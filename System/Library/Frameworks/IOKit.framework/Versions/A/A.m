uint64_t __IOHIDCFArrayFunctionApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

kern_return_t iokit_user_client_trap(void *a1, uint32_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(IOKIT_USER_CLIENT_TRAP, a1, a2, a3, a4, a5, a6, a7, a8);
}

IOReturn IODataQueueDequeue(IODataQueueMemory *dataQueue, void *data, uint32_t *dataSize)
{
  return __IODataQueueDequeue(dataQueue, 0, data, dataSize);
}

id IOHIDSessionFilterFilterEventToConnection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t SenderID;
  void *v8;
  id v9;
  const char *v10;
  NSObject *v12;
  int Type;
  uint64_t UUID;
  uint64_t v15;
  _DWORD v16[2];
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  SenderID = a3;
  v23 = *MEMORY[0x1E0C80C00];
  v8 = *(void **)(a1 + 56);
  v9 = (id)a4;
  if (v8)
  {
    v10 = *(const char **)(a1 + 120);
    v9 = (id)a4;
    if (v10)
      v9 = objc_msgSend(v8, v10, a4, a2, a3);
  }
  if (!v9)
  {
    if (*(_BYTE *)(a1 + 48))
    {
      v12 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        Type = IOHIDEventGetType(a4);
        if (SenderID)
          SenderID = _IOHIDServiceGetSenderID(SenderID);
        UUID = IOHIDEventSystemConnectionGetUUID(a2);
        v15 = *(_QWORD *)(a1 + 32);
        v16[0] = 67109890;
        v16[1] = Type;
        v17 = 2048;
        v18 = SenderID;
        v19 = 2112;
        v20 = UUID;
        v21 = 2112;
        v22 = v15;
        _os_log_impl(&dword_18AAAF000, v12, OS_LOG_TYPE_INFO, "Event filtered type:%d service:0x%llx connection:%@ session filter:%@", (uint8_t *)v16, 0x26u);
      }
    }
  }
  return v9;
}

uint64_t _IOHIDObjectExtRetainCount(uint64_t a1, unsigned int *a2)
{
  return _IOHIDObjectRetainCount(a1, a2, 0);
}

uint64_t IOHIDEventGetAttributeDataLength(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t IOHIDEventGetChildren(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

kern_return_t IOConnectTrap3(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, (void *)p3, 0, 0, 0);
}

const void *_IOHIDObjectInternalRetainCallback(uint64_t a1, const void *a2)
{
  return _IOHIDObjectInternalRetain(a2);
}

uint64_t _IOHIDObjectInternalReleaseCallback(uint64_t a1, const void *a2)
{
  return _IOHIDObjectInternalRelease(a2);
}

uint64_t IOHIDEventGetAttributeDataPtr(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

id __FilterFunctionSetPropertyForClient(void *a1, uint64_t *a2)
{
  return IOHIDServiceFilterSetPropertyForClient(a1, *a2, a2[1], a2[2]);
}

id __FilterFunctionSetPropertyForClient_0(void *a1, uint64_t a2)
{
  return IOHIDSessionFilterSetPropertyForClient(a1, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16));
}

kern_return_t IOConnectTrap1(io_connect_t connect, uint32_t index, uintptr_t p1)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, 0, 0, 0, 0, 0);
}

uint64_t __IOHIDEventSystemFilterEventServiceUnregister(uint64_t a1, const void *a2)
{
  return _IOHIDServiceRemoveConnection(a1, a2, 1);
}

uint64_t __RemoveServiceConnectionPropertyFunction(uint64_t a1, uint64_t a2, const void *a3)
{
  return _IOHIDServiceRemovePropertiesForClient(a2, a3);
}

BOOL _IOHIDEventSystemConnectionContainsService(uint64_t a1, const void *a2)
{
  _BOOL8 v4;

  os_unfair_recursive_lock_lock_with_options();
  v4 = CFSetContainsValue(*(CFSetRef *)(a1 + 80), a2) != 0;
  os_unfair_recursive_lock_unlock();
  return v4;
}

const __CFDictionary *_IOHIDServiceClientRefresh(CFDictionaryRef *a1)
{
  const __CFDictionary *result;
  const void *Value;
  const void *v4;
  const void *v5;

  result = (const __CFDictionary *)os_unfair_recursive_lock_lock_with_options();
  if (a1)
  {
    result = a1[12];
    if (result)
    {
      Value = CFDictionaryGetValue(result, CFSTR("ReportInterval"));
      if (Value)
      {
        v4 = Value;
        os_unfair_recursive_lock_unlock();
        IOHIDServiceClientSetProperty((IOHIDServiceClientRef)a1, CFSTR("ReportInterval"), v4);
        os_unfair_recursive_lock_lock_with_options();
      }
      v5 = CFDictionaryGetValue(a1[12], CFSTR("BatchInterval"));
      result = (const __CFDictionary *)os_unfair_recursive_lock_unlock();
      if (v5)
        return (const __CFDictionary *)IOHIDServiceClientSetProperty((IOHIDServiceClientRef)a1, CFSTR("BatchInterval"), v5);
    }
  }
  return result;
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  __CFDictionary *v6;

  if (!CFEqual(key, CFSTR("ReportInterval")) && !CFEqual(key, CFSTR("BatchInterval")))
    goto LABEL_5;
  os_unfair_recursive_lock_lock_with_options();
  v6 = (__CFDictionary *)*((_QWORD *)service + 12);
  if (v6)
  {
    CFDictionarySetValue(v6, key, property);
    os_unfair_recursive_lock_unlock();
LABEL_5:
    LOBYTE(v6) = _IOHIDEventSystemClientSetPropertyForService(*((_QWORD *)service + 1), service, (void *)key, (void *)property);
  }
  return v6;
}

_QWORD *__FilterFunctionFilterEvent(_QWORD *result, _QWORD **a2)
{
  _QWORD *v3;

  v3 = *a2;
  if (v3)
  {
    result = IOHIDServiceFilterFilterEvent((uint64_t)result, v3);
    *a2 = result;
  }
  return result;
}

_QWORD *__FilterFunctionFilterEvent_0(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a2 + 16);
  if (v2)
  {
    result = IOHIDSessionFilterFilterEvent((uint64_t)result, *(_QWORD *)(a2 + 8), v2);
    *(_QWORD *)(a2 + 16) = result;
  }
  return result;
}

_QWORD *IOHIDSessionFilterFilterEvent(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t (*v7)(void);
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const __CFString *v11;
  NSObject *v12;
  int Type;
  uint64_t SenderID;
  uint64_t v15;
  _DWORD v17[2];
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  const __CFString *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 16);
  if (v6 && (v7 = *(uint64_t (**)(void))(*(_QWORD *)v6 + 32)) != 0
    || (v8 = *(_QWORD *)(a1 + 24)) != 0 && (v7 = *(uint64_t (**)(void))(*(_QWORD *)v8 + 32)) != 0)
  {
    v9 = v7();
    goto LABEL_6;
  }
  v9 = (uint64_t)a3;
  if (!*(_QWORD *)(a1 + 56)
    || (v10 = objc_msgSend(*(id *)(a1 + 56), *(SEL *)(a1 + 80), a3, a2), v9 = (uint64_t)a3, v10 == a3))
  {
LABEL_6:
    v10 = (_QWORD *)v9;
    if (v9)
      return v10;
    goto LABEL_7;
  }
  CFRelease(a3);
  if (v10)
  {
    CFRetain(v10);
    return v10;
  }
LABEL_7:
  if (*(_BYTE *)(a1 + 48))
  {
    v11 = _IOHIDEventDebugInfo(a3);
    v12 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      Type = IOHIDEventGetType((uint64_t)a3);
      if (a2)
        SenderID = _IOHIDServiceGetSenderID(a2);
      else
        SenderID = 0;
      v15 = *(_QWORD *)(a1 + 32);
      v17[0] = 67109890;
      v17[1] = Type;
      v18 = 2048;
      v19 = SenderID;
      v20 = 2112;
      v21 = v11;
      v22 = 2112;
      v23 = v15;
      _os_log_impl(&dword_18AAAF000, v12, OS_LOG_TYPE_INFO, "Event filtered type:%d service:0x%llx eventInfo:(%@) session filter:%@", (uint8_t *)v17, 0x26u);
    }
    CFRelease(v11);
  }
  return 0;
}

id IOHIDServiceFilterFilterEvent(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t v6;
  id result;
  void *v8;
  const __CFString *v9;
  NSObject *v10;
  int Type;
  uint64_t SenderID;
  uint64_t v13;
  _DWORD v14[2];
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  const __CFString *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 16);
  if (v4 && (v5 = *(uint64_t (**)(void))(*(_QWORD *)v4 + 40)) != 0
    || (v6 = *(_QWORD *)(a1 + 24)) != 0 && (v5 = *(uint64_t (**)(void))(*(_QWORD *)v6 + 40)) != 0)
  {
    result = (id)v5();
    if (result)
      return result;
  }
  else
  {
    v8 = *(void **)(a1 + 96);
    if (v8)
    {
      result = objc_msgSend(v8, *(SEL *)(a1 + 120), a2);
      if (result)
        return result;
    }
  }
  v9 = _IOHIDEventDebugInfo(a2);
  v10 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    Type = IOHIDEventGetType((uint64_t)a2);
    SenderID = _IOHIDServiceGetSenderID(*(_QWORD *)(a1 + 48));
    v13 = *(_QWORD *)(a1 + 88);
    v14[0] = 67109890;
    v14[1] = Type;
    v15 = 2048;
    v16 = SenderID;
    v17 = 2112;
    v18 = v9;
    v19 = 2112;
    v20 = v13;
    _os_log_impl(&dword_18AAAF000, v10, OS_LOG_TYPE_INFO, "Event filtered type:%d sender:0x%llx eventInfo:(%@) service filter:%@", (uint8_t *)v14, 0x26u);
  }
  CFRelease(v9);
  return 0;
}

uint64_t _IOHIDServiceRemovePropertiesForClient(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v6, v7);
  ++**(_DWORD **)(a1 + 72);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 240), a2);
  v4 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v4)
  {
    --*(_DWORD *)v4;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v6, v7);
  }
  return __IOHIDServiceUpdateIntervals(a1, (uint64_t)a2);
}

uint64_t IOCFSerializeBinaryCFArraySetFunction(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = *a2;
  v4 = a2[1] + 1;
  a2[1] = v4;
  *(_BYTE *)(v3 + 16) = v4 == a2[2];
  result = DoCFSerializeBinary();
  *((_BYTE *)a2 + 24) &= result;
  return result;
}

_QWORD *__hid_dispatch_queue_did_execute(NSObject *a1)
{
  _QWORD *result;
  uint64_t (*v3)(_QWORD, NSObject *);

  result = dispatch_queue_get_specific(a1, &sHIDExecutionCallbacksKey);
  if (result)
  {
    v3 = (uint64_t (*)(_QWORD, NSObject *))result[1];
    if (v3)
      return (_QWORD *)v3(result[2], a1);
  }
  return result;
}

_QWORD *__hid_dispatch_queue_will_execute(NSObject *a1)
{
  _QWORD *result;

  result = dispatch_queue_get_specific(a1, &sHIDExecutionCallbacksKey);
  if (result)
  {
    if (*result)
      return (_QWORD *)((uint64_t (*)(_QWORD, NSObject *))*result)(result[2], a1);
  }
  return result;
}

void __IOHIDServiceComparePropertyFunction(const void *a1, const void *a2, uint64_t a3)
{
  CFTypeID v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  int v10;
  const __CFDictionary *ValueAtIndex;
  CFTypeID TypeID;
  const __CFDictionary *v13;
  uint64_t v14;
  const void *v15;

  if (!*(_DWORD *)(a3 + 8))
    return;
  if (CFEqual(a1, CFSTR("DeviceUsagePairs")))
  {
    v6 = CFGetTypeID(a2);
    if (v6 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)a2);
      if (Count < 1)
      {
        v10 = 0;
      }
      else
      {
        v8 = Count;
        v9 = 0;
        v10 = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a2, v9);
          TypeID = CFDictionaryGetTypeID();
          if (ValueAtIndex)
          {
            if (CFGetTypeID(ValueAtIndex) == TypeID)
              v13 = ValueAtIndex;
            else
              v13 = 0;
          }
          else
          {
            v13 = 0;
          }
          v10 |= __IOHIDServiceCompareUsagePair(*(_QWORD *)a3, v13);
          ++v9;
        }
        while (v8 != v9);
      }
      *(_DWORD *)(a3 + 8) = v10;
      return;
    }
  }
  if (CFEqual(a1, CFSTR("DeviceUsagePage")))
  {
    *(_DWORD *)(a3 + 8) = __IOHIDServiceCompareUsagePair(*(_QWORD *)a3, *(CFDictionaryRef *)(a3 + 16));
    return;
  }
  if (!CFEqual(a1, CFSTR("DeviceUsage")))
  {
    if (CFEqual(a1, CFSTR("Built-In")))
    {
      if (*(_DWORD *)(*(_QWORD *)a3 + 284) == CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
        return;
      goto LABEL_18;
    }
    if (CFEqual(a1, CFSTR("Hidden")))
    {
      if (!CFEqual(a2, CFSTR("*")))
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(*(_QWORD *)a3 + 300) == CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    }
    else
    {
      if (!a2)
        return;
      v14 = _IOHIDServiceCopyPropertyForClient(*(_QWORD *)a3, a1, (const void *)*MEMORY[0x1E0C9B0D0]);
      if (!v14)
      {
LABEL_18:
        *(_DWORD *)(a3 + 8) = 0;
        return;
      }
      v15 = (const void *)v14;
      if (!CFEqual(a2, CFSTR("*")))
        *(_DWORD *)(a3 + 8) = CFEqual(a2, v15);
      CFRelease(v15);
    }
  }
}

uint64_t __IOHIDServiceCompareUsagePair(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  CFTypeID v9;
  int v10;
  int v12;
  int valuePtr;

  v12 = -1;
  valuePtr = -1;
  if (!theDict)
    return 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DeviceUsagePage"));
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == CFNumberGetTypeID())
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
  }
  v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DeviceUsage"));
  if (v7 && (v8 = v7, v9 = CFGetTypeID(v7), v9 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(v8, kCFNumberSInt32Type, &v12);
    v10 = v12;
  }
  else
  {
    v10 = -1;
  }
  return IOHIDServiceConformsTo(a1, valuePtr, v10);
}

uint64_t IOHIDServiceConformsTo(uint64_t a1, int a2, int a3)
{
  const void *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  CFTypeID v7;
  NSObject *v8;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  _DWORD context[3];
  CFRange v17;

  context[0] = 0;
  context[1] = a2;
  context[2] = a3;
  v4 = (const void *)*MEMORY[0x1E0C9B0D0];
  v5 = (const __CFArray *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("DeviceUsagePairs"), (const void *)*MEMORY[0x1E0C9B0D0]);
  v6 = v5;
  if (v5)
  {
    v7 = CFGetTypeID(v5);
    if (v7 == CFArrayGetTypeID())
    {
      v17.length = CFArrayGetCount(v6);
      v17.location = 0;
      CFArrayApplyFunction(v6, v17, (CFArrayApplierFunction)__IOHIDServiceConformsToFunction, context);
LABEL_12:
      CFRelease(v6);
      return context[0];
    }
    v8 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      IOHIDServiceConformsTo_cold_1();
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v10 = Mutable;
    v11 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("PrimaryUsagePage"), v4);
    if (v11)
    {
      v12 = v11;
      CFDictionarySetValue(v10, CFSTR("DeviceUsagePage"), v11);
      CFRelease(v12);
      v13 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("PrimaryUsage"), v4);
      if (v13)
      {
        v14 = v13;
        CFDictionarySetValue(v10, CFSTR("DeviceUsage"), v13);
        CFRelease(v14);
        __IOHIDServiceConformsToFunction(v10, context);
      }
    }
    CFRelease(v10);
  }
  if (v6)
    goto LABEL_12;
  return context[0];
}

uint64_t __SetPropertyForObjectFunction(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  uint64_t result;

  v4 = CFGetTypeID(a1);
  result = IOHIDServiceGetTypeID();
  if (v4 == result)
  {
    result = _IOHIDServiceSetPropertyForClient((uint64_t)a1, *(const void **)a2, *(const void **)(a2 + 8), *(CFTypeRef *)(a2 + 24));
    if ((_DWORD)result)
      *(_BYTE *)(a2 + 16) = 1;
  }
  return result;
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  int *v6;
  uint64_t v8;
  int v9;

  v9 = 0;
  v8 = 0;
  v6 = (int *)&IOConnectCallMethod_zero;
  if (outputCnt)
    v6 = (int *)outputCnt;
  return io_connect_method(connection, selector, (int)input, inputCnt, 0, 0, 0, 0, 0, &v9, output, v6, 0, &v8);
}

uint64_t ServiceClientFunctionRemove(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t result;

  for (i = 0; i != 3; ++i)
    result = _IOHIDServiceRemoveConnection(a1, *(const void **)(a2 + 8), i);
  return result;
}

uint64_t ServiceDictClientFunctionRemove(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int i;
  uint64_t result;

  for (i = 0; i != 3; ++i)
    result = _IOHIDServiceRemoveConnection(a2, *(const void **)(a3 + 8), i);
  return result;
}

uint64_t _IOHIDServiceRemoveConnection(uint64_t result, const void *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  const __CFAllocator *v7;
  const __CFSet *v8;
  const __CFArray *v9;
  __CFSet *MutableCopy;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const void *ValueAtIndex;
  void *v15;
  const char *v16;
  const __CFArray *v17;
  _QWORD v18[5];
  uint64_t v19;
  _OWORD v20[5];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a3 > 2)
    return result;
  v5 = result;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(result + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v19, v20);
  ++**(_DWORD **)(v5 + 72);
  if (*(_QWORD *)(*(_QWORD *)(v5 + 368) + 8 * a3))
  {
    v6 = a3;
    v7 = CFGetAllocator((CFTypeRef)v5);
    v8 = *(const __CFSet **)(*(_QWORD *)(v5 + 368) + 8 * a3);
    if (a3 != 1)
    {
      MutableCopy = CFSetCreateMutableCopy(v7, 0, v8);
      CFSetRemoveValue(MutableCopy, a2);
LABEL_14:
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(v5 + 368) + 8 * v6));
      *(_QWORD *)(*(_QWORD *)(v5 + 368) + 8 * v6) = MutableCopy;
      v15 = *(void **)(v5 + 480);
      if (v15)
      {
        v16 = *(const char **)(v5 + 560);
        if (v16)
          objc_msgSend(v15, v16, a2, 0);
      }
      v17 = *(const __CFArray **)(v5 + 256);
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 0x40000000;
      v18[2] = ___IOHIDServiceRemoveConnection_block_invoke;
      v18[3] = &__block_descriptor_tmp_92;
      v18[4] = a2;
      _IOHIDCFArrayApplyBlock(v17, v18);
      goto LABEL_18;
    }
    v9 = CFArrayCreateMutableCopy(v7, 0, v8);
    if (v9)
    {
      MutableCopy = v9;
      Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        v12 = Count;
        v13 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, v13);
          if (ValueAtIndex)
          {
            if (ValueAtIndex == a2)
              break;
          }
          if (v12 == ++v13)
            goto LABEL_14;
        }
        CFArrayRemoveValueAtIndex(MutableCopy, v13);
      }
      goto LABEL_14;
    }
  }
LABEL_18:
  result = *(_QWORD *)(v5 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v19, v20);
  }
  return result;
}

HIDServiceClient *_IOHIDServiceClientCreate(const __CFAllocator *a1, const void *a2, const __CFDictionary *a3, __IOHIDEventSystemClient *a4)
{
  HIDServiceClient *Private;
  HIDServiceClient *v9;

  if (_IOHIDServiceClientCreate_onceToken == -1)
  {
    if (a2)
      goto LABEL_3;
    return 0;
  }
  dispatch_once(&_IOHIDServiceClientCreate_onceToken, &__block_literal_global_12);
  if (!a2)
    return 0;
LABEL_3:
  Private = _IOHIDServiceClientCreatePrivate();
  v9 = Private;
  if (Private)
  {
    Private->_client.system = a4;
    Private->_client.serviceID = (void *)CFRetain(a2);
    v9->_client.cachedProperties = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v9->_client.serviceLock = 0;
    v9->_client.callbackLock = 0;
    _IOHIDServiceClientCacheProperties((uint64_t)v9, a3);
  }
  return v9;
}

HIDServiceClient *_IOHIDServiceClientCreatePrivate()
{
  return objc_alloc_init(HIDServiceClient);
}

void _IOHIDServiceClientCacheProperties(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID v6;
  int v7;
  const __CFNumber *v8;
  const __CFNumber *v9;
  CFTypeID v10;
  int v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFTypeID v14;
  uint64_t v15;
  void *v16;
  uint64_t *v17;
  _QWORD v18[6];
  uint64_t valuePtr;
  uint64_t *p_valuePtr;
  uint64_t v21;
  int Count;

  if (theDict)
  {
    LODWORD(valuePtr) = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("PrimaryUsagePage"));
    if (Value && (v5 = Value, v6 = CFGetTypeID(Value), v6 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
      v7 = valuePtr;
    }
    else
    {
      v7 = 0;
    }
    *(_DWORD *)(a1 + 128) = v7;
    LODWORD(valuePtr) = 0;
    v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("PrimaryUsage"));
    if (v8 && (v9 = v8, v10 = CFGetTypeID(v8), v10 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
      v11 = valuePtr;
    }
    else
    {
      v11 = 0;
    }
    *(_DWORD *)(a1 + 132) = v11;
    v12 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("DeviceUsagePairs"));
    if (v12)
    {
      v13 = v12;
      v14 = CFGetTypeID(v12);
      if (v14 == CFArrayGetTypeID())
      {
        valuePtr = 0;
        p_valuePtr = &valuePtr;
        v21 = 0x2000000000;
        Count = 0;
        Count = CFArrayGetCount(v13);
        v15 = *((unsigned int *)p_valuePtr + 6);
        if ((_DWORD)v15)
        {
          v16 = malloc_type_calloc(1uLL, 8 * v15, 0x100004000313F17uLL);
          *(_QWORD *)(a1 + 136) = v16;
          if (v16)
          {
            v17 = p_valuePtr;
            *(_DWORD *)(a1 + 144) = *((_DWORD *)p_valuePtr + 6);
            *((_DWORD *)v17 + 6) = 0;
            v18[0] = MEMORY[0x1E0C809B0];
            v18[1] = 0x40000000;
            v18[2] = ___IOHIDServiceClientCacheProperties_block_invoke;
            v18[3] = &unk_1E2003378;
            v18[4] = &valuePtr;
            v18[5] = a1;
            _IOHIDCFArrayApplyBlock(v13, v18);
          }
        }
        _Block_object_dispose(&valuePtr, 8);
      }
    }
  }
}

void __EnqueueEventFunction(const void *a1, uint64_t *a2)
{
  uint64_t v4;
  const __CFArray *Filters;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (a2)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v4 = *a2;
    v10 = a2[1];
    Filters = *(const __CFArray **)(a2[2] + 128);
    if (Filters)
      Filters = (const __CFArray *)IOHIDSessionGetFilters((uint64_t)Filters);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = ____EnqueueEventFunction_block_invoke;
    v6[3] = &unk_1E2002908;
    v6[4] = &v7;
    v6[5] = a1;
    v6[6] = v4;
    _IOHIDCFArrayApplyBlock(Filters, v6);
    if (v8[3] && __IOHIDEventSystemIsTimeToDispatchEvent(a1, *a2, (_QWORD *)a2[1]))
      _IOHIDEventSystemConnectionDispatchEvent((uint64_t)a1, (_QWORD *)a2[1]);
  }
  else
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = 0;
  }
  _Block_object_dispose(&v7, 8);
}

void _IOHIDCFArrayApplyBlock(const __CFArray *a1, void *a2)
{
  CFRange v4;

  v4.length = CFArrayGetCount(a1);
  v4.location = 0;
  CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)__IOHIDCFArrayFunctionApplier, a2);
}

uint64_t IOHIDSessionGetFilters(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

uint64_t _IOHIDEventSystemConnectionDispatchEvent(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  _QWORD *Event;

  if (!a1)
    return 3758097084;
  if (!*(_DWORD *)(a1 + 256))
    return IOHIDEventSystemConnectionDispatchEvent(a1, (uint64_t)a2);
  if (!IOHIDEventConformsTo((uint64_t)a2, 17) && !IOHIDEventConformsTo((uint64_t)a2, 11))
  {
    if (!IOHIDEventConformsTo((uint64_t)a2, 3))
      return IOHIDEventSystemConnectionDispatchEvent(a1, (uint64_t)a2);
    Event = (_QWORD *)IOHIDEventGetEvent(a2, 3);
    if (!Event || IOHIDEventGetIntegerValue(Event, 0x30000u) != 7)
      return IOHIDEventSystemConnectionDispatchEvent(a1, (uint64_t)a2);
  }
  result = 0;
  ++*(_DWORD *)(a1 + 288);
  return result;
}

HIDEvent *IOHIDEventCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  HIDEvent *v7;

  if (a2 > 0x2A)
    v6 = 0;
  else
    v6 = qword_18AB46EE0[(int)a2];
  v7 = _IOHIDEventCreate(a1, v6, a2, a3, a4);
  if (v7)
  {
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      a3 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(a3);
    }
    v7->_event.timeStamp = a3;
  }
  return v7;
}

void __IOHIDEventSystemClientQueueCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const void *v5;
  unsigned int *v6;
  unsigned int *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t SenderID;
  const void *Service;
  uint64_t TimeStampOfType;
  uint64_t Type;
  unsigned int TimeStampType;
  unint64_t Latency;
  char v17;
  uint64_t v18;

  if (a4)
  {
    os_unfair_recursive_lock_lock_with_options();
    v5 = *(const void **)(a4 + 272);
    if (v5)
    {
      CFRetain(*(CFTypeRef *)(a4 + 272));
      os_unfair_recursive_lock_unlock();
      os_unfair_recursive_lock_lock_with_options();
      if (*(_QWORD *)(a4 + 200) || *(_QWORD *)(a4 + 208))
      {
        v6 = IOHIDEventQueueDequeueCopy((uint64_t)v5);
        if (v6)
        {
          v7 = v6;
          v8 = 0;
          v9 = 0;
          v10 = 0;
          do
          {
            SenderID = IOHIDEventGetSenderID((uint64_t)v7);
            Service = __IOHIDEventSystemClientGetService(a4, SenderID);
            TimeStampOfType = IOHIDEventGetTimeStampOfType((uint64_t)v7, 2);
            Type = IOHIDEventGetType((uint64_t)v7);
            TimeStampType = IOHIDEventGetTimeStampType((uint64_t)v7);
            _IOHIDDebugTrace(8224, 0, TimeStampOfType, Type, (uint64_t)Service, TimeStampType);
            Latency = IOHIDEventGetLatency((uint64_t)v7, 1u);
            if (Latency > v10)
              v10 = Latency;
            v17 = IOHIDEventGetType((uint64_t)v7);
            v18 = *(_QWORD *)(a4 + 208);
            if (v18)
              (*(void (**)(uint64_t, _QWORD, _QWORD, const void *, unsigned int *))(v18 + 16))(v18, *(_QWORD *)(a4 + 216), *(_QWORD *)(a4 + 224), Service, v7);
            else
              (*(void (**)(_QWORD, _QWORD, const void *, unsigned int *))(a4 + 200))(*(_QWORD *)(a4 + 216), *(_QWORD *)(a4 + 224), Service, v7);
            v9 |= 1 << v17;
            CFRelease(v7);
            v7 = IOHIDEventQueueDequeueCopy((uint64_t)v5);
            ++v8;
          }
          while (v7);
        }
        else
        {
          v10 = 0;
          v9 = 0;
          v8 = 0;
        }
        os_unfair_recursive_lock_unlock();
        CFRelease(v5);
        os_unfair_recursive_lock_lock_with_options();
        if (v10 > *(_QWORD *)(a4 + 480))
          *(_QWORD *)(a4 + 480) = v10;
        gettimeofday((timeval *)(a4 + 464), 0);
        *(_DWORD *)(a4 + 148) += v8;
        *(_QWORD *)(a4 + 152) |= v9;
      }
    }
    os_unfair_recursive_lock_unlock();
  }
}

uint64_t IOHIDEventGetSenderID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

unsigned int *IOHIDEventQueueDequeueCopy(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  unsigned int *v6;
  CFAllocatorRef v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v16 = 0;
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_DWORD *)(a1 + 144))
  {
    v2 = *(_QWORD *)(a1 + 16);
    v3 = *(_DWORD *)(v2 + 4);
    v4 = *(_DWORD *)(v2 + 8);
    if (v2)
    {
      if (v4 != *(_DWORD *)(a1 + 36))
        __IOHIDEventQueueUpdateUsageAnalytics(a1);
      *(_DWORD *)(a1 + 32) = v3;
      *(_DWORD *)(a1 + 36) = v4;
    }
  }
  v5 = *(_QWORD *)(a1 + 16);
  if (v5)
  {
    v6 = _IODataQueuePeek(*(unsigned int **)(a1 + 16), *(unsigned int *)(a1 + 56), &v16);
    if (v6)
    {
      v7 = CFGetAllocator((CFTypeRef)a1);
      v6 = (unsigned int *)IOHIDEventCreateWithBytesInternal(v7, v6 + 1, v16);
      if (!v6)
      {
        v8 = _IOHIDLog();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          IOHIDEventQueueDequeueCopy_cold_1((uint64_t)&v16, v8, v9, v10, v11, v12, v13, v14);
      }
      _IODataQueueDequeue(v5, *(_DWORD *)(a1 + 56), 0);
    }
  }
  else
  {
    v6 = 0;
  }
  os_unfair_recursive_lock_unlock();
  return v6;
}

uint64_t __IODataQueueDequeue(_DWORD *a1, uint64_t a2, void *__dst, _DWORD *a4)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  unsigned int *v9;
  unint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v17;

  result = 3758097090;
  if (a1 && (!__dst || a4))
  {
    v7 = a1[1];
    v8 = atomic_load(a1 + 2);
    if ((_DWORD)v7 == v8)
      return 3758097127;
    if (!a2)
      LODWORD(a2) = *a1;
    if (v7 > a2)
      return 3758097084;
    v9 = a1 + 3;
    if (v7 >= 0xFFFFFFFC)
    {
      v10 = a2;
      goto LABEL_19;
    }
    v10 = a2;
    if (v7 + 4 > (unint64_t)a2
      || ((v11 = (unsigned int *)((char *)v9 + v7),
           v12 = *(unsigned int *)((char *)v9 + v7),
           v13 = (v12 + v7) + 4,
           v7 + 4 <= (unint64_t)~(_DWORD)v12)
        ? (v14 = v13 > a2)
        : (v14 = 1),
          v14))
    {
LABEL_19:
      v12 = *v9;
      if (v12 <= 0xFFFFFFFB)
      {
        LODWORD(v13) = v12 + 4;
        result = 3758097084;
        if (v12 + 4 > v10)
          return result;
        if (!__dst)
          goto LABEL_25;
        goto LABEL_22;
      }
      return 3758097084;
    }
    if (v12 > 0xFFFFFFFB)
      return 3758097084;
    v15 = ~(_DWORD)v7;
    v16 = v12 + 4 + v7;
    v17 = v12 + 4 > v15 || v16 > a2;
    result = 3758097084;
    if (!v17)
    {
      v9 = v11;
      if (!__dst)
      {
LABEL_25:
        atomic_store(v13, a1 + 1);
        result = 0;
        if (v8 == (_DWORD)v13)
          __dmb(0xBu);
        return result;
      }
LABEL_22:
      if (v12 > *a4)
        return 3758097115;
      memcpy(__dst, v9 + 1, v12);
      *a4 = v12;
      goto LABEL_25;
    }
  }
  return result;
}

IODataQueueEntry *__cdecl IODataQueuePeek(IODataQueueMemory *dataQueue)
{
  uint64_t v2;

  return (IODataQueueEntry *)__IODataQueuePeek(&dataQueue->queueSize, 0, &v2);
}

unsigned int *__IODataQueuePeek(unsigned int *result, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int *v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;

  if (result)
  {
    v3 = result[1];
    v4 = atomic_load(result + 2);
    if ((_DWORD)v3 == v4)
      return 0;
    if (!a2)
      LODWORD(a2) = *result;
    if (v3 > a2)
      return 0;
    v5 = result + 3;
    if (v3 < 0xFFFFFFFC)
    {
      result = (unsigned int *)((char *)v5 + v3);
      v7 = *(unsigned int *)((char *)v5 + v3);
      v6 = a2;
      v8 = v3 + 4 > (unint64_t)a2 || v3 + 4 > (unint64_t)~(_DWORD)v7;
      v9 = (v7 + v3) + 4;
      if (!v8 && v9 <= a2)
      {
        if (!a3)
          return result;
        v5 = result;
        goto LABEL_23;
      }
    }
    else
    {
      v6 = a2;
    }
    result = 0;
    v7 = *v5;
    if (v7 > 0xFFFFFFFB)
      return result;
    if (v7 + 4 > v6)
      return result;
    result = v5;
    if (!a3)
      return result;
LABEL_23:
    *a3 = v7;
    return v5;
  }
  return result;
}

HIDEvent *_IOHIDEventCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return -[HIDEvent initWithSize:type:timestamp:options:](+[HIDEvent allocWithZone:](HIDEvent, "allocWithZone:", a1), "initWithSize:type:timestamp:options:", a2, a3, a4, a5);
}

void IOHIDEventSetAttributeData(uint64_t a1, const void *a2, int64_t a3)
{
  void *v6;
  uint64_t v7;
  size_t v8;
  void *v9;

  v6 = *(void **)(a1 + 40);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 88) = 0;
  }
  if (a2 && a3)
  {
    if (a3 <= 0)
      v7 = -(-a3 & 3);
    else
      v7 = a3 & 3;
    v8 = a3 - v7 + 4;
    v9 = malloc_type_malloc(v8, 0x18D82F27uLL);
    *(_QWORD *)(a1 + 40) = v9;
    if (v9)
    {
      bzero(v9, v8);
      memmove(*(void **)(a1 + 40), a2, a3);
      *(_QWORD *)(a1 + 88) = v8;
    }
  }
}

void IOHIDEventAppendEvent(uint64_t a1, _QWORD *value)
{
  __CFArray *Mutable;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  Mutable = *(__CFArray **)(a1 + 72);
  if (Mutable
    || (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]),
        (*(_QWORD *)(a1 + 72) = Mutable) != 0))
  {
    value[10] = a1;
    v5 = value[13];
    v6 = *(_DWORD *)(v5 + 4);
    v7 = a1;
    do
    {
      *(_QWORD *)(v7 + 24) |= 1 << v6;
      v7 = *(_QWORD *)(v7 + 80);
    }
    while (v7);
    if (v6 == 11)
    {
      v8 = *(_QWORD *)(a1 + 104);
      if (*(_DWORD *)(v8 + 4) == 11)
        *(_DWORD *)(v8 + 44) |= *(_DWORD *)(v5 + 40);
    }
    CFArrayAppendValue(Mutable, value);
  }
}

const void *__IOHIDEventSystemClientGetService(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  const void *Value;
  uint64_t valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v3)
    return 0;
  v4 = v3;
  os_unfair_recursive_lock_lock_with_options();
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), v4);
  os_unfair_recursive_lock_unlock();
  CFRelease(v4);
  return Value;
}

void __IOHIDSessionDispatchEvent(uint64_t a1, void *a2)
{
  uint64_t TimeStampOfType;
  unsigned int TimeStampType;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, CFTypeRef, CFTypeRef);
  uint64_t v8;
  CFTypeRef v9;
  uint64_t v10;
  unsigned int v11;
  const __CFArray *v12;
  uint64_t v13;
  unsigned int v14;
  CFTypeRef v15;
  uint64_t v16;
  int *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t context;
  CFTypeRef v25;
  CFTypeRef cf;
  _OWORD v27[5];
  uint64_t v28;
  CFRange v29;

  v28 = *MEMORY[0x1E0C80C00];
  context = 0;
  v25 = 0;
  cf = 0;
  if (!a1)
    goto LABEL_28;
  TimeStampOfType = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  TimeStampType = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8273, 0, TimeStampOfType, TimeStampType, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v23, v27);
  ++**(_DWORD **)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(void (**)(uint64_t, uint64_t, CFTypeRef, CFTypeRef))(a1 + 16);
  v8 = *(_QWORD *)(a1 + 24);
  v9 = _IOHIDEventCopyAttachment((uint64_t)a2, CFSTR("Sender"));
  context = a1;
  v25 = v9;
  cf = CFRetain(a2);
  v10 = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  v11 = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8274, 1, v10, v11, 0, 0);
  v12 = *(const __CFArray **)(a1 + 144);
  v29.length = CFArrayGetCount(v12);
  v29.location = 0;
  CFArrayApplyFunction(v12, v29, (CFArrayApplierFunction)__FilterFunctionFilterEvent_0, &context);
  v13 = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  v14 = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8274, 2, v13, v14, 0, 0);
  v15 = cf;
  if (v9 && cf)
  {
    if (_IOHIDServiceIsInactive((uint64_t)v9) && (IOHIDEventGetEventFlags((uint64_t)cf) & 0x800000) == 0)
    {
      cf = 0;
LABEL_8:
      v16 = *(_QWORD *)(a1 + 32);
      if (*(_DWORD *)v16)
      {
        --*(_DWORD *)v16;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8)))
          __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
      }
      goto LABEL_28;
    }
    v15 = cf;
  }
  if (!v15)
    goto LABEL_8;
  if (IOHIDEventGetPolicy((uint64_t)a2, 3) == 3)
  {
    *(_QWORD *)(a1 + 168) = mach_continuous_time();
    gettimeofday((timeval *)(a1 + 176), 0);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 192), (CFSetApplierFunction)__ActivityFunctionApplier, a2);
  }
  v17 = *(int **)(a1 + 32);
  v18 = *v17;
  if (v7)
  {
    if (v18)
    {
      v19 = *v17;
      do
      {
        v20 = *(_QWORD *)(a1 + 32);
        if (*(_DWORD *)v20)
        {
          --*(_DWORD *)v20;
          if (pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8)))
            __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
        }
        --v19;
      }
      while (v19);
    }
    v7(v6, v8, v25, cf);
    v21 = *(_QWORD *)(a1 + 32);
    if (v18)
    {
      do
      {
        if (pthread_mutex_lock((pthread_mutex_t *)(v21 + 8)))
          __IOHIDSessionCreate_block_invoke_cold_4(&v23, v27);
        v21 = *(_QWORD *)(a1 + 32);
        v22 = *(_DWORD *)v21 + 1;
        *(_DWORD *)v21 = v22;
        --v18;
      }
      while (v18);
      if (!v22)
        goto LABEL_28;
    }
    else
    {
      v22 = *(_DWORD *)v21;
      if (!*(_DWORD *)v21)
        goto LABEL_28;
    }
    *(_DWORD *)v21 = v22 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
    goto LABEL_28;
  }
  if (v18)
  {
    *v17 = v18 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v17 + 2)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
  }
LABEL_28:
  if (cf)
    CFRelease(cf);
  if (v25)
    CFRelease(v25);
}

uint64_t IOHIDEventGetTimeStampOfType(uint64_t a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return IOHIDEventGetTimeStamp(a1);
  v2 = *(_QWORD *)(a1 + 8);
  if (a2 == 1)
  {
    if ((*(_BYTE *)(a1 + 32) & 0x80) == 0 && mach_get_times())
      v2 = 0;
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      return ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v2);
    }
  }
  else if (a2 == 2 && (*(_BYTE *)(a1 + 32) & 0x80) == 0)
  {
    return IOHIDEventGetTimeStamp(a1);
  }
  return v2;
}

void __IOHIDEventSystemEventCallback(uint64_t a1, uint64_t a2, const void *a3, HIDEvent *a4)
{
  uint64_t TimeStampOfType;
  CFTypeID v8;
  const __CFSet *Copy;
  const __CFSet *v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  uint64_t v13;
  unsigned int TimeStampType;
  unsigned int v15;
  int v16;
  CFTypeID v17;
  const __CFArray *v18;
  const __CFArray *v19;
  const __CFAllocator *v20;
  uint64_t v21;
  const __CFSet *v22;
  const __CFSet *v23;
  char v24;
  void (*v25)(uint64_t, uint64_t, const void *, HIDEvent *);
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  const __CFArray *cf;
  _QWORD context[3];
  _QWORD v33[3];
  int v34;
  CFRange v35;

  context[0] = a3;
  context[1] = a4;
  context[2] = a1;
  if (!a1)
    return;
  TimeStampOfType = IOHIDEventGetTimeStampOfType((uint64_t)a4, 2);
  if (a3 && (v8 = CFGetTypeID(a3), v8 == IOHIDServiceGetTypeID()))
  {
    Copy = (const __CFSet *)_IOHIDServiceCopyConnections((uint64_t)a3, 0);
    v10 = (const __CFSet *)_IOHIDServiceCopyConnections((uint64_t)a3, 2);
  }
  else
  {
    os_unfair_recursive_lock_lock_with_options();
    v11 = CFGetAllocator((CFTypeRef)a1);
    Copy = CFSetCreateCopy(v11, *(CFSetRef *)(a1 + 56));
    v12 = CFGetAllocator((CFTypeRef)a1);
    v10 = CFSetCreateCopy(v12, *(CFSetRef *)(a1 + 64));
    os_unfair_recursive_lock_unlock();
  }
  v13 = mach_absolute_time();
  _IOHIDDebugEventAddPerfData(a4, 2, v13);
  TimeStampType = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8211, 1, TimeStampOfType, TimeStampType, 0, 0);
  if (Copy)
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__EnqueueEventFunction, context);
  v15 = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8209, 0, TimeStampOfType, v15, 0, 0);
  if (!a3)
  {
    v34 = 0;
    goto LABEL_15;
  }
  if (_IOHIDServiceHidden((uint64_t)a3))
  {
    v16 = 0;
    goto LABEL_27;
  }
  v34 = 0;
  v17 = CFGetTypeID(a3);
  if (v17 != IOHIDServiceGetTypeID())
  {
LABEL_15:
    v19 = *(const __CFArray **)(a1 + 80);
    if (!v19)
      goto LABEL_20;
    if (!CFArrayGetCount(v19))
      goto LABEL_20;
    os_unfair_recursive_lock_lock_with_options();
    v20 = CFGetAllocator((CFTypeRef)a1);
    v18 = CFArrayCreateCopy(v20, *(CFArrayRef *)(a1 + 80));
    os_unfair_recursive_lock_unlock();
    if (!v18)
      goto LABEL_20;
    goto LABEL_18;
  }
  v18 = (const __CFArray *)_IOHIDServiceCopyConnections((uint64_t)a3, 1);
  if (!v18)
  {
LABEL_20:
    v21 = TimeStampOfType;
    v22 = Copy;
    v23 = v10;
    cf = 0;
    v24 = 1;
    goto LABEL_21;
  }
LABEL_18:
  v33[0] = a3;
  v33[1] = a4;
  v33[2] = &v34;
  v35.length = CFArrayGetCount(v18);
  cf = v18;
  v35.location = 0;
  CFArrayApplyFunction(v18, v35, (CFArrayApplierFunction)__IOHIDEventSystemFilterEventFunction, v33);
  if (!v34)
  {
    v21 = TimeStampOfType;
    v22 = Copy;
    v23 = v10;
    v24 = 0;
LABEL_21:
    os_unfair_recursive_lock_lock_with_options();
    v26 = *(_QWORD *)(a1 + 104);
    v25 = *(void (**)(uint64_t, uint64_t, const void *, HIDEvent *))(a1 + 112);
    v27 = *(_QWORD *)(a1 + 120);
    os_unfair_recursive_lock_unlock();
    if (__IOHIDEventSystemIsTimeToDispatchEvent((const void *)*MEMORY[0x1E0C9B0D0], (uint64_t)a3, a4)
      && v25)
    {
      v25(v26, v27, a3, a4);
    }
    v10 = v23;
    Copy = v22;
    TimeStampOfType = v21;
    if ((v24 & 1) != 0)
      goto LABEL_26;
  }
  CFRelease(cf);
LABEL_26:
  v16 = v34;
LABEL_27:
  v28 = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8210, 0, TimeStampOfType, v16, v28, 0);
  v29 = mach_absolute_time();
  _IOHIDDebugEventAddPerfData(a4, 3, v29);
  if (!v16 && v10)
    CFSetApplyFunction(v10, (CFSetApplierFunction)__EnqueueEventFunction, context);
  v30 = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8211, 2, TimeStampOfType, v30, 0, 0);
  if (Copy)
    CFRelease(Copy);
  if (v10)
    CFRelease(v10);
}

void _IOHIDDebugTrace(__int16 a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v10 = (4 * (a1 & 0x3FFF)) | a2 | 0x5230000u;
  kdebug_trace();
  if ((gIOHIDDebugConfig & 2) != 0)
  {
    if (_IOHIDLogCategory_onceToken != -1)
      dispatch_once(&_IOHIDLogCategory_onceToken, &__block_literal_global_6);
    v11 = qword_1ECD37928;
    if (os_log_type_enabled((os_log_t)qword_1ECD37928, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 134219008;
      v13 = v10;
      v14 = 2048;
      v15 = a3;
      v16 = 2048;
      v17 = a4;
      v18 = 2048;
      v19 = a5;
      v20 = 2048;
      v21 = a6;
      _os_log_impl(&dword_18AAAF000, v11, OS_LOG_TYPE_DEFAULT, "0x%-16llx 0x%-16llx 0x%-16llx 0x%-16llx 0x%-16llx", (uint8_t *)&v12, 0x34u);
    }
  }
}

uint64_t IOHIDEventGetTimeStampType(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 32) >> 7) & 1;
}

uint64_t IOHIDServiceGetTypeID()
{
  return objc_opt_self();
}

HIDEvent *_IOHIDDebugEventAddPerfData(HIDEvent *result, int a2, uint64_t a3)
{
  HIDEvent *v5;
  const __CFArray *Children;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  _QWORD *ValueAtIndex;
  CFAllocatorRef v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _OWORD v16[2];
  uint64_t v17;

  if ((gIOHIDDebugConfig & 0x10) != 0)
  {
    v5 = result;
    if (!IOHIDEventConformsTo((uint64_t)result, 1))
      goto LABEL_10;
    Children = (const __CFArray *)IOHIDEventGetChildren((uint64_t)v5);
    if (!Children)
      goto LABEL_10;
    v7 = Children;
    Count = CFArrayGetCount(Children);
    if (Count < 1)
      goto LABEL_10;
    v9 = Count;
    v10 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v7, v10);
      if (IOHIDEventGetType((uint64_t)ValueAtIndex) == 1
        && IOHIDEventGetIntegerValue(ValueAtIndex, 0x10001u) == 38
        && IOHIDEventGetIntegerValue(ValueAtIndex, 0x10000u) == 65280)
      {
        break;
      }
      if (v9 == ++v10)
        goto LABEL_10;
    }
    if (!ValueAtIndex)
    {
LABEL_10:
      v17 = 0;
      memset(v16, 0, sizeof(v16));
      v12 = CFGetAllocator(v5);
      v13 = mach_absolute_time();
      result = IOHIDEventCreateVendorDefinedEvent((uint64_t)v12, v13, 65280, 38, 0, v16, 0x28uLL, 0);
      if (!result)
        return result;
      ValueAtIndex = &result->super.isa;
      IOHIDEventAppendEvent((uint64_t)v5, result);
      CFRelease(ValueAtIndex);
    }
    v15 = 0;
    *(_QWORD *)&v16[0] = 0;
    result = (HIDEvent *)IOHIDEventGetVendorDefinedData(ValueAtIndex, (uint64_t *)v16, &v15);
    if (*(_QWORD *)&v16[0])
    {
      switch(a2)
      {
        case 1:
          v14 = (_QWORD *)(*(_QWORD *)&v16[0] + 8);
          goto LABEL_18;
        case 2:
          v14 = (_QWORD *)(*(_QWORD *)&v16[0] + 16);
          goto LABEL_18;
        case 3:
          v14 = (_QWORD *)(*(_QWORD *)&v16[0] + 24);
          goto LABEL_18;
        case 4:
          v14 = (_QWORD *)(*(_QWORD *)&v16[0] + 32);
LABEL_18:
          *v14 = a3;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

CFTypeRef _IOHIDServiceCopyConnections(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  CFTypeRef v6;
  uint64_t v8;
  _OWORD v9[5];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a2 > 2)
    return 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  v4 = *(_QWORD *)(a1 + 72);
  v5 = *(_DWORD *)v4 + 1;
  *(_DWORD *)v4 = v5;
  if (*(_QWORD *)(*(_QWORD *)(a1 + 368) + 8 * a2))
  {
    v6 = CFRetain(*(CFTypeRef *)(*(_QWORD *)(a1 + 368) + 8 * a2));
    v4 = *(_QWORD *)(a1 + 72);
    v5 = *(_DWORD *)v4;
    if (!*(_DWORD *)v4)
      return v6;
  }
  else
  {
    v6 = 0;
    if (!v5)
      return v6;
  }
  *(_DWORD *)v4 = v5 - 1;
  if (pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
  return v6;
}

uint64_t _IOHIDServiceHidden(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t IOHIDEventGetPolicy(uint64_t a1, uint64_t a2)
{
  NSObject *v4;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 104) + 10) & 0x80) != 0)
    return 0;
  if (a2 != 3)
  {
    v4 = _IOHIDLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      IOHIDEventGetPolicy_cold_1(a2, v4);
    return 0;
  }
  if ((*(_QWORD *)(a1 + 24) & 0x819CF0DFCLL) != 0)
    return 3;
  else
    return 0;
}

CFTypeRef IOCFUnserializeBinary(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  size_t v5;
  CFMutableDictionaryRef v7;
  _QWORD *v8;
  __CFArray *v9;
  __CFDictionary *v10;
  const __CFString *v11;
  uint64_t v12;
  __CFSet *v13;
  size_t v14;
  double *v15;
  int v16;
  int v17;
  CFIndex v18;
  uint64_t v19;
  __CFSet *v20;
  CFMutableDictionaryRef Mutable;
  _BOOL4 v22;
  uint64_t v23;
  float v24;
  float *v25;
  const __CFAllocator *v26;
  CFNumberType v27;
  CFIndex v28;
  const char *CStringPtr;
  unsigned int v30;
  char *v31;
  uint64_t v32;
  _BOOL4 v33;
  char v34;
  char *v35;
  unsigned int v36;
  const __CFString **v37;
  const __CFString *v38;
  CFTypeID TypeID;
  int v40;
  CFTypeID v41;
  CFTypeID v42;
  CFTypeID v43;
  CFTypeID v44;
  int v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  unsigned int v49;
  int v50;
  const void **v51;
  const void *v52;
  size_t v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *v57;
  uint64_t v58;
  _QWORD *v59;
  _BOOL4 v60;
  int v61;
  const char *v62;
  _QWORD *v63;
  __CFArray *v65;
  __CFDictionary *v66;
  char *__src;
  unint64_t v68;
  const __CFString *v69;
  __CFDictionary *v70;
  __CFArray *v71;
  uint64_t v72;
  _BOOL4 v73;
  const __CFString *v74;
  unsigned int v75;
  const char *v76;
  float v77;

  v5 = bufferSize;
  if (errorString)
    *errorString = 0;
  v7 = 0;
  if (bufferSize < 4 || (buffer & 3) != 0)
    return v7;
  if (*(unsigned __int8 *)buffer == 212)
  {
    v54 = bufferSize >> 2;
    v8 = malloc_type_calloc(bufferSize >> 2, 8uLL, 0xC0040B8AA526DuLL);
  }
  else
  {
    if (strcmp(byte_18AB45C68, buffer))
      return 0;
    v54 = 0;
    v8 = 0;
  }
  v74 = 0;
  v7 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v55 = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v75 = 0;
  v72 = 0;
  __src = 0;
  v62 = buffer;
  v76 = buffer + 4;
  v57 = (const __CFString *)*MEMORY[0x1E0C9AE50];
  v56 = (const __CFString *)*MEMORY[0x1E0C9AE40];
  v60 = v8 != 0;
  v12 = 4;
  v63 = v8;
  v68 = v5;
LABEL_11:
  v13 = v7;
  v70 = v10;
  v71 = v9;
  while (2)
  {
    v69 = v11;
    v14 = v12 + 4;
    if (v12 + 4 > v5)
      goto LABEL_102;
    v7 = 0;
    v15 = (double *)(v76 + 4);
    v16 = *(_DWORD *)v76;
    v17 = *(_DWORD *)v76 & 0x7F000000;
    v18 = *(_DWORD *)v76 & 0xFFFFFFLL;
    v19 = (v18 + 3) >> 2;
    v20 = v13;
    switch((v17 - 0x1000000) >> 24)
    {
      case 0u:
        Mutable = CFDictionaryCreateMutable(allocator, v18, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v65 = 0;
        v7 = 0;
        v73 = v18 != 0;
        v66 = Mutable;
        goto LABEL_17;
      case 1u:
        Mutable = CFArrayCreateMutable(allocator, v18, MEMORY[0x1E0C9B378]);
        v66 = 0;
        v7 = 0;
        v73 = v18 != 0;
        v65 = Mutable;
        goto LABEL_17;
      case 2u:
        Mutable = CFSetCreateMutable(allocator, v18, MEMORY[0x1E0C9B3B0]);
        v7 = Mutable;
        v65 = 0;
        v66 = 0;
        v73 = v18 != 0;
LABEL_17:
        v11 = (const __CFString *)Mutable;
        v22 = v60;
        goto LABEL_36;
      case 3u:
        v14 = v12 + 12;
        if (v12 + 12 > v5)
          goto LABEL_102;
        if ((_DWORD)v18 == 63)
        {
          v11 = (const __CFString *)CFNumberCreate(allocator, kCFNumberFloat64Type, v15);
          v23 = v72;
        }
        else
        {
          v23 = v72;
          if ((_DWORD)v18 == 31)
          {
            v24 = *v15;
            v77 = v24;
            v25 = &v77;
            v26 = allocator;
            v27 = kCFNumberFloat32Type;
          }
          else
          {
            v26 = allocator;
            v27 = v18 > 0x20 ? kCFNumberSInt64Type : kCFNumberSInt32Type;
            v25 = (float *)(v76 + 4);
          }
          v11 = (const __CFString *)CFNumberCreate(v26, v27, v25);
        }
        v65 = 0;
        v66 = 0;
        v7 = 0;
        v73 = 0;
        v22 = 0;
        v15 = (double *)(v76 + 12);
        v30 = v75;
        if (!v11)
          goto LABEL_102;
        goto LABEL_37;
      case 7u:
        if (!(_DWORD)v18)
          goto LABEL_102;
        LODWORD(v18) = v18 - 1;
        goto LABEL_24;
      case 8u:
LABEL_24:
        v14 += 4 * v19;
        if (v14 > v5)
          goto LABEL_102;
        v28 = v18;
        if (v17 == 0x8000000 && *((_BYTE *)v15 + v18))
          goto LABEL_114;
        v11 = CFStringCreateWithBytes(allocator, (const UInt8 *)v15, v18, 0x8000100u, 0);
        if (!v11)
        {
          v11 = CFStringCreateWithBytes(allocator, (const UInt8 *)v15, v28, 0, 0);
          CStringPtr = CFStringGetCStringPtr(v11, 0);
          syslog(3, "FIXME: IOUnserialize has detected a string that is not valid UTF-8, \"%s\".", CStringPtr);
        }
        v65 = 0;
        v66 = 0;
        v7 = 0;
        v73 = 0;
        v22 = 0;
        v15 = (double *)((char *)v15 + 4 * v19);
        v8 = v63;
LABEL_36:
        v30 = v75;
        v23 = v72;
        if (!v11)
          goto LABEL_102;
LABEL_37:
        if (v30 < v23)
        {
          v31 = __src;
          v32 = v23;
LABEL_46:
          v34 = 0;
          *(_QWORD *)&v31[8 * v30] = v11;
          v33 = 1;
          v72 = v32;
          __src = v31;
          v8 = v63;
          if (!v63)
            goto LABEL_48;
LABEL_47:
          v8[(v76 - v62) >> 2] = v11;
          goto LABEL_48;
        }
        if (BYTE3(v23))
        {
          v33 = 0;
          v34 = 1;
          if (!v8)
            goto LABEL_48;
          goto LABEL_47;
        }
        v32 = (v23 + 64);
        v35 = (char *)malloc_type_malloc(8 * v32, 0xC0040B8AA526DuLL);
        if (v35)
        {
          v31 = v35;
          if (__src)
          {
            memmove(v35, __src, 8 * v72);
            free(__src);
          }
          v30 = v75;
          goto LABEL_46;
        }
        v33 = 0;
        v34 = 1;
        v8 = v63;
        v30 = v75;
        if (v63)
          goto LABEL_47;
LABEL_48:
        if ((v34 & 1) != 0)
          goto LABEL_101;
        v36 = v30 + 1;
        if (v22)
        {
          v12 = v14 + 4;
          if (v14 + 4 > v68)
          {
            v75 = v36;
LABEL_101:
            CFRelease(v11);
LABEL_102:
            v7 = 0;
            goto LABEL_103;
          }
          v76 = (char *)v15 + 4;
          v33 = 1;
        }
        else
        {
LABEL_61:
          v12 = v14;
          v76 = (const char *)v15;
        }
        v38 = v74;
        v75 = v36;
        if (v70)
        {
          if (!v74)
          {
            TypeID = CFStringGetTypeID();
            v33 = TypeID == CFGetTypeID(v11);
            v38 = v11;
LABEL_67:
            v5 = v68;
            goto LABEL_75;
          }
          v5 = v68;
          if (v11 != (const __CFString *)v70)
            CFDictionarySetValue(v70, v74, v11);
          v38 = 0;
        }
        else
        {
          if (v71)
          {
            CFArrayAppendValue(v71, v11);
            goto LABEL_67;
          }
          v5 = v68;
          if (v20)
          {
            CFSetAddValue(v20, v11);
          }
          else
          {
            if (v55)
              goto LABEL_102;
            v55 = v11;
            if (v69)
              IOCFUnserializeBinary_cold_1();
          }
        }
LABEL_75:
        if (!v33)
          goto LABEL_102;
        v74 = v38;
        if (!v73)
        {
          v11 = v69;
          v13 = v20;
          if (v16 < 0)
          {
            v40 = v61;
            if (!v61)
            {
              v7 = (CFMutableDictionaryRef)v55;
              goto LABEL_103;
            }
            v11 = (const __CFString *)v59[v61--];
            v41 = CFGetTypeID((CFTypeRef)v59[v40]);
            v42 = CFDictionaryGetTypeID();
            v13 = 0;
            v70 = (__CFDictionary *)v11;
            v71 = 0;
            if (v41 != v42)
            {
              v43 = CFArrayGetTypeID();
              v13 = 0;
              v70 = 0;
              v71 = (__CFArray *)v11;
              if (v41 != v43)
              {
                v44 = CFSetGetTypeID();
                v70 = 0;
                v71 = 0;
                v7 = 0;
                v13 = (__CFSet *)v11;
                if (v41 != v44)
                  goto LABEL_103;
              }
            }
          }
          continue;
        }
        v13 = v7;
        v9 = v65;
        v10 = v66;
        v70 = v66;
        v71 = v65;
        if (v16 < 0)
          continue;
        v45 = v61 + 1;
        if (v61 + 1 < v58)
        {
          v46 = v59;
          v47 = v58;
          goto LABEL_99;
        }
        if (WORD1(v58))
          goto LABEL_102;
        v47 = (v58 + 64);
        v48 = malloc_type_malloc(8 * v47, 0xC0040B8AA526DuLL);
        if (v48)
        {
          v46 = v48;
          if (v59)
          {
            memmove(v48, v59, 8 * v58);
            free(v59);
          }
LABEL_99:
          ++v61;
          v46[v45] = v69;
          v58 = v47;
          v59 = v46;
          v8 = v63;
          goto LABEL_11;
        }
LABEL_114:
        v7 = 0;
        v8 = v63;
LABEL_103:
        if ((_DWORD)v72)
        {
          v49 = v7 != 0;
          v50 = v75 - v49;
          if (v75 > v49)
          {
            v51 = (const void **)&__src[8 * (v7 != 0)];
            do
            {
              v52 = *v51++;
              CFRelease(v52);
              --v50;
            }
            while (v50);
          }
          free(__src);
        }
        if ((_DWORD)v58)
          free(v59);
        if (v8)
          free(v8);
        return v7;
      case 9u:
        v14 += 4 * v19;
        if (v14 > v5)
          goto LABEL_102;
        v11 = (const __CFString *)CFDataCreate(allocator, (const UInt8 *)v15, v18);
        v65 = 0;
        v66 = 0;
        v7 = 0;
        v73 = 0;
        v22 = 0;
        v15 = (double *)((char *)v15 + 4 * v19);
        goto LABEL_36;
      case 0xAu:
        if ((_DWORD)v18)
          v11 = v57;
        else
          v11 = v56;
        CFRetain(v11);
        v65 = 0;
        v66 = 0;
        v7 = 0;
        v73 = 0;
        v22 = 0;
        goto LABEL_36;
      case 0xBu:
        if (v8)
        {
          v36 = v75;
          if (v54 <= v18)
            goto LABEL_102;
          v37 = (const __CFString **)&v8[v18];
        }
        else
        {
          v36 = v75;
          if (v18 >= v75)
            goto LABEL_102;
          v37 = (const __CFString **)&__src[8 * v18];
        }
        v7 = 0;
        v11 = *v37;
        if (!*v37)
          goto LABEL_103;
        v73 = 0;
        v33 = 1;
        v65 = 0;
        v66 = 0;
        goto LABEL_61;
      default:
        goto LABEL_103;
    }
  }
}

uint64_t DoCFSerializeBinary(uint64_t a1, const __CFString *a2, int a3)
{
  const void *Value;
  uint64_t result;
  CFTypeID v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  unint64_t v12;
  CFNumberType v13;
  int v14;
  uint64_t v15;
  const __CFString *v16;
  const UInt8 *BytePtr;
  uint64_t v18;
  unint64_t v19;
  const char *CStringPtr;
  const UInt8 *v21;
  size_t v22;
  const __CFData *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  const __CFString *v27;
  const UInt8 *v28;
  uint64_t v29;
  CFIndex Length;
  const void *v31;
  uint64_t v32;
  const __CFAllocator *v33;
  CFDataRef ExternalRepresentation;
  char *v35;
  char *v36;
  UInt8 bytes[8];
  __int128 context;
  __int128 v39;
  CFRange v40;

  context = 0u;
  v39 = 0u;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  if (Value)
  {
    *(_DWORD *)bytes = Value & 0xFFFFFF | 0xC000000;
    if (*(_BYTE *)(a1 + 16))
    {
      *(_BYTE *)(a1 + 16) = 0;
      *(_DWORD *)bytes = Value & 0xFFFFFF | 0x8C000000;
    }
    CFDataAppendBytes(*(CFMutableDataRef *)a1, bytes, 4);
    return 1;
  }
  v8 = CFGetTypeID(a2);
  *(_QWORD *)&context = a1;
  if (v8 == CFDictionaryGetTypeID())
  {
    Count = CFDictionaryGetCount((CFDictionaryRef)a2);
    IOCFSerializeBinaryAddObject(a1, a2, Count | 0x1000000, 0, 0, 0);
    BYTE8(v39) = 1;
    *((_QWORD *)&context + 1) = 0;
    *(_QWORD *)&v39 = Count;
    CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)IOCFSerializeBinaryCFDictionaryFunction, &context);
    return BYTE8(v39);
  }
  if (v8 == CFArrayGetTypeID())
  {
    v10 = CFArrayGetCount((CFArrayRef)a2);
    IOCFSerializeBinaryAddObject(a1, a2, v10 | 0x2000000, 0, 0, 0);
    BYTE8(v39) = 1;
    *((_QWORD *)&context + 1) = 0;
    *(_QWORD *)&v39 = v10;
    v40.location = 0;
    v40.length = v10;
    CFArrayApplyFunction((CFArrayRef)a2, v40, (CFArrayApplierFunction)IOCFSerializeBinaryCFArraySetFunction, &context);
    return BYTE8(v39);
  }
  if (v8 == CFSetGetTypeID())
  {
    v11 = CFArrayGetCount((CFArrayRef)a2);
    IOCFSerializeBinaryAddObject(a1, a2, v11 | 0x3000000, 0, 0, 0);
    BYTE8(v39) = 1;
    *((_QWORD *)&context + 1) = 0;
    *(_QWORD *)&v39 = v11;
    CFSetApplyFunction((CFSetRef)a2, (CFSetApplierFunction)IOCFSerializeBinaryCFArraySetFunction, &context);
    return BYTE8(v39);
  }
  if (v8 != CFNumberGetTypeID())
  {
    if (v8 == CFBooleanGetTypeID())
    {
      v14 = (*MEMORY[0x1E0C9AE50] == (_QWORD)a2) | 0xB000000;
      v15 = a1;
      v16 = a2;
      BytePtr = 0;
      v18 = 0;
      goto LABEL_30;
    }
    if (v8 != CFStringGetTypeID())
    {
      if (v8 != CFDataGetTypeID())
      {
        result = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<string>typeID 0x%x not serializable</string>"), v8);
        if (result)
        {
          v31 = (const void *)result;
          v32 = DoCFSerializeBinary(a1, result, 0);
          CFRelease(v31);
          return v32;
        }
        return result;
      }
      Length = CFDataGetLength((CFDataRef)a2);
      BytePtr = CFDataGetBytePtr((CFDataRef)a2);
      v15 = a1;
      v16 = a2;
      v14 = Length | 0xA000000;
      v18 = Length;
LABEL_30:
      IOCFSerializeBinaryAddObject(v15, v16, v14, BytePtr, v18, 0);
      return 1;
    }
    CStringPtr = CFStringGetCStringPtr(a2, 0x8000100u);
    if (CStringPtr)
    {
      v21 = (const UInt8 *)CStringPtr;
      v22 = CFStringGetLength(a2);
      v23 = 0;
      goto LABEL_26;
    }
    v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x8000100u, 0);
    v23 = ExternalRepresentation;
    if (ExternalRepresentation || (v23 = CFStringCreateExternalRepresentation(v33, a2, 0x8000100u, 0x3Fu)) != 0)
    {
      v22 = CFDataGetLength(v23);
      v21 = CFDataGetBytePtr(v23);
      if (ExternalRepresentation)
      {
LABEL_26:
        if (a3)
        {
          v24 = v22 + 1;
          v25 = (v22 + 1) | 0x8000000;
          v26 = a1;
          v27 = a2;
          v28 = v21;
          v29 = 1;
        }
        else
        {
          v25 = v22 | 0x9000000;
          v26 = a1;
          v27 = a2;
          v28 = v21;
          v24 = v22;
          v29 = 0;
        }
        IOCFSerializeBinaryAddObject(v26, v27, v25, v28, v24, v29);
        if (v23)
          CFRelease(v23);
        return 1;
      }
    }
    else
    {
      v22 = 0;
      v21 = (const UInt8 *)"";
    }
    if (v21)
    {
      v35 = (char *)malloc_type_malloc(v22 + 1, 0x48D202D1uLL);
      if (v35)
      {
        v36 = v35;
        memmove(v35, v21, v22);
        v36[v22] = 0;
        syslog(3, "FIXME: IOCFSerialize has detected a string that can not be converted to UTF-8, \"%s\"", v36);
        free(v36);
      }
    }
    goto LABEL_26;
  }
  *(_QWORD *)bytes = 0;
  v12 = CFNumberGetType((CFNumberRef)a2) - 5;
  if (v12 > 0xB)
    v13 = kCFNumberLongLongType;
  else
    v13 = qword_18AB45BC8[v12];
  result = CFNumberGetValue((CFNumberRef)a2, v13, bytes);
  if ((_DWORD)result)
  {
    v19 = CFNumberGetType((CFNumberRef)a2) - 1;
    if (v19 > 0xF)
      v14 = 67108928;
    else
      v14 = dword_18AB45C28[v19];
    BytePtr = bytes;
    v15 = a1;
    v16 = a2;
    v18 = 8;
    goto LABEL_30;
  }
  return result;
}

uint64_t io_connect_method(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__dst, int *a10, void *a11, int *a12, uint64_t a13, _QWORD *a14)
{
  unsigned int v14;
  unsigned int v15;
  const void *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  const void *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  mach_port_t *v30;
  uint64_t v31;
  char *v32;
  int v33;
  int v34;
  int v35;
  mach_port_t v36;
  uint64_t v37;
  BOOL v38;
  int v40;
  unsigned int v41;
  char *v42;
  mach_port_t v43;
  unsigned int v44;
  size_t v45;
  char *v46;
  unsigned int v47;
  const void *v48;
  mach_port_t reply_port[4];
  __int128 v50;
  size_t __n[2];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v14 = MEMORY[0x1E0C80A78]();
  v81 = *MEMORY[0x1E0C80C00];
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  *(_OWORD *)__n = 0u;
  v52 = 0u;
  *(_OWORD *)reply_port = 0u;
  v50 = 0u;
  *((_QWORD *)&v50 + 1) = *MEMORY[0x1E0C804E8];
  LODWORD(__n[0]) = v20;
  if (v15 <= 0x10)
  {
    v21 = v19;
    v22 = v18;
    v23 = v17;
    v24 = v16;
    v25 = v15;
    v26 = v14;
    v27 = 2 * v15;
    __memcpy_chk();
    HIDWORD(__n[0]) = v25;
    if (v23 <= 0x1000)
    {
      v30 = &reply_port[v27];
      v31 = (v23 + 3) & 0xFFFFFFFC;
      v32 = (char *)&reply_port[v27] + v31;
      v33 = v27 * 4 + v31;
      memcpy(v30 + 11, v24, v23);
      v30[10] = v23;
      *(_QWORD *)(v32 + 44) = v22;
      *(_QWORD *)(v32 + 52) = v21;
      v34 = *a10;
      if (*a10 >= 0x1000)
        v34 = 4096;
      *((_DWORD *)v32 + 15) = v34;
      v35 = *a12;
      if (*a12 >= 0x10)
        v35 = 16;
      *((_DWORD *)v32 + 16) = v35;
      *(_QWORD *)(v32 + 68) = a13;
      *(_QWORD *)(v32 + 76) = *a14;
      v36 = mig_get_reply_port();
      reply_port[0] = 5395;
      reply_port[1] = v33 + 84;
      *(_QWORD *)&reply_port[2] = __PAIR64__(v36, v26);
      *(_QWORD *)&v50 = 0xB3100000000;
      v37 = mach_msg2_internal();
      v28 = v37;
      if ((v37 - 268435458) <= 0xE && ((1 << (v37 - 2)) & 0x4003) != 0)
      {
        mig_put_reply_port(reply_port[3]);
        return v28;
      }
      if ((_DWORD)v37)
      {
        mig_dealloc_reply_port(reply_port[3]);
        return v28;
      }
      if (DWORD1(v50) == 71)
      {
        v28 = 4294966988;
      }
      else if (DWORD1(v50) == 2965)
      {
        if ((reply_port[0] & 0x80000000) != 0)
          goto LABEL_30;
        if (reply_port[1] - 4277 <= 0xFFFFEF7E)
        {
          if (reply_port[2])
            v38 = 1;
          else
            v38 = LODWORD(__n[0]) == 0;
          if (!v38 && reply_port[1] == 36)
            v28 = LODWORD(__n[0]);
          else
            v28 = 4294966996;
          goto LABEL_31;
        }
        if (reply_port[2])
          goto LABEL_30;
        v28 = LODWORD(__n[0]);
        if (LODWORD(__n[0]))
          goto LABEL_31;
        v40 = HIDWORD(__n[0]);
        if (HIDWORD(__n[0]) > 0x1000)
        {
LABEL_30:
          v28 = 4294966996;
        }
        else
        {
          v28 = 4294966996;
          if (reply_port[1] - 52 >= HIDWORD(__n[0]))
          {
            v41 = (HIDWORD(__n[0]) + 3) & 0xFFFFFFFC;
            if (reply_port[1] >= v41 + 52)
            {
              v42 = (char *)reply_port + v41;
              v43 = *((_DWORD *)v42 + 10);
              if (v43 <= 0x10 && v43 <= (reply_port[1] - v41 - 52) >> 3)
              {
                v44 = 8 * v43;
                if (reply_port[1] - v41 == 8 * v43 + 52)
                {
                  v45 = *a10;
                  if (HIDWORD(__n[0]) <= v45)
                  {
                    v46 = v42 - 4096;
                    memcpy(__dst, &__n[1], HIDWORD(__n[0]));
                    *a10 = v40;
                    v47 = *((_DWORD *)v46 + 1034);
                    v48 = v46 + 4140;
                    if (v47 <= *a12)
                    {
                      memcpy(a11, v48, 8 * v47);
                      v28 = 0;
                      *a12 = *((_DWORD *)v46 + 1034);
                      *a14 = *(_QWORD *)&v46[v44 + 4140];
                      return v28;
                    }
                    memcpy(a11, v48, (8 * *a12));
                    *a12 = *((_DWORD *)v46 + 1034);
                  }
                  else
                  {
                    memcpy(__dst, &__n[1], v45);
                    *a10 = v40;
                  }
                  return 4294966989;
                }
              }
            }
          }
        }
      }
      else
      {
        v28 = 4294966995;
      }
LABEL_31:
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v28;
    }
  }
  return 4294966989;
}

void IOCFSerializeBinaryAddObject(uint64_t a1, const void *a2, int a3, const UInt8 *a4, uint64_t a5, uint64_t a6)
{
  UInt8 bytes[4];

  *(_DWORD *)bytes = a3;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), a2, *(const void **)(a1 + 24));
  ++*(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(a1 + 16))
  {
    *(_BYTE *)(a1 + 16) = 0;
    *(_DWORD *)bytes = a3 | 0x80000000;
  }
  CFDataAppendBytes(*(CFMutableDataRef *)a1, bytes, 4);
  CFDataAppendBytes(*(CFMutableDataRef *)a1, a4, a5 - a6);
  if (a6)
    CFDataIncreaseLength(*(CFMutableDataRef *)a1, 1);
  if ((a5 & 3) != 0)
    CFDataIncreaseLength(*(CFMutableDataRef *)a1, 4 - (a5 & 3));
}

uint64_t IOCFSerializeBinaryCFDictionaryFunction(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v6 = *a3;
  ++a3[1];
  *((_BYTE *)a3 + 24) &= DoCFSerializeBinary(v6, a1, 1);
  v7 = *a3;
  *(_BYTE *)(v7 + 16) = a3[1] == a3[2];
  result = DoCFSerializeBinary(v7, a2, 0);
  *((_BYTE *)a3 + 24) &= result;
  return result;
}

uint64_t (*initrosetta_is_current_process_translated())()
{
  void *v0;
  uint64_t (*result)();

  v0 = (void *)RosettaLibrary_libLibrary;
  if (!RosettaLibrary_libLibrary)
  {
    v0 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary = (uint64_t)v0;
  }
  result = (uint64_t (*)())dlsym(v0, "rosetta_is_current_process_translated");
  dynLinkrosetta_is_current_process_translated[0] = result;
  if (result)
    return (uint64_t (*)())result();
  return result;
}

uint64_t (*initrosetta_is_current_process_translated_0())()
{
  void *v0;
  uint64_t (*result)();

  v0 = (void *)RosettaLibrary_libLibrary_0;
  if (!RosettaLibrary_libLibrary_0)
  {
    v0 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_0 = (uint64_t)v0;
  }
  result = (uint64_t (*)())dlsym(v0, "rosetta_is_current_process_translated");
  dynLinkrosetta_is_current_process_translated_0[0] = result;
  if (result)
    return (uint64_t (*)())result();
  return result;
}

uint64_t (*initrosetta_is_current_process_translated_1())()
{
  void *v0;
  uint64_t (*result)();

  v0 = (void *)RosettaLibrary_libLibrary_1;
  if (!RosettaLibrary_libLibrary_1)
  {
    v0 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_1 = (uint64_t)v0;
  }
  result = (uint64_t (*)())dlsym(v0, "rosetta_is_current_process_translated");
  dynLinkrosetta_is_current_process_translated_1 = result;
  if (result)
    return (uint64_t (*)())result();
  return result;
}

uint64_t __PropertyChangedFunction(uint64_t result, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 16) != result)
    return _IOHIDEventSystemConnectionPropertyChanged(result, *(void **)a2, *(const void **)(a2 + 8));
  return result;
}

uint64_t __IOHIDCFDictionaryFunctionApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

kern_return_t IOConnectTrap2(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, 0, 0, 0, 0);
}

id IOHIDServiceFilterSetPropertyForClient(id result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD, uint64_t, uint64_t, uint64_t);

  v4 = *((_QWORD *)result + 2);
  if (v4)
  {
    v5 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4 + 96);
    if (v5)
      return (id)v5(*((_QWORD *)result + 2), a2, a3, a4);
  }
  if (*((_QWORD *)result + 12))
    return objc_msgSend(*((id *)result + 12), *((SEL *)result + 14), a3, a2, a4);
  return result;
}

id IOHIDServiceFilterClientNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id result;
  const char *v7;

  result = *(id *)(a1 + 96);
  if (result)
  {
    v7 = *(const char **)(a1 + 176);
    if (v7)
      return objc_msgSend(result, v7, a2, a3);
  }
  return result;
}

_QWORD *IOHIDEventGetDataValue(_QWORD *a1, unsigned int a2)
{
  return IOHIDEventGetDataValueWithOptions(a1, a2, 0);
}

uint64_t __IOHIDServiceEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, HIDEvent *a4)
{
  uint64_t result;
  uint64_t v7;
  __darwin_time_t tv_sec;
  uint64_t TimeStampOfType;
  uint64_t Type;
  unsigned int TimeStampType;
  int v12;
  uint64_t v13;
  void (*v14)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v15;
  unsigned __int16 IntegerValue;
  int v17;
  unsigned int v18;
  uint64_t v19;
  _QWORD *Event;
  _QWORD *v21;
  int v22;
  const __CFAllocator *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  uint64_t v26;
  __CFSet *v27;
  __int16 v28;
  uint64_t v29;
  unsigned __int8 v30;
  unsigned int v31;
  unsigned __int16 v32;
  int v33;
  unsigned __int8 v34;
  unsigned int Phase;
  unint64_t v36;
  int v37;
  unsigned __int16 v38;
  unint64_t v39;
  unsigned __int16 v40;
  BOOL v41;
  const __CFData *v42;
  const __CFAllocator *v43;
  const __CFArray *v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  void (*v50)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  HIDEvent *context;
  timeval valuePtr[5];
  uint64_t v57;
  CFRange v58;

  v57 = *MEMORY[0x1E0C80C00];
  context = a4;
  result = mach_absolute_time();
  v7 = result;
  if (!a1)
    goto LABEL_82;
  valuePtr[0].tv_sec = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, valuePtr);
  tv_sec = valuePtr[0].tv_sec;
  TimeStampOfType = IOHIDEventGetTimeStampOfType((uint64_t)a4, 2);
  Type = IOHIDEventGetType((uint64_t)a4);
  TimeStampType = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8256, 0, TimeStampOfType, tv_sec, Type, TimeStampType);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v54, valuePtr);
  result = *(_QWORD *)(a1 + 72);
  v12 = *(_DWORD *)result + 1;
  *(_DWORD *)result = v12;
  if ((*(_BYTE *)(a1 + 224) & 1) != 0)
  {
LABEL_78:
    if (!v12)
      goto LABEL_82;
    goto LABEL_81;
  }
  v13 = *(_QWORD *)(a1 + 128);
  v52 = *(_QWORD *)(a1 + 136);
  v14 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 144);
  if (v14)
  {
    v15 = mach_absolute_time();
    _IOHIDDebugEventAddPerfData(a4, 1, v15);
    if (*(_DWORD *)(a1 + 284))
      IOHIDEventSetIntegerValue(a4, 4u, 1);
    if (IOHIDEventGetType((uint64_t)a4) == 1)
    {
      IntegerValue = IOHIDEventGetIntegerValue(a4, 0x10001u);
      v53 = IntegerValue | ((unsigned __int16)IOHIDEventGetIntegerValue(a4, 0x10000u) << 16);
    }
    else
    {
      v53 = 0;
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 2) && IOHIDEventGetEvent(a4, 2))
    {
      if (!IOHIDEventGetIntegerValue(a4, 0x20001u))
      {
        v17 = IOHIDEventGetIntegerValue(a4, 0x20000u);
        v18 = *(_DWORD *)(a1 + 156) ^ v17;
        if (v18)
        {
          v19 = 1;
          while (((v18 >> (v19 - 1)) & 1) == 0)
          {
            if ((_DWORD)++v19 == 32)
              goto LABEL_24;
          }
          IOHIDEventSetIntegerValue(a4, 0x20001u, v19);
        }
LABEL_24:
        *(_DWORD *)(a1 + 156) = v17;
      }
    }
    else if (*(_DWORD *)(a1 + 280))
    {
      if (IOHIDEventConformsTo((uint64_t)a4, 11))
      {
        Event = (_QWORD *)IOHIDEventGetEvent(a4, 11);
        if (Event)
        {
          v21 = Event;
          if (!IOHIDEventGetIntegerValue(Event, 0xB0019u))
            IOHIDEventSetIntegerValue(v21, 0xB0019u, 1);
        }
      }
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 3))
    {
      v22 = IOHIDEventGetIntegerValue(a4, 0x30000u);
      LODWORD(valuePtr[0].tv_sec) = IOHIDEventGetIntegerValue(a4, 0x30001u);
      BYTE4(valuePtr[0].tv_sec) = v22;
      BYTE5(valuePtr[0].tv_sec) = BYTE1(v22);
      BYTE6(valuePtr[0].tv_sec) = BYTE2(v22);
      HIBYTE(valuePtr[0].tv_sec) = HIBYTE(v22);
      v23 = CFGetAllocator((CFTypeRef)a1);
      v24 = CFNumberCreate(v23, kCFNumberSInt64Type, valuePtr);
      if (v24)
      {
        v25 = v24;
        v26 = IOHIDEventGetIntegerValue(a4, 0x30002u);
        v27 = *(__CFSet **)(a1 + 264);
        if (v26)
          CFSetAddValue(v27, v25);
        else
          CFSetRemoveValue(v27, v25);
        CFRelease(v25);
      }
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 35))
      *(_QWORD *)(a1 + 272) |= 0x800000000uLL;
    if (IOHIDEventConformsTo((uint64_t)a4, 17))
      *(_QWORD *)(a1 + 272) |= 0x20000uLL;
    if (IOHIDEventConformsTo((uint64_t)a4, 2))
      *(_QWORD *)(a1 + 272) |= 4uLL;
    if (IOHIDEventConformsTo((uint64_t)a4, 6))
    {
      if (IOHIDEventGetScrollMomentum((uint64_t)a4) == 2)
        *(_DWORD *)(a1 + 288) = 1;
      if (IOHIDEventGetScrollMomentum((uint64_t)a4) == 4)
        *(_DWORD *)(a1 + 288) = 0;
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 11))
    {
      v28 = IOHIDEventGetIntegerValue(a4, 0xB0007u);
      if ((v28 & 0x100) != 0)
        *(_DWORD *)(a1 + 292) = 1;
      if ((v28 & 0x88) != 0)
        *(_DWORD *)(a1 + 292) = 0;
    }
    if (!IOHIDEventGetSenderID((uint64_t)a4))
      IOHIDEventSetSenderID((uint64_t)a4, tv_sec);
    v29 = IOHIDEventGetTimeStampOfType((uint64_t)a4, 2);
    v30 = IOHIDEventGetTimeStampType((uint64_t)a4);
    *(_QWORD *)(a1 + 328) = IOHIDEventGetTimeStamp((uint64_t)a4);
    memset(valuePtr, 0, 32);
    LODWORD(valuePtr[0].tv_sec) = IOHIDEventGetType((uint64_t)a4);
    gettimeofday((timeval *)&valuePtr[0].tv_usec, 0);
    v31 = valuePtr[0].tv_sec;
    if (LODWORD(valuePtr[0].tv_sec) == 1)
    {
      v37 = IOHIDEventGetIntegerValue(a4, 0x10000u);
      v38 = IOHIDEventGetIntegerValue(a4, 0x10001u);
      v39 = (v37 << 16) & 0xFFFFFFFFFFFF0000 | v38 | (IOHIDEventGetIntegerValue(a4, 0x10003u) << 32);
    }
    else
    {
      if (LODWORD(valuePtr[0].tv_sec) != 3)
        goto LABEL_61;
      v50 = v14;
      v51 = v7;
      v32 = IOHIDEventGetIntegerValue(a4, 0x30000u);
      v49 = IOHIDEventGetIntegerValue(a4, 0x30002u);
      v33 = IOHIDEventGetIntegerValue(a4, 0x30005u);
      v34 = IOHIDEventGetIntegerValue(a4, 0x30004u);
      Phase = IOHIDEventGetPhase((uint64_t)a4);
      if (v32 == 7)
      {
        v36 = 0;
      }
      else
      {
        v40 = IOHIDEventGetIntegerValue(a4, 0x30001u);
        v41 = v40 == 46 || v32 == 12;
        v36 = (unint64_t)v40 << 26;
        if (!v41)
          v36 = 0;
      }
      v39 = v49 | ((unint64_t)v32 << 42) | (2 * v33) | (4 * v34) | ((unint64_t)Phase << 10) | v36;
      v14 = v50;
      v7 = v51;
    }
    *(_QWORD *)&valuePtr[1].tv_usec = v39;
LABEL_61:
    v42 = *(const __CFData **)(a1 + 408);
    if (v42
      || (v43 = CFGetAllocator((CFTypeRef)a1),
          v42 = _IOHIDSimpleQueueCreate(v43, 32, 50),
          (*(_QWORD *)(a1 + 408) = v42) != 0))
    {
      _IOHIDSimpleQueueEnqueue(v42, valuePtr, 1);
      v31 = valuePtr[0].tv_sec;
    }
    ++*(_QWORD *)(*(_QWORD *)(a1 + 416) + 8 * v31);
    ++*(_DWORD *)(a1 + 228);
    *(_QWORD *)(a1 + 232) |= 1 << IOHIDEventGetType((uint64_t)a4);
    _IOHIDDebugTrace(8259, 1, v29, a1, v30, v53);
    v44 = *(const __CFArray **)(a1 + 248);
    if (v44)
    {
      v58.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 248));
      v58.location = 0;
      CFArrayApplyFunction(v44, v58, (CFArrayApplierFunction)__FilterFunctionFilterEvent, &context);
    }
    _IOHIDDebugTrace(8259, 2, v29, a1, v30, v53);
    v12 = **(_DWORD **)(a1 + 72);
  }
  if (v12)
  {
    v45 = v12;
    do
    {
      v46 = *(_QWORD *)(a1 + 72);
      if (*(_DWORD *)v46)
      {
        --*(_DWORD *)v46;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v46 + 8)))
          __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v54, valuePtr);
      }
      --v45;
    }
    while (v45);
  }
  if (v14)
    v14(v13, v52, a1, context, 0);
  result = *(_QWORD *)(a1 + 72);
  if (v12)
  {
    do
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(result + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v54, valuePtr);
      result = *(_QWORD *)(a1 + 72);
      v47 = *(_DWORD *)result + 1;
      *(_DWORD *)result = v47;
      --v12;
    }
    while (v12);
    v12 = v47;
    goto LABEL_78;
  }
  v12 = *(_DWORD *)result;
  if (!*(_DWORD *)result)
    goto LABEL_82;
LABEL_81:
  *(_DWORD *)result = v12 - 1;
  result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
  if ((_DWORD)result)
    __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v54, valuePtr);
LABEL_82:
  if (*(_QWORD *)(a1 + 472))
  {
    v48 = mach_absolute_time();
    _IOHIDGetTimestampDelta(v48, v7, 0x3E8u);
    return IOHIDAnalyticsHistogramEventSetIntegerValue();
  }
  return result;
}

uint64_t IOHIDEventConformsTo(uint64_t a1, char a2)
{
  return (*(_QWORD *)(a1 + 24) >> a2) & 1;
}

uint64_t IOHIDEventSystemConnectionDispatchEvent(uint64_t a1, uint64_t a2)
{
  HIDEvent *v2;
  uint64_t v4;
  char Type;
  char v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t Latency;
  unint64_t v13;
  CFTypeRef v14;
  const void *v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t TimeStampOfType;
  unsigned int TimeStampType;
  NSObject *v21;
  NSObject *v22;
  uint64_t v24;
  int v25;
  uint64_t SenderID;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  _BYTE v31[10];
  _DWORD v32[4];
  uint64_t v33;

  v2 = (HIDEvent *)a2;
  v33 = *MEMORY[0x1E0C80C00];
  v4 = 3758097084;
  Type = IOHIDEventGetType(a2);
  if (a1)
  {
    v6 = Type;
    v7 = _IOHIDEventSystemConnectionCopyQueue(a1);
    if (v7)
    {
      v8 = v7;
      if (((*(_QWORD *)(a1 + 280) >> v6) & 1) == 0)
      {
        v4 = 0;
        ++*(_DWORD *)(a1 + 288);
        goto LABEL_37;
      }
      v9 = mach_absolute_time();
      _IOHIDDebugEventAddPerfData(v2, 4, v9);
      v10 = *(_QWORD *)(a1 + 440);
      if (v10)
      {
        v2 = (HIDEvent *)IOHIDConnectionFilterFilterEvent(v10, (uint64_t)v2);
        if (!v2)
          goto LABEL_37;
      }
      if (IsNotificationEvent(v2))
      {
        IOHIDEventQueueNotify(*(_QWORD *)(a1 + 24));
LABEL_37:
        CFRelease(v8);
        return v4;
      }
      ++*(_DWORD *)(a1 + 312);
      *(_QWORD *)(a1 + 320) |= 1 << IOHIDEventGetType((uint64_t)v2);
      v11 = IOHIDEventQueueEnqueue((uint64_t)v8, (uint64_t)v2);
      v4 = v11;
      if ((_DWORD)v11 == -536870168)
      {
        if (*MEMORY[0x1E0C9B0D0] == a1 || (*(_BYTE *)(a1 + 264) & 2) == 0)
        {
          CFRetain((CFTypeRef)a1);
          v18 = *(NSObject **)(a1 + 96);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 0x40000000;
          block[2] = __IOHIDEventSystemConnectionDispatchEvent_block_invoke;
          block[3] = &__block_descriptor_tmp_16_0;
          block[4] = a1;
          dispatch_async(v18, block);
        }
        goto LABEL_23;
      }
      if ((_DWORD)v11)
      {
LABEL_23:
        TimeStampOfType = IOHIDEventGetTimeStampOfType((uint64_t)v2, 2);
        TimeStampType = IOHIDEventGetTimeStampType((uint64_t)v2);
        _IOHIDDebugTrace(8240, 0, TimeStampOfType, (int)v4, TimeStampType, 0);
        if ((_DWORD)v4 != -536870195)
        {
          if ((_DWORD)v4)
          {
            if ((_DWORD)v4 != *(_DWORD *)(a1 + 368))
            {
              v22 = _IOHIDLogCategory(9u);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                v24 = *(_QWORD *)(a1 + 168);
                v25 = IOHIDEventGetType((uint64_t)v2);
                SenderID = IOHIDEventGetSenderID((uint64_t)v2);
                *(_DWORD *)buf = 136315906;
                v29 = v24;
                v30 = 1024;
                *(_DWORD *)v31 = v4;
                *(_WORD *)&v31[4] = 1024;
                *(_DWORD *)&v31[6] = v25;
                LOWORD(v32[0]) = 2048;
                *(_QWORD *)((char *)v32 + 2) = SenderID;
                _os_log_error_impl(&dword_18AAAF000, v22, OS_LOG_TYPE_ERROR, "%s: Event enqueue error:0x%08x type:%d sender:0x%llx", buf, 0x22u);
              }
              *(_DWORD *)(a1 + 368) = v4;
            }
            *(int32x2_t *)(a1 + 296) = vadd_s32(*(int32x2_t *)(a1 + 296), (int32x2_t)0x100000001);
            *(_QWORD *)(a1 + 304) |= 1 << IOHIDEventGetType((uint64_t)v2);
            if (!*(_QWORD *)(a1 + 344))
              gettimeofday((timeval *)(a1 + 344), 0);
            gettimeofday((timeval *)(a1 + 328), 0);
          }
          else if (*(_DWORD *)(a1 + 368))
          {
            v21 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
              IOHIDEventSystemConnectionDispatchEvent_cold_1();
            v4 = 0;
            *(_DWORD *)(a1 + 368) = 0;
            *(_DWORD *)(a1 + 300) = 0;
          }
          else
          {
            v4 = 0;
          }
        }
        goto LABEL_37;
      }
      Latency = IOHIDEventGetLatency((uint64_t)v2, 1u);
      v13 = Latency;
      if (Latency > *(_QWORD *)(a1 + 360))
        *(_QWORD *)(a1 + 360) = Latency;
      v14 = _IOHIDEventCopyAttachment((uint64_t)v2, CFSTR("Sender"));
      v15 = v14;
      if (v13 >= 0x2FAF081)
      {
        if (v14 && _IOHIDServiceCurrentBatchInterval((uint64_t)v14) > 1)
        {
LABEL_19:
          CFRelease(v15);
          goto LABEL_23;
        }
        v16 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          v17 = *(_QWORD *)(a1 + 168);
          *(_DWORD *)buf = 136315906;
          v29 = v17;
          v30 = 2048;
          *(_QWORD *)v31 = v13;
          *(_WORD *)&v31[8] = 1024;
          v32[0] = IOHIDEventGetType((uint64_t)v2);
          LOWORD(v32[1]) = 2048;
          *(_QWORD *)((char *)&v32[1] + 2) = IOHIDEventGetSenderID((uint64_t)v2);
          _os_log_impl(&dword_18AAAF000, v16, OS_LOG_TYPE_INFO, "%s: Event latency:%lld type:%d sender:0x%llx", buf, 0x26u);
        }
      }
      if (!v15)
        goto LABEL_23;
      goto LABEL_19;
    }
  }
  return v4;
}

uint64_t IOHIDEventGetType(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 104) + 4);
}

CFTypeRef _IOHIDEventCopyAttachment(uint64_t a1, CFTypeRef cf1)
{
  const void *v2;
  const void *v5;
  const __CFDictionary *v7;
  const void *Value;

  v2 = 0;
  if (!a1 || !cf1)
    return v2;
  if (CFEqual(cf1, CFSTR("Sender")))
  {
    v5 = *(const void **)(a1 + 64);
    if (v5)
      return CFRetain(v5);
  }
  else
  {
    v7 = *(const __CFDictionary **)(a1 + 56);
    if (v7)
    {
      Value = CFDictionaryGetValue(v7, cf1);
      v2 = Value;
      if (Value)
        CFRetain(Value);
      return v2;
    }
  }
  return 0;
}

const void *_IOHIDEventSystemConnectionCopyQueue(uint64_t a1)
{
  const void *v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRetain(v2);
  os_unfair_recursive_lock_unlock();
  return v2;
}

unint64_t IOHIDEventGetLatency(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t TimeStamp;
  unint64_t result;

  if (dynLinkrosetta_is_current_process_translated_0[0]
    && dynLinkrosetta_is_current_process_translated_0[0]())
  {
    v4 = mach_absolute_time();
    v5 = v4;
    if (!dynLinkrosetta_convert_to_system_absolute_time_0[0])
      goto LABEL_7;
    v6 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v4);
  }
  else
  {
    v6 = mach_absolute_time();
  }
  v5 = v6;
LABEL_7:
  TimeStamp = IOHIDEventGetTimeStamp(a1);
  result = _IOHIDGetTimestampDelta(v5, TimeStamp, a2);
  if (v5 < TimeStamp)
    return 0;
  return result;
}

uint64_t IOHIDEventGetTimeStamp(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = v1;
  if ((*(_BYTE *)(a1 + 32) & 0x80) != 0)
  {
    v2 = 0;
    if (mach_get_times())
      return v2;
    v2 = v1;
  }
  if (v2
    && dynLinkrosetta_is_current_process_translated_0[0]
    && dynLinkrosetta_is_current_process_translated_0[0]()
    && dynLinkrosetta_convert_to_rosetta_absolute_time_0[0])
  {
    return ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_rosetta_absolute_time_0[0])(v2);
  }
  return v2;
}

uint64_t _IOHIDServiceSetPropertyForClient(uint64_t a1, const void *a2, const void *a3, CFTypeRef cf)
{
  CFTypeID v8;
  uint64_t UUID;
  uint64_t v10;
  CFTypeRef v11;
  const __CFArray *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  int ReportIntervalForClient;
  NSObject *v19;
  uint64_t v20;
  const void *v21;
  const void *v22;
  NSObject *v23;
  uint64_t v24;
  unsigned __int8 updated;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(void);
  unsigned __int8 v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  uint64_t (*v37)(_QWORD, _QWORD, const void *, const void *);
  void *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD context[3];
  uint8_t buf[4];
  uint64_t v43;
  __int16 v44;
  const void *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  uint64_t v50;
  CFRange v51;

  v50 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v8 = CFGetTypeID(cf);
    if (v8 == IOHIDEventSystemConnectionGetTypeID())
    {
      UUID = IOHIDEventSystemConnectionGetUUID((uint64_t)cf);
      v10 = mach_absolute_time();
      if (!IOHIDServiceCheckEntitlements(a1, (uint64_t)cf))
        return 0;
      v11 = cf;
    }
    else
    {
      v10 = mach_absolute_time();
      v11 = 0;
      UUID = 0;
    }
    if (CFEqual(cf, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
      CFDictionaryReplaceValue(*(CFMutableDictionaryRef *)(a1 + 312), a2, a3);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    }
  }
  else
  {
    v10 = mach_absolute_time();
    v11 = 0;
    UUID = 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(context, buf);
  ++**(_DWORD **)(a1 + 72);
  context[0] = a2;
  context[1] = a3;
  context[2] = v11;
  v12 = *(const __CFArray **)(a1 + 256);
  v51.length = CFArrayGetCount(v12);
  v51.location = 0;
  CFArrayApplyFunction(v12, v51, (CFArrayApplierFunction)__FilterFunctionSetPropertyForClient, context);
  v13 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v13)
  {
    --*(_DWORD *)v13;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v40, buf);
  }
  v14 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    v30 = *(_QWORD *)(a1 + 400);
    *(_DWORD *)buf = 134218754;
    v43 = v30;
    v44 = 2112;
    v45 = a2;
    v46 = 2112;
    v47 = (uint64_t)a3;
    v48 = 2112;
    v49 = UUID;
    _os_log_debug_impl(&dword_18AAAF000, v14, OS_LOG_TYPE_DEBUG, "0x%llx: set property:%@ value:%@ client:%@", buf, 0x2Au);
  }
  if (CFEqual(a2, CFSTR("ReportInterval")))
  {
    _IOHIDServiceSetReportIntervalForClient(a1, cf, a3);
    v15 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(a1 + 400);
      *(_DWORD *)buf = 134218498;
      v43 = v16;
      v44 = 2112;
      v45 = a3;
      v46 = 2112;
      v47 = UUID;
      _os_log_impl(&dword_18AAAF000, v15, OS_LOG_TYPE_DEFAULT, "0x%llx: set report interval:%@ client:%@", buf, 0x20u);
    }
    if (a3)
    {
      v17 = mach_absolute_time();
      ReportIntervalForClient = _IOHIDServiceGetReportIntervalForClient(a1, cf, 0);
      _IOHIDServiceSetEventDeadlineForClient(a1, cf, v17, ReportIntervalForClient, 0);
    }
    goto LABEL_27;
  }
  if (CFEqual(a2, CFSTR("BatchInterval")))
  {
    _IOHIDServiceSetBatchIntervalForClient(a1, cf, a3);
    v19 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_QWORD *)(a1 + 400);
      *(_DWORD *)buf = 134218498;
      v43 = v20;
      v44 = 2112;
      v45 = a3;
      v46 = 2112;
      v47 = UUID;
      _os_log_impl(&dword_18AAAF000, v19, OS_LOG_TYPE_DEFAULT, "0x%llx: set batch interval:%@ client:%@", buf, 0x20u);
    }
    goto LABEL_27;
  }
  if (!CFEqual(a2, CFSTR("IOHIDEventSystemClientIsUnresponsive")))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v40, buf);
    ++**(_DWORD **)(a1 + 72);
    v31 = *(_QWORD *)(a1 + 32);
    if (v31)
    {
      v32 = *(uint64_t (**)(void))(*(_QWORD *)v31 + 56);
      if (v32)
      {
        v33 = v32();
LABEL_47:
        updated = v33;
LABEL_49:
        v39 = *(_QWORD *)(a1 + 72);
        if (*(_DWORD *)v39)
        {
          --*(_DWORD *)v39;
          if (pthread_mutex_unlock((pthread_mutex_t *)(v39 + 8)))
            __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v40, buf);
        }
        goto LABEL_28;
      }
    }
    v34 = *(_QWORD *)(a1 + 24);
    if (v34 && (v35 = *(void (**)(void))(*(_QWORD *)v34 + 56)) != 0)
    {
      v35();
    }
    else
    {
      v36 = *(_QWORD *)(a1 + 360);
      if (v36)
      {
        v37 = *(uint64_t (**)(_QWORD, _QWORD, const void *, const void *))(v36 + 32);
        if (v37)
        {
          v33 = v37(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), a2, a3);
          goto LABEL_47;
        }
      }
      v38 = *(void **)(a1 + 480);
      if (v38)
      {
        v33 = objc_msgSend(v38, *(SEL *)(a1 + 504), a3, a2, cf);
        goto LABEL_47;
      }
    }
    updated = 1;
    goto LABEL_49;
  }
  v21 = _IOHIDServiceCopyConnectionCache(a1, cf);
  if (!v21)
  {
    updated = 1;
    goto LABEL_28;
  }
  v22 = v21;
  v23 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    v24 = *(_QWORD *)(a1 + 400);
    *(_DWORD *)buf = 134218498;
    v43 = v24;
    v44 = 2112;
    v45 = a3;
    v46 = 2112;
    v47 = UUID;
    _os_log_impl(&dword_18AAAF000, v23, OS_LOG_TYPE_DEFAULT, "0x%llx: unresponsive:%@ client:%@", buf, 0x20u);
  }
  CFRelease(v22);
LABEL_27:
  updated = __IOHIDServiceUpdateIntervals(a1, (uint64_t)cf);
LABEL_28:
  v26 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v26, v10, 0x3E8u);
  if (*(_QWORD *)(a1 + 464))
    IOHIDAnalyticsEventSetIntegerValueForField();
  v27 = mach_absolute_time();
  v28 = _IOHIDGetTimestampDelta(v27, v10, 1u);
  if (v28 > *(_QWORD *)(a1 + 376))
    *(_QWORD *)(a1 + 376) = v28;
  return updated;
}

uint64_t _IOHIDServiceCopyPropertyForClient(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6;
  const void *Value;
  const void *v8;
  uint64_t v9;
  const void *v10;
  const __CFArray *v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  const void *context;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  _OWORD v20[5];
  uint64_t v21;
  CFRange v22;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = mach_absolute_time();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 312), a2);
  v8 = Value;
  if (Value)
  {
    CFRetain(Value);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    ++*(_DWORD *)(a1 + 320);
    if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
    {
      CFRelease(v8);
      v9 = 0;
      goto LABEL_21;
    }
    if (v8 != (const void *)defaultPropertyKeyValue)
    {
      v9 = (uint64_t)v8;
      goto LABEL_21;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    ++*(_DWORD *)(a1 + 324);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v19, v20);
  ++**(_DWORD **)(a1 + 72);
  context = a2;
  v17 = 0;
  if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
    v10 = 0;
  else
    v10 = a3;
  v18 = v10;
  v11 = *(const __CFArray **)(a1 + 256);
  v22.length = CFArrayGetCount(v11);
  v22.location = 0;
  CFArrayApplyFunction(v11, v22, (CFArrayApplierFunction)__FilterFunctionCopyPropertyForClient, &context);
  v12 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v12)
  {
    --*(_DWORD *)v12;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v19, v20);
  }
  v9 = v17;
  if (!v17)
    v9 = __IOHIDServiceCopyPropertyForClient(a1, a2, a3, 0);
  if (v8 == (const void *)defaultPropertyKeyValue)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
    if (v9)
      v13 = (const void *)v9;
    else
      v13 = (const void *)*MEMORY[0x1E0C9B0D0];
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 312), a2, v13);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    CFRelease(v8);
  }
LABEL_21:
  v14 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v14, v6, 0x3E8u);
  if (*(_QWORD *)(a1 + 464))
    IOHIDAnalyticsEventSetIntegerValueForField();
  return v9;
}

unint64_t _IOHIDGetTimestampDelta(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v6;

  v6 = dword_1ECD379BC;
  if (!dword_1ECD379BC)
  {
    mach_timebase_info((mach_timebase_info_t)&_IOHIDGetTimestampDelta_timebaseInfo);
    v6 = dword_1ECD379BC;
  }
  return (a1 - a2) * (unint64_t)_IOHIDGetTimestampDelta_timebaseInfo / v6 / a3;
}

uint64_t IOHIDAnalyticsEventSetIntegerValueForField()
{
  uint64_t result;

  if (setIntegerValueForFieldFuncPtr)
    return setIntegerValueForFieldFuncPtr();
  return result;
}

void __IOHIDEventSystemCompareServiceFunction(uint64_t a1, const void *a2, uint64_t a3)
{
  const void *v5;
  CFTypeID v6;
  uint64_t v7;
  uint64_t UUID;
  __CFArray *Mutable;
  const __CFAllocator *v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t RegistryID;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v5 = *(const void **)(a3 + 16);
  if (v5
    && (v6 = CFGetTypeID(v5), v6 == IOHIDEventSystemConnectionGetTypeID())
    && (v7 = *(_QWORD *)(a3 + 16)) != 0
    && (UUID = IOHIDEventSystemConnectionGetUUID(*(_QWORD *)(a3 + 16)), _IOHIDServiceIsProtected((uint64_t)a2))
    && !IOHIDServiceCheckEntitlements((uint64_t)a2, v7))
  {
    v11 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 138412546;
      v13 = UUID;
      v14 = 2112;
      RegistryID = IOHIDServiceGetRegistryID((uint64_t)a2);
      _os_log_impl(&dword_18AAAF000, v11, OS_LOG_TYPE_DEFAULT, "Connection: %@ not entitled to match protected service: %@", (uint8_t *)&v12, 0x16u);
    }
  }
  else if (!_IOHIDServiceIsInactive((uint64_t)a2))
  {
    if (IOHIDServiceMatchPropertyTable((uint64_t)a2, *(const __CFDictionary **)(a3 + 8)))
    {
      Mutable = *(__CFArray **)a3;
      if (*(_QWORD *)a3
        || (v10 = CFGetAllocator(a2),
            Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E0C9B378]),
            (*(_QWORD *)a3 = Mutable) != 0))
      {
        CFArrayAppendValue(Mutable, a2);
      }
    }
  }
}

uint64_t __IOHIDEventSystemIsTimeToDispatchEvent(const void *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  int Type;
  unsigned int ReportIntervalForClient;
  unint64_t EventDeadlineForClient;
  unsigned int ReportInterval;
  unint64_t TimeStamp;
  _BOOL8 v12;
  double v13;
  CFTypeID v14;

  if (a2 && _IOHIDServiceContainsReportInterval(a2))
  {
    v6 = _IOHIDServiceCopyConnectionCache(a2, a1);
    if (!v6 || !_IOHIDServiceContainsReportIntervalForClient(a2, a1, v6))
    {
      v14 = CFGetTypeID(a1);
      if (v14 == IOHIDEventSystemConnectionGetTypeID())
      {
        v12 = (int)IOHIDEventSystemConnectionGetType((uint64_t)a1) < 2;
        if (!v6)
          return v12;
      }
      else
      {
        v12 = 1;
        if (!v6)
          return v12;
      }
      goto LABEL_24;
    }
    if (!_IOHIDServiceSupportReportLatency(a2))
    {
      Type = IOHIDEventGetType((uint64_t)a3);
      if (Type != 10 && (Type != 13 || IOHIDEventGetIntegerValue(a3, 0xD0003u) != 1))
      {
        ReportIntervalForClient = _IOHIDServiceGetReportIntervalForClient(a2, a1, v6);
        EventDeadlineForClient = _IOHIDServiceGetEventDeadlineForClient(a2, a1, (uint64_t)v6);
        ReportInterval = _IOHIDServiceGetReportInterval(a2);
        TimeStamp = IOHIDEventGetTimeStamp((uint64_t)a3);
        v12 = 0;
        if (!ReportIntervalForClient || !ReportInterval)
          goto LABEL_24;
        if (EventDeadlineForClient <= TimeStamp)
        {
          v13 = *(double *)&__absoluteTime_to_nanoseconds_factor;
        }
        else if ((uint64_t)(EventDeadlineForClient - TimeStamp) < 0
               || (v13 = *(double *)&__absoluteTime_to_nanoseconds_factor,
                   (double)(1000 * (unint64_t)ReportInterval) * 0.5 <= (double)(unint64_t)((double)(uint64_t)(EventDeadlineForClient - TimeStamp) / *(double *)&__absoluteTime_to_nanoseconds_factor)))
        {
          v12 = 0;
LABEL_24:
          CFRelease(v6);
          return v12;
        }
        _IOHIDServiceSetEventDeadlineForClient(a2, a1, TimeStamp + (unint64_t)(v13 * (double)(1000 * (unint64_t)ReportIntervalForClient)), ReportIntervalForClient, v6);
      }
    }
    v12 = 1;
    goto LABEL_24;
  }
  return 1;
}

uint64_t IOHIDEventSystemConnectionGetTypeID()
{
  return objc_opt_self();
}

uint64_t IOHIDEventGetIntegerValue(_QWORD *a1, unsigned int a2)
{
  return IOHIDEventGetIntegerValueWithOptions(a1, a2, 4026531840);
}

const void *_IOHIDServiceCopyConnectionCache(uint64_t a1, const void *a2)
{
  const void *Value;
  const void *v5;
  uint64_t v6;
  uint64_t v8;
  _OWORD v9[5];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  ++**(_DWORD **)(a1 + 72);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 240), a2);
  v5 = Value;
  if (Value)
    CFRetain(Value);
  v6 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v6)
  {
    --*(_DWORD *)v6;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
  }
  return v5;
}

uint64_t _IOHIDServiceContainsReportInterval(uint64_t a1)
{
  return *(unsigned int *)(a1 + 220);
}

__n64 IOHIDEventGetFloatValueWithOptions(_QWORD *EventWithOptions, unsigned int a2, uint64_t a3)
{
  unsigned int v4;
  __n64 result;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;

  v4 = HIWORD(a2);
  if (!EventWithOptions || a2 >= 0x10000)
  {
    EventWithOptions = (_QWORD *)IOHIDEventGetEventWithOptions(EventWithOptions, HIWORD(a2), a3);
    if (!EventWithOptions)
    {
      result.n64_f64[0] = 0.0;
      return result;
    }
  }
  result.n64_f64[0] = 0.0;
  v6 = EventWithOptions[13];
  switch(v4)
  {
    case 0u:
      switch(a2)
      {
        case 0u:
          LOBYTE(v6) = *(_BYTE *)(v6 + 8);
          goto LABEL_195;
        case 1u:
          v13 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_204;
        case 2u:
          goto LABEL_21;
        case 3u:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 3) & 1;
          goto LABEL_205;
        case 4u:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 4) & 1;
          goto LABEL_205;
        case 5u:
          v14 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_171;
        case 6u:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 6) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 1u:
      switch(a2)
      {
        case 0x10000u:
          goto LABEL_111;
        case 0x10001u:
          goto LABEL_114;
        case 0x10002u:
          goto LABEL_150;
        case 0x10003u:
          goto LABEL_83;
        default:
          return result;
      }
      return result;
    case 2u:
      switch(a2)
      {
        case 0x20000u:
          goto LABEL_131;
        case 0x20001u:
          goto LABEL_122;
        case 0x20002u:
          goto LABEL_123;
        case 0x20003u:
          goto LABEL_144;
        case 0x20004u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 3u:
      switch(a2)
      {
        case 0x30000u:
          goto LABEL_111;
        case 0x30001u:
          goto LABEL_114;
        case 0x30002u:
          goto LABEL_150;
        case 0x30003u:
          goto LABEL_160;
        case 0x30004u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 28);
          goto LABEL_151;
        case 0x30005u:
          LODWORD(v6) = *(_DWORD *)(v6 + 24);
          goto LABEL_195;
        case 0x30006u:
          v7 = (*(_DWORD *)(v6 + 24) >> 1) & 3;
          goto LABEL_205;
        case 0x30007u:
          v7 = (*(_DWORD *)(v6 + 24) >> 3) & 3;
          goto LABEL_205;
        case 0x30008u:
          v14 = *(_DWORD *)(v6 + 24);
LABEL_171:
          v7 = (v14 >> 5) & 1;
          goto LABEL_205;
        case 0x30009u:
          v7 = (*(_DWORD *)(v6 + 24) >> 6) & 7;
          goto LABEL_205;
        case 0x3000Au:
          v7 = (*(_DWORD *)(v6 + 24) >> 9) & 3;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 4u:
      if (a2 == 262146)
        goto LABEL_137;
      if (a2 == 262145)
        goto LABEL_144;
      if (a2 != 0x40000)
        return result;
      goto LABEL_98;
    case 5u:
      if (a2 == 327682)
        goto LABEL_137;
      if (a2 == 327681)
        goto LABEL_144;
      if (a2 != 327680)
        return result;
      goto LABEL_98;
    case 6u:
      switch(a2)
      {
        case 0x60000u:
          goto LABEL_98;
        case 0x60001u:
          goto LABEL_144;
        case 0x60002u:
          goto LABEL_137;
        case 0x60003u:
LABEL_21:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 2) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 7u:
      if (a2 == 458754)
        goto LABEL_137;
      if (a2 == 458753)
        goto LABEL_144;
      if (a2 != 458752)
        return result;
      goto LABEL_98;
    case 9u:
      if (a2 == 589826)
      {
LABEL_137:
        v11 = *(_DWORD *)(v6 + 24);
        goto LABEL_145;
      }
      if (a2 == 589825)
        goto LABEL_144;
      if (a2 != 589824)
        return result;
      goto LABEL_98;
    case 0xAu:
      if (a2 - 655360 > 0xB)
        return result;
      if (a2 == 655363)
      {
LABEL_113:
        result.n64_u32[0] = *(_DWORD *)(v6 + 32);
        goto LABEL_151;
      }
      switch(*(_DWORD *)(v6 + 32))
      {
        case 0:
          switch(a2)
          {
            case 0xA0002u:
              goto LABEL_137;
            case 0xA0001u:
              goto LABEL_144;
            case 0xA0000u:
              goto LABEL_98;
          }
          break;
        case 1:
          if (a2 == 655364)
            goto LABEL_131;
          break;
        case 2:
          switch(a2)
          {
            case 0xA0007u:
              goto LABEL_137;
            case 0xA0006u:
              goto LABEL_144;
            case 0xA0005u:
              goto LABEL_98;
          }
          break;
        case 3:
          switch(a2)
          {
            case 0xA0008u:
              goto LABEL_98;
            case 0xA0009u:
              goto LABEL_144;
            case 0xA000Au:
              goto LABEL_137;
            case 0xA000Bu:
              goto LABEL_138;
            default:
              return result;
          }
        default:
          return result;
      }
      return result;
    case 0xBu:
      switch(a2)
      {
        case 0xB0000u:
          goto LABEL_98;
        case 0xB0001u:
          goto LABEL_144;
        case 0xB0002u:
          goto LABEL_137;
        case 0xB0003u:
          goto LABEL_161;
        case 0xB0004u:
          goto LABEL_113;
        case 0xB0005u:
          goto LABEL_107;
        case 0xB0006u:
          goto LABEL_116;
        case 0xB0007u:
          goto LABEL_162;
        case 0xB0008u:
LABEL_160:
          v7 = HIWORD(*(_DWORD *)(v6 + 8)) & 1;
          goto LABEL_205;
        case 0xB0009u:
          v7 = (*(_DWORD *)(v6 + 8) >> 17) & 1;
          goto LABEL_205;
        case 0xB000Au:
          goto LABEL_186;
        case 0xB000Bu:
          goto LABEL_187;
        case 0xB000Cu:
          goto LABEL_207;
        case 0xB000Du:
        case 0xB000Eu:
        case 0xB000Fu:
        case 0xB0010u:
        case 0xB0011u:
        case 0xB0012u:
        case 0xB0013u:
        case 0xB0014u:
        case 0xB0015u:
        case 0xB001Au:
          v8 = *(_DWORD *)(v6 + 64);
          if (v8)
          {
            if (v8 == 2)
            {
              switch(a2)
              {
                case 0xB0011u:
                  goto LABEL_178;
                case 0xB0012u:
                  goto LABEL_179;
                case 0xB0013u:
                  goto LABEL_188;
                case 0xB0014u:
                  goto LABEL_189;
                case 0xB0015u:
LABEL_213:
                  v11 = *(_DWORD *)(v6 + 84);
                  goto LABEL_145;
                case 0xB001Au:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            else if (v8 == 1)
            {
              switch(a2)
              {
                case 0xB000Fu:
                  goto LABEL_178;
                case 0xB0010u:
                  goto LABEL_179;
                case 0xB0011u:
                  goto LABEL_188;
                case 0xB0012u:
                  goto LABEL_189;
                case 0xB0014u:
                  goto LABEL_213;
                case 0xB0015u:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            return result;
          }
          if (a2 == 720910)
            goto LABEL_179;
          if (a2 != 720909)
            return result;
          goto LABEL_178;
        case 0xB0016u:
          v13 = *(_DWORD *)(v6 + 8);
          goto LABEL_204;
        case 0xB0017u:
          if (!*(_DWORD *)(v6 + 32))
            goto LABEL_207;
          return result;
        case 0xB0018u:
          goto LABEL_159;
        case 0xB0019u:
          v7 = (*(_DWORD *)(v6 + 8) >> 19) & 1;
          goto LABEL_205;
        case 0xB001Bu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 92);
          goto LABEL_151;
        case 0xB001Cu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 96);
          goto LABEL_151;
        case 0xB001Du:
          result.n64_u32[0] = *(_DWORD *)(v6 + 100);
          goto LABEL_151;
        case 0xB001Fu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 64);
          goto LABEL_151;
        default:
          return result;
      }
    case 0xCu:
      switch(a2)
      {
        case 0xC0000u:
          goto LABEL_131;
        case 0xC0001u:
          goto LABEL_150;
        case 0xC0002u:
          goto LABEL_83;
        case 0xC0003u:
          goto LABEL_107;
        case 0xC0004u:
          goto LABEL_113;
        case 0xC0005u:
          v9 = *(unsigned __int8 *)(v6 + 36);
          goto LABEL_164;
        case 0xC0006u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 37);
          goto LABEL_151;
        case 0xC0007u:
          goto LABEL_126;
        case 0xC0008u:
          goto LABEL_119;
        case 0xC0009u:
          goto LABEL_120;
        case 0xC000Au:
          goto LABEL_139;
        case 0xC000Bu:
          goto LABEL_140;
        default:
          return result;
      }
      return result;
    case 0xDu:
      switch(a2)
      {
        case 0xD0000u:
          goto LABEL_98;
        case 0xD0001u:
          goto LABEL_144;
        case 0xD0002u:
          goto LABEL_137;
        case 0xD0003u:
          goto LABEL_107;
        case 0xD0004u:
          goto LABEL_113;
        case 0xD0005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0xEu:
      switch(a2)
      {
        case 0xE0000u:
          goto LABEL_111;
        case 0xE0001u:
        case 0xE0003u:
          if (*(_WORD *)(v6 + 18) == 1)
          {
            v10 = 917507;
            goto LABEL_103;
          }
          if (a2 != 917505 || *(_WORD *)(v6 + 18))
            return result;
          goto LABEL_150;
        case 0xE0002u:
          goto LABEL_114;
        default:
          return result;
      }
    case 0xFu:
      if (a2 != 983040)
        return result;
      goto LABEL_98;
    case 0x10u:
      switch(a2)
      {
        case 0x100000u:
          goto LABEL_107;
        case 0x100001u:
          goto LABEL_72;
        case 0x100002u:
          goto LABEL_112;
        case 0x100003u:
          goto LABEL_98;
        case 0x100004u:
          goto LABEL_144;
        case 0x100005u:
          goto LABEL_115;
        case 0x100006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x11u:
      switch(a2)
      {
        case 0x110000u:
          goto LABEL_98;
        case 0x110001u:
          goto LABEL_144;
        case 0x110002u:
          goto LABEL_137;
        case 0x110003u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x12u:
      if (a2 == 1179649)
        goto LABEL_144;
      if (a2 != 1179648)
        return result;
      goto LABEL_131;
    case 0x13u:
      switch(a2)
      {
        case 0x130000u:
          goto LABEL_98;
        case 0x130001u:
          goto LABEL_144;
        case 0x130002u:
          goto LABEL_137;
        case 0x130003u:
          goto LABEL_91;
        case 0x130004u:
          goto LABEL_112;
        case 0x130005u:
          goto LABEL_153;
        case 0x130006u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x14u:
      switch(a2)
      {
        case 0x140000u:
          goto LABEL_98;
        case 0x140001u:
          goto LABEL_144;
        case 0x140002u:
          goto LABEL_137;
        case 0x140003u:
          goto LABEL_107;
        case 0x140004u:
          goto LABEL_113;
        case 0x140005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x15u:
      switch(a2)
      {
        case 0x150000u:
          goto LABEL_98;
        case 0x150001u:
          goto LABEL_144;
        case 0x150002u:
          goto LABEL_137;
        case 0x150003u:
          goto LABEL_107;
        case 0x150004u:
          goto LABEL_113;
        case 0x150005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x17u:
      switch(a2)
      {
        case 0x170000u:
          goto LABEL_107;
        case 0x170001u:
          goto LABEL_72;
        case 0x170002u:
          goto LABEL_112;
        case 0x170003u:
          goto LABEL_98;
        case 0x170004u:
          goto LABEL_144;
        case 0x170005u:
          goto LABEL_115;
        case 0x170006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x18u:
      if (a2 == 1572864)
        goto LABEL_131;
      if (a2 == 1572865)
      {
        v7 = *(unsigned __int16 *)(v6 + 8) >> 15;
LABEL_205:
        result.n64_f64[0] = (double)v7;
      }
      return result;
    case 0x19u:
      if (a2 == 1638402)
      {
LABEL_107:
        result.n64_u32[0] = *(_DWORD *)(v6 + 28);
        goto LABEL_151;
      }
      if (a2 == 1638401)
      {
LABEL_83:
        result.n64_u32[0] = *(_DWORD *)(v6 + 24);
        goto LABEL_151;
      }
      if (a2 != 1638400)
        return result;
      goto LABEL_98;
    case 0x1Au:
      switch(a2)
      {
        case 0x1A0002u:
          goto LABEL_83;
        case 0x1A0001u:
LABEL_109:
          result.n64_u8[0] = *(_BYTE *)(v6 + 20);
          goto LABEL_151;
        case 0x1A0000u:
          goto LABEL_131;
      }
      return result;
    case 0x1Bu:
      switch(a2)
      {
        case 0x1B0000u:
          goto LABEL_107;
        case 0x1B0001u:
          goto LABEL_72;
        case 0x1B0002u:
          goto LABEL_112;
        case 0x1B0003u:
          goto LABEL_98;
        case 0x1B0004u:
          goto LABEL_144;
        case 0x1B0005u:
          goto LABEL_115;
        default:
          return result;
      }
      return result;
    case 0x1Cu:
      switch(a2)
      {
        case 0x1C0000u:
          goto LABEL_107;
        case 0x1C0001u:
LABEL_72:
          result.n64_u16[0] = *(_WORD *)(v6 + 32);
          goto LABEL_151;
        case 0x1C0002u:
          goto LABEL_112;
        case 0x1C0003u:
          goto LABEL_98;
        case 0x1C0004u:
          goto LABEL_144;
        case 0x1C0005u:
LABEL_115:
          result.n64_u16[0] = *(_WORD *)(v6 + 34);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Du:
      switch(a2)
      {
        case 0x1D0000u:
          goto LABEL_131;
        case 0x1D0001u:
          goto LABEL_144;
        case 0x1D0002u:
          result.n64_u16[0] = *(_WORD *)(v6 + 24);
          goto LABEL_151;
        case 0x1D0003u:
          result.n64_u16[0] = *(_WORD *)(v6 + 26);
          goto LABEL_151;
        case 0x1D0004u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 32);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Eu:
      if (a2 == 1966082)
        goto LABEL_83;
      if (a2 == 1966081)
        goto LABEL_144;
      if (a2 != 1966080)
        return result;
      goto LABEL_131;
    case 0x1Fu:
      if (a2 == 2031617)
        goto LABEL_150;
      if (a2 != 2031616)
        return result;
      goto LABEL_98;
    case 0x20u:
      switch(a2)
      {
        case 0x200000u:
          goto LABEL_131;
        case 0x200001u:
          goto LABEL_144;
        case 0x200002u:
          goto LABEL_83;
        case 0x200003u:
          goto LABEL_138;
        default:
          return result;
      }
      return result;
    case 0x21u:
      if (a2 == 2162689)
        goto LABEL_144;
      if (a2 != 2162688)
        return result;
      goto LABEL_131;
    case 0x22u:
      if (a2 == 2228225)
        goto LABEL_144;
      if (a2 != 2228224)
        return result;
      goto LABEL_131;
    case 0x23u:
      switch(a2)
      {
        case 0x230000u:
          goto LABEL_131;
        case 0x230001u:
          goto LABEL_144;
        case 0x230002u:
          goto LABEL_137;
        case 0x230003u:
LABEL_138:
          v11 = *(_DWORD *)(v6 + 28);
          goto LABEL_145;
        case 0x230004u:
LABEL_91:
          v11 = *(_DWORD *)(v6 + 32);
          goto LABEL_145;
        case 0x230005u:
          v11 = *(_DWORD *)(v6 + 44);
          goto LABEL_145;
        case 0x230006u:
          v11 = *(_DWORD *)(v6 + 48);
          goto LABEL_145;
        case 0x230007u:
LABEL_112:
          v11 = *(_DWORD *)(v6 + 36);
          goto LABEL_145;
        case 0x230008u:
LABEL_153:
          v11 = *(_DWORD *)(v6 + 40);
          goto LABEL_145;
        case 0x230009u:
LABEL_178:
          v11 = *(_DWORD *)(v6 + 68);
          goto LABEL_145;
        case 0x23000Au:
LABEL_188:
          v11 = *(_DWORD *)(v6 + 76);
          goto LABEL_145;
        case 0x23000Bu:
LABEL_179:
          v11 = *(_DWORD *)(v6 + 72);
          goto LABEL_145;
        case 0x23000Cu:
LABEL_189:
          v11 = *(_DWORD *)(v6 + 80);
          goto LABEL_145;
        case 0x23000Du:
LABEL_186:
          v11 = *(_DWORD *)(v6 + 52);
          goto LABEL_145;
        case 0x23000Eu:
LABEL_187:
          v11 = *(_DWORD *)(v6 + 56);
          goto LABEL_145;
        case 0x23000Fu:
LABEL_207:
          v11 = *(_DWORD *)(v6 + 60);
          goto LABEL_145;
        case 0x230010u:
          v11 = *(_DWORD *)(v6 + 64);
          goto LABEL_145;
        case 0x230011u:
          LOBYTE(v6) = *(_BYTE *)(v6 + 84);
LABEL_195:
          v7 = v6 & 1;
          goto LABEL_205;
        case 0x230012u:
          v13 = *(unsigned __int8 *)(v6 + 84);
LABEL_204:
          v7 = (v13 >> 1) & 1;
          goto LABEL_205;
        case 0x230013u:
LABEL_190:
          v11 = *(_DWORD *)(v6 + 88);
          goto LABEL_145;
        case 0x230014u:
          v11 = *(_DWORD *)(v6 + 92);
          goto LABEL_145;
        case 0x230015u:
          v11 = *(_DWORD *)(v6 + 96);
          goto LABEL_145;
        case 0x230016u:
          v11 = *(_DWORD *)(v6 + 100);
          goto LABEL_145;
        case 0x230017u:
          v11 = *(_DWORD *)(v6 + 104);
          goto LABEL_145;
        case 0x230018u:
          v11 = *(_DWORD *)(v6 + 108);
          goto LABEL_145;
        default:
          return result;
      }
      return result;
    case 0x24u:
      if (a2 == 2359297)
        goto LABEL_150;
      if (a2 != 2359296)
        return result;
      goto LABEL_98;
    case 0x26u:
      switch(a2)
      {
        case 0x260002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          goto LABEL_151;
        case 0x260001u:
          goto LABEL_144;
        case 0x260000u:
LABEL_98:
          v11 = *(_DWORD *)(v6 + 16);
          goto LABEL_145;
      }
      return result;
    case 0x27u:
      if (a2 - 2555905 >= 2)
      {
        if (a2 != 2555904)
          return result;
LABEL_131:
        result.n64_u32[0] = *(_DWORD *)(v6 + 16);
        goto LABEL_151;
      }
      v12 = *(_DWORD *)(v6 + 16);
      if (v12 != 1)
      {
        if (v12)
        {
          if (a2 != 2555905 || v12 != 2)
            return result;
        }
        else
        {
          v10 = 2555905;
LABEL_103:
          if (a2 != v10)
            return result;
        }
LABEL_150:
        result.n64_u32[0] = *(_DWORD *)(v6 + 20);
LABEL_151:
        result.n64_f64[0] = (double)result.n64_u64[0];
        return result;
      }
      if (a2 == 2555906)
      {
LABEL_144:
        v11 = *(_DWORD *)(v6 + 20);
LABEL_145:
        result.n64_f64[0] = (double)v11 * 0.0000152587891;
        if (v11 == 0x80000000)
          result.n64_f64[0] = NAN;
      }
      return result;
    case 0x28u:
      switch(a2)
      {
        case 0x280000u:
          result.n64_u16[0] = *(_WORD *)(v6 + 64);
          goto LABEL_151;
        case 0x280001u:
          result.n64_u16[0] = *(_WORD *)(v6 + 66);
          goto LABEL_151;
        case 0x280002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 16);
          break;
        case 0x280003u:
LABEL_122:
          result.n64_u8[0] = *(_BYTE *)(v6 + 24);
          goto LABEL_151;
        case 0x280004u:
LABEL_123:
          result.n64_u8[0] = *(_BYTE *)(v6 + 25);
          goto LABEL_151;
        case 0x280005u:
          goto LABEL_107;
        case 0x280006u:
          goto LABEL_113;
        case 0x280007u:
LABEL_116:
          result.n64_u32[0] = *(_DWORD *)(v6 + 36);
          goto LABEL_151;
        case 0x280008u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 44);
          goto LABEL_151;
        case 0x280009u:
LABEL_161:
          result.n64_u32[0] = *(_DWORD *)(v6 + 48);
          goto LABEL_151;
        case 0x28000Au:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          goto LABEL_151;
        case 0x28000Bu:
          result.n64_u8[0] = *(_BYTE *)(v6 + 26);
          goto LABEL_151;
        case 0x28000Cu:
LABEL_162:
          result.n64_u32[0] = *(_DWORD *)(v6 + 40);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x29u:
      switch(a2)
      {
        case 0x290000u:
          goto LABEL_131;
        case 0x290001u:
          goto LABEL_109;
        case 0x290002u:
          goto LABEL_124;
        case 0x290003u:
          goto LABEL_125;
        case 0x290004u:
LABEL_126:
          result.n64_u64[0] = *(unint64_t *)(v6 + 40);
          break;
        case 0x290005u:
          goto LABEL_119;
        case 0x290006u:
          goto LABEL_120;
        default:
          return result;
      }
      return result;
    case 0x2Au:
      switch(a2)
      {
        case 0x2A0000u:
LABEL_111:
          result.n64_u16[0] = *(_WORD *)(v6 + 16);
          goto LABEL_151;
        case 0x2A0001u:
LABEL_114:
          result.n64_u16[0] = *(_WORD *)(v6 + 18);
          goto LABEL_151;
        case 0x2A0002u:
LABEL_124:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          break;
        case 0x2A0003u:
LABEL_125:
          result.n64_u64[0] = *(unint64_t *)(v6 + 32);
          break;
        case 0x2A0004u:
          v9 = *(unsigned __int8 *)(v6 + 40);
LABEL_164:
          if (v9)
            result.n64_f64[0] = 1.0;
          break;
        case 0x2A0005u:
LABEL_159:
          result.n64_u32[0] = *(_DWORD *)(v6 + 44);
          goto LABEL_151;
        case 0x2A0006u:
LABEL_119:
          result.n64_u64[0] = *(unint64_t *)(v6 + 48);
          break;
        case 0x2A0007u:
LABEL_120:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          break;
        case 0x2A0008u:
LABEL_139:
          result.n64_u64[0] = *(unint64_t *)(v6 + 64);
          break;
        case 0x2A0009u:
LABEL_140:
          result.n64_u64[0] = *(unint64_t *)(v6 + 72);
          break;
        default:
          return result;
      }
      return result;
    default:
      return result;
  }
}

uint64_t IOHIDEventGetIntegerValueWithOptions(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  double v12;
  unint64_t v13;
  unint64_t v14;

  v4 = a1;
  v5 = HIWORD(a2);
  if (a1 && a2 < 0x10000
    || (result = IOHIDEventGetEventWithOptions(a1, HIWORD(a2), a3), (v4 = (_QWORD *)result) != 0))
  {
    result = 0;
    v7 = v4[13];
    switch(v5)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            LOBYTE(v7) = *(_BYTE *)(v7 + 8);
            goto LABEL_189;
          case 1u:
            v13 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_198;
          case 2u:
            goto LABEL_20;
          case 3u:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 3) & 1;
            break;
          case 4u:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 4) & 1;
            break;
          case 5u:
            v14 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_164;
          case 6u:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 6) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x10001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x10002u:
            return *(unsigned int *)(v7 + 20);
          case 0x10003u:
            return *(unsigned int *)(v7 + 24);
          case 0x10004u:
            goto LABEL_75;
          default:
            return 0;
        }
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            return *(unsigned int *)(v7 + 16);
          case 0x20001u:
            goto LABEL_120;
          case 0x20002u:
            goto LABEL_121;
          case 0x20003u:
            goto LABEL_142;
          case 0x20004u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x30001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x30002u:
            return *(unsigned int *)(v7 + 20);
          case 0x30003u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0x30004u:
            result = *(unsigned __int8 *)(v7 + 28);
            break;
          case 0x30005u:
            LODWORD(v7) = *(_DWORD *)(v7 + 24);
            goto LABEL_189;
          case 0x30006u:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 1) & 3;
            break;
          case 0x30007u:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 3) & 3;
            break;
          case 0x30008u:
            v14 = *(unsigned int *)(v7 + 24);
LABEL_164:
            result = (v14 >> 5) & 1;
            break;
          case 0x30009u:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 6) & 7;
            break;
          case 0x3000Au:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 9) & 3;
            break;
          default:
            return 0;
        }
        return result;
      case 4u:
        if (a2 == 262146)
          goto LABEL_135;
        if (a2 == 262145)
          goto LABEL_142;
        if (a2 != 0x40000)
          return 0;
        goto LABEL_96;
      case 5u:
        if (a2 == 327682)
          goto LABEL_135;
        if (a2 == 327681)
          goto LABEL_142;
        if (a2 != 327680)
          return 0;
        goto LABEL_96;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_96;
          case 0x60001u:
            goto LABEL_142;
          case 0x60002u:
            goto LABEL_135;
          case 0x60003u:
LABEL_20:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 2) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 7u:
        if (a2 == 458754)
          goto LABEL_135;
        if (a2 == 458753)
          goto LABEL_142;
        if (a2 != 458752)
          return 0;
        goto LABEL_96;
      case 9u:
        if (a2 == 589826)
        {
LABEL_135:
          v10 = *(_DWORD *)(v7 + 24);
          goto LABEL_143;
        }
        if (a2 == 589825)
          goto LABEL_142;
        if (a2 != 589824)
          return 0;
        goto LABEL_96;
      case 0xAu:
        if (a2 - 655360 > 0xB)
          return 0;
        if (a2 != 655363)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              if (a2 == 655362)
                goto LABEL_135;
              if (a2 == 655361)
                goto LABEL_142;
              if (a2 != 655360)
                return 0;
              goto LABEL_96;
            case 1:
              if (a2 == 655364)
                return *(unsigned int *)(v7 + 16);
              return 0;
            case 2:
              if (a2 == 655367)
                goto LABEL_135;
              if (a2 == 655366)
                goto LABEL_142;
              if (a2 != 655365)
                return 0;
              goto LABEL_96;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_96;
                case 0xA0009u:
                  goto LABEL_142;
                case 0xA000Au:
                  goto LABEL_135;
                case 0xA000Bu:
                  goto LABEL_136;
                default:
                  return 0;
              }
            default:
              return 0;
          }
        }
        return *(unsigned int *)(v7 + 32);
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_96;
          case 0xB0001u:
            goto LABEL_142;
          case 0xB0002u:
            goto LABEL_135;
          case 0xB0003u:
            goto LABEL_157;
          case 0xB0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xB0005u:
            return *(unsigned int *)(v7 + 28);
          case 0xB0006u:
            goto LABEL_114;
          case 0xB0007u:
            goto LABEL_158;
          case 0xB0008u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0xB0009u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 17) & 1;
          case 0xB000Au:
            goto LABEL_180;
          case 0xB000Bu:
            goto LABEL_181;
          case 0xB000Cu:
            goto LABEL_202;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            v8 = *(_DWORD *)(v7 + 64);
            if (v8)
            {
              if (v8 == 2)
              {
                result = 0;
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_171;
                  case 0xB0012u:
                    goto LABEL_172;
                  case 0xB0013u:
                    goto LABEL_182;
                  case 0xB0014u:
                    goto LABEL_183;
                  case 0xB0015u:
LABEL_209:
                    v10 = *(_DWORD *)(v7 + 84);
                    goto LABEL_143;
                  case 0xB001Au:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              else
              {
                if (v8 != 1)
                  return 0;
                result = 0;
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_171;
                  case 0xB0010u:
                    goto LABEL_172;
                  case 0xB0011u:
                    goto LABEL_182;
                  case 0xB0012u:
                    goto LABEL_183;
                  case 0xB0014u:
                    goto LABEL_209;
                  case 0xB0015u:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910)
              goto LABEL_172;
            if (a2 != 720909)
              return 0;
            goto LABEL_171;
          case 0xB0016u:
            v13 = *(unsigned int *)(v7 + 8);
            goto LABEL_198;
          case 0xB0017u:
            if (*(_DWORD *)(v7 + 32))
              return 0;
            goto LABEL_202;
          case 0xB0018u:
            return *(unsigned int *)(v7 + 44);
          case 0xB0019u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 19) & 1;
          case 0xB001Bu:
            return *(unsigned int *)(v7 + 92);
          case 0xB001Cu:
            return *(unsigned int *)(v7 + 96);
          case 0xB001Du:
            return *(unsigned int *)(v7 + 100);
          case 0xB001Eu:
            return (*(_DWORD *)(v7 + 40) >> 13) & 0x18000 | (*(_DWORD *)(v7 + 40) >> 20) & 0x400u | (*(_DWORD *)(v7 + 40) >> 31 << 23);
          case 0xB001Fu:
            return *(unsigned int *)(v7 + 64);
          default:
            return 0;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            return *(unsigned int *)(v7 + 16);
          case 0xC0001u:
            return *(unsigned int *)(v7 + 20);
          case 0xC0002u:
            return *(unsigned int *)(v7 + 24);
          case 0xC0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xC0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xC0005u:
            result = *(unsigned __int8 *)(v7 + 36);
            break;
          case 0xC0006u:
            result = *(unsigned __int8 *)(v7 + 37);
            break;
          case 0xC0007u:
            goto LABEL_124;
          case 0xC0008u:
            goto LABEL_117;
          case 0xC0009u:
            goto LABEL_118;
          case 0xC000Au:
            goto LABEL_137;
          case 0xC000Bu:
            goto LABEL_138;
          default:
            return 0;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_96;
          case 0xD0001u:
            goto LABEL_142;
          case 0xD0002u:
            goto LABEL_135;
          case 0xD0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xD0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xD0005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              v9 = 917507;
              goto LABEL_101;
            }
            result = 0;
            if (a2 != 917505 || *(_WORD *)(v7 + 18))
              return result;
            return *(unsigned int *)(v7 + 20);
          case 0xE0002u:
            return *(unsigned __int16 *)(v7 + 18);
          default:
            return 0;
        }
      case 0xFu:
        if (a2 != 983040)
          return 0;
        goto LABEL_96;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            return *(unsigned int *)(v7 + 28);
          case 0x100001u:
            goto LABEL_71;
          case 0x100002u:
            goto LABEL_110;
          case 0x100003u:
            goto LABEL_96;
          case 0x100004u:
            goto LABEL_142;
          case 0x100005u:
            goto LABEL_113;
          case 0x100006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_96;
          case 0x110001u:
            goto LABEL_142;
          case 0x110002u:
            goto LABEL_135;
          case 0x110003u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x12u:
        if (a2 == 1179649)
          goto LABEL_142;
        if (a2 != 1179648)
          return 0;
        return *(unsigned int *)(v7 + 16);
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_96;
          case 0x130001u:
            goto LABEL_142;
          case 0x130002u:
            goto LABEL_135;
          case 0x130003u:
            goto LABEL_89;
          case 0x130004u:
            goto LABEL_110;
          case 0x130005u:
            goto LABEL_149;
          case 0x130006u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_96;
          case 0x140001u:
            goto LABEL_142;
          case 0x140002u:
            goto LABEL_135;
          case 0x140003u:
            return *(unsigned int *)(v7 + 28);
          case 0x140004u:
            return *(unsigned int *)(v7 + 32);
          case 0x140005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_96;
          case 0x150001u:
            goto LABEL_142;
          case 0x150002u:
            goto LABEL_135;
          case 0x150003u:
            return *(unsigned int *)(v7 + 28);
          case 0x150004u:
            return *(unsigned int *)(v7 + 32);
          case 0x150005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            return *(unsigned int *)(v7 + 28);
          case 0x170001u:
            goto LABEL_71;
          case 0x170002u:
            goto LABEL_110;
          case 0x170003u:
            goto LABEL_96;
          case 0x170004u:
            goto LABEL_142;
          case 0x170005u:
            goto LABEL_113;
          case 0x170006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x18u:
        if (a2 == 1572864)
          return *(unsigned int *)(v7 + 16);
        if (a2 != 1572865)
          return 0;
        return (unint64_t)*(unsigned __int16 *)(v7 + 8) >> 15;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
            return *(unsigned int *)(v7 + 28);
          case 0x190001u:
            return *(unsigned int *)(v7 + 24);
          case 0x190000u:
            goto LABEL_96;
        }
        return 0;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1A0001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x1A0000u:
            return *(unsigned int *)(v7 + 16);
        }
        return 0;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1B0001u:
            goto LABEL_71;
          case 0x1B0002u:
            goto LABEL_110;
          case 0x1B0003u:
            goto LABEL_96;
          case 0x1B0004u:
            goto LABEL_142;
          case 0x1B0005u:
            goto LABEL_113;
          default:
            return 0;
        }
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1C0001u:
LABEL_71:
            result = *(unsigned __int16 *)(v7 + 32);
            break;
          case 0x1C0002u:
            goto LABEL_110;
          case 0x1C0003u:
            goto LABEL_96;
          case 0x1C0004u:
            goto LABEL_142;
          case 0x1C0005u:
LABEL_113:
            result = *(unsigned __int16 *)(v7 + 34);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1D0001u:
            goto LABEL_142;
          case 0x1D0002u:
            result = *(unsigned __int16 *)(v7 + 24);
            break;
          case 0x1D0003u:
            result = *(unsigned __int16 *)(v7 + 26);
            break;
          case 0x1D0004u:
            result = *(unsigned __int8 *)(v7 + 32);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1E0001u:
            goto LABEL_142;
          case 0x1E0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1E0003u:
LABEL_75:
            if (*(_DWORD *)(v7 + 24) < 8u)
              return 0;
            result = *(_QWORD *)(v7 + 28);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617)
          return *(unsigned int *)(v7 + 20);
        if (a2 != 2031616)
          return 0;
        goto LABEL_96;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            return *(unsigned int *)(v7 + 16);
          case 0x200001u:
            goto LABEL_142;
          case 0x200002u:
            return *(unsigned int *)(v7 + 24);
          case 0x200003u:
            goto LABEL_136;
          default:
            return 0;
        }
      case 0x21u:
        if (a2 == 2162689)
          goto LABEL_142;
        if (a2 != 2162688)
          return 0;
        return *(unsigned int *)(v7 + 16);
      case 0x22u:
        if (a2 == 2228225)
          goto LABEL_142;
        if (a2 != 2228224)
          return 0;
        return *(unsigned int *)(v7 + 16);
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            return *(unsigned int *)(v7 + 16);
          case 0x230001u:
            goto LABEL_142;
          case 0x230002u:
            goto LABEL_135;
          case 0x230003u:
LABEL_136:
            v10 = *(_DWORD *)(v7 + 28);
            goto LABEL_143;
          case 0x230004u:
LABEL_89:
            v10 = *(_DWORD *)(v7 + 32);
            goto LABEL_143;
          case 0x230005u:
            v10 = *(_DWORD *)(v7 + 44);
            goto LABEL_143;
          case 0x230006u:
            v10 = *(_DWORD *)(v7 + 48);
            goto LABEL_143;
          case 0x230007u:
LABEL_110:
            v10 = *(_DWORD *)(v7 + 36);
            goto LABEL_143;
          case 0x230008u:
LABEL_149:
            v10 = *(_DWORD *)(v7 + 40);
            goto LABEL_143;
          case 0x230009u:
LABEL_171:
            v10 = *(_DWORD *)(v7 + 68);
            goto LABEL_143;
          case 0x23000Au:
LABEL_182:
            v10 = *(_DWORD *)(v7 + 76);
            goto LABEL_143;
          case 0x23000Bu:
LABEL_172:
            v10 = *(_DWORD *)(v7 + 72);
            goto LABEL_143;
          case 0x23000Cu:
LABEL_183:
            v10 = *(_DWORD *)(v7 + 80);
            goto LABEL_143;
          case 0x23000Du:
LABEL_180:
            v10 = *(_DWORD *)(v7 + 52);
            goto LABEL_143;
          case 0x23000Eu:
LABEL_181:
            v10 = *(_DWORD *)(v7 + 56);
            goto LABEL_143;
          case 0x23000Fu:
LABEL_202:
            v10 = *(_DWORD *)(v7 + 60);
            goto LABEL_143;
          case 0x230010u:
            v10 = *(_DWORD *)(v7 + 64);
            goto LABEL_143;
          case 0x230011u:
            LOBYTE(v7) = *(_BYTE *)(v7 + 84);
LABEL_189:
            result = v7 & 1;
            break;
          case 0x230012u:
            v13 = *(unsigned __int8 *)(v7 + 84);
LABEL_198:
            result = (v13 >> 1) & 1;
            break;
          case 0x230013u:
LABEL_184:
            v10 = *(_DWORD *)(v7 + 88);
            goto LABEL_143;
          case 0x230014u:
            v10 = *(_DWORD *)(v7 + 92);
            goto LABEL_143;
          case 0x230015u:
            v10 = *(_DWORD *)(v7 + 96);
            goto LABEL_143;
          case 0x230016u:
            v10 = *(_DWORD *)(v7 + 100);
            goto LABEL_143;
          case 0x230017u:
            v10 = *(_DWORD *)(v7 + 104);
            goto LABEL_143;
          case 0x230018u:
            v10 = *(_DWORD *)(v7 + 108);
            goto LABEL_143;
          default:
            return 0;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
          return *(unsigned int *)(v7 + 20);
        if (a2 != 2359296)
          return 0;
        goto LABEL_96;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            return *(_QWORD *)(v7 + 24);
          case 0x260001u:
            goto LABEL_142;
          case 0x260000u:
LABEL_96:
            v10 = *(_DWORD *)(v7 + 16);
            goto LABEL_143;
        }
        return 0;
      case 0x27u:
        if (a2 - 2555905 >= 2)
        {
          if (a2 == 2555904)
            return *(unsigned int *)(v7 + 16);
          return 0;
        }
        v11 = *(_DWORD *)(v7 + 16);
        if (v11 == 1)
        {
          if (a2 != 2555906)
            return 0;
LABEL_142:
          v10 = *(_DWORD *)(v7 + 20);
LABEL_143:
          if (v10 == 0x80000000)
            result = 0xFFFFFFFF80000000;
          else
            result = (uint64_t)(v10 + (v10 < 0 ? 0xFFFF : 0)) >> 16;
        }
        else
        {
          if (!v11)
          {
            v9 = 2555905;
LABEL_101:
            if (a2 != v9)
              return 0;
            return *(unsigned int *)(v7 + 20);
          }
          result = 0;
          if (a2 == 2555905 && v11 == 2)
            return *(unsigned int *)(v7 + 20);
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            result = *(unsigned __int16 *)(v7 + 64);
            break;
          case 0x280001u:
            result = *(unsigned __int16 *)(v7 + 66);
            break;
          case 0x280002u:
            v12 = *(double *)(v7 + 16);
            goto LABEL_176;
          case 0x280003u:
LABEL_120:
            result = *(unsigned __int8 *)(v7 + 24);
            break;
          case 0x280004u:
LABEL_121:
            result = *(unsigned __int8 *)(v7 + 25);
            break;
          case 0x280005u:
            return *(unsigned int *)(v7 + 28);
          case 0x280006u:
            return *(unsigned int *)(v7 + 32);
          case 0x280007u:
LABEL_114:
            result = *(unsigned int *)(v7 + 36);
            break;
          case 0x280008u:
            result = *(unsigned __int8 *)(v7 + 44);
            break;
          case 0x280009u:
LABEL_157:
            result = *(unsigned int *)(v7 + 48);
            break;
          case 0x28000Au:
            result = *(_QWORD *)(v7 + 56);
            break;
          case 0x28000Bu:
            result = *(unsigned __int8 *)(v7 + 26);
            break;
          case 0x28000Cu:
LABEL_158:
            result = *(unsigned int *)(v7 + 40);
            break;
          default:
            return 0;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            return *(unsigned int *)(v7 + 16);
          case 0x290001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x290002u:
            goto LABEL_122;
          case 0x290003u:
            goto LABEL_123;
          case 0x290004u:
LABEL_124:
            v12 = *(double *)(v7 + 40);
            goto LABEL_176;
          case 0x290005u:
            goto LABEL_117;
          case 0x290006u:
            goto LABEL_118;
          default:
            return 0;
        }
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x2A0001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x2A0002u:
LABEL_122:
            v12 = *(double *)(v7 + 24);
            goto LABEL_176;
          case 0x2A0003u:
LABEL_123:
            v12 = *(double *)(v7 + 32);
            goto LABEL_176;
          case 0x2A0004u:
            return *(unsigned __int8 *)(v7 + 40);
          case 0x2A0005u:
            return *(unsigned int *)(v7 + 44);
          case 0x2A0006u:
LABEL_117:
            v12 = *(double *)(v7 + 48);
            goto LABEL_176;
          case 0x2A0007u:
LABEL_118:
            v12 = *(double *)(v7 + 56);
            goto LABEL_176;
          case 0x2A0008u:
LABEL_137:
            v12 = *(double *)(v7 + 64);
            goto LABEL_176;
          case 0x2A0009u:
LABEL_138:
            v12 = *(double *)(v7 + 72);
LABEL_176:
            result = (uint64_t)v12;
            break;
          default:
            return 0;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

uint64_t IOHIDEventGetEventWithOptions(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;
  uint64_t EventWithOptions;

  v3 = a1;
  if (*(_DWORD *)(a1[13] + 4) != (_DWORD)a2)
  {
    if (((a1[3] >> a2) & 1) != 0 && (v5 = (const __CFArray *)a1[9]) != 0 && (Count = CFArrayGetCount(v5), Count >= 1))
    {
      v8 = Count;
      v9 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3[9], v9);
        EventWithOptions = IOHIDEventGetEventWithOptions(ValueAtIndex, a2, a3);
        if (EventWithOptions)
          break;
        if (v8 == ++v9)
          return 0;
      }
      return EventWithOptions;
    }
    else
    {
      return 0;
    }
  }
  return (uint64_t)v3;
}

uint64_t IOHIDEventSystemConnectionGetUUID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

uint64_t IOHIDEventSystemConnectionGetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 176);
}

uint64_t _IOHIDServiceMatchPropertyTable(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  uint64_t result;
  uint64_t context;
  uint64_t v6;
  CFDictionaryRef v7;

  v7 = theDict;
  context = a1;
  v6 = 1;
  if ((*(_BYTE *)(a1 + 224) & 1) != 0)
    return 0;
  if (!a3 && *(_DWORD *)(a1 + 300))
  {
    if (theDict)
    {
      result = CFDictionaryContainsKey(theDict, CFSTR("Hidden"));
      if (!(_DWORD)result)
        return result;
      goto LABEL_4;
    }
    return 0;
  }
  if (!theDict)
    return 1;
LABEL_4:
  result = CFDictionaryGetCount(theDict);
  if (result)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__IOHIDServiceComparePropertyFunction, &context);
    return v6;
  }
  return result;
}

uint64_t _IOHIDServiceIsInactive(uint64_t a1)
{
  return *(_DWORD *)(a1 + 224) & 1;
}

uint64_t IOHIDServiceMatchPropertyTable(uint64_t a1, const __CFDictionary *a2)
{
  return _IOHIDServiceMatchPropertyTable(a1, a2, 0);
}

BOOL _IOHIDServiceIsProtected(uint64_t a1)
{
  return *(_DWORD *)(a1 + 304) || *(_QWORD *)(a1 + 64) != 0;
}

uint64_t _IOHIDServiceGetReportIntervalForClient(uint64_t a1, const void *a2, _QWORD *a3)
{
  _QWORD *v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  char v9;
  CFTypeID v10;
  uint64_t v11;
  char v12;
  uint64_t v14;
  unsigned int valuePtr;
  _OWORD v16[5];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v16);
  ++**(_DWORD **)(a1 + 72);
  v6 = a3;
  if (a3 || (v6 = _IOHIDServiceCopyConnectionCache(a1, a2)) != 0)
  {
    v7 = (const __CFNumber *)IOHIDServiceConnectionCacheCopyValueForKey(v6, CFSTR("ReportInterval"));
    if (v7)
    {
      v8 = v7;
      CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr);
      CFRelease(v8);
      v9 = 1;
      goto LABEL_12;
    }
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  v10 = CFGetTypeID(a2);
  if (v10 == IOHIDEventSystemConnectionGetTypeID() && IOHIDEventSystemConnectionGetType((uint64_t)a2) == 3)
    valuePtr = 0;
  else
    valuePtr = -1;
LABEL_12:
  v11 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v11)
  {
    --*(_DWORD *)v11;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v16);
  }
  v12 = v9 ^ 1;
  if (v6 == a3)
    v12 = 1;
  if ((v12 & 1) == 0)
    CFRelease(v6);
  return valuePtr;
}

CFTypeRef IOHIDServiceConnectionCacheCopyValueForKey(_QWORD *a1, const void *a2)
{
  const void *v4;
  const __CFDictionary *v6;
  const void *Value;
  const void *v8;

  if (CFEqual(CFSTR("ReportInterval"), a2))
  {
    v4 = (const void *)a1[3];
    if (!v4)
      return 0;
    return CFRetain(v4);
  }
  if (CFEqual(CFSTR("BatchInterval"), a2))
  {
    v4 = (const void *)a1[4];
    if (v4)
      return CFRetain(v4);
  }
  else
  {
    v6 = (const __CFDictionary *)a1[5];
    if (v6)
    {
      Value = CFDictionaryGetValue(v6, a2);
      v8 = Value;
      if (Value)
        CFRetain(Value);
      return v8;
    }
  }
  return 0;
}

uint64_t _IOHIDLogCategory(unsigned int a1)
{
  if (a1 >= 0xF)
    _IOHIDLogCategory_cold_1();
  if (_IOHIDLogCategory_onceToken != -1)
    dispatch_once(&_IOHIDLogCategory_onceToken, &__block_literal_global_6);
  return _IOHIDLogCategory_log[a1];
}

uint64_t IOHIDServiceCheckEntitlements(uint64_t a1, uint64_t a2)
{
  _BYTE *Entitlements;
  _BYTE *v5;
  const __CFArray *v7;
  uint64_t v8;
  uint64_t v9;
  CFRange v10;

  Entitlements = (_BYTE *)IOHIDEventSystemConnectionGetEntitlements(a2);
  v5 = Entitlements;
  if (*(_DWORD *)(a1 + 304))
    return (*Entitlements & 0x11) != 0;
  if (!*(_QWORD *)(a1 + 64))
    return 1;
  v9 = 0;
  if (os_variant_allows_internal_security_policies())
  {
    if ((*v5 & 0x40) != 0)
      return 1;
  }
  v8 = a2;
  v7 = *(const __CFArray **)(a1 + 64);
  v10.length = CFArrayGetCount(v7);
  v10.location = 0;
  CFArrayApplyFunction(v7, v10, (CFArrayApplierFunction)EntitlementCheckApplier, &v8);
  return v9;
}

uint64_t IOHIDEventSystemConnectionGetEntitlements(uint64_t a1)
{
  return *(_QWORD *)(a1 + 240);
}

uint64_t IOHIDEventQueueEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t TimeStamp;
  uint64_t v6;
  int v7;
  int v8;
  char v9;
  unsigned int *v10;
  uint64_t v11;
  int DataLength;
  uint64_t CallbackOptions;
  uint64_t v14;
  uint64_t v15;

  v4 = 3758097101;
  TimeStamp = IOHIDEventGetTimeStamp(a2);
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 152))
  {
    v6 = *(_QWORD *)(a1 + 16);
    if (v6)
    {
      v7 = *(_DWORD *)(v6 + 4);
      v8 = *(_DWORD *)(v6 + 8);
      if (v7 != *(_DWORD *)(a1 + 32))
        __IOHIDEventQueueUpdateUsageAnalytics(a1);
      *(_DWORD *)(a1 + 32) = v7;
      *(_DWORD *)(a1 + 36) = v8;
    }
    if ((IOHIDEventGetEventFlags(a2) & 0x2000) != 0)
    {
      *(_DWORD *)(a1 + 156) = 1;
      v9 = 2;
    }
    else
    {
      v9 = 0;
    }
    if ((IOHIDEventGetEventFlags(a2) & 0x1000) != 0)
    {
      v9 |= 1u;
      *(_DWORD *)(a1 + 156) = 0;
    }
    v10 = *(unsigned int **)(a1 + 16);
    v11 = *(unsigned int *)(a1 + 56);
    DataLength = IOHIDEventGetDataLength(a2);
    CallbackOptions = _IODataQueueEnqueueWithReadCallbackOptions(v10, v11, (mach_msg_header_t *)(a1 + 60), ((DataLength - 1) & 0xFFFFFFFC) + 4, (void (*)(uint64_t, char *, size_t))IOHIDEventReadBytesInternal, a2, v9);
    if ((_DWORD)CallbackOptions)
    {
      v4 = CallbackOptions;
      if ((_DWORD)CallbackOptions != 268435460)
        goto LABEL_20;
      goto LABEL_19;
    }
    if ((v9 & 2) != 0)
    {
LABEL_19:
      v4 = 0;
      goto LABEL_20;
    }
    if (*(_DWORD *)(a1 + 156))
    {
      _IODataQueueSendDataAvailableNotification(*(unsigned int **)(a1 + 16), (mach_msg_header_t *)(a1 + 60));
      *(_DWORD *)(a1 + 156) = 0;
    }
    v14 = mach_absolute_time();
    v4 = 0;
    v15 = *(_QWORD *)(a1 + 136) + 1;
    *(_QWORD *)(a1 + 128) = v14;
    *(_QWORD *)(a1 + 136) = v15;
    *(_QWORD *)(a1 + 120) = TimeStamp;
  }
LABEL_20:
  os_unfair_recursive_lock_unlock();
  return v4;
}

uint64_t IOHIDEventGetEventFlags(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 104) + 8);
}

uint64_t IOHIDAnalyticsHistogramEventSetIntegerValue()
{
  uint64_t result;

  if (setHistogramIntegerValueFuncPtr)
    return setHistogramIntegerValueFuncPtr();
  return result;
}

BOOL IsNotificationEvent(_QWORD *a1)
{
  unsigned __int16 IntegerValue;
  uint64_t v3;

  if (IOHIDEventGetType((uint64_t)a1) != 1)
    return 0;
  IntegerValue = IOHIDEventGetIntegerValue(a1, 0x10000u);
  v3 = (unsigned __int16)IOHIDEventGetIntegerValue(a1, 0x10001u);
  return IntegerValue == 65308 && v3 == 48;
}

uint64_t __IODataQueueEnqueue(unsigned int *a1, uint64_t a2, mach_msg_header_t *a3, size_t __n, void *__src, void (*a6)(uint64_t, char *, size_t), uint64_t a7, char a8)
{
  int v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v17;
  _DWORD *v18;
  _DWORD *v19;
  _DWORD *v20;
  unsigned int v21;
  _BOOL4 v23;

  v9 = __n;
  if (!a2)
    LODWORD(a2) = *a1;
  v12 = 3758097128;
  v13 = a1[2];
  v14 = atomic_load(a1 + 1);
  if (__n > 0xFFFFFFFB)
    return v12;
  v15 = a2 - v13;
  if (a2 < v13 || v14 > a2)
    return 3758097127;
  v17 = __n + 4;
  if (v14 > v13)
  {
    if (v14 - v13 > v17)
    {
      v18 = (unsigned int *)((char *)a1 + v13 + 12);
      if (__src)
      {
        memcpy((char *)a1 + v13 + 16, __src, __n);
      }
      else if (a6)
      {
        a6(a7, (char *)a1 + v13 + 16, __n);
      }
      *v18 = v9;
      v17 += v13;
      goto LABEL_32;
    }
    goto LABEL_19;
  }
  if (__CFADD__((_DWORD)v13, v17) || v13 + v17 > a2)
  {
    if (v14 <= v17)
    {
LABEL_19:
      _IODataQueueSendDataAvailableNotification(a1, a3);
      return v12;
    }
    v19 = a1 + 3;
    if (__src)
    {
      memcpy(a1 + 4, __src, __n);
    }
    else if (a6)
    {
      a6(a7, (char *)a1 + 16, __n);
    }
    *v19 = v9;
    if (v15 >= 4)
      *(_DWORD *)((char *)v19 + v13) = v9;
  }
  else
  {
    v20 = (unsigned int *)((char *)a1 + v13 + 12);
    if (__src)
    {
      memcpy((char *)a1 + v13 + 16, __src, __n);
    }
    else if (a6)
    {
      a6(a7, (char *)a1 + v13 + 16, __n);
    }
    *v20 = v9;
    v17 += v13;
  }
LABEL_32:
  atomic_store(v17, a1 + 2);
  v21 = v13;
  if (v14 != (_DWORD)v13)
  {
    __dmb(0xBu);
    v21 = a1[1];
  }
  v23 = (a8 & 2) == 0 && (_DWORD)v13 == v21;
  if ((a8 & 1) == 0 && !v23)
    return 0;
  return _IODataQueueSendDataAvailableNotification(a1, a3);
}

int64_t __IOHIDEventDataAppendEventData(uint64_t a1, char *a2, uint64_t a3)
{
  unsigned int *v5;
  int64_t v6;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFArray *v18;
  uint64_t Count;
  CFIndex v20;
  const void *ValueAtIndex;
  NSObject *v23;

  if (!a1)
    return 0;
  v5 = *(unsigned int **)(a1 + 104);
  v6 = *v5;
  if (v6 > a3)
  {
    v23 = _IOHIDLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      __IOHIDEventDataAppendEventData_cold_1(a3, v23);
    return 0;
  }
  v8 = *(_QWORD *)(a1 + 80);
  if (v8)
  {
    v9 = *(_QWORD *)(v8 + 104);
    if (v9)
    {
      *((_BYTE *)v5 + 12) = *(_BYTE *)(v9 + 12) + 1;
    }
    else
    {
      v10 = _IOHIDLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        __IOHIDEventDataAppendEventData_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  else
  {
    *((_BYTE *)v5 + 12) = 0;
  }
  memmove(a2, *(const void **)(a1 + 104), v6);
  v18 = *(const __CFArray **)(a1 + 72);
  if (v18)
  {
    Count = CFArrayGetCount(v18);
    if (Count)
    {
      v20 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v20);
        v6 += __IOHIDEventDataAppendEventData(ValueAtIndex, &a2[v6], a3 - v6);
        ++v20;
      }
      while (Count != v20);
    }
  }
  return v6;
}

uint64_t _IODataQueueEnqueueWithReadCallbackOptions(unsigned int *a1, uint64_t a2, mach_msg_header_t *a3, size_t a4, void (*a5)(uint64_t, char *, size_t), uint64_t a6, char a7)
{
  return __IODataQueueEnqueue(a1, a2, a3, a4, 0, a5, a6, a7);
}

uint64_t IOHIDEventGetDataLength(uint64_t a1)
{
  uint64_t result;

  result = __IOHIDEventGetLengthAndCount(a1, (_QWORD *)(a1 + 96));
  if (result)
    result += *(_QWORD *)(a1 + 88) + 28;
  return result;
}

uint64_t __IOHIDEventGetLengthAndCount(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  const __CFArray *v5;
  uint64_t Count;
  CFIndex v7;
  const void *ValueAtIndex;

  if (!a1)
    return 0;
  v4 = **(unsigned int **)(a1 + 104);
  v5 = *(const __CFArray **)(a1 + 72);
  if (v5)
  {
    Count = CFArrayGetCount(v5);
    if (Count)
    {
      v7 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v7);
        v4 += __IOHIDEventGetLengthAndCount(ValueAtIndex, a2);
        ++v7;
      }
      while (Count != v7);
    }
  }
  if (a2)
    ++*a2;
  return v4;
}

uint64_t _IOHIDServiceGetEventDeadlineForClient(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t ReportDeadline;
  const void *v7;
  uint64_t v8;
  uint64_t v10;
  _OWORD v11[5];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v10, v11);
  ++**(_DWORD **)(a1 + 72);
  if (a3)
  {
    ReportDeadline = IOHIDServiceConnectionCacheGetReportDeadline(a3);
    v7 = (const void *)a3;
  }
  else
  {
    v7 = _IOHIDServiceCopyConnectionCache(a1, a2);
    ReportDeadline = 0;
  }
  v8 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v8)
  {
    --*(_DWORD *)v8;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v10, v11);
  }
  if (v7 != (const void *)a3 && v7)
    CFRelease(v7);
  return ReportDeadline;
}

uint64_t _IOHIDServiceSupportReportLatency(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t _IOHIDServiceGetReportInterval(uint64_t a1)
{
  return *(unsigned int *)(a1 + 160);
}

const __CFDictionary *_IOHIDServiceContainsReportIntervalForClient(uint64_t a1, const void *a2, _QWORD *a3)
{
  _QWORD *v6;
  const __CFDictionary *v7;
  char v8;
  uint64_t v9;
  char v10;
  uint64_t v12;
  _OWORD v13[5];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v12, v13);
  ++**(_DWORD **)(a1 + 72);
  v6 = a3;
  if (a3 || (v6 = _IOHIDServiceCopyConnectionCache(a1, a2)) != 0)
  {
    v7 = IOHIDServiceConnectionCacheContainsKey(v6, CFSTR("ReportInterval"));
    v8 = 1;
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v9 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v9)
  {
    --*(_DWORD *)v9;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v12, v13);
  }
  v10 = v8 ^ 1;
  if (v6 == a3)
    v10 = 1;
  if ((v10 & 1) == 0)
    CFRelease(v6);
  return v7;
}

const __CFDictionary *IOHIDServiceConnectionCacheContainsKey(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  const __CFDictionary *result;

  if (CFEqual(CFSTR("ReportInterval"), a2))
  {
    v4 = a1[3];
    return (const __CFDictionary *)(v4 != 0);
  }
  if (CFEqual(CFSTR("BatchInterval"), a2))
  {
    v4 = a1[4];
    return (const __CFDictionary *)(v4 != 0);
  }
  result = (const __CFDictionary *)a1[5];
  if (result)
    return (const __CFDictionary *)CFDictionaryContainsKey(result, a2);
  return result;
}

uint64_t IOHIDServiceConnectionCacheGetReportDeadline(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t _IODataQueueSendDataAvailableNotification(unsigned int *a1, mach_msg_header_t *a2)
{
  char *v2;
  uint64_t v3;
  mach_msg_header_t send_size;

  if (!a2)
  {
    v2 = (char *)a1 + *a1;
    if (!*((_DWORD *)v2 + 6))
      return 0;
    a2 = (mach_msg_header_t *)(v2 + 16);
  }
  send_size = *a2;
  v3 = mach_msg(&send_size, 17, send_size.msgh_size, 0, 0, 0, 0);
  if ((v3 - 268435459) <= 1)
  {
    if (send_size.msgh_local_port - 1 <= 0xFFFFFFFD && ((send_size.msgh_bits >> 8) & 0x1F) - 17 <= 1)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], send_size.msgh_local_port);
    mach_msg_destroy(&send_size);
  }
  return v3;
}

uint64_t __IOHIDEventQueueUpdateUsageAnalytics(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 160);
  if (result)
    return IOHIDAnalyticsHistogramEventSetIntegerValue();
  return result;
}

_QWORD *IOHIDEventSetIntegerValueWithOptions(_QWORD *result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6;
  uint64_t v7;
  char v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;

  v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (result = (_QWORD *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a4)) != 0)
  {
    v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFE | (a3 != 0);
            goto LABEL_179;
          case 1u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFD | (2 * (a3 != 0));
            goto LABEL_179;
          case 2u:
            goto LABEL_21;
          case 3u:
            v8 = *(_BYTE *)(v7 + 8) & 0xF7 | (8 * (a3 != 0));
            goto LABEL_179;
          case 4u:
            v8 = *(_BYTE *)(v7 + 8) & 0xEF | (16 * (a3 != 0));
            goto LABEL_179;
          case 5u:
            v8 = *(_BYTE *)(v7 + 8) & 0xDF | (32 * (a3 != 0));
            goto LABEL_179;
          case 6u:
            v8 = *(_BYTE *)(v7 + 8) & 0xBF | ((a3 != 0) << 6);
            goto LABEL_179;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x10002u:
            goto LABEL_170;
          case 0x10004u:
            if (*(_DWORD *)(v7 + 24) >= 8u)
              *(_QWORD *)(v7 + 28) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_145;
          case 0x20001u:
            goto LABEL_133;
          case 0x20002u:
            goto LABEL_134;
          case 0x20003u:
            goto LABEL_151;
          case 0x20004u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_118;
          case 0x30001u:
            goto LABEL_126;
          case 0x30002u:
            goto LABEL_170;
          case 0x30003u:
            goto LABEL_182;
          case 0x30004u:
            *(_BYTE *)(v7 + 28) = a3;
            break;
          case 0x30005u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a3 != 0);
            goto LABEL_156;
          case 0x30006u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a3 & 3));
            goto LABEL_156;
          case 0x30007u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a3 & 3));
            goto LABEL_156;
          case 0x30008u:
            *(_DWORD *)(v7 + 24) = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a3 != 0));
            break;
          case 0x30009u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a3 & 7) << 6);
            goto LABEL_156;
          case 0x3000Au:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a3 & 3) << 9);
            goto LABEL_156;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146)
          goto LABEL_52;
        if (a2 == 262145)
          goto LABEL_165;
        if (a2 != 0x40000)
          return result;
        goto LABEL_69;
      case 5u:
        if (a2 == 327682)
          goto LABEL_154;
        if (a2 == 327681)
          goto LABEL_151;
        if (a2 != 327680)
          return result;
        goto LABEL_105;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_105;
          case 0x60001u:
            goto LABEL_151;
          case 0x60002u:
            goto LABEL_154;
          case 0x60003u:
LABEL_21:
            v8 = *(_BYTE *)(v7 + 8) & 0xFB | (4 * (a3 != 0));
LABEL_179:
            *(_BYTE *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
LABEL_52:
            v10 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v10 = 0x80000000;
            goto LABEL_156;
          case 0x70001u:
            goto LABEL_165;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_154:
          v10 = (_DWORD)a3 << 16;
          if ((_DWORD)a3 == 0x80000000)
            v10 = 0x80000000;
LABEL_156:
          *(_DWORD *)(v7 + 24) = v10;
          return result;
        }
        if (a2 == 589825)
          goto LABEL_151;
        if (a2 != 589824)
          return result;
        goto LABEL_105;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_154;
                case 0xA0001u:
                  goto LABEL_151;
                case 0xA0000u:
                  goto LABEL_105;
              }
              break;
            case 1:
              if (a2 == 655364)
                goto LABEL_145;
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_154;
                case 0xA0006u:
                  goto LABEL_151;
                case 0xA0005u:
                  goto LABEL_105;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_105;
                case 0xA0009u:
                  goto LABEL_151;
                case 0xA000Au:
                  goto LABEL_154;
                case 0xA000Bu:
                  goto LABEL_157;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_165;
          case 0xB0002u:
            goto LABEL_52;
          case 0xB0003u:
            goto LABEL_183;
          case 0xB0004u:
            goto LABEL_127;
          case 0xB0005u:
            goto LABEL_119;
          case 0xB0006u:
            goto LABEL_132;
          case 0xB0007u:
            goto LABEL_184;
          case 0xB0008u:
LABEL_182:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a3 != 0) << 16);
            goto LABEL_257;
          case 0xB0009u:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a3 != 0) << 17);
            goto LABEL_257;
          case 0xB000Au:
            goto LABEL_208;
          case 0xB000Bu:
            goto LABEL_211;
          case 0xB000Cu:
            goto LABEL_253;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_199;
                  case 0xB0013u:
                    goto LABEL_214;
                  case 0xB0014u:
                    goto LABEL_217;
                  case 0xB0015u:
LABEL_262:
                    v38 = (_DWORD)a3 << 16;
                    if ((_DWORD)a3 == 0x80000000)
                      v38 = 0x80000000;
                    *(_DWORD *)(v7 + 84) = v38;
                    break;
                  case 0xB001Au:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_196;
                  case 0xB0010u:
                    goto LABEL_199;
                  case 0xB0011u:
                    goto LABEL_214;
                  case 0xB0012u:
                    goto LABEL_217;
                  case 0xB0014u:
                    goto LABEL_262;
                  case 0xB0015u:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910)
              goto LABEL_199;
            if (a2 != 720909)
              return result;
            goto LABEL_196;
          case 0xB0016u:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a3 != 0));
            goto LABEL_257;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32))
              goto LABEL_253;
            return result;
          case 0xB0018u:
            goto LABEL_181;
          case 0xB0019u:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a3 != 0) << 19);
LABEL_257:
            *(_DWORD *)(v7 + 8) = v20;
            return result;
          case 0xB001Bu:
            *(_DWORD *)(v7 + 92) = a3;
            return result;
          case 0xB001Cu:
            *(_DWORD *)(v7 + 96) = a3;
            return result;
          case 0xB001Du:
            *(_DWORD *)(v7 + 100) = a3;
            return result;
          case 0xB001Eu:
            *(_DWORD *)(v7 + 40) = ((_DWORD)a3 << 13) & 0x30000000 | (((a3 >> 10) & 1) << 30) & 0x70000000 | ((a3 >> 23) << 31) | *(_DWORD *)(v7 + 40) & 0xFFFFFFF;
            return result;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_116;
          case 0xC0001u:
            goto LABEL_170;
          case 0xC0002u:
            goto LABEL_88;
          case 0xC0003u:
            goto LABEL_119;
          case 0xC0004u:
            goto LABEL_127;
          case 0xC0005u:
            *(_BYTE *)(v7 + 36) = a3 != 0;
            break;
          case 0xC0006u:
            *(_BYTE *)(v7 + 37) = a3;
            break;
          case 0xC0007u:
            goto LABEL_137;
          case 0xC0008u:
            goto LABEL_128;
          case 0xC0009u:
            goto LABEL_129;
          case 0xC000Au:
            goto LABEL_160;
          case 0xC000Bu:
            goto LABEL_161;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_165;
          case 0xD0002u:
            goto LABEL_52;
          case 0xD0003u:
            goto LABEL_119;
          case 0xD0004u:
            goto LABEL_127;
          case 0xD0005u:
            goto LABEL_132;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_118;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507)
                goto LABEL_143;
              return result;
            }
            if (a2 != 917505 || *(_WORD *)(v7 + 18))
              return result;
            break;
          case 0xE0002u:
            goto LABEL_126;
          default:
            return result;
        }
        goto LABEL_143;
      case 0xFu:
        if (a2 != 983040)
          return result;
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_78;
          case 0x100001u:
            goto LABEL_123;
          case 0x100002u:
            goto LABEL_120;
          case 0x100003u:
            goto LABEL_105;
          case 0x100004u:
            goto LABEL_151;
          case 0x100005u:
            goto LABEL_124;
          case 0x100006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_165;
          case 0x110002u:
            goto LABEL_52;
          case 0x110003u:
            goto LABEL_119;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649)
          goto LABEL_165;
        if (a2 != 1179648)
          return result;
        goto LABEL_116;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_105;
          case 0x130001u:
            goto LABEL_151;
          case 0x130002u:
            goto LABEL_154;
          case 0x130003u:
            goto LABEL_96;
          case 0x130004u:
            goto LABEL_120;
          case 0x130005u:
            goto LABEL_171;
          case 0x130006u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_105;
          case 0x140001u:
            goto LABEL_151;
          case 0x140002u:
            goto LABEL_154;
          case 0x140003u:
            goto LABEL_78;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_130;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_105;
          case 0x150001u:
            goto LABEL_151;
          case 0x150002u:
            goto LABEL_154;
          case 0x150003u:
            goto LABEL_78;
          case 0x150004u:
LABEL_61:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x150005u:
LABEL_130:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_78;
          case 0x170001u:
            goto LABEL_123;
          case 0x170002u:
            goto LABEL_120;
          case 0x170003u:
            goto LABEL_105;
          case 0x170004u:
            goto LABEL_151;
          case 0x170005u:
            goto LABEL_124;
          case 0x170006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864)
          goto LABEL_116;
        if (a2 == 1572865)
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a3 != 0) << 15);
        return result;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
LABEL_119:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x190001u:
LABEL_88:
            *(_DWORD *)(v7 + 24) = a3;
            break;
          case 0x190000u:
LABEL_69:
            v11 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v11 = 0x80000000;
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            goto LABEL_88;
          case 0x1A0001u:
LABEL_125:
            *(_BYTE *)(v7 + 20) = a3;
            break;
          case 0x1A0000u:
LABEL_145:
            *(_DWORD *)(v7 + 16) = a3;
            break;
        }
        return result;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_78;
          case 0x1B0001u:
            goto LABEL_123;
          case 0x1B0002u:
            goto LABEL_120;
          case 0x1B0003u:
            goto LABEL_105;
          case 0x1B0004u:
            goto LABEL_151;
          case 0x1B0005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_78:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x1C0001u:
LABEL_123:
            *(_WORD *)(v7 + 32) = a3;
            break;
          case 0x1C0002u:
            goto LABEL_120;
          case 0x1C0003u:
            goto LABEL_105;
          case 0x1C0004u:
            goto LABEL_151;
          case 0x1C0005u:
LABEL_124:
            *(_WORD *)(v7 + 34) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_145;
          case 0x1D0001u:
            goto LABEL_151;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = a3;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = a3;
            break;
          case 0x1D0004u:
            *(_BYTE *)(v7 + 32) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            goto LABEL_145;
          case 0x1E0001u:
            goto LABEL_151;
          case 0x1E0002u:
            goto LABEL_88;
          case 0x1E0003u:
            if (*(_DWORD *)(v7 + 24) >= 8u)
              *(_QWORD *)(v7 + 28) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617)
          goto LABEL_143;
        if (a2 != 2031616)
          return result;
        goto LABEL_105;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_116;
          case 0x200001u:
            goto LABEL_165;
          case 0x200002u:
            goto LABEL_88;
          case 0x200003u:
            goto LABEL_157;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689)
          goto LABEL_151;
        if (a2 != 2162688)
          return result;
        goto LABEL_145;
      case 0x22u:
        if (a2 == 2228225)
          goto LABEL_165;
        if (a2 != 2228224)
          return result;
LABEL_116:
        *(_DWORD *)(v7 + 16) = a3;
        return result;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_116;
          case 0x230001u:
            goto LABEL_165;
          case 0x230002u:
            goto LABEL_52;
          case 0x230003u:
LABEL_157:
            v17 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v17 = 0x80000000;
            *(_DWORD *)(v7 + 28) = v17;
            return result;
          case 0x230004u:
LABEL_96:
            v12 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v12 = 0x80000000;
            *(_DWORD *)(v7 + 32) = v12;
            return result;
          case 0x230005u:
            v28 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v28 = 0x80000000;
            *(_DWORD *)(v7 + 44) = v28;
            return result;
          case 0x230006u:
            v29 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v29 = 0x80000000;
            *(_DWORD *)(v7 + 48) = v29;
            return result;
          case 0x230007u:
LABEL_120:
            v15 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v15 = 0x80000000;
            *(_DWORD *)(v7 + 36) = v15;
            return result;
          case 0x230008u:
LABEL_171:
            v19 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v19 = 0x80000000;
            *(_DWORD *)(v7 + 40) = v19;
            return result;
          case 0x230009u:
LABEL_196:
            v21 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v21 = 0x80000000;
            *(_DWORD *)(v7 + 68) = v21;
            return result;
          case 0x23000Au:
LABEL_214:
            v25 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v25 = 0x80000000;
            *(_DWORD *)(v7 + 76) = v25;
            return result;
          case 0x23000Bu:
LABEL_199:
            v22 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v22 = 0x80000000;
            *(_DWORD *)(v7 + 72) = v22;
            return result;
          case 0x23000Cu:
LABEL_217:
            v26 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v26 = 0x80000000;
            *(_DWORD *)(v7 + 80) = v26;
            return result;
          case 0x23000Du:
LABEL_208:
            v23 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v23 = 0x80000000;
            *(_DWORD *)(v7 + 52) = v23;
            return result;
          case 0x23000Eu:
LABEL_211:
            v24 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v24 = 0x80000000;
            *(_DWORD *)(v7 + 56) = v24;
            return result;
          case 0x23000Fu:
LABEL_253:
            v37 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v37 = 0x80000000;
            *(_DWORD *)(v7 + 60) = v37;
            return result;
          case 0x230010u:
            v30 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v30 = 0x80000000;
            *(_DWORD *)(v7 + 64) = v30;
            return result;
          case 0x230011u:
            v31 = *(_BYTE *)(v7 + 84) & 0xFE | (a3 != 0);
            goto LABEL_234;
          case 0x230012u:
            v31 = *(_BYTE *)(v7 + 84) & 0xFD | (2 * (a3 != 0));
LABEL_234:
            *(_BYTE *)(v7 + 84) = v31;
            break;
          case 0x230013u:
LABEL_220:
            v27 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v27 = 0x80000000;
            *(_DWORD *)(v7 + 88) = v27;
            break;
          case 0x230014u:
            v32 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v32 = 0x80000000;
            *(_DWORD *)(v7 + 92) = v32;
            break;
          case 0x230015u:
            v33 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v33 = 0x80000000;
            *(_DWORD *)(v7 + 96) = v33;
            break;
          case 0x230016u:
            v34 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v34 = 0x80000000;
            *(_DWORD *)(v7 + 100) = v34;
            break;
          case 0x230017u:
            v35 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v35 = 0x80000000;
            *(_DWORD *)(v7 + 104) = v35;
            break;
          case 0x230018u:
            v36 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v36 = 0x80000000;
            *(_DWORD *)(v7 + 108) = v36;
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
        {
LABEL_143:
          *(_DWORD *)(v7 + 20) = a3;
        }
        else if (a2 == 2359296)
        {
          goto LABEL_105;
        }
        return result;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(_QWORD *)(v7 + 24) = a3;
            break;
          case 0x260001u:
LABEL_151:
            v16 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v16 = 0x80000000;
            *(_DWORD *)(v7 + 20) = v16;
            break;
          case 0x260000u:
LABEL_105:
            v13 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v13 = 0x80000000;
            *(_DWORD *)(v7 + 16) = v13;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1)
          return result;
        v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 == 2555906)
          {
LABEL_165:
            v18 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v18 = 0x80000000;
            *(_DWORD *)(v7 + 20) = v18;
          }
        }
        else
        {
          if (!v14)
          {
            if (a2 != 2555905)
              return result;
            goto LABEL_170;
          }
          if (a2 == 2555905 && v14 == 2)
          {
LABEL_170:
            *(_DWORD *)(v7 + 20) = a3;
            return result;
          }
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = a3;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = a3;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = (double)a3;
            break;
          case 0x280003u:
LABEL_133:
            *(_BYTE *)(v7 + 24) = a3;
            break;
          case 0x280004u:
LABEL_134:
            *(_BYTE *)(v7 + 25) = a3;
            break;
          case 0x280005u:
            goto LABEL_119;
          case 0x280006u:
LABEL_127:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x280007u:
LABEL_132:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          case 0x280008u:
            *(_BYTE *)(v7 + 44) = a3;
            break;
          case 0x280009u:
LABEL_183:
            *(_DWORD *)(v7 + 48) = a3;
            break;
          case 0x28000Au:
            *(_QWORD *)(v7 + 56) = a3;
            break;
          case 0x28000Bu:
            *(_BYTE *)(v7 + 26) = a3;
            break;
          case 0x28000Cu:
LABEL_184:
            *(_DWORD *)(v7 + 40) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_116;
          case 0x290001u:
            goto LABEL_125;
          case 0x290002u:
            goto LABEL_135;
          case 0x290003u:
            goto LABEL_136;
          case 0x290004u:
LABEL_137:
            *(double *)(v7 + 40) = (double)a3;
            break;
          case 0x290005u:
            goto LABEL_128;
          case 0x290006u:
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_118:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x2A0001u:
LABEL_126:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x2A0002u:
LABEL_135:
            *(double *)(v7 + 24) = (double)a3;
            break;
          case 0x2A0003u:
LABEL_136:
            *(double *)(v7 + 32) = (double)a3;
            break;
          case 0x2A0004u:
            *(_BYTE *)(v7 + 40) = a3 != 0;
            break;
          case 0x2A0005u:
LABEL_181:
            *(_DWORD *)(v7 + 44) = a3;
            break;
          case 0x2A0006u:
LABEL_128:
            *(double *)(v7 + 48) = (double)a3;
            break;
          case 0x2A0007u:
LABEL_129:
            *(double *)(v7 + 56) = (double)a3;
            break;
          case 0x2A0008u:
LABEL_160:
            *(double *)(v7 + 64) = (double)a3;
            break;
          case 0x2A0009u:
LABEL_161:
            *(double *)(v7 + 72) = (double)a3;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

_QWORD *IOHIDEventSetIntegerValue(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  return IOHIDEventSetIntegerValueWithOptions(a1, a2, a3, 4026531840);
}

uint64_t _IOHIDSimpleQueueEnqueue(const __CFData *a1, const void *a2, int a3)
{
  const UInt8 *BytePtr;
  const UInt8 *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;

  BytePtr = CFDataGetBytePtr(a1);
  v6 = BytePtr;
  v7 = *((_QWORD *)BytePtr + 3);
  v8 = (unint64_t)(v7 + 1) % *(_QWORD *)BytePtr;
  if (v8 != *((_QWORD *)BytePtr + 2))
  {
LABEL_7:
    memcpy((void *)&BytePtr[*((_QWORD *)BytePtr + 1) * v7 + 32], a2, *((_QWORD *)BytePtr + 1));
    result = 0;
    *((_QWORD *)v6 + 3) = v8;
    return result;
  }
  if (a3)
  {
    if (v8 + 1 == *(_QWORD *)BytePtr)
      v9 = 0;
    else
      v9 = v8 + 1;
    *((_QWORD *)BytePtr + 2) = v9;
    goto LABEL_7;
  }
  return 3758097115;
}

void _IOHIDServiceSetEventDeadlineForClient(uint64_t a1, const void *a2, uint64_t a3, int a4, _QWORD *a5)
{
  _QWORD *v10;
  char v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  _OWORD v15[5];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v15);
  ++**(_DWORD **)(a1 + 72);
  v10 = a5;
  if (a5 || (v10 = __IOHIDServiceCreateAndCopyConnectionCache(a1, a2)) != 0)
  {
    if (_IOHIDServiceGetReportIntervalForClient(a1, a2, v10) == a4)
      IOHIDServiceConnectionCacheSetReportDeadline((uint64_t)v10, a3);
    v11 = 1;
  }
  else
  {
    v11 = 0;
  }
  v12 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v12)
  {
    --*(_DWORD *)v12;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v15);
  }
  v13 = v11 ^ 1;
  if (v10 == a5)
    v13 = 1;
  if ((v13 & 1) == 0)
    CFRelease(v10);
}

uint64_t IOHIDServiceConnectionCacheSetReportDeadline(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t IOHIDEventGetEvent(_QWORD *a1, uint64_t a2)
{
  return IOHIDEventGetEventWithOptions(a1, a2, 4026531840);
}

const __CFData *_IOHIDSimpleQueueCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  CFIndex v5;
  __CFData *Mutable;
  const __CFData *v7;
  UInt8 *BytePtr;

  v4 = a3 + 1;
  v5 = (a3 + 1) * a2 + 32;
  Mutable = CFDataCreateMutable(a1, v5);
  v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    BytePtr = (UInt8 *)CFDataGetBytePtr(v7);
    *(_QWORD *)BytePtr = v4;
    *((_QWORD *)BytePtr + 1) = a2;
    *((_QWORD *)BytePtr + 2) = 0;
    *((_QWORD *)BytePtr + 3) = 0;
  }
  return v7;
}

uint64_t _IOHIDServiceCurrentBatchInterval(uint64_t a1)
{
  return *(unsigned int *)(a1 + 164);
}

id __FilterFunctionRegisterService(void *a1, uint64_t *a2)
{
  return IOHIDSessionFilterRegisterService(a1, *a2);
}

id __FilterFunctionUnregisterService(void *a1, uint64_t *a2)
{
  return IOHIDSessionFilterUnregisterService(a1, *a2);
}

uint64_t _IOHIDServiceDispatchEvent(uint64_t result, HIDEvent *a2, uint64_t a3)
{
  if (result)
  {
    if (a2)
      return __IOHIDServiceEventCallback(result, (uint64_t)a2, a3, a2);
  }
  return result;
}

const __CFDictionary *__IOHIDEventSystemClientRefreshServiceCallback(void *key, CFDictionaryRef *a2, _QWORD *a3)
{
  const __CFDictionary *v5;
  _QWORD *v6;
  uint64_t v7;
  void (*v8)(_QWORD, _QWORD, CFDictionaryRef *);

  v5 = (const __CFDictionary *)a3[1];
  if (v5)
  {
    v6 = (_QWORD *)*a3;
    if (!CFDictionaryContainsKey(v5, key))
    {
      os_unfair_recursive_lock_lock_with_options();
      v7 = v6[22];
      if (v7)
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, CFDictionaryRef *))(v7 + 16))(v7, v6[23], v6[24], a2);
      }
      else
      {
        v8 = (void (*)(_QWORD, _QWORD, CFDictionaryRef *))v6[21];
        if (v8)
          v8(v6[23], v6[24], a2);
      }
      os_unfair_recursive_lock_unlock();
    }
  }
  return _IOHIDServiceClientRefresh(a2);
}

uint64_t __IOHIDServiceQueueDidExecute(uint64_t result)
{
  uint64_t v1;
  _OWORD v2[5];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceQueueDidExecute_cold_1(&v1, v2);
  }
  return result;
}

uint64_t __IOHIDServiceQueueWillExecute(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  _OWORD v4[5];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if ((_DWORD)result)
    __IOHIDServiceQueueWillExecute_cold_1(&v3, v4);
  ++*(_DWORD *)a1;
  return result;
}

mach_port_t IONotificationPortGetMachPort(IONotificationPortRef notify)
{
  return *((_DWORD *)notify + 1);
}

void __IOHIDSessionServiceCallback(uint64_t a1, int a2, const void *a3, _QWORD *a4)
{
  if (a1)
  {
    if (a4)
    {
      _IOHIDEventSetAttachment(a4, CFSTR("Sender"), a3);
      __IOHIDSessionDispatchEvent(a1, a4);
    }
  }
}

BOOL _IOHIDEventSetAttachment(_QWORD *a1, CFTypeRef cf1, const void *a3)
{
  _BOOL8 result;
  const void *v7;
  CFTypeRef v8;
  __CFDictionary *Mutable;
  const __CFAllocator *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  result = 0;
  if (a1 && cf1)
  {
    if (CFEqual(cf1, CFSTR("Sender")))
    {
      v7 = (const void *)a1[8];
      if (v7)
        CFRelease(v7);
      if (a3)
        v8 = CFRetain(a3);
      else
        v8 = 0;
      a1[8] = v8;
      return 1;
    }
    Mutable = (__CFDictionary *)a1[7];
    if (Mutable
      || (v10 = CFGetAllocator(a1),
          Mutable = CFDictionaryCreateMutable(v10, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
          (a1[7] = Mutable) != 0))
    {
      CFDictionarySetValue(Mutable, cf1, a3);
      return 1;
    }
    v11 = _IOHIDLog();
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (result)
    {
      _IOHIDEventSetAttachment_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
      return 0;
    }
  }
  return result;
}

__n64 IOHIDEventGetFloatValue(_QWORD *a1, unsigned int a2)
{
  return IOHIDEventGetFloatValueWithOptions(a1, a2, 4026531840);
}

uint64_t _IODispatchCalloutWithDispatch(mach_msg_header_t *a1, mach_msg_header_t *a2)
{
  uint64_t v4;

  mig_reply_setup(a1, a2);
  a2[1].msgh_remote_port = -305;
  IODispatchCalloutFromCFMessage(v4, a1);
  return 1;
}

void IODispatchCalloutFromCFMessage(uint64_t a1, _DWORD *a2)
{
  int v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  ipc_space_t *v9;
  int v11;
  unsigned int *v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  void (*v16)(_QWORD, _QWORD, _QWORD);
  _QWORD *v17;
  unint64_t v18;
  mach_port_name_t *v19;
  mach_port_name_t v20;
  unsigned int v21;

  if (a2[5] == 53)
  {
    v2 = (int)a2;
    if ((*a2 & 0x80000000) != 0)
    {
      v6 = a2[6];
      if (v6)
        v3 = a2[7];
      else
        v3 = 0;
      v5 = (uint64_t)&a2[3 * v6 + 7];
      v4 = a2;
    }
    else
    {
      v3 = 0;
      v4 = 0;
      v5 = (uint64_t)(a2 + 6);
    }
    v8 = a2[1];
    v7 = a2[2];
    v9 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    if ((_DWORD)v7)
    {
      v21 = 0;
      if (MEMORY[0x18D772984](*MEMORY[0x1E0C83DA0], v7, 0, &v21) || v21 < 2)
        goto LABEL_31;
    }
    v11 = *(_DWORD *)(v5 + 4) & 0xFFF;
    if ((v11 - 100) >= 3)
    {
      v12 = (unsigned int *)(v5 + 72);
      v13 = v8 + v2 - (v5 + 72) - (*(_DWORD *)(v5 + 4) >> 30);
      if (v11 == 160)
      {
        v17 = (_QWORD *)(v5 + 76);
        if (((v13 + 0x7FFFFFFFCLL) & 0x7FFFFFFF0) == 0)
          v17 = (_QWORD *)*v17;
        if (!(_DWORD)v3)
          v3 = *(unsigned int *)(v5 + 32);
        (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD *))(v5 + 16))(*(_QWORD *)(v5 + 24), v3, *v12, v17);
      }
      else if (v11 == 150)
      {
        v14 = ((unint64_t)v13 + 0x7FFFFFFFCLL) >> 3;
        v16 = *(void (**)(_QWORD, _QWORD, _QWORD))(v5 + 16);
        v15 = *(_QWORD *)(v5 + 24);
        if ((_DWORD)v14 == 2)
        {
          ((void (*)(uint64_t, _QWORD, _QWORD, _QWORD))v16)(v15, *(unsigned int *)(v5 + 72), *(_QWORD *)(v5 + 76), *(_QWORD *)(v5 + 84));
        }
        else if ((_DWORD)v14 == 1)
        {
          v16(v15, *(unsigned int *)(v5 + 72), *(_QWORD *)(v5 + 76));
        }
        else if ((_DWORD)v14)
        {
          v16(v15, *(unsigned int *)(v5 + 72), v5 + 76);
        }
        else
        {
          ((void (*)(uint64_t, _QWORD))v16)(v15, *v12);
        }
      }
    }
    else
    {
      (*(void (**)(_QWORD, uint64_t))(v5 + 16))(*(_QWORD *)(v5 + 24), v7);
    }
    if ((_DWORD)v7)
LABEL_31:
      mach_port_deallocate(*v9, v7);
    if (v4 && v4[6])
    {
      v18 = 0;
      v19 = v4 + 7;
      do
      {
        v20 = *v19;
        v19 += 3;
        mach_port_deallocate(*v9, v20);
        ++v18;
      }
      while (v18 < v4[6]);
    }
  }
}

id IOHIDSessionFilterSetPropertyForClient(id result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD, uint64_t);

  v3 = *((_QWORD *)result + 2);
  if (v3)
  {
    v4 = *(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v3 + 128);
    if (v4)
      return (id)v4(*((_QWORD *)result + 2), a2);
  }
  if (*((_QWORD *)result + 7))
    return objc_msgSend(*((id *)result + 7), *((SEL *)result + 9), a3, a2);
  return result;
}

uint64_t IOHIDServiceSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  return _IOHIDServiceSetPropertyForClient(a1, a2, a3, (CFTypeRef)*MEMORY[0x1E0C9B0D0]);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return _IOObjectConformsTo(object, className, 0);
}

const __CFDictionary *IOHIDEventSystemConnectionGetAttribute(uint64_t a1, const void *a2)
{
  const __CFDictionary *result;

  result = *(const __CFDictionary **)(a1 + 184);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

uint64_t IOHIDEventSystemConnectionGetProcName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

void __IOHIDServiceConformsToFunction(const void *a1, _DWORD *a2)
{
  CFTypeID v4;
  const __CFNumber *v5;
  const __CFNumber *v6;
  CFTypeID v7;
  const __CFNumber *Value;
  const __CFNumber *v9;
  CFTypeID v10;
  NSObject *v11;
  int valuePtr;

  if (a1 && !*a2)
  {
    valuePtr = 0;
    v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      if (a2[1] == -1
        || (v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("DeviceUsagePage"))) != 0
        && (v6 = v5, v7 = CFGetTypeID(v5), v7 == CFNumberGetTypeID())
        && CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr)
        && valuePtr == a2[1])
      {
        if (a2[2] == -1
          || (Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("DeviceUsage"))) != 0
          && (v9 = Value, v10 = CFGetTypeID(Value), v10 == CFNumberGetTypeID())
          && CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr)
          && valuePtr == a2[2])
        {
          *a2 = 1;
        }
      }
    }
    else
    {
      v11 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        __IOHIDServiceConformsToFunction_cold_1((uint64_t)a1, v11);
    }
  }
}

void __IOMIGMachPortChannelCallback(void *cf, uint64_t a2)
{
  mach_msg_header_t *msg;
  int v4;

  if (a2 == 8)
  {
    CFRelease(cf);
  }
  else if (a2 == 2)
  {
    msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
    __IOMIGMachPortPortCallback((int)msg, msg, v4, (CFIndex *)cf);
  }
}

void __IOMIGMachPortPortCallback(int a1, mach_msg_header_t *a2, int a3, CFIndex *cf)
{
  mach_msg_header_t *v6;
  mach_msg_header_t *v7;
  mach_port_t msgh_remote_port;
  mach_port_t *p_msgh_remote_port;
  void (*v10)(CFIndex *, CFIndex);
  uint64_t v11;
  void (*v12)(CFIndex *, mach_msg_header_t *, mach_msg_header_t *, CFIndex);
  mach_msg_option_t v13;
  mach_port_name_t msgh_local_port;

  if (cf)
  {
    CFRetain(cf);
    v6 = (mach_msg_header_t *)CFAllocatorAllocate(0, cf[8], 0);
    if (!v6)
    {
LABEL_23:
      CFRelease(cf);
      return;
    }
    v7 = v6;
    msgh_remote_port = a2->msgh_remote_port;
    v6->msgh_bits = a2->msgh_bits & 0x1F;
    v6->msgh_size = 36;
    *(_QWORD *)&v6->msgh_remote_port = msgh_remote_port;
    v6->msgh_id = a2->msgh_id + 100;
    if (a2->msgh_id == 70)
    {
      v6->msgh_bits = 0;
      v6->msgh_remote_port = 0;
      v6[1].msgh_remote_port = 0;
      p_msgh_remote_port = &v6[1].msgh_remote_port;
      v10 = (void (*)(CFIndex *, CFIndex))cf[11];
      if (!v10)
        goto LABEL_22;
      v10(cf, cf[12]);
    }
    else
    {
      v11 = *MEMORY[0x1E0C804E8];
      v6[1].msgh_remote_port = -303;
      p_msgh_remote_port = &v6[1].msgh_remote_port;
      *(_QWORD *)&v6[1].msgh_bits = v11;
      v12 = (void (*)(CFIndex *, mach_msg_header_t *, mach_msg_header_t *, CFIndex))cf[9];
      if (!v12)
        goto LABEL_21;
      v12(cf, a2, v6, cf[10]);
    }
    if ((v7->msgh_bits & 0x80000000) == 0 && *p_msgh_remote_port)
    {
      if (*p_msgh_remote_port == -305)
        goto LABEL_22;
      a2->msgh_remote_port = 0;
      mach_msg_destroy(a2);
    }
    if (v7->msgh_remote_port)
    {
      if ((v7->msgh_bits & 0x1F) == 0x12)
        v13 = 1;
      else
        v13 = 17;
      if ((mach_msg(v7, v13, v7->msgh_size, 0, 0, 0, 0) - 268435459) > 1)
        goto LABEL_22;
      msgh_local_port = v7->msgh_local_port;
      a2 = v7;
      if (msgh_local_port - 1 <= 0xFFFFFFFD)
      {
        a2 = v7;
        if (((v7->msgh_bits >> 8) & 0x1F) - 17 <= 1)
        {
          mach_port_deallocate(*MEMORY[0x1E0C83DA0], msgh_local_port);
          a2 = v7;
        }
      }
      goto LABEL_21;
    }
    a2 = v7;
    if ((v7->msgh_bits & 0x80000000) != 0)
LABEL_21:
      mach_msg_destroy(a2);
LABEL_22:
    CFAllocatorDeallocate(0, v7);
    goto LABEL_23;
  }
}

uint64_t __IOHIDEventSystemClientMIGDemuxCallback(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3;
  uint64_t result;

  v3 = a2[5];
  if (v3 >= 75000 && v3 < 75013)
    LOBYTE(result) = iohideventsystem_client_server(a2, a3);
  else
    LOBYTE(result) = 0;
  return result;
}

uint64_t iohideventsystem_client_server(_DWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  void (*v5)(void);
  uint64_t result;

  v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  v4 = a1[5];
  if ((v4 - 75013) >= 0xFFFFFFF3
    && (v5 = (void (*)(void))*(&_iohideventsystem_client_subsystem + 5 * (v4 - 75000) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t _Xiohideventsystem_client_dispatch_virtual_service_copy_property(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 60))
  {
    v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = _iohideventsystem_client_dispatch_virtual_service_copy_property(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(_QWORD *)(a2 + 44) = *MEMORY[0x1E0C804E8];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _Xiohideventsystem_client_dispatch_service_removal(uint64_t result, uint64_t a2)
{
  CFIndex v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v4 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v4;
    goto LABEL_9;
  }
  if (*(_BYTE *)(result + 39) != 1 || (v3 = *(unsigned int *)(result + 40), (_DWORD)v3 != *(_DWORD *)(result + 52)))
  {
    v4 = -300;
    goto LABEL_8;
  }
  result = _iohideventsystem_client_dispatch_service_removal(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3);
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t __IOHIDEventSystemConnectionPortDemuxCallback(uint64_t (*a1)(CFTypeRef, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t (**cf)(CFTypeRef, uint64_t, uint64_t, uint64_t))
{
  uint64_t (*v8)(CFTypeRef, uint64_t, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t (*v10)(CFTypeRef, uint64_t, uint64_t, uint64_t);

  CFRetain(cf);
  os_unfair_recursive_lock_lock_with_options();
  v8 = cf[6];
  if (v8 && cf[4] == a1)
  {
    v10 = cf[7];
    os_unfair_recursive_lock_unlock();
    v9 = v8(cf, a2, a3, (uint64_t)v10);
    os_unfair_recursive_lock_lock_with_options();
  }
  else
  {
    v9 = 0;
  }
  os_unfair_recursive_lock_unlock();
  CFRelease(cf);
  return v9;
}

uint64_t __IOHIDEventSystemConnectionDemuxCallback(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3;
  uint64_t result;

  v3 = a2[5];
  if (v3 >= 70000 && v3 < 70029)
    LOBYTE(result) = iohideventsystem_server(a2, a3);
  else
    LOBYTE(result) = 0;
  return result;
}

uint64_t iohideventsystem_server(_DWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  void (*v5)(void);
  uint64_t result;

  v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  v4 = a1[5];
  if ((v4 - 70029) >= 0xFFFFFFE3
    && (v5 = (void (*)(void))*(&_iohideventsystem_subsystem + 5 * (v4 - 70000) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

CFTypeRef IOHIDServiceGetProperty(uint64_t a1, const void *a2)
{
  return (id)__IOHIDServiceCopyPropertyForClient(a1, a2, (const void *)*MEMORY[0x1E0C9B0D0], 0);
}

CFTypeRef __IOHIDServiceCopyPropertyForClient(uint64_t a1, const void *a2, const void *a3, int a4)
{
  uint64_t v8;
  CFTypeID v9;
  int Type;
  const __CFAllocator *v11;
  const void *v12;
  CFNumberType v13;
  _QWORD *v14;
  const void *v15;
  CFTypeRef v16;
  CFNumberRef v17;
  uint64_t v18;
  uint64_t (*v19)(void);
  uint64_t v20;
  uint64_t (*v21)(void);
  uint64_t v22;
  char v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v27;
  uint64_t (*v28)(_QWORD, _QWORD, const void *);
  void *v29;
  id v30;
  uint64_t v31;
  _OWORD v32[5];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v8 = mach_absolute_time();
  if (a3 && (v9 = CFGetTypeID(a3), v9 == IOHIDEventSystemConnectionGetTypeID()))
    Type = IOHIDEventSystemConnectionGetType((uint64_t)a3);
  else
    Type = 5;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v31, v32);
  ++**(_DWORD **)(a1 + 72);
  if (!a4)
  {
    if (CFEqual(a2, CFSTR("ReportInterval")) || CFEqual(a2, CFSTR("BatchInterval")))
    {
      if (Type >= 2 && Type != 5)
      {
        v14 = _IOHIDServiceCopyConnectionCache(a1, a3);
        v15 = v14;
        if (v14)
        {
          v16 = IOHIDServiceConnectionCacheCopyValueForKey(v14, a2);
          CFRelease(v15);
LABEL_33:
          LOBYTE(v15) = 1;
          goto LABEL_34;
        }
        goto LABEL_52;
      }
      if (CFEqual(a2, CFSTR("ReportInterval")))
      {
        v11 = CFGetAllocator((CFTypeRef)a1);
        v12 = (const void *)(a1 + 160);
      }
      else
      {
        if (!CFEqual(a2, CFSTR("BatchInterval")))
        {
          v16 = 0;
          goto LABEL_33;
        }
        v11 = CFGetAllocator((CFTypeRef)a1);
        v12 = (const void *)(a1 + 164);
      }
    }
    else
    {
      if (!CFEqual(a2, CFSTR("QueueSize")) || Type != 2)
        goto LABEL_7;
      v11 = CFGetAllocator((CFTypeRef)a1);
      v12 = (const void *)(a1 + 216);
    }
    v13 = kCFNumberSInt32Type;
    goto LABEL_31;
  }
LABEL_7:
  if (CFEqual(a2, CFSTR("LastActivityTimestamp")))
  {
    v11 = CFGetAllocator((CFTypeRef)a1);
    v12 = (const void *)(a1 + 328);
    v13 = kCFNumberSInt64Type;
LABEL_31:
    v17 = CFNumberCreate(v11, v13, v12);
    goto LABEL_32;
  }
  if (CFEqual(a2, CFSTR("ServiceRecord")))
  {
    v17 = _IOHIDServiceCopyServiceRecordForClient((_DWORD *)a1, a3);
LABEL_32:
    v16 = v17;
    goto LABEL_33;
  }
  v18 = *(_QWORD *)(a1 + 32);
  if (v18)
  {
    v19 = *(uint64_t (**)(void))(*(_QWORD *)v18 + 48);
    if (v19)
    {
      v17 = (CFNumberRef)v19();
      goto LABEL_32;
    }
  }
  v20 = *(_QWORD *)(a1 + 24);
  if (!v20 || (v21 = *(uint64_t (**)(void))(*(_QWORD *)v20 + 48)) == 0)
  {
    v27 = *(_QWORD *)(a1 + 360);
    if (v27)
    {
      v28 = *(uint64_t (**)(_QWORD, _QWORD, const void *))(v27 + 24);
      if (v28)
      {
        v17 = (CFNumberRef)v28(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), a2);
        goto LABEL_32;
      }
    }
    v29 = *(void **)(a1 + 480);
    if (v29)
    {
      v30 = objc_msgSend(v29, *(SEL *)(a1 + 496), a2, a3);
      v16 = v30;
      if (v30)
        CFRetain(v30);
      goto LABEL_33;
    }
    LOBYTE(v15) = 0;
LABEL_52:
    v16 = 0;
    goto LABEL_34;
  }
  v16 = (CFTypeRef)v21();
  LOBYTE(v15) = 0;
LABEL_34:
  v22 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v22)
  {
    --*(_DWORD *)v22;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v22 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v31, v32);
  }
  if (v16)
    v23 = (char)v15;
  else
    v23 = 1;
  if ((v23 & 1) == 0)
    CFRetain(v16);
  v24 = mach_absolute_time();
  v25 = _IOHIDGetTimestampDelta(v24, v8, 1u);
  if (v25 > *(_QWORD *)(a1 + 384))
    *(_QWORD *)(a1 + 384) = v25;
  return v16;
}

uint64_t _iohideventsystem_client_dispatch_service_removal(unsigned int a1, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v4;
  const void *v5;
  CFDictionaryRef *v6;
  CFDictionaryRef *v7;
  CFTypeID v8;
  uint64_t v9;
  _QWORD *Value;

  v4 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  if (v4)
  {
    v5 = v4;
    v6 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    if (v6)
    {
      v7 = v6;
      v8 = CFGetTypeID(v6);
      v9 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        v9 = __kIOHIDEventSystemClientTypeID;
      }
      if (v8 == v9)
      {
        os_unfair_recursive_lock_lock_with_options();
        Value = CFDictionaryGetValue(v7[12], v5);
        os_unfair_recursive_lock_unlock();
        if (Value)
        {
          _IOHIDServiceClientDispatchServiceRemoval(Value);
          os_unfair_recursive_lock_lock_with_options();
          CFDictionaryRemoveValue(v7[12], v5);
          os_unfair_recursive_lock_unlock();
        }
      }
      CFRelease(v7);
    }
    CFRelease(v5);
  }
  return 0;
}

void _IOHIDServiceClientReleasePrivate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  void *v5;
  const void *v6;
  void *v7;

  IOHIDServiceClientFastPathInvalidate((uint64_t)a1);
  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[12];
  if (v3)
  {
    CFRelease(v3);
    a1[12] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
    _Block_release(v4);
  v5 = (void *)a1[8];
  if (v5)
    free(v5);
  v6 = (const void *)a1[15];
  if (v6)
    _Block_release(v6);
  v7 = (void *)a1[17];
  if (v7)
    free(v7);
}

IOCFPlugInInterface **IOHIDServiceClientFastPathInvalidate(uint64_t a1)
{
  uint64_t v2;
  IOCFPlugInInterface **result;

  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, 0);
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 24))(*(_QWORD *)(a1 + 104));
    *(_QWORD *)(a1 + 104) = 0;
  }
  result = *(IOCFPlugInInterface ***)(a1 + 112);
  if (result)
  {
    result = (IOCFPlugInInterface **)IODestroyPlugInInterface(result);
    *(_QWORD *)(a1 + 112) = 0;
  }
  return result;
}

uint64_t _iohideventsystem_client_dispatch_virtual_service_copy_property(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, vm_offset_t *a5, _DWORD *a6)
{
  mach_vm_size_t v11;
  CFTypeID TypeID;
  const void *v13;
  const void *v14;
  CFDictionaryRef *v15;
  CFDictionaryRef *v16;
  CFTypeID v17;
  uint64_t v18;
  _QWORD *Value;
  _QWORD *v20;
  const void *v21;
  NSObject *v22;
  NSObject *v24;
  NSObject *v25;

  v11 = a4;
  TypeID = CFStringGetTypeID();
  v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a3, v11, TypeID);
  if (v13)
  {
    v14 = v13;
    v15 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    v16 = v15;
    if (v15)
    {
      v17 = CFGetTypeID(v15);
      v18 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        v18 = __kIOHIDEventSystemClientTypeID;
      }
      if (v17 == v18)
      {
        os_unfair_recursive_lock_lock_with_options();
        Value = CFDictionaryGetValue(v16[13], a2);
        if (Value)
        {
          v20 = Value;
          CFRetain(Value);
          os_unfair_recursive_lock_unlock();
          v21 = (const void *)_IOHIDVirtualServiceClientCopyProperty(v20, (uint64_t)v14);
          *a6 = _IOHIDSerialize(v21, a5);
          CFRelease(v20);
          if (v21)
            CFRelease(v21);
        }
        else
        {
          os_unfair_recursive_lock_unlock();
          v22 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_3();
        }
        CFRelease(v14);
LABEL_12:
        CFRelease(v16);
        return 0;
      }
    }
    v24 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
    CFRelease(v14);
    if (v16)
      goto LABEL_12;
  }
  else
  {
    v25 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_1();
  }
  return 0;
}

const void *IOMIGMachPortCacheCopy(unsigned int a1)
{
  const void *Value;
  const void *v3;

  pthread_mutex_lock(&__ioPortCacheLock);
  Value = CFDictionaryGetValue((CFDictionaryRef)__ioPortCache, (const void *)a1);
  v3 = Value;
  if (Value)
    CFRetain(Value);
  pthread_mutex_unlock(&__ioPortCacheLock);
  return v3;
}

CFTypeRef _IOHIDSerialize(CFTypeRef result, vm_offset_t *a2)
{
  const __CFData *v3;
  vm_size_t Length;
  vm_map_read_t v5;
  const UInt8 *BytePtr;
  mach_msg_type_number_t dataCnt;

  if (result)
  {
    result = _IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], result);
    if (result)
    {
      v3 = (const __CFData *)result;
      dataCnt = 0;
      Length = CFDataGetLength((CFDataRef)result);
      v5 = *MEMORY[0x1E0C83DA0];
      BytePtr = CFDataGetBytePtr(v3);
      LODWORD(Length) = vm_read(v5, (vm_address_t)BytePtr, Length, a2, &dataCnt);
      CFRelease(v3);
      if ((_DWORD)Length)
      {
        result = 0;
        *a2 = 0;
      }
      else
      {
        return (CFTypeRef)dataCnt;
      }
    }
  }
  return result;
}

CFPropertyListRef __IOHIDServiceVirtualCopyPropertyCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t SenderID;
  const __CFData *v6;
  const __CFData *v7;
  mach_port_t v8;
  const UInt8 *BytePtr;
  int v10;
  int v11;
  int v12;
  NSObject *v13;
  CFPropertyListRef v14;
  uint64_t v16;
  NSObject *v17;
  _DWORD length[3];
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  SenderID = _IOHIDServiceGetSenderID(a1);
  memset(length, 0, sizeof(length));
  if (!a3)
  {
    v17 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      __IOHIDServiceVirtualCopyPropertyCallback_cold_1();
    return 0;
  }
  v6 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a3);
  if (!v6)
    return 0;
  v7 = v6;
  if (*(_DWORD *)(a2 + 448))
  {
    v14 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(a2 + 40);
    BytePtr = CFDataGetBytePtr(v6);
    v10 = CFDataGetLength(v7);
    v11 = iohideventsystem_client_dispatch_virtual_service_copy_property(v8, SenderID, (uint64_t)BytePtr, v10, &length[1], length, 0x20u);
    if (v11)
    {
      v12 = v11;
      v13 = _IOHIDLogCategory(9u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v16 = *(_QWORD *)(a2 + 168);
        *(_DWORD *)buf = 136315650;
        v20 = v16;
        v21 = 2048;
        v22 = SenderID;
        v23 = 1024;
        v24 = v12;
        _os_log_error_impl(&dword_18AAAF000, v13, OS_LOG_TYPE_ERROR, "%s: HIDVS ID:%llx iohideventsystem_client_dispatch_virtual_service_copy_property:%x", buf, 0x1Cu);
      }
      __IOHIDEventSystemConnectionCheckServerStatus(v12, a2);
    }
    v14 = _IOHIDUnserializeAndVMDealloc(*(UInt8 **)&length[1], length[0]);
  }
  CFRelease(v7);
  return v14;
}

CFTypeRef _IOHIDCreateBinaryData(CFAllocatorRef bufferAllocator, const void *a2)
{
  CFTypeRef v2;
  __CFWriteStream *v3;
  __CFWriteStream *v4;
  NSObject *v5;
  CFStringRef errorString;

  v2 = a2;
  errorString = 0;
  if (a2)
  {
    v3 = CFWriteStreamCreateWithAllocatedBuffers(bufferAllocator, bufferAllocator);
    if (v3)
    {
      v4 = v3;
      if (CFWriteStreamOpen(v3))
      {
        CFPropertyListWriteToStream(v2, v4, kCFPropertyListBinaryFormat_v1_0, &errorString);
        CFWriteStreamClose(v4);
        v2 = CFWriteStreamCopyProperty(v4, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
      }
      else
      {
        v2 = 0;
      }
      CFRelease(v4);
      if (errorString)
      {
        v5 = _IOHIDLog();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          _IOHIDCreateBinaryData_cold_1((uint64_t *)&errorString, v5);
        CFRelease(errorString);
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

const void *_IOHIDUnserializeAndVMDeallocWithTypeID(UInt8 *a1, mach_vm_size_t a2, uint64_t a3)
{
  CFPropertyListRef v4;
  const void *v5;

  v4 = _IOHIDUnserializeAndVMDealloc(a1, a2);
  v5 = v4;
  if (v4 && CFGetTypeID(v4) != a3)
  {
    CFRelease(v5);
    return 0;
  }
  return v5;
}

CFPropertyListRef _IOHIDUnserializeAndVMDealloc(UInt8 *bytes, mach_vm_size_t length)
{
  CFPropertyListRef v2;
  const __CFAllocator *v5;
  __CFReadStream *v6;
  __CFReadStream *v7;
  CFPropertyListFormat format;

  v2 = 0;
  if (bytes && length)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v6)
    {
      v7 = v6;
      if (CFReadStreamOpen(v6))
      {
        format = kCFPropertyListBinaryFormat_v1_0;
        v2 = CFPropertyListCreateFromStream(v5, v7, length, 2uLL, &format, 0);
        CFReadStreamClose(v7);
      }
      else
      {
        v2 = 0;
      }
      CFRelease(v7);
    }
    else
    {
      v2 = 0;
    }
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)bytes, length);
  }
  return v2;
}

uint64_t _IOHIDServiceGetSenderID(uint64_t a1)
{
  uint64_t valuePtr;

  valuePtr = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, &valuePtr);
  return valuePtr;
}

uint64_t iohideventsystem_client_dispatch_virtual_service_copy_property(mach_port_t a1, uint64_t a2, uint64_t a3, int a4, _QWORD *a5, _DWORD *a6, mach_msg_timeout_t a7)
{
  mach_port_t special_reply_port;
  uint64_t v12;
  uint64_t v13;
  int v14;
  mach_msg_header_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  v17 = 1;
  v18 = a3;
  v19 = 16777472;
  v20 = a4;
  v21 = *MEMORY[0x1E0C804E8];
  v22 = a2;
  v23 = a4;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v16.msgh_bits = 2147489043;
  v16.msgh_remote_port = a1;
  v16.msgh_local_port = special_reply_port;
  *(_QWORD *)&v16.msgh_voucher_port = 0x124FE00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v16);
    special_reply_port = v16.msgh_local_port;
  }
  v12 = mach_msg(&v16, 3162515, 0x40u, 0x40u, special_reply_port, a7, 0);
  v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v12)
    {
      if (v16.msgh_id == 71)
      {
        v13 = 4294966988;
      }
      else if (v16.msgh_id == 75106)
      {
        if ((v16.msgh_bits & 0x80000000) == 0)
        {
          if (v16.msgh_size == 36)
          {
            v13 = 4294966996;
            if (HIDWORD(v18))
            {
              if (v16.msgh_remote_port)
                v13 = 4294966996;
              else
                v13 = HIDWORD(v18);
            }
          }
          else
          {
            v13 = 4294966996;
          }
          goto LABEL_26;
        }
        v13 = 4294966996;
        if (v17 == 1 && *(_QWORD *)&v16.msgh_size == 56 && HIBYTE(v19) == 1)
        {
          v14 = v20;
          if (v20 == (_DWORD)v22)
          {
            v13 = 0;
            *a5 = v18;
            *a6 = v14;
            return v13;
          }
        }
      }
      else
      {
        v13 = 4294966995;
      }
LABEL_26:
      mach_msg_destroy(&v16);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v13 - 268435459) <= 1)
  {
    if ((v16.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v16.msgh_local_port);
    goto LABEL_26;
  }
  return v13;
}

uint64_t _IOHIDVirtualServiceClientCopyProperty(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD *, uint64_t);

  v2 = a1[8];
  if (v2 && (v3 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(v2 + 24)) != 0)
    return v3(a1[9], a1[10], a1, a2);
  else
    return 0;
}

uint64_t _Xiohideventsystem_client_dispatch_notification_results(uint64_t result, uint64_t a2)
{
  CFIndex v3;
  unsigned int v4;
  int v5;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    v5 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v5;
    goto LABEL_11;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || (v3 = *(unsigned int *)(result + 40), (_DWORD)v3 != *(_DWORD *)(result + 68))
    || (v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 72)))
  {
    v5 = -300;
    goto LABEL_10;
  }
  result = _iohideventsystem_client_dispatch_notification_results(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(UInt8 **)(result + 44), v4);
  *(_DWORD *)(a2 + 32) = result;
LABEL_11:
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t _iohideventsystem_client_dispatch_notification_results(unsigned int a1, UInt8 *bytes, CFIndex length, UInt8 *a4, unsigned int a5)
{
  CFPropertyListRef v8;
  CFTypeID TypeID;
  const __CFArray *v10;
  const __CFArray *v11;
  CFDictionaryRef *v12;
  CFDictionaryRef *v13;
  CFTypeID v14;
  uint64_t v15;
  const void *Value;
  uint64_t v17;
  _QWORD v19[5];
  _QWORD v20[5];

  v8 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  TypeID = CFArrayGetTypeID();
  v10 = (const __CFArray *)_IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  v11 = v10;
  if (v8 && v10)
  {
    v12 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    if (v12)
    {
      v13 = v12;
      v14 = CFGetTypeID(v12);
      v15 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        v15 = __kIOHIDEventSystemClientTypeID;
      }
      if (v14 == v15)
      {
        os_unfair_recursive_lock_lock_with_options();
        Value = CFDictionaryGetValue(v13[11], v8);
        os_unfair_recursive_lock_unlock();
        if (Value)
        {
          v17 = MEMORY[0x1E0C809B0];
          v20[0] = MEMORY[0x1E0C809B0];
          v20[1] = 0x40000000;
          v20[2] = ____IOHIDEventSystemClientCacheServices_block_invoke;
          v20[3] = &__block_descriptor_tmp_93;
          v20[4] = v13;
          _IOHIDCFArrayApplyBlock(v11, v20);
          os_unfair_recursive_lock_lock_with_options();
          if (v13[21] || v13[22])
          {
            v19[0] = v17;
            v19[1] = 0x40000000;
            v19[2] = ___iohideventsystem_client_dispatch_notification_results_block_invoke;
            v19[3] = &__block_descriptor_tmp_30_0;
            v19[4] = v13;
            _IOHIDCFArrayApplyBlock(v11, v19);
          }
          os_unfair_recursive_lock_unlock();
        }
      }
      CFRelease(v13);
    }
    goto LABEL_13;
  }
  if (v8)
LABEL_13:
    CFRelease(v8);
  if (v11)
    CFRelease(v11);
  return 0;
}

uint64_t _IOHIDServiceClientDispatchServiceRemoval(_QWORD *a1)
{
  uint64_t v2;
  void (*v3)(_QWORD, _QWORD, _QWORD *);

  os_unfair_recursive_lock_lock_with_options();
  v2 = a1[5];
  if (v2)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD *))(v2 + 16))(v2, a1[6], a1[7], a1);
  }
  else
  {
    v3 = (void (*)(_QWORD, _QWORD, _QWORD *))a1[4];
    if (v3)
      v3(a1[6], a1[7], a1);
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _Xiohideventsystem_client_dispatch_virtual_service_set_property(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  int v5;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    v4 = *MEMORY[0x1E0C804E8];
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 60)))
  {
    v5 = -300;
    goto LABEL_9;
  }
  result = _iohideventsystem_client_dispatch_virtual_service_set_property(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(UInt8 **)(result + 28), v3, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v4 = *MEMORY[0x1E0C804E8];
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_10:
  *(_QWORD *)(a2 + 24) = v4;
  return result;
}

uint64_t _iohideventsystem_client_dispatch_virtual_service_set_property(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, _DWORD *a5)
{
  mach_vm_size_t v9;
  CFTypeID TypeID;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  CFDictionaryRef *v13;
  CFDictionaryRef *v14;
  CFTypeID v15;
  uint64_t v16;
  const void *Value;
  const void *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  NSObject *v22;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;

  v9 = a4;
  TypeID = CFDictionaryGetTypeID();
  v11 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a3, v9, TypeID);
  if (v11)
  {
    v12 = v11;
    v13 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    v14 = v13;
    if (v13)
    {
      v15 = CFGetTypeID(v13);
      v16 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        v16 = __kIOHIDEventSystemClientTypeID;
      }
      if (v15 == v16)
      {
        Value = CFDictionaryGetValue(v12, CFSTR("Key"));
        v18 = CFDictionaryGetValue(v12, CFSTR("Value"));
        if (Value)
        {
          v19 = (uint64_t)v18;
          os_unfair_recursive_lock_lock_with_options();
          v20 = CFDictionaryGetValue(v14[13], a2);
          if (v20)
          {
            v21 = v20;
            CFRetain(v20);
            os_unfair_recursive_lock_unlock();
            *a5 = _IOHIDVirtualServiceClientSetProperty(v21, (uint64_t)Value, v19);
            CFRelease(v21);
          }
          else
          {
            os_unfair_recursive_lock_unlock();
            *a5 = -536870208;
            v22 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              _iohideventsystem_client_dispatch_virtual_service_set_property_cold_4();
          }
        }
        else
        {
          *a5 = -536870212;
          v26 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            _iohideventsystem_client_dispatch_virtual_service_set_property_cold_3();
        }
        CFRelease(v12);
LABEL_12:
        CFRelease(v14);
        return 0;
      }
    }
    *a5 = -536870206;
    v24 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
    CFRelease(v12);
    if (v14)
      goto LABEL_12;
  }
  else
  {
    *a5 = -536870206;
    v25 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_1();
  }
  return 0;
}

uint64_t _IOHIDVirtualServiceClientSetProperty(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t);

  v3 = a1[8];
  if (v3 && (v4 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t))(v3 + 16)) != 0)
    return v4(a1[9], a1[10], a1, a2, a3);
  else
    return 0;
}

uint64_t _Xio_hideventsystem_set_properties_for_service(uint64_t result, uint64_t a2)
{
  CFIndex v3;
  unsigned int v4;
  uint64_t v5;
  int v6;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    v6 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v6;
    v5 = *MEMORY[0x1E0C804E8];
    goto LABEL_12;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || (v3 = *(unsigned int *)(result + 40), (_DWORD)v3 != *(_DWORD *)(result + 68))
    || (v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 72)))
  {
    v6 = -300;
    goto LABEL_11;
  }
  result = _io_hideventsystem_set_properties_for_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(UInt8 **)(result + 44), v4, (int *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v5 = *MEMORY[0x1E0C804E8];
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 24) = v5;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_12:
  *(_QWORD *)(a2 + 24) = v5;
  return result;
}

uint64_t _io_hideventsystem_copy_property_for_service(unsigned int a1, UInt8 *bytes, CFIndex length, UInt8 *a4, unsigned int a5, vm_offset_t *a6, _DWORD *a7, _DWORD *a8)
{
  const void *v14;
  CFPropertyListRef v15;
  CFTypeID TypeID;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  CFTypeID v21;
  uint64_t v22;
  uint64_t System;
  const void *v24;
  const void *v25;

  *a7 = 0;
  LODWORD(v14) = -536870206;
  v15 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  TypeID = CFStringGetTypeID();
  v17 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  v18 = v17;
  if (v17 && v15)
  {
    v19 = IOMIGMachPortCacheCopy(a1);
    v20 = v19;
    if (v19)
    {
      v21 = CFGetTypeID(v19);
      v22 = IOHIDEventSystemConnectionGetTypeID();
      if (a6)
      {
        if (v21 == v22)
        {
          System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v20);
          if (System)
          {
            v24 = IOHIDEventSystemCopyService(System, v15);
            if (v24)
            {
              v25 = v24;
              if (IOHIDEventSystemConnectionGetType((uint64_t)v20) != 4
                || CFSetContainsValue((CFSetRef)__whiteListSet, v18))
              {
                v14 = (const void *)_IOHIDServiceCopyPropertyForClient((uint64_t)v25, v18, v20);
                *a7 = _IOHIDSerialize(v14, a6);
                if (v14)
                {
                  CFRelease(v14);
                  LODWORD(v14) = 0;
                }
              }
              CFRelease(v18);
              CFRelease(v25);
              CFRelease(v15);
LABEL_13:
              CFRelease(v20);
              goto LABEL_14;
            }
            LODWORD(v14) = -536870160;
          }
          else
          {
            LODWORD(v14) = -536870185;
          }
        }
      }
    }
    CFRelease(v18);
    CFRelease(v15);
    if (!v20)
      goto LABEL_14;
    goto LABEL_13;
  }
  if (v17)
    CFRelease(v17);
  v20 = v15;
  if (v15)
    goto LABEL_13;
LABEL_14:
  *a8 = (_DWORD)v14;
  return 0;
}

uint64_t _io_hideventsystem_set_properties_for_service(unsigned int a1, UInt8 *bytes, CFIndex length, UInt8 *a4, unsigned int a5, int *a6)
{
  int v10;
  CFPropertyListRef v11;
  CFTypeID TypeID;
  const void *v13;
  const void *v14;
  const void *v15;
  uint64_t v16;
  CFTypeID v17;
  uint64_t System;
  const void *v19;
  const void *v20;
  const void *v21;
  _QWORD context[7];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;

  v10 = -536870206;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = -536870212;
  v11 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  TypeID = CFDictionaryGetTypeID();
  v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  v14 = v13;
  if (v11 && v13)
  {
    v15 = IOMIGMachPortCacheCopy(a1);
    if (!v15)
    {
      *((_DWORD *)v25 + 6) = -536870185;
      *a6 = -536870185;
      v16 = (uint64_t)v11;
      goto LABEL_11;
    }
    v16 = (uint64_t)v15;
    v17 = CFGetTypeID(v15);
    if (v17 == IOHIDEventSystemConnectionGetTypeID())
    {
      System = _IOHIDEventSystemConnectionGetSystem(v16);
      if (!System)
      {
LABEL_15:
        *((_DWORD *)v25 + 6) = v10;
        *a6 = v10;
        v21 = v14;
LABEL_10:
        CFRelease(v21);
        v14 = v11;
LABEL_11:
        CFRelease(v14);
        v11 = (CFPropertyListRef)v16;
LABEL_12:
        CFRelease(v11);
        goto LABEL_13;
      }
      v19 = IOHIDEventSystemCopyService(System, v11);
      if (v19)
      {
        v20 = v19;
        if (CFDictionaryGetCount((CFDictionaryRef)v14))
        {
          *((_DWORD *)v25 + 6) = 0;
          context[0] = MEMORY[0x1E0C809B0];
          context[1] = 0x40000000;
          context[2] = ___io_hideventsystem_set_properties_for_service_block_invoke;
          context[3] = &unk_1E20037F0;
          context[4] = &v24;
          context[5] = v16;
          context[6] = v20;
          _IOHIDCFDictionaryApplyBlock((const __CFDictionary *)v14, context);
          v10 = *((_DWORD *)v25 + 6);
        }
        else
        {
          *((_DWORD *)v25 + 6) = -536870206;
        }
        *a6 = v10;
        CFRelease(v14);
        v21 = v20;
        goto LABEL_10;
      }
    }
    v10 = -536870185;
    goto LABEL_15;
  }
  *((_DWORD *)v25 + 6) = -536870206;
  *a6 = -536870206;
  if (v13)
    CFRelease(v13);
  if (v11)
    goto LABEL_12;
LABEL_13:
  _Block_object_dispose(&v24, 8);
  return 0;
}

uint64_t _IOHIDEventSystemConnectionGetSystem(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

const void *IOHIDEventSystemCopyService(uint64_t a1, const void *a2)
{
  const void *Value;
  const void *v5;

  os_unfair_recursive_lock_lock_with_options();
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  v5 = Value;
  if (Value)
  {
    CFRetain(Value);
    os_unfair_recursive_lock_unlock();
    if (_IOHIDServiceIsInactive((uint64_t)v5))
    {
      CFRelease(v5);
      return 0;
    }
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
  return v5;
}

void _IOHIDCFDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)__IOHIDCFDictionaryFunctionApplier, context);
}

uint64_t _Xio_hideventsystem_copy_property_for_service(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    v3 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_12;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 68)
    || *(_DWORD *)(result + 56) != *(_DWORD *)(result + 72))
  {
    v3 = -300;
    goto LABEL_11;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = _io_hideventsystem_copy_property_for_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(unsigned int *)(result + 40), *(UInt8 **)(result + 44), *(_DWORD *)(result + 56), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52), (_DWORD *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_12:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(_QWORD *)(a2 + 44) = *MEMORY[0x1E0C804E8];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _Xio_hideventsystem_copy_matching_services(uint64_t result, uint64_t a2)
{
  int v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = 16777473;
  result = _io_hideventsystem_copy_matching_services(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 68), (vm_offset_t *)(a2 + 44), (_DWORD *)(a2 + 72));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  v4 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 56) = v4;
  *(_QWORD *)(a2 + 60) = *MEMORY[0x1E0C804E8];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 76;
  *(_DWORD *)(a2 + 24) = 2;
  return result;
}

uint64_t _io_hideventsystem_copy_matching_services(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, _DWORD *a5, vm_offset_t *a6, _DWORD *a7)
{
  mach_vm_size_t v13;
  CFTypeID TypeID;
  const __CFDictionary *v15;
  const void *v16;
  const void *v17;
  CFTypeID v18;
  const __CFAllocator *v19;
  CFNumberRef v20;
  CFDictionaryRef *System;
  const __CFArray *v22;
  const __CFArray *v23;
  const __CFArray *v24;
  CFTypeRef cf;

  cf = 0;
  *a5 = 0;
  *a7 = 0;
  v13 = a3;
  TypeID = CFDictionaryGetTypeID();
  v15 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a2, v13, TypeID);
  v16 = IOMIGMachPortCacheCopy(a1);
  v17 = v16;
  if (v16 && (v18 = CFGetTypeID(v16), v18 == IOHIDEventSystemConnectionGetTypeID()))
  {
    v19 = CFGetAllocator(v17);
    v20 = CFNumberCreate(v19, kCFNumberSInt64Type, &_io_hideventsystem_copy_matching_services_sNotificationID);
    ++_io_hideventsystem_copy_matching_services_sNotificationID;
    if (v20)
    {
      System = (CFDictionaryRef *)_IOHIDEventSystemConnectionGetSystem((uint64_t)v17);
      if (System)
      {
        v22 = (const __CFArray *)IOHIDEventSystemCopyMatchingServices(System, v15, (uint64_t)__io_hideventsystem_matching_services_callback, v17, (uint64_t)v20, &cf);
        if (cf)
        {
          _IOHIDEventSystemConnectionAddNotification((uint64_t)v17, v20, cf);
          *a5 = _IOHIDSerialize(v20, a4);
        }
        if (v22)
        {
          v23 = _IOHIDCopyServiceClientInfo(v22);
          if (v23)
          {
            v24 = v23;
            _IOHIDEventSystemConnectionAddServices((uint64_t)v17, v22, 0);
            *a7 = _IOHIDSerialize(v24, a6);
            CFRelease(v24);
          }
          CFRelease(v22);
        }
      }
    }
  }
  else
  {
    v20 = 0;
  }
  if (cf)
    CFRelease(cf);
  if (v20)
    CFRelease(v20);
  if (v17)
    CFRelease(v17);
  if (v15)
    CFRelease(v15);
  return 0;
}

void _IOHIDEventSystemConnectionAddNotification(uint64_t a1, const void *a2, const void *a3)
{
  os_unfair_lock_s *v6;

  v6 = (os_unfair_lock_s *)(a1 + 268);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), a2, a3);
  os_unfair_lock_unlock(v6);
}

uint64_t IOHIDEventSystemCopyMatchingServices(CFDictionaryRef *a1, const __CFDictionary *a2, uint64_t a3, const void *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v7;

  v7 = 0;
  __IOHIDEventSystemCopyMatchingServices(a1, a2, a3, a4, a5, a6, &v7);
  return v7;
}

void __IOHIDEventSystemCopyMatchingServices(CFDictionaryRef *cf, const __CFDictionary *a2, uint64_t a3, CFTypeRef a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  const __CFDictionary *MutableCopy;
  const __CFAllocator *v14;
  CFTypeID v15;
  CFTypeRef v16;
  CFAllocatorRef v17;
  _QWORD *v18;
  const void *v19;
  const __CFAllocator *v20;
  const __CFDictionary *Copy;
  uint64_t v22;
  _QWORD context[3];

  MutableCopy = a2;
  if (a2)
  {
    v14 = CFGetAllocator(cf);
    MutableCopy = CFDictionaryCreateMutableCopy(v14, 0, MutableCopy);
  }
  if (a4)
  {
    v15 = CFGetTypeID(a4);
    if (v15 == IOHIDEventSystemConnectionGetTypeID())
      v16 = a4;
    else
      v16 = 0;
  }
  else
  {
    v16 = 0;
  }
  context[0] = 0;
  context[1] = MutableCopy;
  context[2] = v16;
  os_unfair_recursive_lock_lock_with_options();
  if (a3)
  {
    if (a6)
    {
      v17 = CFGetAllocator(cf);
      v18 = IOHIDNotificationCreate((uint64_t)v17, (uint64_t)__IOHIDEventSystemMatchNotifyRelease, (uint64_t)cf, (uint64_t)MutableCopy, a3, (uint64_t)a4, a5);
      if (v18)
      {
        v19 = v18;
        if (MutableCopy)
          CFRetain(MutableCopy);
        CFSetAddValue(cf[5], v19);
        *a6 = v19;
      }
    }
  }
  if (a7 && CFDictionaryGetCount(cf[2]))
  {
    v20 = CFGetAllocator(cf);
    Copy = CFDictionaryCreateCopy(v20, cf[2]);
    os_unfair_recursive_lock_unlock();
    if (Copy)
    {
      CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__IOHIDEventSystemCompareServiceFunction, context);
      CFRelease(Copy);
      v22 = context[0];
    }
    else
    {
      v22 = 0;
    }
    *a7 = v22;
    os_unfair_recursive_lock_lock_with_options();
  }
  os_unfair_recursive_lock_unlock();
  if (MutableCopy)
    CFRelease(MutableCopy);
}

_QWORD *IOHIDNotificationCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  _QWORD *result;

  v14 = __kIOHIDNotificationTypeID;
  if (!__kIOHIDNotificationTypeID)
  {
    pthread_once(&__notificationTypeInit, (void (*)(void))__IOHIDNotificationRegister);
    v14 = __kIOHIDNotificationTypeID;
  }
  result = (_QWORD *)_IOHIDObjectCreateInstance(a1, v14, 0x50uLL);
  if (result)
  {
    result[3] = a5;
    result[4] = a6;
    result[5] = a7;
    result[6] = a2;
    result[7] = a3;
    result[8] = a4;
    result[10] = 0;
    result[11] = 0;
  }
  return result;
}

uint64_t _IOHIDObjectCreateInstance(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t Instance;
  uint64_t v5;

  Instance = _CFRuntimeCreateInstance();
  v5 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), a3);
    *(_DWORD *)(v5 + 16) = 1;
    *(_DWORD *)(v5 + 20) = 1;
  }
  return v5;
}

_DWORD *_Xio_hideventsystem_clear_service_cache(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  }
  else
  {
    result = (_DWORD *)_io_hideventsystem_clear_service_cache(result[3]);
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t _io_hideventsystem_clear_service_cache(unsigned int a1)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;

  v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    if (v3 == IOHIDEventSystemConnectionGetTypeID())
      _IOHIDEventSystemConnectionRemoveAllServices((uint64_t)v2);
    CFRelease(v2);
  }
  return 0;
}

void _IOHIDEventSystemConnectionRemoveAllServices(uint64_t a1)
{
  uint64_t v2;
  const __CFAllocator *v3;
  CFSetRef Copy;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(_QWORD *)(a1 + 8);
  v3 = CFGetAllocator((CFTypeRef)a1);
  Copy = CFSetCreateCopy(v3, *(CFSetRef *)(a1 + 80));
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 80));
  os_unfair_recursive_lock_unlock();
  if (v2 && Copy)
  {
    _IOHIDEventSystemRemoveServicesForConnection(v2, Copy, a1);
LABEL_4:
    CFRelease(Copy);
    return;
  }
  if (Copy)
    goto LABEL_4;
}

void _IOHIDEventSystemRemoveServicesForConnection(uint64_t a1, const void *a2, uint64_t a3)
{
  CFTypeID v4;
  const __CFAllocator *v5;
  const __CFArray *Copy;
  const __CFArray *v7;
  CFTypeID v8;
  const __CFAllocator *v9;
  const __CFSet *v10;
  CFTypeID v11;
  const __CFAllocator *v12;
  _QWORD v13[2];
  CFRange v14;

  v13[0] = a1;
  v13[1] = a3;
  os_unfair_recursive_lock_lock_with_options();
  v4 = CFGetTypeID(a2);
  if (v4 == CFArrayGetTypeID())
  {
    v5 = CFGetAllocator(a2);
    Copy = CFArrayCreateCopy(v5, (CFArrayRef)a2);
    os_unfair_recursive_lock_unlock();
    if (!Copy)
      return;
    v14.length = CFArrayGetCount((CFArrayRef)a2);
    v14.location = 0;
    CFArrayApplyFunction(Copy, v14, (CFArrayApplierFunction)ServiceClientFunctionRemove, v13);
    v7 = Copy;
    goto LABEL_11;
  }
  v8 = CFGetTypeID(a2);
  if (v8 == CFSetGetTypeID())
  {
    v9 = CFGetAllocator(a2);
    v10 = CFSetCreateCopy(v9, (CFSetRef)a2);
    os_unfair_recursive_lock_unlock();
    if (!v10)
      return;
    CFSetApplyFunction(v10, (CFSetApplierFunction)ServiceClientFunctionRemove, v13);
    goto LABEL_10;
  }
  v11 = CFGetTypeID(a2);
  if (v11 != CFDictionaryGetTypeID())
  {
    os_unfair_recursive_lock_unlock();
    return;
  }
  v12 = CFGetAllocator(a2);
  v10 = CFDictionaryCreateCopy(v12, (CFDictionaryRef)a2);
  os_unfair_recursive_lock_unlock();
  if (v10)
  {
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)ServiceDictClientFunctionRemove, v13);
LABEL_10:
    v7 = v10;
LABEL_11:
    CFRelease(v7);
  }
}

const void **__IOHIDServiceNotificationSetApplier(const void **result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = ____IOHIDServiceNotificationSetApplier_block_invoke;
    v2[3] = &__block_descriptor_tmp_201;
    v2[4] = a2;
    return IOHIDNotificationSignalWithBlock(result, (uint64_t)v2);
  }
  return result;
}

void __IOHIDEventSystemMatchNotifyFunction(const void **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  const __CFArray *v6;
  const void *v7;
  _QWORD v8[6];
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v10 = 0;
  v11 = &v10;
  v12 = 0x3000000000;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  if (a1)
  {
    v13 = 0;
    v14 = 0;
    v4 = MEMORY[0x1E0C809B0];
    v15 = 0;
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = ____IOHIDEventSystemMatchNotifyFunction_block_invoke;
    v9[3] = &unk_1E2002950;
    v9[4] = &v10;
    IOHIDNotificationSignalWithBlock(a1, (uint64_t)v9);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 8), (CFDictionaryApplierFunction)__IOHIDEventSystemCompareServiceFunction, v11 + 3);
    v5 = v11;
    v6 = (const __CFArray *)v11[3];
    if (v6)
    {
      if (CFArrayGetCount(v6))
      {
        v8[0] = v4;
        v8[1] = 0x40000000;
        v8[2] = ____IOHIDEventSystemMatchNotifyFunction_block_invoke_2;
        v8[3] = &unk_1E2002978;
        v8[4] = &v10;
        v8[5] = a2;
        IOHIDNotificationSignalWithBlock(a1, (uint64_t)v8);
      }
      CFRelease((CFTypeRef)v11[3]);
      v5 = v11;
    }
    v7 = (const void *)v5[4];
    if (v7)
      CFRelease(v7);
  }
  _Block_object_dispose(&v10, 8);
}

const void **IOHIDNotificationSignalWithBlock(const void **result, uint64_t a2)
{
  OSQueueHead *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = (OSQueueHead *)result;
  v3 = (unsigned int *)(result + 9);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  if ((v4 & 0x80000000) != 0)
  {
    do
      v5 = __ldaxr(v3);
    while (__stlxr(v5 - 1, v3));
  }
  else
  {
    result = (const void **)(*(uint64_t (**)(uint64_t, const void *, const void *, const void *, const void *, const void *))(a2 + 16))(a2, result[7], result[8], result[3], result[4], result[5]);
    do
      v5 = __ldaxr(v3);
    while (__stlxr(v5 - 1, v3));
  }
  if (v5 == -2147483647)
    return __IOHIDNotificationInvalidateCompletion(v2);
  return result;
}

void _IOHIDEventSystemConnectionAddServices(uint64_t a1, const __CFArray *a2, const void *a3)
{
  CFSetRef *v6;
  mach_port_t v7;
  int v8;
  CFMutableArrayRef Mutable;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  const __CFAllocator *v18;
  CFTypeRef v19;
  const void *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  const __CFAllocator *v23;
  const __CFData *v24;
  const __CFData *v25;
  const UInt8 *BytePtr;
  int Length;
  const UInt8 *v28;
  int v29;
  int v30;
  int v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  os_log_type_t v35;
  NSObject *v36;
  uint64_t v37;
  NSObject *v38;
  mach_port_t v39;
  const void *v40;
  _QWORD v41[6];
  int valuePtr;
  uint64_t v43;
  __int16 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v6 = *(CFSetRef **)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 40);
  v8 = *(_DWORD *)(a1 + 176);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v10 = Mutable;
    v39 = v7;
    v41[0] = MEMORY[0x1E0C809B0];
    v41[1] = 0x40000000;
    v41[2] = ___IOHIDEventSystemConnectionAddServices_block_invoke;
    v41[3] = &__block_descriptor_tmp_24;
    v41[4] = a1;
    v41[5] = Mutable;
    _IOHIDCFArrayApplyBlock(a2, v41);
    if (!CFArrayGetCount(v10))
      goto LABEL_29;
    v40 = a3;
    Count = CFArrayGetCount(v10);
    if (Count >= 1)
    {
      v12 = Count;
      for (i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
        v15 = ValueAtIndex;
        if (v8 == 2)
        {
          v16 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient((uint64_t)ValueAtIndex, CFSTR("QueueSize"), (const void *)a1);
          if (v16)
          {
            v17 = v16;
            valuePtr = 0;
            CFNumberGetValue(v16, kCFNumberSInt32Type, &valuePtr);
            CFRelease(v17);
            if (!valuePtr)
              continue;
          }
        }
        os_unfair_recursive_lock_lock_with_options();
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 80), v15);
        os_unfair_recursive_lock_unlock();
        _IOHIDEventSystemAddServiceForConnection(v6, (uint64_t)v15, (const void *)a1);
      }
    }
    if (!v40)
      goto LABEL_29;
    v18 = CFGetAllocator((CFTypeRef)a1);
    v19 = _IOHIDCreateBinaryData(v18, v40);
    if (!v19)
      goto LABEL_29;
    v20 = v19;
    v21 = _IOHIDCopyServiceClientInfo(v10);
    if (!v21)
    {
LABEL_28:
      CFRelease(v20);
LABEL_29:
      CFRelease(v10);
      return;
    }
    v22 = v21;
    v23 = CFGetAllocator((CFTypeRef)a1);
    v24 = (const __CFData *)_IOHIDCreateBinaryData(v23, v22);
    if (!v24)
    {
LABEL_27:
      CFRelease(v22);
      goto LABEL_28;
    }
    v25 = v24;
    if (!*(_DWORD *)(a1 + 448))
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)v20);
      Length = CFDataGetLength((CFDataRef)v20);
      v28 = CFDataGetBytePtr(v25);
      v29 = CFDataGetLength(v25);
      v30 = iohideventsystem_client_dispatch_notification_results(v39, (uint64_t)BytePtr, Length, (uint64_t)v28, v29, 0);
      v31 = v30;
      if ((v30 - 268435459) < 2)
      {
        v36 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          v37 = *(_QWORD *)(a1 + 168);
          valuePtr = 136315394;
          v43 = v37;
          v44 = 1024;
          v45 = v31;
          v34 = v36;
          v35 = OS_LOG_TYPE_DEFAULT;
          goto LABEL_22;
        }
LABEL_25:
        __IOHIDEventSystemConnectionCheckServerStatus(v31, a1);
        goto LABEL_26;
      }
      if (v30)
      {
        if (v30 != 268451843)
        {
          v38 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            _IOHIDEventSystemConnectionAddServices_cold_1();
          goto LABEL_25;
        }
        v32 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          v33 = *(_QWORD *)(a1 + 168);
          valuePtr = 136315394;
          v43 = v33;
          v44 = 1024;
          v45 = 268451843;
          v34 = v32;
          v35 = OS_LOG_TYPE_INFO;
LABEL_22:
          _os_log_impl(&dword_18AAAF000, v34, v35, "%s: iohideventsystem_client_dispatch_notification_results:0x%x", (uint8_t *)&valuePtr, 0x12u);
          goto LABEL_25;
        }
        goto LABEL_25;
      }
    }
LABEL_26:
    CFRelease(v25);
    goto LABEL_27;
  }
}

uint64_t _IOHIDEventSystemAddServiceForConnection(CFSetRef *a1, uint64_t a2, const void *a3)
{
  int v6;
  int v7;
  const __CFArray *v8;
  CFIndex FirstIndexOfValue;
  uint64_t result;
  CFRange v11;

  os_unfair_recursive_lock_lock_with_options();
  v6 = CFSetContainsValue(a1[7], a3);
  v7 = CFSetContainsValue(a1[8], a3);
  v8 = a1[10];
  v11.length = CFArrayGetCount(v8);
  v11.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v8, v11, a3);
  result = os_unfair_recursive_lock_unlock();
  if (v6)
    result = _IOHIDServiceAddConnection(a2, a3, 0);
  if (v7)
    result = _IOHIDServiceAddConnection(a2, a3, 2);
  if (FirstIndexOfValue != -1)
    return _IOHIDServiceAddConnection(a2, a3, 1);
  return result;
}

uint64_t _IOHIDEventSystemConnectionRemoveService(uint64_t a1, const void *a2)
{
  const __CFAllocator *v4;
  const void *RegistryID;
  const __CFData *v6;
  const __CFData *v7;
  mach_port_t v8;
  const UInt8 *BytePtr;
  int Length;
  int v11;
  int v12;
  NSObject *v13;

  os_unfair_recursive_lock_lock_with_options();
  v4 = CFGetAllocator((CFTypeRef)a1);
  RegistryID = (const void *)IOHIDServiceGetRegistryID((uint64_t)a2);
  v6 = (const __CFData *)_IOHIDCreateBinaryData(v4, RegistryID);
  if (v6)
  {
    v7 = v6;
    if (!*(_DWORD *)(a1 + 448))
    {
      v8 = *(_DWORD *)(a1 + 40);
      BytePtr = CFDataGetBytePtr(v6);
      Length = CFDataGetLength(v7);
      v11 = iohideventsystem_client_dispatch_service_removal(v8, (uint64_t)BytePtr, Length, 0);
      v12 = v11;
      if ((v11 - 268435459) < 2)
      {
LABEL_8:
        __IOHIDEventSystemConnectionCheckServerStatus(v12, a1);
        goto LABEL_9;
      }
      if (v11)
      {
        if (v11 != 268451843)
        {
          v13 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            _IOHIDEventSystemConnectionRemoveService_cold_1();
        }
        goto LABEL_8;
      }
    }
LABEL_9:
    CFRelease(v7);
  }
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 80), a2);
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDServiceCopyProperty(uint64_t a1, const void *a2)
{
  return _IOHIDServiceCopyPropertyForClient(a1, a2, (const void *)*MEMORY[0x1E0C9B0D0]);
}

uint64_t IOHIDServiceGetRegistryID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

void __IOHIDEventSystemConnectionCheckServerStatus(int a1, uint64_t a2)
{
  NSObject *v3;

  if (a1 == -308)
  {
    v3 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      __IOHIDEventSystemConnectionCheckServerStatus_cold_1();
    *(_DWORD *)(a2 + 448) = 1;
  }
}

uint64_t iohideventsystem_client_dispatch_service_removal(mach_port_t a1, uint64_t a2, int a3, mach_msg_timeout_t a4)
{
  mach_port_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  mach_msg_header_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v11 = 1;
  v12 = a2;
  v13 = 16777472;
  v14 = a3;
  v15 = *MEMORY[0x1E0C804E8];
  v16 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v10.msgh_bits = 2147489043;
  v10.msgh_remote_port = a1;
  v10.msgh_local_port = special_reply_port;
  *(_QWORD *)&v10.msgh_voucher_port = 0x124F900000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v10);
    special_reply_port = v10.msgh_local_port;
  }
  v7 = mach_msg(&v10, 3162515, 0x38u, 0x2Cu, special_reply_port, a4, 0);
  v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
    goto LABEL_13;
  if ((_DWORD)v7)
  {
    mig_dealloc_special_reply_port();
LABEL_13:
    if ((v8 - 268435459) > 1)
      return v8;
    if ((v10.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v10.msgh_local_port);
LABEL_18:
    mach_msg_destroy(&v10);
    return v8;
  }
  if (v10.msgh_id == 71)
  {
    v8 = 4294966988;
    goto LABEL_18;
  }
  if (v10.msgh_id != 75101)
  {
    v8 = 4294966995;
    goto LABEL_18;
  }
  v8 = 4294966996;
  if ((v10.msgh_bits & 0x80000000) != 0)
    goto LABEL_18;
  if (*(_QWORD *)&v10.msgh_size != 36)
    goto LABEL_18;
  v8 = HIDWORD(v12);
  if (HIDWORD(v12))
    goto LABEL_18;
  return v8;
}

const __CFArray *_IOHIDCopyServiceClientInfo(const __CFArray *cf)
{
  const __CFArray *v1;
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v1 = cf;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  if (cf)
  {
    v2 = CFGetAllocator(cf);
    Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
    v7[3] = (uint64_t)Mutable;
    if (Mutable)
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 0x40000000;
      v5[2] = ___IOHIDCopyServiceClientInfo_block_invoke;
      v5[3] = &unk_1E2003330;
      v5[4] = &v6;
      _IOHIDCFArrayApplyBlock(v1, v5);
      v1 = (const __CFArray *)v7[3];
    }
    else
    {
      v1 = 0;
    }
  }
  _Block_object_dispose(&v6, 8);
  return v1;
}

uint64_t _IOHIDServiceAddConnection(uint64_t result, const void *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  CFIndex v10;
  __CFSet *MutableCopy;
  uint64_t v12;
  uint64_t v13;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  CFIndex Count;
  void *v17;
  const char *v18;
  const __CFArray *v19;
  _QWORD v20[5];
  uint64_t v21;
  _OWORD v22[5];
  uint64_t v23;
  CFRange v24;

  v23 = *MEMORY[0x1E0C80C00];
  if (a3 > 2)
    return result;
  v5 = result;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(result + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v21, v22);
  ++**(_DWORD **)(v5 + 72);
  if ((*(_BYTE *)(v5 + 224) & 1) == 0)
  {
    v6 = *(_QWORD *)(v5 + 368);
    if (a3 != 1)
    {
      v12 = a3;
      v13 = *(_QWORD *)(v6 + 8 * a3);
      v14 = CFGetAllocator((CFTypeRef)v5);
      v15 = v14;
      if (v13)
      {
        Count = CFSetGetCount(*(CFSetRef *)(*(_QWORD *)(v5 + 368) + 8 * v12));
        MutableCopy = CFSetCreateMutableCopy(v15, Count + 1, *(CFSetRef *)(*(_QWORD *)(v5 + 368) + 8 * v12));
        CFRelease(*(CFTypeRef *)(*(_QWORD *)(v5 + 368) + 8 * v12));
      }
      else
      {
        MutableCopy = CFSetCreateMutable(v14, 0, MEMORY[0x1E0C9B3B0]);
        if (!MutableCopy)
          goto LABEL_17;
      }
      CFSetAddValue(MutableCopy, a2);
LABEL_13:
      *(_QWORD *)(*(_QWORD *)(v5 + 368) + 8 * v12) = MutableCopy;
      v17 = *(void **)(v5 + 480);
      if (v17)
      {
        v18 = *(const char **)(v5 + 560);
        if (v18)
          objc_msgSend(v17, v18, a2, 1);
      }
      v19 = *(const __CFArray **)(v5 + 256);
      v20[0] = MEMORY[0x1E0C809B0];
      v20[1] = 0x40000000;
      v20[2] = ___IOHIDServiceAddConnection_block_invoke;
      v20[3] = &__block_descriptor_tmp_93_0;
      v20[4] = a2;
      _IOHIDCFArrayApplyBlock(v19, v20);
      goto LABEL_17;
    }
    v7 = *(_QWORD *)(v6 + 8);
    v8 = CFGetAllocator((CFTypeRef)v5);
    v9 = v8;
    if (v7)
    {
      v10 = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(v5 + 368) + 8));
      MutableCopy = CFArrayCreateMutableCopy(v9, v10 + 1, *(CFArrayRef *)(*(_QWORD *)(v5 + 368) + 8));
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(v5 + 368) + 8));
LABEL_10:
      CFArrayAppendValue(MutableCopy, a2);
      v24.length = CFArrayGetCount(MutableCopy);
      v24.location = 0;
      CFArraySortValues(MutableCopy, v24, (CFComparatorFunction)_IOHIDEventSystemConnectionEventFilterCompare, 0);
      v12 = 1;
      goto LABEL_13;
    }
    MutableCopy = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
    if (MutableCopy)
      goto LABEL_10;
  }
LABEL_17:
  result = *(_QWORD *)(v5 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v21, v22);
  }
  return result;
}

uint64_t iohideventsystem_client_dispatch_notification_results(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, mach_msg_timeout_t a6)
{
  mach_port_t special_reply_port;
  uint64_t v9;
  uint64_t v10;
  mach_msg_header_t msg;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v13 = 2;
  v14 = a2;
  v15 = 16777472;
  v16 = a3;
  v17 = a4;
  v18 = 16777472;
  v19 = a5;
  v20 = *MEMORY[0x1E0C804E8];
  v21 = a3;
  v22 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x124F800000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v9 = mach_msg(&msg, 3162515, 0x4Cu, 0x2Cu, special_reply_port, a6, 0);
  v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0)
    goto LABEL_14;
  if ((_DWORD)v9)
  {
    mig_dealloc_special_reply_port();
LABEL_14:
    if ((v10 - 268435459) > 1)
      return v10;
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
LABEL_19:
    mach_msg_destroy(&msg);
    return v10;
  }
  if (msg.msgh_id == 71)
  {
    v10 = 4294966988;
    goto LABEL_19;
  }
  if (msg.msgh_id != 75100)
  {
    v10 = 4294966995;
    goto LABEL_19;
  }
  v10 = 4294966996;
  if ((msg.msgh_bits & 0x80000000) != 0)
    goto LABEL_19;
  if (msg.msgh_size != 36)
    goto LABEL_19;
  if (msg.msgh_remote_port)
    goto LABEL_19;
  v10 = HIDWORD(v14);
  if (HIDWORD(v14))
    goto LABEL_19;
  return v10;
}

void __io_hideventsystem_matching_services_callback(uint64_t a1, const void *a2, uint64_t a3, const __CFArray *a4)
{
  _IOHIDEventSystemConnectionAddServices(a1, a4, a2);
}

uint64_t _Xiohideventsystem_client_dispatch_virtual_service_notification(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 68)
  {
    if (*(_BYTE *)(result + 39) == 1)
    {
      v3 = *(_DWORD *)(result + 40);
      if (v3 == *(_DWORD *)(result + 64))
      {
        result = _iohideventsystem_client_dispatch_virtual_service_notification(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(unsigned int *)(result + 60), *(UInt8 **)(result + 28), v3);
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    v4 = -300;
  }
  else
  {
    v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t _iohideventsystem_client_dispatch_virtual_service_notification(unsigned int a1, const void *a2, uint64_t a3, UInt8 *a4, unsigned int a5)
{
  mach_vm_size_t v9;
  CFTypeID TypeID;
  const void *v11;
  CFDictionaryRef *v12;
  CFDictionaryRef *v13;
  CFTypeID v14;
  uint64_t v15;
  _QWORD *Value;
  _QWORD *v17;
  NSObject *v18;
  NSObject *v20;

  v9 = a5;
  TypeID = CFDictionaryGetTypeID();
  v11 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, v9, TypeID);
  v12 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  v13 = v12;
  if (v12)
  {
    v14 = CFGetTypeID(v12);
    v15 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      v15 = __kIOHIDEventSystemClientTypeID;
    }
    if (v14 == v15)
    {
      os_unfair_recursive_lock_lock_with_options();
      Value = CFDictionaryGetValue(v13[13], a2);
      if (Value)
      {
        v17 = Value;
        CFRetain(Value);
        os_unfair_recursive_lock_unlock();
        _IOHIDVirtualServiceClientNotification(v17, a3, (uint64_t)v11);
        CFRelease(v17);
      }
      else
      {
        os_unfair_recursive_lock_unlock();
        v18 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          _iohideventsystem_client_dispatch_virtual_service_set_property_cold_4();
      }
LABEL_9:
      CFRelease(v13);
      goto LABEL_10;
    }
  }
  v20 = _IOHIDLogCategory(0xDu);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
  if (v13)
    goto LABEL_9;
LABEL_10:
  if (v11)
    CFRelease(v11);
  return 0;
}

_QWORD *_IOHIDVirtualServiceClientNotification(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t);

  v3 = result[8];
  if (v3)
  {
    v4 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t))(v3 + 8);
    if (v4)
      return (_QWORD *)v4(result[9], result[10], result, a2, a3);
  }
  return result;
}

uint64_t _Xio_hideventsystem_dispatch_event_for_virtual_service(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 64)
  {
    if (*(_BYTE *)(result + 39) == 1)
    {
      v3 = *(_DWORD *)(result + 40);
      if (v3 == *(_DWORD *)(result + 60))
      {
        result = _io_hideventsystem_dispatch_event_for_virtual_service(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(UInt8 **)(result + 28), v3);
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    v4 = -300;
  }
  else
  {
    v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t _io_hideventsystem_dispatch_event_for_virtual_service(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4)
{
  mach_vm_size_t v7;
  CFTypeID TypeID;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  CFTypeID v13;
  CFAllocatorRef v14;
  const void *v15;
  const void *v16;

  v7 = a4;
  TypeID = CFDataGetTypeID();
  v9 = _IOHIDUnserializeAndVMDeallocWithTypeID(a3, v7, TypeID);
  if (v9)
  {
    v10 = v9;
    v11 = IOMIGMachPortCacheCopy(a1);
    if (v11)
    {
      v12 = v11;
      v13 = CFGetTypeID(v11);
      if (v13 == IOHIDEventSystemConnectionGetTypeID())
      {
        v14 = CFGetAllocator(v12);
        v15 = (const void *)IOHIDEventCreateWithDataInternal(v14, v10);
        if (v15)
        {
          v16 = v15;
          _IOHIDEventSystemConnectionDispatchEventForVirtualService((uint64_t)v12, a2, v15);
          CFRelease(v16);
        }
      }
      CFRelease(v12);
    }
    CFRelease(v10);
  }
  return 0;
}

__CFData *IOHIDEventCreateCopy(const __CFAllocator *a1, uint64_t a2)
{
  __CFData *result;
  __CFData *v4;
  const void *v5;

  result = IOHIDEventCreateDataInternal(a1, a2);
  if (result)
  {
    v4 = result;
    v5 = __IOHIDEventCreateWithDataHelper((uint64_t)a1, result);
    CFRelease(v4);
    return (__CFData *)v5;
  }
  return result;
}

__CFData *IOHIDEventCreateData(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t LengthAndCount;
  CFIndex v5;
  __CFData *Mutable;
  __CFData *v7;
  UInt8 *MutableBytePtr;

  if (!a2)
    return 0;
  LengthAndCount = __IOHIDEventGetLengthAndCount(a2, (_QWORD *)(a2 + 96));
  if (!LengthAndCount)
    return 0;
  v5 = LengthAndCount + *(_QWORD *)(a2 + 88) + 28;
  Mutable = CFDataCreateMutable(a1, v5);
  v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    __IOHIDEventReadBytesHelper(a2, (uint64_t)MutableBytePtr, v5);
  }
  return v7;
}

void __IOHIDEventSystemConnectionUpdateActivityState(uint64_t a1, int a2, uint64_t a3)
{
  int Type;
  uint64_t SenderID;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  const __CFData *v13;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  _BYTE v18[40];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 400) != a2)
  {
    if (a3)
    {
      Type = IOHIDEventGetType(a3);
      SenderID = IOHIDEventGetSenderID(a3);
    }
    else
    {
      Type = 0;
      SenderID = 0;
    }
    v8 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = *(_QWORD *)(a1 + 168);
      v10 = *(_DWORD *)(a1 + 400);
      *(_DWORD *)v18 = 136316162;
      *(_QWORD *)&v18[4] = v9;
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v10;
      *(_WORD *)&v18[18] = 1024;
      *(_DWORD *)&v18[20] = a2;
      *(_WORD *)&v18[24] = 2048;
      *(_QWORD *)&v18[26] = SenderID;
      *(_WORD *)&v18[34] = 1024;
      *(_DWORD *)&v18[36] = Type;
      _os_log_impl(&dword_18AAAF000, v8, OS_LOG_TYPE_INFO, "%s: HID activity: %d -> %d (service:0x%llx event:%d)", v18, 0x28u);
    }
    memset(v18, 0, sizeof(v18));
    *(_DWORD *)v18 = a2;
    if (a3)
    {
      v11 = IOHIDEventGetSenderID(a3);
      v12 = IOHIDEventGetType(a3);
    }
    else
    {
      v11 = 0;
      v12 = 0;
    }
    *(_QWORD *)&v18[24] = v11;
    *(_DWORD *)&v18[32] = v12;
    gettimeofday((timeval *)&v18[8], 0);
    ++*(_DWORD *)(a1 + 404);
    os_unfair_recursive_lock_lock_with_options();
    v13 = *(const __CFData **)(a1 + 432);
    if (v13
      || (v14 = CFGetAllocator((CFTypeRef)a1),
          v13 = _IOHIDSimpleQueueCreate(v14, 40, 50),
          (*(_QWORD *)(a1 + 432) = v13) != 0))
    {
      _IOHIDSimpleQueueEnqueue(v13, v18, 1);
    }
    os_unfair_recursive_lock_unlock();
    *(_DWORD *)(a1 + 400) = a2;
    v15 = CFGetAllocator((CFTypeRef)a1);
    v16 = CFNumberCreate(v15, kCFNumberSInt32Type, (const void *)(a1 + 400));
    if (v16)
    {
      v17 = v16;
      _IOHIDEventSystemConnectionPropertyChanged(a1, CFSTR("HIDActivityState"), v16);
      CFRelease(v17);
    }
  }
}

void __IOHIDEventSystemConnectionActivityNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  dispatch_time_t v6;

  v5 = *(NSObject **)(a1 + 416);
  v6 = dispatch_time(0, 1000000000 * *(_QWORD *)(a1 + 408));
  dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0);
  __IOHIDEventSystemConnectionUpdateActivityState(a1, 1, a3);
}

uint64_t __IOHIDEventServerDemuxCallback(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3;
  uint64_t result;

  v3 = a2[5];
  if (v3 >= 70000 && v3 < 70029)
    LOBYTE(result) = iohideventsystem_server(a2, a3);
  else
    LOBYTE(result) = 0;
  return result;
}

uint64_t _Xio_hideventsystem_open(uint64_t result, _DWORD *a2)
{
  int v3;
  unsigned int v4;
  mach_port_name_t v5;
  unsigned int v6;
  UInt8 *v7;
  unsigned int v8;
  UInt8 *v9;
  unsigned int v10;
  mach_port_name_t v11;
  __int128 v12;
  _OWORD v13[2];

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 4 || *(_DWORD *)(result + 4) != 104)
  {
    v3 = -304;
    goto LABEL_14;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112
    || *(_BYTE *)(result + 51) != 1
    || *(_BYTE *)(result + 67) != 1
    || *(unsigned __int16 *)(result + 82) << 16 != 1114112
    || *(_DWORD *)(result + 52) != *(_DWORD *)(result + 96)
    || *(_DWORD *)(result + 68) != *(_DWORD *)(result + 100))
  {
    v3 = -300;
    goto LABEL_14;
  }
  if (*(_DWORD *)(result + 104) || *(_DWORD *)(result + 108) <= 0x1Fu)
  {
    v3 = -309;
LABEL_14:
    a2[8] = v3;
    goto LABEL_15;
  }
  *((_QWORD *)a2 + 4) = 0x11000000000000;
  v4 = *(_DWORD *)(result + 12);
  v5 = *(_DWORD *)(result + 28);
  v6 = *(_DWORD *)(result + 92);
  v7 = *(UInt8 **)(result + 40);
  v8 = *(_DWORD *)(result + 52);
  v9 = *(UInt8 **)(result + 56);
  v10 = *(_DWORD *)(result + 68);
  v11 = *(_DWORD *)(result + 72);
  v12 = *(_OWORD *)(result + 140);
  v13[0] = *(_OWORD *)(result + 124);
  v13[1] = v12;
  result = _io_hideventsystem_open(v4, v5, v6, v7, v8, v9, v10, v11, a2 + 7, v13);
  if (!(_DWORD)result)
  {
    *a2 |= 0x80000000;
    a2[1] = 40;
    a2[6] = 1;
    return result;
  }
  a2[8] = result;
LABEL_15:
  *((_QWORD *)a2 + 3) = *MEMORY[0x1E0C804E8];
  return result;
}

_DWORD *_Xio_hideventsystem_queue_stop(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  }
  else
  {
    result = (_DWORD *)_io_hideventsystem_queue_stop(result[3]);
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t _io_hideventsystem_queue_stop(unsigned int a1)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;
  const void *v4;
  const void *v5;

  v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    if (v3 == IOHIDEventSystemConnectionGetTypeID())
    {
      v4 = _IOHIDEventSystemConnectionCopyQueue((uint64_t)v2);
      if (v4)
      {
        v5 = v4;
        _IOHIDEventSystemConnectionQueueStop((uint64_t)v2);
        IOHIDEventQueueStop((uint64_t)v5);
        CFRelease(v5);
      }
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t IOHIDEventQueueStop(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 148) = 0;
  while (!_IODataQueueDequeue(*(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 56), 0))
    ++*(_QWORD *)(a1 + 168);
  return os_unfair_recursive_lock_unlock();
}

void __IOHIDEventSystemConnectionPortTerminateCallback(uint64_t a1, void (**cf)(CFTypeRef, uint64_t))
{
  void (*v4)(CFTypeRef, uint64_t);
  void (*v5)(CFTypeRef, uint64_t);

  CFRetain(cf);
  os_unfair_recursive_lock_lock_with_options();
  v4 = cf[8];
  if (v4 && cf[4] == (void (*)(CFTypeRef, uint64_t))a1)
  {
    v5 = cf[9];
    if (a1)
      IOMIGMachPortRegisterTerminationCallback(a1, 0, 0);
    os_unfair_recursive_lock_unlock();
    v4(cf, (uint64_t)v5);
    os_unfair_recursive_lock_lock_with_options();
  }
  os_unfair_recursive_lock_unlock();
  CFRelease(cf);
}

void __IOHIDEventSystemConnectionDiedCallback(uint64_t *a1, uint64_t a2)
{
  if (a1)
    __IOHIDEventServerKillClient(a2, a1);
}

void __IOHIDEventServerKillClient(uint64_t a1, uint64_t *a2)
{
  unsigned int Port;

  _IOHIDEventSystemConnectionInvalidate((uint64_t)a2);
  _IOHIDEventSystemConnectionUnscheduleAsync(a2);
  Port = _IOHIDEventSystemConnectionGetPort((uint64_t)a2);
  IOMIGMachPortCacheRemove(Port);
  _IOHIDEventSystemRemoveConnection(*(CFDictionaryRef **)(a1 + 16), a2);
}

uint64_t _IOHIDEventSystemConnectionUnscheduleAsync(uint64_t *a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;

  os_unfair_recursive_lock_lock_with_options();
  v2 = a1[14];
  if (v2)
    dispatch_source_cancel(v2);
  v3 = a1[52];
  if (v3)
    dispatch_source_cancel(v3);
  v4 = a1[15];
  if (v4)
    dispatch_source_cancel(v4);
  IOMIGMachPortUnscheduleFromDispatchQueue(a1[4], a1[12]);
  v5 = a1[55];
  if (v5)
    IOHIDConnectionFilterCancel(v5);
  return os_unfair_recursive_lock_unlock();
}

uint64_t _Xiohideventsystem_copy_event_from_virtual_service(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 64))
  {
    v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = _iohideventsystem_copy_event_from_virtual_service(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(unsigned int *)(result + 60), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), *(unsigned int *)(result + 68), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(_QWORD *)(a2 + 44) = *MEMORY[0x1E0C804E8];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void __IOHIDEventSystemServiceRemoved(_QWORD *a1, int a2, CFTypeRef cf)
{
  NSObject *v5;
  _QWORD v6[6];

  CFRetain(cf);
  CFRetain(a1);
  v5 = a1[18];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = ____IOHIDEventSystemServiceRemoved_block_invoke;
  v6[3] = &__block_descriptor_tmp_43;
  v6[4] = cf;
  v6[5] = a1;
  dispatch_async(v5, v6);
}

uint64_t _iohideventsystem_copy_event_from_virtual_service(unsigned int a1, const void *a2, uint64_t a3, UInt8 *a4, unsigned int a5, uint64_t a6, vm_offset_t *a7, _DWORD *a8)
{
  mach_vm_size_t v15;
  CFTypeID TypeID;
  const void *v17;
  const void *v18;
  CFDictionaryRef *v19;
  CFDictionaryRef *v20;
  CFTypeID v21;
  uint64_t v22;
  _QWORD *Value;
  _QWORD *v24;
  const void *v25;
  const __CFAllocator *v26;
  __CFData *DataInternal;
  NSObject *v28;
  NSObject *v30;

  v15 = a5;
  TypeID = CFDataGetTypeID();
  v17 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, v15, TypeID);
  if (v17)
    v18 = (const void *)IOHIDEventCreateWithDataInternal(*MEMORY[0x1E0C9AE00], v17);
  else
    v18 = 0;
  v19 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  v20 = v19;
  if (!v19)
    goto LABEL_25;
  v21 = CFGetTypeID(v19);
  v22 = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    v22 = __kIOHIDEventSystemClientTypeID;
  }
  if (v21 == v22)
  {
    os_unfair_recursive_lock_lock_with_options();
    Value = CFDictionaryGetValue(v20[13], a2);
    if (Value)
    {
      v24 = Value;
      CFRetain(Value);
      os_unfair_recursive_lock_unlock();
      v25 = (const void *)_IOHIDVirtualServiceClientCopyEvent(v24, a3, (uint64_t)v18, a6);
      if (v25)
      {
        v26 = CFGetAllocator(v24);
        DataInternal = IOHIDEventCreateDataInternal(v26, (uint64_t)v25);
      }
      else
      {
        DataInternal = 0;
      }
      *a8 = _IOHIDSerialize(DataInternal, a7);
      CFRelease(v24);
      if (v25)
        CFRelease(v25);
      if (DataInternal)
        CFRelease(DataInternal);
    }
    else
    {
      os_unfair_recursive_lock_unlock();
      v28 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        _iohideventsystem_output_event_to_virtual_service_cold_2();
    }
  }
  else
  {
LABEL_25:
    v30 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
  }
  if (v18)
    CFRelease(v18);
  if (v17)
    CFRelease(v17);
  if (v20)
    CFRelease(v20);
  return 0;
}

uint64_t _IOHIDVirtualServiceClientCopyEvent(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t, uint64_t);

  v4 = a1[8];
  if (v4 && (v5 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t, uint64_t))(v4 + 32)) != 0)
    return v5(a1[9], a1[10], a1, a2, a3, a4);
  else
    return 0;
}

void __IOHIDEventSystemConnectionCheckServerStatus_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_8_1(*MEMORY[0x1E0C80C00]);
  OUTLINED_FUNCTION_8_0();
  OUTLINED_FUNCTION_1_2(&dword_18AAAF000, v0, v1, "%s: Server died, preventing any future MIG calls", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_3();
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

uint64_t OUTLINED_FUNCTION_6()
{
  return _os_crash_msg();
}

BOOL OUTLINED_FUNCTION_2()
{
  NSObject *v0;

  return os_log_type_enabled(v0, OS_LOG_TYPE_ERROR);
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

double OUTLINED_FUNCTION_1_0(_QWORD *a1, _OWORD *a2)
{
  double result;

  *a1 = 0;
  result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

BOOL OUTLINED_FUNCTION_4_0()
{
  NSObject *v0;

  return os_log_type_enabled(v0, OS_LOG_TYPE_ERROR);
}

void OUTLINED_FUNCTION_0_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

uint64_t OUTLINED_FUNCTION_3_1(uint64_t a1)
{
  return _IOHIDEventSystemConnectionGetPID(a1);
}

void OUTLINED_FUNCTION_3_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

uint64_t _IOHIDEventSystemConnectionPropertyChanged(uint64_t a1, void *a2, const void *a3)
{
  const __CFSet *v5;
  uint64_t v6;
  const __CFAllocator *v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  const __CFAllocator *v10;
  const __CFData *v11;
  const __CFData *v12;
  mach_port_t v13;
  const UInt8 *BytePtr;
  int Length;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  unint64_t v22;
  const void *v24;
  void *keys;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v24 = a3;
  keys = a2;
  os_unfair_recursive_lock_lock_with_options();
  v5 = *(const __CFSet **)(a1 + 136);
  if (v5 && CFSetContainsValue(v5, a2))
  {
    v6 = mach_absolute_time();
    v7 = CFGetAllocator((CFTypeRef)a1);
    v8 = CFDictionaryCreate(v7, (const void **)&keys, &v24, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v8)
    {
      v9 = v8;
      v10 = CFGetAllocator((CFTypeRef)a1);
      v11 = (const __CFData *)_IOHIDCreateBinaryData(v10, v9);
      if (v11)
      {
        v12 = v11;
        if (!*(_DWORD *)(a1 + 448))
        {
          v13 = *(_DWORD *)(a1 + 40);
          BytePtr = CFDataGetBytePtr(v11);
          Length = CFDataGetLength(v12);
          v16 = iohideventsystem_client_dispatch_properties_changed(v13, (uint64_t)BytePtr, Length, 0);
          if (v16)
          {
            v17 = v16;
            if (v16 == 268451843)
            {
              v18 = _IOHIDLogCategory(9u);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
              {
                v19 = *(_QWORD *)(a1 + 168);
                *(_DWORD *)buf = 136315394;
                v27 = v19;
                v28 = 1024;
                v29 = 268451843;
                _os_log_impl(&dword_18AAAF000, v18, OS_LOG_TYPE_INFO, "%s: iohideventsystem_client_dispatch_properties_changed:0x%x", buf, 0x12u);
              }
            }
            else
            {
              v20 = _IOHIDLogCategory(9u);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                _IOHIDEventSystemConnectionPropertyChanged_cold_1();
            }
            __IOHIDEventSystemConnectionCheckServerStatus(v17, a1);
          }
        }
        CFRelease(v12);
      }
      CFRelease(v9);
    }
    v21 = mach_absolute_time();
    v22 = _IOHIDGetTimestampDelta(v21, v6, 1u);
    if (v22 > *(_QWORD *)(a1 + 376))
      *(_QWORD *)(a1 + 376) = v22;
  }
  return os_unfair_recursive_lock_unlock();
}

void __ConnectionFunctionPickReportInterval(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  const __CFNumber *v5;
  const __CFNumber *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int valuePtr;

  valuePtr = 0;
  if (_IOHIDEventSystemConnectionIsResponsive(a1))
  {
    v5 = (const __CFNumber *)IOHIDServiceConnectionCacheCopyValueForKey(a2, CFSTR("ReportInterval"));
    if (v5)
    {
      v6 = v5;
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
      CFRelease(v6);
      v7 = valuePtr;
      if (valuePtr)
      {
        v8 = *a3;
        if (*a3)
        {
          if (valuePtr < v8)
          {
            a3[1] = v8;
LABEL_10:
            *a3 = v7;
            return;
          }
        }
        else
        {
          *a3 = valuePtr;
          a3[1] = v7;
          v8 = v7;
        }
        v10 = a3[1];
        ++a3;
        v9 = v10;
        if (v8 == v10 || v7 < v9)
          goto LABEL_10;
      }
    }
  }
}

BOOL _IOHIDEventSystemConnectionIsResponsive(uint64_t a1)
{
  return *MEMORY[0x1E0C9B0D0] == a1 || (*(_BYTE *)(a1 + 264) & 2) == 0;
}

void __ConnectionFunctionPickBatchInterval(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  const __CFNumber *v4;
  const __CFNumber *v5;
  unsigned int valuePtr;

  valuePtr = 0;
  v4 = (const __CFNumber *)IOHIDServiceConnectionCacheCopyValueForKey(a2, CFSTR("BatchInterval"));
  if (v4)
  {
    v5 = v4;
    CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
    CFRelease(v5);
    if (valuePtr < *a3)
      *a3 = valuePtr;
  }
}

BOOLean_t IOHIDServiceClientConformsTo(IOHIDServiceClientRef service, uint32_t usagePage, uint32_t usage)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *i;

  v3 = *((_QWORD *)service + 17);
  if (!v3)
    return 0;
  v4 = *((unsigned int *)service + 36);
  if (!(_DWORD)v4)
    return 0;
  for (i = (_DWORD *)(v3 + 4); *(i - 1) != usagePage || *i != usage; i += 2)
  {
    if (!--v4)
      return 0;
  }
  return 1;
}

id IOHIDSessionFilterRegisterService(id result, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD, uint64_t);
  const char *v5;

  v3 = *((_QWORD *)result + 2);
  if (v3)
  {
    v4 = *(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v3 + 88);
    if (v4)
      return (id)v4(*((_QWORD *)result + 2), a2);
  }
  if (*((_QWORD *)result + 7))
  {
    v5 = (const char *)*((_QWORD *)result + 13);
    if (v5)
      return objc_msgSend(*((id *)result + 7), v5, a2, 1);
  }
  return result;
}

_QWORD *IOHIDEventGetVendorDefinedData(_QWORD *result, uint64_t *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t v6;
  uint64_t v7;

  v4 = result;
  if (a2)
  {
    result = (_QWORD *)IOHIDEventGetEventWithOptions(result, 1, 0);
    if (result)
      v6 = result[13] + 28;
    else
      v6 = 0;
    *a2 = v6;
  }
  if (a3)
  {
    result = (_QWORD *)IOHIDEventGetEventWithOptions(v4, 1, 4026531840);
    if (result)
      v7 = *(unsigned int *)(result[13] + 24);
    else
      v7 = 0;
    *a3 = v7;
  }
  return result;
}

id IOHIDSessionFilterUnregisterService(id result, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD, uint64_t);
  const char *v5;

  v3 = *((_QWORD *)result + 2);
  if (v3)
  {
    v4 = *(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v3 + 96);
    if (v4)
      return (id)v4(*((_QWORD *)result + 2), a2);
  }
  if (*((_QWORD *)result + 7))
  {
    v5 = (const char *)*((_QWORD *)result + 13);
    if (v5)
      return objc_msgSend(*((id *)result + 7), v5, a2, 0);
  }
  return result;
}

_QWORD *IOHIDEventGetDataValueWithOptions(_QWORD *result, unsigned int a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v4 = HIWORD(a2);
  if (result && a2 < 0x10000 || (result = (_QWORD *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a3)) != 0)
  {
    v5 = result[13] + 28;
    if (a2 == 1966083)
      v6 = result[13] + 28;
    else
      v6 = 0;
    if (a2 != 65540)
      v5 = 0;
    if (v4 != 1)
      v5 = 0;
    if (v4 == 30)
      return (_QWORD *)v6;
    else
      return (_QWORD *)v5;
  }
  return result;
}

uint64_t __FilterFunctionSetEventCallback(uint64_t a1)
{
  return IOHIDServiceFilterSetEventCallback(a1);
}

__CFDictionary *__FilterFunctionCopyPropertyForClient(__CFDictionary *result, uint64_t a2)
{
  if (!*(_QWORD *)(a2 + 8))
  {
    result = IOHIDServiceFilterCopyPropertyForClient((uint64_t)result, *(CFTypeRef *)a2, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a2 + 8) = result;
  }
  return result;
}

__CFDictionary *IOHIDServiceFilterCopyPropertyForClient(uint64_t a1, CFTypeRef cf1, uint64_t a3)
{
  const void *v6;
  uint64_t v8;
  uint64_t (*v9)(void);
  const __CFString *v10;
  __CFDictionary *v11;
  void *v12;
  const __CFString *v13;
  const __CFAllocator *v14;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v16;
  const __CFString *v17;
  NSObject *v18;
  const __CFAllocator *v19;
  CFStringRef v20;
  CFStringRef v21;
  const void *v22;

  if (CFEqual(cf1, CFSTR("HIDObjectUUID")))
  {
    v6 = *(const void **)(a1 + 88);
    if (v6)
      return (__CFDictionary *)CFRetain(v6);
    return 0;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 && (v9 = *(uint64_t (**)(void))(*(_QWORD *)v8 + 88)) != 0)
    {
      v10 = (const __CFString *)v9();
    }
    else
    {
      v12 = *(void **)(a1 + 96);
      if (v12)
      {
        v13 = (const __CFString *)objc_msgSend(v12, *(SEL *)(a1 + 104), cf1, a3);
        v10 = v13;
        if (v13)
          CFRetain(v13);
      }
      else
      {
        v10 = 0;
      }
    }
    if (CFEqual(cf1, CFSTR("ServiceFilterDebug"))
      && (v14 = CFGetAllocator((CFTypeRef)a1),
          (Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) != 0))
    {
      v11 = Mutable;
      if (v10)
      {
        if (_IOHIDIsSerializable((uint64_t)v10))
        {
          v16 = v11;
          v17 = v10;
        }
        else
        {
          v18 = _IOHIDLog();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            IOHIDServiceFilterCopyPropertyForClient_cold_1(a1, (uint64_t)v10, v18);
          v17 = CFSTR("not serializable");
          v16 = v11;
        }
        CFDictionaryAddValue(v16, CFSTR("plugin"), v17);
        CFRelease(v10);
      }
      v19 = CFGetAllocator((CFTypeRef)a1);
      v20 = CFUUIDCreateString(v19, *(CFUUIDRef *)(a1 + 88));
      if (v20)
      {
        v21 = v20;
        CFDictionaryAddValue(v11, CFSTR("uuid"), v20);
        CFRelease(v21);
      }
      v22 = *(const void **)(a1 + 80);
      if (v22)
        CFDictionaryAddValue(v11, CFSTR("name"), v22);
      _IOHIDDictionaryAddSInt32(v11, CFSTR("score"), *(_DWORD *)(a1 + 40));
      _IOHIDDictionaryAddSInt32(v11, CFSTR("type"), *(_QWORD *)(a1 + 16) == 0);
    }
    else
    {
      return (__CFDictionary *)v10;
    }
  }
  return v11;
}

void __OSKextInitialize()
{
  void *v0;
  const __CFAllocator *v1;
  const __CFAllocator *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFArrayRef v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  const CFDictionaryKeyCallBacks *v20;
  CFMutableDictionaryRef Mutable;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFArrayCallBacks v29;
  stat v30;
  CFAllocatorContext context;
  void *values[2];
  __int128 v33;
  __int128 v34;
  void *v35[2];
  __int128 v36;
  const __CFString *v37;
  void *v38[18];
  void *v39[2];
  __int128 v40;
  __int128 v41;
  void *v42[2];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)v42 = xmmword_1E20032A8;
  *(_OWORD *)v39 = xmmword_1E20032B8;
  v40 = *(_OWORD *)&off_1E20032C8;
  v41 = xmmword_1E20032D8;
  v0 = (void *)*MEMORY[0x1E0C9AE90];
  v38[0] = *(void **)MEMORY[0x1E0C9AE78];
  v38[1] = v0;
  v38[2] = *(void **)MEMORY[0x1E0C9AAE0];
  v38[3] = CFSTR("OSBundleCompatibleVersion");
  v38[4] = CFSTR("OSBundleIsInterface");
  v38[5] = CFSTR("OSKernelResource");
  v38[6] = CFSTR("OSBundleCPUType");
  v38[7] = CFSTR("OSBundleCPUSubtype");
  v38[8] = CFSTR("OSBundlePath");
  v38[9] = CFSTR("OSBundleUUID");
  v38[10] = CFSTR("OSBundleStarted");
  v38[11] = CFSTR("OSBundleLoadTag");
  v38[12] = CFSTR("OSBundleLoadAddress");
  v38[13] = CFSTR("OSBundleLoadSize");
  v38[14] = CFSTR("OSBundleWiredSize");
  v38[15] = CFSTR("OSBundlePrelinked");
  v38[16] = CFSTR("OSBundleDependencies");
  v38[17] = CFSTR("OSBundleRetainCount");
  *(_OWORD *)v35 = xmmword_1E20032E8;
  v36 = off_1E20032F8;
  v37 = CFSTR("OSBundleIsInterface");
  memset(&context, 0, sizeof(context));
  v33 = 0u;
  v34 = 0u;
  memset(&v30, 0, sizeof(v30));
  __sOSKextInitializing = 1;
  __kOSKextTypeID = _CFRuntimeRegisterClass();
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CFAllocatorGetContext((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
  context.retain = 0;
  context.release = 0;
  v2 = CFAllocatorCreate(v1, &context);
  if (v2)
  {
    v8 = v2;
    values[0] = CFURLCreateFromFileSystemRepresentation(v2, (const UInt8 *)"/System/Library/Extensions", 26, 1u);
    values[1] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/Library/Extensions", 19, 1u);
    if (stat("/System/Library/DriverExtensions", &v30))
    {
      v9 = 2;
    }
    else
    {
      *(_QWORD *)&v33 = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/System/Library/DriverExtensions", 32, 1u);
      v9 = 3;
    }
    if (!stat("/Library/DriverExtensions", &v30))
      values[v9++] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/Library/DriverExtensions", 25, 1u);
    if (!stat("/Library/Apple/System/Library/Extensions", &v30))
      values[v9++] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/Library/Apple/System/Library/Extensions", 40, 1u);
    if (!stat("/AppleInternal/Library/Extensions", &v30))
      values[v9++] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/AppleInternal/Library/Extensions", 33, 1u);
    v15 = 0;
    do
    {
      if (!values[v15])
        goto LABEL_22;
      ++v15;
    }
    while (v9 != v15);
    v16 = CFArrayCreate(v8, (const void **)values, v9, MEMORY[0x1E0C9B378]);
    __sOSKextSystemExtensionsFolderURLs = (uint64_t)v16;
    if (v16)
    {
      v17 = MEMORY[0x1E0C9B378];
      __sOSKextPackageTypeValues = (uint64_t)CFArrayCreate(v1, (const void **)v42, 2, MEMORY[0x1E0C9B378]);
      __sOSKextOSBundleRequiredValues = (uint64_t)CFArrayCreate(v1, (const void **)v39, 6, (const CFArrayCallBacks *)v17);
      __sOSKextInfoEssentialKeys = (uint64_t)CFArrayCreate(v1, (const void **)v38, 18, (const CFArrayCallBacks *)v17);
      __sOSKextInfoKextOnlyKeys = (uint64_t)CFArrayCreate(v1, (const void **)v35, 5, (const CFArrayCallBacks *)v17);
      if (__sOSAllKexts)
        goto LABEL_20;
      v18 = *(_OWORD *)(v17 + 16);
      *(_OWORD *)&v29.version = *(_OWORD *)v17;
      *(_OWORD *)&v29.release = v18;
      v29.equal = *(CFArrayEqualCallBack *)(v17 + 32);
      v29.retain = 0;
      v29.release = 0;
      v16 = CFArrayCreateMutable(v1, 0, &v29);
      __sOSAllKexts = (uint64_t)v16;
      if (v16)
      {
LABEL_20:
        if (__sOSKextsByURL)
          goto LABEL_21;
        v19 = *(_OWORD *)(MEMORY[0x1E0C9B3A0] + 16);
        *(_OWORD *)&v29.version = *MEMORY[0x1E0C9B3A0];
        *(_OWORD *)&v29.release = v19;
        v29.equal = *(CFArrayEqualCallBack *)(MEMORY[0x1E0C9B3A0] + 32);
        v29.retain = 0;
        v29.release = 0;
        v20 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
        __sOSKextsByURL = (uint64_t)CFDictionaryCreateMutable(v1, 0, MEMORY[0x1E0C9B390], (const CFDictionaryValueCallBacks *)&v29);
        Mutable = CFDictionaryCreateMutable(v1, 0, v20, (const CFDictionaryValueCallBacks *)&v29);
        __sOSKextsByIdentifier = (uint64_t)Mutable;
        if (__sOSKextsByURL)
        {
          if (Mutable)
          {
LABEL_21:
            __sOSNewKmodInfoKernelVersion = OSKextParseVersionString("6.0");
            OSKextSetArchitecture(0, v22, v23, v24, v25, v26, v27, v28);
            goto LABEL_24;
          }
        }
LABEL_22:
        v16 = 0;
      }
    }
    OSKextLog((uint64_t)v16, 17, "Memory allocation failure.", v10, v11, v12, v13, v14, v29.version);
LABEL_24:
    CFRelease(v8);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v29.version);
  }
  __sOSKextInitializing = 0;
}

uint64_t OSKextSetArchitecture(const NXArchInfo *RunningKernelArchitecture, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const NXArchInfo *v8;
  const char **v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  const char *name;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  cpu_type_t cputype;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v8 = RunningKernelArchitecture;
  v9 = (const char **)__sOSKextArchInfo;
  if ((__sOSKextInitializing & 1) == 0)
    RunningKernelArchitecture = (const NXArchInfo *)pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (v9)
    v10 = v9 == (const char **)v8;
  else
    v10 = 0;
  if (v10)
  {
    RunningKernelArchitecture = (const NXArchInfo *)__sOSKextArchInfo;
    goto LABEL_14;
  }
  __sOSKextArchInfo = 0;
  if (v8)
  {
    RunningKernelArchitecture = NXGetArchInfoFromCpuType(v8->cputype, v8->cpusubtype);
    __sOSKextArchInfo = (char **)RunningKernelArchitecture;
    if (!RunningKernelArchitecture)
    {
      name = v8->name;
      if (!v8->name || !*name)
      {
        cputype = v8->cputype;
        OSKextGetRunningKernelArchitecture(0, v11, v12, a4, a5, a6, a7, a8);
        OSKextLog(0, 7, "Unknown CPU info given (type %d, subtype %d), using running kernel architecture %s.", v28, v29, v30, v31, v32, cputype);
LABEL_34:
        v23 = 0;
        v22 = 0;
        RunningKernelArchitecture = (const NXArchInfo *)__sOSKextArchInfo;
        if (__sOSKextArchInfo)
          goto LABEL_19;
        goto LABEL_16;
      }
      OSKextLog(0, 23, "Architecture %s not found by CPU info (type %d, subtype %d), trying by name.", a4, a5, a6, a7, a8, (char)name);
      RunningKernelArchitecture = NXGetArchInfoFromName(v8->name);
      __sOSKextArchInfo = (char **)RunningKernelArchitecture;
      if (!RunningKernelArchitecture)
      {
        v16 = v8->name;
        OSKextGetRunningKernelArchitecture(0, v14, v15, a4, a5, a6, a7, a8);
        OSKextLog(0, 23, "Architecture %s not found by name, using running kernel architecture %s.", v17, v18, v19, v20, v21, (char)v16);
        goto LABEL_34;
      }
    }
LABEL_14:
    v22 = 1;
    goto LABEL_19;
  }
  v23 = 1;
LABEL_16:
  RunningKernelArchitecture = (const NXArchInfo *)OSKextGetRunningKernelArchitecture((uint64_t)RunningKernelArchitecture, a2, a3, a4, a5, a6, a7, a8);
  if (!RunningKernelArchitecture)
    RunningKernelArchitecture = (const NXArchInfo *)&__sOSKextUnknownArchInfo;
  __sOSKextArchInfo = (char **)RunningKernelArchitecture;
  v22 = v23;
LABEL_19:
  if (v9 == (const char **)RunningKernelArchitecture)
  {
    v25 = *v9;
    if (!*v9)
      v25 = "(unknown)";
    OSKextLog(0, 23, "Kext library architecture is %s (unchanged).", a4, a5, a6, a7, a8, (char)v25);
  }
  else
  {
    if ((__sOSKextInitializing & 1) == 0 && __sOSAllKexts)
    {
      CFArrayGetCount((CFArrayRef)__sOSAllKexts);
      RunningKernelArchitecture = (const NXArchInfo *)__sOSKextArchInfo;
    }
    v24 = RunningKernelArchitecture->name;
    if (!RunningKernelArchitecture->name)
      v24 = "(unknown)";
    OSKextLog(0, 262166, "Kext library architecture set to %s%s.", a4, a5, a6, a7, a8, (char)v24);
    if ((__sOSKextInitializing & 1) == 0)
    {
      if (__sOSKextsByURL)
        CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextReinitApplierFunction, 0);
      OSKextFlushLoadInfo(0, 1);
    }
  }
  return v22;
}

uint64_t OSKextParseVersionString(char *a1)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  unsigned int v4;
  unsigned int v6;
  char *v7;
  char *v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  uint64_t v19;
  unsigned int v20;
  unsigned int v22;
  unsigned __int8 *v23;
  int v24;
  uint64_t v25;
  unsigned __int8 *v26;
  unsigned int v27;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v33;
  unsigned __int8 *v35;

  if (!a1)
    return -1;
  if (!*a1)
    return -1;
  v1 = (*a1 - 48);
  if (v1 > 9)
    return -1;
  v2 = 0;
  v35 = (unsigned __int8 *)(a1 + 1);
  do
  {
    v3 = &a1[v2];
    v4 = a1[v2 + 1];
    if (v4 <= 0x20 && ((1 << v4) & 0x100002601) != 0)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v35 = (unsigned __int8 *)(v3 + 1);
LABEL_17:
      v16 = 9;
      return v13 + 1000000000000 * v1 + 10000 * v14 + (1000 * v16) + 100000000 * v15;
    }
    if ((v4 - 58) < 0xF6u)
    {
      v35 = (unsigned __int8 *)&a1[v2 + 1];
      v12 = -1;
      if (v4 - 46 > 0x38)
        return v12;
      if (((1 << (v4 - 46)) & 0x158000000000000) == 0)
      {
        if (v4 != 46)
          return v12;
        v7 = &a1[v2];
LABEL_30:
        v9 = (unsigned __int8 *)(v7 + 2);
        v35 = (unsigned __int8 *)(v7 + 2);
        goto LABEL_31;
      }
      v15 = 0;
      v14 = 0;
      v17 = v4;
LABEL_22:
      if (v17 <= 0x20 && ((1 << v17) & 0x100002601) != 0)
      {
LABEL_24:
        v13 = 0;
        goto LABEL_17;
      }
      v16 = __OSKextVersionStageForString(&v35);
      if (v16)
      {
        v25 = 0;
        v13 = 0;
        v26 = v35;
        do
        {
          v27 = v26[v25];
          if (v27 <= 0x20 && ((1 << v27) & 0x100002601) != 0)
          {
            if (!(_DWORD)v25)
              return -1;
            goto LABEL_61;
          }
          if ((v27 - 58) < 0xF6u)
            return -1;
          v29 = v27 - 48;
          if (v29 > 9)
            return -1;
          v13 = 10 * v13 + v29;
          v35 = &v26[++v25];
        }
        while ((_DWORD)v25 != 3);
        v30 = v26[v25];
        if (v30 <= 0x20 && ((1 << v30) & 0x100002600) != 0)
        {
          if (v13 > 255)
            return -1;
        }
        else
        {
          v12 = -1;
          if (v30 || v13 > 255)
            return v12;
        }
LABEL_61:
        if (v16 == 7 && !v13)
          return -1;
        return v13 + 1000000000000 * v1 + 10000 * v14 + (1000 * v16) + 100000000 * v15;
      }
      return -1;
    }
    v6 = v4 - 48;
    if (v6 > 9)
    {
      v35 = (unsigned __int8 *)&a1[v2 + 1];
      return -1;
    }
    v1 = 10 * v1 + v6;
    ++v2;
  }
  while ((_DWORD)v2 != 3);
  v7 = &a1[v2];
  v8 = &a1[v2];
  v11 = v8[1];
  v9 = (unsigned __int8 *)(v8 + 1);
  v10 = v11;
  v35 = v9;
  if (v11 == 46)
    goto LABEL_30;
  if ((v10 - 58) > 0xFFFFFFF5)
    return -1;
LABEL_31:
  v19 = 0;
  v15 = 0;
  while (1)
  {
    v20 = v9[v19];
    if (v20 <= 0x20 && ((1 << v20) & 0x100002601) != 0)
    {
      v13 = 0;
      v14 = 0;
      goto LABEL_17;
    }
    if ((v20 - 58) < 0xF6u)
      break;
    v22 = v20 - 48;
    if (v22 > 9)
      return -1;
    v15 = 10 * v15 + v22;
    v35 = &v9[++v19];
    if ((_DWORD)v19 == 4)
    {
      v23 = &v9[v19];
      v24 = v9[v19];
      if (v24 != 46)
      {
        if ((v24 - 58) > 0xFFFFFFF5)
          return -1;
        goto LABEL_67;
      }
LABEL_66:
      v35 = ++v23;
LABEL_67:
      v31 = 0;
      v14 = 0;
      while (1)
      {
        v17 = v23[v31];
        if (v17 <= 0x20 && ((1 << v17) & 0x100002601) != 0)
          goto LABEL_24;
        if ((v17 - 58) < 0xF6u)
        {
          if (v17 - 97 > 5 || ((1 << (v17 - 97)) & 0x2B) == 0)
            return -1;
          goto LABEL_22;
        }
        v33 = v17 - 48;
        if (v33 > 9)
          return -1;
        v14 = 10 * v14 + v33;
        v35 = &v23[++v31];
        if ((_DWORD)v31 == 4)
        {
          v17 = v23[v31];
          if (v17 == 46)
          {
            v35 = &v23[v31 + 1];
            v17 = *v35;
            goto LABEL_22;
          }
          if ((v17 - 58) <= 0xF5u)
            goto LABEL_22;
          return -1;
        }
      }
    }
  }
  v12 = -1;
  if (v20 - 46 > 0x38)
    return v12;
  if (((1 << (v20 - 46)) & 0x158000000000000) != 0)
  {
    v14 = 0;
    v17 = v9[v19];
    goto LABEL_22;
  }
  if (v20 == 46)
  {
    v23 = &v9[v19];
    goto LABEL_66;
  }
  return v12;
}

uint64_t IOPSRequestBatteryUpdate(int a1)
{
  const __CFDictionary *v1;
  io_service_t MatchingService;
  io_object_t v3;
  uint64_t v4;
  uint64_t input;
  io_connect_t connect;

  connect = 0;
  input = a1;
  v1 = IOServiceMatching("AppleSmartBatteryManager");
  MatchingService = IOServiceGetMatchingService(0, v1);
  if (!MatchingService)
    return 3758097136;
  v3 = MatchingService;
  v4 = IOServiceOpen(MatchingService, *MEMORY[0x1E0C83DA0], 0, &connect);
  if (!(_DWORD)v4)
  {
    IOConnectCallMethod(connect, 4u, &input, 1u, 0, 0, 0, 0, 0, 0);
    IOServiceClose(connect);
  }
  IOObjectRelease(v3);
  return v4;
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return IOConnectCallMethod(connection, selector, 0, 0, inputStruct, inputStructCnt, 0, 0, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  int v12;
  int v13;
  BOOL v14;
  int v15;
  int v16;
  void *__dst;
  kern_return_t result;
  size_t v19;
  void *v20;
  unsigned int v21;
  uint64_t v22;
  size_t v23;
  unsigned int v24;

  v12 = inputStructCnt;
  v13 = (int)inputStruct;
  v24 = 0;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  v14 = inputStructCnt > 0x1000;
  if (inputStructCnt <= 0x1000)
  {
    v15 = 0;
  }
  else
  {
    LODWORD(inputStruct) = 0;
    LODWORD(inputStructCnt) = 0;
    v15 = v13;
  }
  if (v14)
    v16 = v12;
  else
    v16 = 0;
  if (!outputCnt)
    outputCnt = (uint32_t *)&IOConnectCallMethod_zero;
  if (!outputStructCnt)
    return io_connect_method(connection, selector, (int)input, inputCnt, (int)inputStruct, inputStructCnt, v15, v16, 0, (int *)&v24, output, (int *)outputCnt, 0, &v23);
  __dst = outputStruct;
  if (*outputStructCnt == -3)
  {
    result = io_connect_method_var_output(connection, selector, (int)input, inputCnt, (int)inputStruct, inputStructCnt, v15, v16, 0, (int *)&v24, output, (int *)outputCnt, &v22, &v21);
    *(_QWORD *)outputStruct = v22;
    v19 = v21;
  }
  else
  {
    if (*outputStructCnt > 0x1000)
    {
      v20 = outputStruct;
      v23 = *outputStructCnt;
      __dst = 0;
    }
    else
    {
      v20 = 0;
      v24 = *outputStructCnt;
    }
    result = io_connect_method(connection, selector, (int)input, inputCnt, (int)inputStruct, inputStructCnt, v15, v16, __dst, (int *)&v24, output, (int *)outputCnt, (uint64_t)v20, &v23);
    if (*outputStructCnt > 0x1000)
      v19 = v23;
    else
      v19 = v24;
  }
  *outputStructCnt = v19;
  return result;
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  kern_return_t v2;

  v2 = io_service_close(connect);
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], connect);
  return v2;
}

uint64_t io_service_close(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  *(_QWORD *)&v5.msgh_bits = 0x1800001513;
  *(_QWORD *)&v5.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v5.msgh_voucher_port = 0xB0000000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t io_connect_method_var_output(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__dst, int *a10, void *a11, int *a12, _QWORD *a13, _DWORD *a14)
{
  unsigned int v14;
  unsigned int v15;
  const void *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  const void *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  mach_port_t *v30;
  uint64_t v31;
  char *v32;
  int v33;
  int v34;
  int v35;
  mach_port_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  char *v40;
  mach_port_t v41;
  char *v42;
  uint64_t v43;
  size_t v44;
  unsigned int v45;
  const void *v46;
  mach_port_t reply_port[4];
  _BYTE v48[32];
  size_t __n[2];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;

  v14 = MEMORY[0x1E0C80A78]();
  v78 = *MEMORY[0x1E0C80C00];
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  *(_OWORD *)&v48[16] = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)reply_port = 0u;
  *(_OWORD *)v48 = 0u;
  *(_QWORD *)&v48[8] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&v48[16] = v20;
  if (v15 <= 0x10)
  {
    v21 = v19;
    v22 = v18;
    v23 = v17;
    v24 = v16;
    v25 = v15;
    v26 = v14;
    v27 = 2 * v15;
    __memcpy_chk();
    *(_DWORD *)&v48[20] = v25;
    if (v23 <= 0x1000)
    {
      v30 = &reply_port[v27];
      v31 = (v23 + 3) & 0xFFFFFFFC;
      v32 = (char *)&reply_port[v27] + v31;
      v33 = v27 * 4 + v31;
      memcpy(v30 + 11, v24, v23);
      v30[10] = v23;
      *(_QWORD *)(v32 + 44) = v22;
      *(_QWORD *)(v32 + 52) = v21;
      v34 = *a10;
      if (*a10 >= 0x1000)
        v34 = 4096;
      *((_DWORD *)v32 + 15) = v34;
      v35 = *a12;
      if (*a12 >= 0x10)
        v35 = 16;
      *((_DWORD *)v32 + 16) = v35;
      v36 = mig_get_reply_port();
      reply_port[0] = 5395;
      reply_port[1] = v33 + 68;
      *(_QWORD *)&reply_port[2] = __PAIR64__(v36, v26);
      *(_QWORD *)v48 = 0xB3800000000;
      v37 = mach_msg2_internal();
      v28 = v37;
      if ((v37 - 268435458) <= 0xE && ((1 << (v37 - 2)) & 0x4003) != 0)
      {
        mig_put_reply_port(reply_port[3]);
        return v28;
      }
      if ((_DWORD)v37)
      {
        mig_dealloc_reply_port(reply_port[3]);
        return v28;
      }
      if (*(_DWORD *)&v48[4] == 71)
      {
        v28 = 4294966988;
      }
      else if (*(_DWORD *)&v48[4] == 2972)
      {
        if ((reply_port[0] & 0x80000000) != 0)
        {
          v28 = 4294966996;
          if (*(_DWORD *)&v48[8] == 1
            && reply_port[1] >= 0x40
            && reply_port[1] <= 0x10C0
            && !reply_port[2]
            && v48[23] == 1)
          {
            v38 = HIDWORD(__n[0]);
            if (HIDWORD(__n[0]) <= 0x1000 && reply_port[1] - 64 >= HIDWORD(__n[0]))
            {
              v39 = (HIDWORD(__n[0]) + 3) & 0xFFFFFFFC;
              if (reply_port[1] >= v39 + 64)
              {
                v40 = (char *)reply_port + v39;
                v41 = *((_DWORD *)v40 + 14);
                if (v41 <= 0x10 && v41 <= (reply_port[1] - v39 - 64) >> 3 && reply_port[1] - v39 == 8 * v41 + 64)
                {
                  v42 = v40 - 4096;
                  v43 = (uint64_t)&v40[8 * v41 - 4096];
                  if (*(_DWORD *)&v48[24] == *(_DWORD *)(v43 + 4156))
                  {
                    v44 = *a10;
                    if (HIDWORD(__n[0]) <= v44)
                    {
                      memcpy(__dst, &__n[1], HIDWORD(__n[0]));
                      *a10 = v38;
                      v45 = *((_DWORD *)v42 + 1038);
                      v46 = v42 + 4156;
                      if (v45 <= *a12)
                      {
                        memcpy(a11, v46, 8 * v45);
                        v28 = 0;
                        *a12 = *((_DWORD *)v42 + 1038);
                        *a13 = *(_QWORD *)&v48[12];
                        *a14 = *(_DWORD *)(v43 + 4156);
                        return v28;
                      }
                      memcpy(a11, v46, (8 * *a12));
                      *a12 = *((_DWORD *)v42 + 1038);
                    }
                    else
                    {
                      memcpy(__dst, &__n[1], v44);
                      *a10 = v38;
                    }
                    return 4294966989;
                  }
                }
              }
            }
          }
        }
        else if (reply_port[1] == 36)
        {
          v28 = 4294966996;
          if (*(_DWORD *)&v48[16])
          {
            if (reply_port[2])
              v28 = 4294966996;
            else
              v28 = *(unsigned int *)&v48[16];
          }
        }
        else
        {
          v28 = 4294966996;
        }
      }
      else
      {
        v28 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v28;
    }
  }
  return 4294966989;
}

void IOHIDManagerSetDeviceMatchingMultiple(IOHIDManagerRef manager, CFArrayRef multiple)
{
  __CFSet *v5;
  __CFDictionary *v6;
  __CFSet *v7;
  __CFDictionary *v8;
  const void *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFTypeID TypeID;
  const void *v15;
  const __CFAllocator *v16;

  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  v5 = (__CFSet *)*((_QWORD *)manager + 4);
  if (v5)
  {
    if ((*((_DWORD *)manager + 38) & 5) == 1)
    {
      __IOHIDManagerSaveProperties((uint64_t)manager, 0);
      v5 = (__CFSet *)*((_QWORD *)manager + 4);
    }
    CFSetRemoveAllValues(v5);
  }
  v6 = (__CFDictionary *)*((_QWORD *)manager + 6);
  if (v6)
    CFDictionaryRemoveAllValues(v6);
  v7 = (__CFSet *)*((_QWORD *)manager + 5);
  if (v7)
    CFSetRemoveAllValues(v7);
  v8 = (__CFDictionary *)*((_QWORD *)manager + 8);
  if (v8)
    CFDictionaryRemoveAllValues(v8);
  v9 = (const void *)*((_QWORD *)manager + 15);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)manager + 15) = 0;
  }
  if (multiple)
  {
    Count = CFArrayGetCount(multiple);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; i != v11; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(multiple, i);
        TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(ValueAtIndex))
          __IOHIDManagerSetDeviceMatching((uint64_t)manager, ValueAtIndex);
      }
    }
  }
  else
  {
    __IOHIDManagerSetDeviceMatching((uint64_t)manager, 0);
  }
  if (*((_QWORD *)manager + 4))
  {
    v15 = (const void *)*((_QWORD *)manager + 15);
    if (v15)
      CFRelease(v15);
    v16 = CFGetAllocator(manager);
    *((_QWORD *)manager + 15) = CFSetCreateCopy(v16, *((CFSetRef *)manager + 4));
  }
  os_unfair_recursive_lock_unlock();
}

void __IOHIDManagerSetDeviceMatching(uint64_t a1, const __CFDictionary *a2)
{
  __CFDictionary *v4;
  const __CFDictionary *v5;
  kern_return_t v6;
  int v7;
  NSObject *v8;
  IONotificationPort *v9;
  __CFRunLoopSource *RunLoopSource;
  __CFSet *v11;
  const __CFAllocator *v12;
  CFSetCallBacks v13;
  io_iterator_t notification;

  os_unfair_recursive_lock_lock_with_options();
  if (!*(_QWORD *)(a1 + 72))
  {
    v9 = IONotificationPortCreate(0);
    *(_QWORD *)(a1 + 72) = v9;
    if (*(_QWORD *)(a1 + 80))
    {
      RunLoopSource = IONotificationPortGetRunLoopSource(v9);
      if (RunLoopSource)
        CFRunLoopAddSource(*(CFRunLoopRef *)(a1 + 80), RunLoopSource, *(CFRunLoopMode *)(a1 + 88));
    }
  }
  os_unfair_recursive_lock_unlock();
  v4 = IOServiceMatching("IOHIDDevice");
  if (v4)
  {
    v5 = v4;
    notification = 0;
    __IOHIDManagerMergeDictionaries(a2, v4);
    v6 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)(a1 + 72), "IOServiceFirstMatch", v5, (IOServiceMatchingCallback)__IOHIDManagerDeviceAdded, (void *)a1, &notification);
    if (v6)
    {
      v7 = v6;
      v8 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        __IOHIDManagerSetDeviceMatching_cold_1(v7, v8);
    }
    else
    {
      os_unfair_recursive_lock_lock_with_options();
      v11 = *(__CFSet **)(a1 + 40);
      if (v11
        || (v13.version = 0,
            memset(&v13.copyDescription, 0, 24),
            v13.retain = (CFSetRetainCallBack)_IOObjectCFRetain,
            v13.release = (CFSetReleaseCallBack)_IOObjectCFRelease,
            v12 = CFGetAllocator((CFTypeRef)a1),
            v11 = CFSetCreateMutable(v12, 0, &v13),
            (*(_QWORD *)(a1 + 40) = v11) != 0))
      {
        CFSetAddValue(v11, (const void *)notification);
        IOObjectRelease(notification);
        os_unfair_recursive_lock_unlock();
        __IOHIDManagerDeviceAdded(a1, notification);
      }
      else
      {
        os_unfair_recursive_lock_unlock();
      }
    }
  }
}

__CFDictionary *MakeOneStringProp(const void *a1, const char *a2)
{
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  CFStringRef v6;
  const void *v7;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v6 = CFStringCreateWithCString(v4, a2, 0);
    if (v6)
    {
      v7 = v6;
      CFDictionarySetValue(Mutable, a1, v6);
    }
    else
    {
      v7 = Mutable;
      Mutable = 0;
    }
    CFRelease(v7);
  }
  return Mutable;
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return MakeOneStringProp(CFSTR("IOProviderClass"), name);
}

void __IOHIDManagerMergeDictionaries(const __CFDictionary *a1, __CFDictionary *a2)
{
  unsigned int Count;
  uint64_t v5;
  size_t v6;
  const void **v7;
  const void **v8;
  const void **v9;
  const void **v10;
  const void **v11;
  const void *v12;
  const void *v13;
  const void *v14;

  if (a1)
  {
    if (a2)
    {
      Count = CFDictionaryGetCount(a1);
      v5 = Count;
      if (Count)
      {
        v6 = 8 * Count;
        v7 = (const void **)malloc_type_malloc(v6, 0xC0040B8AA526DuLL);
        v8 = (const void **)malloc_type_malloc(v6, 0x6004044C4A2DFuLL);
        v9 = v8;
        if (v7 && v8)
        {
          CFDictionaryGetKeysAndValues(a1, v8, v7);
          v10 = v7;
          v11 = v9;
          do
          {
            v13 = *v11++;
            v12 = v13;
            v14 = *v10++;
            CFDictionarySetValue(a2, v12, v14);
            --v5;
          }
          while (v5);
        }
        else if (!v7)
        {
          goto LABEL_11;
        }
        free(v7);
LABEL_11:
        if (v9)
          free(v9);
      }
    }
  }
}

uint64_t __IOHIDManagerDeviceAdded(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result;
  io_service_t v5;
  int v6;
  uint64_t v7;
  const __CFAllocator *v8;
  IOHIDDeviceRef v9;
  IOHIDDeviceRef v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  kern_return_t v13;
  __CFDictionary *Mutable;
  NSObject *v15;
  __int128 v16;
  __CFSet *v17;
  int v18;
  int v19;
  unsigned int v20;
  char v21;
  const __CFDictionary *v22;
  const __CFAllocator *v23;
  const __CFAllocator *v24;
  __CFRunLoopSource *v25;
  __CFRunLoop *v26;
  const __CFString *v27;
  const __CFAllocator *allocator;
  uint64_t v29;
  uint64_t v30;
  io_object_t notification;
  CFRunLoopSourceContext valueCallBacks;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  notification = 0;
  result = IOIteratorNext(iterator);
  if (!(_DWORD)result)
    return result;
  v5 = result;
  v6 = 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = MEMORY[0x1E0C9B3A0];
  do
  {
    v8 = CFGetAllocator((CFTypeRef)a1);
    v9 = IOHIDDeviceCreate(v8, v5);
    if (!v9)
      goto LABEL_45;
    v10 = v9;
    os_unfair_recursive_lock_lock_with_options();
    if (!*(_QWORD *)(a1 + 32))
    {
      v11 = CFGetAllocator((CFTypeRef)a1);
      *(_QWORD *)(a1 + 32) = CFSetCreateMutable(v11, 0, MEMORY[0x1E0C9B3B0]);
      if (*(_BYTE *)(a1 + 144))
      {
        v12 = CFGetAllocator((CFTypeRef)a1);
        *(_QWORD *)(a1 + 136) = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E0C9B390], 0);
      }
      v6 = 1;
    }
    v29 = a1;
    v30 = 0;
    v13 = IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 72), v5, "IOGeneralInterest", (IOServiceInterestCallback)__IOHIDManagerDeviceRemoved, (void *)a1, &notification);
    Mutable = *(__CFDictionary **)(a1 + 48);
    if (Mutable)
    {
      if (!v13)
        goto LABEL_14;
    }
    else
    {
      v16 = *(_OWORD *)(v7 + 16);
      *(_OWORD *)&valueCallBacks.version = *(_OWORD *)v7;
      *(_OWORD *)&valueCallBacks.retain = v16;
      valueCallBacks.copyDescription = *(CFStringRef (__cdecl **)(const void *))(v7 + 32);
      valueCallBacks.info = _IOObjectCFRetain;
      valueCallBacks.retain = (const void *(__cdecl *)(const void *))_IOObjectCFRelease;
      Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], (const CFDictionaryValueCallBacks *)&valueCallBacks);
      *(_QWORD *)(a1 + 48) = Mutable;
      if (!v13)
      {
LABEL_14:
        CFDictionarySetValue(Mutable, v10, (const void *)notification);
        IOObjectRelease(notification);
        v17 = *(__CFSet **)(a1 + 32);
        if (v17)
          CFSetAddValue(v17, v10);
        os_unfair_recursive_lock_unlock();
        os_unfair_recursive_lock_lock_with_options();
        if (*(_QWORD *)(a1 + 240))
        {
          v18 = 8;
          LODWORD(v30) = 8;
        }
        else
        {
          v18 = 0;
        }
        if (*(_QWORD *)(a1 + 176))
        {
          v18 |= 0x10u;
          LODWORD(v30) = v18;
        }
        if (*(_QWORD *)(a1 + 192))
        {
          v18 |= 0x20u;
          LODWORD(v30) = v18;
        }
        if (*(_QWORD *)(a1 + 200))
        {
          v18 |= 0x1000u;
          LODWORD(v30) = v18;
        }
        if (*(_QWORD *)(a1 + 104))
        {
          v18 |= 0x200u;
          LODWORD(v30) = v18;
        }
        os_unfair_recursive_lock_unlock();
        os_unfair_recursive_lock_lock_with_options();
        if (*(_BYTE *)(a1 + 144))
        {
          v18 |= 1u;
          LODWORD(v30) = v18;
        }
        if (*(_QWORD *)(a1 + 80))
        {
          v19 = v18 | 0x40;
          LODWORD(v30) = v18 | 0x40;
          if (!v6 && *(_QWORD *)(a1 + 216))
          {
            v19 = v18 | 0x44;
            LODWORD(v30) = v18 | 0x44;
          }
        }
        else
        {
          v19 = v18;
        }
        if (*(_QWORD *)(a1 + 96))
        {
          LODWORD(v30) = v19 | 0x100;
          if (*(_QWORD *)(a1 + 216))
          {
            v20 = atomic_load((unsigned int *)(a1 + 116));
            if (v20 == 1)
              LODWORD(v30) = v30 | 4;
          }
        }
        v21 = atomic_load((unsigned int *)(a1 + 116));
        if ((v21 & 1) != 0)
          LODWORD(v30) = v30 | 0x400;
        os_unfair_recursive_lock_unlock();
        __IOHIDManagerDeviceApplier(v10, &v29);
        if ((*(_DWORD *)(a1 + 152) & 3) == 1)
          __IOHIDDeviceLoadProperties((uint64_t)v10);
        os_unfair_recursive_lock_lock_with_options();
        v22 = *(const __CFDictionary **)(a1 + 56);
        if (v22)
          CFDictionaryApplyFunction(v22, (CFDictionaryApplierFunction)__IOHIDApplyPropertiesToDeviceFromDictionary, v10);
        os_unfair_recursive_lock_unlock();
        CFRelease(v10);
LABEL_45:
        IOObjectRelease(v5);
        goto LABEL_46;
      }
    }
    v15 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(valueCallBacks.version) = 67109120;
      HIDWORD(valueCallBacks.version) = v13;
      _os_log_error_impl(&dword_18AAAF000, v15, OS_LOG_TYPE_ERROR, "IOServiceAddInterestNotification: 0x%x", (uint8_t *)&valueCallBacks, 8u);
    }
    CFRelease(v10);
    IOObjectRelease(v5);
    os_unfair_recursive_lock_unlock();
LABEL_46:
    result = IOIteratorNext(iterator);
    v5 = result;
  }
  while ((_DWORD)result);
  if (v6)
  {
    memset(&valueCallBacks, 0, 72);
    os_unfair_recursive_lock_lock_with_options();
    valueCallBacks.info = (void *)a1;
    valueCallBacks.perform = (void (__cdecl *)(void *))__IOHIDManagerInitialEnumCallback;
    v23 = CFGetAllocator((CFTypeRef)a1);
    *(_QWORD *)(a1 + 120) = CFSetCreateCopy(v23, *(CFSetRef *)(a1 + 32));
    v24 = CFGetAllocator((CFTypeRef)a1);
    v25 = CFRunLoopSourceCreate(v24, 0, &valueCallBacks);
    *(_QWORD *)(a1 + 128) = v25;
    v26 = *(__CFRunLoop **)(a1 + 80);
    if (v26)
    {
      v27 = *(const __CFString **)(a1 + 88);
      if (v27)
      {
        CFRunLoopAddSource(v26, v25, v27);
        CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 128));
        CFRunLoopWakeUp(*(CFRunLoopRef *)(a1 + 80));
      }
    }
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

uint64_t IOHIDServiceClientFastPathInit(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  const __CFNumber *v5;
  const __CFDictionary *v7;
  uint64_t MatchingServices;
  io_object_t v9;
  io_service_t v10;
  const __CFUUID *v11;
  const __CFUUID *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, _QWORD, _QWORD, _QWORD *);
  const __CFUUID *v16;
  CFUUIDBytes v17;
  uint64_t v18;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  io_iterator_t existing;
  uint64_t valuePtr;
  SInt32 theScore;

  existing = 0;
  v2 = (_QWORD *)(a1 + 104);
  if (*(_QWORD *)(a1 + 104))
    return 1;
  theScore = 0;
  valuePtr = 0;
  v5 = *(const __CFNumber **)(a1 + 16);
  if (!v5 || !CFNumberGetValue(v5, kCFNumberSInt64Type, &valuePtr))
    goto LABEL_24;
  v7 = IORegistryEntryIDMatching(valuePtr);
  if (!v7)
  {
    v20 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      IOHIDServiceClientFastPathInit_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
    goto LABEL_24;
  }
  MatchingServices = IOServiceGetMatchingServices(0, v7, &existing);
  if ((_DWORD)MatchingServices)
  {
    v28 = MatchingServices;
    v29 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      IOHIDServiceClientFastPathInit_cold_5(v28, v29, v30, v31, v32, v33, v34, v35);
    goto LABEL_24;
  }
  v9 = IOIteratorNext(existing);
  if (!v9)
  {
    v36 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      IOHIDServiceClientFastPathInit_cold_2(v36, v37, v38, v39, v40, v41, v42, v43);
LABEL_24:
    v10 = 0;
LABEL_25:
    v3 = 0;
    goto LABEL_11;
  }
  v10 = v9;
  v11 = CFUUIDGetConstantUUIDWithBytes(0, 0xBu, 0x84u, 0x2Au, 0xDDu, 0xC3u, 0x95u, 0x43u, 0x52u, 0x95u, 0xF6u, 0x65u, 0x85u, 0xEBu, 0x51u, 0x56u, 0x23u);
  v12 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  v13 = IOCreatePlugInInterfaceForService(v10, v11, v12, (IOCFPlugInInterface ***)(a1 + 112), &theScore);
  if ((_DWORD)v13)
  {
    v44 = v13;
    v45 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      IOHIDServiceClientFastPathInit_cold_4(v44, v45, v46, v47, v48, v49, v50, v51);
    goto LABEL_25;
  }
  v14 = *(_QWORD *)(a1 + 112);
  v15 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD *))(*(_QWORD *)v14 + 8);
  v16 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x27u, 0xBAu, 0xAEu, 0x90u, 0x2Fu, 0xE5u, 0x40u, 0x2Au, 0xBFu, 0x7Fu, 0x4Eu, 0xFAu, 0x27u, 0x7Du, 0x37u, 8u);
  v17 = CFUUIDGetUUIDBytes(v16);
  v18 = v15(v14, *(_QWORD *)&v17.byte0, *(_QWORD *)&v17.byte8, v2);
  if ((_DWORD)v18)
  {
    v52 = v18;
    v53 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      IOHIDServiceClientFastPathInit_cold_3(v52, v53, v54, v55, v56, v57, v58, v59);
    goto LABEL_25;
  }
  v3 = (*(unsigned __int8 (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)*v2 + 32))(*v2, 0, a2);
LABEL_11:
  if (existing)
    IOObjectRelease(existing);
  if (v10)
    IOObjectRelease(v10);
  if (!(_DWORD)v3)
    IOHIDServiceClientFastPathInvalidate(a1);
  return v3;
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  kern_return_t result;

  result = io_registry_entry_get_parent_iterator(entry, plane);
  if (!result)
  {
    io_iterator_next(0);
    *parent = 0;
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], 0);
    if (*parent)
      return 0;
    else
      return -536870208;
  }
  return result;
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  if (io_iterator_next(iterator))
    return 0;
  else
    return 0;
}

uint64_t io_iterator_next(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  *(_QWORD *)&v5.msgh_bits = 0x1800001513;
  *(_QWORD *)&v5.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v5.msgh_voucher_port = 0xAF200000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t io_registry_entry_get_parent_iterator(unsigned int a1, const char *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  _OWORD v9[8];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  else
    v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v8 = 0xAFE00000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  io_object_t v2;

  v2 = *notifier;
  if (v2)
  {
    IOObjectRelease(v2);
    *notifier = 0;
  }
  return 0;
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return mach_port_deallocate(*MEMORY[0x1E0C83DA0], object);
}

CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID)
{
  const __CFAllocator *v1;
  __CFDictionary *Mutable;
  CFNumberRef v3;
  CFNumberRef v4;
  uint64_t valuePtr;

  valuePtr = entryID;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v3 = CFNumberCreate(v1, kCFNumberSInt64Type, &valuePtr);
    if (v3)
    {
      v4 = v3;
      CFDictionarySetValue(Mutable, CFSTR("IORegistryEntryID"), v3);
    }
    else
    {
      v4 = Mutable;
      Mutable = 0;
    }
    CFRelease(v4);
  }
  return Mutable;
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  const __CFAllocator *v8;
  CFMutableStringRef Mutable;
  CFTypeRef CFProperty;
  CFTypeID TypeID;
  const __CFString *v12;
  const __CFURL *v13;
  const __CFURL *v14;
  __CFBundle *v15;
  const __CFArray *FactoriesForPlugInTypeInPlugIn;
  kern_return_t v17;
  __CFArray *v18;
  CFMutableArrayRef v19;
  const __CFArray *v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex v23;
  const __CFUUID *v24;
  void *v25;
  void *v26;
  const __CFUUID *v27;
  void (*v28)(void *, _QWORD, _QWORD, void **);
  CFUUIDBytes v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex v32;
  int v33;
  CFIndex v34;
  CFIndex v35;
  int v36;
  CFIndex v37;
  void *v38;
  int v39;
  const __CFArray *SystemExtensionsFolderURLs;
  CFIndex Count;
  CFIndex v43;
  const __CFUUID *v44;
  CFIndex v45;
  const __CFURL *ValueAtIndex;
  const __CFURL *v47;
  const __CFURL *v48;
  __CFBundle *Bundle;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *v51;
  kern_return_t matched;
  SInt32 *v53;
  SInt32 *v54;
  io_service_t v55;
  io_service_t v56;
  void *value;
  BOOLean_t matches[2];
  CFStringRef context;
  CFUUIDRef v62;

  value = 0;
  *(_QWORD *)matches = 0;
  context = 0;
  v62 = 0;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!Mutable)
  {
    CFProperty = 0;
    goto LABEL_11;
  }
  CFProperty = IORegistryEntryCreateCFProperty(service, CFSTR("IOCFPlugInTypes"), v8, 0);
  if (!CFProperty)
    goto LABEL_11;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(CFProperty))
    goto LABEL_11;
  context = 0;
  v62 = pluginType;
  CFDictionaryApplyFunction((CFDictionaryRef)CFProperty, (CFDictionaryApplierFunction)_IOGetWithUUIDKey, &context);
  v12 = context;
  if (!context)
    goto LABEL_11;
  if (CFStringGetCharacterAtIndex(context, 0) == 47)
  {
    CFStringAppend(Mutable, v12);
    v13 = CFURLCreateWithFileSystemPath(0, Mutable, kCFURLPOSIXPathStyle, 1u);
    if (v13)
    {
      v14 = v13;
      if (CFURLResourceIsReachable(v13, 0))
      {
        v15 = CFPlugInCreate(0, v14);
        CFRelease(v14);
        if (v15)
          goto LABEL_65;
      }
      else
      {
        CFRelease(v14);
      }
    }
  }
  SystemExtensionsFolderURLs = (const __CFArray *)OSKextGetSystemExtensionsFolderURLs();
  Count = CFArrayGetCount(SystemExtensionsFolderURLs);
  if (Count < 1)
  {
LABEL_11:
    FactoriesForPlugInTypeInPlugIn = 0;
    v17 = 0;
    matches[1] = 1;
    goto LABEL_12;
  }
  v43 = Count;
  v56 = service;
  v44 = pluginType;
  v54 = theScore;
  v45 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(SystemExtensionsFolderURLs, v45);
    v47 = CFURLCreateCopyAppendingPathComponent(0, ValueAtIndex, v12, 1u);
    if (v47)
    {
      v48 = v47;
      v15 = CFPlugInCreate(0, v47);
      CFRelease(v48);
      if (v15)
        break;
    }
    if (v43 == ++v45)
    {
      theScore = v54;
      pluginType = v44;
      service = v56;
      goto LABEL_11;
    }
  }
  theScore = v54;
  pluginType = v44;
  service = v56;
LABEL_65:
  Bundle = CFPlugInGetBundle(v15);
  if (Bundle
    && (InfoDictionary = CFBundleGetInfoDictionary(Bundle)) != 0
    && (v51 = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, CFSTR("Personality"))) != 0)
  {
    matched = IOServiceMatchPropertyTable(service, v51, &matches[1]);
    if (matched)
    {
      v17 = matched;
      FactoriesForPlugInTypeInPlugIn = 0;
      matches[1] = 0;
      goto LABEL_12;
    }
    if (!matches[1])
    {
      FactoriesForPlugInTypeInPlugIn = 0;
      goto LABEL_72;
    }
  }
  else
  {
    matches[1] = 1;
  }
  FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(pluginType, v15);
LABEL_72:
  v17 = 0;
LABEL_12:
  if (Mutable)
    CFRelease(Mutable);
  if (CFProperty)
    CFRelease(CFProperty);
  if (!v17)
  {
    v17 = -536870201;
    if (!FactoriesForPlugInTypeInPlugIn)
      return v17;
    if (!CFArrayGetCount(FactoriesForPlugInTypeInPlugIn))
      goto LABEL_18;
    v55 = service;
    v18 = CFArrayCreateMutable(v8, 0, 0);
    v19 = CFArrayCreateMutable(v8, 0, 0);
    v20 = v19;
    if (v18)
    {
      if (v19)
      {
        v21 = CFArrayGetCount(FactoriesForPlugInTypeInPlugIn);
        if (v21 >= 1)
        {
          v22 = v21;
          v23 = 0;
          v53 = theScore;
          do
          {
            v24 = (const __CFUUID *)CFArrayGetValueAtIndex(FactoriesForPlugInTypeInPlugIn, v23);
            v25 = CFPlugInInstanceCreate(0, v24, pluginType);
            if (v25)
            {
              v26 = v25;
              v27 = pluginType;
              v28 = *(void (**)(void *, _QWORD, _QWORD, void **))(*(_QWORD *)v25 + 8);
              v29 = CFUUIDGetUUIDBytes(interfaceType);
              v28(v26, *(_QWORD *)&v29.byte0, *(_QWORD *)&v29.byte8, &value);
              pluginType = v27;
              (*(void (**)(void *))(*(_QWORD *)v26 + 24))(v26);
              if (value)
              {
                matches[0] = 0;
                if ((*(unsigned int (**)(void *, _QWORD, _QWORD, BOOLean_t *))(*(_QWORD *)value + 40))(value, 0, v55, matches))
                {
                  (*(void (**)(void *))(*(_QWORD *)value + 24))(value);
                }
                else
                {
                  v30 = CFArrayGetCount(v20);
                  if (v30 < 1)
                  {
                    v32 = 0;
                  }
                  else
                  {
                    v31 = v30;
                    v32 = 0;
                    while (1)
                    {
                      v33 = matches[0];
                      if (v33 > (int)CFArrayGetValueAtIndex(v20, v32))
                        break;
                      if (v31 == ++v32)
                      {
                        v32 = v31;
                        break;
                      }
                    }
                    theScore = v53;
                  }
                  pluginType = v27;
                  CFArrayInsertValueAtIndex(v18, v32, value);
                  CFArrayInsertValueAtIndex(v20, v32, (const void *)matches[0]);
                }
              }
            }
            ++v23;
          }
          while (v23 != v22);
        }
      }
    }
    v34 = CFArrayGetCount(v18);
    if (v34 < 1)
    {
      v36 = 0;
LABEL_49:
      CFRelease(FactoriesForPlugInTypeInPlugIn);
      if (v18)
        CFRelease(v18);
      if (v20)
        CFRelease(v20);
      if (v36)
        return 0;
      else
        return -536870210;
    }
    v35 = v34;
    v36 = 0;
    v37 = 0;
    while (1)
    {
      v38 = (void *)CFArrayGetValueAtIndex(v18, v37);
      value = v38;
      if (v36)
      {
        v36 = 1;
      }
      else
      {
        v39 = (*(uint64_t (**)(void *, _QWORD, _QWORD))(*(_QWORD *)v38 + 48))(v38, 0, v55);
        v38 = value;
        if (!v39)
        {
          *theInterface = (IOCFPlugInInterface **)value;
          *theScore = CFArrayGetValueAtIndex(v20, v37);
          v36 = 1;
          goto LABEL_45;
        }
        v36 = 0;
      }
      (*(void (**)(void *))(*(_QWORD *)v38 + 24))(v38);
LABEL_45:
      if (v35 == ++v37)
        goto LABEL_49;
    }
  }
  if (FactoriesForPlugInTypeInPlugIn)
LABEL_18:
    CFRelease(FactoriesForPlugInTypeInPlugIn);
  return v17;
}

uint64_t OSKextGetSystemExtensionsFolderURLs()
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  return __sOSKextSystemExtensionsFolderURLs;
}

char **OSKextGetRunningKernelArchitecture(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char **result;
  io_registry_entry_t RootEntry;
  io_registry_entry_t v10;
  const NXArchInfo *v11;
  char v12;
  cpu_subtype_t v13;
  cpu_type_t v14;

  v13 = -1;
  v14 = -1;
  result = (char **)OSKextGetRunningKernelArchitecture_result;
  if ((char **)OSKextGetRunningKernelArchitecture_result != &__sOSKextUnknownArchInfo)
  {
    if (OSKextGetRunningKernelArchitecture_result)
      return result;
    goto LABEL_10;
  }
  RootEntry = IORegistryGetRootEntry(0);
  if (!RootEntry
    || (v10 = RootEntry,
        !__OSKextReadRegistryNumberProperty(RootEntry, CFSTR("OSKernelCPUType"), kCFNumberSInt32Type, &v14))|| !__OSKextReadRegistryNumberProperty(v10, CFSTR("OSKernelCPUSubtype"), kCFNumberSInt32Type, &v13))
  {
LABEL_9:
    result = (char **)OSKextGetRunningKernelArchitecture_result;
    if (OSKextGetRunningKernelArchitecture_result)
      return result;
    goto LABEL_10;
  }
  v11 = NXGetArchInfoFromCpuType(v14, v13);
  OSKextGetRunningKernelArchitecture_result = (uint64_t)v11;
  if (v11)
  {
    OSKextLog(0, 262148, "Running kernel architecture is %s.", a4, a5, a6, a7, a8, (char)v11->name);
    goto LABEL_9;
  }
LABEL_10:
  OSKextLog(0, 81, "Can't read running kernel architecture.", a4, a5, a6, a7, a8, v12);
  OSKextGetRunningKernelArchitecture_result = (uint64_t)&__sOSKextUnknownArchInfo;
  return &__sOSKextUnknownArchInfo;
}

uint64_t __OSKextReadRegistryNumberProperty(io_registry_entry_t a1, const __CFString *a2, CFNumberType a3, void *a4)
{
  const __CFNumber *CFProperty;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFNumber *v12;
  CFTypeID v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t Value;
  char v21;

  CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(a1, a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (CFProperty)
  {
    v12 = CFProperty;
    v13 = CFGetTypeID(CFProperty);
    if (v13 == CFNumberGetTypeID())
    {
      Value = CFNumberGetValue(v12, a3, a4);
    }
    else
    {
      OSKextLog(0, 81, "Can't read kernel CPU info from IORegistry (absent or wrong type).", v14, v15, v16, v17, v18, v21);
      Value = 0;
    }
    CFRelease(v12);
  }
  else
  {
    OSKextLog(0, 81, "Can't read kernel CPU info from IORegistry (absent or wrong type).", v7, v8, v9, v10, v11, v21);
    return 0;
  }
  return Value;
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return IORegistryEntrySearchCFProperty(entry, 0, key, allocator, 0);
}

io_registry_entry_t IORegistryGetRootEntry(mach_port_t mainPort)
{
  mach_port_t v2;
  mach_port_t mainPorta;

  v2 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v2 = 0;
    else
      v2 = mainPorta;
  }
  io_registry_get_root_entry(v2);
  if (v2 && v2 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v2);
  return 0;
}

uint64_t io_registry_get_root_entry(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  *(_QWORD *)&v5.msgh_bits = 0x1800001513;
  *(_QWORD *)&v5.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v5.msgh_voucher_port = 0xB0B00000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

IOReturn IODataQueueEnqueue(IODataQueueMemory *dataQueue, void *data, uint32_t dataSize)
{
  return __IODataQueueEnqueue(&dataQueue->queueSize, 0, 0, *(size_t *)&dataSize, data, 0, 0, 0);
}

void __IOHIDEventSystemClientServiceReplaceCallback(void *key, const void *a2, CFDictionaryRef theDict)
{
  if (CFDictionaryContainsKey(theDict, key))
    CFDictionarySetValue(theDict, key, a2);
}

__n64 IOHIDEventGetDoubleValue(_QWORD *a1, unsigned int a2)
{
  return IOHIDEventGetDoubleValueWithOptions(a1, a2, 4026531840);
}

uint64_t _Xio_hideventsystem_release_notification(uint64_t result, uint64_t a2)
{
  CFIndex v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 56)
  {
    if (*(_BYTE *)(result + 39) == 1)
    {
      v3 = *(unsigned int *)(result + 40);
      if ((_DWORD)v3 == *(_DWORD *)(result + 52))
      {
        result = _io_hideventsystem_release_notification(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3);
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    v4 = -300;
  }
  else
  {
    v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t _io_hideventsystem_release_notification(unsigned int a1, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v4;
  const void *v5;
  const void *v6;
  const void *v7;
  CFTypeID v8;
  uint64_t System;

  v4 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  if (v4)
  {
    v5 = v4;
    v6 = IOMIGMachPortCacheCopy(a1);
    if (v6)
    {
      v7 = v6;
      v8 = CFGetTypeID(v6);
      if (v8 == IOHIDEventSystemConnectionGetTypeID())
      {
        System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v7);
        if (System)
          _IOHIDEventSystemRemoveNotificationForConnection(System, (uint64_t)v7, v5);
      }
      CFRelease(v5);
    }
    else
    {
      v7 = v5;
    }
    CFRelease(v7);
  }
  return 0;
}

uint64_t _IOHIDEventSystemRemoveNotificationForConnection(uint64_t a1, uint64_t a2, const void *a3)
{
  const void *v6;

  os_unfair_recursive_lock_lock_with_options();
  v6 = _IOHIDEventSystemConnectionCopyNotification(a2, a3);
  _IOHIDEventSystemConnectionRemoveNotification(a2, a3);
  if (v6)
  {
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), v6);
    CFRelease(v6);
  }
  return os_unfair_recursive_lock_unlock();
}

void _IOHIDEventSystemConnectionRemoveNotification(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  OSQueueHead *Value;
  _QWORD v6[7];

  v4 = (os_unfair_lock_s *)(a1 + 268);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  Value = (OSQueueHead *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  os_unfair_lock_unlock(v4);
  if (Value)
  {
    CFRetain(Value);
    CFRetain(a2);
    CFRetain((CFTypeRef)a1);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = ___IOHIDEventSystemConnectionRemoveNotification_block_invoke;
    v6[3] = &__block_descriptor_tmp_22_0;
    v6[4] = a1;
    v6[5] = a2;
    v6[6] = Value;
    IOHIDNotificationInvalidate(Value, v6);
  }
}

const void *_IOHIDEventSystemConnectionCopyNotification(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  const void *Value;
  const void *v6;

  v4 = (os_unfair_lock_s *)(a1 + 268);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  v6 = Value;
  if (Value)
    CFRetain(Value);
  os_unfair_lock_unlock(v4);
  return v6;
}

uint64_t IOHIDEventSystemClientCreateWithType(const __CFAllocator *a1, int a2, const __CFDictionary *a3)
{
  uint64_t v6;
  uint64_t Instance;
  const __CFUUID *v8;
  const __CFUUID *v9;
  CFMutableDictionaryRef v10;
  CFMutableSetRef Mutable;
  CFMutableDictionaryRef v12;
  CFMutableDictionaryRef v13;
  CFMutableDictionaryRef v14;
  const __CFDictionary *Copy;
  uint64_t v16;
  const char *dli_fname;
  char *v18;
  const char *v19;
  const char *dli_sname;
  void *v21;
  CFStringRef v22;
  NSObject *v23;
  Dl_info v25;
  CFDictionaryValueCallBacks valueCallBacks;
  void *v27[4];

  v27[3] = *(void **)MEMORY[0x1E0C80C00];
  v6 = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    v6 = __kIOHIDEventSystemClientTypeID;
  }
  Instance = _IOHIDObjectCreateInstance((uint64_t)a1, v6, 0x1F8uLL);
  if (Instance)
  {
    v8 = CFUUIDCreate(a1);
    if (v8)
    {
      v9 = v8;
      *(_QWORD *)(Instance + 440) = CFUUIDCreateString(a1, v8);
      CFRelease(v9);
    }
    valueCallBacks.equal = 0;
    *(_OWORD *)&valueCallBacks.version = xmmword_1E2002998;
    *(_OWORD *)&valueCallBacks.release = *(_OWORD *)&off_1E20029A8;
    *(_QWORD *)(Instance + 24) = 0;
    *(_QWORD *)(Instance + 160) = 0;
    v10 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], &valueCallBacks);
    *(_QWORD *)(Instance + 88) = v10;
    if (!v10)
      goto LABEL_37;
    Mutable = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
    *(_QWORD *)(Instance + 112) = Mutable;
    if (!Mutable)
      goto LABEL_37;
    v12 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(Instance + 96) = v12;
    if (!v12)
      goto LABEL_37;
    v13 = CFDictionaryCreateMutable(a1, 0, 0, MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(Instance + 104) = v13;
    if (!v13)
      goto LABEL_37;
    v14 = CFDictionaryCreateMutable(a1, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(Instance + 128) = v14;
    if (!v14)
      goto LABEL_37;
    if (a3 != (const __CFDictionary *)1635017576 && a3)
    {
      Copy = CFDictionaryCreateCopy(a1, a3);
      *(_QWORD *)(Instance + 416) = Copy;
      if (Copy)
        *(_BYTE *)(Instance + 448) = CFDictionaryGetValue(Copy, CFSTR("HighFrequency")) == (const void *)*MEMORY[0x1E0C9AE50];
    }
    else
    {
      *(_QWORD *)(Instance + 416) = 0;
    }
    *(_DWORD *)(Instance + 424) = a2;
    memset(v27, 0, 24);
    memset(&v25, 0, sizeof(v25));
    backtrace(v27, 3);
    if (a3 == (const __CFDictionary *)1635017576)
      v16 = 2;
    else
      v16 = 1;
    if (!dladdr(v27[v16], &v25))
    {
      if (*(_QWORD *)(Instance + 432))
        goto LABEL_33;
LABEL_32:
      *(_QWORD *)(Instance + 432) = CFSTR("***UNKOWN***");
      CFRetain(CFSTR("***UNKOWN***"));
LABEL_33:
      v23 = dispatch_queue_create("hideventsystemclient.default.queue", 0);
      *(_QWORD *)(Instance + 488) = v23;
      if (v23)
      {
        dispatch_set_context(v23, (void *)Instance);
        dispatch_set_finalizer_f(*(dispatch_object_t *)(Instance + 488), (dispatch_function_t)__IOHIDEventSystemClientFinalizeStateHandler);
        _IOHIDObjectInternalRetain((const void *)Instance);
        *(_QWORD *)(Instance + 456) = os_state_add_handler();
        __IOHIDEventSystemClientRefresh(Instance, 0);
        return Instance;
      }
LABEL_37:
      CFRelease((CFTypeRef)Instance);
      return 0;
    }
    dli_fname = v25.dli_fname;
    if (v25.dli_fname)
    {
      v18 = strrchr((char *)v25.dli_fname, 47);
      if (v18)
        v19 = v18 + 1;
      else
        v19 = dli_fname;
      dli_sname = v25.dli_sname;
      if (!v25.dli_sname)
      {
        v21 = (void *)((_BYTE *)v27[v16] - (char *)v25.dli_fbase);
        dli_sname = v19;
        goto LABEL_31;
      }
    }
    else
    {
      dli_sname = v25.dli_sname;
      if (!v25.dli_sname)
      {
        v21 = v27[v16];
        dli_sname = "0x0";
        v19 = "???";
LABEL_31:
        v22 = CFStringCreateWithFormat(a1, 0, CFSTR("%s: %s + %lu"), v19, dli_sname, v21);
        *(_QWORD *)(Instance + 432) = v22;
        if (v22)
          goto LABEL_33;
        goto LABEL_32;
      }
      v19 = "???";
    }
    v21 = (void *)((_BYTE *)v27[v16] - (char *)v25.dli_saddr);
    goto LABEL_31;
  }
  return Instance;
}

void __IOHIDNotificationExtFinalize(OSQueueHead *a1)
{
  void (*opaque1)(uint64_t, void *, OSQueueHead *);
  _QWORD v3[5];

  opaque1 = (void (*)(uint64_t, void *, OSQueueHead *))a1[3].opaque1;
  if (opaque1)
    opaque1(a1[3].opaque2, a1[4].opaque1, a1);
  _IOHIDObjectInternalRetain(a1);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ____IOHIDNotificationExtFinalize_block_invoke;
  v3[3] = &__block_descriptor_tmp_2;
  v3[4] = a1;
  IOHIDNotificationInvalidate(a1, v3);
}

void IOHIDNotificationInvalidate(OSQueueHead *a1, const void *a2)
{
  const __CFAllocator *v4;
  void *v5;
  void *v6;
  unsigned int *p_opaque2;
  unsigned int v8;
  dispatch_semaphore_t v9;
  NSObject *v10;
  _QWORD v11[5];
  uint64_t v12;
  _OWORD v13[5];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = CFGetAllocator(a1);
    v5 = CFAllocatorAllocate(v4, 16, 0);
    if (!v5)
      IOHIDNotificationInvalidate_cold_2(&v12, v13);
    v6 = v5;
    *((_QWORD *)v5 + 1) = _Block_copy(a2);
    OSAtomicEnqueue(a1 + 5, v6, 0);
    p_opaque2 = (unsigned int *)&a1[4].opaque2;
    do
      v8 = __ldaxr(p_opaque2);
    while (__stlxr(v8 | 0x80000000, p_opaque2));
    if ((v8 & 0x7FFFFFFF) == 0)
      __IOHIDNotificationInvalidateCompletion(a1);
  }
  else
  {
    v9 = dispatch_semaphore_create(0);
    if (!v9)
      IOHIDNotificationInvalidate_cold_1(&v12, v13);
    v10 = v9;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = __IOHIDNotificationInvalidate_block_invoke;
    v11[3] = &__block_descriptor_tmp_12;
    v11[4] = v9;
    IOHIDNotificationInvalidate(a1, v11);
    dispatch_semaphore_wait(v10, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v10);
  }
}

const void **__IOHIDNotificationInvalidateCompletion(OSQueueHead *a1)
{
  const __CFAllocator *v2;
  OSQueueHead *v3;
  const void **result;
  const void **v5;

  v2 = CFGetAllocator(a1);
  v3 = a1 + 5;
  result = (const void **)OSAtomicDequeue(v3, 0);
  if (result)
  {
    v5 = result;
    do
    {
      (*((void (**)(void))v5[1] + 2))();
      _Block_release(v5[1]);
      CFAllocatorDeallocate(v2, v5);
      result = (const void **)OSAtomicDequeue(v3, 0);
      v5 = result;
    }
    while (result);
  }
  return result;
}

const void *_IOHIDObjectInternalRetain(const void *a1)
{
  uint64_t ClassWithTypeID;

  CFGetTypeID(a1);
  ClassWithTypeID = _CFRuntimeGetClassWithTypeID();
  if (ClassWithTypeID)
    (*(void (**)(uint64_t, const void *))(ClassWithTypeID + 96))(1, a1);
  return a1;
}

uint64_t _IOHIDObjectRetainCount(uint64_t a1, unsigned int *cf, int a3)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v7;
  unsigned int v8;
  uint64_t ClassWithTypeID;
  uint64_t v11;
  void (*v12)(unsigned int *);
  CFAllocatorRef v13;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  uint64_t v16;
  _OWORD v17[5];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = cf + 5;
  v4 = 5;
  if (!a3)
  {
    v4 = 4;
    v3 = cf + 4;
  }
  if (a1 == 1)
  {
    do
      v8 = __ldaxr(v3);
    while (__stlxr(v8 + 1, v3));
    if (v8 == -1)
      _IOHIDObjectRetainCount_cold_1(&v16, v17);
  }
  else
  {
    v5 = cf;
    if (!a1)
      return atomic_load(&cf[v4]);
    if (a1 == -1)
    {
      do
        v7 = __ldaxr(v3);
      while (__stlxr(v7 - 1, v3));
      if (v7 == 1)
      {
        CFGetTypeID(cf);
        ClassWithTypeID = _CFRuntimeGetClassWithTypeID();
        v11 = 104;
        if (!a3)
          v11 = 32;
        v12 = *(void (**)(unsigned int *))(ClassWithTypeID + v11);
        if (v12)
          v12(v5);
        if (a3)
        {
          v13 = CFGetAllocator(v5);
          v14 = v13;
          if ((CFAllocatorRef)*MEMORY[0x1E0C9AE30] != v13)
          {
            if (v13 && (CFAllocatorRef)*MEMORY[0x1E0C9AE00] != v13
              || (v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30], v15 != CFAllocatorGetDefault()))
            {
              v5 -= 4;
            }
          }
          CFAllocatorDeallocate(v14, v5);
        }
        else
        {
          _IOHIDObjectInternalRelease(v5);
        }
      }
      else if (!v7)
      {
        _IOHIDObjectRetainCount_cold_2(&v16, v17);
      }
    }
  }
  return 0;
}

uint64_t _IOHIDObjectIntRetainCount(uint64_t a1, unsigned int *a2)
{
  return _IOHIDObjectRetainCount(a1, a2, 1);
}

uint64_t _IOHIDObjectInternalRelease(const void *a1)
{
  uint64_t result;

  CFGetTypeID(a1);
  result = _CFRuntimeGetClassWithTypeID();
  if (result)
    return (*(uint64_t (**)(uint64_t, const void *))(result + 96))(-1, a1);
  return result;
}

void __IOHIDEventSystemClientRefresh(uint64_t a1, char a2)
{
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  pid_t v6;
  CFStringRef v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  ipc_space_t *v11;
  kern_return_t v12;
  kern_return_t v13;
  mach_error_t v14;
  const __CFData *v15;
  const __CFData *v16;
  const UInt8 *BytePtr;
  int Length;
  const __CFData *v19;
  const __CFData *v20;
  const __CFString *v21;
  const UInt8 *v22;
  ipc_space_t *v23;
  mach_port_name_t v24;
  pid_t v25;
  unsigned int Port;
  int v27;
  mach_port_t v28;
  kern_return_t v29;
  mach_error_t v30;
  const __CFData *v31;
  const __CFArray *Copy;
  const __CFArray *v33;
  kern_return_t v34;
  NSObject *v35;
  const __CFDictionary *v36;
  const __CFDictionary *v37;
  __CFRunLoop *v38;
  const __CFString *v39;
  char v40;
  const __CFAllocator *v41;
  const __CFDictionary *v42;
  const __CFDictionary *v43;
  const __CFNumber *v44;
  const __CFNumber *v45;
  CFTypeID v46;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  char v51;
  __CFDictionary *v52;
  const __CFData *v53;
  const __CFData *cf;
  mach_port_name_t tn[2];
  _OWORD v56[2];
  mach_port_name_t v57;
  mach_port_t special_port[2];
  char buffer[1024];
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)special_port = 0;
  v57 = 0;
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 32))
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    memset(v56, 0, sizeof(v56));
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v6 = getpid();
      if (proc_name(v6, buffer, 0x400u))
        v7 = CFStringCreateWithCString(v4, buffer, 0);
      else
        v7 = 0;
      v8 = *(const void **)(a1 + 432);
      if (v8)
        CFDictionarySetValue(Mutable, CFSTR("caller"), v8);
      if (v7)
        CFDictionarySetValue(Mutable, CFSTR("procName"), v7);
      v9 = *(const void **)(a1 + 440);
      if (v9)
        CFDictionarySetValue(Mutable, CFSTR("UUID"), v9);
    }
    else
    {
      v7 = 0;
    }
    __IOHIDEventSystemClientInitReplyPort((uint64_t *)a1);
    v10 = *(_QWORD *)(a1 + 40);
    os_unfair_recursive_lock_unlock();
    if (v10)
    {
      v11 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
      if (!task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port[1]))
      {
        if (xpc_user_sessions_enabled())
        {
          tn[1] = 0;
          xpc_user_sessions_get_foreground_uid();
          v34 = bootstrap_look_up_per_user();
          if (v34)
          {
            v35 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              __IOHIDEventSystemClientRefresh_cold_6(v34, v35);
          }
        }
        v12 = bootstrap_look_up2();
        v13 = mach_port_deallocate(*v11, special_port[1]);
        if (v12)
        {
          v47 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            __IOHIDEventSystemClientRefresh_cold_5(v12, v47);
        }
        else
        {
          v14 = v13;
          if (v13)
          {
            v48 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
              __IOHIDEventSystemClientRefresh_cold_4(v14, v48);
          }
          else
          {
            v51 = a2;
            v15 = (const __CFData *)_IOHIDCreateBinaryData(v4, Mutable);
            v53 = v15;
            if (v15)
            {
              v16 = v15;
              BytePtr = CFDataGetBytePtr(v15);
              Length = CFDataGetLength(v16);
            }
            else
            {
              BytePtr = 0;
              Length = 0;
            }
            v52 = Mutable;
            v19 = (const __CFData *)_IOHIDCreateBinaryData(v4, *(const void **)(a1 + 416));
            v20 = v19;
            cf = v19;
            v21 = v7;
            if (v19)
            {
              v22 = CFDataGetBytePtr(v19);
              LODWORD(v20) = CFDataGetLength(v20);
            }
            else
            {
              v22 = 0;
            }
            tn[0] = 0;
            v23 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
            v24 = *MEMORY[0x1E0C83DA0];
            v25 = getpid();
            if (task_name_for_pid(v24, v25, tn))
              __IOHIDEventSystemClientRefresh_cold_3();
            os_unfair_recursive_lock_lock_with_options();
            Port = IOMIGMachPortGetPort(*(_QWORD *)(a1 + 40));
            os_unfair_recursive_lock_unlock();
            v27 = io_hideventsystem_open(v57, tn[0], *(_DWORD *)(a1 + 424), (uint64_t)BytePtr, Length, (uint64_t)v22, (int)v20, Port, special_port, v56);
            v28 = special_port[0];
            v29 = mach_port_deallocate(*v23, v57);
            if (v27 || !v28)
            {
              v49 = _IOHIDLogCategory(0xDu);
              v7 = v21;
              Mutable = v52;
              v31 = v53;
              if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
                __IOHIDEventSystemClientRefresh_cold_1();
            }
            else
            {
              v30 = v29;
              v31 = v53;
              if (v29)
              {
                v50 = _IOHIDLogCategory(0xDu);
                v7 = v21;
                Mutable = v52;
                if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  __IOHIDEventSystemClientRefresh_cold_2(v30, v50);
              }
              else
              {
                os_unfair_recursive_lock_lock_with_options();
                *(_DWORD *)(a1 + 32) = special_port[0];
                v7 = v21;
                if ((v51 & 1) != 0)
                {
                  Copy = 0;
                  Mutable = v52;
                }
                else
                {
                  v33 = *(const __CFArray **)(a1 + 80);
                  Mutable = v52;
                  if (v33)
                    Copy = CFArrayCreateCopy(v4, v33);
                  else
                    Copy = 0;
                  IOHIDEventSystemClientSetMatchingMultiple(a1, Copy);
                }
                if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 104)))
                {
                  v36 = CFDictionaryCreateCopy(v4, *(CFDictionaryRef *)(a1 + 104));
                  v37 = v36;
                  if (v36)
                    CFDictionaryApplyFunction(v36, (CFDictionaryApplierFunction)__VirtualServiceNotifier, (void *)a1);
                  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 104));
                }
                else
                {
                  v37 = 0;
                }
                if ((*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400))
                  && (__IOHIDEventSystemClientSetupAsyncSupport(a1), (v38 = *(__CFRunLoop **)(a1 + 384)) != 0)
                  && (v39 = *(const __CFString **)(a1 + 392)) != 0)
                {
                  IOHIDEventSystemClientScheduleWithRunLoop((CFRunLoopSourceRef)a1, v38, v39);
                }
                else if (*(_QWORD *)(a1 + 400))
                {
                  v40 = atomic_load((unsigned int *)(a1 + 312));
                  if ((v40 & 2) == 0)
                    IOMIGMachPortScheduleWithDispatchQueue(*(_QWORD *)(a1 + 40), *(NSObject **)(a1 + 400));
                }
                os_unfair_recursive_lock_unlock();
                __IOHIDEventSystemClientStartQueue(a1);
                __IOHIDEventSystemClientStartFilter(a1);
                os_unfair_recursive_lock_lock_with_options();
                if (*(_QWORD *)(a1 + 360) || *(_QWORD *)(a1 + 352))
                  io_hideventsystem_register_record_service_changed_notification(*(_DWORD *)(a1 + 32));
                if (*(_QWORD *)(a1 + 328) || *(_QWORD *)(a1 + 320))
                  io_hideventsystem_register_record_client_changed_notification(*(_DWORD *)(a1 + 32));
                os_unfair_recursive_lock_unlock();
                os_unfair_recursive_lock_lock_with_options();
                v41 = CFGetAllocator((CFTypeRef)a1);
                v42 = CFDictionaryCreateCopy(v41, *(CFDictionaryRef *)(a1 + 128));
                os_unfair_recursive_lock_unlock();
                if (v42)
                {
                  CFDictionaryApplyFunction(v42, (CFDictionaryApplierFunction)__IOHIDEventSystemClientConnectionPropertyFunction, (void *)a1);
                  CFRelease(v42);
                }
                os_unfair_recursive_lock_lock_with_options();
                v43 = *(const __CFDictionary **)(a1 + 120);
                if (v43)
                  CFDictionaryApplyFunction(v43, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRegisterPropertyCallbackRegisterFunction, (void *)a1);
                os_unfair_recursive_lock_unlock();
                v44 = (const __CFNumber *)IOHIDEventSystemClientCopyProperty((IOHIDEventSystemClientRef)a1, CFSTR("HIDDebug"));
                if (v44)
                {
                  v45 = v44;
                  v46 = CFGetTypeID(v44);
                  if (v46 == CFNumberGetTypeID())
                    CFNumberGetValue(v45, kCFNumberSInt32Type, &gIOHIDDebugConfig);
                  CFRelease(v45);
                }
                if (v37)
                  CFRelease(v37);
                if (Copy)
                  CFRelease(Copy);
              }
            }
            if (v31)
              CFRelease(v31);
            if (cf)
              CFRelease(cf);
          }
        }
      }
    }
    if (Mutable)
      CFRelease(Mutable);
    if (v7)
      CFRelease(v7);
  }
}

uint64_t __IOHIDEventSystemClientStartQueue(uint64_t a1)
{
  BOOL v2;
  mach_port_t v3;
  NSObject *v4;

  os_unfair_recursive_lock_lock_with_options();
  v2 = 0;
  if (!*(_QWORD *)(a1 + 200))
    v2 = *(_QWORD *)(a1 + 208) == 0;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  v3 = *(_DWORD *)(a1 + 32);
  if (v3 && !v2 && (*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400)))
  {
    if (io_hideventsystem_queue_start(v3))
    {
      v4 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        __IOHIDEventSystemClientStartQueue_cold_1();
    }
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDEventSystemClientStartFilter(uint64_t a1)
{
  mach_port_t v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(_DWORD *)(a1 + 32);
  if (v2 && (*(_QWORD *)(a1 + 232) || *(_QWORD *)(a1 + 240)) && (*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400)))
    io_hideventsystem_register_event_filter(v2, *(_DWORD *)(a1 + 264));
  return os_unfair_recursive_lock_unlock();
}

void IOHIDEventSystemClientSetMatchingMultiple(uint64_t a1, const __CFArray *a2)
{
  const __CFAllocator *v4;
  const __CFDictionary *Copy;
  const void *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v11;
  const __CFAllocator *v12;
  const __CFDictionary *v13;
  void *value[3];

  value[2] = *(void **)MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFDictionaryRef *)(a1 + 96));
  v6 = *(const void **)(a1 + 80);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 80) = 0;
  }
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 112));
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 96));
  if (io_hideventsystem_clear_service_cache(*(_DWORD *)(a1 + 32)) == 268435459
    && !*(_QWORD *)(a1 + 384)
    && !*(_QWORD *)(a1 + 400))
  {
    __IOHIDEventSystemClientTerminationCallback();
    io_hideventsystem_clear_service_cache(*(_DWORD *)(a1 + 32));
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
  {
    os_unfair_recursive_lock_lock_with_options();
    *(_QWORD *)(a1 + 80) = CFArrayCreateCopy(v4, a2);
    os_unfair_recursive_lock_unlock();
    Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      v8 = Count;
      for (i = 0; i != v8; ++i)
      {
        value[0] = 0;
        ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        v11 = CFGetTypeID(ValueAtIndex);
        if (v11 == CFDictionaryGetTypeID())
        {
          __IOHIDEventSystemClientCacheMatchingServices(a1, ValueAtIndex, (const void **)value);
          if (value[0])
          {
            os_unfair_recursive_lock_lock_with_options();
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 112), value[0]);
            os_unfair_recursive_lock_unlock();
            CFRelease(value[0]);
          }
        }
      }
    }
  }
  else
  {
    value[0] = 0;
    __IOHIDEventSystemClientCacheMatchingServices(a1, 0, (const void **)value);
    if (value[0])
    {
      os_unfair_recursive_lock_lock_with_options();
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 112), value[0]);
      os_unfair_recursive_lock_unlock();
      CFRelease(value[0]);
    }
  }
  if (Copy)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__IOHIDEventSystemClientServiceReplaceCallback, *(void **)(a1 + 96));
    v12 = CFGetAllocator((CFTypeRef)a1);
    v13 = CFDictionaryCreateCopy(v12, *(CFDictionaryRef *)(a1 + 96));
    os_unfair_recursive_lock_unlock();
    value[0] = (void *)a1;
    value[1] = Copy;
    CFDictionaryApplyFunction(v13, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRefreshServiceCallback, value);
    CFRelease(v13);
    CFRelease(Copy);
  }
}

void __IOHIDEventSystemClientCacheMatchingServices(uint64_t a1, const void *a2, const void **a3)
{
  _QWORD *v6;
  _DWORD *v7;
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int v11;
  int v12;
  const __CFArray *v13;
  UInt8 *v14;
  mach_vm_size_t v15;
  CFTypeID TypeID;
  CFPropertyListRef v17;
  const void *v18;
  const __CFAllocator *v19;
  __CFDictionary *Mutable;
  __CFDictionary *v21;
  CFDictionaryRef Copy;
  _QWORD *v23;
  unsigned int v24;
  UInt8 *v25;
  _DWORD length[3];
  _QWORD v27[5];

  memset(length, 0, sizeof(length));
  v25 = 0;
  v24 = 0;
  if (a3)
    v6 = &length[1];
  else
    v6 = 0;
  if (a3)
    v7 = length;
  else
    v7 = 0;
  if (a2)
  {
    v8 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
    v9 = v8;
    if (v8)
    {
      BytePtr = CFDataGetBytePtr(v8);
      v11 = CFDataGetLength(v9);
    }
    else
    {
      BytePtr = 0;
      v11 = 0;
    }
  }
  else
  {
    BytePtr = 0;
    v11 = 0;
    v9 = 0;
  }
  os_unfair_recursive_lock_lock_with_options();
  v12 = io_hideventsystem_copy_matching_services(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, v6, v7, &v25, &v24);
  if (v12 == 268435459)
  {
    if (*(_QWORD *)(a1 + 384))
    {
      os_unfair_recursive_lock_unlock();
LABEL_17:
      v13 = 0;
      goto LABEL_18;
    }
    __IOHIDEventSystemClientTerminationCallback();
    v12 = io_hideventsystem_copy_matching_services(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, v6, v7, &v25, &v24);
  }
  os_unfair_recursive_lock_unlock();
  if (v12)
    goto LABEL_17;
  v14 = v25;
  v15 = v24;
  TypeID = CFArrayGetTypeID();
  v13 = (const __CFArray *)_IOHIDUnserializeAndVMDeallocWithTypeID(v14, v15, TypeID);
  v17 = _IOHIDUnserializeAndVMDealloc(*(UInt8 **)&length[1], length[0]);
  if (v17)
  {
    v18 = v17;
    if (a3)
    {
      v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v21 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("id"), v18);
        if (a2)
        {
          Copy = CFDictionaryCreateCopy(v19, (CFDictionaryRef)a2);
          CFDictionarySetValue(v21, CFSTR("matching"), Copy);
          CFRelease(Copy);
        }
        v23 = IOHIDNotificationCreate((uint64_t)v19, (uint64_t)__IOHIDEventSystemClientMatchNotifyRelease, a1, (uint64_t)v21, 0, 0, 0);
        *a3 = v23;
        if (v23)
        {
          os_unfair_recursive_lock_lock_with_options();
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 88), v18, *a3);
          os_unfair_recursive_lock_unlock();
        }
      }
    }
    CFRelease(v18);
  }
LABEL_18:
  if (v9)
    CFRelease(v9);
  if (v13)
  {
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 0x40000000;
    v27[2] = ____IOHIDEventSystemClientCacheServices_block_invoke;
    v27[3] = &__block_descriptor_tmp_93;
    v27[4] = a1;
    _IOHIDCFArrayApplyBlock(v13, v27);
    CFRelease(v13);
  }
}

uint64_t io_hideventsystem_copy_matching_services(mach_port_t a1, uint64_t a2, int a3, _QWORD *a4, _DWORD *a5, _QWORD *a6, _DWORD *a7)
{
  mach_port_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  mach_msg_header_t msg;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;

  msg.msgh_id = 0;
  v23 = 0;
  v24 = 0u;
  v25 = 0u;
  *(_OWORD *)&msg.msgh_size = 0u;
  v19 = 1;
  v20 = a2;
  v21 = 16777472;
  v22 = a3;
  v23 = *MEMORY[0x1E0C804E8];
  LODWORD(v24) = a3;
  special_reply_port = mig_get_special_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1117100000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3162115, 0x38u, 0x54u, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 70101)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v14 = 4294966996;
            if (HIDWORD(v20))
            {
              if (msg.msgh_remote_port)
                v14 = 4294966996;
              else
                v14 = HIDWORD(v20);
            }
          }
          else
          {
            v14 = 4294966996;
          }
          goto LABEL_29;
        }
        v14 = 4294966996;
        if (v19 == 2 && msg.msgh_size == 76 && !msg.msgh_remote_port && HIBYTE(v21) == 1 && BYTE3(v24) == 1)
        {
          v15 = v22;
          if (v22 == (_DWORD)v25)
          {
            v16 = DWORD1(v24);
            if (DWORD1(v24) == DWORD1(v25))
            {
              v14 = 0;
              *a4 = v20;
              *a5 = v15;
              *a6 = v23;
              *a7 = v16;
              return v14;
            }
          }
        }
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_29:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v14 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_29;
  }
  return v14;
}

uint64_t io_hideventsystem_clear_service_cache(mach_port_t a1)
{
  uint64_t v1;
  mach_msg_header_t msg;

  msg.msgh_size = 0;
  msg.msgh_bits = 19;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = 0;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1117300000000;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set(&msg);
  v1 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
  if ((v1 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    mach_msg_destroy(&msg);
  }
  return v1;
}

uint64_t __IOHIDServiceNotificationRelease(_QWORD *a1, uint64_t a2, const void *a3)
{
  __CFSet *v5;
  __CFSet *v6;
  uint64_t result;
  uint64_t v8;
  _OWORD v9[5];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  ++*(_DWORD *)a1[9];
  v5 = (__CFSet *)a1[14];
  if (v5)
    CFSetRemoveValue(v5, a3);
  v6 = (__CFSet *)a1[13];
  if (v6)
    CFSetRemoveValue(v6, a3);
  result = a1[9];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
  }
  return result;
}

uint64_t io_hideventsystem_open(int a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, unsigned int a8, _DWORD *a9, _OWORD *a10)
{
  mach_port_name_t special_reply_port;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  _BYTE msg[36];
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  _BYTE v21[44];
  uint64_t v22;

  *(_OWORD *)&msg[20] = 0u;
  *(_OWORD *)&v21[28] = 0u;
  v22 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[24] = 4;
  *(_DWORD *)&msg[28] = a2;
  v17 = 1245184;
  v18 = a4;
  v19 = 16777472;
  v20 = a5;
  *(_QWORD *)v21 = a6;
  *(_DWORD *)&v21[8] = 16777472;
  *(_DWORD *)&v21[12] = a7;
  *(_QWORD *)&v21[16] = a8;
  *(_DWORD *)&v21[24] = 1245184;
  *(_QWORD *)&v21[28] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&v21[36] = a3;
  *(_DWORD *)&v21[40] = a5;
  LODWORD(v22) = a7;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = -2147478253;
  *(_QWORD *)&msg[16] = 0x1117000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v12 = mach_msg((mach_msg_header_t *)msg, 53493763, 0x68u, 0x6Cu, special_reply_port, 0, 0);
  v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v12)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v13 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 70100)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            v13 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8])
                v13 = 4294966996;
              else
                v13 = *(unsigned int *)&msg[32];
            }
          }
          else
          {
            v13 = 4294966996;
          }
          goto LABEL_28;
        }
        v13 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 40 && !*(_DWORD *)&msg[8] && HIWORD(v17) << 16 == 1114112)
        {
          if ((_DWORD)v18 || HIDWORD(v18) < 0x20)
            return 4294966987;
          v13 = 0;
          *a9 = *(_DWORD *)&msg[28];
          v15 = *(_OWORD *)&v21[20];
          *a10 = *(_OWORD *)&v21[4];
          a10[1] = v15;
          return v13;
        }
      }
      else
      {
        v13 = 4294966995;
      }
LABEL_28:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v13 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)&msg[12]);
    goto LABEL_28;
  }
  return v13;
}

CFTypeRef IOHIDEventSystemClientCopyProperty(IOHIDEventSystemClientRef client, CFStringRef key)
{
  CFTypeRef result;
  const __CFData *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  int v7;
  int v8;
  BOOL v9;
  CFIndex length;
  UInt8 *bytes;

  result = 0;
  length = 0;
  bytes = 0;
  if (client && key)
  {
    v4 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], key);
    if (v4)
    {
      v5 = v4;
      BytePtr = CFDataGetBytePtr(v4);
      v7 = CFDataGetLength(v5);
      os_unfair_recursive_lock_lock_with_options();
      v8 = io_hideventsystem_copy_property(*((_DWORD *)client + 8), (uint64_t)BytePtr, v7, &bytes, (_DWORD *)&length + 1, &length);
      if (v8 == 268435459)
      {
        if (*((_QWORD *)client + 48))
        {
          v8 = 268435459;
        }
        else
        {
          v8 = 268435459;
          if (!*((_QWORD *)client + 50))
          {
            __IOHIDEventSystemClientTerminationCallback();
            v8 = io_hideventsystem_copy_property(*((_DWORD *)client + 8), (uint64_t)BytePtr, v7, &bytes, (_DWORD *)&length + 1, &length);
          }
        }
      }
      os_unfair_recursive_lock_unlock();
      CFRelease(v5);
      v9 = (_DWORD)length != 0;
    }
    else
    {
      v9 = 0;
      v8 = 0;
    }
    result = 0;
    if (!v8 && !v9)
      return _IOHIDUnserializeAndVMDealloc(bytes, HIDWORD(length));
  }
  return result;
}

uint64_t io_hideventsystem_copy_property(mach_port_t a1, uint64_t a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6)
{
  mach_port_t special_reply_port;
  uint64_t v11;
  uint64_t v12;
  int v13;
  mach_msg_header_t msg;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  __int128 v21;

  msg.msgh_id = 0;
  v20 = 0;
  v21 = 0u;
  *(_OWORD *)&msg.msgh_size = 0u;
  v16 = 1;
  v17 = a2;
  v18 = 16777472;
  v19 = a3;
  v20 = *MEMORY[0x1E0C804E8];
  LODWORD(v21) = a3;
  special_reply_port = mig_get_special_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1117E00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3162115, 0x38u, 0x44u, special_reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v11)
    {
      if (msg.msgh_id == 71)
      {
        v12 = 4294966988;
      }
      else if (msg.msgh_id == 70114)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v12 = 4294966996;
            if (HIDWORD(v17))
            {
              if (msg.msgh_remote_port)
                v12 = 4294966996;
              else
                v12 = HIDWORD(v17);
            }
          }
          else
          {
            v12 = 4294966996;
          }
          goto LABEL_27;
        }
        v12 = 4294966996;
        if (v16 == 1 && msg.msgh_size == 60 && !msg.msgh_remote_port && HIBYTE(v18) == 1)
        {
          v13 = v19;
          if (v19 == (_DWORD)v21)
          {
            v12 = 0;
            *a4 = v17;
            *a5 = v13;
            *a6 = DWORD1(v21);
            return v12;
          }
        }
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_27:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v12 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_27;
  }
  return v12;
}

uint64_t _IOHIDEventSystemConnectionCreate(const __CFAllocator *a1, uint64_t a2, unsigned int a3, const __CFDictionary *a4, const __CFDictionary *a5, uint64_t a6, mach_port_name_t a7, mach_port_name_t a8, _OWORD *a9)
{
  HIDConnection *Private;
  uint64_t v18;
  ipc_space_t *v19;
  _QWORD *v20;
  __int128 v21;
  __int128 v22;
  void *v23;
  xpc_object_t empty;
  void *v25;
  uint64_t v26;
  _DWORD *v27;
  _BYTE *v28;
  xpc_object_t value;
  xpc_object_t v30;
  ipc_space_t *v31;
  char v32;
  char v33;
  char v34;
  char v35;
  char v36;
  char v37;
  char v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  CFStringRef Copy;
  uint64_t v43;
  const __CFDictionary *v44;
  uint64_t v45;
  const char *CStringPtr;
  CFStringRef v47;
  CFStringEncoding SystemEncoding;
  CFDictionaryRef v49;
  const __CFString *v50;
  NSObject *v51;
  CFMutableDictionaryRef Mutable;
  CFMutableSetRef v53;
  CFMutableDictionaryRef v54;
  void *v55;
  int v56;
  CFStringEncoding v57;
  const char *v58;
  NSObject *v59;
  const __CFArray *v60;
  const __CFArray *v61;
  CFIndex v62;
  __CFBundle *ValueAtIndex;
  CFAllocatorRef v64;
  CFTypeRef v65;
  uint64_t v66;
  NSObject *v67;
  uint64_t v68;
  NSObject *v70;
  mach_port_name_t v71;
  uint64_t v72;
  const __CFDictionary *v73;
  uint64_t v74;
  _QWORD v75[5];
  __int128 v76;
  __int128 v77;
  mach_port_t previous;
  mach_port_name_t name;
  _BYTE applier[24];
  void *v81;
  xpc_object_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  name = 0;
  previous = 0;
  Private = _IOHIDEventSystemConnectionCreatePrivate((uint64_t)a1);
  v18 = (uint64_t)Private;
  v19 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (a3 > 4 || !Private)
  {
    if (a3 >= 5 && (v70 = _IOHIDLog(), os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)))
    {
      _IOHIDEventSystemConnectionCreate_cold_1(a3, a6, v70);
      if (!a7)
      {
LABEL_88:
        if (a8)
          mach_port_deallocate(*v19, a8);
        v50 = 0;
        v71 = 0;
        if (!v18)
          goto LABEL_58;
        goto LABEL_57;
      }
    }
    else if (!a7)
    {
      goto LABEL_88;
    }
    mach_port_deallocate(*v19, a7);
    goto LABEL_88;
  }
  Private->_connection.reply_port = a8;
  Private->_connection.task_name_port = a7;
  mach_port_allocate(*v19, 1u, &name);
  if (mach_port_request_notification(*v19, name, 70, 1u, name, 0x15u, &previous)
    || mach_port_insert_right(*v19, name, name, 0x14u))
  {
    v50 = 0;
    v71 = 0;
    goto LABEL_57;
  }
  v71 = name;
  v20 = IOMIGMachPortCreate(a1, 76, name);
  *(_QWORD *)(v18 + 32) = v20;
  if (!v20)
    goto LABEL_83;
  v74 = a2;
  name = 0;
  *(_DWORD *)(v18 + 448) = 0;
  v21 = a9[1];
  *(_OWORD *)(v18 + 196) = *a9;
  *(_OWORD *)(v18 + 212) = v21;
  v22 = a9[1];
  v76 = *a9;
  v77 = v22;
  v23 = (void *)xpc_copy_entitlement_for_token();
  empty = xpc_dictionary_create_empty();
  v25 = empty;
  if (v23)
  {
    *(_QWORD *)applier = MEMORY[0x1E0C809B0];
    *(_QWORD *)&applier[8] = 0x40000000;
    *(_QWORD *)&applier[16] = ____IOHIDEventSystemConnectionCreateConnectionEntitlements_block_invoke;
    v81 = &__block_descriptor_tmp_111;
    v82 = empty;
    xpc_dictionary_apply(v23, applier);
    xpc_release(v23);
  }
  *(_QWORD *)(v18 + 248) = v25;
  if (!v25)
  {
LABEL_83:
    v50 = 0;
    goto LABEL_57;
  }
  v73 = a5;
  v26 = *(_QWORD *)(v18 + 168);
  v27 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  if (!v27)
  {
    v50 = 0;
    *(_QWORD *)(v18 + 240) = 0;
    goto LABEL_57;
  }
  v28 = v27;
  v72 = a6;
  *v27 = 0;
  value = xpc_dictionary_get_value(v25, "com.apple.private.hid.client.admin");
  v30 = (xpc_object_t)MEMORY[0x1E0C81240];
  v31 = v19;
  if (value == (xpc_object_t)MEMORY[0x1E0C81240])
    v32 = 1;
  else
    v32 = __IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.admin.internal", v26);
  *v28 = *v28 & 0xFE | v32;
  v33 = 2;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.event-monitor") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.event-monitor.internal", v26))v33 = 2;
    else
      v33 = 0;
  }
  *v28 = *v28 & 0xFD | v33;
  v34 = 4;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.event-filter") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.event-filter.internal", v26))v34 = 4;
    else
      v34 = 0;
  }
  *v28 = *v28 & 0xFB | v34;
  v35 = 8;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.event-dispatch") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.event-dispatch.internal", v26))v35 = 8;
    else
      v35 = 0;
  }
  *v28 = *v28 & 0xF7 | v35;
  v36 = 16;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.service-protected") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.service-protected.internal", v26))v36 = 16;
    else
      v36 = 0;
  }
  *v28 = *v28 & 0xEF | v36;
  v37 = 32;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.motion-event-privileged") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.motion-event-privileged.internal", v26))v37 = 32;
    else
      v37 = 0;
  }
  *v28 = *v28 & 0xDF | v37;
  if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.debug-tool.internal", v26))v38 = 64;
  else
    v38 = 0;
  *v28 = *v28 & 0xBF | v38;
  *(_QWORD *)(v18 + 240) = v28;
  if (a4)
  {
    v39 = (const __CFString *)CFDictionaryGetValue(a4, CFSTR("caller"));
    v40 = (const __CFString *)CFDictionaryGetValue(a4, CFSTR("procName"));
    v41 = (const __CFString *)CFDictionaryGetValue(a4, CFSTR("UUID"));
    v19 = v31;
    if (v39)
      Copy = CFStringCreateCopy(a1, v39);
    else
      Copy = 0;
    v43 = v72;
    *(_QWORD *)(v18 + 144) = Copy;
    v45 = v74;
    if (v40)
      v47 = CFStringCreateCopy(a1, v40);
    else
      v47 = 0;
    v44 = v73;
    *(_QWORD *)(v18 + 152) = v47;
    if (v41)
      v41 = CFStringCreateCopy(a1, v41);
    *(_QWORD *)(v18 + 160) = v41;
    if (v41)
      goto LABEL_48;
  }
  else
  {
    v41 = *(const __CFString **)(v18 + 160);
    v19 = v31;
    v43 = v72;
    v44 = v73;
    v45 = v74;
    if (v41)
    {
LABEL_48:
      SystemEncoding = CFStringGetSystemEncoding();
      CStringPtr = CFStringGetCStringPtr(v41, SystemEncoding);
      goto LABEL_49;
    }
  }
  CStringPtr = 0;
LABEL_49:
  *(_QWORD *)(v18 + 168) = CStringPtr;
  *(_QWORD *)(v18 + 8) = v45;
  *(_DWORD *)(v18 + 176) = a3;
  if (v44)
    v49 = CFDictionaryCreateCopy(a1, v44);
  else
    v49 = 0;
  *(_QWORD *)(v18 + 184) = v49;
  *(_DWORD *)(v18 + 88) = v43;
  *(_QWORD *)(v18 + 280) = -1;
  *(_DWORD *)(v18 + 228) = 0;
  *(_DWORD *)(v18 + 232) = 0;
  *(_DWORD *)(v18 + 268) = 0;
  *(_DWORD *)(v18 + 256) = (**(_BYTE **)(v18 + 240) & 0x13) == 0;
  v50 = CFStringCreateWithFormat(a1, 0, CFSTR("IOHIDConnection process:%@ pid:%d uuid:%@ caller:%@"), *(_QWORD *)(v18 + 152), v43, *(_QWORD *)(v18 + 160), *(_QWORD *)(v18 + 144));
  if (!v50)
    goto LABEL_57;
  if (!a3 && (**(_BYTE **)(v18 + 240) & 1) == 0)
  {
    v51 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemConnectionCreate_cold_2();
    goto LABEL_57;
  }
  IOMIGMachPortRegisterTerminationCallback(*(_QWORD *)(v18 + 32), (uint64_t)__IOHIDEventSystemConnectionPortTerminateCallback, v18);
  IOMIGMachPortRegisterDemuxCallback(*(_QWORD *)(v18 + 32), (uint64_t)__IOHIDEventSystemConnectionPortDemuxCallback, v18);
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v18 + 16) = Mutable;
  if (!Mutable)
    goto LABEL_57;
  v53 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v18 + 80) = v53;
  if (!v53)
    goto LABEL_57;
  v54 = CFDictionaryCreateMutable(a1, 0, 0, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v18 + 272) = v54;
  if (!v54)
    goto LABEL_57;
  v55 = malloc_type_calloc(0x2BuLL, 8uLL, 0x100004000313F17uLL);
  *(_QWORD *)(v18 + 392) = v55;
  if (!v55)
    goto LABEL_57;
  CFRetain(*(CFTypeRef *)(v18 + 8));
  v56 = _os_feature_enabled_impl();
  v57 = CFStringGetSystemEncoding();
  v58 = CFStringGetCStringPtr(v50, v57);
  v59 = v56
      ? hid_workloop_create(v58, 63)
      : hid_dispatch_queue_create(v58, 0, kIOHIDServerConnectionRootQueue, 0, 0, 0);
  *(_QWORD *)(v18 + 96) = v59;
  if (!v59 || (*(_DWORD *)(v18 + 400) = 2, (v60 = (const __CFArray *)_IOHIDLoadConnectionPluginBundles()) == 0))
  {
LABEL_57:
    CFRelease((CFTypeRef)v18);
LABEL_58:
    if (name)
      mach_port_mod_refs(*v19, name, 1u, -1);
    if (v71)
      mach_port_deallocate(*v19, v71);
    v18 = 0;
    goto LABEL_79;
  }
  v61 = v60;
  if (CFArrayGetCount(v60) < 1)
  {
LABEL_80:
    CFRelease(v50);
    return v18;
  }
  v62 = 0;
  while (1)
  {
    ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v61, v62);
    v64 = CFGetAllocator((CFTypeRef)v18);
    v65 = IOHIDConnectionFilterCreate((uint64_t)v64, ValueAtIndex, v18);
    if (v65)
      break;
    if (++v62 >= CFArrayGetCount(v61))
      goto LABEL_79;
  }
  v66 = (uint64_t)v65;
  CFRetain((CFTypeRef)v18);
  v75[0] = MEMORY[0x1E0C809B0];
  v75[1] = 0x40000000;
  v75[2] = ___IOHIDEventSystemConnectionCreate_block_invoke;
  v75[3] = &__block_descriptor_tmp_22;
  v75[4] = v18;
  IOHIDConnectionFilterSetCancelHandler(v66, (uint64_t)v75);
  *(_QWORD *)(v18 + 440) = v66;
  v67 = _IOHIDLogCategory(9u);
  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
  {
    v68 = *(_QWORD *)(v18 + 168);
    *(_DWORD *)applier = 136315394;
    *(_QWORD *)&applier[4] = v68;
    *(_WORD *)&applier[12] = 2112;
    *(_QWORD *)&applier[14] = v66;
    _os_log_impl(&dword_18AAAF000, v67, OS_LOG_TYPE_DEFAULT, "%s: Connection filter added:%@", applier, 0x16u);
  }
LABEL_79:
  if (v50)
    goto LABEL_80;
  return v18;
}

uint64_t __IOHIDValidateInternalBuildEntitlement(void *a1, const char *a2, uint64_t a3)
{
  unsigned int v6;
  xpc_object_t value;
  BOOL v8;
  uint64_t result;
  NSObject *v10;
  _BOOL4 v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = os_variant_allows_internal_security_policies();
  value = xpc_dictionary_get_value(a1, a2);
  v8 = value == (xpc_object_t)MEMORY[0x1E0C81240];
  if (value == (xpc_object_t)MEMORY[0x1E0C81240])
    result = v6;
  else
    result = 0;
  if (v8 && (v6 & 1) == 0)
  {
    v10 = _IOHIDLogCategory(9u);
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v11)
    {
      v12 = 136315394;
      v13 = a3;
      v14 = 2080;
      v15 = a2;
      _os_log_impl(&dword_18AAAF000, v10, OS_LOG_TYPE_DEFAULT, "[%s] Process has entitlement %s on Non-Internal build", (uint8_t *)&v12, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t _io_hideventsystem_open(unsigned int a1, mach_port_name_t a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, mach_port_name_t a8, _DWORD *a9, _OWORD *a10)
{
  __int128 v18;
  CFTypeID TypeID;
  const __CFDictionary *v20;
  CFTypeID v21;
  const __CFDictionary *v22;
  CFMutableSetRef **v23;
  CFMutableSetRef **v24;
  CFTypeID v25;
  uint64_t v26;
  const __CFAllocator *v27;
  uint64_t v28;
  __int128 v29;
  const void *v30;
  unsigned int Port;
  int v32;
  audit_token_t atoken;
  pid_t pidp;

  pidp = -1;
  v18 = a10[1];
  *(_OWORD *)atoken.val = *a10;
  *(_OWORD *)&atoken.val[4] = v18;
  audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
  TypeID = CFDictionaryGetTypeID();
  v20 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  v21 = CFDictionaryGetTypeID();
  v22 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a6, a7, v21);
  v23 = (CFMutableSetRef **)IOMIGMachPortCacheCopy(a1);
  v24 = v23;
  if (!v23)
    goto LABEL_16;
  v25 = CFGetTypeID(v23);
  v26 = __kIOHIDEventServerTypeID;
  if (!__kIOHIDEventServerTypeID)
  {
    pthread_once(&__serviceTypeInit, (void (*)(void))__IOHIDEventServerRegister);
    v26 = __kIOHIDEventServerTypeID;
  }
  if (v25 == v26)
  {
    v27 = CFGetAllocator(v24);
    v28 = (uint64_t)v24[2];
    v29 = a10[1];
    *(_OWORD *)atoken.val = *a10;
    *(_OWORD *)&atoken.val[4] = v29;
    v30 = (const void *)_IOHIDEventSystemConnectionCreate(v27, v28, a3, v20, v22, pidp, a2, a8, &atoken);
    if (v30)
    {
      _IOHIDEventSystemAddConnection(v24[2], v30);
      Port = _IOHIDEventSystemConnectionGetPort((uint64_t)v30);
      IOMIGMachPortCacheAdd(Port, v30);
      _IOHIDEventSystemConnectionRegisterTerminationCallback((uint64_t)v30, (uint64_t)__IOHIDEventSystemConnectionDiedCallback, (uint64_t)v24);
      _IOHIDEventSystemConnectionRegisterDemuxCallback((uint64_t)v30, (uint64_t)__IOHIDEventSystemConnectionDemuxCallback, (uint64_t)v24);
      _IOHIDEventSystemConnectionScheduleAsync((uint64_t)v30);
      v32 = _IOHIDEventSystemConnectionGetPort((uint64_t)v30);
    }
    else
    {
      v32 = 0;
    }
  }
  else
  {
LABEL_16:
    v32 = 0;
    v30 = 0;
  }
  if (v22)
    CFRelease(v22);
  if (v20)
    CFRelease(v20);
  if (v30)
    CFRelease(v30);
  if (v24)
    CFRelease(v24);
  *a9 = v32;
  return 0;
}

uint64_t _IOHIDEventSystemConnectionGetPort(uint64_t a1)
{
  return IOMIGMachPortGetPort(*(_QWORD *)(a1 + 32));
}

uint64_t __IOHIDEventSystemClientInitReplyPort(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  unsigned int *v4;
  ipc_space_read_t v5;
  mach_port_name_t Port;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  const void *v14;
  integer_t port_info_out;
  mach_msg_type_number_t port_info_outCnt;

  os_unfair_recursive_lock_lock_with_options();
  v2 = 1;
  if (!a1[5])
  {
    port_info_out = 0;
    port_info_outCnt = 1;
    v3 = IOMIGMachPortCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 56, 0);
    a1[5] = (uint64_t)v3;
    if (v3)
    {
      v4 = (unsigned int *)MEMORY[0x1E0C83DA0];
      v5 = *MEMORY[0x1E0C83DA0];
      Port = IOMIGMachPortGetPort((uint64_t)v3);
      if (mach_port_get_attributes(v5, Port, 1, &port_info_out, &port_info_outCnt))
      {
        v12 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          __IOHIDEventSystemClientInitReplyPort_cold_3();
      }
      else
      {
        port_info_out = 64;
        v7 = *v4;
        v8 = IOMIGMachPortGetPort(a1[5]);
        if (!MEMORY[0x18D7729B4](v7, v8, 1, &port_info_out, port_info_outCnt))
        {
          IOMIGMachPortRegisterDemuxCallback(a1[5], (uint64_t)__IOHIDEventSystemClientMIGDemuxCallback, (uint64_t)a1);
          IOMIGMachPortRegisterTerminationCallback(a1[5], (uint64_t)__IOHIDEventSystemClientTerminationCallback, (uint64_t)a1);
          v9 = IOMIGMachPortGetPort(a1[5]);
          IOMIGMachPortCacheAdd(v9, a1);
          v2 = 1;
          goto LABEL_6;
        }
        v13 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          __IOHIDEventSystemClientInitReplyPort_cold_2();
      }
    }
    else
    {
      v11 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        __IOHIDEventSystemClientInitReplyPort_cold_1();
    }
    v14 = (const void *)a1[5];
    if (v14)
    {
      CFRelease(v14);
      v2 = 0;
      a1[5] = 0;
    }
    else
    {
      v2 = 0;
    }
  }
LABEL_6:
  os_unfair_recursive_lock_unlock();
  return v2;
}

uint64_t IOMIGMachPortGetPort(uint64_t a1)
{
  return CFMachPortGetPort(*(CFMachPortRef *)(a1 + 48));
}

uint64_t IOMIGMachPortRegisterTerminationCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 88) = a2;
  *(_QWORD *)(result + 96) = a3;
  return result;
}

_QWORD *IOMIGMachPortCreate(const __CFAllocator *a1, uint64_t a2, mach_port_t a3)
{
  uint64_t Instance;
  _QWORD *v7;
  CFMachPortRef v8;
  CFMachPortContext v10;

  if (a2 < 1)
    return 0;
  if (!__IOMIGMachPortTypeID)
    pthread_once(&__IOMIGMachPortTypeInit, (void (*)(void))__IOMIGMachPortRegister);
  Instance = _CFRuntimeCreateInstance();
  v7 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_QWORD *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 80) = 0u;
    v10.version = 0;
    memset(&v10.retain, 0, 24);
    v10.info = (void *)Instance;
    if (a3)
      v8 = CFMachPortCreateWithPort(a1, a3, (CFMachPortCallBack)__IOMIGMachPortPortCallback, &v10, 0);
    else
      v8 = CFMachPortCreate(a1, (CFMachPortCallBack)__IOMIGMachPortPortCallback, &v10, 0);
    v7[6] = v8;
    if (v8)
    {
      v7[8] = a2;
      return v7;
    }
    CFRelease(v7);
    return 0;
  }
  return v7;
}

uint64_t IOMIGMachPortCacheAdd(unsigned int a1, const void *a2)
{
  pthread_mutex_lock(&__ioPortCacheLock);
  CFDictionarySetValue((CFMutableDictionaryRef)__ioPortCache, (const void *)a1, a2);
  return pthread_mutex_unlock(&__ioPortCacheLock);
}

uint64_t IOMIGMachPortRegisterDemuxCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 72) = a2;
  *(_QWORD *)(result + 80) = a3;
  return result;
}

uint64_t _IOHIDLoadConnectionPluginBundles()
{
  if (_IOHIDLoadConnectionPluginBundles_onceToken != -1)
    dispatch_once(&_IOHIDLoadConnectionPluginBundles_onceToken, &__block_literal_global_40);
  return __hidConnectionPluginBundles;
}

id _IOHIDEventSystemConnectionScheduleAsync(uint64_t a1)
{
  dispatch_source_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  id result;
  _QWORD v8[5];
  _QWORD handler[5];

  v2 = dispatch_source_create(MEMORY[0x1E0C80DA0], *(unsigned int *)(a1 + 40), 8uLL, *(dispatch_queue_t *)(a1 + 96));
  *(_QWORD *)(a1 + 120) = v2;
  if (v2)
  {
    CFRetain((CFTypeRef)a1);
    dispatch_source_set_registration_handler(*(dispatch_source_t *)(a1 + 120), &__block_literal_global_13);
    v3 = MEMORY[0x1E0C809B0];
    v4 = *(NSObject **)(a1 + 120);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = ___IOHIDEventSystemConnectionScheduleAsync_block_invoke_2;
    handler[3] = &__block_descriptor_tmp_12_0;
    handler[4] = a1;
    dispatch_source_set_event_handler(v4, handler);
    v5 = *(NSObject **)(a1 + 120);
    v8[0] = v3;
    v8[1] = 0x40000000;
    v8[2] = ___IOHIDEventSystemConnectionScheduleAsync_block_invoke_3;
    v8[3] = &__block_descriptor_tmp_13;
    v8[4] = a1;
    dispatch_source_set_cancel_handler(v5, v8);
    dispatch_resume(*(dispatch_object_t *)(a1 + 120));
  }
  else
  {
    v6 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemConnectionScheduleAsync_cold_1();
  }
  IOMIGMachPortScheduleWithDispatchQueue(*(_QWORD *)(a1 + 32), *(NSObject **)(a1 + 96));
  result = *(id *)(a1 + 440);
  if (result)
  {
    IOHIDConnectionFilterSetDispatchQueue((uint64_t)result, *(_QWORD *)(a1 + 96));
    return IOHIDConnectionFilterActivate(*(_QWORD *)(a1 + 440));
  }
  return result;
}

uint64_t IOMIGMachPortScheduleWithDispatchQueue(uint64_t a1, NSObject *a2)
{
  uint64_t result;

  result = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 48));
  *(_QWORD *)(a1 + 32) = a2;
  if (a2 && !*(_QWORD *)(a1 + 40))
  {
    dispatch_queue_get_label(a2);
    result = dispatch_mach_create_f();
    if (result)
    {
      *(_QWORD *)(a1 + 40) = result;
      CFRetain((CFTypeRef)a1);
      return dispatch_mach_connect();
    }
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionRegisterTerminationCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemConnectionRegisterDemuxCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 56) = a3;
  return os_unfair_recursive_lock_unlock();
}

HIDConnection *_IOHIDEventSystemConnectionCreatePrivate(uint64_t a1)
{
  return -[HIDConnection init](+[HIDConnection allocWithZone:](HIDConnection, "allocWithZone:", a1), "init");
}

CFTypeRef IOHIDConnectionFilterCreate(uint64_t a1, __CFBundle *a2, uint64_t a3)
{
  _OWORD *Instance;
  _QWORD *v6;
  _QWORD *v7;
  const __CFDictionary *InfoDictionary;
  uint64_t v9;
  const void *Value;
  const void *v11;
  CFTypeID v12;
  const __CFString *v13;
  const __CFString *v14;
  void *DataPointerForName;
  void *v16;
  id v17;
  id v18;
  Protocol *Protocol;
  CFTypeRef v20;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  if (!__kIOHIDConnectionFilterTypeID)
    pthread_once(&__connectionFilterClientTypeInit, (void (*)(void))__IOHIDConnectionFilterRegister);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  if (!Instance)
    return 0;
  v6 = Instance;
  Instance[1] = 0u;
  v7 = Instance + 1;
  Instance[3] = 0u;
  Instance[4] = 0u;
  Instance[2] = 0u;
  InfoDictionary = CFBundleGetInfoDictionary(a2);
  if (!InfoDictionary
    || (v9 = (uint64_t)InfoDictionary, (Value = CFDictionaryGetValue(InfoDictionary, CFSTR("NSPrincipalClass"))) == 0)
    || (v11 = Value, v12 = CFGetTypeID(Value), v12 != CFStringGetTypeID())
    || (v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("OBJC_CLASS_$_%@"), v11)) == 0)
  {
    v20 = 0;
    goto LABEL_16;
  }
  v14 = v13;
  DataPointerForName = CFBundleGetDataPointerForName(a2, v13);
  if (!DataPointerForName)
  {
    v22 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      IOHIDConnectionFilterCreate_cold_1((uint64_t)v14, v9, v22);
    goto LABEL_28;
  }
  v16 = DataPointerForName;
  if (!objc_msgSend(DataPointerForName, sel_getUid("matchConnection:"), a3)
    || (v17 = objc_msgSend(v16, sel_getUid("alloc"))) == 0)
  {
LABEL_28:
    v20 = 0;
    goto LABEL_15;
  }
  v18 = v17;
  if (!objc_msgSend(v17, sel_getUid("initWithConnection:"), a3))
  {
    v23 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      IOHIDConnectionFilterCreate_cold_2(v23, v24, v25, v26, v27, v28, v29, v30);
    goto LABEL_28;
  }
  *v7 = v18;
  Protocol = objc_getProtocol("HIDConnectionPlugin");
  if (!Protocol)
  {
    v31 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      IOHIDConnectionFilterCreate_cold_3(v31, v32, v33, v34, v35, v36, v37, v38);
    goto LABEL_28;
  }
  if (!class_conformsToProtocol((Class)v16, Protocol))
  {
    v39 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      IOHIDConnectionFilterCreate_cold_4(v39, v40, v41, v42, v43, v44, v45, v46);
    goto LABEL_28;
  }
  v6[3] = sel_getUid("propertyForKey:");
  v6[4] = sel_getUid("setProperty:forKey:");
  v6[9] = sel_getUid("filterEvent:");
  v6[5] = sel_getUid("setCancelHandler:");
  v6[8] = sel_getUid("setDispatchQueue:");
  v6[6] = sel_getUid("activate");
  v6[7] = sel_getUid("cancel");
  v20 = CFRetain(v6);
LABEL_15:
  CFRelease(v14);
LABEL_16:
  CFRelease(v6);
  return v20;
}

void _IOHIDEventSystemAddConnection(CFMutableSetRef *a1, const void *a2)
{
  int Type;
  NSObject *v5;
  CFMutableSetRef *v6;
  CFMutableSetRef v7;
  void (*v8)(CFMutableSetRef, CFMutableSetRef, const void *);
  CFMutableSetRef v9;
  CFMutableSetRef *v10;
  const __CFAllocator *v11;
  const __CFSet *Copy;
  int v13;
  const void *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  Type = IOHIDEventSystemConnectionGetType((uint64_t)a2);
  v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v13 = 138543362;
    v14 = a2;
    _os_log_impl(&dword_18AAAF000, v5, OS_LOG_TYPE_DEFAULT, "Connection added: %{public}@", (uint8_t *)&v13, 0xCu);
  }
  os_unfair_recursive_lock_lock_with_options();
  v6 = &a1[3 * Type];
  v7 = v6[23];
  v8 = (void (*)(CFMutableSetRef, CFMutableSetRef, const void *))v6[24];
  v9 = v6[25];
  CFSetAddValue(a1[6], a2);
  switch(Type)
  {
    case 0:
      v10 = a1 + 7;
      goto LABEL_7;
    case 1:
    case 3:
      v10 = a1 + 8;
      goto LABEL_7;
    case 2:
    case 4:
      v10 = a1 + 9;
LABEL_7:
      CFSetAddValue(*v10, a2);
      break;
    default:
      break;
  }
  v11 = CFGetAllocator(a1);
  Copy = CFSetCreateCopy(v11, a1[53]);
  os_unfair_recursive_lock_unlock();
  if (Copy)
  {
    CFSetApplyFunction(Copy, (CFSetApplierFunction)_IOHIDEventSystemConnectionRecordClientChanged, 0);
    CFRelease(Copy);
  }
  if (v8)
    v8(v7, v9, a2);
}

NSObject *hid_workloop_create(const char *a1, int a2)
{
  NSObject *inactive;

  inactive = dispatch_workloop_create_inactive(a1);
  if (a2)
    dispatch_workloop_set_scheduler_priority();
  dispatch_set_qos_class_fallback();
  dispatch_workloop_set_scheduler_priority();
  _dispatch_workloop_set_observer_hooks_4IOHID();
  dispatch_activate(inactive);
  return inactive;
}

void __IOHIDEventSystemClientMatchNotifyRelease(uint64_t a1, const __CFDictionary *a2)
{
  const void *Value;
  const void *v5;
  const __CFData *v6;
  const __CFData *v7;
  int v8;
  const UInt8 *BytePtr;
  int Length;

  os_unfair_recursive_lock_lock_with_options();
  if (*(_QWORD *)(a1 + 88))
  {
    Value = CFDictionaryGetValue(a2, CFSTR("id"));
    if (Value)
    {
      v5 = Value;
      v6 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Value);
      if (v6)
      {
        v7 = v6;
        v8 = *(_DWORD *)(a1 + 32);
        BytePtr = CFDataGetBytePtr(v6);
        Length = CFDataGetLength(v7);
        io_hideventsystem_release_notification(v8, (uint64_t)BytePtr, Length);
        CFRelease(v7);
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 88), v5);
    }
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
    CFRelease(a2);
}

uint64_t io_hideventsystem_release_notification(int a1, uint64_t a2, int a3)
{
  uint64_t v3;
  _BYTE msg[28];
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;

  v6 = a2;
  v7 = 16777472;
  v8 = a3;
  v9 = *MEMORY[0x1E0C804E8];
  v10 = a3;
  *(_QWORD *)msg = 2147483667;
  *(_DWORD *)&msg[8] = a1;
  *(_OWORD *)&msg[12] = xmmword_18AB47720;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  v3 = mach_msg((mach_msg_header_t *)msg, 1, 0x38u, 0, 0, 0, 0);
  if ((v3 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)&msg[12]);
    mach_msg_destroy((mach_msg_header_t *)msg);
  }
  return v3;
}

void __IOHIDEventSystemMatchNotifyRelease(uint64_t a1, const void *a2, const void *a3)
{
  __CFSet *v6;

  os_unfair_recursive_lock_lock_with_options();
  v6 = *(__CFSet **)(a1 + 40);
  if (v6)
    CFSetRemoveValue(v6, a3);
  os_unfair_recursive_lock_unlock();
  if (a2)
    CFRelease(a2);
}

uint64_t io_hideventsystem_queue_start(mach_port_t a1)
{
  uint64_t v1;
  mach_msg_header_t msg;

  msg.msgh_size = 0;
  msg.msgh_bits = 19;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = 0;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1118000000000;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set(&msg);
  v1 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
  if ((v1 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    mach_msg_destroy(&msg);
  }
  return v1;
}

void __IOHIDEventSystemClientIntRelease(uint64_t a1)
{
  const void *v2;
  mach_port_name_t v3;
  ipc_space_t *v4;
  const void *v5;
  __CFMachPort *v6;
  ipc_space_t v7;
  mach_port_name_t Port;
  const void *v9;
  const void *v10;
  const void *v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;

  v2 = *(const void **)(a1 + 112);
  if (v2)
    CFRelease(v2);
  v3 = *(_DWORD *)(a1 + 32);
  v4 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (v3)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v3);
  v5 = *(const void **)(a1 + 272);
  if (v5)
    CFRelease(v5);
  v6 = *(__CFMachPort **)(a1 + 280);
  if (v6)
  {
    v7 = *v4;
    Port = CFMachPortGetPort(v6);
    mach_port_mod_refs(v7, Port, 1u, -1);
    CFRelease(*(CFTypeRef *)(a1 + 280));
  }
  v9 = *(const void **)(a1 + 288);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 64);
  if (v10)
    CFRelease(v10);
  v11 = *(const void **)(a1 + 56);
  if (v11)
    CFRelease(v11);
  v12 = *(_DWORD *)(a1 + 48);
  if (v12)
    notify_cancel(v12);
  v13 = *(_QWORD *)(a1 + 40);
  if (v13)
  {
    v14 = IOMIGMachPortGetPort(v13);
    IOMIGMachPortCacheRemove(v14);
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  v15 = *(const void **)(a1 + 80);
  if (v15)
    CFRelease(v15);
  v16 = *(const void **)(a1 + 88);
  if (v16)
    CFRelease(v16);
  v17 = *(const void **)(a1 + 96);
  if (v17)
    CFRelease(v17);
  v18 = *(const void **)(a1 + 104);
  if (v18)
    CFRelease(v18);
  v19 = *(const void **)(a1 + 120);
  if (v19)
    CFRelease(v19);
  v20 = *(const void **)(a1 + 128);
  if (v20)
    CFRelease(v20);
  v21 = *(const void **)(a1 + 136);
  if (v21)
    CFRelease(v21);
  v22 = *(const void **)(a1 + 416);
  if (v22)
    CFRelease(v22);
  v23 = *(const void **)(a1 + 432);
  if (v23)
    CFRelease(v23);
  v24 = *(const void **)(a1 + 440);
  if (v24)
    CFRelease(v24);
  v25 = *(const void **)(a1 + 176);
  if (v25)
    _Block_release(v25);
  v26 = *(const void **)(a1 + 208);
  if (v26)
    _Block_release(v26);
}

uint64_t IOMIGMachPortCacheRemove(unsigned int a1)
{
  pthread_mutex_lock(&__ioPortCacheLock);
  CFDictionaryRemoveValue((CFMutableDictionaryRef)__ioPortCache, (const void *)a1);
  return pthread_mutex_unlock(&__ioPortCacheLock);
}

void __IOHIDEventSystemClientExtRelease(uint64_t a1)
{
  CFMutableDictionaryRef v2;
  unsigned int v3;
  NSObject *v4;
  const char *CStringPtr;
  __CFMachPort *v6;
  __CFMachPort *v7;
  __CFRunLoop *v8;
  uint64_t v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  CFMutableDictionaryRef v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = __IOHIDEventSystemClientStateSerialize(a1);
  if (*(_QWORD *)(a1 + 400))
  {
    if (!*(_BYTE *)(a1 + 408))
    {
      v3 = atomic_load((unsigned int *)(a1 + 312));
      if (v3 != 3)
        __IOHIDQueueExtRelease_cold_1(&v9, buf, (unsigned int *)(a1 + 312));
    }
  }
  v4 = _IOHIDLogCategory(0xEu);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 440), 0x8000100u);
    *(_DWORD *)buf = 136315394;
    v11 = CStringPtr;
    v12 = 2114;
    v13 = v2;
    _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_DEFAULT, "Released connection: %s\n%{public}@", buf, 0x16u);
  }
  CFRelease(v2);
  if (*(_QWORD *)(a1 + 456))
    os_state_remove_handler();
  v6 = *(__CFMachPort **)(a1 + 56);
  if (v6)
    CFMachPortInvalidate(v6);
  v7 = *(__CFMachPort **)(a1 + 280);
  if (v7)
    CFMachPortInvalidate(v7);
  if (*(_BYTE *)(a1 + 408))
    IOHIDEventSystemClientCancel(a1);
  v8 = *(__CFRunLoop **)(a1 + 384);
  if (v8
    && (IOHIDEventSystemClientUnscheduleWithRunLoop(a1, v8, *(const __CFString **)(a1 + 392)), *(_QWORD *)(a1 + 384))
    || !*(_QWORD *)(a1 + 400))
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 488));
  }
}

uint64_t IOHIDServiceFilterSetEventCallback(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v2)(void);

  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v2 = *(uint64_t (**)(void))(*(_QWORD *)result + 112);
    if (v2)
      return v2();
  }
  return result;
}

CFMutableDictionaryRef IOBSDNameMatching(mach_port_t mainPort, uint32_t options, const char *bsdName)
{
  if (bsdName)
    return MakeOneStringProp(CFSTR("BSD Name"), bsdName);
  else
    return 0;
}

__CFDictionary *__FilterFunctionGetPropertyForClient(__CFDictionary *result, uint64_t a2)
{
  if (!*(_QWORD *)(a2 + 16))
  {
    result = IOHIDSessionFilterGetPropertyForClient((uint64_t)result, *(CFTypeRef *)(a2 + 8));
    *(_QWORD *)(a2 + 16) = result;
  }
  return result;
}

__CFDictionary *IOHIDSessionFilterGetPropertyForClient(uint64_t a1, CFTypeRef cf1)
{
  __CFDictionary *v4;
  uint64_t v5;
  uint64_t (*v6)(void);
  const __CFString *v7;
  void *v8;
  const __CFAllocator *v9;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v11;
  const __CFString *v12;
  NSObject *v13;
  const __CFAllocator *v14;
  CFStringRef v15;
  CFStringRef v16;
  const void *v17;

  if (CFEqual(cf1, CFSTR("HIDObjectUUID")))
    return *(__CFDictionary **)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 && (v6 = *(uint64_t (**)(void))(*(_QWORD *)v5 + 120)) != 0)
  {
    v7 = (const __CFString *)v6();
  }
  else
  {
    v8 = *(void **)(a1 + 56);
    if (v8)
    {
      v7 = (const __CFString *)objc_msgSend(v8, *(SEL *)(a1 + 64), cf1);
      if (CFEqual(cf1, CFSTR("SessionFilterDebug")) && v7)
        CFRetain(v7);
    }
    else
    {
      v7 = 0;
    }
  }
  if (!CFEqual(cf1, CFSTR("SessionFilterDebug")))
    return (__CFDictionary *)v7;
  v9 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return (__CFDictionary *)v7;
  v4 = Mutable;
  if (v7)
  {
    if (_IOHIDIsSerializable((uint64_t)v7))
    {
      v11 = v4;
      v12 = v7;
    }
    else
    {
      v13 = _IOHIDLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        IOHIDSessionFilterGetPropertyForClient_cold_1(a1, v13);
      v12 = CFSTR("not serializable");
      v11 = v4;
    }
    CFDictionaryAddValue(v11, CFSTR("plugin"), v12);
    CFRelease(v7);
  }
  v14 = CFGetAllocator((CFTypeRef)a1);
  v15 = CFUUIDCreateString(v14, *(CFUUIDRef *)(a1 + 32));
  if (v15)
  {
    v16 = v15;
    CFDictionaryAddValue(v4, CFSTR("uuid"), v15);
    CFRelease(v16);
  }
  v17 = *(const void **)(a1 + 40);
  if (v17)
    CFDictionaryAddValue(v4, CFSTR("name"), v17);
  return v4;
}

CFTypeID EntitlementCheckApplier(CFTypeID result, uint64_t a2)
{
  const __CFString *v3;
  CFTypeID v4;

  if (!*(_BYTE *)(a2 + 8))
  {
    v3 = (const __CFString *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v4 == result)
    {
      result = IOHIDEventSystemConnectionHasEntitlement(*(_QWORD *)a2, v3);
      *(_BYTE *)(a2 + 8) = (_DWORD)result != 0;
    }
  }
  return result;
}

BOOL IOHIDEventSystemConnectionHasEntitlement(uint64_t a1, CFStringRef theString)
{
  void *v2;
  const char *CStringPtr;

  v2 = *(void **)(a1 + 248);
  if (!v2)
    return 0;
  CStringPtr = CFStringGetCStringPtr(theString, 0);
  return xpc_dictionary_get_value(v2, CStringPtr) == (xpc_object_t)MEMORY[0x1E0C81240];
}

const __CFDictionary *__ConnectionFunctionContainsReportInterval(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  const __CFDictionary *result;

  result = IOHIDServiceConnectionCacheContainsKey(a2, CFSTR("ReportInterval"));
  *a3 |= result;
  return result;
}

uint64_t IOHIDServiceClientFastPathCopyEventWithStatus(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(a1 + 104);
  if (v1 && (v2 = *(uint64_t (**)(void))(*(_QWORD *)v1 + 64)) != 0)
    return v2();
  else
    return 3758097095;
}

id __FilterFunctionScheduleAsync_0(uint64_t a1, uint64_t a2)
{
  return IOHIDSessionFilterScheduleWithDispatchQueue(a1, *(dispatch_object_t *)(a2 + 96));
}

void __VirtualServicesApplier(uint64_t a1, _QWORD *a2)
{
  _IOHIDServiceTerminate(a2);
}

uint64_t __SetPropertiesForObjectFunction(const void *a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  uint64_t result;

  v6 = CFGetTypeID(cf);
  result = IOHIDServiceGetTypeID();
  if (v6 == result)
    return IOHIDServiceSetProperty((uint64_t)cf, a1, a2);
  return result;
}

void __IOHIDConnectionFilterRelease(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

void __CheckForNewProperties(void *key, const void *a2, CFDictionaryRef *a3)
{
  const void *Value;

  Value = CFDictionaryGetValue(*a3, key);
  if (!Value || !CFEqual(Value, a2))
    CFDictionaryAddValue(a3[1], key, a2);
}

uint64_t IOHIDEventSystemConnectionGetTaskNamePort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 192);
}

void __FilterFunctionUnscheduleAsync_0(uint64_t a1, uint64_t a2)
{
  IOHIDSessionFilterUnscheduleFromDispatchQueue(a1, *(dispatch_object_t *)(a2 + 96));
}

uint64_t __FilterFunctionClose(uint64_t a1)
{
  return IOHIDServiceFilterClose(a1);
}

id __FilterFunctionClose_0(id result)
{
  return IOHIDSessionFilterClose(result);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  kern_return_t result;
  const char *v7;
  size_t v8;
  __CFDictionary *v9;
  const char *CStringPtr;
  size_t bufferSize;
  CFStringRef errorString;
  mach_vm_address_t address;
  unsigned int size;
  _QWORD size_4[257];

  size_4[256] = *MEMORY[0x1E0C80C00];
  size = 0;
  errorString = 0;
  address = 0;
  bufferSize = 2048;
  if ((gIOKitLibSerializeOptions & 1) != 0)
  {
    result = io_registry_entry_get_properties_bin_buf(entry, (uint64_t)size_4, (uint64_t *)&bufferSize);
    if (result)
      return result;
  }
  else
  {
    result = io_registry_entry_get_properties(entry);
    if (result)
      return result;
  }
  v7 = (const char *)address;
  if (address)
  {
    v8 = size;
  }
  else
  {
    v8 = bufferSize;
    v7 = (const char *)size_4;
  }
  v9 = (__CFDictionary *)IOCFUnserializeWithSize(v7, v8, allocator, 0, &errorString);
  *properties = v9;
  if (!v9 && errorString)
  {
    CStringPtr = CFStringGetCStringPtr(errorString, 0);
    if (CStringPtr)
      puts(CStringPtr);
    CFRelease(errorString);
  }
  if (address)
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], address, size);
  if (*properties)
    return 0;
  else
    return -536870199;
}

uint64_t io_registry_entry_get_properties_bin_buf(unsigned int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  mach_msg_header_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = 0;
  v7 = *MEMORY[0x1E0C804E8];
  v8 = a2;
  v9 = *a3;
  v10 = 0;
  *(_QWORD *)&v6.msgh_bits = 0x3000001513;
  *(_QWORD *)&v6.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v6.msgh_voucher_port = 0xB4800000000;
  v3 = mach_msg2_internal();
  v4 = v3;
  if ((v3 - 268435458) <= 0xE && ((1 << (v3 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v6.msgh_local_port);
  }
  else if ((_DWORD)v3)
  {
    mig_dealloc_reply_port(v6.msgh_local_port);
  }
  else
  {
    v4 = 4294966995;
    mach_msg_destroy(&v6);
  }
  return v4;
}

BOOL _IOObjectConformsTo(unsigned int a1, const char *a2, char a3)
{
  const __CFAllocator *v6;
  const __CFString *v7;
  const __CFString *v8;
  CFTypeID v9;
  const __CFString *v10;
  const __CFString *v11;
  _BOOL4 v13;

  v13 = 0;
  if (io_object_conforms_to(a1, a2))
  {
    v13 = 0;
    if ((a3 & 1) != 0)
      return v13;
  }
  else if ((a3 & 1) != 0)
  {
    return v13;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = (const __CFString *)IORegistryEntrySearchCFProperty(a1, 0, CFSTR("IOClassNameOverride"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (v7)
  {
    v8 = v7;
    v9 = CFGetTypeID(v7);
    if (v9 == CFStringGetTypeID())
    {
      v10 = CFStringCreateWithCStringNoCopy(v6, a2, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      if (v10)
      {
        v11 = v10;
        v13 = CFStringCompare(v8, v10, 0) == kCFCompareEqualTo;
        CFRelease(v11);
      }
    }
    CFRelease(v8);
  }
  return v13;
}

uint64_t io_object_conforms_to(unsigned int a1, const char *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  _OWORD v9[8];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  else
    v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v8 = 0xAF100000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

void IOHIDEventSystemClientSetDispatchQueue(uint64_t a1, NSObject *a2)
{
  const char *label;
  dispatch_queue_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_QWORD *)(a1 + 400))
    IOHIDEventSystemClientSetDispatchQueue_cold_1();
  __IOHIDEventSystemClientSetupAsyncSupport(a1);
  label = dispatch_queue_get_label(a2);
  if (!*label)
    label = "IOHIDEventSystemClientDispatchQueue";
  v5 = dispatch_queue_create_with_target_V2(label, 0, a2);
  *(_QWORD *)(a1 + 400) = v5;
  if (v5)
  {
    _IOHIDObjectInternalRetain((const void *)a1);
    v6 = dispatch_mach_create();
    *(_QWORD *)(a1 + 296) = v6;
    if (v6)
    {
      _IOHIDObjectInternalRetain((const void *)a1);
      v7 = dispatch_mach_create();
      *(_QWORD *)(a1 + 72) = v7;
      if (!v7)
      {
        _IOHIDObjectInternalRelease((const void *)a1);
        dispatch_release(*(dispatch_object_t *)(a1 + 400));
      }
    }
    else
    {
      _IOHIDObjectInternalRelease((const void *)a1);
    }
  }
}

CFRunLoopSourceRef IOHIDEventSystemClientScheduleWithRunLoop(CFRunLoopSourceRef result, __CFRunLoop *a2, const __CFString *a3)
{
  _QWORD *v5;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoopSource *v7;
  const void *v8;
  __CFMachPort *v9;
  __CFMachPort *v10;

  *((_QWORD *)result + 48) = a2;
  *((_QWORD *)result + 49) = a3;
  if (!a2)
    return result;
  v5 = result;
  __IOHIDEventSystemClientSetupAsyncSupport((uint64_t)result);
  os_unfair_recursive_lock_lock_with_options();
  RunLoopSource = (__CFRunLoopSource *)v5[36];
  if (RunLoopSource)
    goto LABEL_3;
  v9 = (__CFMachPort *)v5[35];
  if (v9)
  {
    RunLoopSource = CFMachPortCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, 0);
    v5[36] = RunLoopSource;
    if (!RunLoopSource)
      return (CFRunLoopSourceRef)os_unfair_recursive_lock_unlock();
LABEL_3:
    CFRunLoopAddSource(a2, RunLoopSource, a3);
  }
  v7 = (__CFRunLoopSource *)v5[8];
  if (!v7)
  {
    v10 = (__CFMachPort *)v5[7];
    if (!v10)
      goto LABEL_6;
    result = CFMachPortCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10, 0);
    v7 = result;
    v5[8] = result;
    if (!result)
      return result;
  }
  CFRunLoopAddSource(a2, v7, a3);
LABEL_6:
  v8 = (const void *)v5[5];
  if (v8)
    IOMIGMachPortScheduleWithRunLoop(v8, a2, a3);
  os_unfair_recursive_lock_unlock();
  __IOHIDEventSystemClientStartQueue((uint64_t)v5);
  return (CFRunLoopSourceRef)__IOHIDEventSystemClientStartFilter((uint64_t)v5);
}

uint64_t __IOHIDEventSystemClientSetupAsyncSupport(uint64_t a1)
{
  mach_port_t NotificationPort;
  CFMachPortRef v3;
  NSObject *v4;
  CFMachPortRef v5;
  uint64_t v6;
  mach_port_t Port;
  NSObject *v8;
  CFMachPortContext v10;
  mach_port_t notify_port;

  v10.version = 0;
  memset(&v10.retain, 0, 24);
  v10.info = (void *)a1;
  os_unfair_recursive_lock_lock_with_options();
  if (*(_QWORD *)(a1 + 280)
    || (NotificationPort = IODataQueueAllocateNotificationPort()) != 0
    && (v3 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x1E0C9AE00], NotificationPort, (CFMachPortCallBack)__IOHIDEventSystemClientQueueCallback, &v10, 0), (*(_QWORD *)(a1 + 280) = v3) != 0))
  {
    if (!*(_QWORD *)(a1 + 56))
    {
      notify_port = 0;
      if (notify_register_mach_port("com.apple.iohideventsystem.available", &notify_port, 0, (int *)(a1 + 48)))
      {
        v4 = _IOHIDLogCategory(0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          __IOHIDEventSystemClientSetupAsyncSupport_cold_2();
      }
      else
      {
        v5 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x1E0C9AE00], notify_port, (CFMachPortCallBack)__IOHIDEventSystemClientAvailabilityCallback, &v10, 0);
        *(_QWORD *)(a1 + 56) = v5;
        if (!v5)
          return os_unfair_recursive_lock_unlock();
        __IOHIDEventSystemClientRefresh(a1, 0);
      }
    }
    if (!*(_QWORD *)(a1 + 272))
    {
      if (*(_BYTE *)(a1 + 448))
      {
        v6 = 0x20000;
      }
      else if (*(_DWORD *)(a1 + 424) == 2)
      {
        v6 = 0x4000;
      }
      else
      {
        v6 = 0x8000;
      }
      Port = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 280));
      notify_port = 0;
      if (io_hideventsystem_queue_create(*(_DWORD *)(a1 + 32), Port, v6, &notify_port))
      {
        v8 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          __IOHIDEventSystemClientSetupAsyncSupport_cold_1();
        *(_QWORD *)(a1 + 272) = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 272) = IOHIDEventQueueCreateWithVM(*MEMORY[0x1E0C9AE00], notify_port, v6);
      }
    }
  }
  return os_unfair_recursive_lock_unlock();
}

mach_port_t IODataQueueAllocateNotificationPort(void)
{
  ipc_space_t *v0;
  kern_return_t v1;
  mach_port_t result;
  mach_msg_type_number_t port_info_outCnt;
  mach_port_name_t name[2];

  *(_QWORD *)name = 0;
  v0 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v1 = mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, &name[1]);
  result = 0;
  if (!v1)
  {
    port_info_outCnt = 1;
    if (mach_port_get_attributes(*v0, name[1], 1, (mach_port_info_t)name, &port_info_outCnt)
      || (name[0] = 1, MEMORY[0x18D7729B4](*v0, name[1], 1, name, 1)))
    {
      mach_port_mod_refs(*v0, name[1], 1u, -1);
      return 0;
    }
    else
    {
      return name[1];
    }
  }
  return result;
}

uint64_t io_hideventsystem_queue_create(int a1, int a2, int a3, _DWORD *a4)
{
  mach_port_name_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  _BYTE msg[36];
  int v11;
  uint64_t v12;
  int v13;

  memset(&msg[4], 0, 32);
  *(_DWORD *)&msg[24] = 1;
  *(_DWORD *)&msg[28] = a2;
  v11 = 1310720;
  v12 = *MEMORY[0x1E0C804E8];
  v13 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = -2147478253;
  *(_QWORD *)&msg[16] = 0x1117F00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v7 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x34u, 0x30u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 70115)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            v8 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8])
                v8 = 4294966996;
              else
                v8 = *(unsigned int *)&msg[32];
            }
          }
          else
          {
            v8 = 4294966996;
          }
          goto LABEL_26;
        }
        v8 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 40 && !*(_DWORD *)&msg[8] && HIWORD(v11) << 16 == 1114112)
        {
          v8 = 0;
          *a4 = *(_DWORD *)&msg[28];
          return v8;
        }
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_26:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v8 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)&msg[12]);
    goto LABEL_26;
  }
  return v8;
}

_DWORD *IOHIDEventQueueCreateWithVM(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t Private;
  _DWORD *v6;
  mach_vm_offset_t v7;
  mach_vm_size_t v8;
  NSObject *v10;
  NSObject *v11;

  if (!a2 || !a3)
  {
    v10 = _IOHIDLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      IOHIDEventQueueCreateWithVM_cold_1(a2, a3, v10);
    return 0;
  }
  Private = __IOHIDEventQueueCreatePrivate();
  v6 = (_DWORD *)Private;
  if (Private)
  {
    v7 = *MEMORY[0x1E0C85AC0];
    v8 = ~*MEMORY[0x1E0C85AC0] & (unint64_t)(a3 + *MEMORY[0x1E0C85AC0] + 40);
    *(_QWORD *)(Private + 24) = v8;
    *(_DWORD *)(Private + 84) = a2;
    if (!mach_vm_map(*MEMORY[0x1E0C83DA0], (mach_vm_address_t *)(Private + 16), v8, v7, 1, a2, 0, 0, 3, 3, 2u))
    {
      v6[36] = 1;
      return v6;
    }
    v11 = _IOHIDLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      IOHIDEventQueueCreate_cold_2();
    CFRelease(v6);
    return 0;
  }
  return v6;
}

uint64_t _Xio_hideventsystem_queue_create(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 52)
  {
    v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_8;
  }
  *(_QWORD *)(a2 + 32) = 0x13000000000000;
  result = _io_hideventsystem_queue_create(*(_DWORD *)(result + 12), *(_DWORD *)(result + 28), *(_DWORD *)(result + 48), (_DWORD *)(a2 + 28));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _io_hideventsystem_queue_create(unsigned int a1, int a2, int a3, _DWORD *a4)
{
  const void *v7;
  const void *v8;
  CFTypeID v9;
  const void *v10;
  const void *v11;
  CFAllocatorRef v12;
  uint64_t v13;
  const void *v14;

  *a4 = 0;
  v7 = IOMIGMachPortCacheCopy(a1);
  if (v7)
  {
    v8 = v7;
    v9 = CFGetTypeID(v7);
    if (v9 == IOHIDEventSystemConnectionGetTypeID())
    {
      v10 = _IOHIDEventSystemConnectionCopyQueue((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        _IOHIDEventSystemConnectionSetQueue((uint64_t)v8, 0);
        CFRelease(v11);
      }
      v12 = CFGetAllocator(v8);
      v13 = IOHIDEventQueueCreate((uint64_t)v12, 1, a3);
      if (v13)
      {
        v14 = (const void *)v13;
        IOHIDEventQueueSetNotificationPort(v13, a2);
        *a4 = IOHIDEventQueueGetMemoryHandle((uint64_t)v14);
        _IOHIDEventSystemConnectionSetQueue((uint64_t)v8, (uint64_t)v14);
        CFRelease(v14);
      }
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t IOHIDEventQueueCreate(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t Private;
  uint64_t v6;
  vm_map_t *v7;
  mach_vm_size_t v8;
  _DWORD *v9;
  const __CFAllocator *v10;
  CFNumberRef v11;
  __CFString *v12;
  CFDictionaryRef v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  char v17;
  char v18;
  const void *v19;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  uint8_t buf[16];
  __int128 v32;
  memory_object_size_t size[3];

  size[2] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
    return 0;
  Private = __IOHIDEventQueueCreatePrivate();
  v6 = Private;
  if (!Private)
    return v6;
  *(_DWORD *)(Private + 144) = a2;
  if (a2 == 1)
  {
    size[0] = (a3 + *MEMORY[0x1E0C85AD8] + 39) & -*MEMORY[0x1E0C85AD8];
    v7 = (vm_map_t *)MEMORY[0x1E0C83DA0];
    if (mach_make_memory_entry_64(*MEMORY[0x1E0C83DA0], size, 0, 393219, (mach_port_t *)(Private + 84), 0))
    {
      v29 = _IOHIDLog();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        IOHIDEventQueueCreate_cold_3();
      goto LABEL_29;
    }
    v8 = size[0];
    *(_QWORD *)(v6 + 24) = size[0];
    if (mach_vm_map(*v7, (mach_vm_address_t *)(v6 + 16), v8, *MEMORY[0x1E0C85AC0], 1, *(_DWORD *)(v6 + 84), 0, 0, 3, 3, 2u))
    {
      v30 = _IOHIDLog();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        IOHIDEventQueueCreate_cold_2();
      goto LABEL_29;
    }
  }
  v9 = *(_DWORD **)(v6 + 16);
  if (!v9)
    goto LABEL_29;
  *(_DWORD *)(v6 + 56) = a3;
  *v9 = a3;
  v9[1] = 0;
  v9[2] = 0;
  v32 = xmmword_18AB470C0;
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, (const void *)(v6 + 24));
  v12 = *(_DWORD *)(v6 + 144) ? CFSTR("userEventQueue") : CFSTR("kernelEventQueue");
  size[0] = (memory_object_size_t)v11;
  size[1] = (memory_object_size_t)v12;
  v13 = CFDictionaryCreate(v10, (const void **)__IOHIDEventQueueSetupAnalytics_keys, (const void **)size, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v13)
  {
    v14 = IOHIDAnalyticsHistogramEventCreate((uint64_t)CFSTR("com.apple.hid.queueUsage"), (uint64_t)v13, (uint64_t)CFSTR("UsagePercent"), (uint64_t)&v32, 1);
    *(_QWORD *)(v6 + 160) = v14;
    if (v14)
      goto LABEL_15;
    v15 = _IOHIDLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18AAAF000, v15, OS_LOG_TYPE_DEFAULT, "Unable to create queue analytics", buf, 2u);
    }
    if (*(_QWORD *)(v6 + 160))
LABEL_15:
      IOHIDAnalyticsEventActivate();
    CFRelease(v13);
  }
  else
  {
    v21 = _IOHIDLog();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      IOHIDEventQueueCreate_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
  }
  v16 = 0;
  v17 = 1;
  do
  {
    v18 = v17;
    v19 = (const void *)size[v16];
    if (v19)
      CFRelease(v19);
    v17 = 0;
    v16 = 1;
  }
  while ((v18 & 1) != 0);
  if (!v13)
  {
LABEL_29:
    CFRelease((CFTypeRef)v6);
    return 0;
  }
  return v6;
}

uint64_t __IOHIDEventQueueCreatePrivate()
{
  uint64_t Instance;
  uint64_t v1;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  IOHIDEventQueueGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v1 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_QWORD *)(Instance + 40) = 0;
  }
  else
  {
    v3 = _IOHIDLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      __IOHIDEventQueueCreatePrivate_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return v1;
}

uint64_t IOHIDEventQueueGetTypeID()
{
  uint64_t result;

  result = __kIOHIDEventQueueTypeID;
  if (!__kIOHIDEventQueueTypeID)
  {
    if (__queueTypeInit_0 != -1)
      dispatch_once(&__queueTypeInit_0, &__block_literal_global_10);
    return __kIOHIDEventQueueTypeID;
  }
  return result;
}

uint64_t IOHIDAnalyticsHistogramEventCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (__loadFramework_haOnce_0 != -1)
    dispatch_once(&__loadFramework_haOnce_0, &__block_literal_global_17);
  if (createHistogramEventFuncPtr)
    return createHistogramEventFuncPtr(a1, a2, a3, a4, a5);
  else
    return 0;
}

uint64_t _IOHIDEventSystemConnectionSetQueue(uint64_t a1, uint64_t a2)
{
  const void *v4;
  unsigned int v5;
  unsigned int *v6;
  kern_return_t v7;
  mach_error_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  const void *v19;
  _QWORD v21[5];
  _QWORD handler[5];

  os_unfair_recursive_lock_lock_with_options();
  v4 = *(const void **)(a1 + 24);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(a1 + 24) = a2;
  if (a2)
  {
    v6 = (unsigned int *)(a1 + 104);
    v5 = *(_DWORD *)(a1 + 104);
    if (v5)
      goto LABEL_10;
    v7 = mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, (mach_port_name_t *)(a1 + 104));
    if (v7)
    {
      v8 = v7;
      v9 = _IOHIDLogCategory(9u);
      v10 = (int)v9;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        _IOHIDEventSystemConnectionReleasePrivate_cold_3(a1, v8, v10, v11, v12, v13, v14, v15);
      __IOHIDEventSystemConnectionCheckServerStatus(v8, a1);
    }
    v5 = *v6;
    if (*v6)
    {
LABEL_10:
      v16 = dispatch_source_create(MEMORY[0x1E0C80D98], v5, 0, *(dispatch_queue_t *)(a1 + 96));
      *(_QWORD *)(a1 + 112) = v16;
      if (!v16)
        goto LABEL_12;
    }
    else
    {
      v16 = *(NSObject **)(a1 + 112);
      if (!v16)
      {
LABEL_12:
        *(_DWORD *)(a1 + 128) = 1;
        v19 = *(const void **)(a1 + 24);
        if (v19)
          CFRetain(v19);
        return os_unfair_recursive_lock_unlock();
      }
    }
    v17 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = ___IOHIDEventSystemConnectionSetQueue_block_invoke;
    handler[3] = &__block_descriptor_tmp_19_2;
    handler[4] = a1;
    dispatch_source_set_event_handler(v16, handler);
    CFRetain((CFTypeRef)a1);
    v18 = *(NSObject **)(a1 + 112);
    v21[0] = v17;
    v21[1] = 0x40000000;
    v21[2] = ___IOHIDEventSystemConnectionSetQueue_block_invoke_20;
    v21[3] = &__block_descriptor_tmp_21;
    v21[4] = a1;
    dispatch_source_set_cancel_handler(v18, v21);
    dispatch_resume(*(dispatch_object_t *)(a1 + 112));
    goto LABEL_12;
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueSetNotificationPort(uint64_t a1, int a2)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 144) == 1)
  {
    *(_QWORD *)(a1 + 60) = 0x1800000013;
    *(_DWORD *)(a1 + 68) = a2;
  }
  *(_DWORD *)(a1 + 96) = a2;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueGetMemoryHandle(uint64_t a1)
{
  uint64_t v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(unsigned int *)(a1 + 84);
  os_unfair_recursive_lock_unlock();
  return v2;
}

void IOMIGMachPortScheduleWithRunLoop(CFTypeRef cf, CFRunLoopRef rl, CFRunLoopMode mode)
{
  __CFRunLoopSource *RunLoopSource;
  const __CFAllocator *v7;

  *((_QWORD *)cf + 2) = rl;
  *((_QWORD *)cf + 3) = mode;
  if (rl)
  {
    if (mode)
    {
      RunLoopSource = (__CFRunLoopSource *)*((_QWORD *)cf + 7);
      if (RunLoopSource
        || (v7 = CFGetAllocator(cf),
            RunLoopSource = CFMachPortCreateRunLoopSource(v7, *((CFMachPortRef *)cf + 6), 1),
            (*((_QWORD *)cf + 7) = RunLoopSource) != 0))
      {
        CFRunLoopAddSource(rl, RunLoopSource, mode);
      }
    }
  }
}

uint64_t __IOHIDServiceInit(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  IONotificationPort *v8;
  io_service_t v9;
  const __CFAllocator *v10;
  CFMutableSetRef v11;
  const __CFAllocator *v12;
  CFMutableSetRef v13;
  const __CFAllocator *v14;
  CFMutableSetRef v15;
  const __CFAllocator *v16;
  CFNumberRef v17;
  const __CFAllocator *v18;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v20;
  CFMutableDictionaryRef v21;
  uint64_t i;
  const __CFAllocator *v23;
  CFMutableArrayRef v24;
  const __CFAllocator *v25;
  CFMutableSetRef v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  const __CFAllocator *v30;
  CFMutableArrayRef v31;
  const void *v32;
  const void *v33;
  CFTypeRef *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  CFMutableDictionaryRef v38;
  __CFDictionary *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  const __CFArray *v50;
  const __CFArray *v51;
  CFIndex v52;
  __CFBundle *ValueAtIndex;
  const __CFArray *v54;
  const __CFArray *v55;
  CFIndex v56;
  const __CFUUID *v57;
  const __CFAllocator *v58;
  CFTypeRef v59;
  const void *v60;
  NSObject *v61;
  uint64_t v62;
  const __CFArray *v63;
  const __CFArray *v64;
  CFIndex v65;
  __CFBundle *v66;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *v68;
  const __CFDictionary *Value;
  const __CFDictionary *v70;
  CFTypeID v71;
  const void *v72;
  const void *v73;
  CFTypeID v74;
  const __CFString *v75;
  const __CFString *v76;
  void *DataPointerForName;
  void *v78;
  const __CFString *v79;
  NSObject *v80;
  NSObject *v81;
  uint64_t v82;
  const __CFString *v83;
  NSObject *v84;
  const __CFArray *v85;
  const __CFArray *v86;
  const __CFNumber *v87;
  CFTypeRef *v88;
  const __CFNumber *v89;
  CFTypeID v90;
  const __CFNumber *v91;
  const __CFNumber *v92;
  CFTypeID v93;
  const void *v94;
  const void *v95;
  const void *v96;
  const void *v97;
  const __CFNumber *v98;
  const __CFNumber *v99;
  CFTypeID v100;
  const __CFNumber *v101;
  const __CFNumber *v102;
  CFTypeID v103;
  CFTypeID TypeID;
  int v105;
  const __CFNumber *v106;
  const __CFNumber *v107;
  CFTypeID v108;
  const __CFNumber *v109;
  const __CFNumber *v110;
  CFTypeID v111;
  const __CFString *v112;
  const __CFString *v113;
  CFTypeID v114;
  const void *v115;
  const void *v116;
  CFTypeID v117;
  const __CFAllocator *v118;
  __CFArray *v119;
  CFTypeID v120;
  NSObject *v121;
  uint64_t v122;
  uint64_t v123;
  NSObject *v125;
  const void *v126;
  uint64_t v127;
  const __CFAllocator *alloc;
  uint64_t *v129;
  _QWORD v130[5];
  _QWORD block[5];
  CFSetCallBacks callBacks;
  uint64_t valuePtr;
  uint64_t v134;
  _BYTE buf[66];
  pthread_mutexattr_t v136;
  io_name_t name;
  char v138[16];
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  uint64_t v154;
  CFRange v155;
  CFRange v156;

  v2 = a2;
  v154 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v152 = 0u;
  v153 = 0u;
  v150 = 0u;
  v151 = 0u;
  v148 = 0u;
  v149 = 0u;
  v146 = 0u;
  v147 = 0u;
  v144 = 0u;
  v145 = 0u;
  v142 = 0u;
  v143 = 0u;
  v140 = 0u;
  v141 = 0u;
  *(_OWORD *)v138 = 0u;
  v139 = 0u;
  memset(name, 0, sizeof(name));
  v4 = mach_absolute_time();
  __sprintf_chk(v138, 0, 0x100uLL, "0x%llx", v2);
  *(_QWORD *)(a1 + 400) = v2;
  IORegistryEntryGetName(*(_DWORD *)(a1 + 16), name);
  if (!name[0])
  {
    IOObjectGetClass(*(_DWORD *)(a1 + 16), name);
    v2 = valuePtr;
  }
  __sprintf_chk(v138, 0, 0x100uLL, "IOHIDService(%p) id:0x%llx name:%s", (const void *)a1, v2, name);
  v5 = malloc_type_calloc(1uLL, 0x48uLL, 0x10000400131AABDuLL);
  *(_QWORD *)(a1 + 72) = v5;
  if (v5)
  {
    *(_DWORD *)(a1 + 456) = 0;
    v136.__sig = 0;
    *(_QWORD *)v136.__opaque = 0;
    if (pthread_mutexattr_init(&v136))
      __IOHIDServiceInit_cold_4(&v134, buf);
    pthread_mutexattr_settype(&v136, 2);
    if (pthread_mutex_init((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8), &v136))
      __IOHIDServiceInit_cold_3(&v134, buf);
    pthread_mutexattr_destroy(&v136);
    v6 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v7 = hid_dispatch_queue_create_with_context_destructor(v138, v6, kIOHIDServiceInterruptWorkloop, (uint64_t)__IOHIDServiceQueueWillExecute, (uint64_t)__IOHIDServiceQueueDidExecute, *(_QWORD *)(a1 + 72), __IOHIDServiceQueueContextDestructor);
    *(_QWORD *)(a1 + 80) = v7;
    if (v7)
    {
      v8 = IONotificationPortCreate(0);
      *(_QWORD *)(a1 + 88) = v8;
      if (v8)
      {
        v129 = (uint64_t *)(a1 + 400);
        v9 = *(_DWORD *)(a1 + 16);
        if (v9
          && IOServiceAddInterestNotification(v8, v9, "IOGeneralInterest", (IOServiceInterestCallback)__IOHIDServiceNotification, (void *)a1, (io_object_t *)(a1 + 96)))
        {
          v125 = _IOHIDLogCategory(6u);
          if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
            __IOHIDServiceInit_cold_2();
        }
        else
        {
          callBacks = *(CFSetCallBacks *)byte_1E2002E10;
          v10 = CFGetAllocator((CFTypeRef)a1);
          v11 = CFSetCreateMutable(v10, 0, &callBacks);
          *(_QWORD *)(a1 + 104) = v11;
          if (v11)
          {
            v12 = CFGetAllocator((CFTypeRef)a1);
            v13 = CFSetCreateMutable(v12, 0, &callBacks);
            *(_QWORD *)(a1 + 112) = v13;
            if (v13)
            {
              v14 = CFGetAllocator((CFTypeRef)a1);
              v15 = CFSetCreateMutable(v14, 0, &callBacks);
              *(_QWORD *)(a1 + 120) = v15;
              if (v15)
              {
                v16 = CFGetAllocator((CFTypeRef)a1);
                v17 = CFNumberCreate(v16, kCFNumberSInt64Type, &valuePtr);
                *(_QWORD *)(a1 + 48) = v17;
                if (v17)
                {
                  v18 = CFGetAllocator((CFTypeRef)a1);
                  Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  *(_QWORD *)(a1 + 240) = Mutable;
                  if (Mutable)
                  {
                    v20 = CFGetAllocator((CFTypeRef)a1);
                    v21 = CFDictionaryCreateMutable(v20, 15, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    *(_QWORD *)(a1 + 312) = v21;
                    if (v21)
                    {
                      for (i = 0; i != 15; ++i)
                        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 312), _servicePropertyCacheKeys[i], (const void *)defaultPropertyKeyValue);
                      v23 = CFGetAllocator((CFTypeRef)a1);
                      v24 = CFArrayCreateMutable(v23, 0, MEMORY[0x1E0C9B378]);
                      *(_QWORD *)(a1 + 248) = v24;
                      if (v24)
                      {
                        v25 = CFGetAllocator((CFTypeRef)a1);
                        v26 = CFSetCreateMutable(v25, 0, MEMORY[0x1E0C9B3B0]);
                        *(_QWORD *)(a1 + 264) = v26;
                        if (v26)
                        {
                          v27 = malloc_type_malloc(0x18uLL, 0xC0040B8AA526DuLL);
                          *(_QWORD *)(a1 + 368) = v27;
                          if (v27)
                          {
                            *v27 = 0;
                            v27[1] = 0;
                            v27[2] = 0;
                            v28 = malloc_type_malloc(0x158uLL, 0x100004000313F17uLL);
                            *(_QWORD *)(a1 + 416) = v28;
                            if (v28)
                            {
                              v28[42] = 0;
                              *((_OWORD *)v28 + 19) = 0u;
                              *((_OWORD *)v28 + 20) = 0u;
                              *((_OWORD *)v28 + 17) = 0u;
                              *((_OWORD *)v28 + 18) = 0u;
                              *((_OWORD *)v28 + 15) = 0u;
                              *((_OWORD *)v28 + 16) = 0u;
                              *((_OWORD *)v28 + 13) = 0u;
                              *((_OWORD *)v28 + 14) = 0u;
                              *((_OWORD *)v28 + 11) = 0u;
                              *((_OWORD *)v28 + 12) = 0u;
                              *((_OWORD *)v28 + 9) = 0u;
                              *((_OWORD *)v28 + 10) = 0u;
                              *((_OWORD *)v28 + 7) = 0u;
                              *((_OWORD *)v28 + 8) = 0u;
                              *((_OWORD *)v28 + 5) = 0u;
                              *((_OWORD *)v28 + 6) = 0u;
                              *((_OWORD *)v28 + 3) = 0u;
                              *((_OWORD *)v28 + 4) = 0u;
                              *((_OWORD *)v28 + 1) = 0u;
                              *((_OWORD *)v28 + 2) = 0u;
                              *(_OWORD *)v28 = 0u;
                              *(_QWORD *)(a1 + 272) = 0;
                              *(_DWORD *)(a1 + 292) = 0;
                              v29 = MEMORY[0x1E0C809B0];
                              *(_DWORD *)(a1 + 288) = 0;
                              block[0] = v29;
                              block[1] = 0x40000000;
                              block[2] = ____IOHIDServiceInit_block_invoke;
                              block[3] = &__block_descriptor_tmp_141;
                              block[4] = a1;
                              *(_QWORD *)(a1 + 424) = dispatch_block_create((dispatch_block_flags_t)0, block);
                              v130[0] = v29;
                              v130[1] = 0x40000000;
                              v130[2] = ____IOHIDServiceInit_block_invoke_2;
                              v130[3] = &__block_descriptor_tmp_142_0;
                              v130[4] = a1;
                              *(_QWORD *)(a1 + 432) = dispatch_block_create((dispatch_block_flags_t)0, v130);
                              v30 = CFGetAllocator((CFTypeRef)a1);
                              v31 = CFArrayCreateMutable(v30, 0, MEMORY[0x1E0C9B378]);
                              *(_QWORD *)(a1 + 256) = v31;
                              if (v31)
                              {
                                *(_DWORD *)(a1 + 172) = 1;
                                v32 = (const void *)*MEMORY[0x1E0C9B0D0];
                                v33 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("Built-In"), (const void *)*MEMORY[0x1E0C9B0D0]);
                                v34 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
                                if (v33)
                                {
                                  v35 = v33;
                                  *(_DWORD *)(a1 + 284) = CFEqual(v33, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
                                  CFRelease(v35);
                                }
                                v36 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("Hidden"), v32);
                                if (v36)
                                {
                                  v37 = v36;
                                  *(_DWORD *)(a1 + 300) = CFEqual(v36, *v34);
                                  CFRelease(v37);
                                }
                                alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                                v38 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                                if (v38)
                                {
                                  v39 = v38;
                                  v40 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("DeviceUsagePairs"), v32);
                                  if (v40)
                                  {
                                    v41 = v40;
                                    CFDictionaryAddValue(v39, CFSTR("DeviceUsagePairs"), v40);
                                    CFRelease(v41);
                                  }
                                  v42 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("Transport"), v32);
                                  if (v42)
                                  {
                                    v43 = v42;
                                    CFDictionaryAddValue(v39, CFSTR("Transport"), v42);
                                    CFRelease(v43);
                                  }
                                  v44 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("ProductID"), v32);
                                  if (v44)
                                  {
                                    v45 = v44;
                                    CFDictionaryAddValue(v39, CFSTR("ProductID"), v44);
                                    CFRelease(v45);
                                  }
                                  v46 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("VendorID"), v32);
                                  if (v46)
                                  {
                                    v47 = v46;
                                    CFDictionaryAddValue(v39, CFSTR("VendorID"), v46);
                                    CFRelease(v47);
                                  }
                                  v48 = *(_QWORD *)(a1 + 464);
                                  if (!v48)
                                  {
                                    v48 = IOHIDAnalyticsEventCreate((uint64_t)CFSTR("com.apple.hid.analytics.service"), (uint64_t)v39);
                                    *(_QWORD *)(a1 + 464) = v48;
                                  }
                                  *(_OWORD *)buf = xmmword_18AB470B0;
                                  v49 = *(_QWORD *)(a1 + 472);
                                  if (!v49)
                                  {
                                    v49 = IOHIDAnalyticsHistogramEventCreate((uint64_t)CFSTR("com.apple.hid.analytics.service.dispatchEvent"), (uint64_t)v39, (uint64_t)CFSTR("LatencyDispatchEvent"), (uint64_t)buf, 1);
                                    *(_QWORD *)(a1 + 472) = v49;
                                    v48 = *(_QWORD *)(a1 + 464);
                                  }
                                  if (v48)
                                  {
                                    IOHIDAnalyticsEventAddHistogramField(v48, (uint64_t)CFSTR("LatencyServiceInit"), (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(_QWORD *)(a1 + 464), (uint64_t)CFSTR("LatencyServiceOpen"), (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(_QWORD *)(a1 + 464), (uint64_t)CFSTR("LatencyCopyProperty"), (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(_QWORD *)(a1 + 464), (uint64_t)CFSTR("LatencySetProperty"), (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(_QWORD *)(a1 + 464), (uint64_t)CFSTR("LatencyCopyEvent"), (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventActivate();
                                    v49 = *(_QWORD *)(a1 + 472);
                                  }
                                  if (v49)
                                    IOHIDAnalyticsEventActivate();
                                  CFRelease(v39);
                                }
                                v126 = v32;
                                v127 = v4;
                                v50 = (const __CFArray *)_IOHIDLoadBundles();
                                if (v50)
                                {
                                  v51 = v50;
                                  if (CFArrayGetCount(v50) >= 1)
                                  {
                                    v52 = 0;
                                    do
                                    {
                                      ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v51, v52);
                                      v54 = __IOHIDServicePassiveMatchToFilterPlugin(a1, ValueAtIndex);
                                      if (v54)
                                      {
                                        v55 = v54;
                                        if (CFArrayGetCount(v54) >= 1)
                                        {
                                          v56 = 0;
                                          do
                                          {
                                            v57 = (const __CFUUID *)CFArrayGetValueAtIndex(v55, v56);
                                            v58 = CFGetAllocator((CFTypeRef)a1);
                                            v59 = IOHIDServiceFilterCreate(v58, a1, ValueAtIndex, v57);
                                            if (v59)
                                            {
                                              v60 = v59;
                                              v61 = _IOHIDLogCategory(0);
                                              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                                              {
                                                v62 = *v129;
                                                *(_DWORD *)buf = 138412546;
                                                *(_QWORD *)&buf[4] = v60;
                                                *(_WORD *)&buf[12] = 2048;
                                                *(_QWORD *)&buf[14] = v62;
                                                _os_log_impl(&dword_18AAAF000, v61, OS_LOG_TYPE_DEFAULT, "Add filter:%@ for service:0x%llx", buf, 0x16u);
                                              }
                                              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 248), v60);
                                              if (!IOHIDServiceFilterGetType((uint64_t)v60))
                                                CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 256), v60);
                                              CFRelease(v60);
                                            }
                                            ++v56;
                                          }
                                          while (v56 < CFArrayGetCount(v55));
                                        }
                                        CFRelease(v55);
                                      }
                                      ++v52;
                                    }
                                    while (v52 < CFArrayGetCount(v51));
                                  }
                                }
                                v63 = (const __CFArray *)_IOHIDLoadServiceFilterBundles();
                                if (v63)
                                {
                                  v64 = v63;
                                  if (CFArrayGetCount(v63) >= 1)
                                  {
                                    v65 = 0;
                                    while (1)
                                    {
                                      v134 = 0;
                                      v66 = (__CFBundle *)CFArrayGetValueAtIndex(v64, v65);
                                      InfoDictionary = CFBundleGetInfoDictionary(v66);
                                      if (!InfoDictionary)
                                        goto LABEL_80;
                                      v68 = InfoDictionary;
                                      Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, CFSTR("Matching"));
                                      if (Value)
                                      {
                                        v70 = Value;
                                        v71 = CFGetTypeID(Value);
                                        if (v71 == CFDictionaryGetTypeID()
                                          && !_IOHIDServiceMatchPropertyTable(a1, v70, 1))
                                        {
                                          goto LABEL_80;
                                        }
                                      }
                                      v72 = CFDictionaryGetValue(v68, CFSTR("NSPrincipalClass"));
                                      if (!v72)
                                        goto LABEL_80;
                                      v73 = v72;
                                      v74 = CFGetTypeID(v72);
                                      if (v74 != CFStringGetTypeID())
                                        goto LABEL_80;
                                      v75 = CFStringCreateWithFormat(alloc, 0, CFSTR("OBJC_CLASS_$_%@"), v73);
                                      if (!v75)
                                        goto LABEL_80;
                                      v76 = v75;
                                      DataPointerForName = CFBundleGetDataPointerForName(v66, v75);
                                      if (!DataPointerForName)
                                        break;
                                      v78 = DataPointerForName;
                                      CFRelease(v76);
                                      if (objc_msgSend(v78, sel_getUid("matchService:options:score:"), a1, 0, &v134))
                                      {
                                        v79 = (const __CFString *)IOHIDServiceFilterCreateWithClass(alloc, v78, a1, v73, v134);
                                        v80 = _IOHIDLogCategory(0);
                                        v81 = v80;
                                        if (!v79)
                                        {
                                          if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
                                          {
                                            *(_DWORD *)buf = 138412290;
                                            *(_QWORD *)&buf[4] = v68;
                                            _os_log_error_impl(&dword_18AAAF000, v81, OS_LOG_TYPE_ERROR, "IOHIDServiceFilterCreateWithClass failed for bundle %@", buf, 0xCu);
                                          }
                                          goto LABEL_80;
                                        }
                                        if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
                                        {
                                          v82 = *v129;
                                          *(_DWORD *)buf = 138412546;
                                          *(_QWORD *)&buf[4] = v79;
                                          *(_WORD *)&buf[12] = 2048;
                                          *(_QWORD *)&buf[14] = v82;
                                          _os_log_impl(&dword_18AAAF000, v81, OS_LOG_TYPE_DEFAULT, "Add filter:%@ for service:0x%llx", buf, 0x16u);
                                        }
                                        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 248), v79);
                                        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 256), v79);
                                        v83 = v79;
                                        goto LABEL_79;
                                      }
LABEL_80:
                                      if (++v65 >= CFArrayGetCount(v64))
                                        goto LABEL_84;
                                    }
                                    v84 = _IOHIDLogCategory(0);
                                    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                                    {
                                      *(_DWORD *)buf = 138412546;
                                      *(_QWORD *)&buf[4] = v76;
                                      *(_WORD *)&buf[12] = 2112;
                                      *(_QWORD *)&buf[14] = v68;
                                      _os_log_error_impl(&dword_18AAAF000, v84, OS_LOG_TYPE_ERROR, "__IOHIDServiceLoadServiceFilterBundles failed to find symbol %@ for bundle %@", buf, 0x16u);
                                    }
                                    v83 = v76;
LABEL_79:
                                    CFRelease(v83);
                                    goto LABEL_80;
                                  }
                                }
LABEL_84:
                                v85 = *(const __CFArray **)(a1 + 248);
                                v155.length = CFArrayGetCount(v85);
                                v155.location = 0;
                                CFArraySortValues(v85, v155, (CFComparatorFunction)IOHIDServiceFilterCompare, 0);
                                v86 = *(const __CFArray **)(a1 + 256);
                                v156.length = CFArrayGetCount(v86);
                                v156.location = 0;
                                CFArraySortValues(v86, v156, (CFComparatorFunction)IOHIDServiceFilterCompare, 0);
                                v87 = (const __CFNumber *)__IOHIDServiceCopyPropertyForClient(a1, CFSTR("ReportInterval"), 0, 1);
                                v88 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
                                if (v87)
                                {
                                  v89 = v87;
                                  v90 = CFGetTypeID(v87);
                                  if (v90 == CFNumberGetTypeID())
                                  {
                                    CFNumberGetValue(v89, kCFNumberSInt32Type, (void *)(a1 + 168));
                                    *(_DWORD *)(a1 + 160) = *(_DWORD *)(a1 + 168);
                                  }
                                  CFRelease(v89);
                                }
                                v91 = (const __CFNumber *)__IOHIDServiceCopyPropertyForClient(a1, CFSTR("BatchInterval"), 0, 1);
                                v4 = v127;
                                if (v91)
                                {
                                  v92 = v91;
                                  v93 = CFGetTypeID(v91);
                                  if (v93 == CFNumberGetTypeID())
                                    CFNumberGetValue(v92, kCFNumberSInt32Type, (void *)(a1 + 172));
                                  CFRelease(v92);
                                }
                                v94 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("DisplayIntegrated"), v126);
                                if (v94)
                                {
                                  v95 = v94;
                                  *(_DWORD *)(a1 + 280) = CFEqual(v94, *v88);
                                  CFRelease(v95);
                                }
                                else if (IOHIDServiceConformsTo(a1, 13, 4))
                                {
                                  *(_DWORD *)(a1 + 280) = 1;
                                }
                                v96 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("ProtectedAccess"), v126);
                                if (v96)
                                {
                                  v97 = v96;
                                  *(_DWORD *)(a1 + 304) = CFEqual(v96, *v88);
                                  CFRelease(v97);
                                }
                                v98 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("QueueSize"), v126);
                                if (v98)
                                {
                                  v99 = v98;
                                  v100 = CFGetTypeID(v98);
                                  if (v100 == CFNumberGetTypeID())
                                    CFNumberGetValue(v99, kCFNumberSInt32Type, (void *)(a1 + 216));
                                  CFRelease(v99);
                                }
                                v101 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("SensorPropertySupported"), v126);
                                if (v101)
                                {
                                  v102 = v101;
                                  *(_DWORD *)buf = 0;
                                  v103 = CFGetTypeID(v101);
                                  TypeID = CFNumberGetTypeID();
                                  v105 = 0;
                                  if (v103 == TypeID)
                                  {
                                    CFNumberGetValue(v102, kCFNumberSInt32Type, buf);
                                    v105 = buf[0] & 2;
                                  }
                                  *(_DWORD *)(a1 + 296) = v105;
                                  CFRelease(v102);
                                }
                                v106 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("PrimaryUsagePage"), v126);
                                if (v106)
                                {
                                  v107 = v106;
                                  v108 = CFGetTypeID(v106);
                                  if (v108 == CFNumberGetTypeID())
                                    CFNumberGetValue(v107, kCFNumberSInt32Type, (void *)(a1 + 176));
                                  CFRelease(v107);
                                }
                                v109 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("PrimaryUsage"), v126);
                                if (v109)
                                {
                                  v110 = v109;
                                  v111 = CFGetTypeID(v109);
                                  if (v111 == CFNumberGetTypeID())
                                    CFNumberGetValue(v110, kCFNumberSInt32Type, (void *)(a1 + 180));
                                  CFRelease(v110);
                                }
                                v112 = (const __CFString *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("Transport"), v126);
                                if (v112)
                                {
                                  v113 = v112;
                                  v114 = CFGetTypeID(v112);
                                  if (v114 == CFStringGetTypeID())
                                    CFStringGetCString(v113, (char *)(a1 + 184), 32, 0x8000100u);
                                  CFRelease(v113);
                                }
                                *(_QWORD *)(a1 + 56) = _IOHIDServiceCopyPropertyForClient(a1, CFSTR("LocationID"), v126);
                                v115 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, CFSTR("HIDServiceAccessEntitlement"), v126);
                                if (!v115)
                                  goto LABEL_126;
                                v116 = v115;
                                v117 = CFGetTypeID(v115);
                                if (v117 == CFStringGetTypeID())
                                {
                                  v118 = CFGetAllocator((CFTypeRef)a1);
                                  v119 = CFArrayCreateMutable(v118, 0, MEMORY[0x1E0C9B378]);
                                  CFArrayAppendValue(v119, v116);
                                  *(_QWORD *)(a1 + 64) = v119;
                                }
                                else
                                {
                                  v120 = CFGetTypeID(v116);
                                  if (v120 == CFArrayGetTypeID())
                                  {
                                    *(_QWORD *)(a1 + 64) = v116;
LABEL_126:
                                    v122 = 1;
                                    goto LABEL_127;
                                  }
                                  v121 = _IOHIDLogCategory(0);
                                  if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
                                    __IOHIDServiceInit_cold_1((CFNumberRef *)(a1 + 48), v121);
                                }
                                CFRelease(v116);
                                goto LABEL_126;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v122 = 0;
LABEL_127:
  v123 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v123, v4, 0x3E8u);
  if (*(_QWORD *)(a1 + 464))
    IOHIDAnalyticsEventSetIntegerValueForField();
  return v122;
}

CFArrayRef __IOHIDServicePassiveMatchToFilterPlugin(uint64_t a1, CFBundleRef bundle)
{
  CFPlugInRef PlugIn;
  __CFBundle *v4;
  const __CFUUID *v5;
  CFArrayRef FactoriesForPlugInTypeInPlugIn;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *Value;
  const __CFDictionary *v9;
  CFTypeID v10;

  PlugIn = CFBundleGetPlugIn(bundle);
  if (!PlugIn)
    return 0;
  v4 = PlugIn;
  v5 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x6Bu, 3u, 0x40u, 0xD3u, 0x57u, 0x98u, 0x40u, 0x64u, 0xAAu, 0x17u, 0x92u, 4u, 0xC7u, 0xB0u, 0x6Fu, 0xFDu);
  FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(v5, v4);
  if (FactoriesForPlugInTypeInPlugIn)
  {
    InfoDictionary = CFBundleGetInfoDictionary(v4);
    if (InfoDictionary)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, CFSTR("Matching"));
      if (Value)
      {
        v9 = Value;
        v10 = CFGetTypeID(Value);
        if (v10 == CFDictionaryGetTypeID() && !_IOHIDServiceMatchPropertyTable(a1, v9, 1))
        {
          CFRelease(FactoriesForPlugInTypeInPlugIn);
          return 0;
        }
      }
    }
  }
  return FactoriesForPlugInTypeInPlugIn;
}

CFStringRef IOHIDServiceCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t valuePtr;
  char name[136];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  memset(name, 0, 128);
  IORegistryEntryGetName(*(_DWORD *)(a1 + 16), name);
  if (!name[0])
    IOObjectGetClass(*(_DWORD *)(a1 + 16), name);
  v2 = CFGetAllocator((CFTypeRef)a1);
  valuePtr = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, &valuePtr);
  return CFStringCreateWithFormat(v2, 0, CFSTR("IOHIDService name:%s id:0x%llx primaryUsagePage:0x%x primaryUsage:0x%x transport:%s locationID:%@ reportInterval:%d batchInterval:%d events:%d mask:0x%llx"), name, valuePtr, *(unsigned int *)(a1 + 176), *(unsigned int *)(a1 + 180), a1 + 184, *(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 160), *(unsigned int *)(a1 + 164), *(unsigned int *)(a1 + 228), *(_QWORD *)(a1 + 232));
}

uint64_t io_registry_entry_get_name(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _DWORD v13[7];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(v13, 0, sizeof(v13));
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  v6 = 0u;
  v5 = 0u;
  *(_QWORD *)&v4.msgh_bits = 0x1800001513;
  *(_QWORD *)&v4.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v4.msgh_voucher_port = 0xAFA00000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) <= 0xE && ((1 << (v1 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v4.msgh_local_port);
  }
  else if ((_DWORD)v1)
  {
    mig_dealloc_reply_port(v4.msgh_local_port);
  }
  else
  {
    v2 = 4294966995;
    mach_msg_destroy(&v4);
  }
  return v2;
}

uint64_t _IOObjectGetClass(io_registry_entry_t entry, char a2, char *a3)
{
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID v7;
  int CString;

  if ((a2 & 1) == 0)
  {
    v5 = (const __CFString *)IORegistryEntrySearchCFProperty(entry, 0, CFSTR("IOClassNameOverride"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 == CFStringGetTypeID())
      {
        CString = CFStringGetCString(v6, a3, 128, 0x8000100u);
        CFRelease(v6);
        if (CString)
          return 0;
      }
      else
      {
        CFRelease(v6);
      }
    }
  }
  return io_object_get_class(entry);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  const char *CStringPtr;
  const char *v11;
  char *v12;
  int property_bin_buf;
  const char *v14;
  CFIndex Length;
  CFIndex v16;
  char *v17;
  int v18;
  CFTypeRef v19;
  const char *v20;
  size_t v21;
  const char *v22;
  size_t bufferSize;
  CFStringRef errorString;
  mach_vm_address_t address;
  unsigned int size;
  _QWORD size_4[257];

  size_4[256] = *MEMORY[0x1E0C80C00];
  size = 0;
  errorString = 0;
  address = 0;
  bufferSize = 2048;
  CStringPtr = CFStringGetCStringPtr(key, 0);
  if (CStringPtr)
  {
    v11 = CStringPtr;
    v12 = 0;
  }
  else
  {
    Length = CFStringGetLength(key);
    v16 = CFStringGetMaximumSizeForEncoding(Length, 0) + 4;
    v17 = (char *)malloc_type_malloc(v16, 0x1CEEAEE5uLL);
    if (!v17)
      return 0;
    v12 = v17;
    if (!CFStringGetCString(key, v17, v16, 0))
    {
      v18 = -536870212;
LABEL_15:
      free(v12);
      goto LABEL_16;
    }
    v11 = v12;
  }
  if ((gIOKitLibSerializeOptions & 1) != 0)
  {
    if ((options & 1) != 0)
      v14 = plane;
    else
      v14 = (const char *)&unk_18AB45FF0;
    property_bin_buf = io_registry_entry_get_property_bin_buf(entry, v14, v11, options, (uint64_t)size_4, &bufferSize, &address, &size);
  }
  else if ((options & 1) != 0)
  {
    property_bin_buf = io_registry_entry_get_property_recursively(entry, plane, v11, options, &address, &size);
  }
  else
  {
    property_bin_buf = io_registry_entry_get_property(entry, v11);
  }
  v18 = property_bin_buf;
  if (v12)
    goto LABEL_15;
LABEL_16:
  if (v18)
    return 0;
  v20 = (const char *)address;
  if (address)
  {
    v21 = size;
  }
  else
  {
    v21 = bufferSize;
    v20 = (const char *)size_4;
  }
  v19 = IOCFUnserializeWithSize(v20, v21, allocator, 0, &errorString);
  if (!v19 && errorString)
  {
    v22 = CFStringGetCStringPtr(errorString, 0);
    if (v22)
      puts(v22);
    CFRelease(errorString);
  }
  if (address)
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], address, size);
  return v19;
}

uint64_t io_registry_entry_get_property_bin_buf(unsigned int a1, const char *a2, const char *a3, int a4, uint64_t a5, _QWORD *a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t (*v15)(_QWORD, _QWORD, _QWORD);
  int v16;
  uint64_t v17;
  int v18;
  char *v19;
  char *v20;
  char *v21;
  int v22;
  uint64_t v23;
  mach_port_t v24;
  char *v25;
  mach_port_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  mach_port_t reply_port[4];
  _OWORD v32[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v50 = 0;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  *(_OWORD *)reply_port = 0u;
  memset(v32, 0, sizeof(v32));
  *((_QWORD *)&v32[0] + 1) = *MEMORY[0x1E0C804E8];
  v15 = MEMORY[0x1E0C84128];
  if (MEMORY[0x1E0C84128])
    v16 = mig_strncpy_zerofill((char *)&v32[1] + 8, a2, 128);
  else
    v16 = mig_strncpy((char *)&v32[1] + 8, a2, 128);
  LODWORD(v32[1]) = 0;
  DWORD1(v32[1]) = v16;
  v17 = (v16 + 3) & 0xFFFFFFFC;
  v18 = v17 + 68;
  v19 = (char *)reply_port + v17;
  v20 = v19 - 128;
  v21 = v19 + 48;
  if (v15)
    v22 = mig_strncpy_zerofill(v21, a3, 128);
  else
    v22 = mig_strncpy(v21, a3, 128);
  *((_DWORD *)v20 + 42) = 0;
  *((_DWORD *)v20 + 43) = v22;
  v23 = (v22 + 3) & 0xFFFFFFFC;
  v24 = v18 + v23;
  v25 = &v20[v23];
  *((_DWORD *)v25 + 44) = a4;
  *(_QWORD *)(v25 + 180) = a5;
  *(_QWORD *)(v25 + 188) = *a6;
  v26 = mig_get_reply_port();
  reply_port[0] = 5395;
  reply_port[1] = v24;
  *(_QWORD *)&reply_port[2] = __PAIR64__(v26, a1);
  *(_QWORD *)&v32[0] = 0xB4900000000;
  v27 = mach_msg2_internal();
  v28 = v27;
  if ((v27 - 268435458) <= 0xE && ((1 << (v27 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else
  {
    if (!(_DWORD)v27)
    {
      if (DWORD1(v32[0]) == 71)
      {
        v28 = 4294966988;
      }
      else if (DWORD1(v32[0]) == 2989)
      {
        if ((reply_port[0] & 0x80000000) != 0)
        {
          v28 = 4294966996;
          if (DWORD2(v32[0]) == 1 && reply_port[1] == 64 && !reply_port[2] && BYTE7(v32[1]) == 1)
          {
            v29 = DWORD2(v32[1]);
            if (DWORD2(v32[1]) == HIDWORD(v33))
            {
              v28 = 0;
              *a6 = *(_QWORD *)((char *)&v33 + 4);
              *a7 = *(_QWORD *)((char *)v32 + 12);
              *a8 = v29;
              return v28;
            }
          }
        }
        else if (reply_port[1] == 36)
        {
          v28 = 4294966996;
          if (LODWORD(v32[1]))
          {
            if (reply_port[2])
              v28 = 4294966996;
            else
              v28 = LODWORD(v32[1]);
          }
        }
        else
        {
          v28 = 4294966996;
        }
      }
      else
      {
        v28 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v28;
    }
    mig_dealloc_reply_port(reply_port[3]);
  }
  return v28;
}

CFTypeRef IOCFUnserializeWithSize(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  if (errorString)
    *errorString = 0;
  if (!buffer || bufferSize < 4)
    return 0;
  if ((options & 1) != 0 || !strcmp(byte_18AB45C68, buffer) || *(unsigned __int8 *)buffer == 212)
    return IOCFUnserializeBinary(buffer, bufferSize, allocator, options, errorString);
  return IOCFUnserialize(buffer, allocator, options, errorString);
}

kern_return_t IOObjectGetClass(io_object_t object, io_name_t className)
{
  return _IOObjectGetClass(object, 0, className);
}

uint64_t io_object_get_class(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _DWORD v13[7];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(v13, 0, sizeof(v13));
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  v6 = 0u;
  v5 = 0u;
  *(_QWORD *)&v4.msgh_bits = 0x1800001513;
  *(_QWORD *)&v4.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v4.msgh_voucher_port = 0xAF000000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) <= 0xE && ((1 << (v1 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v4.msgh_local_port);
  }
  else if ((_DWORD)v1)
  {
    mig_dealloc_reply_port(v4.msgh_local_port);
  }
  else
  {
    v2 = 4294966995;
    mach_msg_destroy(&v4);
  }
  return v2;
}

uint64_t IOHIDAnalyticsEventAddHistogramField(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int8 a4)
{
  if (addHistogramFieldFuncPtr)
    return addHistogramFieldFuncPtr(result, a2, a3, a4);
  return result;
}

uint64_t IOHIDAnalyticsEventActivate()
{
  uint64_t result;

  if (activateEventFuncPtr)
    return activateEventFuncPtr();
  return result;
}

CFTypeRef IOHIDServiceFilterCreate(const __CFAllocator *a1, uint64_t a2, __CFBundle *a3, const __CFUUID *a4)
{
  uint64_t Private;
  uint64_t v9;
  const __CFAllocator *v10;
  const __CFUUID *v11;
  void *v12;
  const void *v13;
  unsigned int (*v14)(const void *, _QWORD, _QWORD, uint64_t);
  const __CFUUID *v15;
  CFUUIDBytes v16;
  _QWORD *v17;
  unsigned int (*v18)(const void *, _QWORD, _QWORD, uint64_t);
  const __CFUUID *v19;
  CFUUIDBytes v20;
  _QWORD *v21;
  int v22;
  int v23;
  CFStringRef Identifier;
  CFTypeRef v25;

  Private = __IOHIDServiceFilterCreatePrivate(a1);
  if (!Private)
    return 0;
  v9 = Private;
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
  v11 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x6Bu, 3u, 0x40u, 0xD3u, 0x57u, 0x98u, 0x40u, 0x64u, 0xAAu, 0x17u, 0x92u, 4u, 0xC7u, 0xB0u, 0x6Fu, 0xFDu);
  v12 = CFPlugInInstanceCreate(a1, a4, v11);
  if (!v12)
  {
    v25 = 0;
    goto LABEL_17;
  }
  v13 = v12;
  v14 = *(unsigned int (**)(const void *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v12 + 8);
  v15 = CFUUIDGetConstantUUIDWithBytes(v10, 5u, 5u, 0xD7u, 0x8Du, 0x4Fu, 0x4Eu, 0x4Cu, 0x41u, 0xA3u, 0xA6u, 0xC7u, 0xA7u, 0x7Bu, 0x41u, 0xBDu, 0xACu);
  v16 = CFUUIDGetUUIDBytes(v15);
  v17 = (_QWORD *)(v9 + 24);
  if (v14(v13, *(_QWORD *)&v16.byte0, *(_QWORD *)&v16.byte8, v9 + 24))
    *v17 = 0;
  v18 = *(unsigned int (**)(const void *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v13 + 8);
  v19 = CFUUIDGetConstantUUIDWithBytes(v10, 0xC7u, 0x10u, 0x95u, 0x1Du, 0x18u, 0x40u, 0x45u, 0x6Eu, 0x82u, 0xE7u, 0xFCu, 0xA1u, 0xA0u, 0xFAu, 0x7Fu, 0xE4u);
  v20 = CFUUIDGetUUIDBytes(v19);
  v21 = (_QWORD *)(v9 + 16);
  if (v18(v13, *(_QWORD *)&v20.byte0, *(_QWORD *)&v20.byte8, v9 + 16))
  {
    *v21 = 0;
    goto LABEL_7;
  }
  if (!*v21)
  {
LABEL_7:
    if (!*v17)
      goto LABEL_15;
  }
  v22 = IOHIDServiceFilterMatch(v9);
  if (v22)
  {
    v23 = v22;
    *(_QWORD *)(v9 + 48) = a2;
    *(_QWORD *)(v9 + 32) = _IOHIDServiceCopyDispatchQueue(a2);
    *(_DWORD *)(v9 + 40) = v23;
    Identifier = CFBundleGetIdentifier(a3);
    *(_QWORD *)(v9 + 80) = Identifier;
    if (Identifier)
      CFRetain(Identifier);
    v25 = CFRetain((CFTypeRef)v9);
    goto LABEL_16;
  }
  _IOHIDPlugInInstanceCacheAdd(a4, v13);
LABEL_15:
  v25 = 0;
LABEL_16:
  (*(void (**)(const void *))(*(_QWORD *)v13 + 24))(v13);
LABEL_17:
  CFRelease((CFTypeRef)v9);
  return v25;
}

uint64_t __IOHIDServiceFilterCreatePrivate(const __CFAllocator *a1)
{
  uint64_t Instance;
  uint64_t v3;

  if (!__kIOHIDServiceFilterTypeID)
    pthread_once(&__systemFilterClientTypeInit_0, (void (*)(void))__IOHIDServiceFilterRegister);
  Instance = _CFRuntimeCreateInstance();
  v3 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_QWORD *)(Instance + 88) = CFUUIDCreate(a1);
  }
  return v3;
}

uint64_t IOHIDServiceFilterMatch(uint64_t a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*(_QWORD *)v2 + 32);
    if (v3)
      return v3();
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (v4 && (v3 = *(uint64_t (**)(void))(*(_QWORD *)v4 + 32)) != 0)
    return v3();
  else
    return 0;
}

void _IOHIDEventSystemConnectionDispatchEventForVirtualService(uint64_t a1, const void *a2, const void *a3)
{
  const void *Value;
  const void *v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[6];

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 272), a2);
  if (Value)
  {
    v5 = Value;
    v6 = _IOHIDServiceCopyDispatchQueue((uint64_t)Value);
    if (v6)
    {
      v7 = v6;
      CFRetain(v5);
      CFRetain(a3);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 0x40000000;
      v8[2] = ___IOHIDEventSystemConnectionDispatchEventForVirtualService_block_invoke;
      v8[3] = &__block_descriptor_tmp_100;
      v8[4] = v5;
      v8[5] = a3;
      dispatch_async(v7, v8);
      dispatch_release(v7);
    }
  }
}

uint64_t _IOHIDServiceCopyDispatchQueue(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 80);
  if (v1)
    dispatch_retain(*(dispatch_object_t *)(a1 + 80));
  return v1;
}

NSObject *hid_dispatch_queue_create_with_context_destructor(const char *a1, NSObject *a2, NSObject *a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(uint64_t))
{
  dispatch_queue_t v11;
  NSObject *v12;
  _QWORD *v13;

  v11 = dispatch_queue_create_with_target_V2(a1, a2, a3);
  if (v11)
  {
    v12 = v11;
    if (!(a4 | a5))
      return v12;
    v13 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
    if (v13)
    {
      *v13 = a4;
      v13[1] = a5;
      v13[2] = a6;
      v13[3] = a7;
      dispatch_queue_set_specific(v12, &sHIDExecutionCallbacksKey, v13, (dispatch_function_t)__hid_dispatch_queue_context_destructor);
      return v12;
    }
    dispatch_release(v12);
  }
  if (a7)
    a7(a6);
  return 0;
}

void _IOHIDPlugInInstanceCacheAdd(void *key, const void *a2)
{
  __CFDictionary *v4;

  if (a2 && key && __hidPlugInInstanceCache && !CFDictionaryContainsKey((CFDictionaryRef)__hidPlugInInstanceCache, key))
  {
    v4 = (__CFDictionary *)__hidPlugInInstanceCache;
    (*(void (**)(const void *))(*(_QWORD *)a2 + 16))(a2);
    CFDictionarySetValue(v4, key, a2);
  }
}

uint64_t _IOHIDLoadServiceFilterBundles()
{
  if (_IOHIDLoadServiceFilterBundles_onceToken != -1)
    dispatch_once(&_IOHIDLoadServiceFilterBundles_onceToken, &__block_literal_global_20);
  return __hidServiceFilterBundles;
}

uint64_t _IOHIDLoadBundles()
{
  if (_IOHIDLoadBundles_onceToken != -1)
    dispatch_once(&_IOHIDLoadBundles_onceToken, &__block_literal_global_15);
  return __hidPlugInBundles;
}

BOOL IOHIDServiceFilterGetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) == 0;
}

uint64_t IOHIDAnalyticsEventCreate(uint64_t a1, uint64_t a2)
{
  if (__loadFramework_haOnce_0 != -1)
    dispatch_once(&__loadFramework_haOnce_0, &__block_literal_global_17);
  if (createEventFuncPtr)
    return createEventFuncPtr(a1, a2);
  else
    return 0;
}

CFStringRef IOHIDEventSystemConnectionCopyDescription(time_t *cf)
{
  const __CFAllocator *v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  uint64_t v5;
  const char *v6;
  CFStringRef v7;

  if (*((_DWORD *)cf + 74))
  {
    v2 = CFGetAllocator(cf);
    v3 = _IOHIDCreateTimeString(v2, cf + 41);
  }
  else
  {
    v3 = CFSTR("NONE");
  }
  v4 = CFGetAllocator(cf);
  v5 = *((int *)cf + 44);
  if (v5 > 4)
    v6 = "Invalid";
  else
    v6 = off_1E2003688[v5];
  v7 = CFStringCreateWithFormat(v4, 0, CFSTR("IOHIDEventSystemConnection uuid:%@ pid:%d process:%@ type:%s entitlements:0x%x caller:%@ attributes:%@ state:0x%x events:%d mask:0x%llx dropped:%d dropStatus:%d droppedMask:0x%llx lastDroppedTime:%@"), cf[20], *((unsigned int *)cf + 22), cf[19], v6, *(unsigned int *)cf[30], cf[18], cf[23], *((unsigned int *)cf + 66), *((unsigned int *)cf + 78), cf[40], *((unsigned int *)cf + 74), *((unsigned int *)cf + 92), cf[38], v3);
  if (v3)
    CFRelease(v3);
  return v7;
}

HIDEvent *IOHIDEventCreateDigitizerFingerEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13)
{
  return IOHIDEventCreateDigitizerFingerEventWithQuality(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, 5.0, 5.0, 1.0, 1.0, 1.0);
}

HIDEvent *IOHIDEventCreateDigitizerEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, int a14, int a15)
{
  int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  HIDEvent *v29;
  HIDEvent *v30;
  uint64_t EventWithOptions;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  uint8_t v43[16];

  if (a8)
    v25 = 65537;
  else
    v25 = 1;
  v26 = v25 | a15;
  v27 = v25 | a15 | 0x20000;
  if (a7 & 1 | a14)
    v28 = v27;
  else
    v28 = v26;
  v29 = IOHIDEventCreate(a1, 11, a2, v28);
  v30 = v29;
  if (v29)
  {
    EventWithOptions = IOHIDEventGetEventWithOptions(v29, 11, 4026531840);
    if (EventWithOptions)
      *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 40) = a6;
    v32 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v32)
      *(_DWORD *)(*(_QWORD *)(v32 + 104) + 48) = a7;
    v33 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v33)
      *(_DWORD *)(*(_QWORD *)(v33 + 104) + 28) = a4;
    v34 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v34)
      *(_DWORD *)(*(_QWORD *)(v34 + 104) + 32) = a3;
    v35 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v35)
      *(_DWORD *)(*(_QWORD *)(v35 + 104) + 36) = a5;
    v36 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v36)
      *(_DWORD *)(*(_QWORD *)(v36 + 104) + 16) = vcvtd_n_s64_f64(a9, 0x10uLL);
    v37 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v37)
      *(_DWORD *)(*(_QWORD *)(v37 + 104) + 20) = vcvtd_n_s64_f64(a10, 0x10uLL);
    v38 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v38)
      *(_DWORD *)(*(_QWORD *)(v38 + 104) + 24) = vcvtd_n_s64_f64(a11, 0x10uLL);
    v39 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v39)
      *(_DWORD *)(*(_QWORD *)(v39 + 104) + 52) = vcvtd_n_s64_f64(a12, 0x10uLL);
    v40 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v40)
      *(_DWORD *)(*(_QWORD *)(v40 + 104) + 60) = vcvtd_n_s64_f64(a13, 0x10uLL);
  }
  else
  {
    v41 = _IOHIDLog();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v43 = 0;
      _os_log_impl(&dword_18AAAF000, v41, OS_LOG_TYPE_DEFAULT, "IOHIDEventCreateDigitizerEvent event is null", v43, 2u);
    }
  }
  return v30;
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return MakeOneStringProp(CFSTR("IONameMatch"), name);
}

uint64_t IOHIDServiceClientCopyEvent(uint64_t *a1, int a2, const __CFData *a3, int a4)
{
  return _IOHIDEventSystemClientCopyEventForService(a1[1], (IOHIDServiceClientRef)a1, a2, a3, a4);
}

__n64 IOHIDEventGetDoubleValueWithOptions(_QWORD *EventWithOptions, unsigned int a2, uint64_t a3)
{
  unsigned int v4;
  __n64 result;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;

  v4 = HIWORD(a2);
  if (!EventWithOptions || a2 >= 0x10000)
  {
    EventWithOptions = (_QWORD *)IOHIDEventGetEventWithOptions(EventWithOptions, HIWORD(a2), a3);
    if (!EventWithOptions)
    {
      result.n64_f64[0] = 0.0;
      return result;
    }
  }
  result.n64_f64[0] = 0.0;
  v6 = EventWithOptions[13];
  switch(v4)
  {
    case 0u:
      switch(a2)
      {
        case 0u:
          LOBYTE(v6) = *(_BYTE *)(v6 + 8);
          goto LABEL_195;
        case 1u:
          v13 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_204;
        case 2u:
          goto LABEL_21;
        case 3u:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 3) & 1;
          goto LABEL_205;
        case 4u:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 4) & 1;
          goto LABEL_205;
        case 5u:
          v14 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_171;
        case 6u:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 6) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 1u:
      switch(a2)
      {
        case 0x10000u:
          goto LABEL_111;
        case 0x10001u:
          goto LABEL_114;
        case 0x10002u:
          goto LABEL_150;
        case 0x10003u:
          goto LABEL_83;
        default:
          return result;
      }
      return result;
    case 2u:
      switch(a2)
      {
        case 0x20000u:
          goto LABEL_131;
        case 0x20001u:
          goto LABEL_122;
        case 0x20002u:
          goto LABEL_123;
        case 0x20003u:
          goto LABEL_144;
        case 0x20004u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 3u:
      switch(a2)
      {
        case 0x30000u:
          goto LABEL_111;
        case 0x30001u:
          goto LABEL_114;
        case 0x30002u:
          goto LABEL_150;
        case 0x30003u:
          goto LABEL_160;
        case 0x30004u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 28);
          goto LABEL_151;
        case 0x30005u:
          LODWORD(v6) = *(_DWORD *)(v6 + 24);
          goto LABEL_195;
        case 0x30006u:
          v7 = (*(_DWORD *)(v6 + 24) >> 1) & 3;
          goto LABEL_205;
        case 0x30007u:
          v7 = (*(_DWORD *)(v6 + 24) >> 3) & 3;
          goto LABEL_205;
        case 0x30008u:
          v14 = *(_DWORD *)(v6 + 24);
LABEL_171:
          v7 = (v14 >> 5) & 1;
          goto LABEL_205;
        case 0x30009u:
          v7 = (*(_DWORD *)(v6 + 24) >> 6) & 7;
          goto LABEL_205;
        case 0x3000Au:
          v7 = (*(_DWORD *)(v6 + 24) >> 9) & 3;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 4u:
      if (a2 == 262146)
        goto LABEL_137;
      if (a2 == 262145)
        goto LABEL_144;
      if (a2 != 0x40000)
        return result;
      goto LABEL_98;
    case 5u:
      if (a2 == 327682)
        goto LABEL_137;
      if (a2 == 327681)
        goto LABEL_144;
      if (a2 != 327680)
        return result;
      goto LABEL_98;
    case 6u:
      switch(a2)
      {
        case 0x60000u:
          goto LABEL_98;
        case 0x60001u:
          goto LABEL_144;
        case 0x60002u:
          goto LABEL_137;
        case 0x60003u:
LABEL_21:
          v7 = (*(unsigned __int8 *)(v6 + 8) >> 2) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 7u:
      if (a2 == 458754)
        goto LABEL_137;
      if (a2 == 458753)
        goto LABEL_144;
      if (a2 != 458752)
        return result;
      goto LABEL_98;
    case 9u:
      if (a2 == 589826)
      {
LABEL_137:
        v11 = *(_DWORD *)(v6 + 24);
        goto LABEL_145;
      }
      if (a2 == 589825)
        goto LABEL_144;
      if (a2 != 589824)
        return result;
      goto LABEL_98;
    case 0xAu:
      if (a2 - 655360 > 0xB)
        return result;
      if (a2 == 655363)
      {
LABEL_113:
        result.n64_u32[0] = *(_DWORD *)(v6 + 32);
        goto LABEL_151;
      }
      switch(*(_DWORD *)(v6 + 32))
      {
        case 0:
          switch(a2)
          {
            case 0xA0002u:
              goto LABEL_137;
            case 0xA0001u:
              goto LABEL_144;
            case 0xA0000u:
              goto LABEL_98;
          }
          break;
        case 1:
          if (a2 == 655364)
            goto LABEL_131;
          break;
        case 2:
          switch(a2)
          {
            case 0xA0007u:
              goto LABEL_137;
            case 0xA0006u:
              goto LABEL_144;
            case 0xA0005u:
              goto LABEL_98;
          }
          break;
        case 3:
          switch(a2)
          {
            case 0xA0008u:
              goto LABEL_98;
            case 0xA0009u:
              goto LABEL_144;
            case 0xA000Au:
              goto LABEL_137;
            case 0xA000Bu:
              goto LABEL_138;
            default:
              return result;
          }
        default:
          return result;
      }
      return result;
    case 0xBu:
      switch(a2)
      {
        case 0xB0000u:
          goto LABEL_98;
        case 0xB0001u:
          goto LABEL_144;
        case 0xB0002u:
          goto LABEL_137;
        case 0xB0003u:
          goto LABEL_161;
        case 0xB0004u:
          goto LABEL_113;
        case 0xB0005u:
          goto LABEL_107;
        case 0xB0006u:
          goto LABEL_116;
        case 0xB0007u:
          goto LABEL_162;
        case 0xB0008u:
LABEL_160:
          v7 = HIWORD(*(_DWORD *)(v6 + 8)) & 1;
          goto LABEL_205;
        case 0xB0009u:
          v7 = (*(_DWORD *)(v6 + 8) >> 17) & 1;
          goto LABEL_205;
        case 0xB000Au:
          goto LABEL_186;
        case 0xB000Bu:
          goto LABEL_187;
        case 0xB000Cu:
          goto LABEL_207;
        case 0xB000Du:
        case 0xB000Eu:
        case 0xB000Fu:
        case 0xB0010u:
        case 0xB0011u:
        case 0xB0012u:
        case 0xB0013u:
        case 0xB0014u:
        case 0xB0015u:
        case 0xB001Au:
          v8 = *(_DWORD *)(v6 + 64);
          if (v8)
          {
            if (v8 == 2)
            {
              switch(a2)
              {
                case 0xB0011u:
                  goto LABEL_178;
                case 0xB0012u:
                  goto LABEL_179;
                case 0xB0013u:
                  goto LABEL_188;
                case 0xB0014u:
                  goto LABEL_189;
                case 0xB0015u:
LABEL_213:
                  v11 = *(_DWORD *)(v6 + 84);
                  goto LABEL_145;
                case 0xB001Au:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            else if (v8 == 1)
            {
              switch(a2)
              {
                case 0xB000Fu:
                  goto LABEL_178;
                case 0xB0010u:
                  goto LABEL_179;
                case 0xB0011u:
                  goto LABEL_188;
                case 0xB0012u:
                  goto LABEL_189;
                case 0xB0014u:
                  goto LABEL_213;
                case 0xB0015u:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            return result;
          }
          if (a2 == 720910)
            goto LABEL_179;
          if (a2 != 720909)
            return result;
          goto LABEL_178;
        case 0xB0016u:
          v13 = *(_DWORD *)(v6 + 8);
          goto LABEL_204;
        case 0xB0017u:
          if (!*(_DWORD *)(v6 + 32))
            goto LABEL_207;
          return result;
        case 0xB0018u:
          goto LABEL_159;
        case 0xB0019u:
          v7 = (*(_DWORD *)(v6 + 8) >> 19) & 1;
          goto LABEL_205;
        case 0xB001Bu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 92);
          goto LABEL_151;
        case 0xB001Cu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 96);
          goto LABEL_151;
        case 0xB001Du:
          result.n64_u32[0] = *(_DWORD *)(v6 + 100);
          goto LABEL_151;
        case 0xB001Fu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 64);
          goto LABEL_151;
        default:
          return result;
      }
    case 0xCu:
      switch(a2)
      {
        case 0xC0000u:
          goto LABEL_131;
        case 0xC0001u:
          goto LABEL_150;
        case 0xC0002u:
          goto LABEL_83;
        case 0xC0003u:
          goto LABEL_107;
        case 0xC0004u:
          goto LABEL_113;
        case 0xC0005u:
          v9 = *(unsigned __int8 *)(v6 + 36);
          goto LABEL_164;
        case 0xC0006u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 37);
          goto LABEL_151;
        case 0xC0007u:
          goto LABEL_126;
        case 0xC0008u:
          goto LABEL_119;
        case 0xC0009u:
          goto LABEL_120;
        case 0xC000Au:
          goto LABEL_139;
        case 0xC000Bu:
          goto LABEL_140;
        default:
          return result;
      }
      return result;
    case 0xDu:
      switch(a2)
      {
        case 0xD0000u:
          goto LABEL_98;
        case 0xD0001u:
          goto LABEL_144;
        case 0xD0002u:
          goto LABEL_137;
        case 0xD0003u:
          goto LABEL_107;
        case 0xD0004u:
          goto LABEL_113;
        case 0xD0005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0xEu:
      switch(a2)
      {
        case 0xE0000u:
          goto LABEL_111;
        case 0xE0001u:
        case 0xE0003u:
          if (*(_WORD *)(v6 + 18) == 1)
          {
            v10 = 917507;
            goto LABEL_103;
          }
          if (a2 != 917505 || *(_WORD *)(v6 + 18))
            return result;
          goto LABEL_150;
        case 0xE0002u:
          goto LABEL_114;
        default:
          return result;
      }
    case 0xFu:
      if (a2 != 983040)
        return result;
      goto LABEL_98;
    case 0x10u:
      switch(a2)
      {
        case 0x100000u:
          goto LABEL_107;
        case 0x100001u:
          goto LABEL_72;
        case 0x100002u:
          goto LABEL_112;
        case 0x100003u:
          goto LABEL_98;
        case 0x100004u:
          goto LABEL_144;
        case 0x100005u:
          goto LABEL_115;
        case 0x100006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x11u:
      switch(a2)
      {
        case 0x110000u:
          goto LABEL_98;
        case 0x110001u:
          goto LABEL_144;
        case 0x110002u:
          goto LABEL_137;
        case 0x110003u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x12u:
      if (a2 == 1179649)
        goto LABEL_144;
      if (a2 != 1179648)
        return result;
      goto LABEL_131;
    case 0x13u:
      switch(a2)
      {
        case 0x130000u:
          goto LABEL_98;
        case 0x130001u:
          goto LABEL_144;
        case 0x130002u:
          goto LABEL_137;
        case 0x130003u:
          goto LABEL_91;
        case 0x130004u:
          goto LABEL_112;
        case 0x130005u:
          goto LABEL_153;
        case 0x130006u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x14u:
      switch(a2)
      {
        case 0x140000u:
          goto LABEL_98;
        case 0x140001u:
          goto LABEL_144;
        case 0x140002u:
          goto LABEL_137;
        case 0x140003u:
          goto LABEL_107;
        case 0x140004u:
          goto LABEL_113;
        case 0x140005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x15u:
      switch(a2)
      {
        case 0x150000u:
          goto LABEL_98;
        case 0x150001u:
          goto LABEL_144;
        case 0x150002u:
          goto LABEL_137;
        case 0x150003u:
          goto LABEL_107;
        case 0x150004u:
          goto LABEL_113;
        case 0x150005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x17u:
      switch(a2)
      {
        case 0x170000u:
          goto LABEL_107;
        case 0x170001u:
          goto LABEL_72;
        case 0x170002u:
          goto LABEL_112;
        case 0x170003u:
          goto LABEL_98;
        case 0x170004u:
          goto LABEL_144;
        case 0x170005u:
          goto LABEL_115;
        case 0x170006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x18u:
      if (a2 == 1572864)
        goto LABEL_131;
      if (a2 == 1572865)
      {
        v7 = *(unsigned __int16 *)(v6 + 8) >> 15;
LABEL_205:
        result.n64_f64[0] = (double)v7;
      }
      return result;
    case 0x19u:
      if (a2 == 1638402)
      {
LABEL_107:
        result.n64_u32[0] = *(_DWORD *)(v6 + 28);
        goto LABEL_151;
      }
      if (a2 == 1638401)
      {
LABEL_83:
        result.n64_u32[0] = *(_DWORD *)(v6 + 24);
        goto LABEL_151;
      }
      if (a2 != 1638400)
        return result;
      goto LABEL_98;
    case 0x1Au:
      switch(a2)
      {
        case 0x1A0002u:
          goto LABEL_83;
        case 0x1A0001u:
LABEL_109:
          result.n64_u8[0] = *(_BYTE *)(v6 + 20);
          goto LABEL_151;
        case 0x1A0000u:
          goto LABEL_131;
      }
      return result;
    case 0x1Bu:
      switch(a2)
      {
        case 0x1B0000u:
          goto LABEL_107;
        case 0x1B0001u:
          goto LABEL_72;
        case 0x1B0002u:
          goto LABEL_112;
        case 0x1B0003u:
          goto LABEL_98;
        case 0x1B0004u:
          goto LABEL_144;
        case 0x1B0005u:
          goto LABEL_115;
        default:
          return result;
      }
      return result;
    case 0x1Cu:
      switch(a2)
      {
        case 0x1C0000u:
          goto LABEL_107;
        case 0x1C0001u:
LABEL_72:
          result.n64_u16[0] = *(_WORD *)(v6 + 32);
          goto LABEL_151;
        case 0x1C0002u:
          goto LABEL_112;
        case 0x1C0003u:
          goto LABEL_98;
        case 0x1C0004u:
          goto LABEL_144;
        case 0x1C0005u:
LABEL_115:
          result.n64_u16[0] = *(_WORD *)(v6 + 34);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Du:
      switch(a2)
      {
        case 0x1D0000u:
          goto LABEL_131;
        case 0x1D0001u:
          goto LABEL_144;
        case 0x1D0002u:
          result.n64_u16[0] = *(_WORD *)(v6 + 24);
          goto LABEL_151;
        case 0x1D0003u:
          result.n64_u16[0] = *(_WORD *)(v6 + 26);
          goto LABEL_151;
        case 0x1D0004u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 32);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Eu:
      if (a2 == 1966082)
        goto LABEL_83;
      if (a2 == 1966081)
        goto LABEL_144;
      if (a2 != 1966080)
        return result;
      goto LABEL_131;
    case 0x1Fu:
      if (a2 == 2031617)
        goto LABEL_150;
      if (a2 != 2031616)
        return result;
      goto LABEL_98;
    case 0x20u:
      switch(a2)
      {
        case 0x200000u:
          goto LABEL_131;
        case 0x200001u:
          goto LABEL_144;
        case 0x200002u:
          goto LABEL_83;
        case 0x200003u:
          goto LABEL_138;
        default:
          return result;
      }
      return result;
    case 0x21u:
      if (a2 == 2162689)
        goto LABEL_144;
      if (a2 != 2162688)
        return result;
      goto LABEL_131;
    case 0x22u:
      if (a2 == 2228225)
        goto LABEL_144;
      if (a2 != 2228224)
        return result;
      goto LABEL_131;
    case 0x23u:
      switch(a2)
      {
        case 0x230000u:
          goto LABEL_131;
        case 0x230001u:
          goto LABEL_144;
        case 0x230002u:
          goto LABEL_137;
        case 0x230003u:
LABEL_138:
          v11 = *(_DWORD *)(v6 + 28);
          goto LABEL_145;
        case 0x230004u:
LABEL_91:
          v11 = *(_DWORD *)(v6 + 32);
          goto LABEL_145;
        case 0x230005u:
          v11 = *(_DWORD *)(v6 + 44);
          goto LABEL_145;
        case 0x230006u:
          v11 = *(_DWORD *)(v6 + 48);
          goto LABEL_145;
        case 0x230007u:
LABEL_112:
          v11 = *(_DWORD *)(v6 + 36);
          goto LABEL_145;
        case 0x230008u:
LABEL_153:
          v11 = *(_DWORD *)(v6 + 40);
          goto LABEL_145;
        case 0x230009u:
LABEL_178:
          v11 = *(_DWORD *)(v6 + 68);
          goto LABEL_145;
        case 0x23000Au:
LABEL_188:
          v11 = *(_DWORD *)(v6 + 76);
          goto LABEL_145;
        case 0x23000Bu:
LABEL_179:
          v11 = *(_DWORD *)(v6 + 72);
          goto LABEL_145;
        case 0x23000Cu:
LABEL_189:
          v11 = *(_DWORD *)(v6 + 80);
          goto LABEL_145;
        case 0x23000Du:
LABEL_186:
          v11 = *(_DWORD *)(v6 + 52);
          goto LABEL_145;
        case 0x23000Eu:
LABEL_187:
          v11 = *(_DWORD *)(v6 + 56);
          goto LABEL_145;
        case 0x23000Fu:
LABEL_207:
          v11 = *(_DWORD *)(v6 + 60);
          goto LABEL_145;
        case 0x230010u:
          v11 = *(_DWORD *)(v6 + 64);
          goto LABEL_145;
        case 0x230011u:
          LOBYTE(v6) = *(_BYTE *)(v6 + 84);
LABEL_195:
          v7 = v6 & 1;
          goto LABEL_205;
        case 0x230012u:
          v13 = *(unsigned __int8 *)(v6 + 84);
LABEL_204:
          v7 = (v13 >> 1) & 1;
          goto LABEL_205;
        case 0x230013u:
LABEL_190:
          v11 = *(_DWORD *)(v6 + 88);
          goto LABEL_145;
        case 0x230014u:
          v11 = *(_DWORD *)(v6 + 92);
          goto LABEL_145;
        case 0x230015u:
          v11 = *(_DWORD *)(v6 + 96);
          goto LABEL_145;
        case 0x230016u:
          v11 = *(_DWORD *)(v6 + 100);
          goto LABEL_145;
        case 0x230017u:
          v11 = *(_DWORD *)(v6 + 104);
          goto LABEL_145;
        case 0x230018u:
          v11 = *(_DWORD *)(v6 + 108);
          goto LABEL_145;
        default:
          return result;
      }
      return result;
    case 0x24u:
      if (a2 == 2359297)
        goto LABEL_150;
      if (a2 != 2359296)
        return result;
      goto LABEL_98;
    case 0x26u:
      switch(a2)
      {
        case 0x260002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          goto LABEL_151;
        case 0x260001u:
          goto LABEL_144;
        case 0x260000u:
LABEL_98:
          v11 = *(_DWORD *)(v6 + 16);
          goto LABEL_145;
      }
      return result;
    case 0x27u:
      if (a2 - 2555905 >= 2)
      {
        if (a2 != 2555904)
          return result;
LABEL_131:
        result.n64_u32[0] = *(_DWORD *)(v6 + 16);
        goto LABEL_151;
      }
      v12 = *(_DWORD *)(v6 + 16);
      if (v12 != 1)
      {
        if (v12)
        {
          if (a2 != 2555905 || v12 != 2)
            return result;
        }
        else
        {
          v10 = 2555905;
LABEL_103:
          if (a2 != v10)
            return result;
        }
LABEL_150:
        result.n64_u32[0] = *(_DWORD *)(v6 + 20);
LABEL_151:
        result.n64_f64[0] = (double)result.n64_u64[0];
        return result;
      }
      if (a2 == 2555906)
      {
LABEL_144:
        v11 = *(_DWORD *)(v6 + 20);
LABEL_145:
        result.n64_f64[0] = (double)v11 * 0.0000152587891;
        if (v11 == 0x80000000)
          result.n64_f64[0] = NAN;
      }
      return result;
    case 0x28u:
      switch(a2)
      {
        case 0x280000u:
          result.n64_u16[0] = *(_WORD *)(v6 + 64);
          goto LABEL_151;
        case 0x280001u:
          result.n64_u16[0] = *(_WORD *)(v6 + 66);
          goto LABEL_151;
        case 0x280002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 16);
          break;
        case 0x280003u:
LABEL_122:
          result.n64_u8[0] = *(_BYTE *)(v6 + 24);
          goto LABEL_151;
        case 0x280004u:
LABEL_123:
          result.n64_u8[0] = *(_BYTE *)(v6 + 25);
          goto LABEL_151;
        case 0x280005u:
          goto LABEL_107;
        case 0x280006u:
          goto LABEL_113;
        case 0x280007u:
LABEL_116:
          result.n64_u32[0] = *(_DWORD *)(v6 + 36);
          goto LABEL_151;
        case 0x280008u:
          result.n64_u8[0] = *(_BYTE *)(v6 + 44);
          goto LABEL_151;
        case 0x280009u:
LABEL_161:
          result.n64_u32[0] = *(_DWORD *)(v6 + 48);
          goto LABEL_151;
        case 0x28000Au:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          goto LABEL_151;
        case 0x28000Bu:
          result.n64_u8[0] = *(_BYTE *)(v6 + 26);
          goto LABEL_151;
        case 0x28000Cu:
LABEL_162:
          result.n64_u32[0] = *(_DWORD *)(v6 + 40);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x29u:
      switch(a2)
      {
        case 0x290000u:
          goto LABEL_131;
        case 0x290001u:
          goto LABEL_109;
        case 0x290002u:
          goto LABEL_124;
        case 0x290003u:
          goto LABEL_125;
        case 0x290004u:
LABEL_126:
          result.n64_u64[0] = *(unint64_t *)(v6 + 40);
          break;
        case 0x290005u:
          goto LABEL_119;
        case 0x290006u:
          goto LABEL_120;
        default:
          return result;
      }
      return result;
    case 0x2Au:
      switch(a2)
      {
        case 0x2A0000u:
LABEL_111:
          result.n64_u16[0] = *(_WORD *)(v6 + 16);
          goto LABEL_151;
        case 0x2A0001u:
LABEL_114:
          result.n64_u16[0] = *(_WORD *)(v6 + 18);
          goto LABEL_151;
        case 0x2A0002u:
LABEL_124:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          break;
        case 0x2A0003u:
LABEL_125:
          result.n64_u64[0] = *(unint64_t *)(v6 + 32);
          break;
        case 0x2A0004u:
          v9 = *(unsigned __int8 *)(v6 + 40);
LABEL_164:
          if (v9)
            result.n64_f64[0] = 1.0;
          break;
        case 0x2A0005u:
LABEL_159:
          result.n64_u32[0] = *(_DWORD *)(v6 + 44);
          goto LABEL_151;
        case 0x2A0006u:
LABEL_119:
          result.n64_u64[0] = *(unint64_t *)(v6 + 48);
          break;
        case 0x2A0007u:
LABEL_120:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          break;
        case 0x2A0008u:
LABEL_139:
          result.n64_u64[0] = *(unint64_t *)(v6 + 64);
          break;
        case 0x2A0009u:
LABEL_140:
          result.n64_u64[0] = *(unint64_t *)(v6 + 72);
          break;
        default:
          return result;
      }
      return result;
    default:
      return result;
  }
}

__CFString *__IOHIDEventEventCopyDebugDescWithIndentLevel(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  const __CFString *Name;
  void (*v7)(uint64_t, __CFString *, uint64_t);
  unint64_t Latency;
  __CFString *Mutable;
  __CFString *v10;
  const __CFString *v11;
  const char *v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *v17;
  const __CFString *v18;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v2 = *(_QWORD *)(a1 + 104);
  v3 = *(unsigned int *)(v2 + 4);
  if (v3 > 0x2A)
    return 0;
  Name = IOHIDEventTypeGetName(*(_DWORD *)(v2 + 4));
  v7 = (void (*)(uint64_t, __CFString *, uint64_t))__descriptorCallbacks[v3];
  Latency = IOHIDEventGetLatency(a1, 0x3E8u);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v10 = Mutable;
  if (Mutable)
  {
    if (a2)
    {
      v11 = CFSTR("-----------------------------------------------------------------------\n");
      _IOHIDStringAppendIndendationAndFormat(Mutable, a2, CFSTR("-----------------------------------------------------------------------\n"));
    }
    else
    {
      v11 = CFSTR("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
      _IOHIDStringAppendIndendationAndFormat(Mutable, 0, CFSTR("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
    }
    if (!a2)
    {
      v20 = *(_QWORD *)(a1 + 16);
      v21 = (*(_BYTE *)(a1 + 32) & 0x80) != 0 ? *(_QWORD *)(a1 + 8) : IOHIDEventGetTimeStamp(a1);
      _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s %llu\n"), "Timestamp:", v21);
      v22 = (*(_DWORD *)(a1 + 32) & 0x80) != 0 ? "Continuous" : "Absolute";
      _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s %s\n"), "Timestamp type:", v22);
      _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s %llu us\n"), "Total Latency:", Latency);
      if (v20 >> 33)
      {
        _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%c[1m"), 27);
        _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s 0x%016llX NON KERNEL SENDER\n"), "SenderID:", v20);
        _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%c[0m"), 27, v25);
      }
      else
      {
        _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s 0x%016llX\n"), "SenderID:", v20);
      }
      _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s %ld\n"), "BuiltIn:", ((unint64_t)*(unsigned __int8 *)(*(_QWORD *)(a1 + 104) + 8) >> 4) & 1);
      if (*(_QWORD *)(a1 + 40))
      {
        v23 = *(_QWORD *)(a1 + 88);
        if (v23)
        {
          _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s %ld\n"), "AttributeDataLength:", v23);
          _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%-20.20s "), "AttributeData:");
          if (*(uint64_t *)(a1 + 88) >= 1)
          {
            v24 = 0;
            do
              _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("%02x "), *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + v24++));
            while (v24 < *(_QWORD *)(a1 + 88));
          }
          _IOHIDStringAppendIndendationAndFormat(v10, 0, CFSTR("\n"));
        }
      }
    }
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 104) + 8) & 1) != 0)
      v12 = "Absolute";
    else
      v12 = "Relative";
    _IOHIDStringAppendIndendationAndFormat(v10, a2, CFSTR("%-20.20s %s\n"), "ValueType:", v12);
    _IOHIDStringAppendIndendationAndFormat(v10, a2, CFSTR("%-20.20s %@\n"), "EventType:", Name);
    _IOHIDStringAppendIndendationAndFormat(v10, a2, CFSTR("%-20.20s 0x%x\n"), "Flags:", *(unsigned int *)(*(_QWORD *)(a1 + 104) + 8));
    if (((0x12004400001uLL >> v3) & 1) == 0)
      v7(a1, v10, a2);
    if (*(_QWORD *)(a1 + 72))
    {
      _IOHIDStringAppendIndendationAndFormat(v10, a2, CFSTR("%-20.20s\n"), "ChildEvents:");
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
      if (Count >= 1)
      {
        v14 = Count;
        for (i = 0; i != v14; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
          if (ValueAtIndex)
          {
            v17 = (const __CFString *)__IOHIDEventEventCopyDebugDescWithIndentLevel(ValueAtIndex, a2 + 1);
            if (v17)
            {
              v18 = v17;
              CFStringAppend(v10, v17);
              CFRelease(v18);
            }
          }
        }
      }
    }
    _IOHIDStringAppendIndendationAndFormat(v10, a2, v11);
  }
  return v10;
}

void __IOHIDEventTypeDescriptorDigitizer(_QWORD *a1, __CFString *a2, int a3)
{
  _DWORD *v6;
  uint64_t EventWithOptions;
  unint64_t v8;
  const char *v9;
  int v10;
  uint64_t v11;
  double v12;
  double v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double v18;
  double v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  double v24;
  double v25;
  int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  const char *v33;
  const char *v34;
  const char *v35;
  unsigned int v36;
  const char *v37;
  unsigned int v38;
  const char *v39;
  __n64 v40;
  __n64 v41;
  __n64 v42;
  __n64 v43;
  __n64 v44;
  __n64 v45;
  const char *v46;
  unsigned int v47;
  int v48;
  const char *v49;

  v6 = (_DWORD *)a1[13];
  EventWithOptions = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (EventWithOptions)
    v8 = ((unint64_t)*(unsigned int *)(*(_QWORD *)(EventWithOptions + 104) + 8) >> 1) & 1;
  else
    v8 = 0;
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "DisplayIntegrated:", (v6[2] >> 19) & 1);
  v9 = "Stylus";
  switch(v6[8])
  {
    case 0:
      break;
    case 1:
      v9 = "Puck";
      break;
    case 2:
      if (v8)
        goto LABEL_8;
      v9 = "Finger";
      break;
    case 3:
LABEL_8:
      v9 = "Hand";
      break;
    default:
      v9 = "Unknown";
      break;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %s\n"), "TransducerType:", v9);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "TransducerIndex:", v6[7]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "Identity:", v6[9]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "EventMask:", v6[10]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s "), "Events:");
  v10 = v6[10];
  if ((v10 & 1) != 0)
  {
    _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Range "));
    v10 = v6[10];
    if ((v10 & 2) == 0)
    {
LABEL_12:
      if ((v10 & 4) == 0)
        goto LABEL_13;
      goto LABEL_63;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_12;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Touch "));
  v10 = v6[10];
  if ((v10 & 4) == 0)
  {
LABEL_13:
    if ((v10 & 8) == 0)
      goto LABEL_14;
    goto LABEL_64;
  }
LABEL_63:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Position "));
  v10 = v6[10];
  if ((v10 & 8) == 0)
  {
LABEL_14:
    if ((v10 & 0x10) == 0)
      goto LABEL_15;
    goto LABEL_65;
  }
LABEL_64:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Stop "));
  v10 = v6[10];
  if ((v10 & 0x10) == 0)
  {
LABEL_15:
    if ((v10 & 0x20) == 0)
      goto LABEL_16;
    goto LABEL_66;
  }
LABEL_65:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Peak "));
  v10 = v6[10];
  if ((v10 & 0x20) == 0)
  {
LABEL_16:
    if ((v10 & 0x40) == 0)
      goto LABEL_17;
    goto LABEL_67;
  }
LABEL_66:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Identity "));
  v10 = v6[10];
  if ((v10 & 0x40) == 0)
  {
LABEL_17:
    if ((v10 & 0x80) == 0)
      goto LABEL_18;
    goto LABEL_68;
  }
LABEL_67:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Attribute "));
  v10 = v6[10];
  if ((v10 & 0x80) == 0)
  {
LABEL_18:
    if ((v10 & 0x100) == 0)
      goto LABEL_19;
    goto LABEL_69;
  }
LABEL_68:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Cancel "));
  v10 = v6[10];
  if ((v10 & 0x100) == 0)
  {
LABEL_19:
    if ((v10 & 0x200) == 0)
      goto LABEL_20;
    goto LABEL_70;
  }
LABEL_69:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Start "));
  v10 = v6[10];
  if ((v10 & 0x200) == 0)
  {
LABEL_20:
    if ((v10 & 0x400) == 0)
      goto LABEL_21;
    goto LABEL_71;
  }
LABEL_70:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Resting "));
  v10 = v6[10];
  if ((v10 & 0x400) == 0)
  {
LABEL_21:
    if ((v10 & 0x800) == 0)
      goto LABEL_22;
    goto LABEL_72;
  }
LABEL_71:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("FromEdgeFlat "));
  v10 = v6[10];
  if ((v10 & 0x800) == 0)
  {
LABEL_22:
    if ((v10 & 0x1000) == 0)
      goto LABEL_23;
    goto LABEL_73;
  }
LABEL_72:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("FromEdgeTip "));
  v10 = v6[10];
  if ((v10 & 0x1000) == 0)
  {
LABEL_23:
    if ((v10 & 0x2000) == 0)
      goto LABEL_24;
    goto LABEL_74;
  }
LABEL_73:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("FromCorner "));
  v10 = v6[10];
  if ((v10 & 0x2000) == 0)
  {
LABEL_24:
    if ((v10 & 0x4000) == 0)
      goto LABEL_25;
    goto LABEL_75;
  }
LABEL_74:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("SwipePending "));
  v10 = v6[10];
  if ((v10 & 0x4000) == 0)
  {
LABEL_25:
    if ((v10 & 0x8000) == 0)
      goto LABEL_26;
    goto LABEL_76;
  }
LABEL_75:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("ForcePending "));
  v10 = v6[10];
  if ((v10 & 0x8000) == 0)
  {
LABEL_26:
    if ((v10 & 0x20000) == 0)
      goto LABEL_27;
    goto LABEL_77;
  }
LABEL_76:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("ForceActive "));
  v10 = v6[10];
  if ((v10 & 0x20000) == 0)
  {
LABEL_27:
    if ((v10 & 0x40000) == 0)
      goto LABEL_28;
    goto LABEL_78;
  }
LABEL_77:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("Tap "));
  v10 = v6[10];
  if ((v10 & 0x40000) == 0)
  {
LABEL_28:
    if ((v10 & 0x1000000) == 0)
      goto LABEL_29;
    goto LABEL_79;
  }
LABEL_78:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("SwipeLocked "));
  v10 = v6[10];
  if ((v10 & 0x1000000) == 0)
  {
LABEL_29:
    if ((v10 & 0x2000000) == 0)
      goto LABEL_30;
    goto LABEL_80;
  }
LABEL_79:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("SwipeUp "));
  v10 = v6[10];
  if ((v10 & 0x2000000) == 0)
  {
LABEL_30:
    if ((v10 & 0x4000000) == 0)
      goto LABEL_31;
    goto LABEL_81;
  }
LABEL_80:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("SwipeDown "));
  v10 = v6[10];
  if ((v10 & 0x4000000) == 0)
  {
LABEL_31:
    if ((v10 & 0x8000000) == 0)
      goto LABEL_32;
    goto LABEL_82;
  }
LABEL_81:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("SwipeLeft "));
  v10 = v6[10];
  if ((v10 & 0x8000000) == 0)
  {
LABEL_32:
    if ((v10 & 0x10000000) == 0)
      goto LABEL_33;
    goto LABEL_83;
  }
LABEL_82:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("SwipeRight "));
  v10 = v6[10];
  if ((v10 & 0x10000000) == 0)
  {
LABEL_33:
    if ((v10 & 0x20000000) == 0)
      goto LABEL_34;
LABEL_84:
    _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("EstimatedAzimuth "));
    if ((v6[10] & 0x40000000) == 0)
      goto LABEL_36;
    goto LABEL_35;
  }
LABEL_83:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("EstimatedAltitude "));
  v10 = v6[10];
  if ((v10 & 0x20000000) != 0)
    goto LABEL_84;
LABEL_34:
  if ((v10 & 0x40000000) != 0)
LABEL_35:
    _IOHIDStringAppendIndendationAndFormat(a2, 0, CFSTR("EstimatedPressure "));
LABEL_36:
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("\n"));
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "ButtonMask:", v6[12]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "Range:", HIWORD(v6[2]) & 1);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "Touch:", (v6[2] >> 17) & 1);
  v11 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  v12 = 0.0;
  v13 = 0.0;
  if (v11)
  {
    v14 = *(_DWORD *)(*(_QWORD *)(v11 + 104) + 52);
    v13 = (double)v14 * 0.0000152587891;
    if (v14 == 0x80000000)
      v13 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "Pressure:", *(_QWORD *)&v13);
  v15 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (v15)
  {
    v16 = *(_DWORD *)(*(_QWORD *)(v15 + 104) + 56);
    if (v16 == 0x80000000)
      v12 = NAN;
    else
      v12 = (double)v16 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "AuxiliaryPressure:", *(_QWORD *)&v12);
  v17 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  v18 = 0.0;
  v19 = 0.0;
  if (v17)
  {
    v20 = *(_DWORD *)(*(_QWORD *)(v17 + 104) + 60);
    v19 = (double)v20 * 0.0000152587891;
    if (v20 == 0x80000000)
      v19 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "Twist:", *(_QWORD *)&v19);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %d\n"), "GenerationCount:", v6[23]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %08x\n"), "WillUpdateMask:", v6[24]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %08x\n"), "DidUpdateMask:", v6[25]);
  v21 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (v21)
  {
    v22 = *(_DWORD *)(*(_QWORD *)(v21 + 104) + 16);
    if (v22 == 0x80000000)
      v18 = NAN;
    else
      v18 = (double)v22 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v18);
  v23 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  v24 = 0.0;
  v25 = 0.0;
  if (v23)
  {
    v26 = *(_DWORD *)(*(_QWORD *)(v23 + 104) + 20);
    v25 = (double)v26 * 0.0000152587891;
    if (v26 == 0x80000000)
      v25 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v25);
  v27 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (v27)
  {
    v28 = *(_DWORD *)(*(_QWORD *)(v27 + 104) + 24);
    if (v28 == 0x80000000)
      v24 = NAN;
    else
      v24 = (double)v28 * 0.0000152587891;
  }
  v29 = 720913;
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "Z:", *(_QWORD *)&v24);
  v30 = v6[16];
  if (v30)
  {
    if (v30 == 1)
    {
      v36 = 720911;
      v31 = 720912;
      v32 = 720916;
      v47 = 720914;
      v48 = 720917;
      v49 = "MinorRadius:";
      v33 = "MajorRadius:";
      v46 = "Density:";
      v34 = "Quality:";
      v35 = "Azimuth:";
      v37 = "Altitude:";
    }
    else
    {
      if (v30 != 2)
        return;
      v31 = 720914;
      v32 = 720917;
      v47 = 720916;
      v48 = 720922;
      v29 = 720915;
      v49 = "Accuracy:";
      v33 = "MinorRadius:";
      v46 = "MajorRadius:";
      v34 = "Irregularity:";
      v35 = "Density:";
      v36 = 720913;
      v37 = "Quality:";
    }
    v40.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v36, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), v37, v40.n64_u64[0]);
    v41.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v31, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), v35, v41.n64_u64[0]);
    v42.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v29, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), v34, v42.n64_u64[0]);
    v43.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v47, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), v46, v43.n64_u64[0]);
    v39 = v49;
    v38 = v48;
  }
  else
  {
    v32 = 720909;
    v38 = 720910;
    v39 = "TiltY:";
    v33 = "TiltX:";
  }
  v44.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v32, 4026531840).n64_u64[0];
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), v33, v44.n64_u64[0]);
  v45.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v38, 4026531840).n64_u64[0];
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), v39, v45.n64_u64[0]);
}

void _IOHIDStringAppendIndendationAndFormat(CFMutableStringRef theString, int a2, CFStringRef format, ...)
{
  int v5;
  va_list va;

  va_start(va, format);
  if (a2)
  {
    v5 = a2;
    do
    {
      CFStringAppend(theString, CFSTR("    "));
      --v5;
    }
    while (v5);
  }
  CFStringAppendFormatAndArguments(theString, 0, format, va);
}

void __IOHIDEventTypeDescriptorAxis(uint64_t a1, CFMutableStringRef theString, int a3)
{
  _DWORD *v5;
  int v6;
  double v7;
  int v8;
  double v9;
  int v10;
  double v11;

  v5 = *(_DWORD **)(a1 + 104);
  v6 = v5[4];
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v7);
  v8 = v5[5];
  v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000)
    v9 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v9);
  v10 = v5[6];
  v11 = (double)v10 * 0.0000152587891;
  if (v10 == 0x80000000)
    v11 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Z:", *(_QWORD *)&v11);
}

__CFString *IOHIDEventCopyDescription(uint64_t a1)
{
  return __IOHIDEventEventCopyDebugDescWithIndentLevel(a1, 0);
}

kern_return_t IOConnectCallAsyncScalarMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return IOConnectCallAsyncMethod(connection, selector, wake_port, reference, referenceCnt, input, inputCnt, 0, 0, output, outputCnt, 0, 0);
}

kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  const void *v13;
  int *v16;
  size_t v17;
  unsigned int v18;
  uint64_t v19;
  void *__dst;
  void *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  BOOL v24;
  uint32_t v25;
  void *v26;
  kern_return_t result;
  size_t v28;
  size_t v29;
  unsigned int v30;

  v13 = inputStruct;
  v16 = (int *)outputCnt;
  v17 = inputStructCnt;
  v30 = 0;
  v29 = 0;
  if (inputStructCnt <= 0x1000)
  {
    v18 = inputStructCnt;
  }
  else
  {
    LODWORD(inputStruct) = 0;
    v18 = 0;
  }
  if (inputStructCnt <= 0x1000)
    v19 = 0;
  else
    v19 = (uint64_t)v13;
  if (inputStructCnt <= 0x1000)
    v17 = 0;
  if (!outputCnt)
    v16 = (int *)&IOConnectCallAsyncMethod_zero;
  if (outputStructCnt)
  {
    __dst = outputStruct;
    if (*outputStructCnt > 0x1000)
    {
      v21 = outputStruct;
      v29 = *outputStructCnt;
      __dst = 0;
    }
    else
    {
      v21 = 0;
      v30 = *outputStructCnt;
    }
  }
  else
  {
    __dst = 0;
    v21 = 0;
  }
  v22 = reference == 0;
  v23 = referenceCnt == 0;
  v24 = !v22 || !v23;
  if (v22 && v23)
    v25 = 1;
  else
    v25 = referenceCnt;
  if (v24)
    LODWORD(v26) = (_DWORD)reference;
  else
    v26 = &IOConnectCallAsyncMethod_temp_reference;
  result = io_connect_async_method(connection, wake_port, (int)v26, v25, selector, (int)input, inputCnt, (int)inputStruct, v18, v19, v17, __dst, (int *)&v30, output, v16, (uint64_t)v21, &v29);
  if (outputStructCnt)
  {
    if (*outputStructCnt > 0x1000)
      v28 = v29;
    else
      v28 = v30;
    *outputStructCnt = v28;
  }
  return result;
}

uint64_t io_connect_async_method(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned int a9, uint64_t a10, uint64_t a11, void *__dst, int *a13, void *a14, int *a15, uint64_t a16, _QWORD *a17)
{
  unsigned int v17;
  unsigned int v18;
  int v19;
  const void *v20;
  unsigned int v21;
  const void *v22;
  int v23;
  const void *v24;
  unsigned int v25;
  const void *v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  char *v31;
  char *v32;
  size_t v33;
  uint64_t v34;
  char *v36;
  uint64_t v37;
  char *v38;
  int v39;
  int v40;
  int v41;
  mach_port_t v42;
  uint64_t v43;
  BOOL v44;
  int v46;
  unsigned int v47;
  char *v48;
  mach_msg_size_t v49;
  unsigned int v50;
  size_t v51;
  char *v52;
  unsigned int v53;
  const void *v54;
  mach_msg_header_t reply_port;
  int v56;
  int v57;
  size_t __n[2];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;

  v17 = MEMORY[0x1E0C80A78]();
  v88 = *MEMORY[0x1E0C80C00];
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  *(_OWORD *)__n = 0u;
  v59 = 0u;
  memset(&reply_port, 0, sizeof(reply_port));
  v56 = 1;
  v57 = v23;
  HIDWORD(__n[0]) = 1310720;
  __n[1] = *MEMORY[0x1E0C804E8];
  if (v18 <= 8)
  {
    v24 = v22;
    v25 = v21;
    v26 = v20;
    v27 = v19;
    v28 = v18;
    v29 = v17;
    v30 = 8 * v18;
    __memcpy_chk();
    LODWORD(v59) = v28;
    v31 = (char *)&reply_port + v30;
    *(_DWORD *)((char *)&reply_port + v30 + 52) = v27;
    if (v25 <= 0x10)
    {
      v32 = v31 - 64;
      v33 = 8 * v25;
      memcpy(v31 + 60, v26, v33);
      *((_DWORD *)v32 + 30) = v25;
      if (a9 <= 0x1000)
      {
        v36 = &v32[v33];
        v37 = (a9 + 3) & 0xFFFFFFFC;
        v38 = &v36[v37];
        v39 = v30 + v33 + v37;
        memcpy(v36 + 128, v24, a9);
        *((_DWORD *)v36 + 31) = a9;
        *((_QWORD *)v38 + 16) = a10;
        *((_QWORD *)v38 + 17) = a11;
        v40 = *a13;
        if (*a13 >= 0x1000)
          v40 = 4096;
        *((_DWORD *)v38 + 36) = v40;
        v41 = *a15;
        if (*a15 >= 0x10)
          v41 = 16;
        *((_DWORD *)v38 + 37) = v41;
        *((_QWORD *)v38 + 19) = a16;
        *((_QWORD *)v38 + 20) = *a17;
        v42 = mig_get_reply_port();
        reply_port.msgh_bits = -2147478253;
        reply_port.msgh_size = v39 + 104;
        *(_QWORD *)&reply_port.msgh_remote_port = __PAIR64__(v42, v29);
        *(_QWORD *)&reply_port.msgh_voucher_port = 0xB3200000000;
        v43 = mach_msg2_internal();
        v34 = v43;
        if ((v43 - 268435458) <= 0xE && ((1 << (v43 - 2)) & 0x4003) != 0)
        {
          mig_put_reply_port(reply_port.msgh_local_port);
          return v34;
        }
        if ((_DWORD)v43)
        {
          mig_dealloc_reply_port(reply_port.msgh_local_port);
          return v34;
        }
        if (reply_port.msgh_id == 71)
        {
          v34 = 4294966988;
        }
        else if (reply_port.msgh_id == 2966)
        {
          if ((reply_port.msgh_bits & 0x80000000) != 0)
            goto LABEL_31;
          if (reply_port.msgh_size - 4277 <= 0xFFFFEF7E)
          {
            if (reply_port.msgh_remote_port)
              v44 = 1;
            else
              v44 = LODWORD(__n[0]) == 0;
            if (!v44 && reply_port.msgh_size == 36)
              v34 = LODWORD(__n[0]);
            else
              v34 = 4294966996;
            goto LABEL_32;
          }
          if (reply_port.msgh_remote_port)
            goto LABEL_31;
          v34 = LODWORD(__n[0]);
          if (LODWORD(__n[0]))
            goto LABEL_32;
          v46 = HIDWORD(__n[0]);
          if (HIDWORD(__n[0]) > 0x1000)
          {
LABEL_31:
            v34 = 4294966996;
          }
          else
          {
            v34 = 4294966996;
            if (reply_port.msgh_size - 52 >= HIDWORD(__n[0]))
            {
              v47 = (HIDWORD(__n[0]) + 3) & 0xFFFFFFFC;
              if (reply_port.msgh_size >= v47 + 52)
              {
                v48 = (char *)&reply_port + v47;
                v49 = *((_DWORD *)v48 + 10);
                if (v49 <= 0x10 && v49 <= (reply_port.msgh_size - v47 - 52) >> 3)
                {
                  v50 = 8 * v49;
                  if (reply_port.msgh_size - v47 == 8 * v49 + 52)
                  {
                    v51 = *a13;
                    if (HIDWORD(__n[0]) <= v51)
                    {
                      v52 = v48 - 4096;
                      memcpy(__dst, &__n[1], HIDWORD(__n[0]));
                      *a13 = v46;
                      v53 = *((_DWORD *)v52 + 1034);
                      v54 = v52 + 4140;
                      if (v53 <= *a15)
                      {
                        memcpy(a14, v54, 8 * v53);
                        v34 = 0;
                        *a15 = *((_DWORD *)v52 + 1034);
                        *a17 = *(_QWORD *)&v52[v50 + 4140];
                        return v34;
                      }
                      memcpy(a14, v54, (8 * *a15));
                      *a15 = *((_DWORD *)v52 + 1034);
                    }
                    else
                    {
                      memcpy(__dst, &__n[1], v51);
                      *a13 = v46;
                    }
                    return 4294966989;
                  }
                }
              }
            }
          }
        }
        else
        {
          v34 = 4294966995;
        }
LABEL_32:
        mach_msg_destroy(&reply_port);
        return v34;
      }
    }
  }
  return 4294966989;
}

CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps)
{
  if (blob)
    return (CFDictionaryRef)ps;
  else
    return 0;
}

kern_return_t IOCreateReceivePort(uint32_t msgType, mach_port_t *recvPort)
{
  if (msgType == 57 || msgType == 53)
    return mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, recvPort);
  else
    return -536870206;
}

uint64_t IOHIDEventSetTimeStamp(uint64_t result, uint64_t a2)
{
  uint64_t v3;

  v3 = result;
  if (dynLinkrosetta_is_current_process_translated_0[0])
  {
    result = dynLinkrosetta_is_current_process_translated_0[0]();
    if ((_DWORD)result)
    {
      if (dynLinkrosetta_convert_to_system_absolute_time_0[0])
      {
        result = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(a2);
        a2 = result;
      }
    }
  }
  *(_QWORD *)(v3 + 8) = a2;
  *(_DWORD *)(v3 + 32) &= ~0x80u;
  return result;
}

uint64_t _IOHIDServiceInitVirtual(uint64_t a1)
{
  return __IOHIDServiceInit(a1, *(_QWORD *)(a1 + 400));
}

void _IOHIDEventSystemAddService(const void *a1, void *a2)
{
  const __CFAllocator *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  void *values;

  values = a2;
  v3 = CFGetAllocator(a1);
  v4 = CFArrayCreate(v3, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (v4)
  {
    v5 = v4;
    __IOHIDEventSystemAddServices((uint64_t)a1, v4);
    CFRelease(v5);
  }
}

uint64_t IOHIDSessionRemoveService(uint64_t a1, const void *a2)
{
  const __CFAllocator *v4;
  __CFSet *MutableCopy;
  int v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  _OWORD v10[5];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v9, v10);
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 136), a2))
  {
    v4 = CFGetAllocator(*(CFTypeRef *)(a1 + 136));
    MutableCopy = CFSetCreateMutableCopy(v4, 0, *(CFSetRef *)(a1 + 136));
    CFRelease(*(CFTypeRef *)(a1 + 136));
    *(_QWORD *)(a1 + 136) = MutableCopy;
    CFSetRemoveValue(MutableCopy, a2);
    v6 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)v7)
  {
    --*(_DWORD *)v7;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v9, v10);
  }
  if (v6)
    __UnregisterServiceFunction(a2, a1);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v9, v10);
  ++**(_DWORD **)(a1 + 32);
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  result = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDSessionCreate_block_invoke_cold_1(&v9, v10);
  }
  return result;
}

void __UnregisterServiceFunction(const void *a1, uint64_t a2)
{
  const __CFArray *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD context[2];
  _OWORD v8[5];
  uint64_t v9;
  CFRange v10;

  v9 = *MEMORY[0x1E0C80C00];
  CFRetain(a1);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a2 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(context, v8);
  ++**(_DWORD **)(a2 + 32);
  context[0] = a1;
  context[1] = a2;
  v4 = *(const __CFArray **)(a2 + 152);
  v10.length = CFArrayGetCount(v4);
  v10.location = 0;
  CFArrayApplyFunction(v4, v10, (CFArrayApplierFunction)__FilterFunctionUnregisterService, context);
  v5 = *(_QWORD *)(a2 + 32);
  if (*(_DWORD *)v5)
  {
    --*(_DWORD *)v5;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v6, v8);
  }
  _IOHIDServiceUnscheduleAsync((uint64_t)a1);
  _IOHIDServiceClose((uint64_t)a1, a2, 0);
  CFRelease(a1);
}

void _IOHIDServiceClose(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  BOOL v9;
  const __CFArray *v10;
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  void (*v16)(_QWORD, _QWORD, uint64_t);
  _QWORD block[5];
  uint64_t v18;
  __int128 context;
  uint64_t v20;
  uint64_t v21;
  CFRange v22;

  v21 = *MEMORY[0x1E0C80C00];
  _IOHIDDebugTrace(8261, 1, a1, a2, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v18, &context);
  v6 = *(_QWORD *)(a1 + 72);
  v7 = *(_DWORD *)v6 + 1;
  *(_DWORD *)v6 = v7;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
    v9 = v8 == a2;
  else
    v9 = 0;
  if (v9)
  {
    *((_QWORD *)&context + 1) = a2;
    v20 = 0;
    *(_QWORD *)&context = a1;
    v10 = *(const __CFArray **)(a1 + 256);
    v22.length = CFArrayGetCount(v10);
    v22.location = 0;
    CFArrayApplyFunction(v10, v22, (CFArrayApplierFunction)__FilterFunctionClose, &context);
    v11 = *(_QWORD *)(a1 + 32);
    if (v11 && (v12 = *(void (**)(void))(*(_QWORD *)v11 + 40)) != 0
      || (v13 = *(_QWORD *)(a1 + 24)) != 0 && (v12 = *(void (**)(void))(*(_QWORD *)v13 + 40)) != 0)
    {
      v12();
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 360);
      if (v15)
      {
        v16 = *(void (**)(_QWORD, _QWORD, uint64_t))(v15 + 16);
        if (v16)
          v16(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), a3);
      }
    }
    _IOHIDServiceSetEventCallback((_QWORD *)a1, 0, 0, 0);
    CFRelease(*(CFTypeRef *)(a1 + 8));
    *(_QWORD *)(a1 + 8) = 0;
    v6 = *(_QWORD *)(a1 + 72);
    v7 = *(_DWORD *)v6;
  }
  if (v7)
  {
    *(_DWORD *)v6 = v7 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v18, &context);
  }
  CFRetain((CFTypeRef)a1);
  v14 = *(NSObject **)(a1 + 80);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___IOHIDServiceClose_block_invoke;
  block[3] = &__block_descriptor_tmp_60_0;
  block[4] = a1;
  dispatch_async(v14, block);
  _IOHIDDebugTrace(8261, 2, a1, a2, 0, 0);
}

uint64_t __IOHIDServiceVirtualCloseCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID;

  SenderID = _IOHIDServiceGetSenderID(a1);
  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 1, 0);
}

void _IOHIDServiceUnscheduleAsync(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  dispatch_time_t v4;
  NSObject *v5;
  const __CFArray *v6;
  uint64_t v7;
  void (*v8)(void);
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  _QWORD v18[5];
  _QWORD block[5];
  _QWORD handler[5];
  uint64_t v21;
  _OWORD v22[5];
  uint64_t v23;
  CFRange v24;

  v23 = *MEMORY[0x1E0C80C00];
  _IOHIDDebugTrace(8262, 1, a1, 0, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v21, v22);
  ++**(_DWORD **)(a1 + 72);
  v2 = MEMORY[0x1E0C809B0];
  if ((*(_DWORD *)(a1 + 444) || *(_BYTE *)(a1 + 440)) && !*(_QWORD *)(a1 + 448))
  {
    v3 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(a1 + 80));
    *(_QWORD *)(a1 + 448) = v3;
    v4 = dispatch_time(0, 300000000000);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 448), (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 448), (dispatch_function_t)__IOHIDServiceHandleCancelTimerTimeout);
    CFRetain((CFTypeRef)a1);
    v5 = *(NSObject **)(a1 + 448);
    handler[0] = v2;
    handler[1] = 0x40000000;
    handler[2] = ___IOHIDServiceUnscheduleAsync_block_invoke;
    handler[3] = &__block_descriptor_tmp_64;
    handler[4] = a1;
    dispatch_source_set_cancel_handler(v5, handler);
    dispatch_activate(*(dispatch_object_t *)(a1 + 448));
  }
  if (*(_QWORD *)(a1 + 8))
  {
    v6 = *(const __CFArray **)(a1 + 256);
    v24.length = CFArrayGetCount(v6);
    v24.location = 0;
    CFArrayApplyFunction(v6, v24, (CFArrayApplierFunction)__FilterFunctionUnscheduleAsync, 0);
    v7 = *(_QWORD *)(a1 + 32);
    if (v7)
    {
      v8 = *(void (**)(void))(*(_QWORD *)v7 + 80);
      if (v8)
      {
        v8();
        goto LABEL_19;
      }
    }
    v9 = *(_QWORD *)(a1 + 24);
    if (v9)
    {
      v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 80);
      if (v10)
      {
        v11 = qword_1EDF7B4F0;
        v12 = *(_QWORD *)algn_1EDF7B4F8;
LABEL_16:
        v10(v9, v11, v12);
        goto LABEL_19;
      }
    }
    v13 = *(_QWORD *)(a1 + 360);
    if (v13)
    {
      v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 56);
      if (v10)
      {
        v9 = *(_QWORD *)(a1 + 344);
        v11 = *(_QWORD *)(a1 + 352);
        v12 = *(_QWORD *)(a1 + 80);
        goto LABEL_16;
      }
    }
    v14 = *(void **)(a1 + 480);
    if (v14)
      objc_msgSend(v14, *(SEL *)(a1 + 544));
  }
LABEL_19:
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 88), 0);
  v15 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v15)
  {
    --*(_DWORD *)v15;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v21, v22);
  }
  CFRetain((CFTypeRef)a1);
  v16 = *(NSObject **)(a1 + 80);
  block[0] = v2;
  block[1] = 0x40000000;
  block[2] = ___IOHIDServiceUnscheduleAsync_block_invoke_65;
  block[3] = &__block_descriptor_tmp_66_0;
  block[4] = a1;
  dispatch_async(v16, block);
  v17 = *(_QWORD *)(a1 + 24);
  if (v17 && *(_QWORD *)(*(_QWORD *)v17 + 80))
  {
    CFRetain((CFTypeRef)a1);
    v18[0] = v2;
    v18[1] = 0x40000000;
    v18[2] = ___IOHIDServiceUnscheduleAsync_block_invoke_67;
    v18[3] = &__block_descriptor_tmp_68;
    v18[4] = a1;
    CFRunLoopPerformBlock((CFRunLoopRef)qword_1EDF7B4F0, *(CFTypeRef *)algn_1EDF7B4F8, v18);
    CFRunLoopWakeUp((CFRunLoopRef)qword_1EDF7B4F0);
  }
  _IOHIDDebugTrace(8262, 2, a1, 0, 0, 0);
}

CFIndex __IOHIDEventSystemAddServices(uint64_t a1, const __CFArray *a2)
{
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  uint64_t v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  _QWORD *ValueAtIndex;
  NSObject *v11;
  uint64_t RegistryID;
  _QWORD *RemovalNotification;
  __CFDictionary *v14;
  const void *v15;
  __CFDictionary *v16;
  const void *v17;
  NSObject *v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  const __CFAllocator *v22;
  const __CFSet *Copy;
  const __CFAllocator *v24;
  const __CFSet *v25;
  CFIndex result;
  CFIndex v27;
  CFIndex j;
  const void *v29;
  __int128 buf;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = *(_QWORD *)(a1 + 128);
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    v8 = Count;
    for (i = 0; i != v8; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      v11 = _IOHIDLog();
      if (os_signpost_enabled(v11))
      {
        if (ValueAtIndex)
          RegistryID = IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
        else
          RegistryID = 0;
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = RegistryID;
        _os_signpost_emit_with_name_impl(&dword_18AAAF000, v11, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddService", "%@", (uint8_t *)&buf, 0xCu);
      }
      if (ValueAtIndex)
      {
        RemovalNotification = IOHIDServiceCreateRemovalNotification((uint64_t)ValueAtIndex, (uint64_t)__IOHIDEventSystemServiceRemoved, a1, 0);
        if (RemovalNotification)
        {
          os_unfair_recursive_lock_lock_with_options();
          v14 = *(__CFDictionary **)(a1 + 16);
          v15 = (const void *)IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
          CFDictionaryAddValue(v14, v15, ValueAtIndex);
          v16 = *(__CFDictionary **)(a1 + 24);
          v17 = (const void *)IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
          CFDictionarySetValue(v16, v17, RemovalNotification);
          os_unfair_recursive_lock_unlock();
          IOHIDSessionAddService(v6, ValueAtIndex);
          v18 = _IOHIDLogCategory(0);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138543362;
            *(_QWORD *)((char *)&buf + 4) = ValueAtIndex;
            _os_log_impl(&dword_18AAAF000, v18, OS_LOG_TYPE_DEFAULT, "Service added: %{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (Mutable)
          {
            v19 = (const void *)IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
            CFDictionaryAddValue(Mutable, v19, ValueAtIndex);
          }
        }
      }
      else
      {
        RemovalNotification = 0;
      }
      v20 = _IOHIDLog();
      if (os_signpost_enabled(v20))
      {
        if (ValueAtIndex)
          v21 = IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
        else
          v21 = 0;
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = v21;
        _os_signpost_emit_with_name_impl(&dword_18AAAF000, v20, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddService", "%@", (uint8_t *)&buf, 0xCu);
      }
      if (RemovalNotification)
        CFRelease(RemovalNotification);
    }
  }
  os_unfair_recursive_lock_lock_with_options();
  if (CFSetGetCount(*(CFSetRef *)(a1 + 40)))
  {
    v22 = CFGetAllocator(*(CFTypeRef *)(a1 + 40));
    Copy = CFSetCreateCopy(v22, *(CFSetRef *)(a1 + 40));
  }
  else
  {
    Copy = 0;
  }
  v24 = CFGetAllocator((CFTypeRef)a1);
  v25 = CFSetCreateCopy(v24, *(CFSetRef *)(a1 + 432));
  os_unfair_recursive_lock_unlock();
  if (Mutable)
  {
    if (Copy && CFDictionaryGetCount(Mutable))
    {
      *(_QWORD *)&buf = a1;
      *((_QWORD *)&buf + 1) = Mutable;
      CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDEventSystemMatchNotifyFunction, &buf);
    }
    CFRelease(Mutable);
  }
  if (Copy)
    CFRelease(Copy);
  if (v25)
  {
    CFSetApplyFunction(v25, (CFSetApplierFunction)_IOHIDEventSystemConnectionRecordServiceChanged, 0);
    CFRelease(v25);
  }
  result = CFArrayGetCount(a2);
  if (result >= 1)
  {
    v27 = result;
    for (j = 0; j != v27; ++j)
    {
      v29 = CFArrayGetValueAtIndex(a2, j);
      result = __IOHIDServiceOpenedByEventSystem((uint64_t)v29);
    }
  }
  return result;
}

uint64_t _IOHIDLog()
{
  if (_IOHIDLog_onceToken != -1)
    dispatch_once(&_IOHIDLog_onceToken, &__block_literal_global_7);
  return _IOHIDLog_log;
}

_QWORD *IOHIDServiceCreateRemovalNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8;
  _QWORD *v9;
  NSObject *global_queue;
  uint64_t v11;
  _QWORD v13[6];
  uint64_t v14;
  _OWORD v15[5];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v15);
  ++**(_DWORD **)(a1 + 72);
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDServiceNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
  {
    if ((*(_BYTE *)(a1 + 224) & 1) != 0)
    {
      CFRetain((CFTypeRef)a1);
      CFRetain(v9);
      global_queue = dispatch_get_global_queue(0, 0);
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 0x40000000;
      v13[2] = __IOHIDServiceCreateRemovalNotification_block_invoke;
      v13[3] = &__block_descriptor_tmp_61;
      v13[4] = v9;
      v13[5] = a1;
      dispatch_async(global_queue, v13);
    }
    else
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 104), v9);
    }
  }
  v11 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v11)
  {
    --*(_DWORD *)v11;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v15);
  }
  return v9;
}

uint64_t __IOHIDServiceOpenedByEventSystem(uint64_t a1)
{
  uint64_t result;
  uint64_t valuePtr;

  result = _IOHIDServiceSetPropertyForClient(a1, CFSTR("DeviceOpenedByEventSystem"), (const void *)*MEMORY[0x1E0C9AE50], (CFTypeRef)*MEMORY[0x1E0C9B0D0]);
  if (*(_QWORD *)(a1 + 336))
  {
    valuePtr = 0;
    CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, &valuePtr);
    return _IOHIDEventSystemConnectionVirtualServiceNotify(*(_QWORD *)(a1 + 336), valuePtr, 4, 0);
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionVirtualServiceNotify(uint64_t a1, uint64_t a2, int a3, const void *a4)
{
  const __CFData *v7;
  const __CFData *v8;
  int v9;
  const UInt8 *BytePtr;
  int Length;
  int v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v7 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a4);
  v8 = v7;
  if (!*(_DWORD *)(a1 + 448))
  {
    v9 = *(_DWORD *)(a1 + 40);
    if (v7)
    {
      BytePtr = CFDataGetBytePtr(v7);
      Length = CFDataGetLength(v8);
    }
    else
    {
      BytePtr = 0;
      Length = 0;
    }
    v12 = iohideventsystem_client_dispatch_virtual_service_notification(v9, a2, a3, (uint64_t)BytePtr, Length);
    if (!v12)
    {
      v15 = 1;
      if (!v8)
        return v15;
      goto LABEL_10;
    }
    v13 = v12;
    v14 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_QWORD *)(a1 + 168);
      v18 = 136315650;
      v19 = v17;
      v20 = 2048;
      v21 = a2;
      v22 = 1024;
      v23 = v13;
      _os_log_error_impl(&dword_18AAAF000, v14, OS_LOG_TYPE_ERROR, "%s: HIDVS ID:%llx iohideventsystem_client_dispatch_virtual_service_notification:%x", (uint8_t *)&v18, 0x1Cu);
    }
    __IOHIDEventSystemConnectionCheckServerStatus(v13, a1);
  }
  v15 = 0;
  if (v8)
LABEL_10:
    CFRelease(v8);
  return v15;
}

uint64_t iohideventsystem_client_dispatch_virtual_service_notification(int a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  _BYTE msg[28];
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v8 = a4;
  v9 = 16777472;
  v10 = a5;
  v11 = *MEMORY[0x1E0C804E8];
  v12 = a2;
  v13 = a3;
  v14 = a5;
  *(_QWORD *)msg = 2147483667;
  *(_DWORD *)&msg[8] = a1;
  *(_OWORD *)&msg[12] = xmmword_18AB477E0;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  v5 = mach_msg((mach_msg_header_t *)msg, 129, 0x44u, 0, 0, 0, 0);
  if ((v5 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)&msg[12]);
    mach_msg_destroy((mach_msg_header_t *)msg);
  }
  return v5;
}

uint64_t IOHIDSessionAddService(uint64_t a1, _QWORD *a2)
{
  int v4;
  const __CFAllocator *v5;
  CFDictionaryRef Copy;
  uint64_t v7;
  const __CFDictionary *Mutable;
  const __CFAllocator *v9;
  __CFSet *MutableCopy;
  uint64_t result;
  uint64_t v12;
  _OWORD context[5];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v12, context);
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  v4 = *(_DWORD *)(a1 + 88);
  v5 = CFGetAllocator(*(CFTypeRef *)(a1 + 120));
  Copy = CFDictionaryCreateCopy(v5, *(CFDictionaryRef *)(a1 + 120));
  v7 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)v7)
  {
    --*(_DWORD *)v7;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v12, context);
  }
  if (v4)
    __RegisterServiceFunction(a2, a1);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v12, context);
  ++**(_DWORD **)(a1 + 32);
  if (v4)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)&context[0] = Copy;
    *((_QWORD *)&context[0] + 1) = Mutable;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 120), (CFDictionaryApplierFunction)__CheckForNewProperties, context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__SetPropertiesForObjectFunction, a2);
    CFRelease(Mutable);
  }
  if (Copy)
    CFRelease(Copy);
  if (!v4 || _IOHIDServiceGetOwner((uint64_t)a2) == a1)
  {
    v9 = CFGetAllocator(*(CFTypeRef *)(a1 + 136));
    MutableCopy = CFSetCreateMutableCopy(v9, 0, *(CFSetRef *)(a1 + 136));
    CFRelease(*(CFTypeRef *)(a1 + 136));
    *(_QWORD *)(a1 + 136) = MutableCopy;
    CFSetAddValue(MutableCopy, a2);
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  result = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDSessionCreate_block_invoke_cold_1(&v12, context);
  }
  return result;
}

uint64_t __IOHIDSessionSetStateBusy(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;

  v3 = result;
  if (a2)
  {
    if (*(_DWORD *)(result + 92))
    {
      v4 = *(_QWORD *)(result + 32);
      v5 = *(_DWORD *)v4 - 1;
      do
      {
        *(_DWORD *)v4 = v5;
        result = pthread_cond_wait((pthread_cond_t *)(v3 + 40), (pthread_mutex_t *)(v4 + 8));
        v4 = *(_QWORD *)(v3 + 32);
        v5 = (*(_DWORD *)v4)++;
      }
      while (*(_DWORD *)(v3 + 92));
    }
  }
  else
  {
    result = pthread_cond_signal((pthread_cond_t *)(result + 40));
  }
  *(_DWORD *)(v3 + 92) = a2;
  return result;
}

uint64_t _IOHIDServiceGetOwner(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void __RegisterServiceFunction(_QWORD *a1, uint64_t a2)
{
  const __CFArray *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD context[2];
  _OWORD v8[5];
  uint64_t v9;
  CFRange v10;

  v9 = *MEMORY[0x1E0C80C00];
  if (_IOHIDServiceOpen(a1, (const void *)a2, 0))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a2 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(context, v8);
    ++**(_DWORD **)(a2 + 32);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 120), (CFDictionaryApplierFunction)__SetPropertiesForObjectFunction, a1);
    context[0] = a1;
    context[1] = a2;
    v4 = *(const __CFArray **)(a2 + 152);
    v10.length = CFArrayGetCount(v4);
    v10.location = 0;
    CFArrayApplyFunction(v4, v10, (CFArrayApplierFunction)__FilterFunctionRegisterService, context);
    v5 = *(_QWORD *)(a2 + 32);
    if (*(_DWORD *)v5)
    {
      --*(_DWORD *)v5;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v6, v8);
    }
    _IOHIDServiceSetEventCallback(a1, (uint64_t)__IOHIDSessionServiceCallback, a2, 0);
  }
  _IOHIDServiceScheduleAsync((uint64_t)a1);
}

uint64_t _IOHIDServiceSetEventCallback(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  void (*v9)(void);
  uint64_t v10;
  const __CFArray *v11;
  uint64_t result;
  uint64_t v13;
  void (*v14)(_QWORD, _QWORD, uint64_t (*)(uint64_t, uint64_t, uint64_t, HIDEvent *), _QWORD *, _QWORD);
  uint64_t v15;
  _QWORD context[3];
  _OWORD v17[5];
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  context[0] = __IOHIDServiceEventCallback;
  context[1] = a1;
  context[2] = a4;
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v15, v17);
  ++*(_DWORD *)a1[9];
  a1[17] = a4;
  a1[18] = a2;
  a1[16] = a3;
  v8 = a1[4];
  if (v8 && (v9 = *(void (**)(void))(*(_QWORD *)v8 + 64)) != 0
    || (v10 = a1[3]) != 0 && (v9 = *(void (**)(void))(*(_QWORD *)v10 + 64)) != 0)
  {
    v9();
  }
  else
  {
    v13 = a1[45];
    if (v13)
    {
      v14 = *(void (**)(_QWORD, _QWORD, uint64_t (*)(uint64_t, uint64_t, uint64_t, HIDEvent *), _QWORD *, _QWORD))(v13 + 40);
      if (v14)
        v14(a1[43], a1[44], __IOHIDServiceEventCallback, a1, 0);
    }
  }
  v11 = (const __CFArray *)a1[32];
  v19.length = CFArrayGetCount(v11);
  v19.location = 0;
  CFArrayApplyFunction(v11, v19, (CFArrayApplierFunction)__FilterFunctionSetEventCallback, context);
  result = a1[9];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v15, v17);
  }
  return result;
}

void _IOHIDServiceScheduleAsync(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(void);
  uint64_t v4;
  void (*v5)(uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  uint64_t v12;
  _QWORD v13[5];
  uint64_t v14;
  _OWORD v15[5];
  uint64_t v16;
  CFRange v17;

  v16 = *MEMORY[0x1E0C80C00];
  _IOHIDDebugTrace(8262, 1, a1, 1, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v15);
  ++**(_DWORD **)(a1 + 72);
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 88), *(dispatch_queue_t *)(a1 + 80));
  if (*(_QWORD *)(a1 + 8))
  {
    v2 = *(_QWORD *)(a1 + 32);
    if (v2 && (v3 = *(void (**)(void))(*(_QWORD *)v2 + 72)) != 0)
    {
      v3();
    }
    else
    {
      v4 = *(_QWORD *)(a1 + 360);
      if (v4 && (v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 48)) != 0)
      {
        v6 = *(_QWORD *)(a1 + 344);
        v7 = *(_QWORD *)(a1 + 352);
        v8 = *(_QWORD *)(a1 + 80);
      }
      else
      {
        v6 = *(_QWORD *)(a1 + 24);
        if (!v6 || (v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 72)) == 0)
        {
          if (*(_QWORD *)(a1 + 480))
          {
            *(_BYTE *)(a1 + 440) = 1;
            CFRetain((CFTypeRef)a1);
            objc_msgSend(*(id *)(a1 + 480), *(SEL *)(a1 + 528), *(_QWORD *)(a1 + 424));
            objc_msgSend(*(id *)(a1 + 480), *(SEL *)(a1 + 520), a1);
            v9 = *(const char **)(a1 + 552);
            if (v9)
              objc_msgSend(*(id *)(a1 + 480), v9, *(_QWORD *)(a1 + 80));
            objc_msgSend(*(id *)(a1 + 480), *(SEL *)(a1 + 536));
          }
          goto LABEL_17;
        }
        v7 = qword_1EDF7B4F0;
        v8 = *(_QWORD *)algn_1EDF7B4F8;
      }
      v5(v6, v7, v8);
    }
LABEL_17:
    v10 = *(const __CFArray **)(a1 + 256);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 0x40000000;
    v13[2] = ___IOHIDServiceScheduleAsync_block_invoke;
    v13[3] = &__block_descriptor_tmp_62;
    v13[4] = a1;
    _IOHIDCFArrayApplyBlock(v10, v13);
    v11 = *(const __CFArray **)(a1 + 256);
    v17.length = CFArrayGetCount(v11);
    v17.location = 0;
    CFArrayApplyFunction(v11, v17, (CFArrayApplierFunction)__FilterFunctionScheduleAsync, 0);
  }
  v12 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v12)
  {
    --*(_DWORD *)v12;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v15);
  }
  _IOHIDDebugTrace(8262, 2, a1, 1, 0, 0);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  NSObject *v4;
  unsigned int *v5;
  unsigned int v6;
  NSObject *v7;
  _QWORD handler[5];

  v4 = *((_QWORD *)notify + 3);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)notify + 3));
    *((_QWORD *)notify + 3) = 0;
  }
  if (queue)
  {
    v5 = (unsigned int *)((char *)notify + 32);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    v7 = dispatch_source_create(MEMORY[0x1E0C80D98], *((unsigned int *)notify + 1), 0, queue);
    dispatch_set_context(v7, notify);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = __IONotificationPortSetDispatchQueue_block_invoke;
    handler[3] = &__block_descriptor_tmp_6;
    handler[4] = v7;
    dispatch_source_set_event_handler(v7, handler);
    dispatch_source_set_cancel_handler_f(v7, (dispatch_function_t)IONotificationPortRelease);
    *((_QWORD *)notify + 3) = v7;
    dispatch_activate(v7);
  }
}

uint64_t __IOHIDServiceVirtualScheduleWithDispatchQueueCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID;

  SenderID = _IOHIDServiceGetSenderID(a1);
  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 2, 0);
}

uint64_t _IOHIDServiceOpen(_QWORD *a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t (*v9)(void);
  uint64_t v10;
  unsigned __int8 v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t (*v14)(_QWORD, _QWORD, uint64_t);
  const __CFArray *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  __int128 context;
  uint64_t v21;
  uint64_t v22;
  CFRange v23;

  v22 = *MEMORY[0x1E0C80C00];
  v6 = mach_absolute_time();
  _IOHIDDebugTrace(8258, 1, (uint64_t)a1, (uint64_t)a2, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v19, &context);
  ++*(_DWORD *)a1[9];
  if (a1[1])
    goto LABEL_3;
  v8 = a1[4];
  if (v8 && (v9 = *(uint64_t (**)(void))(*(_QWORD *)v8 + 32)) != 0
    || (v10 = a1[3]) != 0 && (v9 = *(uint64_t (**)(void))(*(_QWORD *)v10 + 32)) != 0)
  {
    v11 = v9();
  }
  else
  {
    v13 = a1[45];
    if (!v13 || (v14 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t))(v13 + 8)) == 0)
    {
      v7 = 1;
      goto LABEL_16;
    }
    v11 = v14(a1[43], a1[44], a3);
  }
  v7 = v11;
  if (v11)
  {
LABEL_16:
    a1[1] = CFRetain(a2);
    *((_QWORD *)&context + 1) = a2;
    v21 = 0;
    *(_QWORD *)&context = a1;
    v15 = (const __CFArray *)a1[32];
    v23.length = CFArrayGetCount(v15);
    v23.location = 0;
    CFArrayApplyFunction(v15, v23, (CFArrayApplierFunction)__FilterFunctionOpen, &context);
    goto LABEL_17;
  }
  v12 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    _IOHIDServiceOpen_cold_2();
LABEL_3:
  v7 = 0;
LABEL_17:
  v16 = a1[9];
  if (*(_DWORD *)v16)
  {
    --*(_DWORD *)v16;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v19, &context);
  }
  _IOHIDDebugTrace(8258, 2, (uint64_t)a1, (uint64_t)a2, 0, 0);
  v17 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v17, v6, 0x3E8u);
  if (a1[58])
    IOHIDAnalyticsEventSetIntegerValueForField();
  return v7;
}

uint64_t __IOHIDServiceVirtualOpenCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID;

  SenderID = _IOHIDServiceGetSenderID(a1);
  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 0, 0);
}

uint64_t __IOHIDServiceVirtualUnscheduleFromDispatchQueueCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID;

  SenderID = _IOHIDServiceGetSenderID(a1);
  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 3, 0);
}

uint64_t __IOHIDServiceUpdateIntervals(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  char v7;
  int v8;
  int v9;
  uint64_t v10;
  CFMutableDictionaryRef v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t context;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  CFMutableDictionaryRef v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&context, buf);
  ++**(_DWORD **)(a1 + 72);
  context = 0;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__ConnectionFunctionPickReportInterval, &context);
  v5 = context;
  v4 = HIDWORD(context);
  v6 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v6)
  {
    --*(_DWORD *)v6;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v20, buf);
  }
  v7 = (double)v5 * 1.75 > (double)v4 && (double)v5 * 1.25 < (double)v4;
  v8 = __IOHIDServicePickBatchInterval(a1);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&context, buf);
  v9 = v5 >> v7;
  ++**(_DWORD **)(a1 + 72);
  if (v9 == *(_DWORD *)(a1 + 160))
  {
    v10 = 1;
  }
  else
  {
    v10 = __SetNumPropertyForService(a1, (uint64_t)CFSTR("ReportInterval"), v9, a2);
    v11 = _IOHIDServiceCopyEventCounts((_QWORD *)a1);
    v12 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = *(_QWORD *)(a1 + 400);
      v14 = *(_DWORD *)(a1 + 160);
      *(_DWORD *)buf = 134219010;
      v23 = v13;
      v24 = 1024;
      v25 = v14;
      v26 = 1024;
      v27 = v9;
      v28 = 1024;
      v29 = v10;
      v30 = 2112;
      v31 = v11;
      _os_log_impl(&dword_18AAAF000, v12, OS_LOG_TYPE_INFO, "0x%llx: Set report interval current:%d new:%d result:%d events:%@", buf, 0x28u);
    }
    if ((_DWORD)v10)
      *(_DWORD *)(a1 + 160) = v9;
    if (v11)
      CFRelease(v11);
  }
  if (v8 != *(_DWORD *)(a1 + 164))
  {
    v10 = __SetNumPropertyForService(a1, (uint64_t)CFSTR("BatchInterval"), v8, a2);
    v15 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = *(_QWORD *)(a1 + 400);
      v17 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)buf = 134218752;
      v23 = v16;
      v24 = 1024;
      v25 = v17;
      v26 = 1024;
      v27 = v8;
      v28 = 1024;
      v29 = v10;
      _os_log_impl(&dword_18AAAF000, v15, OS_LOG_TYPE_INFO, "0x%llx: Set batch interval current:%d new:%d result:%d", buf, 0x1Eu);
    }
    if ((_DWORD)v10)
      *(_DWORD *)(a1 + 164) = v8;
  }
  v18 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v18)
  {
    --*(_DWORD *)v18;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&context, buf);
  }
  return v10;
}

uint64_t __IOHIDServicePickBatchInterval(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  unsigned int context;
  _OWORD v6[5];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  context = -1;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v4, v6);
  ++**(_DWORD **)(a1 + 72);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__ConnectionFunctionPickBatchInterval, &context);
  v2 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v2)
  {
    --*(_DWORD *)v2;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v4, v6);
  }
  result = context;
  if (context == -1)
    return *(unsigned int *)(a1 + 172);
  return result;
}

uint64_t __SetNumPropertyForService(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  const __CFAllocator *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  uint64_t v10;
  uint64_t (*v11)(void);
  unsigned __int8 v12;
  uint64_t v13;
  void (*v14)(void);
  unsigned __int8 v15;
  uint64_t v16;
  uint64_t (*v17)(_QWORD, _QWORD, uint64_t, CFNumberRef);
  void *v18;
  int valuePtr;

  valuePtr = a3;
  v7 = CFGetAllocator((CFTypeRef)a1);
  v8 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)(a1 + 32);
    if (v10 && (v11 = *(uint64_t (**)(void))(*(_QWORD *)v10 + 56)) != 0)
    {
      v12 = v11();
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 24);
      if (v13)
      {
        v14 = *(void (**)(void))(*(_QWORD *)v13 + 56);
        if (v14)
        {
          v14();
          v15 = 1;
LABEL_15:
          CFRelease(v9);
          return v15;
        }
      }
      v16 = *(_QWORD *)(a1 + 360);
      if (v16 && (v17 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, CFNumberRef))(v16 + 32)) != 0)
      {
        v12 = v17(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), a2, v9);
      }
      else
      {
        v18 = *(void **)(a1 + 480);
        if (!v18)
        {
          v15 = 0;
          goto LABEL_15;
        }
        v12 = objc_msgSend(v18, *(SEL *)(a1 + 504), v9, a2, a4);
      }
    }
    v15 = v12;
    goto LABEL_15;
  }
  return 0;
}

BOOL __IOHIDServiceVirtualSetPropertyCallback(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t SenderID;
  const __CFAllocator *v8;
  CFDictionaryRef v9;
  const __CFData *v10;
  const __CFData *v11;
  mach_port_t v12;
  const UInt8 *BytePtr;
  int Length;
  int v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  void *values[2];
  void *keys[2];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  SenderID = _IOHIDServiceGetSenderID(a1);
  v20 = 0;
  *(_OWORD *)keys = xmmword_1E2003658;
  values[0] = a3;
  values[1] = a4;
  v8 = CFGetAllocator((CFTypeRef)a2);
  v9 = CFDictionaryCreate(v8, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9);
  v11 = v10;
  if (v10)
  {
    if (!*(_DWORD *)(a2 + 448))
    {
      v12 = *(_DWORD *)(a2 + 40);
      BytePtr = CFDataGetBytePtr(v10);
      Length = CFDataGetLength(v11);
      v15 = iohideventsystem_client_dispatch_virtual_service_set_property(v12, SenderID, (uint64_t)BytePtr, Length, &v20, 0x20u);
      if (v15)
      {
        v16 = v15;
        v17 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          v18 = *(_QWORD *)(a2 + 168);
          *(_DWORD *)buf = 136315650;
          v22 = v18;
          v23 = 2048;
          v24 = SenderID;
          v25 = 1024;
          v26 = v16;
          _os_log_impl(&dword_18AAAF000, v17, OS_LOG_TYPE_INFO, "%s: HIDVS ID:%llx: iohideventsystem_client_dispatch_virtual_service_set_property:%x", buf, 0x1Cu);
        }
        __IOHIDEventSystemConnectionCheckServerStatus(v16, a2);
      }
    }
  }
  if (v9)
    CFRelease(v9);
  if (v11)
    CFRelease(v11);
  return v20 != 0;
}

uint64_t iohideventsystem_client_dispatch_virtual_service_set_property(mach_port_t a1, uint64_t a2, uint64_t a3, int a4, int *a5, mach_msg_timeout_t a6)
{
  mach_port_t special_reply_port;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  mach_msg_header_t msg;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v15 = 1;
  v16 = a3;
  v17 = 16777472;
  v18 = a4;
  v19 = *MEMORY[0x1E0C804E8];
  v20 = a2;
  v21 = a4;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x124FF00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v10 = mach_msg(&msg, 3162515, 0x40u, 0x30u, special_reply_port, a6, 0);
  v11 = v10;
  if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v10)
    {
      if (msg.msgh_id == 71)
      {
        v11 = 4294966988;
      }
      else if (msg.msgh_id == 75107)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v11 = HIDWORD(v16);
              if (!HIDWORD(v16))
              {
                *a5 = v17;
                return v11;
              }
              goto LABEL_25;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v12 = 1;
            else
              v12 = HIDWORD(v16) == 0;
            if (v12)
              v11 = 4294966996;
            else
              v11 = HIDWORD(v16);
            goto LABEL_25;
          }
        }
        v11 = 4294966996;
      }
      else
      {
        v11 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&msg);
      return v11;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v11 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_25;
  }
  return v11;
}

CFMutableDictionaryRef __IOHIDEventSystemClientStateSerialize(uint64_t a1)
{
  const __CFAllocator *v2;
  CFMutableDictionaryRef Mutable;
  uint64_t v4;
  const __CFAllocator *v5;
  CFStringRef v6;
  CFStringRef v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  CFStringRef v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  CFIndex Count;
  CFMutableArrayRef v19;
  uint64_t v20;
  CFMutableArrayRef v21;
  const __CFDictionary *v22;
  CFIndex v23;
  CFMutableArrayRef v24;
  CFMutableArrayRef v25;
  const __CFDictionary *v26;
  uint64_t v27;
  CFMutableDictionaryRef v28;
  CFMutableDictionaryRef v29;
  _QWORD v31[5];
  _QWORD context[5];

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    os_unfair_recursive_lock_lock_with_options();
    v4 = *(_QWORD *)(a1 + 480);
    if (v4)
    {
      _IOHIDDictionaryAddSInt64(Mutable, CFSTR("MaxEventLatency"), v4);
      v5 = CFGetAllocator((CFTypeRef)a1);
      v6 = _IOHIDCreateTimeString(v5, (time_t *)(a1 + 464));
      if (v6)
      {
        v7 = v6;
        CFDictionarySetValue(Mutable, CFSTR("LastEventTime"), v6);
        CFRelease(v7);
      }
    }
    v8 = *(_QWORD *)(a1 + 512);
    if (v8)
    {
      _IOHIDDictionaryAddSInt64(Mutable, CFSTR("PropertyNotificationCount"), v8);
      v9 = CFGetAllocator((CFTypeRef)a1);
      v10 = _IOHIDCreateTimeString(v9, (time_t *)(a1 + 496));
      if (v10)
      {
        v11 = v10;
        CFDictionarySetValue(Mutable, CFSTR("LastPropertyNotificationTime"), v10);
        CFRelease(v11);
      }
    }
    v12 = *(const void **)(a1 + 432);
    if (v12)
      CFDictionarySetValue(Mutable, CFSTR("caller"), v12);
    v13 = *(const void **)(a1 + 440);
    if (v13)
      CFDictionarySetValue(Mutable, CFSTR("UUID"), v13);
    _IOHIDDictionaryAddSInt32(Mutable, CFSTR("port"), *(_DWORD *)(a1 + 32));
    _IOHIDDictionaryAddSInt32(Mutable, CFSTR("resetCount"), *(_DWORD *)(a1 + 144));
    _IOHIDDictionaryAddSInt32(Mutable, CFSTR("eventCount"), *(_DWORD *)(a1 + 148));
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("eventMask"), *(_QWORD *)(a1 + 152));
    v14 = (const void *)*MEMORY[0x1E0C9AE50];
    v15 = (const void *)*MEMORY[0x1E0C9AE40];
    if (*(_QWORD *)(a1 + 400))
      v16 = (const void *)*MEMORY[0x1E0C9AE50];
    else
      v16 = (const void *)*MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(Mutable, CFSTR("dispatchQueue"), v16);
    if (*(_QWORD *)(a1 + 392))
      v17 = v14;
    else
      v17 = v15;
    CFDictionarySetValue(Mutable, CFSTR("runloop"), v17);
    Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 96));
    v19 = CFArrayCreateMutable(v2, Count, MEMORY[0x1E0C9B378]);
    v20 = MEMORY[0x1E0C809B0];
    if (v19)
    {
      v21 = v19;
      v22 = *(const __CFDictionary **)(a1 + 96);
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 0x40000000;
      context[2] = ____IOHIDEventSystemClientStateSerialize_block_invoke;
      context[3] = &__block_descriptor_tmp_78;
      context[4] = v21;
      _IOHIDCFDictionaryApplyBlock(v22, context);
      CFDictionarySetValue(Mutable, CFSTR("services"), v21);
      CFRelease(v21);
    }
    v23 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 104));
    v24 = CFArrayCreateMutable(v2, v23, MEMORY[0x1E0C9B378]);
    if (v24)
    {
      v25 = v24;
      v26 = *(const __CFDictionary **)(a1 + 104);
      v31[0] = v20;
      v31[1] = 0x40000000;
      v31[2] = ____IOHIDEventSystemClientStateSerialize_block_invoke_2;
      v31[3] = &__block_descriptor_tmp_81_0;
      v31[4] = v25;
      _IOHIDCFDictionaryApplyBlock(v26, v31);
      CFDictionarySetValue(Mutable, CFSTR("virtualServices"), v25);
      CFRelease(v25);
    }
    v27 = *(_QWORD *)(a1 + 272);
    if (v27)
    {
      v28 = _IOHIDEventQueueSerializeState(v27);
      if (v28)
      {
        v29 = v28;
        CFDictionarySetValue(Mutable, CFSTR("eventQueue"), v28);
        CFRelease(v29);
      }
    }
    os_unfair_recursive_lock_unlock();
  }
  return Mutable;
}

CFMutableDictionaryRef _IOHIDEventQueueSerializeState(uint64_t a1)
{
  ipc_space_read_t v2;
  mach_port_name_t v3;
  kern_return_t attributes;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  int *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  mach_msg_type_number_t port_info_outCnt;
  integer_t port_info_out[4];
  __int128 v15;
  uint64_t v16;

  v16 = 0;
  *(_OWORD *)port_info_out = 0u;
  v15 = 0u;
  port_info_outCnt = 10;
  v2 = *MEMORY[0x1E0C83DA0];
  os_unfair_recursive_lock_lock_with_options();
  v3 = *(_DWORD *)(a1 + 96);
  os_unfair_recursive_lock_unlock();
  attributes = mach_port_get_attributes(v2, v3, 2, port_info_out, &port_info_outCnt);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = Mutable;
  if (Mutable)
  {
    v7 = *(int **)(a1 + 16);
    if (v7)
    {
      _IOHIDDictionaryAddSInt32(Mutable, CFSTR("tail"), v7[2]);
      _IOHIDDictionaryAddSInt32(v6, CFSTR("head"), v7[1]);
      _IOHIDDictionaryAddSInt32(v6, CFSTR("size"), *v7);
      _IOHIDDictionaryAddSInt32(v6, CFSTR("droppedEvents"), *(_DWORD *)(a1 + 168));
      if (!attributes)
        _IOHIDDictionaryAddSInt32(v6, CFSTR("msgCount"), v15);
      _IOHIDDictionaryAddSInt64(v6, CFSTR("lastNotifyTime"), *(_QWORD *)(a1 + 128));
      _IOHIDDictionaryAddSInt64(v6, CFSTR("lastNotifyEventTimeStamp"), *(_QWORD *)(a1 + 120));
      _IOHIDDictionaryAddSInt64(v6, CFSTR("notificationCount"), *(_QWORD *)(a1 + 136));
      v8 = (const void *)*MEMORY[0x1E0C9AE50];
      v9 = (const void *)*MEMORY[0x1E0C9AE40];
      if (*(_DWORD *)(a1 + 148))
        v10 = (const void *)*MEMORY[0x1E0C9AE50];
      else
        v10 = (const void *)*MEMORY[0x1E0C9AE40];
      CFDictionaryAddValue(v6, CFSTR("active"), v10);
      if (*(_DWORD *)(a1 + 152))
        v11 = v8;
      else
        v11 = v9;
      CFDictionaryAddValue(v6, CFSTR("suspended"), v11);
    }
  }
  return v6;
}

void _IOHIDDictionaryAddSInt32(void *a1, const void *a2, int a3)
{
  const __CFAllocator *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  int valuePtr;

  valuePtr = a3;
  v5 = CFGetAllocator(a1);
  v6 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
  if (v6)
  {
    v7 = v6;
    CFDictionaryAddValue((CFMutableDictionaryRef)a1, a2, v6);
    CFRelease(v7);
  }
}

CFMutableDictionaryRef _IOHIDServiceCopyEventCounts(_QWORD *a1)
{
  const __CFAllocator *v2;
  CFMutableDictionaryRef Mutable;
  uint64_t i;
  const __CFString *Name;
  uint64_t v6;
  uint64_t v8;
  _OWORD v9[5];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  ++*(_DWORD *)a1[9];
  v2 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    for (i = 0; i != 43; ++i)
    {
      if (*(_QWORD *)(a1[52] + 8 * i))
      {
        Name = IOHIDEventTypeGetName(i);
        _IOHIDDictionaryAddSInt64(Mutable, Name, *(_QWORD *)(a1[52] + 8 * i));
      }
    }
    if (!CFDictionaryGetCount(Mutable))
    {
      CFRelease(Mutable);
      Mutable = 0;
    }
  }
  v6 = a1[9];
  if (*(_DWORD *)v6)
  {
    --*(_DWORD *)v6;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
  }
  return Mutable;
}

void _IOHIDDictionaryAddSInt64(void *a1, const void *a2, uint64_t a3)
{
  const __CFAllocator *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  uint64_t valuePtr;

  valuePtr = a3;
  v5 = CFGetAllocator(a1);
  v6 = CFNumberCreate(v5, kCFNumberSInt64Type, &valuePtr);
  if (v6)
  {
    v7 = v6;
    CFDictionaryAddValue((CFMutableDictionaryRef)a1, a2, v6);
    CFRelease(v7);
  }
}

const __CFString *IOHIDEventTypeGetName(unsigned int a1)
{
  if (a1 > 0x2A)
    return CFSTR("Unknown");
  else
    return (const __CFString *)*((_QWORD *)&off_1E20026C0 + (int)a1);
}

CFStringRef _IOHIDCreateTimeString(const __CFAllocator *a1, time_t *a2)
{
  tm *v4;
  tm v6;
  char v7[16];
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(&v6, 0, sizeof(v6));
  *(_OWORD *)v7 = 0u;
  v8 = 0u;
  v4 = localtime_r(a2, &v6);
  if (v4 || (v4 = gmtime_r(a2, &v6)) != 0)
    strftime(v7, 0x20uLL, "%F %H:%M:%S", v4);
  return CFStringCreateWithFormat(a1, 0, CFSTR("%s.%06d"), v4, v7, *((unsigned int *)a2 + 2));
}

const void **__ActivityFunctionApplier(const void **a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ____ActivityFunctionApplier_block_invoke;
  v3[3] = &__block_descriptor_tmp_36_0;
  v3[4] = a2;
  return IOHIDNotificationSignalWithBlock(a1, (uint64_t)v3);
}

uint64_t _IOObjectCFRetain(int a1, uint64_t object)
{
  if (IOObjectRetain(object))
    return 0;
  else
    return object;
}

kern_return_t IORegistryCreateIterator(mach_port_t mainPort, const io_name_t plane, IOOptionBits options, io_iterator_t *iterator)
{
  mach_port_t v8;
  kern_return_t v9;
  mach_port_t mainPorta;

  v8 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v8 = 0;
    else
      v8 = mainPorta;
  }
  v9 = io_registry_create_iterator(v8, plane, options, iterator);
  if (v8 && v8 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v8);
  return v9;
}

uint64_t io_registry_create_iterator(unsigned int a1, const char *a2, int a3, _DWORD *a4)
{
  int v7;
  uint64_t v8;
  mach_port_t v9;
  mach_port_t v10;
  uint64_t v11;
  uint64_t v12;
  mach_port_t reply_port[4];
  __int128 v15;
  _OWORD v16[9];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(v16, 0, 140);
  *(_OWORD *)reply_port = 0u;
  v15 = 0u;
  *((_QWORD *)&v15 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v7 = mig_strncpy_zerofill((char *)v16 + 8, a2, 128);
  else
    v7 = mig_strncpy((char *)v16 + 8, a2, 128);
  LODWORD(v16[0]) = 0;
  DWORD1(v16[0]) = v7;
  v8 = (v7 + 3) & 0xFFFFFFFC;
  v9 = v8 + 44;
  *(_DWORD *)((char *)v16 + v8 + 8) = a3;
  v10 = mig_get_reply_port();
  reply_port[0] = 5395;
  reply_port[1] = v9;
  *(_QWORD *)&reply_port[2] = __PAIR64__(v10, a1);
  *(_QWORD *)&v15 = 0xAF600000000;
  v11 = mach_msg2_internal();
  v12 = v11;
  if ((v11 - 268435458) <= 0xE && ((1 << (v11 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else
  {
    if (!(_DWORD)v11)
    {
      if (DWORD1(v15) == 71)
      {
        v12 = 4294966988;
      }
      else if (DWORD1(v15) == 2906)
      {
        if ((reply_port[0] & 0x80000000) != 0)
        {
          v12 = 4294966996;
          if (DWORD2(v15) == 1 && reply_port[1] == 40 && !reply_port[2] && WORD3(v16[0]) << 16 == 1114112)
          {
            v12 = 0;
            *a4 = HIDWORD(v15);
            return v12;
          }
        }
        else if (reply_port[1] == 36)
        {
          v12 = 4294966996;
          if (LODWORD(v16[0]))
          {
            if (reply_port[2])
              v12 = 4294966996;
            else
              v12 = LODWORD(v16[0]);
          }
        }
        else
        {
          v12 = 4294966996;
        }
      }
      else
      {
        v12 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v12;
    }
    mig_dealloc_reply_port(reply_port[3]);
  }
  return v12;
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  IONotificationPort *v8;
  io_registry_entry_t v9;
  io_object_t v10;
  BOOL v11;
  kern_return_t v12;
  io_connect_t result;
  io_connect_t connect;

  connect = 0;
  *notifier = 0;
  v8 = IONotificationPortCreate(0);
  v9 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (v9)
  {
    v10 = v9;
    if (IOServiceOpen(v9, *MEMORY[0x1E0C83DA0], 0, &connect))
      v11 = 1;
    else
      v11 = connect == 0;
    if (v11)
    {
      IOObjectRelease(v10);
    }
    else
    {
      v12 = IOServiceAddInterestNotification(v8, v10, "IOAppPowerStateInterest", callback, refcon, notifier);
      IOObjectRelease(v10);
      if (!v12)
      {
        *thePortRef = v8;
        return connect;
      }
    }
  }
  if (v8)
    IONotificationPortDestroy(v8);
  if (connect)
    IOServiceClose(connect);
  result = *notifier;
  if (*notifier)
  {
    IOObjectRelease(result);
    return 0;
  }
  return result;
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  kern_return_t result;

  result = io_service_open_extended(service, owningTask, type, *MEMORY[0x1E0C804E8], 0, 0);
  if (!result)
    return 0;
  return result;
}

uint64_t io_service_open_extended(unsigned int a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  mach_msg_header_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;

  v10 = 2;
  v11 = a2;
  v12 = 0x13000000000000;
  v13 = a5;
  v14 = 0x1000000;
  v15 = a6;
  v16 = *MEMORY[0x1E0C804E8];
  v17 = a3;
  v18 = a4;
  v19 = a6;
  *(_QWORD *)&v9.msgh_bits = 0x5080001513;
  *(_QWORD *)&v9.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v9.msgh_voucher_port = 0xB2E00000000;
  v6 = mach_msg2_internal();
  v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v9.msgh_local_port);
  }
  else if ((_DWORD)v6)
  {
    mig_dealloc_reply_port(v9.msgh_local_port);
  }
  else
  {
    v7 = 4294966995;
    mach_msg_destroy(&v9);
  }
  return v7;
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  _QWORD v7[5];

  v7[4] = *MEMORY[0x1E0C80C00];
  v7[0] = 0;
  v7[1] = callback;
  v7[2] = refCon;
  v7[3] = service;
  return io_service_add_interest_notification(service, interestType, *((_DWORD *)notifyPort + 1), v7, 4u, notification);
}

uint64_t io_service_add_interest_notification(unsigned int a1, const char *a2, int a3, const void *a4, unsigned int a5, _DWORD *a6)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  mach_port_t v13;
  uint64_t v14;
  mach_msg_header_t reply_port;
  int v17;
  int v18;
  __int128 v19;
  _OWORD v20[13];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  memset(v20, 0, 204);
  v19 = 0u;
  memset(&reply_port, 0, sizeof(reply_port));
  v17 = 1;
  v18 = a3;
  DWORD1(v19) = 1310720;
  *((_QWORD *)&v19 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v10 = mig_strncpy_zerofill((char *)v20 + 8, a2, 128);
  else
    v10 = mig_strncpy((char *)v20 + 8, a2, 128);
  LODWORD(v20[0]) = 0;
  DWORD1(v20[0]) = v10;
  if (a5 > 8)
    return 4294966989;
  v12 = (v10 + 3) & 0xFFFFFFFC;
  memcpy((char *)v20 + v12 + 12, a4, 8 * a5);
  *(_DWORD *)((char *)v20 + v12 + 8) = a5;
  v13 = mig_get_reply_port();
  reply_port.msgh_bits = -2147478253;
  reply_port.msgh_size = v12 + 8 * a5 + 60;
  *(_QWORD *)&reply_port.msgh_remote_port = __PAIR64__(v13, a1);
  *(_QWORD *)&reply_port.msgh_voucher_port = 0xB3500000000;
  v14 = mach_msg2_internal();
  v11 = v14;
  if ((v14 - 268435458) <= 0xE && ((1 << (v14 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v14)
    {
      if (reply_port.msgh_id == 71)
      {
        v11 = 4294966988;
      }
      else if (reply_port.msgh_id == 2969)
      {
        if ((reply_port.msgh_bits & 0x80000000) != 0)
        {
          v11 = 4294966996;
          if (v17 == 1 && reply_port.msgh_size == 40 && !reply_port.msgh_remote_port && WORD3(v19) << 16 == 1114112)
          {
            v11 = 0;
            *a6 = v18;
            return v11;
          }
        }
        else if (reply_port.msgh_size == 36)
        {
          v11 = 4294966996;
          if ((_DWORD)v19)
          {
            if (reply_port.msgh_remote_port)
              v11 = 4294966996;
            else
              v11 = v19;
          }
        }
        else
        {
          v11 = 4294966996;
        }
      }
      else
      {
        v11 = 4294966995;
      }
      mach_msg_destroy(&reply_port);
      return v11;
    }
    mig_dealloc_reply_port(reply_port.msgh_local_port);
  }
  return v11;
}

CFTypeRef OSKextCopyLoadedKextInfoByUUID(unint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFDictionary *v16;
  mach_error_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  CFTypeID TypeID;
  __CFString *CFStringForPlist_new;
  void *UTF8CStringForCFString;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  char v40;
  char v41;
  CFMutableDictionaryRef theDict;
  CFTypeRef cf;

  theDict = 0;
  cf = 0;
  OSKextLog(0, 69, "Reading loaded kext info from kernel.", a4, a5, a6, a7, a8, v40);
  v10 = __OSKextCreateKextRequest(CFSTR("Get Loaded Kext Info By UUID"), a1, &theDict);
  if (!v10)
  {
    OSKextLog(0, 65, "Failed to create kext request.", v11, v12, v13, v14, v15, v41);
    return cf;
  }
  v16 = v10;
  if (a2 && CFArrayGetCount((CFArrayRef)a2))
    CFDictionarySetValue(theDict, CFSTR("Kext Request Info Keys"), a2);
  v17 = __OSKextSendKextRequest(0, v16, &cf, 0, 0);
  if (v17)
  {
    v23 = mach_error_string(v17);
    v29 = "(unknown)";
    if (v23)
      LOBYTE(v29) = (_BYTE)v23;
    OSKextLog(0, 65, "Failed to read loaded kext info from kernel - %s.", v24, v25, v26, v27, v28, (char)v29);
    if (cf)
      CFRelease(cf);
    cf = 0;
    goto LABEL_25;
  }
  if (!cf)
  {
    v38 = "Kernel request call returned no data.";
LABEL_24:
    OSKextLog(0, 65, v38, v18, v19, v20, v21, v22, v41);
LABEL_25:
    CFRelease(v16);
    return cf;
  }
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(cf))
  {
    if (cf)
      CFRelease(cf);
    cf = 0;
    v38 = "Loaded kext info from kernel is wrong type.";
    goto LABEL_24;
  }
  if ((~__sUserLogFilter & 7) != 0 || (__sUserLogFilter & 0x60) == 0)
    goto LABEL_25;
  CFStringForPlist_new = createCFStringForPlist_new(cf, 1);
  UTF8CStringForCFString = createUTF8CStringForCFString(CFStringForPlist_new);
  OSKextLog(0, 103, "Loaded kext info:\n%s", v33, v34, v35, v36, v37, (char)UTF8CStringForCFString);
  CFRelease(v16);
  if (CFStringForPlist_new)
    CFRelease(CFStringForPlist_new);
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  return cf;
}

CFTypeRef OSKextCopyUUIDForAddress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;
  CFNumberRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFNumberRef v21;
  mach_error_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  char v36;
  char v37;
  CFMutableDictionaryRef theDict;
  CFTypeRef cf;
  uint64_t valuePtr;

  cf = 0;
  valuePtr = a1;
  theDict = 0;
  OSKextLog(0, 69, "Reading kext UUID for Address\n.", a4, a5, a6, a7, a8, v36);
  v8 = __OSKextCreateKextRequest(CFSTR("Get Kext UUID by Address"), 0, &theDict);
  if (!v8)
  {
    OSKextLog(0, 65, "Failed to create kext request.", v9, v10, v11, v12, v13, v37);
    return 0;
  }
  v14 = v8;
  v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v15)
  {
    OSKextLog(0, 65, "Failed to create lookup address object.", v16, v17, v18, v19, v20, v37);
    CFRelease(v14);
    return 0;
  }
  v21 = v15;
  CFDictionarySetValue(theDict, CFSTR("Kext Request Lookup Address"), v15);
  v22 = __OSKextSendKextRequest(0, v14, &cf, 0, 0);
  if (v22)
  {
    v28 = mach_error_string(v22);
    v34 = "(unknown)";
    if (v28)
      LOBYTE(v34) = (_BYTE)v28;
    OSKextLog(0, 65, "Failed to lookup uuid with address from kernel - %s.", v29, v30, v31, v32, v33, (char)v34);
    if (cf)
      CFRelease(cf);
    cf = 0;
  }
  else if (!cf)
  {
    OSKextLog(0, 65, "Kernel request call returned no data.", v23, v24, v25, v26, v27, v37);
  }
  CFRelease(v14);
  CFRelease(v21);
  return cf;
}

void OSKextLog(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  OSKextVLog(a1, a2, a3, &a9);
}

void OSKextVLog(uint64_t a1, int a2, const char *a3, va_list a4)
{
  int v6;
  char *v7[2];
  va_list v8;

  v8 = a4;
  v7[0] = 0;
  if (__sOSKextLogOutputFunction)
  {
    v6 = a1;
    if (__OSKextShouldLog(a1, a2))
    {
      v7[1] = v8;
      vasprintf(v7, a3, v8);
      if (v7[0])
      {
        __sOSKextLogOutputFunction(v6, a2, "%s", v7[0]);
        if (v7[0])
          free(v7[0]);
      }
    }
  }
}

BOOL __OSKextShouldLog(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned int v3;

  if (!a1 || (*(_BYTE *)(a1 + 92) & 0x10) != 0)
    a2 |= 8u;
  v2 = a2 & 7;
  if ((a2 & 7) == 0)
    return 1;
  v3 = __sUserLogFilter & 7;
  if (v2 <= 3 && v2 <= v3)
    return 1;
  if (((__sUserLogFilter | a2) & 8) == 0)
    return 0;
  return (a2 & __sUserLogFilter & 0xFFFFFF0) != 0 && v2 <= v3;
}

uint64_t __OSKextSendKextRequest(uint64_t a1, const void *a2, _QWORD *a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  host_priv_t v10;
  const __CFData *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFData *v17;
  uint32_t v18;
  const UInt8 *BytePtr;
  mach_msg_type_number_t Length;
  uint64_t v21;
  uint64_t v22;
  int v23;
  vm_map_t *v24;
  mach_msg_type_number_t v26;
  CFTypeRef v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *UTF8CStringForCFString;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  const char *v40;
  char op_result;
  CFTypeRef cf;
  mach_msg_type_number_t log_dataCnt;
  vm_offset_t log_data;
  mach_msg_type_number_t response_dataCnt;
  vm_offset_t response_data;
  kern_return_t v47;

  v47 = -603979775;
  response_data = 0;
  response_dataCnt = 0;
  log_data = 0;
  log_dataCnt = 0;
  cf = 0;
  v10 = MEMORY[0x18D772924]();
  v11 = IOCFSerialize(a2, 0);
  if (v11)
  {
    v17 = v11;
    if (__sOSKextLogOutputFunction)
      v18 = __sKernelLogFilter;
    else
      v18 = 0;
    BytePtr = CFDataGetBytePtr(v11);
    Length = CFDataGetLength(v17);
    v21 = kext_request(v10, v18, (vm_offset_t)BytePtr, Length, &response_data, &response_dataCnt, &log_data, &log_dataCnt, &v47);
    v22 = __OSKextProcessKextRequestResults(a1, v21, v47, (char *)log_data, log_dataCnt);
    if ((_DWORD)v22)
    {
      v23 = 1;
    }
    else
    {
      v23 = 1;
      if (response_data)
      {
        v26 = response_dataCnt;
        if (response_dataCnt)
        {
          if (a3)
          {
            v27 = IOCFUnserialize((const char *)response_data, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFStringRef *)&cf);
            *a3 = v27;
            if (v27)
            {
              v22 = 0;
            }
            else
            {
              if (cf)
              {
                UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)cf);
                v39 = UTF8CStringForCFString;
                v40 = "unknown error";
                if (UTF8CStringForCFString)
                  LOBYTE(v40) = (_BYTE)UTF8CStringForCFString;
                OSKextLog(a1, 65, "Can't unserialize kext request response: %s", v34, v35, v36, v37, v38, (char)v40);
                if (v39)
                  free(v39);
              }
              else
              {
                OSKextLog(a1, 65, "Can't unserialize kext request response: %s", v28, v29, v30, v31, v32, (char)"unknown error");
              }
              if (cf)
                CFRelease(cf);
              v22 = 3691020296;
              cf = 0;
            }
          }
          else
          {
            v22 = 0;
            if (a4 && a5)
            {
              v22 = 0;
              v23 = 0;
              *a4 = response_data;
              *a5 = v26;
            }
          }
        }
      }
    }
    CFRelease(v17);
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v22 = 3691020296;
    OSKextLog(a1, 65, "Failed to serialize kext request.", v12, v13, v14, v15, v16, op_result);
    v23 = 1;
  }
  v24 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  if (v23 && response_data && response_dataCnt)
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], response_data, response_dataCnt);
  if (log_data)
    mach_vm_deallocate(*v24, log_data, log_dataCnt);
  if (v10)
    mach_port_deallocate(*v24, v10);
  return v22;
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  _QWORD v7[4];

  v7[3] = *MEMORY[0x1E0C80C00];
  v7[0] = 0;
  v7[1] = callback;
  v7[2] = refCon;
  return InternalIOServiceAddNotification(*(_DWORD *)notifyPort, notificationType, matching, *((_DWORD *)notifyPort + 1), v7, 3u, notification);
}

uint64_t InternalIOServiceAddNotification(mach_port_t a1, const char *a2, CFTypeRef object, int a4, const void *a5, unsigned int a6, _DWORD *a7)
{
  uint64_t v7;
  mach_port_t v14;
  const __CFData *v15;
  unint64_t Length;
  int v17;
  const char *BytePtr;
  uint64_t v19;
  const UInt8 *v20;
  unsigned int v21;
  unsigned int v24;
  mach_port_t mainPort;

  v7 = 3758097090;
  if (!object)
    return v7;
  v14 = a1;
  if (!a1)
  {
    mainPort = 0;
    if (IOMasterPort(0, &mainPort))
      v14 = 0;
    else
      v14 = mainPort;
  }
  v15 = IOCFSerialize(object, gIOKitLibSerializeOptions);
  CFRelease(object);
  if (!v15)
    return 3758097095;
  Length = CFDataGetLength(v15);
  v17 = Length;
  if ((gIOKitLibSerializeOptions & 1) != 0)
  {
    if (Length <= 0xFFF)
    {
      CFDataGetBytePtr(v15);
      v19 = io_service_add_notification_bin();
      goto LABEL_13;
    }
  }
  else if (Length <= 0x1FF)
  {
    BytePtr = (const char *)CFDataGetBytePtr(v15);
    v19 = io_service_add_notification(v14, a2, BytePtr, a4, a5, a6, a7);
LABEL_13:
    v7 = v19;
    goto LABEL_17;
  }
  v24 = 0;
  v20 = CFDataGetBytePtr(v15);
  v21 = io_service_add_notification_ool(v14, a2, (uint64_t)v20, v17, a4, a5, a6, &v24, a7);
  if (v21)
    v7 = v21;
  else
    v7 = v24;
LABEL_17:
  CFRelease(v15);
  if (v14 && v14 != a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v14);
  return v7;
}

void DoCFSerializeString(const __CFString *a1, CFMutableDataRef *a2)
{
  const __CFData *ExternalRepresentation;
  const __CFData *v5;
  CFIndex Length;
  const UInt8 *BytePtr;
  const UInt8 *v8;
  int v9;
  int v10;
  __CFData *v11;
  const char *p_bytes;
  CFIndex v13;
  UInt8 bytes;

  if (!previouslySerialized(a1, a2))
  {
    addStartTag(a1, 0, (uint64_t)a2);
    ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, 0x3Fu);
    if (ExternalRepresentation)
    {
      v5 = ExternalRepresentation;
      Length = CFDataGetLength(ExternalRepresentation);
      BytePtr = CFDataGetBytePtr(v5);
      if (Length >= 1)
      {
        v8 = BytePtr;
        do
        {
          v10 = *(char *)v8++;
          v9 = v10;
          if (v10 == 38)
          {
            v11 = *a2;
            p_bytes = "&amp;";
            v13 = 5;
          }
          else
          {
            if (v9 == 62)
            {
              v11 = *a2;
              p_bytes = "&gt;";
            }
            else
            {
              if (v9 != 60)
              {
                bytes = v9;
                v11 = *a2;
                p_bytes = (const char *)&bytes;
                v13 = 1;
                goto LABEL_13;
              }
              v11 = *a2;
              p_bytes = "&lt;";
            }
            v13 = 4;
          }
LABEL_13:
          CFDataAppendBytes(v11, (const UInt8 *)p_bytes, v13);
          --Length;
        }
        while (Length);
      }
      CFRelease(v5);
    }
    addEndTag(a1, a2);
  }
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  kern_return_t v3;
  mach_port_t v6;
  const __CFData *v7;
  unint64_t Length;
  int v9;
  const char *BytePtr;
  kern_return_t matching_services_bin;
  const UInt8 *v12;
  kern_return_t matching_services_ool;
  mach_port_t mainPorta;

  v3 = -536870206;
  if (!matching)
    return v3;
  v6 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v6 = 0;
    else
      v6 = mainPorta;
  }
  v7 = IOCFSerialize(matching, gIOKitLibSerializeOptions);
  CFRelease(matching);
  if (!v7)
    return -536870201;
  Length = CFDataGetLength(v7);
  v9 = Length;
  if ((gIOKitLibSerializeOptions & 1) != 0)
  {
    if (Length <= 0xFFF)
    {
      CFDataGetBytePtr(v7);
      matching_services_bin = io_service_get_matching_services_bin();
      goto LABEL_13;
    }
  }
  else if (Length <= 0x1FF)
  {
    BytePtr = (const char *)CFDataGetBytePtr(v7);
    matching_services_bin = io_service_get_matching_services(v6, BytePtr);
LABEL_13:
    v3 = matching_services_bin;
    goto LABEL_17;
  }
  v12 = CFDataGetBytePtr(v7);
  matching_services_ool = io_service_get_matching_services_ool(v6, (uint64_t)v12, v9);
  if (matching_services_ool)
    v3 = matching_services_ool;
  else
    v3 = 0;
LABEL_17:
  CFRelease(v7);
  if (v6 && v6 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v6);
  return v3;
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  kern_return_t v6;
  CFTypeRef v8;
  void *keys;

  v8 = property;
  keys = (void *)propertyName;
  v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&keys, &v8, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v4)
    return -536870211;
  v5 = v4;
  v6 = IORegistryEntrySetCFProperties(entry, v4);
  CFRelease(v5);
  return v6;
}

kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties)
{
  const __CFData *v3;
  const __CFData *v4;
  const UInt8 *BytePtr;
  int Length;
  kern_return_t v7;

  v3 = IOCFSerialize(properties, gIOKitLibSerializeOptions);
  if (!v3)
    return -536870201;
  v4 = v3;
  BytePtr = CFDataGetBytePtr(v3);
  Length = CFDataGetLength(v4);
  v7 = io_registry_entry_set_properties(entry, (uint64_t)BytePtr, Length);
  CFRelease(v4);
  if (v7)
    return v7;
  else
    return 0;
}

uint64_t io_registry_entry_set_properties(unsigned int a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  mach_msg_header_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v7 = 1;
  v8 = a2;
  v9 = 0x1000000;
  v10 = a3;
  v11 = *MEMORY[0x1E0C804E8];
  v12 = a3;
  *(_QWORD *)&v6.msgh_bits = 0x3880001513;
  *(_QWORD *)&v6.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v6.msgh_voucher_port = 0xB0C00000000;
  v3 = mach_msg2_internal();
  v4 = v3;
  if ((v3 - 268435458) <= 0xE && ((1 << (v3 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v6.msgh_local_port);
  }
  else if ((_DWORD)v3)
  {
    mig_dealloc_reply_port(v6.msgh_local_port);
  }
  else
  {
    v4 = 4294966995;
    mach_msg_destroy(&v6);
  }
  return v4;
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  mach_port_t v1;
  mach_port_name_t *v2;
  mach_port_name_t *v3;
  mach_port_t mainPorta;

  if (mainPort)
  {
    v1 = mainPort;
    IOObjectRetain(mainPort);
  }
  else
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v1 = 0;
    else
      v1 = mainPorta;
  }
  v2 = (mach_port_name_t *)malloc_type_calloc(1uLL, 0x28uLL, 0x1020040E39C8550uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = v1;
    if (mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, v2 + 1))
    {
      free(v3);
      return 0;
    }
  }
  return (IONotificationPortRef)v3;
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  mach_port_t v4;
  mach_port_t mainPorta;

  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v4 = 0;
    else
      v4 = mainPorta;
  }
  io_registry_entry_from_path(v4, path);
  if (v4 && v4 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  return 0;
}

kern_return_t IOConnectSetCFProperty(io_connect_t connect, CFStringRef propertyName, CFTypeRef property)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  kern_return_t v6;
  CFStringRef v8;
  void *values;

  v8 = propertyName;
  values = (void *)property;
  v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&v8, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v4)
    return -536870211;
  v5 = v4;
  v6 = IOConnectSetCFProperties(connect, v4);
  CFRelease(v5);
  return v6;
}

kern_return_t IOConnectSetCFProperties(io_connect_t connect, CFTypeRef properties)
{
  const __CFData *v3;
  const __CFData *v4;
  const UInt8 *BytePtr;
  int Length;
  kern_return_t v7;

  v3 = IOCFSerialize(properties, gIOKitLibSerializeOptions);
  if (!v3)
    return -536870201;
  v4 = v3;
  BytePtr = CFDataGetBytePtr(v3);
  Length = CFDataGetLength(v4);
  v7 = io_connect_set_properties(connect, (uint64_t)BytePtr, Length);
  CFRelease(v4);
  if (v7)
    return v7;
  else
    return 0;
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  mach_port_t v4;
  const __CFData *v5;
  unint64_t Length;
  int v7;
  const char *v8;
  const UInt8 *BytePtr;
  mach_port_t mainPorta;

  if (!matching)
    return 0;
  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v4 = 0;
    else
      v4 = mainPorta;
  }
  v5 = IOCFSerialize(matching, gIOKitLibSerializeOptions);
  CFRelease(matching);
  if (!v5)
    return 0;
  Length = CFDataGetLength(v5);
  v7 = Length;
  if ((gIOKitLibSerializeOptions & 1) != 0)
  {
    if (Length <= 0xFFF)
    {
      CFDataGetBytePtr(v5);
      io_service_get_matching_service_bin();
      goto LABEL_14;
    }
LABEL_13:
    BytePtr = CFDataGetBytePtr(v5);
    io_service_get_matching_service_ool(v4, (uint64_t)BytePtr, v7);
    goto LABEL_14;
  }
  if (Length > 0x1FF)
    goto LABEL_13;
  v8 = (const char *)CFDataGetBytePtr(v5);
  io_service_get_matching_service(v4, v8);
LABEL_14:
  CFRelease(v5);
  if (v4)
  {
    if (v4 != mainPort)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  }
  return 0;
}

CFDataRef IOCFSerialize(CFDataRef object, CFOptionFlags options)
{
  const __CFString *v2;
  const __CFAllocator *v3;
  CFMutableDataRef Mutable;
  __CFData *v5;
  __int128 v6;
  int v7;
  const __CFAllocator *v8;
  __int128 v9;
  CFMutableDataRef theData;
  uint64_t v11;
  CFTypeRef cf;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  CFDictionaryKeyCallBacks keyCallBacks;
  UInt8 bytes[8];
  CFMutableDictionaryRef v20;
  uint64_t v21;
  uint64_t v22;

  if (object)
  {
    v2 = (const __CFString *)object;
    v11 = 0;
    if ((options & 1) != 0)
    {
      v21 = 1;
      v22 = 0;
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      *(_QWORD *)bytes = Mutable;
      if (!Mutable)
        IOCFSerialize_cold_8();
      v5 = Mutable;
      v6 = *(_OWORD *)(MEMORY[0x1E0C9B390] + 32);
      *(_OWORD *)&keyCallBacks.release = *(_OWORD *)(MEMORY[0x1E0C9B390] + 16);
      *(_OWORD *)&keyCallBacks.equal = v6;
      *(_OWORD *)&keyCallBacks.version = *MEMORY[0x1E0C9B390];
      keyCallBacks.equal = 0;
      v20 = CFDictionaryCreateMutable(v3, 0, &keyCallBacks, 0);
      if (!v20)
        IOCFSerialize_cold_9();
      CFDataAppendBytes(v5, (const UInt8 *)byte_18AB45C68, 4);
      v7 = DoCFSerializeBinary((uint64_t)bytes, v2, 0);
      object = *(CFDataRef *)bytes;
      if (!v7 && *(_QWORD *)bytes)
      {
        CFRelease(*(CFTypeRef *)bytes);
        object = 0;
        *(_QWORD *)bytes = 0;
      }
      if (v20)
      {
        CFRelease(v20);
        return *(CFDataRef *)bytes;
      }
    }
    else if (options)
    {
      return 0;
    }
    else
    {
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      theData = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      if (!theData)
        IOCFSerialize_cold_1();
      LODWORD(v11) = 0;
      v9 = *(_OWORD *)(MEMORY[0x1E0C9B390] + 32);
      *(_OWORD *)&keyCallBacks.release = *(_OWORD *)(MEMORY[0x1E0C9B390] + 16);
      *(_OWORD *)&keyCallBacks.equal = v9;
      *(_OWORD *)&keyCallBacks.version = *MEMORY[0x1E0C9B390];
      keyCallBacks.equal = 0;
      cf = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      if (!cf)
        IOCFSerialize_cold_2();
      v13 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      if (!v13)
        IOCFSerialize_cold_3();
      v14 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      if (!v14)
        IOCFSerialize_cold_4();
      v15 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      if (!v15)
        IOCFSerialize_cold_5();
      v16 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      if (!v16)
        IOCFSerialize_cold_6();
      v17 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      if (!v17)
        IOCFSerialize_cold_7();
      if (DoIdrefScan(v2, (uint64_t)&theData) && DoCFSerialize(v2, &theData))
      {
        bytes[0] = 0;
        CFDataAppendBytes(theData, bytes, 1);
      }
      else if (theData)
      {
        CFRelease(theData);
        theData = 0;
      }
      if (cf)
        CFRelease(cf);
      if (v13)
        CFRelease(v13);
      if (v14)
        CFRelease(v14);
      if (v15)
        CFRelease(v15);
      if (v16)
        CFRelease(v16);
      if (v17)
        CFRelease(v17);
      return theData;
    }
  }
  return object;
}

kern_return_t IOMasterPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  host_t v3;
  kern_return_t io_main;
  _QWORD block[5];

  v3 = MEMORY[0x18D772924](*(_QWORD *)&bootstrapPort);
  io_main = host_get_io_main(v3, mainPort);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOMasterPort_block_invoke;
  block[3] = &__block_descriptor_tmp_0;
  block[4] = mainPort;
  if (IOMasterPort_versionOnce != -1)
  {
    dispatch_once(&IOMasterPort_versionOnce, block);
    if (!v3)
      return io_main;
    goto LABEL_3;
  }
  if (v3)
LABEL_3:
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v3);
  return io_main;
}

uint64_t io_service_get_matching_service_bin()
{
  unsigned int v0;
  unsigned int v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v0 = MEMORY[0x1E0C80A78]();
  v39 = *MEMORY[0x1E0C80C00];
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (v1 > 0x1000)
    return 4294966989;
  v3 = v1;
  v4 = v0;
  __memcpy_chk();
  LODWORD(v9) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 36;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), v4);
  *(_QWORD *)&v8 = 0xB4000000000;
  v5 = mach_msg2_internal();
  v2 = v5;
  if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v5)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v2 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v2;
}

uint64_t io_connect_set_properties(unsigned int a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  mach_msg_header_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v7 = 1;
  v8 = a2;
  v9 = 0x1000000;
  v10 = a3;
  v11 = *MEMORY[0x1E0C804E8];
  v12 = a3;
  *(_QWORD *)&v6.msgh_bits = 0x3880001513;
  *(_QWORD *)&v6.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v6.msgh_voucher_port = 0xB0500000000;
  v3 = mach_msg2_internal();
  v4 = v3;
  if ((v3 - 268435458) <= 0xE && ((1 << (v3 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v6.msgh_local_port);
  }
  else if ((_DWORD)v3)
  {
    mig_dealloc_reply_port(v6.msgh_local_port);
  }
  else
  {
    v4 = 4294966995;
    mach_msg_destroy(&v6);
  }
  return v4;
}

uint64_t io_registry_entry_from_path(unsigned int a1, const char *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  _OWORD v9[32];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(v9, 0, 480);
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 512);
  else
    v3 = mig_strncpy((char *)v9 + 8, a2, 512);
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v8 = 0xAF900000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

uint64_t DoIdrefScan(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  CFIndex Count;
  uint64_t v6;
  size_t v7;
  const void **v8;
  const void **v9;
  const void **v10;
  uint64_t i;
  char v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex j;
  const void *ValueAtIndex;
  uint64_t result;
  CFIndex v18;
  uint64_t v19;
  const void **v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  int v24;

  if (!a1)
    DoIdrefScan_cold_1();
  recordObjectInIDRefDictionary(a1, a2);
  v4 = CFGetTypeID(a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    Count = CFDictionaryGetCount((CFDictionaryRef)a1);
    if (Count)
    {
      v6 = Count;
      v7 = 8 * Count;
      v8 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      v9 = (const void **)malloc_type_malloc(v7, 0x80040B8603338uLL);
      if (!v8)
        return 0;
      v10 = v9;
      if (!v9)
        return 0;
      CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v8, v9);
      if (v6 >= 1)
      {
        for (i = 0; i < v6; ++i)
        {
          v12 = DoIdrefScan(v10[i], a2);
          if ((v12 & 1) == 0)
            break;
        }
        free(v8);
        free(v10);
        return (v12 & 1) != 0;
      }
      free(v8);
LABEL_30:
      free(v10);
      return 1;
    }
    return 1;
  }
  if (v4 != CFArrayGetTypeID())
  {
    if (v4 != CFSetGetTypeID())
      return 1;
    v18 = CFSetGetCount((CFSetRef)a1);
    if (!v18)
      return 1;
    v19 = v18;
    v20 = (const void **)malloc_type_malloc(8 * v18, 0x80040B8603338uLL);
    if (!v20)
      return 0;
    v10 = v20;
    CFSetGetValues((CFSetRef)a1, v20);
    if (v19 >= 1)
    {
      v21 = 0;
      do
      {
        v22 = DoIdrefScan(v10[v21++], a2);
        if (v22)
          v23 = v21 < v19;
        else
          v23 = 0;
      }
      while (v23);
      v24 = v22;
      free(v10);
      return v24 != 0;
    }
    goto LABEL_30;
  }
  v13 = CFArrayGetCount((CFArrayRef)a1);
  if (v13 < 1)
    return 1;
  v14 = v13;
  for (j = 0; j != v14; ++j)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, j);
    result = DoIdrefScan(ValueAtIndex, a2);
    if (!(_DWORD)result)
      break;
  }
  return result;
}

void recordObjectInIDRefDictionary(const void *a1, uint64_t a2)
{
  const __CFDictionary *v3;
  __CFDictionary *v4;

  if (a1)
  {
    if (a2)
    {
      v3 = (const __CFDictionary *)idRefDictionaryForObject(a1, a2);
      if (v3)
      {
        v4 = v3;
        if (CFDictionaryGetValue(v3, a1))
          CFDictionarySetValue(v4, a1, (const void *)*MEMORY[0x1E0C9AE50]);
        else
          CFDictionaryAddValue(v4, a1, (const void *)*MEMORY[0x1E0C9AE40]);
      }
    }
  }
}

uint64_t DoCFSerialize(const __CFString *a1, CFMutableDataRef *a2)
{
  const __CFString *v3;
  CFTypeID v4;
  CFIndex Count;
  uint64_t v6;
  uint64_t result;
  void *v8;
  BOOL v9;
  uint64_t v10;
  const __CFString *v11;
  const __CFData *ExternalRepresentation;
  const __CFData *v13;
  int64_t Length;
  const char *BytePtr;
  unint64_t v16;
  unint64_t v17;
  int v18;
  _BOOL4 v19;
  int v20;
  int v21;
  __CFData *v22;
  const char *v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  CFIndex i;
  const void *ValueAtIndex;
  unint64_t v29;
  CFIndex v30;
  const UInt8 *v31;
  unint64_t v32;
  CFIndex v33;
  unint64_t v34;
  unint64_t v35;
  const void *v36;
  size_t v37;
  __CFData *v38;
  const __CFString *v39;
  const __CFAllocator *alloc;
  void *v41;
  const void **v42;
  uint64_t valuePtr;
  UInt8 bytes[32];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!a1)
    DoCFSerialize_cold_1();
  v3 = a1;
  v4 = CFGetTypeID(a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    if (previouslySerialized(v3, a2))
      return 1;
    addStartTag(v3, 0, (uint64_t)a2);
    Count = CFDictionaryGetCount((CFDictionaryRef)v3);
    if (Count)
    {
      v6 = Count;
      result = (uint64_t)malloc_type_malloc(16 * Count, 0x80040B8603338uLL);
      if (!result)
        return result;
      v8 = (void *)result;
      v39 = v3;
      v42 = (const void **)(result + 8 * v6);
      CFDictionaryGetKeysAndValues((CFDictionaryRef)v3, v42, (const void **)result);
      if (v6 >= 1)
      {
        v9 = 0;
        v10 = 0;
        alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v41 = v8;
        while (1)
        {
          v11 = (const __CFString *)v42[v10];
          CFDataAppendBytes(*a2, (const UInt8 *)"<key>", 5);
          ExternalRepresentation = CFStringCreateExternalRepresentation(alloc, v11, 0x8000100u, 0x3Fu);
          v13 = ExternalRepresentation;
          if (ExternalRepresentation)
          {
            Length = CFDataGetLength(ExternalRepresentation);
            BytePtr = (const char *)CFDataGetBytePtr(v13);
          }
          else
          {
            Length = 0;
            BytePtr = "";
          }
          if (!strncmp(BytePtr, "AppleLSIFusionFC", Length))
          {
            v19 = 1;
          }
          else
          {
            v16 = 0;
            do
            {
              v17 = v16;
              if (v16 == 6)
                break;
              v18 = strncmp(BytePtr, off_1E2001A98[v16 + 1], Length);
              v16 = v17 + 1;
            }
            while (v18);
            v19 = v17 < 6;
          }
          if (Length >= 1)
          {
            do
            {
              v21 = *BytePtr++;
              v20 = v21;
              if (v21 == 38)
              {
                v22 = *a2;
                v23 = "&amp;";
                v24 = 5;
              }
              else
              {
                if (v20 == 62)
                {
                  v22 = *a2;
                  v23 = "&gt;";
                }
                else
                {
                  if (v20 != 60)
                  {
                    bytes[0] = v20;
                    v22 = *a2;
                    v23 = (const char *)bytes;
                    v24 = 1;
                    goto LABEL_26;
                  }
                  v22 = *a2;
                  v23 = "&lt;";
                }
                v24 = 4;
              }
LABEL_26:
              CFDataAppendBytes(v22, (const UInt8 *)v23, v24);
              --Length;
            }
            while (Length);
          }
          if (v13)
            CFRelease(v13);
          CFDataAppendBytes(*a2, (const UInt8 *)"</key>", 6);
          v8 = v41;
          if (v19)
            CFDataAppendBytes(*a2, (const UInt8 *)"<!--  -->", 13);
          if (!DoCFSerialize(*((_QWORD *)v41 + v10), a2))
            break;
          v9 = ++v10 >= v6;
          if (v10 == v6)
            goto LABEL_69;
        }
        free(v41);
        return v9;
      }
      v9 = 1;
LABEL_69:
      free(v8);
      v3 = v39;
    }
    else
    {
      v9 = 1;
    }
    addEndTag(v3, a2);
    return v9;
  }
  if (v4 == CFStringGetTypeID())
  {
    DoCFSerializeString(v3, a2);
    return 1;
  }
  if (v4 == CFArrayGetTypeID())
  {
    if (previouslySerialized(v3, a2))
      return 1;
    addStartTag(v3, 0, (uint64_t)a2);
    v25 = CFArrayGetCount((CFArrayRef)v3);
    if (v25 < 1)
      goto LABEL_82;
    v26 = v25;
    for (i = 0; i < v26; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, i);
      result = DoCFSerialize(ValueAtIndex, a2);
      if (!(_DWORD)result)
        break;
    }
    if ((_DWORD)result)
      goto LABEL_82;
    return result;
  }
  if (v4 == CFNumberGetTypeID())
  {
    if (previouslySerialized(v3, a2))
      return 1;
    valuePtr = 0;
    result = CFNumberGetValue((CFNumberRef)v3, kCFNumberLongLongType, &valuePtr);
    if (!(_DWORD)result)
      return result;
    v29 = CFNumberGetType((CFNumberRef)v3) - 1;
    if (v29 <= 8 && ((0x1C7u >> v29) & 1) != 0)
    {
      snprintf((char *)bytes, 0x20uLL, "size=\"%d\"", dword_18AB45BA0[v29]);
      addStartTag(v3, (uint64_t)bytes, (uint64_t)a2);
      snprintf((char *)bytes, 0x20uLL, "0x%lx");
    }
    else
    {
      snprintf((char *)bytes, 0x20uLL, "size=\"%d\"", 64);
      addStartTag(v3, (uint64_t)bytes, (uint64_t)a2);
      snprintf((char *)bytes, 0x20uLL, "0x%qx");
    }
    v37 = strlen((const char *)bytes);
    v38 = *a2;
    goto LABEL_81;
  }
  if (v4 == CFDataGetTypeID())
  {
    if (previouslySerialized(v3, a2))
      return 1;
    v30 = CFDataGetLength((CFDataRef)v3);
    v31 = CFDataGetBytePtr((CFDataRef)v3);
    addStartTag(v3, 0, (uint64_t)a2);
    if (v30 < 1)
      goto LABEL_82;
    v32 = 0;
    v33 = v30;
    while (1)
    {
      v34 = v32 % 3;
      if (v32 % 3 == 2)
        break;
      if (v34 == 1)
      {
        v35 = ((unint64_t)(*v31 | (*(v31 - 1) << 8)) >> 4) & 0x3F;
        goto LABEL_61;
      }
      if (!v34)
      {
        v35 = (unint64_t)*v31 >> 2;
LABEL_61:
        bytes[0] = __CFPLDataEncodeTable[v35];
        CFDataAppendBytes(*a2, bytes, 1);
      }
      ++v32;
      ++v31;
      if (!--v33)
      {
        if (v30 % 3uLL != 2)
        {
          if (v30 % 3uLL == 1)
          {
            bytes[0] = __CFPLDataEncodeTable[16 * (*(v31 - 1) & 3)];
            CFDataAppendBytes(*a2, bytes, 1);
            bytes[0] = 61;
            CFDataAppendBytes(*a2, bytes, 1);
            bytes[0] = 61;
            goto LABEL_80;
          }
LABEL_82:
          addEndTag(v3, a2);
          return 1;
        }
        bytes[0] = __CFPLDataEncodeTable[4 * (*(v31 - 1) & 0xF)];
        CFDataAppendBytes(*a2, bytes, 1);
        bytes[0] = 61;
LABEL_80:
        v38 = *a2;
        v37 = 1;
LABEL_81:
        CFDataAppendBytes(v38, bytes, v37);
        goto LABEL_82;
      }
    }
    bytes[0] = __CFPLDataEncodeTable[((unint64_t)(*v31 | (*(v31 - 1) << 8)) >> 6) & 0x3F];
    CFDataAppendBytes(*a2, bytes, 1);
    v35 = *v31 & 0x3F;
    goto LABEL_61;
  }
  if (v4 == CFBooleanGetTypeID())
  {
    DoCFSerializeBoolean((const __CFBoolean *)v3, a2);
    return 1;
  }
  if (v4 == CFSetGetTypeID())
    return DoCFSerializeSet(v3, a2);
  result = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<string>typeID 0x%x not serializable</string>"), v4);
  if (result)
  {
    v36 = (const void *)result;
    DoCFSerializeString((const __CFString *)result, a2);
    CFRelease(v36);
    return 1;
  }
  return result;
}

uint64_t previouslySerialized(const void *a1, CFMutableDataRef *a2)
{
  uint64_t result;
  const __CFNumber *v5;
  CFTypeID v6;
  const char *TagString;
  size_t v8;
  int valuePtr;
  char __str[64];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  CFNullGetTypeID();
  result = 0;
  valuePtr = -1;
  if (a1)
  {
    if (a2)
    {
      result = idRefDictionaryForObject(a1, (uint64_t)a2);
      if (result)
      {
        result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)result, a1);
        if (result)
        {
          v5 = (const __CFNumber *)result;
          v6 = CFGetTypeID((CFTypeRef)result);
          if (v6 == CFBooleanGetTypeID() || v6 != CFNumberGetTypeID())
          {
            return 0;
          }
          else
          {
            result = CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
            if ((_DWORD)result)
            {
              TagString = getTagString(a1);
              snprintf(__str, 0x40uLL, "<%s IDREF=\"%d\"/>", TagString, valuePtr);
              v8 = strlen(__str);
              CFDataAppendBytes(*a2, (const UInt8 *)__str, v8);
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t idRefDictionaryForObject(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  uint64_t v5;

  CFNullGetTypeID();
  v4 = CFGetTypeID(a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    v5 = a2 + 40;
    return *(_QWORD *)v5;
  }
  if (v4 == CFStringGetTypeID())
  {
    v5 = a2 + 16;
    return *(_QWORD *)v5;
  }
  if (v4 == CFArrayGetTypeID())
  {
    v5 = a2 + 48;
    return *(_QWORD *)v5;
  }
  if (v4 == CFNumberGetTypeID())
  {
    v5 = a2 + 24;
    return *(_QWORD *)v5;
  }
  if (v4 == CFDataGetTypeID())
  {
    v5 = a2 + 32;
    return *(_QWORD *)v5;
  }
  if (v4 == CFSetGetTypeID())
  {
    v5 = a2 + 56;
    return *(_QWORD *)v5;
  }
  return 0;
}

void addEndTag(const void *a1, CFMutableDataRef *a2)
{
  const char *TagString;
  size_t v4;
  char __str[128];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  TagString = getTagString(a1);
  snprintf(__str, 0x80uLL, "</%s>", TagString);
  v4 = strlen(__str);
  CFDataAppendBytes(*a2, (const UInt8 *)__str, v4);
}

void addStartTag(const void *a1, uint64_t a2, uint64_t a3)
{
  const __CFDictionary *Value;
  __CFDictionary *v7;
  int v8;
  CFNumberRef v9;
  CFNumberRef v10;
  size_t v11;
  int valuePtr;
  char __str[128];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  Value = (const __CFDictionary *)idRefDictionaryForObject(a1, a3);
  v7 = Value;
  if (Value)
    Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a1);
  if (Value == (const __CFDictionary *)*MEMORY[0x1E0C9AE50])
  {
    v8 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = v8 + 1;
    valuePtr = v8;
    v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    if (!v9)
      addStartTag_cold_1();
    v10 = v9;
    CFDictionarySetValue(v7, a1, v9);
    CFRelease(v10);
    getTagString(a1);
    if (a2)
      snprintf(__str, 0x80uLL, "<%s ID=\"%d\" %s>");
    else
      snprintf(__str, 0x80uLL, "<%s ID=\"%d\">");
  }
  else
  {
    getTagString(a1);
    if (a2)
      snprintf(__str, 0x80uLL, "<%s %s>");
    else
      snprintf(__str, 0x80uLL, "<%s>");
  }
  v11 = strlen(__str);
  CFDataAppendBytes(*(CFMutableDataRef *)a3, (const UInt8 *)__str, v11);
}

const char *getTagString(const void *a1)
{
  CFTypeID v1;

  if (!a1)
    getTagString_cold_1();
  v1 = CFGetTypeID(a1);
  if (v1 == CFStringGetTypeID())
    return "string";
  if (v1 == CFNumberGetTypeID())
    return "integer";
  if (v1 == CFDataGetTypeID())
    return "data";
  if (v1 == CFDictionaryGetTypeID())
    return "dict";
  if (v1 == CFArrayGetTypeID())
    return "array";
  if (v1 == CFSetGetTypeID())
    return "set";
  return "internal error";
}

uint64_t io_service_get_matching_services_bin()
{
  unsigned int v0;
  unsigned int v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v0 = MEMORY[0x1E0C80A78]();
  v39 = *MEMORY[0x1E0C80C00];
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (v1 > 0x1000)
    return 4294966989;
  v3 = v1;
  v4 = v0;
  __memcpy_chk();
  LODWORD(v9) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 36;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), v4);
  *(_QWORD *)&v8 = 0xB4100000000;
  v5 = mach_msg2_internal();
  v2 = v5;
  if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v5)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v2 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v2;
}

kern_return_t IOObjectRetain(io_object_t object)
{
  ipc_space_t *v2;
  kern_return_t result;

  v2 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  result = mach_port_mod_refs(*MEMORY[0x1E0C83DA0], object, 0, 1);
  if (result == 17)
    return mach_port_mod_refs(*v2, object, 4u, 1);
  return result;
}

uint64_t io_service_add_notification_bin()
{
  unsigned int v0;
  const char *v1;
  _DWORD *v2;
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  const void *v6;
  const void *v7;
  unsigned int v8;
  unsigned int v9;
  const void *v10;
  const void *v11;
  unsigned int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  char *v19;
  mach_port_t v20;
  uint64_t v21;
  mach_msg_header_t reply_port;
  int v23;
  int v24;
  __int128 v25;
  _OWORD v26[269];
  uint64_t v27;

  v0 = MEMORY[0x1E0C80A78]();
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v0;
  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0u;
  memset(v26, 0, 464);
  memset(&reply_port, 0, sizeof(reply_port));
  v23 = 1;
  v24 = v13;
  DWORD1(v25) = 1310720;
  *((_QWORD *)&v25 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v14 = mig_strncpy_zerofill((char *)v26 + 8, v1, 128);
  else
    v14 = mig_strncpy((char *)v26 + 8, v1, 128);
  LODWORD(v26[0]) = 0;
  DWORD1(v26[0]) = v14;
  if (v9 > 0x1000)
    return 4294966989;
  v15 = (v14 + 3) & 0xFFFFFFFC;
  memcpy((char *)v26 + v15 + 12, v11, v9);
  *(_DWORD *)((char *)v26 + v15 + 8) = v9;
  if (v5 > 8)
    return 4294966989;
  v18 = (v9 + 3) & 0xFFFFFFFC;
  v19 = (char *)&reply_port + v15 + v18 - 128;
  memcpy(v19 + 192, v7, 8 * v5);
  *((_DWORD *)v19 + 47) = v5;
  v20 = mig_get_reply_port();
  reply_port.msgh_bits = -2147478253;
  reply_port.msgh_size = v18 + 8 * v5 + v15 + 64;
  *(_QWORD *)&reply_port.msgh_remote_port = __PAIR64__(v20, v12);
  *(_QWORD *)&reply_port.msgh_voucher_port = 0xB4400000000;
  v21 = mach_msg2_internal();
  v16 = v21;
  if ((v21 - 268435458) <= 0xE && ((1 << (v21 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v21)
    {
      if (reply_port.msgh_id == 71)
      {
        v16 = 4294966988;
      }
      else if (reply_port.msgh_id == 2984)
      {
        if ((reply_port.msgh_bits & 0x80000000) != 0)
        {
          v16 = 4294966996;
          if (v23 == 1 && reply_port.msgh_size == 40 && !reply_port.msgh_remote_port && WORD3(v25) << 16 == 1114112)
          {
            v16 = 0;
            *v3 = v24;
            return v16;
          }
        }
        else if (reply_port.msgh_size == 36)
        {
          v16 = 4294966996;
          if ((_DWORD)v25)
          {
            if (reply_port.msgh_remote_port)
              v16 = 4294966996;
            else
              v16 = v25;
          }
        }
        else
        {
          v16 = 4294966996;
        }
      }
      else
      {
        v16 = 4294966995;
      }
      mach_msg_destroy(&reply_port);
      return v16;
    }
    mig_dealloc_reply_port(reply_port.msgh_local_port);
  }
  return v16;
}

__CFDictionary *__OSKextCreateKextRequest(const void *a1, unint64_t a2, __CFDictionary **a3)
{
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFDictionary *v13;
  CFMutableDictionaryRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFDictionary *v20;
  char v22;

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v13 = Mutable;
  if (Mutable)
  {
    CFDictionarySetValue(Mutable, CFSTR("Kext Request Predicate"), a1);
    if (a2 | (unint64_t)a3)
    {
      v14 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v14)
      {
        v20 = v14;
        CFDictionarySetValue(v13, CFSTR("Kext Request Arguments"), v14);
        if (a3)
          *a3 = v20;
        if (a2)
          CFDictionarySetValue(v20, CFSTR("CFBundleIdentifier"), (const void *)a2);
        CFRelease(v20);
      }
      else
      {
        OSKextLog(0, 17, "Memory allocation failure.", v15, v16, v17, v18, v19, v22);
        CFRelease(v13);
        return 0;
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v8, v9, v10, v11, v12, v22);
  }
  return v13;
}

BOOL _IOHIDEventEqual(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  unsigned int *v4;
  size_t v5;
  _DWORD *v6;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
      && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24)
      && (v4 = *(unsigned int **)(a1 + 104), v5 = *v4, v6 = *(_DWORD **)(a2 + 104), (_DWORD)v5 == *v6))
    {
      return memcmp(v4, v6, v5) == 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IOHIDServiceFilterOpen(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v2)(void);

  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v2 = *(uint64_t (**)(void))(*(_QWORD *)result + 56);
    if (v2)
      return v2();
  }
  return result;
}

void __IOHIDServiceFilterRelease(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  v2 = a1[3];
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = a1[2];
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = (const void *)a1[12];
  if (v4)
    CFRelease(v4);
  v5 = a1[4];
  if (v5)
    dispatch_release(v5);
  v6 = (const void *)a1[11];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[10];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[8];
  if (v8)
    _Block_release(v8);
}

uint64_t IOHIDServiceFilterClose(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v2)(void);

  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v2 = *(uint64_t (**)(void))(*(_QWORD *)result + 64);
    if (v2)
      return v2();
  }
  return result;
}

_QWORD *IOHIDEventSetFloatValue(_QWORD *a1, unsigned int a2, double a3)
{
  return IOHIDEventSetFloatValueWithOptions(a1, a2, 4026531840, a3);
}

uint64_t _IOHIDEventSystemClientCopyEventForService(uint64_t a1, IOHIDServiceClientRef service, int a3, const __CFData *a4, int a5)
{
  uint64_t v5;
  const __CFAllocator *v10;
  CFTypeRef RegistryID;
  const __CFData *v12;
  const __CFData *v13;
  const UInt8 *BytePtr;
  __CFData *DataInternal;
  __CFData *v16;
  const __CFData *v17;
  const UInt8 *v18;
  int v19;
  uint64_t v20;
  const UInt8 *v21;
  int v22;
  uint64_t v23;
  UInt8 *v25;
  mach_vm_size_t v26;
  CFTypeID TypeID;
  const void *v28;
  const void *v29;
  int Length;
  unsigned int v31;
  UInt8 *v32;

  v5 = 0;
  if (a1 && service)
  {
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    RegistryID = IOHIDServiceClientGetRegistryID(service);
    v12 = (const __CFData *)_IOHIDCreateBinaryData(v10, RegistryID);
    if (v12)
    {
      v13 = v12;
      v32 = 0;
      v31 = 0;
      BytePtr = CFDataGetBytePtr(v12);
      Length = CFDataGetLength(v13);
      if (a4)
      {
        DataInternal = IOHIDEventCreateDataInternal(v10, (uint64_t)a4);
        if (DataInternal)
        {
          v16 = DataInternal;
          v17 = (const __CFData *)_IOHIDCreateBinaryData(v10, DataInternal);
          a4 = v17;
          if (v17)
          {
            v18 = CFDataGetBytePtr(v17);
            v19 = CFDataGetLength(a4);
          }
          else
          {
            v18 = 0;
            v19 = 0;
          }
          CFRelease(v16);
LABEL_13:
          os_unfair_recursive_lock_lock_with_options();
          v20 = io_hideventsystem_copy_event_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, a3, (uint64_t)v18, v19, a5, &v32, &v31);
          v21 = BytePtr;
          v22 = v20;
          if ((_DWORD)v20 == 268435459)
          {
            if (*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400))
            {
              os_unfair_recursive_lock_unlock();
              goto LABEL_19;
            }
            v23 = (uint64_t)v21;
            __IOHIDEventSystemClientTerminationCallback(v20, a1, 0);
            v22 = io_hideventsystem_copy_event_for_service(*(_DWORD *)(a1 + 32), v23, Length, a3, (uint64_t)v18, v19, a5, &v32, &v31);
          }
          os_unfair_recursive_lock_unlock();
          if (!v22)
          {
            v25 = v32;
            v26 = v31;
            TypeID = CFDataGetTypeID();
            v28 = _IOHIDUnserializeAndVMDeallocWithTypeID(v25, v26, TypeID);
            if (v28)
            {
              v29 = v28;
              v5 = IOHIDEventCreateWithDataInternal(v10, v28);
              CFRelease(v29);
              if (!a4)
                goto LABEL_21;
              goto LABEL_20;
            }
          }
LABEL_19:
          v5 = 0;
          if (!a4)
          {
LABEL_21:
            CFRelease(v13);
            return v5;
          }
LABEL_20:
          CFRelease(a4);
          goto LABEL_21;
        }
        a4 = 0;
      }
      v18 = 0;
      v19 = 0;
      goto LABEL_13;
    }
    return 0;
  }
  return v5;
}

uint64_t io_hideventsystem_copy_event_for_service(mach_port_t a1, uint64_t a2, int a3, int a4, uint64_t a5, int a6, int a7, _QWORD *a8, _DWORD *a9)
{
  mach_port_t special_reply_port;
  uint64_t v12;
  uint64_t v13;
  int v14;
  mach_msg_header_t msg;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;

  v17 = 2;
  v18 = a2;
  v19 = 16777472;
  v20 = a3;
  v21 = a5;
  v22 = 16777472;
  v23 = a6;
  v24 = *MEMORY[0x1E0C804E8];
  v25 = a3;
  v26 = a4;
  v27 = a6;
  v28 = a7;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1117700000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v12 = mach_msg(&msg, 3162115, 0x54u, 0x40u, special_reply_port, 0, 0);
  v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v12)
    {
      if (msg.msgh_id == 71)
      {
        v13 = 4294966988;
      }
      else if (msg.msgh_id == 70107)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v13 = 4294966996;
            if (HIDWORD(v18))
            {
              if (msg.msgh_remote_port)
                v13 = 4294966996;
              else
                v13 = HIDWORD(v18);
            }
          }
          else
          {
            v13 = 4294966996;
          }
          goto LABEL_27;
        }
        v13 = 4294966996;
        if (v17 == 1 && msg.msgh_size == 56 && !msg.msgh_remote_port && HIBYTE(v19) == 1)
        {
          v14 = v20;
          if (v20 == v22)
          {
            v13 = 0;
            *a8 = v18;
            *a9 = v14;
            return v13;
          }
        }
      }
      else
      {
        v13 = 4294966995;
      }
LABEL_27:
      mach_msg_destroy(&msg);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v13 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_27;
  }
  return v13;
}

uint64_t _Xio_hideventsystem_copy_event_for_service(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 84)
  {
    v3 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_12;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 68)
    || *(_DWORD *)(result + 56) != *(_DWORD *)(result + 76))
  {
    v3 = -300;
    goto LABEL_11;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = _io_hideventsystem_copy_event_for_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(unsigned int *)(result + 40), *(unsigned int *)(result + 72), *(UInt8 **)(result + 44), *(_DWORD *)(result + 56), *(unsigned int *)(result + 80), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_12:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(_QWORD *)(a2 + 44) = *MEMORY[0x1E0C804E8];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _io_hideventsystem_copy_event_for_service(unsigned int a1, UInt8 *bytes, CFIndex length, uint64_t a4, UInt8 *a5, unsigned int a6, uint64_t a7, vm_offset_t *a8, _DWORD *a9)
{
  CFPropertyListRef v15;
  CFTypeID TypeID;
  const void *v17;
  const void *v18;
  const void *v19;
  CFTypeID v20;
  CFAllocatorRef v21;
  const void *v22;
  uint64_t System;
  const void *v24;
  const void *v25;
  uint64_t v26;
  const void *v27;
  const __CFAllocator *v28;
  __CFData *DataInternal;
  __CFData *v30;

  *a9 = 0;
  v15 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  TypeID = CFDataGetTypeID();
  v17 = _IOHIDUnserializeAndVMDeallocWithTypeID(a5, a6, TypeID);
  if (v15)
  {
    v18 = IOMIGMachPortCacheCopy(a1);
    v19 = v18;
    if (v18 && (v20 = CFGetTypeID(v18), v20 == IOHIDEventSystemConnectionGetTypeID()))
    {
      if (v17)
      {
        v21 = CFGetAllocator(v19);
        v22 = (const void *)IOHIDEventCreateWithDataInternal(v21, v17);
      }
      else
      {
        v22 = 0;
      }
      if (IOHIDEventSystemConnectionGetType((uint64_t)v19) == 2
        || IOHIDEventSystemConnectionGetType((uint64_t)v19) == 4
        || (System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v19)) == 0)
      {
        v25 = 0;
        if (v22)
LABEL_16:
          CFRelease(v22);
      }
      else
      {
        v24 = IOHIDEventSystemCopyService(System, v15);
        v25 = v24;
        if (v24)
        {
          v26 = IOHIDServiceCopyEvent((uint64_t)v24, a4, (uint64_t)v22, a7);
          if (v26)
          {
            v27 = (const void *)v26;
            v28 = CFGetAllocator(v19);
            DataInternal = IOHIDEventCreateDataInternal(v28, (uint64_t)v27);
            if (DataInternal)
            {
              v30 = DataInternal;
              *a9 = _IOHIDSerialize(DataInternal, a8);
              CFRelease(v30);
            }
            CFRelease(v27);
          }
        }
        if (v22)
          goto LABEL_16;
      }
    }
    else
    {
      v25 = 0;
    }
  }
  else
  {
    v25 = 0;
    v19 = 0;
  }
  if (v17)
    CFRelease(v17);
  if (v25)
    CFRelease(v25);
  if (v15)
    CFRelease(v15);
  if (v19)
    CFRelease(v19);
  return 0;
}

uint64_t IOHIDServiceCopyEventForClient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(void);
  id v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t);
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const __CFNumber *v20;
  uint64_t v21;
  const __CFArray *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v27[6];
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  _OWORD valuePtr[5];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  v30 = &v29;
  v31 = 0x2000000000;
  v32 = 0;
  v10 = mach_absolute_time();
  *(_QWORD *)&valuePtr[0] = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, valuePtr);
  _IOHIDDebugTrace(8263, 1, *(uint64_t *)&valuePtr[0], a2, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v28, valuePtr);
  ++**(_DWORD **)(a1 + 72);
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
  {
    v12 = *(uint64_t (**)(void))(*(_QWORD *)v11 + 88);
    if (v12)
    {
      v13 = (id)v12();
LABEL_11:
      v30[3] = (uint64_t)v13;
      goto LABEL_12;
    }
  }
  v14 = *(_QWORD *)(a1 + 360);
  if (v14)
  {
    v15 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(v14 + 64);
    if (v15)
    {
      v13 = (id)v15(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), a2, a3, a4);
      goto LABEL_11;
    }
  }
  v16 = *(void **)(a1 + 480);
  if (v16)
  {
    v17 = *(const char **)(a1 + 568);
    if (v17)
    {
      v13 = objc_msgSend(v16, v17, a2, a3, a4);
      goto LABEL_11;
    }
  }
LABEL_12:
  v18 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v18)
  {
    --*(_DWORD *)v18;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v28, valuePtr);
  }
  v19 = v30[3];
  if (v19)
  {
    if (!IOHIDEventGetSenderID(v19))
    {
      v20 = *(const __CFNumber **)(a1 + 48);
      *(_QWORD *)&valuePtr[0] = 0;
      if (v20)
      {
        CFNumberGetValue(v20, kCFNumberSInt64Type, valuePtr);
        v21 = *(_QWORD *)&valuePtr[0];
      }
      else
      {
        v21 = 0;
      }
      IOHIDEventSetSenderID(v30[3], v21);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v28, valuePtr);
    ++**(_DWORD **)(a1 + 72);
    v22 = *(const __CFArray **)(a1 + 248);
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 0x40000000;
    v27[2] = __IOHIDServiceCopyEventForClient_block_invoke;
    v27[3] = &unk_1E2002C10;
    v27[4] = &v29;
    v27[5] = a5;
    _IOHIDCFArrayApplyBlock(v22, v27);
    v23 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)v23)
    {
      --*(_DWORD *)v23;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v28, valuePtr);
    }
  }
  *(_QWORD *)&valuePtr[0] = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, valuePtr);
  _IOHIDDebugTrace(8263, 2, *(uint64_t *)&valuePtr[0], a2, 0, 0);
  v24 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v24, v10, 0x3E8u);
  if (*(_QWORD *)(a1 + 464))
    IOHIDAnalyticsEventSetIntegerValueForField();
  v25 = v30[3];
  _Block_object_dispose(&v29, 8);
  return v25;
}

uint64_t IOHIDVirtualServiceClientDispatchEvent(__IOHIDServiceClient *a1, uint64_t a2)
{
  uint64_t EventSystemClient;
  const __CFNumber *RegistryID;
  const __CFAllocator *v6;
  __CFData *DataInternal;
  const __CFData *v8;
  int v9;
  uint64_t v10;
  const UInt8 *BytePtr;
  int Length;
  int v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v17;
  uint64_t valuePtr;

  valuePtr = 0;
  EventSystemClient = _IOHIDVirtuaServiceClientGetEventSystemClient((uint64_t)a1);
  RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(a1);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  IOHIDEventSetSenderID(a2, valuePtr);
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DataInternal = IOHIDEventCreateDataInternal((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  v8 = (const __CFData *)_IOHIDCreateBinaryData(v6, DataInternal);
  if (!v8)
  {
    v17 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      IOHIDVirtualServiceClientDispatchEvent_cold_1();
LABEL_5:
    v15 = 0;
    if (!DataInternal)
      goto LABEL_7;
    goto LABEL_6;
  }
  os_unfair_recursive_lock_lock_with_options();
  v9 = *(_DWORD *)(EventSystemClient + 32);
  v10 = valuePtr;
  BytePtr = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v8);
  v13 = io_hideventsystem_dispatch_event_for_virtual_service(v9, v10, (uint64_t)BytePtr, Length);
  os_unfair_recursive_lock_unlock();
  if (v13)
  {
    v14 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      IOHIDVirtualServiceClientDispatchEvent_cold_2();
    goto LABEL_5;
  }
  v15 = 1;
  if (DataInternal)
LABEL_6:
    CFRelease(DataInternal);
LABEL_7:
  if (v8)
    CFRelease(v8);
  return v15;
}

uint64_t IOHIDEventSetSenderID(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t io_hideventsystem_dispatch_event_for_virtual_service(int a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v6;
  int v7;
  mach_port_name_t name[4];
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;

  v9 = a3;
  v10 = 16777472;
  v11 = a4;
  v12 = *MEMORY[0x1E0C804E8];
  v13 = a2;
  v14 = a4;
  v6 = 2147483667;
  v7 = a1;
  *(_OWORD *)name = xmmword_18AB47760;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set((mach_msg_header_t *)&v6);
  v4 = mach_msg((mach_msg_header_t *)&v6, 1, 0x40u, 0, 0, 0, 0);
  if ((v4 - 268435459) <= 1)
  {
    if ((v6 & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], name[0]);
    mach_msg_destroy((mach_msg_header_t *)&v6);
  }
  return v4;
}

uint64_t _IOHIDVirtuaServiceClientGetEventSystemClient(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t IOHIDServiceCopyEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return IOHIDServiceCopyEventForClient(a1, a2, a3, a4, 0);
}

uint64_t __IOHIDServiceVirtualCopyEventCallback(uint64_t a1, uint64_t a2, int a3, __CFData *DataInternal, int a5)
{
  uint64_t SenderID;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  const __CFData *v12;
  mach_port_t v13;
  const UInt8 *BytePtr;
  int Length;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  UInt8 *v22;
  mach_vm_size_t v23;
  CFTypeID TypeID;
  const void *v25;
  const void *v26;
  unsigned int v27;
  UInt8 *v28;
  uint8_t buf[4];
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  SenderID = _IOHIDServiceGetSenderID(a1);
  v28 = 0;
  v27 = 0;
  if (DataInternal
    && (v10 = CFGetAllocator((CFTypeRef)a2),
        (DataInternal = IOHIDEventCreateDataInternal(v10, (uint64_t)DataInternal)) != 0))
  {
    v11 = CFGetAllocator((CFTypeRef)a2);
    v12 = (const __CFData *)_IOHIDCreateBinaryData(v11, DataInternal);
  }
  else
  {
    v12 = 0;
  }
  if (*(_DWORD *)(a2 + 448))
    goto LABEL_13;
  v13 = *(_DWORD *)(a2 + 40);
  if (v12)
  {
    BytePtr = CFDataGetBytePtr(v12);
    Length = CFDataGetLength(v12);
  }
  else
  {
    BytePtr = 0;
    Length = 0;
  }
  v16 = iohideventsystem_copy_event_from_virtual_service(v13, SenderID, a3, (uint64_t)BytePtr, Length, a5, &v28, &v27, 0x20u);
  if (v16)
  {
    v17 = v16;
    v18 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      v19 = *(_QWORD *)(a2 + 168);
      *(_DWORD *)buf = 136315650;
      v30 = v19;
      v31 = 2048;
      v32 = SenderID;
      v33 = 1024;
      v34 = v17;
      _os_log_impl(&dword_18AAAF000, v18, OS_LOG_TYPE_INFO, "%s: HIDVS ID:%llx _iohideventsystem_copy_event_from_virtual_service:%x", buf, 0x1Cu);
    }
    __IOHIDEventSystemConnectionCheckServerStatus(v17, a2);
LABEL_13:
    v20 = 0;
    if (!DataInternal)
      goto LABEL_15;
    goto LABEL_14;
  }
  v22 = v28;
  v23 = v27;
  TypeID = CFDataGetTypeID();
  v25 = _IOHIDUnserializeAndVMDeallocWithTypeID(v22, v23, TypeID);
  if (!v25)
    goto LABEL_13;
  v26 = v25;
  v20 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E0C9AE00], v25);
  CFRelease(v26);
  if (DataInternal)
LABEL_14:
    CFRelease(DataInternal);
LABEL_15:
  if (v12)
    CFRelease(v12);
  return v20;
}

uint64_t iohideventsystem_copy_event_from_virtual_service(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, _QWORD *a7, _DWORD *a8, mach_msg_timeout_t a9)
{
  mach_port_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  mach_msg_header_t msg;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;

  v18 = 1;
  v19 = a4;
  v20 = 16777472;
  v21 = a5;
  v22 = *MEMORY[0x1E0C804E8];
  v23 = a2;
  v24 = a3;
  v25 = a5;
  v26 = a6;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1250100000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3162515, 0x48u, 0x40u, special_reply_port, a9, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 75109)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v14 = 4294966996;
            if (HIDWORD(v19))
            {
              if (msg.msgh_remote_port)
                v14 = 4294966996;
              else
                v14 = HIDWORD(v19);
            }
          }
          else
          {
            v14 = 4294966996;
          }
          goto LABEL_27;
        }
        v14 = 4294966996;
        if (v18 == 1 && msg.msgh_size == 56 && !msg.msgh_remote_port && HIBYTE(v20) == 1)
        {
          v15 = v21;
          if (v21 == (_DWORD)v23)
          {
            v14 = 0;
            *a7 = v19;
            *a8 = v15;
            return v14;
          }
        }
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_27:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v14 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_27;
  }
  return v14;
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  const void *Value;
  CFNumberRef v5;
  __CFDictionary *v6;
  CFStringRef v7;
  const void *v8;

  os_unfair_recursive_lock_lock_with_options();
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)service + 12), key);
  os_unfair_recursive_lock_unlock();
  if (!Value)
  {
    v5 = _IOHIDServiceClientCopyUsageProp((uint64_t)service, key);
    if (v5)
    {
      Value = v5;
      os_unfair_recursive_lock_lock_with_options();
      v6 = (__CFDictionary *)*((_QWORD *)service + 12);
      v7 = key;
      v8 = Value;
    }
    else
    {
      Value = _IOHIDEventSystemClientCopyPropertyForService(*((_QWORD *)service + 1), service, key);
      if (!CFSetContainsValue((CFSetRef)__serviceKeysSet, key))
        return Value;
      os_unfair_recursive_lock_lock_with_options();
      v6 = (__CFDictionary *)*((_QWORD *)service + 12);
      if (Value)
        v8 = Value;
      else
        v8 = (const void *)*MEMORY[0x1E0C9B0D0];
      v7 = key;
    }
    CFDictionarySetValue(v6, v7, v8);
    os_unfair_recursive_lock_unlock();
    return Value;
  }
  if (CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
    return 0;
  CFRetain(Value);
  return Value;
}

CFNumberRef _IOHIDServiceClientCopyUsageProp(uint64_t a1, CFTypeRef cf1)
{
  const __CFAllocator *v4;
  const void *v5;
  CFIndex v7;
  const __CFAllocator *v8;
  __CFArray *Mutable;
  uint64_t v10;
  unint64_t v11;
  const CFDictionaryKeyCallBacks *v12;
  const CFDictionaryValueCallBacks *v13;
  CFMutableDictionaryRef v14;
  __CFDictionary *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;

  if (CFEqual(cf1, CFSTR("PrimaryUsagePage")))
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v5 = (const void *)(a1 + 128);
    return CFNumberCreate(v4, kCFNumberSInt32Type, v5);
  }
  if (CFEqual(cf1, CFSTR("PrimaryUsage")))
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v5 = (const void *)(a1 + 132);
    return CFNumberCreate(v4, kCFNumberSInt32Type, v5);
  }
  if (!CFEqual(cf1, CFSTR("DeviceUsagePairs")))
    return 0;
  if (!*(_QWORD *)(a1 + 136))
    return 0;
  v7 = *(unsigned int *)(a1 + 144);
  if (!(_DWORD)v7)
    return 0;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, MEMORY[0x1E0C9B378]);
  if (Mutable && *(_DWORD *)(a1 + 144))
  {
    v10 = 0;
    v11 = 0;
    v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    do
    {
      v14 = CFDictionaryCreateMutable(v8, 2, v12, v13);
      if (!v14)
        break;
      v15 = v14;
      v16 = CFNumberCreate(v8, kCFNumberSInt32Type, (const void *)(*(_QWORD *)(a1 + 136) + v10));
      if (v16)
      {
        v17 = v16;
        CFDictionarySetValue(v15, CFSTR("DeviceUsagePage"), v16);
        CFRelease(v17);
      }
      v18 = CFNumberCreate(v8, kCFNumberSInt32Type, (const void *)(*(_QWORD *)(a1 + 136) + v10 + 4));
      if (v18)
      {
        v19 = v18;
        CFDictionarySetValue(v15, CFSTR("DeviceUsage"), v18);
        CFRelease(v19);
      }
      CFArrayAppendValue(Mutable, v15);
      CFRelease(v15);
      ++v11;
      v10 += 8;
    }
    while (v11 < *(unsigned int *)(a1 + 144));
  }
  return Mutable;
}

const __CFData *_IOHIDEventSystemClientCopyPropertyForService(uint64_t a1, IOHIDServiceClientRef service, const void *a3)
{
  const __CFData *result;
  const __CFAllocator *v6;
  CFTypeRef RegistryID;
  const __CFData *v8;
  const UInt8 *BytePtr;
  int v10;
  const __CFData *v11;
  const __CFData *v12;
  const UInt8 *v13;
  int v14;
  uint64_t v15;
  int v16;
  CFIndex length;
  UInt8 *bytes;

  result = 0;
  length = 0;
  bytes = 0;
  if (a1)
  {
    if (service)
    {
      if (a3)
      {
        v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        RegistryID = IOHIDServiceClientGetRegistryID(service);
        result = (const __CFData *)_IOHIDCreateBinaryData(v6, RegistryID);
        if (result)
        {
          v8 = result;
          BytePtr = CFDataGetBytePtr(result);
          v10 = CFDataGetLength(v8);
          v11 = (const __CFData *)_IOHIDCreateBinaryData(v6, a3);
          if (v11)
          {
            v12 = v11;
            v13 = CFDataGetBytePtr(v11);
            v14 = CFDataGetLength(v12);
            os_unfair_recursive_lock_lock_with_options();
            v15 = io_hideventsystem_copy_property_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v10, (uint64_t)v13, v14, &bytes, (_DWORD *)&length + 1, &length);
            v16 = v15;
            if ((_DWORD)v15 == 268435459)
            {
              if (*(_QWORD *)(a1 + 384))
              {
                v16 = 268435459;
              }
              else
              {
                v16 = 268435459;
                if (!*(_QWORD *)(a1 + 400))
                {
                  __IOHIDEventSystemClientTerminationCallback(v15, a1, 0);
                  v16 = io_hideventsystem_copy_property_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v10, (uint64_t)v13, v14, &bytes, (_DWORD *)&length + 1, &length);
                }
              }
            }
            os_unfair_recursive_lock_unlock();
            CFRelease(v12);
          }
          else
          {
            v16 = 0;
          }
          CFRelease(v8);
          if (v16 | length)
            return 0;
          else
            return (const __CFData *)_IOHIDUnserializeAndVMDealloc(bytes, HIDWORD(length));
        }
      }
    }
  }
  return result;
}

uint64_t _IOHIDEventSystemClientSetPropertyForService(uint64_t a1, IOHIDServiceClientRef service, void *a3, void *a4)
{
  uint64_t v4;
  const __CFAllocator *v6;
  CFTypeRef RegistryID;
  CFTypeRef v8;
  const void *v9;
  CFDictionaryRef v10;
  CFDictionaryRef v11;
  const __CFData *v12;
  const __CFData *v13;
  mach_port_t v14;
  const UInt8 *BytePtr;
  int Length;
  const UInt8 *v17;
  int v18;
  int v19;
  _BOOL4 v20;
  mach_port_t v21;
  const UInt8 *v22;
  int v23;
  const UInt8 *v24;
  int v25;
  int v27;
  void *values;
  void *keys;

  v4 = 0;
  values = a4;
  keys = a3;
  if (a1 && service && a3 && a4)
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    RegistryID = IOHIDServiceClientGetRegistryID(service);
    v8 = _IOHIDCreateBinaryData(v6, RegistryID);
    if (v8)
    {
      v9 = v8;
      v4 = 1;
      v10 = CFDictionaryCreate(v6, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (!v10)
      {
LABEL_25:
        CFRelease(v9);
        return v4;
      }
      v11 = v10;
      v12 = (const __CFData *)_IOHIDCreateBinaryData(v6, v10);
      if (!v12)
      {
        v4 = 1;
LABEL_24:
        CFRelease(v11);
        goto LABEL_25;
      }
      v13 = v12;
      v27 = 0;
      if (CFSetContainsValue((CFSetRef)__restrictedRemapKeys, keys)
        && _IOHIDIsRestrictedRemappingProperty((const __CFString *)values)
        && IOHIDCheckAccess(kIOHIDRequestTypeListenEvent))
      {
        IOHIDRequestAccess(kIOHIDRequestTypeListenEvent);
      }
      os_unfair_recursive_lock_lock_with_options();
      v14 = *(_DWORD *)(a1 + 32);
      BytePtr = CFDataGetBytePtr((CFDataRef)v9);
      Length = CFDataGetLength((CFDataRef)v9);
      v17 = CFDataGetBytePtr(v13);
      v18 = CFDataGetLength(v13);
      v19 = io_hideventsystem_set_properties_for_service(v14, (uint64_t)BytePtr, Length, (uint64_t)v17, v18, &v27);
      if (v19 == 268435459)
      {
        if (*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400))
        {
          os_unfair_recursive_lock_unlock();
          v20 = 0;
LABEL_20:
          if (v27)
            v4 = 0;
          else
            v4 = v20;
          CFRelease(v13);
          goto LABEL_24;
        }
        __IOHIDEventSystemClientTerminationCallback();
        v21 = *(_DWORD *)(a1 + 32);
        v22 = CFDataGetBytePtr((CFDataRef)v9);
        v23 = CFDataGetLength((CFDataRef)v9);
        v24 = CFDataGetBytePtr(v13);
        v25 = CFDataGetLength(v13);
        v19 = io_hideventsystem_set_properties_for_service(v21, (uint64_t)v22, v23, (uint64_t)v24, v25, &v27);
      }
      os_unfair_recursive_lock_unlock();
      v20 = v19 == 0;
      goto LABEL_20;
    }
    return 1;
  }
  return v4;
}

CFTypeRef IOHIDServiceClientGetRegistryID(IOHIDServiceClientRef service)
{
  return (CFTypeRef)*((_QWORD *)service + 2);
}

uint64_t io_hideventsystem_set_properties_for_service(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int *a6)
{
  mach_port_t special_reply_port;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  mach_msg_header_t msg;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v14 = 2;
  v15 = a2;
  v16 = 16777472;
  v17 = a3;
  v18 = a4;
  v19 = 16777472;
  v20 = a5;
  v21 = *MEMORY[0x1E0C804E8];
  v22 = a3;
  v23 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1117A00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v9 = mach_msg(&msg, 3162115, 0x4Cu, 0x30u, special_reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v9)
    {
      if (msg.msgh_id == 71)
      {
        v10 = 4294966988;
      }
      else if (msg.msgh_id == 70110)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v10 = HIDWORD(v15);
              if (!HIDWORD(v15))
              {
                *a6 = v16;
                return v10;
              }
              goto LABEL_25;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v11 = 1;
            else
              v11 = HIDWORD(v15) == 0;
            if (v11)
              v10 = 4294966996;
            else
              v10 = HIDWORD(v15);
            goto LABEL_25;
          }
        }
        v10 = 4294966996;
      }
      else
      {
        v10 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&msg);
      return v10;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v10 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_25;
  }
  return v10;
}

uint64_t io_hideventsystem_copy_property_for_service(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, _QWORD *a6, _DWORD *a7, _DWORD *a8)
{
  mach_port_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  mach_msg_header_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;

  v18 = 2;
  v19 = a2;
  v20 = 16777472;
  v21 = a3;
  v22 = a4;
  v23 = 16777472;
  v24 = a5;
  v25 = *MEMORY[0x1E0C804E8];
  v26 = a3;
  v27 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v17.msgh_bits = 2147489043;
  v17.msgh_remote_port = a1;
  v17.msgh_local_port = special_reply_port;
  *(_QWORD *)&v17.msgh_voucher_port = 0x1117B00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v17);
    special_reply_port = v17.msgh_local_port;
  }
  v13 = mach_msg(&v17, 3162115, 0x4Cu, 0x44u, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (v17.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (v17.msgh_id == 70111)
      {
        if ((v17.msgh_bits & 0x80000000) == 0)
        {
          if (v17.msgh_size == 36)
          {
            v14 = 4294966996;
            if (HIDWORD(v19))
            {
              if (v17.msgh_remote_port)
                v14 = 4294966996;
              else
                v14 = HIDWORD(v19);
            }
          }
          else
          {
            v14 = 4294966996;
          }
          goto LABEL_26;
        }
        v14 = 4294966996;
        if (v18 == 1 && *(_QWORD *)&v17.msgh_size == 60 && HIBYTE(v20) == 1)
        {
          v15 = v21;
          if (v21 == v23)
          {
            v14 = 0;
            *a6 = v19;
            *a7 = v15;
            *a8 = v24;
            return v14;
          }
        }
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_26:
      mach_msg_destroy(&v17);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v14 - 268435459) <= 1)
  {
    if ((v17.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v17.msgh_local_port);
    goto LABEL_26;
  }
  return v14;
}

uint64_t __IOHIDNotificationRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDNotificationTypeID = result;
  return result;
}

CFComparisonResult compare_assertion(const __CFDictionary *a1, const __CFDictionary *a2)
{
  const __CFNumber *Value;
  const __CFNumber *v4;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("TimeoutTimeStamp"));
  v4 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("TimeoutTimeStamp"));
  return CFNumberCompare(Value, v4, 0);
}

uint64_t _IOHIDServiceSetBatchIntervalForClient(uint64_t a1, const void *a2, const void *a3)
{
  _QWORD *v6;
  const void *v7;
  uint64_t result;
  uint64_t v9;
  _OWORD v10[5];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v9, v10);
  ++**(_DWORD **)(a1 + 72);
  v6 = __IOHIDServiceCreateAndCopyConnectionCache(a1, a2);
  if (v6)
  {
    v7 = v6;
    IOHIDServiceConnectionCacheSetValueForKey(v6, CFSTR("BatchInterval"), a3);
    CFRelease(v7);
  }
  result = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v9, v10);
  }
  return result;
}

uint64_t _IOHIDServiceSetReportIntervalForClient(uint64_t a1, const void *a2, const void *a3)
{
  _QWORD *v6;
  const void *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  int context;
  _OWORD v12[5];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v10, v12);
  ++**(_DWORD **)(a1 + 72);
  v6 = __IOHIDServiceCreateAndCopyConnectionCache(a1, a2);
  if (v6)
  {
    v7 = v6;
    IOHIDServiceConnectionCacheSetValueForKey(v6, CFSTR("ReportInterval"), a3);
    context = 0;
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v10, v12);
    ++**(_DWORD **)(a1 + 72);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__ConnectionFunctionContainsReportInterval, &context);
    *(_DWORD *)(a1 + 220) = context;
    v8 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)v8)
    {
      --*(_DWORD *)v8;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v10, v12);
    }
    CFRelease(v7);
  }
  result = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v10, v12);
  }
  return result;
}

const void *__IOHIDServiceCreateAndCopyConnectionCache(uint64_t a1, const void *a2)
{
  const void *Value;
  const void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v9;
  _OWORD v10[5];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v9, v10);
  ++**(_DWORD **)(a1 + 72);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 240), a2);
  if (Value)
  {
    v5 = Value;
    CFRetain(Value);
  }
  else if (_IOHIDEventSystemConnectionIsValid((uint64_t)a2))
  {
    CFGetAllocator((CFTypeRef)a1);
    IOHIDServiceConnectionCacheCreate();
    v5 = v6;
    if (v6)
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 240), a2, v6);
  }
  else
  {
    v5 = 0;
  }
  v7 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v7)
  {
    --*(_DWORD *)v7;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v9, v10);
  }
  return v5;
}

void IOHIDServiceConnectionCacheSetValueForKey(_QWORD *a1, const void *a2, const void *a3)
{
  const void *v6;
  CFTypeRef v7;
  const void *v8;
  CFTypeRef v9;
  __CFDictionary *Mutable;

  if (CFEqual(CFSTR("ReportInterval"), a2))
  {
    v6 = (const void *)a1[3];
    if (v6)
      CFRelease(v6);
    if (a3)
      v7 = CFRetain(a3);
    else
      v7 = 0;
    a1[3] = v7;
  }
  else if (CFEqual(CFSTR("BatchInterval"), a2))
  {
    v8 = (const void *)a1[4];
    if (v8)
      CFRelease(v8);
    if (a3)
      v9 = CFRetain(a3);
    else
      v9 = 0;
    a1[4] = v9;
  }
  else
  {
    Mutable = (__CFDictionary *)a1[5];
    if (Mutable
      || (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]), (a1[5] = Mutable) != 0))
    {
      CFDictionarySetValue(Mutable, a2, a3);
    }
  }
}

BOOL _IOHIDEventSystemConnectionIsValid(uint64_t a1)
{
  return *MEMORY[0x1E0C9B0D0] == a1 || (*(_BYTE *)(a1 + 264) & 1) == 0;
}

double IOHIDServiceConnectionCacheCreate()
{
  uint64_t Instance;
  double result;

  IOHIDServiceConnectionCacheGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    result = 0.0;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  return result;
}

uint64_t IOHIDServiceConnectionCacheGetTypeID()
{
  uint64_t result;

  result = __serviceConnectionCacheTypeID;
  if (!__serviceConnectionCacheTypeID)
  {
    if (__serviceConnectionCacheTypeInit != -1)
      dispatch_once(&__serviceConnectionCacheTypeInit, &__block_literal_global_1);
    return __serviceConnectionCacheTypeID;
  }
  return result;
}

const void *___iohideventsystem_client_dispatch_notification_results_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  const void *result;
  const void *v4;
  const void *Value;
  uint64_t v6;
  uint64_t v7;

  result = CFDictionaryGetValue(theDict, CFSTR("ServiceID"));
  if (result)
  {
    v4 = result;
    os_unfair_recursive_lock_lock_with_options();
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 96), v4);
    os_unfair_recursive_lock_unlock();
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(v6 + 176);
    if (v7)
      return (const void *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, const void *))(v7 + 16))(v7, *(_QWORD *)(v6 + 184), *(_QWORD *)(v6 + 192), Value);
    else
      return (const void *)(*(uint64_t (**)(_QWORD, _QWORD, const void *))(v6 + 168))(*(_QWORD *)(v6 + 184), *(_QWORD *)(v6 + 192), Value);
  }
  return result;
}

void __IOMIGMachPortRelease(uint64_t a1)
{
  __CFMachPort *v2;
  ipc_space_t v3;
  mach_port_name_t Port;
  kern_return_t v5;
  mach_error_t v6;
  NSObject *v7;
  const void *v8;

  v2 = *(__CFMachPort **)(a1 + 48);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    v3 = *MEMORY[0x1E0C83DA0];
    Port = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 48));
    v5 = mach_port_mod_refs(v3, Port, 1u, -1);
    if (v5)
    {
      v6 = v5;
      if (__IOMIGMachPortLog_onceToken != -1)
        dispatch_once(&__IOMIGMachPortLog_onceToken, &__block_literal_global_11);
      v7 = __IOMIGMachPortLog_log;
      if (os_log_type_enabled((os_log_t)__IOMIGMachPortLog_log, OS_LOG_TYPE_ERROR))
        __IOMIGMachPortRelease_cold_1(v6, v7);
    }
    CFRelease(*(CFTypeRef *)(a1 + 48));
  }
  v8 = *(const void **)(a1 + 56);
  if (v8)
    CFRelease(v8);
  if (*(_QWORD *)(a1 + 40))
  {
    dispatch_mach_cancel();
    dispatch_release(*(dispatch_object_t *)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0;
  }
}

void __IOHIDEventQueueRelease(uint64_t a1)
{
  mach_vm_address_t v2;
  ipc_space_t *v3;
  mach_port_name_t v4;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if (*(_DWORD *)(a1 + 144) == 1)
    {
      v3 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
      mach_vm_deallocate(*MEMORY[0x1E0C83DA0], v2, *(_QWORD *)(a1 + 24));
      v4 = *(_DWORD *)(a1 + 84);
      if (v4)
        mach_port_deallocate(*v3, v4);
    }
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
  os_unfair_recursive_lock_unlock();
  if (*(_QWORD *)(a1 + 160))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 160));
    *(_QWORD *)(a1 + 160) = 0;
  }
}

uint64_t _IOHIDServiceReleasePrivate(uint64_t a1)
{
  const void *v2;
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  IOCFPlugInInterface **v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  io_object_t v12;
  IONotificationPort *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  uint64_t i;
  uint64_t v21;
  const void *v22;
  void *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  const void *v27;
  const void *v28;
  NSObject *v29;
  const void *v30;
  const void *v31;
  uint64_t result;

  v2 = *(const void **)(a1 + 336);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 336) = 0;
  }
  v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v6 = *(IOCFPlugInInterface ***)(a1 + 40);
  if (v6)
  {
    IODestroyPlugInInterface(v6);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v7 = *(const void **)(a1 + 480);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 8);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v9 = *(const void **)(a1 + 104);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v10 = *(const void **)(a1 + 112);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v11 = *(const void **)(a1 + 120);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v12 = *(_DWORD *)(a1 + 96);
  if (v12)
  {
    IOObjectRelease(v12);
    *(_DWORD *)(a1 + 96) = 0;
  }
  v13 = *(IONotificationPort **)(a1 + 88);
  if (v13)
  {
    IONotificationPortDestroy(v13);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v14 = *(const void **)(a1 + 240);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 240) = 0;
  }
  v15 = *(const void **)(a1 + 248);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 248) = 0;
  }
  v16 = *(const void **)(a1 + 256);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(a1 + 256) = 0;
  }
  v17 = *(const void **)(a1 + 312);
  if (v17)
  {
    CFRelease(v17);
    *(_QWORD *)(a1 + 312) = 0;
  }
  v18 = *(const void **)(a1 + 264);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 264) = 0;
  }
  v19 = *(const void **)(a1 + 408);
  if (v19)
    CFRelease(v19);
  for (i = 0; i != 24; i += 8)
  {
    v21 = *(_QWORD *)(a1 + 368);
    if (v21)
    {
      v22 = *(const void **)(v21 + i);
      if (v22)
      {
        CFRelease(v22);
        *(_QWORD *)(*(_QWORD *)(a1 + 368) + i) = 0;
      }
    }
  }
  v23 = *(void **)(a1 + 368);
  if (v23)
    free(v23);
  v24 = *(void **)(a1 + 416);
  if (v24)
    free(v24);
  v25 = *(NSObject **)(a1 + 80);
  if (v25)
  {
    hid_dispatch_queue_release(v25);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v26 = *(void **)(a1 + 360);
  if (v26)
    free(v26);
  v27 = *(const void **)(a1 + 424);
  if (v27)
    _Block_release(v27);
  v28 = *(const void **)(a1 + 432);
  if (v28)
    _Block_release(v28);
  v29 = *(NSObject **)(a1 + 448);
  if (v29)
    dispatch_release(v29);
  if (*(_QWORD *)(a1 + 464))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 464));
  }
  if (*(_QWORD *)(a1 + 472))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 472));
  }
  v30 = *(const void **)(a1 + 56);
  if (v30)
    CFRelease(v30);
  v31 = *(const void **)(a1 + 64);
  if (v31)
    CFRelease(v31);
  result = *(unsigned int *)(a1 + 16);
  if ((_DWORD)result)
    return IOObjectRelease(result);
  return result;
}

void IONotificationPortRelease(mach_port_name_t *a1)
{
  unsigned int *v2;
  int v3;
  ipc_space_t *v4;

  v2 = a1 + 8;
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 - 1, v2));
  if (v3 <= 0)
  {
    v4 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    mach_port_mod_refs(*MEMORY[0x1E0C83DA0], a1[1], 1u, -1);
    mach_port_deallocate(*v4, *a1);
    free(a1);
  }
}

uint64_t IOHIDAnalyticsEventCancel()
{
  uint64_t result;

  if (cancelEventFuncPtr)
    return cancelEventFuncPtr();
  return result;
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  __CFMachPort *v2;
  const void *v3;
  NSObject *v4;

  v2 = (__CFMachPort *)*((_QWORD *)notify + 1);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    CFRelease(*((CFTypeRef *)notify + 1));
  }
  v3 = (const void *)*((_QWORD *)notify + 2);
  if (v3)
    CFRelease(v3);
  v4 = *((_QWORD *)notify + 3);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)notify + 3));
  }
  IONotificationPortRelease((mach_port_name_t *)notify);
}

uint64_t ___io_hideventsystem_set_properties_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  int v6;
  uint64_t result;

  v6 = -536870212;
  if (IOHIDEventSystemConnectionGetType(*(_QWORD *)(a1 + 40)) == 4
    && (result = CFSetContainsValue((CFSetRef)__whiteListSet, a2), !(_DWORD)result))
  {
    v6 = -536870206;
  }
  else
  {
    result = _IOHIDEventSystemSetPropertyForConnection(*(_QWORD *)(a1 + 48), a2, a3, *(const void **)(a1 + 40));
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v6;
  return result;
}

uint64_t _IOHIDEventSystemConnectionQueueStop(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  ipc_space_t *v4;
  ipc_space_t v5;
  mach_port_name_t NotificationPort;
  kern_return_t v7;
  mach_error_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  kern_return_t v18;
  mach_error_t v19;
  NSObject *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  mach_port_t previous;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  mach_port_t v31;
  uint64_t v32;

  v1 = result;
  v32 = *MEMORY[0x1E0C80C00];
  if (*MEMORY[0x1E0C9B0D0] == result || (*(_BYTE *)(result + 264) & 1) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    v2 = *(_QWORD *)(v1 + 8);
    v3 = *(_QWORD *)(v1 + 24);
    if (v3 && *(_DWORD *)(v1 + 128))
    {
      if (*(_DWORD *)(v1 + 104))
      {
        previous = 0;
        v4 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
        v5 = *MEMORY[0x1E0C83DA0];
        NotificationPort = IOHIDEventQueueGetNotificationPort(v3);
        v7 = mach_port_request_notification(v5, NotificationPort, 66, 1u, *(_DWORD *)(v1 + 104), 0x15u, &previous);
        if (v7)
        {
          v8 = v7;
          v9 = _IOHIDLogCategory(9u);
          v10 = (int)v9;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            _IOHIDEventSystemConnectionQueueStop_cold_2(v1, v8, v10, v11, v12, v13, v14, v15);
          __IOHIDEventSystemConnectionCheckServerStatus(v8, v1);
        }
        else if (previous)
        {
          v16 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            v17 = *(_QWORD *)(v1 + 168);
            *(_DWORD *)buf = 136315394;
            v29 = v17;
            v30 = 1024;
            v31 = previous;
            _os_log_impl(&dword_18AAAF000, v16, OS_LOG_TYPE_DEFAULT, "%s: mach_port_request_notification(notify) unexpected old notify port %#x", buf, 0x12u);
          }
          v18 = mach_port_deallocate(*v4, previous);
          if (v18)
          {
            v19 = v18;
            v20 = _IOHIDLogCategory(9u);
            v21 = (int)v20;
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              _IOHIDEventSystemConnectionQueueStop_cold_1(v1, v19, v21, v22, v23, v24, v25, v26);
          }
        }
      }
      *(_DWORD *)(v1 + 128) = 0;
    }
    *(_DWORD *)(v1 + 264) |= 2u;
    os_unfair_recursive_lock_unlock();
    return _IOHIDEventSystemSetPropertyForConnection(v2, CFSTR("IOHIDEventSystemClientIsUnresponsive"), (const void *)*MEMORY[0x1E0C9AE50], (const void *)v1);
  }
  return result;
}

_DWORD *_Xio_hideventsystem_queue_start(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  }
  else
  {
    result = (_DWORD *)_io_hideventsystem_queue_start(result[3]);
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t _io_hideventsystem_queue_start(unsigned int a1)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;
  const void *v4;
  const void *v5;

  v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    if (v3 == IOHIDEventSystemConnectionGetTypeID())
    {
      v4 = _IOHIDEventSystemConnectionCopyQueue((uint64_t)v2);
      if (v4)
      {
        v5 = v4;
        _IOHIDEventSystemConnectionQueueStart((uint64_t)v2);
        IOHIDEventQueueStart((uint64_t)v5);
        CFRelease(v5);
      }
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t _IOHIDEventSystemSetPropertyForConnection(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t v7;

  v7 = *(_QWORD *)(a1 + 128);
  if (_IOHIDEventSystemConnectionSetProperty((uint64_t)a4, a2, (const __CFArray *)a3))
    return 1;
  else
    return _IOHIDSessionSetPropertyForClient(v7, a2, a3, a4);
}

uint64_t ___io_hideventsystem_set_properties_for_service_block_invoke(_QWORD *a1, const void *a2, const __CFArray *a3)
{
  uint64_t result;
  int v7;

  if (IOHIDEventSystemConnectionGetType(a1[5]) == 4)
  {
    result = CFSetContainsValue((CFSetRef)__whiteListSet, a2);
    if (!(_DWORD)result)
    {
      v7 = -536870206;
      goto LABEL_7;
    }
  }
  result = _IOHIDEventSystemConnectionSetProperty(a1[5], a2, a3);
  if (!(_DWORD)result)
  {
    result = _IOHIDServiceSetPropertyForClient(a1[6], a2, a3, (CFTypeRef)a1[5]);
    if (!(_DWORD)result)
    {
      v7 = -536870212;
LABEL_7:
      *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v7;
    }
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionSetProperty(uint64_t a1, CFTypeRef cf1, const __CFArray *a3)
{
  uint64_t v6;
  CFTypeID TypeID;
  CFIndex v8;
  uint64_t v9;
  const __CFNumber *ValueAtIndex;
  CFTypeID v11;
  uint64_t result;
  CFTypeID v13;
  const __CFArray *v14;
  uint64_t v15;
  CFTypeID v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t Session;
  _QWORD *ActivityNotification;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  OSQueueHead *v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  _QWORD v30[5];
  uint64_t v31;
  int valuePtr;
  uint64_t v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*MEMORY[0x1E0C9B0D0] == a1)
    return 0;
  v6 = *(_QWORD *)(a1 + 440);
  if (v6 && (IOHIDConnectionFilterSetProperty(v6, (uint64_t)cf1, (uint64_t)a3) & 1) != 0)
    return 1;
  if (CFEqual(cf1, CFSTR("ClientEventFilter")))
  {
    TypeID = CFArrayGetTypeID();
    if (a3 && CFGetTypeID(a3) == TypeID && CFArrayGetCount(a3) >= 1)
    {
      v8 = 0;
      v9 = 0;
      do
      {
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a3, v8);
        v11 = CFNumberGetTypeID();
        if (ValueAtIndex)
        {
          if (CFGetTypeID(ValueAtIndex) == v11)
          {
            valuePtr = 0;
            CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
            v9 |= 1 << valuePtr;
          }
        }
        ++v8;
      }
      while (v8 < CFArrayGetCount(a3));
    }
    else
    {
      v9 = 0;
    }
    *(_QWORD *)(a1 + 280) = v9;
    return 1;
  }
  if (CFEqual(cf1, CFSTR("ClientSuspend")))
  {
    v13 = CFGetTypeID(a3);
    if (v13 == CFBooleanGetTypeID())
    {
      v14 = (const __CFArray *)*MEMORY[0x1E0C9AE50];
      os_unfair_recursive_lock_lock_with_options();
      v15 = *(_QWORD *)(a1 + 24);
      if (v14 == a3)
      {
        if (v15)
          IOHIDEventQueueSuspend(v15);
      }
      else if (v15)
      {
        IOHIDEventQueueResume(v15);
      }
      os_unfair_recursive_lock_unlock();
      return 1;
    }
  }
  result = CFEqual(cf1, CFSTR("IdleNotificationTime"));
  if ((_DWORD)result)
  {
    v16 = CFGetTypeID(a3);
    if (v16 == CFNumberGetTypeID())
    {
      v31 = 0;
      CFNumberGetValue(a3, kCFNumberSInt64Type, &v31);
      v17 = v31;
      if (*(_QWORD *)(a1 + 408) != v31)
      {
        *(_QWORD *)(a1 + 408) = v31;
        if (!*(_QWORD *)(a1 + 416))
        {
          v18 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(a1 + 96));
          *(_QWORD *)(a1 + 416) = v18;
          if (!v18)
          {
            v28 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              _IOHIDEventSystemConnectionSetProperty_cold_1();
            return 1;
          }
          v30[0] = MEMORY[0x1E0C809B0];
          v30[1] = 0x40000000;
          v30[2] = ___IOHIDEventSystemConnectionSetProperty_block_invoke;
          v30[3] = &__block_descriptor_tmp_107;
          v30[4] = a1;
          dispatch_source_set_event_handler(v18, v30);
          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 416), 0xFFFFFFFFFFFFFFFFLL, 0, 0);
          dispatch_activate(*(dispatch_object_t *)(a1 + 416));
          v17 = *(_QWORD *)(a1 + 408);
        }
        if (v17)
        {
          Session = _IOHIDEventSystemGetSession(*(_QWORD *)(a1 + 8));
          if (*(_QWORD *)(a1 + 424)
            || (ActivityNotification = _IOHIDSessionCreateActivityNotification(Session, (uint64_t)__IOHIDEventSystemConnectionActivityNotification, a1, 0), (*(_QWORD *)(a1 + 424) = ActivityNotification) != 0))
          {
            v21 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              v23 = *(_QWORD *)(a1 + 168);
              v24 = *(_QWORD *)(a1 + 408);
              valuePtr = 136315394;
              v33 = v23;
              v34 = 1024;
              v35 = v24;
              _os_log_impl(&dword_18AAAF000, v21, OS_LOG_TYPE_DEFAULT, "%s: HID activity: start reporting with interval: %ds", (uint8_t *)&valuePtr, 0x12u);
            }
            __IOHIDEventSystemConnectionActivityNotification(a1, v22, 0);
          }
          else
          {
            v29 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
              _IOHIDEventSystemConnectionSetProperty_cold_2();
          }
        }
        else
        {
          v25 = *(OSQueueHead **)(a1 + 424);
          if (v25)
          {
            IOHIDNotificationInvalidate(v25, 0);
            CFRelease(*(CFTypeRef *)(a1 + 424));
            *(_QWORD *)(a1 + 424) = 0;
          }
          *(_DWORD *)(a1 + 400) = 2;
          v26 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = *(_QWORD *)(a1 + 168);
            valuePtr = 136315138;
            v33 = v27;
            _os_log_impl(&dword_18AAAF000, v26, OS_LOG_TYPE_DEFAULT, "%s: HID activity: stop reporting", (uint8_t *)&valuePtr, 0xCu);
          }
          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 416), 0xFFFFFFFFFFFFFFFFLL, 0, 0);
        }
      }
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t _IOHIDSessionSetPropertyForClient(uint64_t a1, CFTypeRef cf1, const void *a3, const void *a4)
{
  CFTypeID v8;
  uint64_t v9;
  CFTypeID v10;
  CFTypeID v11;
  int v12;
  const void *v13;
  const __CFArray *v14;
  const __CFSet *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int *v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  NSObject *v27;
  uint64_t UUID;
  _QWORD v29[4];
  uint64_t v30;
  _BYTE context[24];
  const void *v32;
  uint64_t v33;
  CFRange v34;

  v33 = *MEMORY[0x1E0C80C00];
  if (!cf1)
    return 1;
  if (CFEqual(cf1, CFSTR("HIDParameters")))
  {
    v8 = CFGetTypeID(a3);
    if (v8 == CFDictionaryGetTypeID())
    {
      *(_QWORD *)context = a1;
      *(_QWORD *)&context[8] = a4;
      CFDictionaryApplyFunction((CFDictionaryRef)a3, (CFDictionaryApplierFunction)__FunctionApplierForParameters, context);
    }
    return 1;
  }
  if (CFEqual(cf1, CFSTR("LogLevel")))
  {
    v10 = CFGetTypeID(a3);
    if (v10 == CFNumberGetTypeID())
    {
      *(_DWORD *)context = *(_DWORD *)(a1 + 128);
      CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, context);
      if (*(_DWORD *)(a1 + 128) != *(_DWORD *)context)
        *(_DWORD *)(a1 + 128) = *(_DWORD *)context;
    }
  }
  if (CFEqual(cf1, CFSTR("HIDDebug")))
  {
    v11 = CFGetTypeID(a3);
    if (v11 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &gIOHIDDebugConfig);
  }
  v12 = CFEqual(cf1, CFSTR("CASecureLayerOnScreen"));
  if (!v12
    || (*(_BYTE *)IOHIDEventSystemConnectionGetEntitlements((uint64_t)a4) & 2) != 0
    || (*(_BYTE *)IOHIDEventSystemConnectionGetEntitlements((uint64_t)a4) & 1) != 0)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(&v30, context);
    ++**(_DWORD **)(a1 + 32);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), cf1, a3);
    v29[0] = a1;
    v29[1] = cf1;
    v29[2] = a3;
    if (a4 && CFEqual(a4, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
      v13 = 0;
    else
      v13 = a4;
    v29[3] = v13;
    v14 = *(const __CFArray **)(a1 + 152);
    v34.length = CFArrayGetCount(v14);
    v34.location = 0;
    CFArrayApplyFunction(v14, v34, (CFArrayApplierFunction)__FilterFunctionSetPropertyForClient_0, v29);
    v15 = 0;
    if (!v12)
      v15 = (const __CFSet *)CFRetain(*(CFTypeRef *)(a1 + 136));
    v16 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)v16)
    {
      --*(_DWORD *)v16;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v30, context);
    }
    if (v12)
    {
      v9 = 1;
    }
    else
    {
      *(_QWORD *)context = cf1;
      *(_QWORD *)&context[8] = a3;
      *(_QWORD *)&context[16] = 0;
      v32 = a4;
      CFSetApplyFunction(v15, (CFSetApplierFunction)__SetPropertyForObjectFunction, context);
      v9 = context[16];
      CFRelease(v15);
    }
    v17 = *(_QWORD *)(a1 + 8);
    v18 = _IOHIDLogCategory(2u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)context = 138412802;
      *(_QWORD *)&context[4] = cf1;
      *(_WORD *)&context[12] = 2112;
      *(_QWORD *)&context[14] = a3;
      *(_WORD *)&context[22] = 2112;
      v32 = a4;
      _os_log_debug_impl(&dword_18AAAF000, v18, OS_LOG_TYPE_DEBUG, "SetProperty called %@=%@ caller=%@", context, 0x20u);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(&v30, context);
    v19 = *(int **)(a1 + 32);
    v20 = *v19;
    v21 = *v19 + 1;
    *v19 = v21;
    if (v20 == -1)
    {
      _IOHIDEventSystemPropertyChanged(v17, (uint64_t)a4, cf1, (uint64_t)a3);
      v22 = *(_QWORD *)(a1 + 32);
      goto LABEL_42;
    }
    v23 = v20 + 1;
    do
    {
      v24 = *(_QWORD *)(a1 + 32);
      if (*(_DWORD *)v24)
      {
        --*(_DWORD *)v24;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v24 + 8)))
          __IOHIDSessionCreate_block_invoke_cold_1(&v30, context);
      }
      --v23;
    }
    while (v23);
    _IOHIDEventSystemPropertyChanged(v17, (uint64_t)a4, cf1, (uint64_t)a3);
    v22 = *(_QWORD *)(a1 + 32);
    if (!v21)
    {
LABEL_42:
      v25 = *(_DWORD *)v22;
      if (!*(_DWORD *)v22)
        return v9;
      goto LABEL_43;
    }
    do
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v22 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_4(&v30, context);
      v22 = *(_QWORD *)(a1 + 32);
      v25 = *(_DWORD *)v22 + 1;
      *(_DWORD *)v22 = v25;
      --v21;
    }
    while (v21);
    if (v25)
    {
LABEL_43:
      *(_DWORD *)v22 = v25 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v22 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v30, context);
    }
  }
  else
  {
    v27 = _IOHIDLogCategory(2u);
    v9 = 0;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      UUID = IOHIDEventSystemConnectionGetUUID((uint64_t)a4);
      *(_DWORD *)context = 138412290;
      *(_QWORD *)&context[4] = UUID;
      _os_log_impl(&dword_18AAAF000, v27, OS_LOG_TYPE_DEFAULT, "Insufficient permissions to set kIOHIDSessionCASecureLayerOnScreenKey for UUID: %@", context, 0xCu);
      return 0;
    }
  }
  return v9;
}

void _IOHIDEventSystemPropertyChanged(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  const __CFSet *Copy;
  const __CFSet *v10;
  _QWORD context[3];

  os_unfair_recursive_lock_lock_with_options();
  v8 = CFGetAllocator((CFTypeRef)a1);
  Copy = CFSetCreateCopy(v8, *(CFSetRef *)(a1 + 48));
  os_unfair_recursive_lock_unlock();
  if (*(_QWORD *)(a1 + 88))
  {
    v10 = *(const __CFSet **)(a1 + 32);
    if (v10)
    {
      if (CFSetContainsValue(v10, a3))
        (*(void (**)(void))(*(_QWORD *)(a1 + 88) + 16))();
    }
  }
  if (Copy)
  {
    context[0] = a3;
    context[1] = a4;
    context[2] = a2;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__PropertyChangedFunction, context);
    CFRelease(Copy);
  }
}

uint64_t _IOHIDEventSystemConnectionQueueStart(uint64_t a1)
{
  uint64_t v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(a1 + 24))
    *(_DWORD *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 264) &= ~2u;
  os_unfair_recursive_lock_unlock();
  return _IOHIDEventSystemSetPropertyForConnection(v2, CFSTR("IOHIDEventSystemClientIsUnresponsive"), (const void *)*MEMORY[0x1E0C9AE40], (const void *)a1);
}

uint64_t IOHIDEventQueueStart(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 148) = 1;
  return os_unfair_recursive_lock_unlock();
}

void _IOHIDEventSystemConnectionReleasePrivate(uint64_t a1)
{
  const void *v2;
  const void *v3;
  NSObject *v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  ipc_space_t *v9;
  mach_port_name_t NotificationPort;
  kern_return_t v11;
  mach_error_t v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  kern_return_t v20;
  mach_error_t v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  mach_port_name_t v29;
  kern_return_t v30;
  mach_error_t v31;
  NSObject *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  kern_return_t v39;
  mach_error_t v40;
  NSObject *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  mach_port_name_t v48;
  kern_return_t v49;
  mach_error_t v50;
  NSObject *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  mach_port_name_t v63;
  const void *v64;
  const void *v65;
  const void *v66;
  const void *v67;
  void *v68;
  void *v69;
  void *v70;
  const void *v71;
  mach_port_t previous;

  previous = 0;
  v2 = *(const void **)(a1 + 272);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 16);
  if (v3)
    CFRelease(v3);
  v4 = *(NSObject **)(a1 + 96);
  if (v4)
  {
    dispatch_release(v4);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v5 = *(const void **)(a1 + 80);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 32);
  if (v6)
    CFRelease(v6);
  v7 = *(NSObject **)(a1 + 416);
  if (v7)
    dispatch_release(v7);
  v8 = *(_QWORD *)(a1 + 24);
  v9 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (v8)
  {
    NotificationPort = IOHIDEventQueueGetNotificationPort(v8);
    v11 = mach_port_request_notification(*v9, NotificationPort, 66, 1u, 0, 0x15u, &previous);
    if (v11
      && (v12 = v11, v13 = _IOHIDLogCategory(9u),
                     v14 = (int)v13,
                     os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)))
    {
      _IOHIDEventSystemConnectionReleasePrivate_cold_5(a1, v12, v14, v15, v16, v17, v18, v19);
      if (NotificationPort)
        goto LABEL_17;
    }
    else if (NotificationPort)
    {
LABEL_17:
      v20 = mach_port_deallocate(*v9, NotificationPort);
      if (v20)
      {
        v21 = v20;
        v22 = _IOHIDLogCategory(9u);
        v23 = (int)v22;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          _IOHIDEventSystemConnectionReleasePrivate_cold_4(a1, v21, v23, v24, v25, v26, v27, v28);
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 24));
  }
  v29 = *(_DWORD *)(a1 + 104);
  if (v29)
  {
    v30 = mach_port_mod_refs(*v9, v29, 1u, -1);
    *(_DWORD *)(a1 + 104) = 0;
    if (v30)
    {
      v31 = v30;
      v32 = _IOHIDLogCategory(9u);
      v33 = (int)v32;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        _IOHIDEventSystemConnectionReleasePrivate_cold_3(a1, v31, v33, v34, v35, v36, v37, v38);
    }
  }
  if (previous)
  {
    v39 = mach_port_deallocate(*v9, previous);
    if (v39)
    {
      v40 = v39;
      v41 = _IOHIDLogCategory(9u);
      v42 = (int)v41;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        _IOHIDEventSystemConnectionReleasePrivate_cold_2(a1, v40, v42, v43, v44, v45, v46, v47);
    }
  }
  v48 = *(_DWORD *)(a1 + 40);
  if (v48)
  {
    v49 = mach_port_deallocate(*v9, v48);
    *(_DWORD *)(a1 + 40) = 0;
    if (v49)
    {
      v50 = v49;
      v51 = _IOHIDLogCategory(9u);
      v52 = (int)v51;
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        _IOHIDEventSystemConnectionReleasePrivate_cold_1(a1, v50, v52, v53, v54, v55, v56, v57);
    }
  }
  v58 = *(const void **)(a1 + 136);
  if (v58)
    CFRelease(v58);
  v59 = *(const void **)(a1 + 184);
  if (v59)
    CFRelease(v59);
  v60 = *(const void **)(a1 + 144);
  if (v60)
    CFRelease(v60);
  v61 = *(const void **)(a1 + 152);
  if (v61)
    CFRelease(v61);
  v62 = *(const void **)(a1 + 160);
  if (v62)
    CFRelease(v62);
  v63 = *(_DWORD *)(a1 + 192);
  if (v63)
    mach_port_deallocate(*v9, v63);
  v64 = *(const void **)(a1 + 384);
  if (v64)
    CFRelease(v64);
  v65 = *(const void **)(a1 + 424);
  if (v65)
    CFRelease(v65);
  v66 = *(const void **)(a1 + 432);
  if (v66)
    CFRelease(v66);
  v67 = *(const void **)(a1 + 440);
  if (v67)
    CFRelease(v67);
  v68 = *(void **)(a1 + 392);
  if (v68)
    free(v68);
  v69 = *(void **)(a1 + 240);
  if (v69)
    free(v69);
  v70 = *(void **)(a1 + 248);
  if (v70)
    xpc_release(v70);
  v71 = *(const void **)(a1 + 8);
  if (v71)
    CFRelease(v71);
}

uint64_t IOHIDEventQueueGetNotificationPort(uint64_t a1)
{
  uint64_t v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(unsigned int *)(a1 + 96);
  os_unfair_recursive_lock_unlock();
  return v2;
}

void *IOHIDEventSystemClientSetCancelHandler(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 304);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 304) = result;
  return result;
}

id IOHIDServiceFilterUnschedule(id result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD, _QWORD);

  v1 = *((_QWORD *)result + 2);
  if (v1)
  {
    v2 = *(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v1 + 80);
    if (v2)
      return (id)v2(*((_QWORD *)result + 2), *((_QWORD *)result + 4));
  }
  if (*((_QWORD *)result + 12))
    return objc_msgSend(*((id *)result + 12), *((SEL *)result + 19));
  return result;
}

void _IOGetWithUUIDKey(CFStringRef uuidStr, uint64_t a2, uint64_t a3)
{
  CFUUIDRef v5;
  CFUUIDRef v6;

  v5 = CFUUIDCreateFromString(0, uuidStr);
  if (v5)
  {
    v6 = v5;
    if (CFEqual(v5, *(CFTypeRef *)(a3 + 8)))
      *(_QWORD *)a3 = a2;
    CFRelease(v6);
  }
}

uint64_t __IOMIGMachPortRegister()
{
  uint64_t result;

  __ioPortCache = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  result = _CFRuntimeRegisterClass();
  __IOMIGMachPortTypeID = result;
  return result;
}

void __hid_dispatch_queue_context_destructor(_QWORD *a1)
{
  void (*v2)(_QWORD);

  if (a1)
  {
    v2 = (void (*)(_QWORD))a1[3];
    if (v2)
      v2(a1[2]);
    free(a1);
  }
}

void __IOHIDServiceQueueContextDestructor(uint64_t a1)
{
  if (a1)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
    free((void *)a1);
  }
}

BOOL IOHIDServiceFilterSetCancelHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    CFRetain(*(CFTypeRef *)(a1 + 48));
    *(_QWORD *)(a1 + 56) = a2;
    objc_msgSend(*(id *)(a1 + 96), *(SEL *)(a1 + 136), *(_QWORD *)(a1 + 64));
  }
  return v2 != 0;
}

uint64_t __IOHIDEventSystemClientRegister()
{
  const __CFAllocator *v0;
  const CFSetCallBacks *v1;
  uint64_t result;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v1 = (const CFSetCallBacks *)MEMORY[0x1E0C9AEC0];
  __propertyCache = (uint64_t)CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)propertyCacheList, 2, MEMORY[0x1E0C9AEC0]);
  __restrictedRemapKeys = (uint64_t)CFSetCreate(v0, (const void **)restrictedRemapKeyList, 3, v1);
  result = _CFRuntimeRegisterClass();
  __kIOHIDEventSystemClientTypeID = result;
  return result;
}

void _IOHIDArrayAppendSInt64(void *a1, uint64_t a2)
{
  const __CFAllocator *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t valuePtr;

  valuePtr = a2;
  v3 = CFGetAllocator(a1);
  v4 = CFNumberCreate(v3, kCFNumberSInt64Type, &valuePtr);
  if (v4)
  {
    v5 = v4;
    CFArrayAppendValue((CFMutableArrayRef)a1, v4);
    CFRelease(v5);
  }
}

uint64_t io_connect_set_notification_port(unsigned int a1, int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  mach_msg_header_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v8 = 1;
  v9 = a3;
  v10 = 0x14000000000000;
  v11 = *MEMORY[0x1E0C804E8];
  v12 = a2;
  v13 = a4;
  *(_QWORD *)&v7.msgh_bits = 0x3C80001513;
  *(_QWORD *)&v7.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v7.msgh_voucher_port = 0xB3300000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v7.msgh_local_port);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(v7.msgh_local_port);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy(&v7);
  }
  return v5;
}

uint64_t IOHIDServiceClientRegisterRemovalCallback(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[4] = a2;
  a1[6] = a3;
  a1[7] = a4;
  return os_unfair_recursive_lock_unlock();
}

CFDictionaryRef IOPSCopyExternalPowerAdapterDetails(void)
{
  NSObject *PMQueue;
  NSObject *v1;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v3;
  xpc_object_t v4;
  void *v5;
  xpc_object_t v6;
  const __CFDictionary *v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  PMQueue = getPMQueue();
  if (PMQueue)
  {
    v1 = PMQueue;
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      v3 = mach_service;
      xpc_connection_set_target_queue(mach_service, v1);
      xpc_connection_set_event_handler(v3, &__block_literal_global_3);
      xpc_connection_resume(v3);
      v4 = xpc_dictionary_create(0, 0, 0);
      if (!v4)
      {
        v16 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v16)
          IOPSCopyExternalPowerAdapterDetails_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
        v7 = 0;
        goto LABEL_14;
      }
      v5 = v4;
      xpc_dictionary_set_string(v4, "adapterDetails", "true");
      v6 = xpc_connection_send_message_with_reply_sync(v3, v5);
      if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8] && xpc_dictionary_get_value(v6, "adapterDetails"))
      {
        v7 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
        if (!v6)
          goto LABEL_7;
      }
      else
      {
        v7 = 0;
        if (!v6)
        {
LABEL_7:
          xpc_release(v5);
LABEL_14:
          xpc_release(v3);
          return v7;
        }
      }
      xpc_release(v6);
      goto LABEL_7;
    }
    v8 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v8)
      IOPSCopyExternalPowerAdapterDetails_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  return 0;
}

uint64_t IOPMCopyAssertionActivityUpdateWithCallback(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  xpc_connection_t mach_service;
  _xpc_connection_s *v9;
  NSObject *PMQueue;
  xpc_object_t v11;
  void *v12;
  NSObject *v13;
  _BOOL8 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL8 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[8];

  v4 = 3758097084;
  result = 3758097090;
  if (a1 && a2 && a3)
  {
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E0C80D38], 0);
    if (mach_service)
    {
      v9 = mach_service;
      PMQueue = getPMQueue();
      xpc_connection_set_target_queue(v9, PMQueue);
      xpc_connection_set_event_handler(v9, &__block_literal_global_146);
      xpc_connection_resume(v9);
      v11 = xpc_dictionary_create(0, 0, 0);
      if (v11)
      {
        v12 = v11;
        xpc_dictionary_set_BOOL(v11, "assertionCopyActivityUpdate", 1);
        xpc_dictionary_set_uint64(v12, "assertionActivityUpdateRefCnt", *a1);
        v13 = getPMQueue();
        v30[0] = MEMORY[0x1E0C809B0];
        v30[1] = 0x40000000;
        v30[2] = __IOPMCopyAssertionActivityUpdateWithCallback_block_invoke_149;
        v30[3] = &unk_1E2003C90;
        v30[4] = a3;
        v30[5] = a1;
        v30[6] = a2;
        v30[7] = v9;
        xpc_connection_send_message_with_reply(v9, v12, v13, v30);
        xpc_release(v12);
        v4 = 0;
      }
      else if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          IOPMCopyActiveAsyncAssertionsByProcess_cold_4();
      }
      else
      {
        v22 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v22)
          IOPMCopyActiveAsyncAssertionsByProcess_cold_3(v22, v23, v24, v25, v26, v27, v28, v29);
      }
      xpc_release(v9);
      return v4;
    }
    else
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          IOPMCopyAssertionActivityUpdateWithCallback_cold_2();
      }
      else
      {
        v14 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v14)
          IOPSGaugingMitigationGetState_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
      }
      return 3758097084;
    }
  }
  return result;
}

uint64_t IOPSCopyPowerSourcesByTypePrecise(int a1, uint64_t *a2)
{
  uint64_t uint64;
  NSObject *PMQueue;
  NSObject *v6;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v8;
  xpc_object_t v9;
  void *v10;
  xpc_object_t v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  uint64 = 3758097084;
  PMQueue = getPMQueue();
  if (a2)
  {
    v6 = PMQueue;
    if (PMQueue)
    {
      mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
      if (mach_service)
      {
        v8 = mach_service;
        xpc_connection_set_target_queue(mach_service, v6);
        xpc_connection_set_event_handler(v8, &__block_literal_global_72);
        xpc_connection_resume(v8);
        v9 = xpc_dictionary_create(0, 0, 0);
        if (v9)
        {
          v10 = v9;
          xpc_dictionary_set_uint64(v9, "powerInfoPrecise", a1);
          v11 = xpc_connection_send_message_with_reply_sync(v8, v10);
          if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
          {
            uint64 = xpc_dictionary_get_uint64(v11, "returnCode");
            if (!(_DWORD)uint64)
            {
              xpc_dictionary_get_value(v11, "powerInfoPrecise");
              *a2 = _CFXPCCreateCFObjectFromXPCObject();
            }
          }
          if (v11)
            xpc_release(v11);
          xpc_release(v10);
        }
        else
        {
          v20 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
          uint64 = 3758097086;
          if (v20)
            IOPSGaugingMitigationGetState_cold_2(v20, v21, v22, v23, v24, v25, v26, v27);
        }
        xpc_release(v8);
      }
      else
      {
        v12 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        uint64 = 3758097087;
        if (v12)
          IOPSGaugingMitigationGetState_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
      }
    }
  }
  return uint64;
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  IOReturn v1;
  int v4;
  uint64_t v5;
  int v6;
  IOReturn v7;

  v1 = -536870199;
  v7 = -536870212;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  if (!AssertionID)
    return -536870206;
  if (AssertionID >= 0x10000 && gAssertionsDict)
    return releaseAsyncAssertion(AssertionID);
  if (!pm_connect_init(&v6))
  {
    if (io_pm_assertion_retain_release(v6, AssertionID, -1, &v4, (_DWORD *)&v5 + 1, &v5, &v7))
      v7 = -536870199;
    if (v4)
      entr_act_modify();
    else
      entr_act_end();
    _pm_disconnect();
    return v7;
  }
  return v1;
}

uint64_t io_pm_assertion_retain_release(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  mach_port_name_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v17;
  int v18;
  _BYTE msg[36];
  __int128 v20;
  uint64_t v21;

  *(_OWORD *)&msg[20] = 0u;
  v20 = 0u;
  v21 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg[32] = a2;
  LODWORD(v20) = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x11D3100000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v13 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x28u, 0x3Cu, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v14 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 73109)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 52)
          {
            if (!*(_DWORD *)&msg[8])
            {
              v14 = *(unsigned int *)&msg[32];
              if (!*(_DWORD *)&msg[32])
              {
                v17 = DWORD1(v20);
                *a4 = v20;
                *a5 = v17;
                v18 = HIDWORD(v20);
                *a6 = DWORD2(v20);
                *a7 = v18;
                return v14;
              }
              goto LABEL_22;
            }
          }
          else if (*(_DWORD *)&msg[4] == 36)
          {
            if (*(_DWORD *)&msg[8])
              v15 = 1;
            else
              v15 = *(_DWORD *)&msg[32] == 0;
            if (v15)
              v14 = 4294966996;
            else
              v14 = *(unsigned int *)&msg[32];
            goto LABEL_22;
          }
        }
        v14 = 4294966996;
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

IOReturn IOPMAssertionCreateWithName(CFStringRef AssertionType, IOPMAssertionLevel AssertionLevel, CFStringRef AssertionName, IOPMAssertionID *AssertionID)
{
  IOReturn v4;
  CFNumberRef v8;
  CFTypeID TypeID;
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  IOPMAssertionLevel valuePtr;

  v4 = -536870212;
  valuePtr = AssertionLevel;
  if (AssertionType && AssertionName && AssertionID)
  {
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    TypeID = CFNumberGetTypeID();
    if (v8)
    {
      if (CFGetTypeID(v8) == TypeID)
      {
        Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (Mutable)
        {
          v11 = Mutable;
          CFDictionarySetValue(Mutable, CFSTR("AssertType"), AssertionType);
          CFDictionarySetValue(v11, CFSTR("AssertName"), AssertionName);
          CFDictionarySetValue(v11, CFSTR("AssertLevel"), v8);
          CFRelease(v8);
          v4 = IOPMAssertionCreateWithProperties(v11, AssertionID);
          CFRelease(v11);
        }
      }
    }
  }
  else
  {
    v12 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    v4 = -536870206;
    if (v12)
      IOPMAssertionCreateWithName_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  return v4;
}

IOReturn IOPMAssertionCreateWithDescription(CFStringRef AssertionType, CFStringRef Name, CFStringRef Details, CFStringRef HumanReadableReason, CFStringRef LocalizationBundlePath, CFTimeInterval Timeout, CFStringRef TimeoutAction, IOPMAssertionID *AssertionID)
{
  IOReturn result;
  __CFDictionary *AssertionDescription;
  __CFDictionary *v12;
  IOReturn v13;

  result = -536870206;
  if (AssertionType && Name && AssertionID)
  {
    AssertionDescription = createAssertionDescription(AssertionType, Name, Details, HumanReadableReason, LocalizationBundlePath, TimeoutAction, Timeout);
    if (AssertionDescription)
    {
      v12 = AssertionDescription;
      v13 = IOPMAssertionCreateWithProperties(AssertionDescription, AssertionID);
      CFRelease(v12);
      return v13;
    }
    else
    {
      return -536870212;
    }
  }
  return result;
}

__CFDictionary *createAssertionDescription(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, double a7)
{
  __CFDictionary *Mutable;
  __CFDictionary *v15;
  CFNumberRef v16;
  double valuePtr;

  valuePtr = a7;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v15 = Mutable;
  if (Mutable)
  {
    CFDictionarySetValue(Mutable, CFSTR("AssertName"), a2);
    CFDictionarySetValue(v15, CFSTR("AssertType"), a1);
    if (a3)
      CFDictionarySetValue(v15, CFSTR("Details"), a3);
    if (a4)
      CFDictionarySetValue(v15, CFSTR("HumanReadableReason"), a4);
    if (a5)
      CFDictionarySetValue(v15, CFSTR("BundlePath"), a5);
    if (a7 != 0.0)
    {
      v16 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
      CFDictionarySetValue(v15, CFSTR("TimeoutSeconds"), v16);
      CFRelease(v16);
    }
    if (a6)
      CFDictionarySetValue(v15, CFSTR("TimeoutAction"), a6);
  }
  return v15;
}

IOReturn IOPMCancelScheduledPowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type)
{
  const __CFData *v6;
  IOReturn v7;
  const __CFData *Data;
  mach_port_t v10;
  const UInt8 *BytePtr;
  int Length;
  CFTypeRef cf;
  mach_port_t v14;
  IOReturn v15;

  v14 = 0;
  cf = 0;
  if ((inputsValid(time_to_wake, type) & 1) == 0)
  {
    v6 = 0;
    goto LABEL_6;
  }
  if (_pm_connect(&v14))
  {
    v6 = 0;
LABEL_4:
    v7 = -536870199;
LABEL_7:
    v15 = v7;
    goto LABEL_8;
  }
  v15 = _IOPMCreatePowerOnDictionary(time_to_wake, my_id, type, (__CFDictionary **)&cf);
  if (v15)
  {
    v6 = 0;
    goto LABEL_8;
  }
  Data = CFPropertyListCreateData(0, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  v6 = Data;
  if (!Data)
  {
LABEL_6:
    v7 = -536870206;
    goto LABEL_7;
  }
  v10 = v14;
  BytePtr = CFDataGetBytePtr(Data);
  Length = CFDataGetLength(v6);
  if (io_pm_schedule_power_event(v10, (uint64_t)BytePtr, Length, 0, &v15))
    goto LABEL_4;
LABEL_8:
  if (v14)
    _pm_disconnect();
  if (cf)
    CFRelease(cf);
  if (v6)
    CFRelease(v6);
  return v15;
}

uint64_t inputsValid(const void *a1, const void *a2)
{
  CFTypeID TypeID;
  uint64_t result;
  CFTypeID v6;

  TypeID = CFDateGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID
    || CFEqual(a2, CFSTR("WakeImmediate"))
    || (result = CFEqual(a2, CFSTR("PowerOnImmediate")), (_DWORD)result))
  {
    v6 = CFStringGetTypeID();
    if (a2 && CFGetTypeID(a2) == v6)
    {
      if (CFEqual(a2, CFSTR("wake")))
        return 1;
      if (CFEqual(a2, CFSTR("poweron")))
        return 1;
      if (CFEqual(a2, CFSTR("wakepoweron")))
        return 1;
      if (CFEqual(a2, CFSTR("sleep")))
        return 1;
      if (CFEqual(a2, CFSTR("shutdown")))
        return 1;
      if (CFEqual(a2, CFSTR("restart")))
        return 1;
      if (CFEqual(a2, CFSTR("WakeImmediate")))
        return 1;
      if (CFEqual(a2, CFSTR("PowerOnImmediate")))
        return 1;
      if (CFEqual(a2, CFSTR("WakeRelativeToSleep")))
        return 1;
      if (CFEqual(a2, CFSTR("PowerRelativeToShutdown")))
        return 1;
      if (CFEqual(a2, CFSTR("MaintenanceImmediate")))
        return 1;
      result = CFEqual(a2, CFSTR("SleepServiceImmediate"));
      if ((_DWORD)result)
        return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IOPMRequestSysWake(const void *a1)
{
  CFTypeID TypeID;
  const void *Value;
  const __CFString *v4;
  const void *v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  const void *v9;
  const void *v10;
  const __CFData *v11;
  unsigned int v12;
  __CFDictionary *v14;
  const __CFData *Data;
  mach_port_t v16;
  const UInt8 *BytePtr;
  int Length;
  CFTypeRef cf;
  mach_port_t v20;
  unsigned int v21;

  v20 = 0;
  cf = 0;
  TypeID = CFDictionaryGetTypeID();
  if (!a1
    || CFGetTypeID(a1) != TypeID
    || (Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("time")),
        v4 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("scheduledby")),
        v5 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("leeway")),
        v6 = CFDateGetTypeID(),
        !Value)
    || CFGetTypeID(Value) != v6
    || (v7 = CFStringGetTypeID(), !v4)
    || CFGetTypeID(v4) != v7
    || v5 && (v8 = CFNumberGetTypeID(), CFGetTypeID(v5) != v8))
  {
    v11 = 0;
    goto LABEL_16;
  }
  v9 = (const void *)*MEMORY[0x1E0C9AE40];
  if (CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("UserVisible")) == (const void *)*MEMORY[0x1E0C9AE50])
    v10 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v10 = v9;
  if (_pm_connect(&v20))
  {
    v11 = 0;
LABEL_14:
    v12 = -536870199;
LABEL_17:
    v21 = v12;
    goto LABEL_18;
  }
  v21 = _IOPMCreatePowerOnDictionary(Value, v4, CFSTR("wake"), (__CFDictionary **)&cf);
  if (v21)
  {
    v11 = 0;
    goto LABEL_18;
  }
  v14 = (__CFDictionary *)cf;
  if (v5)
    CFDictionaryAddValue((CFMutableDictionaryRef)cf, CFSTR("leeway"), v5);
  CFDictionaryAddValue(v14, CFSTR("UserVisible"), v10);
  Data = CFPropertyListCreateData(0, v14, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  v11 = Data;
  if (!Data)
  {
LABEL_16:
    v12 = -536870206;
    goto LABEL_17;
  }
  v16 = v20;
  BytePtr = CFDataGetBytePtr(Data);
  Length = CFDataGetLength(v11);
  if (io_pm_schedule_power_event(v16, (uint64_t)BytePtr, Length, 1, (int *)&v21))
    goto LABEL_14;
LABEL_18:
  if (v20)
    _pm_disconnect();
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v21;
}

uint64_t io_pm_schedule_power_event(mach_port_t a1, uint64_t a2, int a3, int a4, int *a5)
{
  mach_port_t special_reply_port;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  mach_msg_header_t msg;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13 = 1;
  v14 = a2;
  v15 = 16777472;
  v16 = a3;
  v17 = *MEMORY[0x1E0C804E8];
  v18 = a3;
  v19 = a4;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x11D2B00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v8 = mach_msg(&msg, 3162115, 0x3Cu, 0x30u, special_reply_port, 0, 0);
  v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v8)
    {
      if (msg.msgh_id == 71)
      {
        v9 = 4294966988;
      }
      else if (msg.msgh_id == 73103)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v9 = HIDWORD(v14);
              if (!HIDWORD(v14))
              {
                *a5 = v15;
                return v9;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v10 = 1;
            else
              v10 = HIDWORD(v14) == 0;
            if (v10)
              v9 = 4294966996;
            else
              v9 = HIDWORD(v14);
            goto LABEL_22;
          }
        }
        v9 = 4294966996;
      }
      else
      {
        v9 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v9;
    }
    mig_dealloc_special_reply_port();
  }
  return v9;
}

uint64_t _IOPMCreatePowerOnDictionary(const void *a1, const __CFString *a2, const void *a3, __CFDictionary **a4)
{
  CFTypeID TypeID;
  const __CFString *v9;
  uint64_t v10;
  const __CFString *v11;
  CFTypeID v12;
  __CFDictionary *Mutable;
  __CFDictionary *v14;

  TypeID = CFStringGetTypeID();
  if (a2)
  {
    if (CFGetTypeID(a2) == TypeID)
      v9 = a2;
    else
      v9 = 0;
  }
  else
  {
    v9 = 0;
  }
  v10 = 3758097085;
  if (v9)
    v11 = v9;
  else
    v11 = &stru_1E2005170;
  v12 = CFDateGetTypeID();
  if (a1 && CFGetTypeID(a1) == v12)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v14 = Mutable;
      CFDictionaryAddValue(Mutable, CFSTR("time"), a1);
      CFDictionaryAddValue(v14, CFSTR("scheduledby"), v11);
      CFDictionaryAddValue(v14, CFSTR("eventtype"), a3);
      v10 = 0;
      *a4 = v14;
    }
  }
  else
  {
    asl_log(0, 0, 3, "_IOPMCreatePowerOnDictionary received invalid date\n");
    return 3758097090;
  }
  return v10;
}

uint64_t releaseAsyncAssertion(int a1)
{
  NSObject *PMQueue;
  uint64_t v3;
  _QWORD v5[5];
  int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  PMQueue = getPMQueue();
  if (!PMQueue)
    *((_DWORD *)v8 + 6) = -536870199;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __releaseAsyncAssertion_block_invoke;
  v5[3] = &unk_1E2003A28;
  v5[4] = &v7;
  v6 = a1;
  dispatch_sync(PMQueue, v5);
  v3 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

CFArrayRef IOPSCopyPowerSourcesByType(int a1)
{
  CFPropertyListRef v2;
  const __CFData *v3;
  const __CFData *v4;
  int v6;
  mach_vm_size_t v7;
  const UInt8 *v8;
  int v9;

  v9 = 0;
  if (_pm_connect(&v9))
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  v7 = 0;
  v8 = 0;
  v6 = 0;
  io_ps_copy_powersources_info(v9, a1, &v8, &v7, &v6);
  v3 = CFDataCreate(0, v8, v7);
  if (v3)
  {
    v4 = v3;
    v2 = CFPropertyListCreateWithData(0, v3, 0, 0, 0);
    CFRelease(v4);
  }
  else
  {
    v2 = 0;
  }
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v8, v7);
  if (!v2)
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  return (CFArrayRef)v2;
}

uint64_t setAsyncAssertionProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t PMQueue;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  _QWORD v11[7];
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  PMQueue = getPMQueue();
  if (PMQueue)
  {
    v7 = PMQueue;
    v8 = assertions_log;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109634;
        v18 = a3;
        v19 = 2112;
        v20 = a1;
        v21 = 2112;
        v22 = a2;
        _os_log_debug_impl(&dword_18AAAF000, v8, OS_LOG_TYPE_DEBUG, "setAsyncAssertionProperties for 0x%x %@:%@", buf, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      setAsyncAssertionProperties_cold_1(a1, a2, a3);
    }
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = __setAsyncAssertionProperties_block_invoke;
    v11[3] = &unk_1E2003A50;
    v12 = a3;
    v11[4] = &v13;
    v11[5] = a1;
    v11[6] = a2;
    dispatch_sync(v7, v11);
    v9 = *((unsigned int *)v14 + 6);
  }
  else
  {
    v9 = 3758097097;
    *((_DWORD *)v14 + 6) = -536870199;
  }
  _Block_object_dispose(&v13, 8);
  return v9;
}

uint64_t IOPMAssertionDeclareSystemActivityWithProperties(const __CFDictionary *a1, int *a2, int *a3)
{
  const void *Value;
  CFTypeID TypeID;
  const void *v8;
  CFTypeID v9;
  const __CFData *Data;
  const __CFData *v11;
  mach_port_t v12;
  const UInt8 *BytePtr;
  int Length;
  mach_port_t v16;
  unsigned int v17;

  v16 = 0;
  v17 = -536870212;
  if (!a1 || !a2 || !a3)
    goto LABEL_16;
  if (pm_connect_init(&v16))
  {
    v17 = -536870199;
    goto LABEL_17;
  }
  Value = CFDictionaryGetValue(a1, CFSTR("AssertName"));
  TypeID = CFStringGetTypeID();
  if (!Value)
    goto LABEL_16;
  if (CFGetTypeID(Value) != TypeID)
    goto LABEL_16;
  v8 = CFDictionaryGetValue(a1, CFSTR("AssertType"));
  v9 = CFStringGetTypeID();
  if (v8)
  {
    if (CFGetTypeID(v8) == v9)
      goto LABEL_16;
  }
  if (collectBackTrace)
    saveBackTrace(a1);
  Data = CFPropertyListCreateData(0, a1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    v11 = Data;
    v12 = v16;
    BytePtr = CFDataGetBytePtr(Data);
    Length = CFDataGetLength(v11);
    if (io_pm_declare_system_active(v12, a3, (uint64_t)BytePtr, Length, a2, &v17))
      v17 = -536870199;
    CFRelease(v11);
  }
  else
  {
LABEL_16:
    v17 = -536870206;
  }
LABEL_17:
  if (v16)
    _pm_disconnect();
  return v17;
}

IOReturn IOPMAssertionCreateWithProperties(CFDictionaryRef AssertionProperties, IOPMAssertionID *AssertionID)
{
  const void *Value;
  const void *v5;
  CFTypeID TypeID;
  CFTypeID v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFDictionary *v16;
  _BOOL8 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL8 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFTypeID v34;
  const __CFNumber *v35;
  CFTypeID v36;
  _BOOL4 v37;
  __CFDictionary *MutableCopy;
  CFTypeID v39;
  CFDictionaryRef v40;
  CFDataRef Data;
  const __CFData *v42;
  _BOOL4 v43;
  mach_port_t v44;
  const UInt8 *BytePtr;
  int Length;
  _BOOL8 v47;
  uint64_t v48;
  uint64_t v49;
  int valuePtr;
  int v51;
  int v52;
  mach_port_t v53;
  IOReturn v54;

  v53 = 0;
  v54 = -536870212;
  v51 = -1;
  v52 = 0;
  if (!AssertionProperties || !AssertionID)
  {
    v17 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v17)
      IOPMAssertionCreateWithProperties_cold_6(v17, v18, v19, v20, v21, v22, v23, v24);
    goto LABEL_15;
  }
  Value = CFDictionaryGetValue(AssertionProperties, CFSTR("AssertType"));
  v5 = CFDictionaryGetValue(AssertionProperties, CFSTR("AssertName"));
  TypeID = CFStringGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID || (v7 = CFStringGetTypeID(), !v5) || CFGetTypeID(v5) != v7)
  {
    v25 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v25)
      IOPMAssertionCreateWithProperties_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
LABEL_15:
    v16 = 0;
LABEL_16:
    v54 = -536870206;
    goto LABEL_17;
  }
  if (pm_connect_init(&v53))
  {
    v8 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v8)
      IOPMAssertionCreateWithProperties_cold_5(v8, v9, v10, v11, v12, v13, v14, v15);
LABEL_10:
    v16 = 0;
    v54 = -536870199;
    goto LABEL_17;
  }
  v34 = CFStringGetTypeID();
  if (CFGetTypeID(Value) == v34
    && CFEqual(Value, CFSTR("EnableIdleSleep"))
    && !IOPMAssertionCreateWithProperties_resyncToken)
  {
    IOPMAssertionCreateWithProperties_resyncCopy = (uint64_t)CFDictionaryCreateMutableCopy(0, 0, AssertionProperties);
    notify_register_dispatch("com.apple.system.powermanagement.assertionresync", &IOPMAssertionCreateWithProperties_resyncToken, MEMORY[0x1E0C80D38], &__block_literal_global_130_0);
  }
  v35 = (const __CFNumber *)CFDictionaryGetValue(AssertionProperties, CFSTR("AssertLevel"));
  v36 = CFNumberGetTypeID();
  if (v35 && CFGetTypeID(v35) == v36)
  {
    valuePtr = 0;
    CFNumberGetValue(v35, kCFNumberIntType, &valuePtr);
    v37 = valuePtr != 0;
  }
  else
  {
    v37 = 1;
  }
  v16 = 0;
  if (collectBackTrace && v37)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, AssertionProperties);
    if (!MutableCopy)
    {
      v47 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v47)
        IOPMAssertionCreateWithProperties_cold_2(v47, v48, v49);
      goto LABEL_10;
    }
    v16 = MutableCopy;
    saveBackTrace(MutableCopy);
  }
  v39 = CFStringGetTypeID();
  if (CFGetTypeID(Value) == v39
    && (CFEqual(Value, CFSTR("PreventUserIdleSystemSleep"))
     || CFEqual(Value, CFSTR("NoIdleSleepAssertion"))
     || CFEqual(Value, CFSTR("SystemIsActive"))))
  {
    if (!v16)
      v16 = CFDictionaryCreateMutableCopy(0, 0, AssertionProperties);
    if (!CFDictionaryContainsKey(v16, CFSTR("AllowsDeviceRestart")))
      CFDictionarySetValue(v16, CFSTR("AllowsDeviceRestart"), (const void *)*MEMORY[0x1E0C9AE50]);
  }
  if (v16)
    v40 = v16;
  else
    v40 = AssertionProperties;
  Data = CFPropertyListCreateData(0, v40, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (!Data)
    goto LABEL_16;
  v42 = Data;
  if (createAsyncAssertion(v40, (uint64_t)AssertionID))
  {
    v54 = 0;
    v51 = 0x10000;
  }
  else
  {
    v44 = v53;
    BytePtr = CFDataGetBytePtr(v42);
    Length = CFDataGetLength(v42);
    if (io_pm_assertion_create(v44, (uint64_t)BytePtr, Length, (int *)AssertionID, &v52, &v51, &v54))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        IOPMAssertionCreateWithProperties_cold_4();
      v54 = -536870199;
      goto LABEL_57;
    }
    if (v54 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      IOPMAssertionCreateWithProperties_cold_3();
  }
  if (v51)
    v43 = v37;
  else
    v43 = 0;
  if (v43)
    entr_act_begin();
LABEL_57:
  CFRelease(v42);
LABEL_17:
  if (v53)
    _pm_disconnect();
  if (v16)
    CFRelease(v16);
  return v54;
}

IOReturn IOPMAssertionSetProperty(IOPMAssertionID theAssertion, CFStringRef theProperty, CFTypeRef theValue)
{
  int v6;
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  _BOOL4 v10;
  _BOOL4 v11;
  const __CFData *Data;
  mach_port_t v13;
  const UInt8 *BytePtr;
  int Length;
  CFTypeID TypeID;
  int valuePtr;
  int v18;
  uint64_t v19;
  mach_port_t v20;
  IOReturn v21;

  v20 = 0;
  v19 = 0;
  v18 = -1;
  if (!theAssertion)
  {
    v6 = -536870206;
    goto LABEL_6;
  }
  if (theAssertion >= 0x10000 && gAssertionsDict)
  {
    v21 = setAsyncAssertionProperties((uint64_t)theProperty, (uint64_t)theValue, *(uint64_t *)&theAssertion);
    goto LABEL_8;
  }
  v21 = pm_connect_init(&v20);
  if (!v21)
  {
    Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v9 = Mutable;
      CFDictionarySetValue(Mutable, theProperty, theValue);
      if (CFStringCompare(theProperty, CFSTR("AssertLevel"), 0) == kCFCompareEqualTo
        && (TypeID = CFNumberGetTypeID(), theValue)
        && CFGetTypeID(theValue) == TypeID)
      {
        valuePtr = 0;
        CFNumberGetValue((CFNumberRef)theValue, kCFNumberIntType, &valuePtr);
        v10 = valuePtr == 0;
        v11 = valuePtr == 255;
        if (valuePtr == 255 && collectBackTrace)
        {
          saveBackTrace(v9);
          v10 = 0;
          v11 = 1;
        }
      }
      else
      {
        v10 = 0;
        v11 = 0;
      }
      Data = CFPropertyListCreateData(0, v9, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      CFRelease(v9);
      v13 = v20;
      BytePtr = CFDataGetBytePtr(Data);
      Length = CFDataGetLength(Data);
      if (io_pm_assertion_set_properties(v13, theAssertion, (uint64_t)BytePtr, Length, (int *)&v19 + 1, &v19, &v18, &v21))
      {
        v21 = -536870199;
      }
      else if (v18)
      {
        if (v11)
        {
          entr_act_begin();
        }
        else if (v10)
        {
          entr_act_end();
        }
      }
      if (Data)
        CFRelease(Data);
      goto LABEL_8;
    }
    v6 = -536870211;
LABEL_6:
    v21 = v6;
  }
LABEL_8:
  if (v20)
    _pm_disconnect();
  return v21;
}

uint64_t _pm_connect(_DWORD *a1)
{
  uint64_t v1;
  int v3;

  v1 = 3758097084;
  if (!a1)
    return 3758097090;
  if (powerd_connection)
  {
    v1 = 0;
    *a1 = powerd_connection;
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&lock);
    if (powerd_connection)
    {
      v1 = 0;
      *a1 = powerd_connection;
    }
    else
    {
      v3 = bootstrap_look_up2();
      if (v3)
      {
        powerd_connection = 0;
        *a1 = 0;
        asl_log(0, 0, 3, "bootstrap_look_up2 failed with 0x%x\n", v3);
      }
      else
      {
        *a1 = powerd_connection;
        v1 = 0;
        if (pthread_atfork(0, 0, _reset_connection))
          powerd_connection = 0;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&lock);
  }
  return v1;
}

uint64_t _pm_disconnect()
{
  return 0;
}

uint64_t pm_connect_init(_DWORD *a1)
{
  if (!pm_connect_init_collectBackTraceToken)
  {
    notify_register_dispatch("com.apple.powermanagement.collectbt", &pm_connect_init_collectBackTraceToken, MEMORY[0x1E0C80D38], &__block_literal_global_165);
    notify_get_state(pm_connect_init_collectBackTraceToken, (uint64_t *)&collectBackTrace);
  }
  return _pm_connect(a1);
}

uint64_t io_pm_assertion_set_properties(mach_port_t a1, int a2, uint64_t a3, int a4, int *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  mach_port_t special_reply_port;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v18;
  int v19;
  mach_msg_header_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;

  v21 = 1;
  v22 = a3;
  v23 = 16777472;
  v24 = a4;
  v25 = *MEMORY[0x1E0C804E8];
  v26 = a2;
  v27 = a4;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v20.msgh_bits = 2147489043;
  v20.msgh_remote_port = a1;
  v20.msgh_local_port = special_reply_port;
  *(_QWORD *)&v20.msgh_voucher_port = 0x11D3000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v20);
    special_reply_port = v20.msgh_local_port;
  }
  v14 = mach_msg(&v20, 3162115, 0x3Cu, 0x3Cu, special_reply_port, 0, 0);
  v15 = v14;
  if ((v14 - 268435458) > 0xE || ((1 << (v14 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v14)
    {
      if (v20.msgh_id == 71)
      {
        v15 = 4294966988;
      }
      else if (v20.msgh_id == 73108)
      {
        if ((v20.msgh_bits & 0x80000000) == 0)
        {
          if (v20.msgh_size == 52)
          {
            if (!v20.msgh_remote_port)
            {
              v15 = HIDWORD(v22);
              if (!HIDWORD(v22))
              {
                v18 = v24;
                *a5 = v23;
                *a6 = v18;
                v19 = HIDWORD(v25);
                *a7 = v25;
                *a8 = v19;
                return v15;
              }
              goto LABEL_22;
            }
          }
          else if (v20.msgh_size == 36)
          {
            if (v20.msgh_remote_port)
              v16 = 1;
            else
              v16 = HIDWORD(v22) == 0;
            if (v16)
              v15 = 4294966996;
            else
              v15 = HIDWORD(v22);
            goto LABEL_22;
          }
        }
        v15 = 4294966996;
      }
      else
      {
        v15 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&v20);
      return v15;
    }
    mig_dealloc_special_reply_port();
  }
  return v15;
}

BOOL createAsyncAssertion(const __CFDictionary *a1, uint64_t a2)
{
  const void *Value;
  CFTypeID TypeID;
  NSObject *PMQueue;
  _BOOL8 v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD block[7];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 1;
  if (gAsyncModeDisableOverride)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        createAsyncAssertion_cold_2();
    }
    else
    {
      v8 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (v8)
        createAsyncAssertion_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    goto LABEL_15;
  }
  if (!gAsyncMode)
  {
    if (checkFeatureEnabled_onceToken == -1)
    {
      v7 = 0;
      goto LABEL_16;
    }
    dispatch_once(&checkFeatureEnabled_onceToken, &__block_literal_global_14);
    goto LABEL_15;
  }
  Value = CFDictionaryGetValue(a1, CFSTR("AssertType"));
  TypeID = CFStringGetTypeID();
  if (!Value
    || CFGetTypeID(Value) != TypeID
    || !CFEqual(Value, CFSTR("PreventUserIdleSystemSleep")) && !CFEqual(Value, CFSTR("NoIdleSleepAssertion"))
    || CFDictionaryContainsKey(a1, CFSTR("ResourcesUsed"))
    || (PMQueue = getPMQueue()) == 0)
  {
LABEL_15:
    v7 = 0;
    goto LABEL_16;
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __createAsyncAssertion_block_invoke;
  block[3] = &unk_1E2003A00;
  block[4] = &v18;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync(PMQueue, block);
  v7 = *((_BYTE *)v19 + 24) != 0;
LABEL_16:
  _Block_object_dispose(&v18, 8);
  return v7;
}

uint64_t getPMQueue()
{
  uint64_t result;
  _BOOL8 v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = getPMQueue_pmQueue;
  if (!getPMQueue_pmQueue)
  {
    if (getPMQueue_pmQueue_pred != -1)
      dispatch_once(&getPMQueue_pmQueue_pred, &__block_literal_global_5);
    result = getPMQueue_pmQueue;
    if (!getPMQueue_pmQueue)
    {
      v1 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v1)
        getPMQueue_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
      return 0;
    }
  }
  return result;
}

uint64_t io_pm_declare_system_active(mach_port_t a1, int *a2, uint64_t a3, int a4, int *a5, _DWORD *a6)
{
  mach_port_t special_reply_port;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  int v15;
  mach_msg_header_t msg;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v17 = 1;
  v18 = a3;
  v19 = 16777472;
  v20 = a4;
  v21 = *MEMORY[0x1E0C804E8];
  v22 = *a2;
  v23 = a4;
  v24 = *a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x11D3300000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3162115, 0x40u, 0x38u, special_reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v11)
    {
      if (msg.msgh_id == 71)
      {
        v12 = 4294966988;
      }
      else if (msg.msgh_id == 73111)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 48)
          {
            if (!msg.msgh_remote_port)
            {
              v12 = HIDWORD(v18);
              if (!HIDWORD(v18))
              {
                v15 = v20;
                *a2 = v19;
                *a5 = v15;
                *a6 = v21;
                return v12;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v13 = 1;
            else
              v13 = HIDWORD(v18) == 0;
            if (v13)
              v12 = 4294966996;
            else
              v12 = HIDWORD(v18);
            goto LABEL_22;
          }
        }
        v12 = 4294966996;
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  return v12;
}

uint64_t io_ps_copy_powersources_info(int a1, int a2, _QWORD *a3, _DWORD *a4, _DWORD *a5)
{
  mach_port_name_t special_reply_port;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BYTE msg[36];
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[20] = 0u;
  v16 = 0u;
  v15 = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg[32] = a2;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x11D3E00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v10 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x24u, 0x44u, special_reply_port, 0, 0);
  v11 = v10;
  if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v10)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v11 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 73122)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            v11 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8])
                v11 = 4294966996;
              else
                v11 = *(unsigned int *)&msg[32];
            }
          }
          else
          {
            v11 = 4294966996;
          }
          goto LABEL_24;
        }
        v11 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 60 && !*(_DWORD *)&msg[8] && BYTE3(v15) == 1)
        {
          v12 = DWORD1(v15);
          if (DWORD1(v15) == (_DWORD)v16)
          {
            v11 = 0;
            *a3 = *(_QWORD *)&msg[28];
            *a4 = v12;
            *a5 = DWORD1(v16);
            return v11;
          }
        }
      }
      else
      {
        v11 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v11;
    }
    mig_dealloc_special_reply_port();
  }
  return v11;
}

uint64_t io_pm_assertion_create(mach_port_t a1, uint64_t a2, int a3, int *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  mach_port_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v17;
  int v18;
  mach_msg_header_t msg;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;

  msg.msgh_id = 0;
  v24 = 0;
  v25 = 0;
  *(_OWORD *)&msg.msgh_size = 0u;
  v20 = 1;
  v21 = a2;
  v22 = 16777472;
  v23 = a3;
  v24 = *MEMORY[0x1E0C804E8];
  LODWORD(v25) = a3;
  special_reply_port = mig_get_special_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x11D2F00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3162115, 0x38u, 0x3Cu, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 73107)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 52)
          {
            if (!msg.msgh_remote_port)
            {
              v14 = HIDWORD(v21);
              if (!HIDWORD(v21))
              {
                v17 = v23;
                *a4 = v22;
                *a5 = v17;
                v18 = HIDWORD(v24);
                *a6 = v24;
                *a7 = v18;
                return v14;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v15 = 1;
            else
              v15 = HIDWORD(v21) == 0;
            if (v15)
              v14 = 4294966996;
            else
              v14 = HIDWORD(v21);
            goto LABEL_22;
          }
        }
        v14 = 4294966996;
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

_QWORD *IOHIDEventSetFloatValueWithOptions(_QWORD *result, unsigned int a2, uint64_t a3, double a4)
{
  unsigned int v6;
  uint64_t v7;
  char v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;

  v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (result = (_QWORD *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a3)) != 0)
  {
    v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFE | (a4 != 0.0);
            goto LABEL_168;
          case 1u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFD | (2 * (a4 != 0.0));
            goto LABEL_168;
          case 2u:
            goto LABEL_23;
          case 3u:
            v8 = *(_BYTE *)(v7 + 8) & 0xF7 | (8 * (a4 != 0.0));
            goto LABEL_168;
          case 4u:
            v8 = *(_BYTE *)(v7 + 8) & 0xEF | (16 * (a4 != 0.0));
            goto LABEL_168;
          case 5u:
            v8 = *(_BYTE *)(v7 + 8) & 0xDF | (32 * (a4 != 0.0));
            goto LABEL_168;
          case 6u:
            v8 = *(_BYTE *)(v7 + 8) & 0xBF | ((a4 != 0.0) << 6);
            goto LABEL_168;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10002u:
            v16 = a4;
            goto LABEL_158;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x10000u:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_139;
          case 0x20001u:
            goto LABEL_130;
          case 0x20002u:
            goto LABEL_131;
          case 0x20003u:
            goto LABEL_154;
          case 0x20004u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_113;
          case 0x30001u:
            goto LABEL_120;
          case 0x30002u:
            goto LABEL_157;
          case 0x30003u:
            goto LABEL_170;
          case 0x30004u:
            *(_BYTE *)(v7 + 28) = (int)a4;
            return result;
          case 0x30005u:
            v13 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a4 != 0.0);
            goto LABEL_148;
          case 0x30006u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a4 & 3));
            goto LABEL_181;
          case 0x30007u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a4 & 3));
            goto LABEL_181;
          case 0x30008u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a4 != 0.0));
            goto LABEL_181;
          case 0x30009u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a4 & 7) << 6);
            goto LABEL_181;
          case 0x3000Au:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a4 & 3) << 9);
LABEL_181:
            *(_DWORD *)(v7 + 24) = v21;
            break;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146)
          goto LABEL_147;
        if (a2 == 262145)
          goto LABEL_154;
        if (a2 != 0x40000)
          return result;
        goto LABEL_69;
      case 5u:
        if (a2 == 327682)
          goto LABEL_147;
        if (a2 == 327681)
          goto LABEL_154;
        if (a2 != 327680)
          return result;
        goto LABEL_69;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_69;
          case 0x60001u:
            goto LABEL_154;
          case 0x60002u:
            goto LABEL_147;
          case 0x60003u:
LABEL_23:
            v8 = *(_BYTE *)(v7 + 8) & 0xFB | (4 * (a4 != 0.0));
LABEL_168:
            *(_BYTE *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
            goto LABEL_147;
          case 0x70001u:
            goto LABEL_154;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_147:
          v13 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_148;
        }
        if (a2 == 589825)
          goto LABEL_154;
        if (a2 != 589824)
          return result;
        goto LABEL_69;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_147;
                case 0xA0001u:
                  goto LABEL_154;
                case 0xA0000u:
                  goto LABEL_69;
              }
              break;
            case 1:
              if (a2 == 655364)
                goto LABEL_139;
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_147;
                case 0xA0006u:
                  goto LABEL_154;
                case 0xA0005u:
                  goto LABEL_69;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_69;
                case 0xA0009u:
                  goto LABEL_154;
                case 0xA000Au:
                  goto LABEL_147;
                case 0xA000Bu:
                  goto LABEL_95;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_154;
          case 0xB0002u:
            goto LABEL_147;
          case 0xB0003u:
            goto LABEL_171;
          case 0xB0004u:
            goto LABEL_121;
          case 0xB0005u:
            goto LABEL_114;
          case 0xB0006u:
            goto LABEL_128;
          case 0xB0007u:
            goto LABEL_172;
          case 0xB0008u:
LABEL_170:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a4 != 0.0) << 16);
            goto LABEL_217;
          case 0xB0009u:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a4 != 0.0) << 17);
            goto LABEL_217;
          case 0xB000Au:
            goto LABEL_189;
          case 0xB000Bu:
            goto LABEL_190;
          case 0xB000Cu:
            goto LABEL_215;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_186;
                  case 0xB0012u:
                    goto LABEL_187;
                  case 0xB0013u:
                    goto LABEL_196;
                  case 0xB0014u:
                    goto LABEL_197;
                  case 0xB0015u:
LABEL_224:
                    *(_DWORD *)(v7 + 84) = vcvtd_n_s64_f64(a4, 0x10uLL);
                    break;
                  case 0xB001Au:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_186;
                  case 0xB0010u:
                    goto LABEL_187;
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_197;
                  case 0xB0014u:
                    goto LABEL_224;
                  case 0xB0015u:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910)
              goto LABEL_187;
            if (a2 != 720909)
              return result;
            goto LABEL_186;
          case 0xB0016u:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a4 != 0.0));
            goto LABEL_217;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32))
              goto LABEL_215;
            return result;
          case 0xB0018u:
            goto LABEL_169;
          case 0xB0019u:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a4 != 0.0) << 19);
LABEL_217:
            *(_DWORD *)(v7 + 8) = v19;
            return result;
          case 0xB001Bu:
            v23 = a4;
            goto LABEL_219;
          case 0xB001Cu:
            v24 = a4;
            goto LABEL_221;
          case 0xB001Du:
            v25 = a4;
            goto LABEL_223;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_111;
          case 0xC0001u:
            goto LABEL_157;
          case 0xC0002u:
            goto LABEL_87;
          case 0xC0003u:
            goto LABEL_114;
          case 0xC0004u:
            goto LABEL_121;
          case 0xC0005u:
            *(_BYTE *)(v7 + 36) = a4 != 0.0;
            break;
          case 0xC0006u:
            *(_BYTE *)(v7 + 37) = (int)a4;
            break;
          case 0xC0007u:
            goto LABEL_134;
          case 0xC0008u:
            goto LABEL_122;
          case 0xC0009u:
            goto LABEL_123;
          case 0xC000Au:
            goto LABEL_149;
          case 0xC000Bu:
            goto LABEL_150;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_154;
          case 0xD0002u:
            goto LABEL_147;
          case 0xD0003u:
            goto LABEL_114;
          case 0xD0004u:
            goto LABEL_121;
          case 0xD0005u:
            goto LABEL_128;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_113;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507)
                goto LABEL_157;
            }
            else if (a2 == 917505 && !*(_WORD *)(v7 + 18))
            {
              goto LABEL_157;
            }
            break;
          case 0xE0002u:
            goto LABEL_120;
          default:
            return result;
        }
        return result;
      case 0xFu:
        if (a2 != 983040)
          return result;
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_76;
          case 0x100001u:
            goto LABEL_117;
          case 0x100002u:
            goto LABEL_116;
          case 0x100003u:
            goto LABEL_69;
          case 0x100004u:
            goto LABEL_154;
          case 0x100005u:
            goto LABEL_118;
          case 0x100006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_154;
          case 0x110002u:
            goto LABEL_147;
          case 0x110003u:
            goto LABEL_114;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649)
          goto LABEL_154;
        if (a2 != 1179648)
          return result;
        goto LABEL_111;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_69;
          case 0x130001u:
            goto LABEL_154;
          case 0x130002u:
            goto LABEL_147;
          case 0x130003u:
            goto LABEL_160;
          case 0x130004u:
            goto LABEL_116;
          case 0x130005u:
            goto LABEL_162;
          case 0x130006u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_69;
          case 0x140001u:
            goto LABEL_154;
          case 0x140002u:
            goto LABEL_147;
          case 0x140003u:
            goto LABEL_76;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_69;
          case 0x150001u:
            goto LABEL_154;
          case 0x150002u:
            goto LABEL_147;
          case 0x150003u:
            goto LABEL_76;
          case 0x150004u:
LABEL_61:
            v10 = a4;
            goto LABEL_161;
          case 0x150005u:
LABEL_124:
            v15 = a4;
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_76;
          case 0x170001u:
            goto LABEL_117;
          case 0x170002u:
            goto LABEL_116;
          case 0x170003u:
            goto LABEL_69;
          case 0x170004u:
            goto LABEL_154;
          case 0x170005u:
            goto LABEL_118;
          case 0x170006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864)
          goto LABEL_111;
        if (a2 == 1572865)
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a4 != 0.0) << 15);
        return result;
      case 0x19u:
        if (a2 == 1638402)
        {
LABEL_114:
          v12 = a4;
LABEL_115:
          *(_DWORD *)(v7 + 28) = v12;
          return result;
        }
        if (a2 == 1638401)
        {
LABEL_87:
          v13 = a4;
LABEL_148:
          *(_DWORD *)(v7 + 24) = v13;
          return result;
        }
        if (a2 != 1638400)
          return result;
        goto LABEL_69;
      case 0x1Au:
        if (a2 == 1703938)
          goto LABEL_87;
        if (a2 == 1703937)
        {
LABEL_119:
          *(_BYTE *)(v7 + 20) = (int)a4;
          return result;
        }
        if (a2 != 1703936)
          return result;
LABEL_139:
        v11 = a4;
        goto LABEL_140;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_76;
          case 0x1B0001u:
            goto LABEL_117;
          case 0x1B0002u:
            goto LABEL_116;
          case 0x1B0003u:
            goto LABEL_69;
          case 0x1B0004u:
            goto LABEL_154;
          case 0x1B0005u:
            goto LABEL_118;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_76:
            v12 = a4;
            goto LABEL_115;
          case 0x1C0001u:
LABEL_117:
            *(_WORD *)(v7 + 32) = (int)a4;
            break;
          case 0x1C0002u:
            goto LABEL_116;
          case 0x1C0003u:
            goto LABEL_69;
          case 0x1C0004u:
            goto LABEL_154;
          case 0x1C0005u:
LABEL_118:
            *(_WORD *)(v7 + 34) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_139;
          case 0x1D0001u:
            goto LABEL_154;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = (int)a4;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = (int)a4;
            break;
          case 0x1D0004u:
            *(_BYTE *)(v7 + 32) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        if (a2 == 1966082)
          goto LABEL_87;
        if (a2 == 1966081)
          goto LABEL_154;
        if (a2 != 1966080)
          return result;
        goto LABEL_139;
      case 0x1Fu:
        if (a2 == 2031617)
          goto LABEL_157;
        if (a2 != 2031616)
          return result;
        goto LABEL_69;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_111;
          case 0x200001u:
            goto LABEL_154;
          case 0x200002u:
            goto LABEL_87;
          case 0x200003u:
            goto LABEL_95;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689)
          goto LABEL_154;
        if (a2 != 2162688)
          return result;
        goto LABEL_139;
      case 0x22u:
        if (a2 == 2228225)
          goto LABEL_154;
        if (a2 != 2228224)
          return result;
LABEL_111:
        v11 = a4;
        goto LABEL_140;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_111;
          case 0x230001u:
            goto LABEL_154;
          case 0x230002u:
            goto LABEL_147;
          case 0x230003u:
LABEL_95:
            v12 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_115;
          case 0x230004u:
LABEL_160:
            v10 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_161;
          case 0x230005u:
            v18 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_200;
          case 0x230006u:
            v20 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_202;
          case 0x230007u:
LABEL_116:
            v15 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_129;
          case 0x230008u:
LABEL_162:
            v17 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_173;
          case 0x230009u:
LABEL_186:
            *(_DWORD *)(v7 + 68) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Au:
LABEL_196:
            *(_DWORD *)(v7 + 76) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Bu:
LABEL_187:
            *(_DWORD *)(v7 + 72) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Cu:
LABEL_197:
            *(_DWORD *)(v7 + 80) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Du:
LABEL_189:
            *(_DWORD *)(v7 + 52) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Eu:
LABEL_190:
            *(_DWORD *)(v7 + 56) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Fu:
LABEL_215:
            *(_DWORD *)(v7 + 60) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230010u:
            *(_DWORD *)(v7 + 64) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230011u:
            v22 = *(_BYTE *)(v7 + 84) & 0xFE | (a4 != 0.0);
            goto LABEL_206;
          case 0x230012u:
            v22 = *(_BYTE *)(v7 + 84) & 0xFD | (2 * (a4 != 0.0));
LABEL_206:
            *(_BYTE *)(v7 + 84) = v22;
            break;
          case 0x230013u:
LABEL_198:
            *(_DWORD *)(v7 + 88) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230014u:
            v23 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_219:
            *(_DWORD *)(v7 + 92) = v23;
            break;
          case 0x230015u:
            v24 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_221:
            *(_DWORD *)(v7 + 96) = v24;
            break;
          case 0x230016u:
            v25 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_223:
            *(_DWORD *)(v7 + 100) = v25;
            break;
          case 0x230017u:
            *(_DWORD *)(v7 + 104) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230018u:
            *(_DWORD *)(v7 + 108) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
          goto LABEL_157;
        if (a2 != 2359296)
          return result;
        goto LABEL_69;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(_QWORD *)(v7 + 24) = (unint64_t)a4;
            break;
          case 0x260001u:
            goto LABEL_154;
          case 0x260000u:
LABEL_69:
            v11 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_140:
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1)
          return result;
        v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 != 2555906)
            return result;
LABEL_154:
          v16 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_158;
        }
        if (!v14)
        {
          if (a2 != 2555905)
            return result;
          goto LABEL_157;
        }
        if (a2 == 2555905 && v14 == 2)
        {
LABEL_157:
          v16 = a4;
LABEL_158:
          *(_DWORD *)(v7 + 20) = v16;
          return result;
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = (int)a4;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = (int)a4;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = a4;
            break;
          case 0x280003u:
LABEL_130:
            *(_BYTE *)(v7 + 24) = (int)a4;
            break;
          case 0x280004u:
LABEL_131:
            *(_BYTE *)(v7 + 25) = (int)a4;
            break;
          case 0x280005u:
            goto LABEL_114;
          case 0x280006u:
LABEL_121:
            v10 = a4;
LABEL_161:
            *(_DWORD *)(v7 + 32) = v10;
            break;
          case 0x280007u:
LABEL_128:
            v15 = a4;
LABEL_129:
            *(_DWORD *)(v7 + 36) = v15;
            break;
          case 0x280008u:
            *(_BYTE *)(v7 + 44) = (int)a4;
            break;
          case 0x280009u:
LABEL_171:
            v20 = a4;
LABEL_202:
            *(_DWORD *)(v7 + 48) = v20;
            break;
          case 0x28000Au:
            *(_QWORD *)(v7 + 56) = (unint64_t)a4;
            break;
          case 0x28000Bu:
            *(_BYTE *)(v7 + 26) = (int)a4;
            break;
          case 0x28000Cu:
LABEL_172:
            v17 = a4;
LABEL_173:
            *(_DWORD *)(v7 + 40) = v17;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_111;
          case 0x290001u:
            goto LABEL_119;
          case 0x290002u:
            goto LABEL_132;
          case 0x290003u:
            goto LABEL_133;
          case 0x290004u:
LABEL_134:
            *(double *)(v7 + 40) = a4;
            break;
          case 0x290005u:
            goto LABEL_122;
          case 0x290006u:
            goto LABEL_123;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_113:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
          case 0x2A0001u:
LABEL_120:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x2A0002u:
LABEL_132:
            *(double *)(v7 + 24) = a4;
            break;
          case 0x2A0003u:
LABEL_133:
            *(double *)(v7 + 32) = a4;
            break;
          case 0x2A0004u:
            *(_BYTE *)(v7 + 40) = a4 != 0.0;
            break;
          case 0x2A0005u:
LABEL_169:
            v18 = a4;
LABEL_200:
            *(_DWORD *)(v7 + 44) = v18;
            break;
          case 0x2A0006u:
LABEL_122:
            *(double *)(v7 + 48) = a4;
            break;
          case 0x2A0007u:
LABEL_123:
            *(double *)(v7 + 56) = a4;
            break;
          case 0x2A0008u:
LABEL_149:
            *(double *)(v7 + 64) = a4;
            break;
          case 0x2A0009u:
LABEL_150:
            *(double *)(v7 + 72) = a4;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

uint64_t IOPMAllowsBackgroundTask(unsigned int a1)
{
  return (a1 >> 6) & 1;
}

void _IOHIDServiceTerminate(_QWORD *a1)
{
  NSObject *v2;
  _QWORD block[5];

  CFRetain(a1);
  v2 = a1[10];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___IOHIDServiceTerminate_block_invoke;
  block[3] = &__block_descriptor_tmp_13;
  block[4] = a1;
  dispatch_async(v2, block);
}

CFStringRef __IOHIDServiceFilterCopyDebugDescription(_QWORD *a1)
{
  const void *v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  CFStringRef v6;

  v2 = (const void *)a1[12];
  if (v2)
    v3 = CFCopyDescription(v2);
  else
    v3 = 0;
  v4 = CFGetAllocator(a1);
  v5 = &stru_1E2005170;
  if (v3)
    v5 = v3;
  v6 = CFStringCreateWithFormat(v4, 0, CFSTR("IOHIDServiceFilter uuid:%@ name:%@ %@"), a1[11], a1[10], v5);
  if (v3)
    CFRelease(v3);
  return v6;
}

uint64_t __OSKextProcessKextRequestResults(uint64_t a1, uint64_t error_value, uint64_t a3, char *buffer, int a5)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  void *v14;
  CFTypeRef v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  void *UTF8CStringForCFString;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  CFStringRef errorString;

  errorString = 0;
  if ((_DWORD)error_value)
  {
    v6 = error_value;
    v7 = mach_error_string(error_value);
    v13 = "(unknown)";
    if (v7)
      LOBYTE(v13) = (_BYTE)v7;
    OSKextLog(a1, 65, "Error communicating with kernel - %s.", v8, v9, v10, v11, v12, (char)v13);
    v14 = 0;
    goto LABEL_16;
  }
  v16 = 0;
  v14 = 0;
  if (buffer && a5)
  {
    v16 = IOCFUnserialize(buffer, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &errorString);
    if (!v16)
    {
      UTF8CStringForCFString = createUTF8CStringForCFString(errorString);
      v14 = UTF8CStringForCFString;
      v31 = "(unknown)";
      if (UTF8CStringForCFString)
        LOBYTE(v31) = (_BYTE)UTF8CStringForCFString;
      OSKextLog(a1, 65, "Failed to parse kernel log messages: %s.", v26, v27, v28, v29, v30, (char)v31);
      if (!(_DWORD)a3)
        goto LABEL_13;
      goto LABEL_10;
    }
    __OSKextLogKernelMessages(a1, v16);
    v14 = 0;
  }
  if ((_DWORD)a3)
  {
LABEL_10:
    v17 = mach_error_string(a3);
    v23 = "(unknown)";
    if (v17)
      LOBYTE(v23) = (_BYTE)v17;
    OSKextLog(a1, 71, "Kernel error handling kext request - %s.", v18, v19, v20, v21, v22, (char)v23);
  }
LABEL_13:
  if (v16)
    CFRelease(v16);
  v6 = a3;
LABEL_16:
  if (errorString)
    CFRelease(errorString);
  if (v14)
    free(v14);
  return v6;
}

CFTypeRef IOCFUnserialize(const char *buffer, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  const void *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  const void *v11;
  void *v12;
  const void *v13;
  void *v14;
  _QWORD *v15;

  if (errorString)
    *errorString = 0;
  v7 = 0;
  if (buffer && !options)
  {
    v8 = malloc_type_malloc(0x40uLL, 0x10F0040CDBDF800uLL);
    if (v8)
    {
      v9 = v8;
      *v8 = buffer;
      v8[1] = 0x100000000;
      v8[3] = 0;
      v8[4] = 0;
      v8[2] = allocator;
      v8[5] = CFDictionaryCreateMutable(allocator, 0, 0, MEMORY[0x1E0C9B3A0]);
      v9[6] = errorString;
      v9[7] = 0;
      IOCFUnserializeparse();
      v7 = (const void *)v9[7];
      v10 = (_QWORD *)v9[3];
      if (v10)
      {
        do
        {
          v11 = (const void *)v10[3];
          if (v11)
            CFRelease(v11);
          v12 = (void *)v10[6];
          if (v12)
            free(v12);
          v13 = (const void *)v10[4];
          if (v13)
            CFRelease(v13);
          v14 = (void *)v10[7];
          if (v14)
            free(v14);
          v15 = (_QWORD *)v10[1];
          free(v10);
          v10 = v15;
        }
        while (v15);
      }
      CFRelease((CFTypeRef)v9[5]);
      free(v9);
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t IOCFUnserializeparse()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  char *v3;
  char *v4;
  uint64_t *v5;
  int v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  unsigned __int8 *v17;
  int v18;
  int Tag;
  int v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  _BYTE *v24;
  BOOL v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  CFIndex v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  CFIndex v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  CFIndex v42;
  _QWORD *v43;
  _QWORD *v44;
  CFDataRef v45;
  const void *v46;
  CFNumberType v47;
  const void *v48;
  const void *v49;
  const void *Value;
  const void *v51;
  uint64_t v52;
  _QWORD *v53;
  CFMutableDictionaryRef Mutable;
  const void *v55;
  uint64_t **v56;
  uint64_t *v57;
  const void *v58;
  uint64_t **v59;
  uint64_t *v60;
  const void *v61;
  uint64_t **v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  _BOOL4 v69;
  char *v70;
  char *v71;
  _BYTE *String;
  BOOL v73;
  int v74;
  _BYTE *v76;
  BOOL v77;
  int v78;
  _BYTE *v79;
  const char *v80;
  uint64_t v81;
  _QWORD *v83;
  uint64_t v84;
  const void *v85;
  const void *v86;
  uint64_t v87;
  int v88;
  char *v89;
  void *__src;
  int v91;
  unsigned int v92;
  _OWORD v93[100];
  char v94[400];
  char __str[1024];
  char __s1[2];
  _BYTE v97[6];
  _QWORD v98[7];

  v0 = MEMORY[0x1E0C80A78]();
  v87 = 0;
  v1 = 0u;
  v98[4] = *MEMORY[0x1E0C80C00];
  __src = v93;
  v2 = 200;
  memset(v93, 0, 512);
  v85 = (const void *)*MEMORY[0x1E0C9AE50];
  v86 = (const void *)*MEMORY[0x1E0C9AE40];
  v3 = v94;
  v4 = v94;
  v5 = (uint64_t *)v93;
  v6 = -2;
  while (1)
  {
    *(_WORD *)v4 = v1;
    if (&v3[2 * v2 - 2] <= v4)
    {
      if ((unint64_t)v2 >> 4 > 0x270
        || ((unint64_t)(2 * v2) >= 0x2710 ? (v2 = 10000) : (v2 *= 2),
            (v7 = (char *)malloc_type_malloc(10 * v2 + 7, 0x5CF3AA9FuLL)) == 0))
      {
        IOCFUnserializeerror((CFStringRef)v0, (uint64_t)"memory exhausted");
        v81 = 2;
        goto LABEL_205;
      }
      v8 = v7;
      v9 = v4 - v3;
      v10 = v3;
      v11 = v9 >> 1;
      v12 = (v9 >> 1) + 1;
      memcpy(v7, v10, 2 * v12);
      memcpy(&v8[(2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8], __src, 8 * v12);
      if (v10 != v94)
        free(v10);
      if (v2 <= v12)
      {
        v81 = 1;
        v3 = v8;
        goto LABEL_205;
      }
      v4 = &v8[2 * v11];
      v5 = (uint64_t *)&v8[8 * v12 - 8 + ((2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8)];
      v3 = v8;
      __src = &v8[(2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
    if (((0xFEB5FFC3FEuLL >> v1) & 1) == 0)
    {
      v13 = yypact[v1];
      if (v6 != -2)
        goto LABEL_44;
      v92 = 0;
      while (1)
      {
        do
        {
          while (1)
          {
            v14 = *(_DWORD *)(v0 + 8);
            v15 = *(unsigned __int8 *)(*(_QWORD *)v0 + v14);
            if (v15 == 32 || v15 == 9)
            {
              v17 = (unsigned __int8 *)(*(_QWORD *)v0 + v14 + 1);
              do
              {
                do
                {
                  *(_DWORD *)(v0 + 8) = ++v14;
                  v18 = *v17++;
                  v15 = v18;
                }
                while (v18 == 9);
              }
              while (v15 == 32);
              if (!v15)
              {
                v6 = 0u;
                goto LABEL_44;
              }
            }
            if (v15 != 10)
              break;
            v26 = *(_DWORD *)(v0 + 12) + 1;
            *(_DWORD *)(v0 + 8) = v14 + 1;
            *(_DWORD *)(v0 + 12) = v26;
          }
          v6 = (char)v15;
          if (!(_BYTE)v15)
            goto LABEL_44;
          Tag = getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str);
        }
        while (Tag == 4);
        v20 = Tag;
        if (!Tag)
        {
LABEL_184:
          v6 = 267;
          goto LABEL_44;
        }
        v88 = v13;
        newObject(v0);
        v87 = v21;
        *(_DWORD *)(v21 + 72) = -1;
        v84 = v92;
        if ((int)v92 >= 1)
          break;
LABEL_35:
        if (SLOBYTE(v98[0]) != 112)
        {
          v6 = 267;
          v13 = v88;
          switch(LOBYTE(v98[0]))
          {
            case 'a':
              if (LODWORD(v98[0]) == 1634890337 && WORD2(v98[0]) == 121)
              {
                if (v20 != 3)
                {
                  v77 = v20 == 1;
                  v78 = 40;
                  goto LABEL_191;
                }
                *(_QWORD *)(v87 + 16) = 0;
                v6 = 0x102u;
              }
              break;
            case 'b':
            case 'c':
            case 'e':
            case 'g':
            case 'h':
            case 'j':
              goto LABEL_44;
            case 'd':
              if (LODWORD(v98[0]) ^ 0x74636964 | BYTE4(v98[0]))
              {
                if (!(LODWORD(v98[0]) ^ 0x61746164 | BYTE4(v98[0])))
                {
                  v91 = 0;
                  if (v20 == 3)
                  {
                    *(_QWORD *)(v87 + 48) = 0;
                    *(_DWORD *)(v87 + 40) = 0;
                    v6 = 0x104u;
                  }
                  else
                  {
                    *(_QWORD *)(v87 + 48) = getCFEncodedData((uint64_t *)v0, &v91);
                    *(_DWORD *)(v87 + 40) = v91;
                    if (getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) == 2)
                    {
                      if (LODWORD(v98[0]) ^ 0x61746164 | BYTE4(v98[0]))
                        v6 = 267;
                      else
                        v6 = 260;
                    }
                  }
                }
              }
              else if (v20 == 3)
              {
                *(_QWORD *)(v87 + 16) = 0;
                v6 = 0x105u;
              }
              else if (v20 == 1)
              {
                v6 = 123;
              }
              else
              {
                v6 = 125;
              }
              break;
            case 'f':
              v69 = LODWORD(v98[0]) != 1936482662 || WORD2(v98[0]) != 101;
              if (v20 == 3 && !v69)
              {
                *(_QWORD *)(v87 + 64) = 0;
                goto LABEL_152;
              }
              break;
            case 'i':
              if (v98[0] == 0x72656765746E69)
              {
                *(_DWORD *)(v87 + 40) = 64;
                if ((int)v84 >= 1)
                {
                  v70 = __str;
                  v71 = __s1;
                  do
                  {
                    if (!strcmp(v71, "size"))
                      *(_DWORD *)(v87 + 40) = strtoul(v70, 0, 0);
                    v70 += 32;
                    v71 += 32;
                    --v84;
                  }
                  while (v84);
                }
                if (v20 != 3)
                {
                  *(_QWORD *)(v87 + 64) = getNumber((uint64_t *)v0);
                  if (getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) != 2)
                    goto LABEL_184;
                  v73 = v98[0] == 0x72656765746E69;
                  v74 = 264;
                  goto LABEL_181;
                }
                *(_QWORD *)(v87 + 64) = 0;
                v6 = 0x108u;
              }
              break;
            case 'k':
              if (v20 != 3 && LODWORD(v98[0]) == 7955819)
              {
                String = getString((uint64_t *)v0);
                *(_QWORD *)(v87 + 56) = String;
                if (String)
                {
                  if (getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) == 2)
                  {
                    v73 = LODWORD(v98[0]) == 7955819;
                    v74 = 263;
LABEL_181:
                    if (v73)
                      v6 = v74;
                    else
                      v6 = 267;
                  }
                }
              }
              break;
            default:
              if (SLOBYTE(v98[0]) == 115)
              {
                if (LODWORD(v98[0]) == 1769108595 && *(_DWORD *)((char *)v98 + 3) == 6778473)
                {
                  if (v20 == 3)
                  {
                    v76 = malloc_type_malloc(1uLL, 0xC339ED7CuLL);
                    *(_QWORD *)(v87 + 56) = v76;
                    *v76 = 0;
                    v6 = 0x10Au;
                  }
                  else
                  {
                    v79 = getString((uint64_t *)v0);
                    *(_QWORD *)(v87 + 56) = v79;
                    if (v79 && getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) == 2)
                    {
                      v77 = (LODWORD(v98[0]) ^ 0x69727473 | *(_DWORD *)((char *)v98 + 3) ^ 0x676E69) == 0;
                      v78 = 266;
LABEL_191:
                      if (v77)
                        v6 = v78;
                      else
                        v6 = v78 + 1;
                    }
                  }
                }
                else if (LODWORD(v98[0]) == 7628147)
                {
                  if (v20 == 1)
                  {
                    v6 = 0x5Bu;
                  }
                  else if (v20 == 3)
                  {
                    *(_QWORD *)(v87 + 16) = 0;
                    v6 = 0x109u;
                  }
                  else
                  {
                    v6 = 0x5Du;
                  }
                }
              }
              else if (SLOBYTE(v98[0]) == 116 && v20 == 3 && !(LODWORD(v98[0]) ^ 0x65757274 | BYTE4(v98[0])))
              {
                *(_QWORD *)(v87 + 64) = 1;
LABEL_152:
                v6 = 0x103u;
              }
              break;
          }
          goto LABEL_44;
        }
        v25 = LODWORD(v98[0]) == 1936288880 && WORD2(v98[0]) == 116;
        v13 = v88;
        if (!v25)
          goto LABEL_184;
        *(_QWORD *)v87 = *(_QWORD *)(v0 + 32);
        *(_QWORD *)(v0 + 32) = v87;
      }
      v22 = __str;
      v23 = v92;
      v24 = v97;
      while (1)
      {
        if (*(v24 - 2) != 73 || *(v24 - 1) != 68)
          goto LABEL_34;
        if (*v24)
          break;
        *(_DWORD *)(v87 + 72) = strtol(v22, 0, 0);
LABEL_34:
        v22 += 32;
        v24 += 32;
        if (!--v23)
          goto LABEL_35;
      }
      if (*v24 == 82 && v24[1] == 69 && v24[2] == 70)
      {
        v6 = 267;
        if (v20 == 3 && !v24[3])
        {
          *(_DWORD *)(v87 + 72) = strtol(v22, 0, 0);
          v6 = 0x106u;
        }
      }
      else
      {
        v6 = 0x10Bu;
      }
      v13 = v88;
LABEL_44:
      if (v6 < 1)
      {
        v27 = 0;
        v6 = 0;
      }
      else
      {
        v27 = v6 > 0x10B ? 2 : yytranslate[v6];
      }
      v28 = (v27 + v13);
      if (v28 <= 0x6C && v27 == yycheck[v28])
        break;
    }
    v29 = v1;
    if (((0x14A003C00uLL >> v1) & 1) != 0)
      goto LABEL_201;
    v30 = yydefact[v1];
    v31 = yyr2[yydefact[v29]];
    v32 = v5[1 - v31];
    switch((int)v30)
    {
      case 2:
        v80 = "unexpected end of buffer";
        goto LABEL_202;
      case 3:
        v81 = 0;
        *(_QWORD *)(v0 + 56) = *(_QWORD *)(*v5 + 24);
        *(_QWORD *)(*v5 + 24) = 0;
        v83 = (_QWORD *)*v5;
        *v83 = *(_QWORD *)(v0 + 32);
        *(_QWORD *)(v0 + 32) = v83;
        goto LABEL_205;
      case 4:
        goto LABEL_201;
      case 5:
        v32 = *v5;
        v33 = *(_QWORD **)(*v5 + 16);
        if (v33)
        {
          v34 = 0;
          v35 = 0;
          do
          {
            v36 = v33;
            v33 = (_QWORD *)*v33;
            *v36 = v35;
            ++v34;
            v35 = v36;
          }
          while (v33);
        }
        else
        {
          v36 = 0;
          v34 = 0;
        }
        v89 = v3;
        *(_QWORD *)(v32 + 16) = v36;
        Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(v0 + 16), v34, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v55 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v55 & 0x80000000) == 0)
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v55, Mutable);
        v56 = *(uint64_t ***)(v32 + 16);
        if (v56)
        {
          do
          {
            CFDictionarySetValue(Mutable, v56[4], v56[3]);
            CFRelease(v56[4]);
            CFRelease(v56[3]);
            v56[3] = 0;
            v56[4] = 0;
            v57 = *v56;
            *v56 = *(uint64_t **)(v0 + 32);
            *(_QWORD *)(v0 + 32) = v56;
            v56 = (uint64_t **)v57;
          }
          while (v57);
        }
        goto LABEL_112;
      case 6:
        v32 = *v5;
        v37 = *(_QWORD **)(*v5 + 16);
        if (v37)
        {
          v38 = 0;
          v39 = 0;
          do
          {
            v40 = v37;
            v37 = (_QWORD *)*v37;
            *v40 = v39;
            ++v38;
            v39 = v40;
          }
          while (v37);
        }
        else
        {
          v40 = 0;
          v38 = 0;
        }
        v89 = v3;
        *(_QWORD *)(v32 + 16) = v40;
        Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v0 + 16), v38, MEMORY[0x1E0C9B378]);
        v58 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v58 & 0x80000000) == 0)
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v58, Mutable);
        v59 = *(uint64_t ***)(v32 + 16);
        if (v59)
        {
          do
          {
            CFArrayAppendValue(Mutable, v59[3]);
            CFRelease(v59[3]);
            v59[3] = 0;
            v60 = *v59;
            *v59 = *(uint64_t **)(v0 + 32);
            *(_QWORD *)(v0 + 32) = v59;
            v59 = (uint64_t **)v60;
          }
          while (v60);
        }
        goto LABEL_112;
      case 7:
        v32 = *v5;
        v41 = *(_QWORD **)(*v5 + 16);
        if (v41)
        {
          v42 = 0;
          v43 = 0;
          do
          {
            v44 = v41;
            v41 = (_QWORD *)*v41;
            *v44 = v43;
            ++v42;
            v43 = v44;
          }
          while (v41);
        }
        else
        {
          v44 = 0;
          v42 = 0;
        }
        v89 = v3;
        *(_QWORD *)(v32 + 16) = v44;
        Mutable = CFSetCreateMutable(*(CFAllocatorRef *)(v0 + 16), v42, MEMORY[0x1E0C9B3B0]);
        v61 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v61 & 0x80000000) == 0)
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v61, Mutable);
        v62 = *(uint64_t ***)(v32 + 16);
        if (v62)
        {
          do
          {
            CFSetAddValue(Mutable, v62[3]);
            CFRelease(v62[3]);
            v62[3] = 0;
            v63 = *v62;
            *v62 = *(uint64_t **)(v0 + 32);
            *(_QWORD *)(v0 + 32) = v62;
            v62 = (uint64_t **)v63;
          }
          while (v63);
        }
LABEL_112:
        *(_QWORD *)(v32 + 24) = Mutable;
        v3 = v89;
        goto LABEL_113;
      case 8:
      case 19:
        v32 = *v5;
        buildString(v0, *v5);
        goto LABEL_113;
      case 9:
        v32 = *v5;
        v45 = CFDataCreate(*(CFAllocatorRef *)(v0 + 16), *(const UInt8 **)(*v5 + 48), *(int *)(*v5 + 40));
        v46 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v46 & 0x80000000) == 0)
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v46, v45);
        if (*(_DWORD *)(v32 + 40))
          free(*(void **)(v32 + 48));
        *(_QWORD *)(v32 + 48) = 0;
        goto LABEL_85;
      case 10:
        v32 = *v5;
        if (*(int *)(*v5 + 40) < 33)
          v47 = kCFNumberSInt32Type;
        else
          v47 = kCFNumberSInt64Type;
        v45 = CFNumberCreate(*(CFAllocatorRef *)(v0 + 16), v47, (const void *)(*v5 + 64));
        v48 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v48 & 0x80000000) == 0)
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v48, v45);
LABEL_85:
        *(_QWORD *)(v32 + 24) = v45;
        goto LABEL_113;
      case 11:
        v32 = *v5;
        if (*(_QWORD *)(*v5 + 64))
          v49 = v85;
        else
          v49 = v86;
        *(_QWORD *)(v32 + 24) = CFRetain(v49);
        goto LABEL_113;
      case 12:
        Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v0 + 40), (const void *)*(int *)(*v5 + 72));
        if (!Value)
        {
          v80 = "forward reference detected";
          goto LABEL_202;
        }
        v51 = Value;
        newObject(v0);
        v32 = v52;
        *(_QWORD *)(v52 + 24) = v51;
        CFRetain(v51);
LABEL_93:
        v53 = (_QWORD *)*v5;
        *v53 = *(_QWORD *)(v0 + 32);
        *(_QWORD *)(v0 + 32) = v53;
LABEL_113:
        v64 = &v5[-v31];
        v4 -= 2 * v31;
        v64[1] = v32;
        v5 = v64 + 1;
        v65 = yyr1[v30] - 19;
        v66 = (*(__int16 *)v4 + yypgoto[v65]);
        if (v66 <= 0x6C && *(unsigned __int16 *)v4 == (unsigned __int16)yycheck[v66])
          v1 = yytable[v66];
        else
          v1 = yydefgoto[v65];
LABEL_117:
        v4 += 2;
        break;
      case 13:
      case 20:
      case 23:
        v32 = *(v5 - 1);
        *(_QWORD *)(v32 + 16) = 0;
        goto LABEL_113;
      case 14:
      case 21:
      case 24:
        v32 = *(v5 - 2);
        *(_QWORD *)(v32 + 16) = *(v5 - 1);
        goto LABEL_113;
      case 17:
      case 27:
        v32 = *v5;
        *(_QWORD *)*v5 = *(v5 - 1);
        goto LABEL_113;
      case 18:
        v32 = *(v5 - 1);
        *(_QWORD *)(v32 + 32) = *(_QWORD *)(v32 + 24);
        *(_QWORD *)(v32 + 24) = *(_QWORD *)(*v5 + 24);
        *(_QWORD *)v32 = 0;
        *(_QWORD *)(*v5 + 24) = 0;
        goto LABEL_93;
      case 26:
        v32 = *v5;
        *(_QWORD *)*v5 = 0;
        goto LABEL_113;
      default:
        goto LABEL_113;
    }
  }
  v1 = yytable[v28];
  if (!yytable[v28])
  {
LABEL_201:
    v80 = "syntax error";
LABEL_202:
    IOCFUnserializeerror((CFStringRef)v0, (uint64_t)v80);
    v81 = 1;
    goto LABEL_205;
  }
  if ((_DWORD)v28 != 10)
  {
    if (v6)
      v6 = -2;
    else
      v6 = 0;
    v5[1] = v87;
    ++v5;
    goto LABEL_117;
  }
  v81 = 0;
LABEL_205:
  if (v3 != v94)
    free(v3);
  return v81;
}

uint64_t getTag(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;
  uint64_t v24;
  char v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v5 = 0;
  v6 = *(_QWORD *)a1;
  v7 = *(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 8));
  *a3 = 0;
  if (v7 != 60)
    return v5;
  v8 = *(int *)(a1 + 8);
  LODWORD(v9) = v8 + 1;
  *(_DWORD *)(a1 + 8) = v8 + 1;
  LODWORD(v10) = *(unsigned __int8 *)(v6 + v8 + 1);
  switch((_DWORD)v10)
  {
    case '!':
      *(_DWORD *)(a1 + 8) = v8 + 2;
      v14 = *(char *)(v6 + v8 + 2);
      if (v14 == 45)
      {
        LODWORD(v15) = v8 + 3;
        *(_DWORD *)(a1 + 8) = v8 + 3;
        v16 = *(char *)(v6 + v8 + 3);
        v17 = v16 == 45;
        if (v16)
          v14 = v16;
        else
          v14 = 0;
        if (!v16)
          v17 = 0;
      }
      else
      {
        LODWORD(v15) = v8 + 2;
        v17 = 0;
      }
      v5 = 0;
      v23 = ((v14 - 91) < 0xFFFFFFE6) & ~v17;
      if ((v14 - 123) >= 0xFFFFFFE6)
        v23 = 0;
      if ((v23 & 1) != 0 || !v14)
        return v5;
      while (1)
      {
        v24 = (int)v15;
        v15 = (int)v15 + 1;
        *(_DWORD *)(a1 + 8) = v15;
        v5 = *(unsigned __int8 *)(v6 + v15);
        if ((_DWORD)v5 == 10)
          break;
        if (!*(_BYTE *)(v6 + v15))
          return v5;
        if ((v17 & 1) != 0)
        {
          if ((_DWORD)v5 != 45)
            goto LABEL_45;
          LODWORD(v15) = v24 + 2;
          *(_DWORD *)(a1 + 8) = v24 + 2;
          v5 = *(char *)(v6 + v24 + 2);
          if ((_DWORD)v5 == 45)
          {
            LODWORD(v15) = v24 + 3;
            *(_DWORD *)(a1 + 8) = v24 + 3;
            LODWORD(v5) = *(unsigned __int8 *)(v6 + v24 + 3);
            goto LABEL_42;
          }
LABEL_46:
          if (!(_DWORD)v5)
            return v5;
        }
        else
        {
LABEL_42:
          if ((_DWORD)v5 == 62)
          {
            v13 = v15 + 1;
            goto LABEL_12;
          }
LABEL_49:
          if ((_DWORD)v5)
            v25 = v17;
          else
            v25 = 1;
          if ((v25 & 1) != 0)
            return 0;
        }
      }
      ++*(_DWORD *)(a1 + 12);
      if ((v17 & 1) == 0)
      {
        LODWORD(v5) = 10;
        goto LABEL_49;
      }
LABEL_45:
      v5 = 1;
      goto LABEL_46;
    case '/':
      *(_DWORD *)(a1 + 8) = v8 + 2;
      LOBYTE(v10) = *(_BYTE *)(v6 + v8 + 2);
      v18 = 2;
      break;
    case '?':
      do
      {
        while (1)
        {
          while (1)
          {
            v11 = (int)v9;
            v9 = (int)v9 + 1;
            *(_DWORD *)(a1 + 8) = v9;
            v12 = *(unsigned __int8 *)(v6 + v9);
            if (v12 != 10)
              break;
            ++*(_DWORD *)(a1 + 12);
          }
          if (v12 == 63)
            break;
          if (!*(_BYTE *)(v6 + v9))
            return 0;
        }
        LODWORD(v9) = v11 + 2;
        *(_DWORD *)(a1 + 8) = v11 + 2;
      }
      while (*(_BYTE *)(v6 + v11 + 2) != 62);
      v13 = v11 + 3;
LABEL_12:
      v5 = 4;
LABEL_13:
      *(_DWORD *)(a1 + 8) = v13;
      return v5;
    default:
      v18 = 1;
      break;
  }
  if (((v10 & 0xDF) - 65) > 0x19u)
    return 0;
  v19 = 0;
  while (((v10 & 0xDF) - 65) < 0x1Au
       || v10 == 45
       || (v10 - 48) <= 9u)
  {
    *(_BYTE *)(a2 + v19) = v10;
    v20 = v19 + 1;
    v21 = *(_QWORD *)a1;
    v10 = *(int *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v10;
    LOBYTE(v10) = *(_BYTE *)(v21 + v10);
    v19 = v20;
    if (v20 == 31)
      return 0;
  }
  *(_BYTE *)(a2 + v19) = 0;
  do
  {
    if (v10 == 47)
    {
      v45 = *(_QWORD *)a1;
      v46 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v46;
      if (*(_BYTE *)(v45 + v46) == 62)
      {
        v18 = 3;
LABEL_87:
        v13 = v46 + 1;
        v5 = v18;
        goto LABEL_13;
      }
      return 0;
    }
    if (v10 == 62)
    {
      LODWORD(v46) = *(_DWORD *)(a1 + 8);
      goto LABEL_87;
    }
    while (1)
    {
      if (v10 != 9)
      {
        v26 = (char)v10;
        if ((char)v10 != 32)
          break;
      }
      v27 = *(_QWORD *)a1;
      v10 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v10;
      LOBYTE(v10) = *(_BYTE *)(v27 + v10);
    }
    v28 = 0;
    while (1)
    {
      if ((v26 & 0xFFFFFFDF) - 65 <= 0x19)
      {
        v29 = *a3;
        goto LABEL_65;
      }
      v29 = *a3;
      if (v26 != 45 && (v26 - 48) > 9)
        break;
LABEL_65:
      *(_BYTE *)(a4 + 32 * v29 + v28) = v26;
      if (v28 == 30)
        return 0;
      ++v28;
      v30 = *(_QWORD *)a1;
      v31 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v31;
      v26 = *(char *)(v30 + v31);
    }
    *(_BYTE *)(a4 + 32 * v29 + v28) = 0;
    while (v26 == 9 || v26 == 32)
    {
      v32 = *(_QWORD *)a1;
      v33 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v33;
      v26 = *(char *)(v32 + v33);
    }
    if (v26 != 61)
      return 0;
    v34 = *(_QWORD *)a1;
    v35 = *(int *)(a1 + 8);
    v36 = v35 + 2;
    v37 = (unsigned __int8 *)(*(_QWORD *)a1 + v35 + 1);
    while (1)
    {
      *(_DWORD *)(a1 + 8) = v36 - 1;
      v39 = *v37++;
      v38 = v39;
      if (v39 != 9 && v38 != 32)
        break;
      ++v36;
    }
    if (v38 != 34)
      return 0;
    *(_DWORD *)(a1 + 8) = v36;
    v40 = *(unsigned __int8 *)(v34 + v36);
    if (v40 != 34)
    {
      v41 = 0;
      while (1)
      {
        *(_BYTE *)(a5 + 32 * *a3 + v41) = v40;
        if (v41 == 30)
          return 0;
        ++v41;
        v42 = *(_QWORD *)a1;
        v43 = *(int *)(a1 + 8) + 1;
        *(_DWORD *)(a1 + 8) = v43;
        v40 = *(unsigned __int8 *)(v42 + v43);
        if (v40 == 34)
          goto LABEL_82;
      }
    }
    LODWORD(v41) = 0;
LABEL_82:
    v5 = 0;
    *(_BYTE *)(a5 + 32 * *a3 + v41) = 0;
    v10 = *(_QWORD *)a1;
    v44 = *(int *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v44;
    LOBYTE(v10) = *(_BYTE *)(v10 + v44);
    LODWORD(v44) = (*a3)++;
  }
  while ((int)v44 <= 30);
  return v5;
}

double newObject(uint64_t a1)
{
  _QWORD *v2;
  _OWORD *v3;
  double result;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = *v2;
  }
  else
  {
    v3 = malloc_type_malloc(0x50uLL, 0x10F00409B684ADEuLL);
    result = 0.0;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 1) = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v3;
  }
  return result;
}

_BYTE *getString(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  _BYTE *result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  v2 = 0;
  v3 = *((int *)a1 + 2);
  v4 = *a1 + v3;
  while (1)
  {
    v5 = *(unsigned __int8 *)(v4 + v2);
    if (v5 == 10)
    {
      ++*((_DWORD *)a1 + 3);
      goto LABEL_7;
    }
    if (!*(_BYTE *)(v4 + v2))
      return 0;
    if (v5 == 60)
      break;
LABEL_7:
    *((_DWORD *)a1 + 2) = v3 + 1 + v2++;
  }
  result = malloc_type_malloc((int)v2 + 1, 0xEA361A35uLL);
  if (!result)
  {
    puts("IOCFUnserialize: can't alloc temp memory");
    return 0;
  }
  if ((int)v2 < 1)
  {
    v17 = 0;
LABEL_34:
    result[v17] = 0;
    return result;
  }
  v7 = 0;
  LODWORD(v8) = 0;
  v9 = v3 + 3;
  v10 = result;
  while (2)
  {
    v11 = *a1;
    v12 = (int)v8;
    v13 = (int)v8 + 1;
    v14 = *(unsigned __int8 *)(*a1 + v3 + (int)v8);
    if (v14 != 38)
    {
      LODWORD(v8) = v8 + 1;
      goto LABEL_28;
    }
    v8 = (int)v8 + 4;
    if ((int)v12 + 4 > (int)v2)
      break;
    v15 = v12 + 2;
    v16 = *(unsigned __int8 *)(v11 + v13 + v3);
    if (v16 != 103)
    {
      if (v16 == 108)
      {
        if (*(_BYTE *)(v11 + v15 + v3) != 116 || *(_BYTE *)(v11 + v9 + (int)v12) != 59)
          break;
        LOBYTE(v14) = 60;
      }
      else
      {
        if ((int)v12 + 5 > (int)v2
          || v16 != 97
          || *(_BYTE *)(v11 + v3 + (int)v15) != 109
          || *(_BYTE *)(v11 + v9 + (int)v12) != 112
          || *(_BYTE *)(v11 + v8 + v3) != 59)
        {
          break;
        }
        LOBYTE(v14) = 38;
        LODWORD(v8) = v12 + 5;
      }
      goto LABEL_28;
    }
    if (*(_BYTE *)(v11 + v3 + (int)v15) == 116 && *(_BYTE *)(v11 + v9 + (int)v12) == 59)
    {
      LOBYTE(v14) = 62;
LABEL_28:
      *v10++ = v14;
      v7 += 0x100000000;
      if ((int)v8 >= (int)v2)
      {
        v17 = v7 >> 32;
        goto LABEL_34;
      }
      continue;
    }
    break;
  }
  free(result);
  return 0;
}

uint64_t buildString(uint64_t a1, uint64_t a2)
{
  CFStringRef v4;
  const void *v5;

  v4 = CFStringCreateWithCString(*(CFAllocatorRef *)(a1 + 16), *(const char **)(a2 + 56), 0x8000100u);
  if (!v4)
  {
    syslog(3, "FIXME: IOUnserialize has detected a string that is not valid UTF-8, \"%s\".", *(const char **)(a2 + 56));
    v4 = CFStringCreateWithCString(*(CFAllocatorRef *)(a1 + 16), *(const char **)(a2 + 56), 0);
  }
  v5 = (const void *)*(unsigned int *)(a2 + 72);
  if ((v5 & 0x80000000) == 0)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v5, v4);
  free(*(void **)(a2 + 56));
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 24) = v4;
  return a2;
}

uint64_t getNumber(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  int v10;
  char *v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  char v16;
  unsigned int v17;
  uint64_t v18;
  char *v19;
  int v20;
  unsigned int v21;

  v1 = *a1;
  v2 = *((_DWORD *)a1 + 2);
  v3 = *(unsigned __int8 *)(*a1 + v2);
  if (v3 != 48)
  {
    LODWORD(v4) = *((_DWORD *)a1 + 2);
    goto LABEL_18;
  }
  v4 = v2 + 1;
  *((_DWORD *)a1 + 2) = v4;
  v3 = *(unsigned __int8 *)(v1 + v4);
  if (v3 != 120)
  {
LABEL_18:
    if (v3 == 45)
    {
      v4 = (int)v4 + 1;
      *((_DWORD *)a1 + 2) = v4;
      v16 = *(_BYTE *)(v1 + v4);
    }
    else
    {
      v16 = v3;
    }
    v17 = v16;
    if ((v16 - 48) > 9)
    {
      v18 = 0;
    }
    else
    {
      v18 = 0;
      v19 = (char *)(v1 + (int)v4 + 1);
      v20 = v4 + 1;
      do
      {
        v18 = 10 * v18 + v17 - 48;
        *((_DWORD *)a1 + 2) = v20;
        v21 = *v19++;
        v17 = v21;
        ++v20;
      }
      while (v21 - 48 < 0xA);
    }
    if (v3 == 45)
      return -v18;
    else
      return v18;
  }
  v5 = v2 + 2;
  *((_DWORD *)a1 + 2) = v2 + 2;
  v6 = *(char *)(v1 + v5);
  v7 = v6 - 48 < 0xA;
  v8 = 0;
  if (v6 - 48 < 0xA || v6 - 97 <= 5)
  {
    v10 = v2 + 3;
    v11 = (char *)(v5 + v1 + 1);
    do
    {
      if (v7)
        v12 = -48;
      else
        v12 = -87;
      v8 = v12 + 16 * v8 + v6;
      *((_DWORD *)a1 + 2) = v10;
      v13 = *v11++;
      v6 = v13;
      v14 = v13 - 97;
      v7 = v13 - 48 < 0xA;
      ++v10;
    }
    while (v13 - 48 < 0xA || v14 < 6);
  }
  return v8;
}

void *getCFEncodedData(uint64_t *a1, _DWORD *a2)
{
  void *result;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  result = malloc_type_malloc(0x1000uLL, 0x1D99E107uLL);
  v5 = *a1;
  v6 = *(unsigned __int8 *)(*a1 + *((int *)a1 + 2));
  *a2 = 0;
  if (v6 == 60)
    goto LABEL_22;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  do
  {
    v12 = v6 & 0x7F;
    switch((_DWORD)v12)
    {
      case 0xA:
        v11 = 0;
        ++*((_DWORD *)a1 + 3);
        break;
      case 0x3D:
        ++v11;
        break;
      case 0:
        goto LABEL_22;
      default:
        v11 = 0;
        break;
    }
    v13 = __CFPLDataDecodeTable[v12];
    if ((v13 & 0x80000000) == 0)
    {
      ++v9;
      v10 = v13 + (v10 << 6);
      if ((v9 & 3) == 0)
      {
        v15 = v8 + 2;
        if (v7 <= (int)v15)
        {
          v7 += 4096;
          result = malloc_type_realloc(result, v7, 0x4A6B3F2BuLL);
        }
        *((_BYTE *)result + v8) = BYTE2(v10);
        if (v11 > 1)
        {
          ++v8;
        }
        else
        {
          *((_BYTE *)result + v8 + 1) = BYTE1(v10);
          if (v11 == 1)
          {
            v8 += 2;
          }
          else
          {
            v8 += 3;
            *((_BYTE *)result + v15) = v10;
          }
        }
      }
      v5 = *a1;
    }
    v14 = *((int *)a1 + 2) + 1;
    *((_DWORD *)a1 + 2) = v14;
    v6 = *(unsigned __int8 *)(v5 + v14);
  }
  while (v6 != 60);
  *a2 = v8;
  if (!v8)
  {
LABEL_22:
    free(result);
    return 0;
  }
  return result;
}

void __OSKextLogKernelMessages(int a1, CFTypeRef cf)
{
  CFTypeID v4;
  const void *ValueAtIndex;
  const void *v6;
  CFTypeID v7;
  CFTypeID v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  CFIndex i;
  const __CFNumber *v13;
  const __CFString *v14;
  const char *UTF8CStringForCFString;
  char *v16;
  int valuePtr;

  if (__sOSKextLogOutputFunction)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)cf) == 2)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, 0);
      v6 = CFArrayGetValueAtIndex((CFArrayRef)cf, 1);
      v7 = CFGetTypeID(ValueAtIndex);
      if (v7 == CFArrayGetTypeID())
      {
        v8 = CFGetTypeID(v6);
        if (v8 == CFArrayGetTypeID())
        {
          Count = CFArrayGetCount((CFArrayRef)ValueAtIndex);
          if (Count == CFArrayGetCount((CFArrayRef)v6))
          {
            v10 = CFArrayGetCount((CFArrayRef)v6);
            if (v10 >= 1)
            {
              v11 = v10;
              for (i = 0; i != v11; ++i)
              {
                v13 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, i);
                valuePtr = 0;
                v14 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v6, i);
                if (CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr))
                {
                  UTF8CStringForCFString = (const char *)createUTF8CStringForCFString(v14);
                  if (UTF8CStringForCFString)
                  {
                    v16 = (char *)UTF8CStringForCFString;
                    __sOSKextLogOutputFunction(a1, valuePtr, "(kernel) %s", UTF8CStringForCFString);
                    free(v16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

CFArrayRef IOPSCopyPowerSourcesList(CFTypeRef blob)
{
  CFTypeID TypeID;

  TypeID = CFArrayGetTypeID();
  if (blob && CFGetTypeID(blob) == TypeID)
    return CFArrayCreateCopy(0, (CFArrayRef)blob);
  else
    return 0;
}

CFTypeRef IOPSCopyPowerSourcesInfo(void)
{
  return IOPSCopyPowerSourcesByType(3);
}

uint64_t __FilterFunctionOpen(uint64_t a1)
{
  return IOHIDServiceFilterOpen(a1);
}

void __FilterFunctionOpen_0(const void *a1, uint64_t a2)
{
  __CFArray **v4;
  __CFArray *v5;

  if (IOHIDSessionFilterOpen((uint64_t)a1))
  {
    v4 = *(__CFArray ***)(a2 + 8);
    if (v4)
    {
      v5 = *v4;
      if (*v4
        || (**(_QWORD **)(a2 + 8) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]),
            (v5 = **(__CFArray ***)(a2 + 8)) != 0))
      {
        CFArrayAppendValue(v5, a1);
      }
    }
  }
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  kern_return_t result;

  result = io_registry_entry_get_registry_entry_id(entry);
  if (result)
    *entryID = 0;
  return result;
}

uint64_t io_registry_entry_get_registry_entry_id(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v7 = 0;
  v9 = 0;
  v8 = 0;
  *(_QWORD *)&v5.msgh_bits = 0x1800001513;
  *(_QWORD *)&v5.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v5.msgh_voucher_port = 0xB3700000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t IOHIDEventSystemClientCancel(uint64_t result)
{
  BOOL v1;
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  mach_port_t v6;

  if (*(_QWORD *)(result + 400))
    v1 = *(_QWORD *)(result + 384) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
  }
  v2 = result;
  v3 = (unsigned int *)(result + 312);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 2, v3));
  if ((v4 & 2) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    dispatch_mach_cancel();
    dispatch_mach_cancel();
    v5 = *(_QWORD *)(v2 + 40);
    if (v5)
      IOMIGMachPortUnscheduleFromDispatchQueue(v5, *(_QWORD *)(v2 + 400));
    v6 = *(_DWORD *)(v2 + 32);
    if (v6)
      io_hideventsystem_queue_stop(v6);
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

void IOMIGMachPortUnscheduleFromDispatchQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  BOOL v4;

  if (a2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
      v4 = v3 == a2;
    else
      v4 = 0;
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = 0;
      if (*(_QWORD *)(a1 + 40))
      {
        dispatch_mach_cancel();
        dispatch_release(*(dispatch_object_t *)(a1 + 40));
        *(_QWORD *)(a1 + 40) = 0;
      }
    }
  }
}

uint64_t io_hideventsystem_queue_stop(mach_port_t a1)
{
  uint64_t v1;
  mach_msg_header_t msg;

  msg.msgh_size = 0;
  msg.msgh_bits = 19;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = 0;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1118100000000;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set(&msg);
  v1 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
  if ((v1 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    mach_msg_destroy(&msg);
  }
  return v1;
}

uint64_t _Xio_hideventsystem_copy_property(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = _io_hideventsystem_copy_property(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52), (int *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(_QWORD *)(a2 + 44) = *MEMORY[0x1E0C804E8];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _io_hideventsystem_copy_property(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, _DWORD *a5, int *a6)
{
  mach_vm_size_t v11;
  CFTypeID TypeID;
  const void *v13;
  const void *v14;
  _QWORD *v15;
  _QWORD *v16;
  CFTypeID v17;
  uint64_t System;
  uint64_t v19;
  __CFArray *v20;
  __CFArray *v21;
  int v22;
  const void *v23;

  *a5 = 0;
  v11 = a3;
  TypeID = CFStringGetTypeID();
  v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a2, v11, TypeID);
  if (v13)
  {
    v14 = v13;
    v15 = IOMIGMachPortCacheCopy(a1);
    if (v15)
    {
      v16 = v15;
      v17 = CFGetTypeID(v15);
      if (v17 == IOHIDEventSystemConnectionGetTypeID()
        && (System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v16), a4)
        && ((v19 = System, IOHIDEventSystemConnectionGetType((uint64_t)v16) != 4)
         || CFSetContainsValue((CFSetRef)__whiteListSet, v14)))
      {
        v20 = _IOHIDEventSystemCopyPropertyForConnection(v19, v14, v16);
        if (v20)
        {
          v21 = v20;
          *a5 = _IOHIDSerialize(v20, a4);
          CFRelease(v21);
        }
        v22 = 0;
      }
      else
      {
        v22 = -536870206;
      }
      *a6 = v22;
      CFRelease(v14);
      v23 = v16;
    }
    else
    {
      *a6 = -536870206;
      v23 = v14;
    }
    CFRelease(v23);
  }
  else
  {
    *a6 = -536870206;
  }
  return 0;
}

__CFArray *_IOHIDSessionCopyPropertyForClient(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v5;
  const __CFAllocator *v6;
  CFNumberRef v7;
  const __CFAllocator *v8;
  CFNumberRef v9;
  uint64_t v10;
  const __CFAllocator *v11;
  CFNumberRef v12;
  CFDictionaryRef *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  const __CFAllocator *v16;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  const CFDictionaryValueCallBacks *v22;
  _DWORD *ValueAtIndex;
  uint64_t v24;
  __CFDictionary *v25;
  __CFDictionary *v26;
  CFMutableDictionaryRef v27;
  __CFDictionary *v28;
  const void *RegistryID;
  NSObject *v30;
  const __CFArray *v31;
  uint64_t v32;
  uint64_t i;
  const __CFArray *v35;
  BOOL v36;
  __CFDictionary *v37;
  CFIndex v38;
  CFIndex v39;
  CFIndex v40;
  const void *v41;
  const void *v42;
  CFMutableDictionaryRef v43;
  CFMutableDictionaryRef v44;
  NSObject *v45;
  const __CFAllocator *v46;
  CFIndex v47;
  CFIndex v48;
  CFIndex v49;
  const CFDictionaryKeyCallBacks *v50;
  const CFDictionaryValueCallBacks *v51;
  const void *v52;
  __CFDictionary *PropertyForClient;
  __CFDictionary *v54;
  const __CFArray *v55;
  uint64_t v56;
  __CFDictionary *cf;
  CFSetRef *v58;
  uint64_t v59;
  _QWORD context[2];
  CFTypeRef v61;
  const void *v62;
  uint8_t valuePtr[80];
  uint64_t v64[4];
  CFRange v65;

  v5 = a1;
  v64[2] = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(v64, valuePtr);
  ++**(_DWORD **)(v5 + 32);
  if (CFEqual(a2, CFSTR("LastActivityTimestamp")))
  {
    v6 = CFGetAllocator((CFTypeRef)v5);
    v7 = CFNumberCreate(v6, kCFNumberSInt64Type, (const void *)(v5 + 168));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 120), a2, v7);
    CFRelease(v7);
  }
  if (CFEqual(a2, CFSTR("LastActivityTime")))
  {
    *(_QWORD *)valuePtr = *(_QWORD *)(v5 + 176) | ((unint64_t)*(unsigned int *)(v5 + 184) << 32);
    v8 = CFGetAllocator((CFTypeRef)v5);
    v9 = CFNumberCreate(v8, kCFNumberSInt64Type, valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 120), a2, v9);
    CFRelease(v9);
  }
  if (CFEqual(a2, CFSTR("HIDIdleTimeMicroseconds")))
  {
    *(_QWORD *)valuePtr = 0;
    v10 = mach_continuous_time();
    *(_QWORD *)valuePtr = _IOHIDGetTimestampDelta(v10, *(_QWORD *)(v5 + 168), 0x3E8u);
    v11 = CFGetAllocator((CFTypeRef)v5);
    v12 = CFNumberCreate(v11, kCFNumberSInt64Type, valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 120), a2, v12);
    CFRelease(v12);
  }
  if (CFEqual(a2, CFSTR("ServiceRecords")))
  {
    if (a3)
    {
      v13 = *(CFDictionaryRef **)(v5 + 8);
      if (v13)
      {
        v14 = (const __CFArray *)IOHIDEventSystemCopyServices(v13, 0);
        if (v14)
        {
          v15 = v14;
          v56 = v5;
          v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Count = CFArrayGetCount(v14);
          Mutable = CFArrayCreateMutable(v16, Count, MEMORY[0x1E0C9B378]);
          if (Mutable)
          {
            v19 = CFArrayGetCount(v15);
            if (v19 >= 1)
            {
              v20 = v19;
              v21 = 0;
              v22 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
              do
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v15, v21);
                if (!ValueAtIndex)
                  break;
                v24 = (uint64_t)ValueAtIndex;
                v25 = _IOHIDServiceCopyServiceRecordForClient(ValueAtIndex, a3);
                if (v25)
                {
                  v26 = v25;
                  if (_IOHIDIsSerializable((uint64_t)v25))
                  {
                    CFArrayAppendValue(Mutable, v26);
                  }
                  else
                  {
                    v27 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x1E0C9B390], v22);
                    if (v27)
                    {
                      v28 = v27;
                      RegistryID = (const void *)IOHIDServiceGetRegistryID(v24);
                      CFDictionarySetValue(v28, CFSTR("ServiceID"), RegistryID);
                      CFArrayAppendValue(Mutable, v28);
                      CFRelease(v28);
                    }
                    v30 = _IOHIDLog();
                    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                      _IOHIDSessionCopyPropertyForClient_cold_2((uint8_t *)v64, v24, (uint64_t *)((char *)v64 + 4), v30);
                  }
                  CFRelease(v26);
                }
                ++v21;
              }
              while (v20 != v21);
            }
          }
          v31 = v15;
LABEL_26:
          CFRelease(v31);
LABEL_27:
          v5 = v56;
          goto LABEL_28;
        }
      }
    }
    goto LABEL_75;
  }
  if (CFEqual(a2, CFSTR("ClientRecords")))
  {
    if (a3)
    {
      v58 = *(CFSetRef **)(v5 + 8);
      if (v58)
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (!Mutable)
          goto LABEL_28;
        v56 = v5;
        cf = 0;
        for (i = 0; i != 5; ++i)
        {
          v35 = IOHIDEventSystemCopyConnections(v58, i);
          v36 = v35 == 0;
          if (!v35)
            break;
          if (!i)
          {
            v37 = _IOHIDEventSystemCopyRecord((CFTypeRef *)v58);
            if (!v37)
              goto LABEL_68;
            cf = v37;
            CFArrayAppendValue(Mutable, v37);
          }
          v38 = CFArrayGetCount(v35);
          if (v38 >= 1)
          {
            v39 = v38;
            v40 = 0;
            while (1)
            {
              v41 = CFArrayGetValueAtIndex(v35, v40);
              if (!v41)
                break;
              v42 = v41;
              if (v41 != a3)
              {
                v43 = _IOHIDEventSystemConnectionCopyRecord((uint64_t)v41);
                if (!v43)
                  break;
                v44 = v43;
                if (_IOHIDIsSerializable((uint64_t)v43))
                {
                  CFArrayAppendValue(Mutable, v44);
                }
                else
                {
                  v45 = _IOHIDLog();
                  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)valuePtr = 138412290;
                    *(_QWORD *)&valuePtr[4] = v42;
                    _os_log_error_impl(&dword_18AAAF000, v45, OS_LOG_TYPE_ERROR, "Client record is not serializable for %@", valuePtr, 0xCu);
                  }
                }
                CFRelease(v44);
              }
              if (v39 == ++v40)
                goto LABEL_51;
            }
            v36 = 0;
            break;
          }
LABEL_51:
          CFRelease(v35);
        }
        if (cf)
          CFRelease(cf);
        if (!v36)
        {
LABEL_68:
          v31 = v35;
          goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
LABEL_75:
    Mutable = 0;
    goto LABEL_28;
  }
  if (CFEqual(a2, CFSTR("SessionFilterDebug")))
  {
    if (!a3)
      goto LABEL_75;
    v46 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v47 = CFArrayGetCount(*(CFArrayRef *)(v5 + 152));
      if (v47 >= 1)
      {
        v48 = v47;
        v49 = 0;
        v50 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
        v51 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
        while (1)
        {
          v52 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 152), v49);
          PropertyForClient = IOHIDSessionFilterGetPropertyForClient((uint64_t)v52, CFSTR("SessionFilterDebug"));
          if (PropertyForClient)
            goto LABEL_61;
          v54 = CFDictionaryCreateMutable(v46, 0, v50, v51);
          if (v54)
            break;
LABEL_62:
          if (v48 == ++v49)
            goto LABEL_28;
        }
        PropertyForClient = v54;
        CFDictionaryAddValue(v54, CFSTR("Class"), CFSTR("Unknown"));
LABEL_61:
        CFArrayAppendValue(Mutable, PropertyForClient);
        CFRelease(PropertyForClient);
        goto LABEL_62;
      }
    }
  }
  else
  {
    context[0] = v5;
    context[1] = a2;
    v61 = 0;
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
      a3 = 0;
    v62 = a3;
    v55 = *(const __CFArray **)(v5 + 152);
    v65.length = CFArrayGetCount(v55);
    v65.location = 0;
    CFArrayApplyFunction(v55, v65, (CFArrayApplierFunction)__FilterFunctionGetPropertyForClient, context);
    Mutable = (__CFArray *)v61;
    if (v61 || (Mutable = (__CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 120), a2)) != 0)
      CFRetain(Mutable);
  }
LABEL_28:
  v32 = *(_QWORD *)(v5 + 32);
  if (*(_DWORD *)v32)
  {
    --*(_DWORD *)v32;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v32 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v59, valuePtr);
  }
  return Mutable;
}

__CFArray *_IOHIDEventSystemCopyPropertyForConnection(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t v5;
  __CFArray *result;

  v5 = *(_QWORD *)(a1 + 128);
  result = _IOHIDEventSystemConnectionCopyProperty(a3, a2);
  if (!result)
    return _IOHIDSessionCopyPropertyForClient(v5, a2, a3);
  return result;
}

CFNumberRef _IOHIDEventSystemConnectionCopyProperty(_QWORD *a1, CFTypeRef cf2)
{
  uint64_t v4;
  CFNumberRef result;
  const __CFAllocator *v6;
  const void *v7;
  CFNumberType v8;

  if ((_QWORD *)*MEMORY[0x1E0C9B0D0] == a1)
    return 0;
  v4 = a1[55];
  if (!v4 || (result = (CFNumberRef)IOHIDConnectionFilterCopyProperty(v4, (uint64_t)cf2)) == 0)
  {
    if (CFEqual(CFSTR("HIDActivityState"), cf2))
    {
      v6 = CFGetAllocator(a1);
      v7 = a1 + 50;
      v8 = kCFNumberSInt32Type;
      return CFNumberCreate(v6, v8, v7);
    }
    if (CFEqual(cf2, CFSTR("IdleNotificationTime")))
    {
      v6 = CFGetAllocator(a1);
      v7 = a1 + 51;
      v8 = kCFNumberSInt64Type;
      return CFNumberCreate(v6, v8, v7);
    }
    return 0;
  }
  return result;
}

uint64_t io_server_version(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v7 = 0;
  v9 = 0;
  v8 = 0;
  *(_QWORD *)&v5.msgh_bits = 0x1800001513;
  *(_QWORD *)&v5.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v5.msgh_voucher_port = 0xB3D00000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t _Xio_hideventsystem_create_virtual_service(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  int v5;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    v4 = *MEMORY[0x1E0C804E8];
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    v5 = -300;
    goto LABEL_9;
  }
  result = _io_hideventsystem_create_virtual_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, (const void **)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v4 = *MEMORY[0x1E0C804E8];
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 44;
    return result;
  }
LABEL_10:
  *(_QWORD *)(a2 + 24) = v4;
  return result;
}

uint64_t _io_hideventsystem_create_virtual_service(unsigned int a1, UInt8 *a2, unsigned int a3, const void **a4)
{
  mach_vm_size_t v7;
  CFTypeID TypeID;
  const void *v9;
  void *v10;
  void *v11;
  CFTypeID v12;
  NSObject *v14;

  *a4 = 0;
  v7 = a3;
  TypeID = CFDictionaryGetTypeID();
  v9 = _IOHIDUnserializeAndVMDeallocWithTypeID(a2, v7, TypeID);
  v10 = (void *)IOMIGMachPortCacheCopy(a1);
  if (v10)
  {
    v11 = v10;
    v12 = CFGetTypeID(v10);
    if (v12 == IOHIDEventSystemConnectionGetTypeID())
    {
      if (IOHIDEventSystemConnectionGetType((uint64_t)v11)
        && (*(_BYTE *)IOHIDEventSystemConnectionGetEntitlements((uint64_t)v11) & 8) == 0)
      {
        v14 = _IOHIDLogCategory(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          _io_hideventsystem_dispatch_event_cold_1((uint64_t)v11);
      }
      else
      {
        *a4 = _IOHIDEventSystemConnectionCreateVirtualService(v11);
      }
    }
    CFRelease(v11);
  }
  if (v9)
    CFRelease(v9);
  return 0;
}

const void *_IOHIDEventSystemConnectionCreateVirtualService(void *cf)
{
  unsigned int v2;
  const void *v3;
  CFAllocatorRef v4;
  HIDEventService *VirtualForConnection;
  HIDEventService *v6;
  NSObject *EnumerationQueue;
  NSObject *v8;
  uint64_t v9;
  _QWORD block[7];
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  do
    v2 = __ldaxr((unsigned int *)&_virtualServiceID);
  while (__stlxr(v2 + 1, (unsigned int *)&_virtualServiceID));
  v3 = (const void *)(((_QWORD)cf << 16) | v2);
  v4 = CFGetAllocator(cf);
  VirtualForConnection = _IOHIDServiceCreateVirtualForConnection((uint64_t)v4, (unint64_t)v3, virtualServiceCallbacks, cf);
  if (VirtualForConnection)
  {
    v6 = VirtualForConnection;
    CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 34), v3, VirtualForConnection);
    CFRetain(cf);
    EnumerationQueue = _IOHIDEventSystemGetEnumerationQueue(*((_QWORD *)cf + 1));
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___IOHIDEventSystemConnectionCreateVirtualService_block_invoke;
    block[3] = &__block_descriptor_tmp_98;
    block[4] = v6;
    block[5] = cf;
    block[6] = v3;
    dispatch_async(EnumerationQueue, block);
  }
  else
  {
    v3 = 0;
  }
  v8 = _IOHIDLogCategory(9u);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *((_QWORD *)cf + 21);
    *(_DWORD *)buf = 136315394;
    v13 = v9;
    v14 = 2048;
    v15 = v3;
    _os_log_impl(&dword_18AAAF000, v8, OS_LOG_TYPE_DEFAULT, "%s: HIDVS ID:%llx create", buf, 0x16u);
  }
  return v3;
}

void _IOHIDEventSystemConnectionInvalidate(uint64_t a1)
{
  CFIndex Count;
  uint64_t v3;
  const __CFAllocator *v4;
  CFDictionaryRef Copy;
  NSObject *EnumerationQueue;
  OSQueueHead *v7;
  NSObject *v8;
  _QWORD v9[5];
  _QWORD block[6];

  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 272));
  v3 = MEMORY[0x1E0C809B0];
  if (Count >= 1)
  {
    v4 = CFGetAllocator((CFTypeRef)a1);
    Copy = CFDictionaryCreateCopy(v4, *(CFDictionaryRef *)(a1 + 272));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 272));
    CFRetain((CFTypeRef)a1);
    EnumerationQueue = _IOHIDEventSystemGetEnumerationQueue(*(_QWORD *)(a1 + 8));
    block[0] = v3;
    block[1] = 0x40000000;
    block[2] = ___IOHIDEventSystemConnectionInvalidate_block_invoke;
    block[3] = &__block_descriptor_tmp_14_2;
    block[4] = Copy;
    block[5] = a1;
    dispatch_async(EnumerationQueue, block);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)__NotificationApplier, (void *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 268));
  v7 = *(OSQueueHead **)(a1 + 424);
  if (v7)
    IOHIDNotificationInvalidate(v7, 0);
  CFRetain((CFTypeRef)a1);
  v8 = *(NSObject **)(a1 + 96);
  v9[0] = v3;
  v9[1] = 0x40000000;
  v9[2] = ___IOHIDEventSystemConnectionInvalidate_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_15_1;
  v9[4] = a1;
  dispatch_async(v8, v9);
  *(_DWORD *)(a1 + 264) |= 1u;
}

uint64_t _IOHIDEventSystemGetEnumerationQueue(uint64_t a1)
{
  return *(_QWORD *)(a1 + 144);
}

HIDEventService *_IOHIDServiceCreateVirtualForConnection(uint64_t a1, unint64_t a2, _QWORD *a3, void *a4)
{
  HIDEventService *VirtualNoInit;
  HIDEventService *v6;

  VirtualNoInit = __IOHIDServiceCreateVirtualNoInit(a1, a2, a3, 0, a4);
  v6 = VirtualNoInit;
  if (VirtualNoInit)
  {
    VirtualNoInit->_service.virtualService.target = VirtualNoInit;
    VirtualNoInit->_service.virtualService.connection = (void *)CFRetain(a4);
  }
  return v6;
}

HIDEventService *__IOHIDServiceCreateVirtualNoInit(uint64_t a1, unint64_t a2, _QWORD *a3, void *a4, void *a5)
{
  HIDEventService *Private;
  IOHIDServiceVirtualCallbacksV2 *v10;
  const void *v11;
  size_t v12;

  Private = _IOHIDServiceCreatePrivate(a1);
  if (Private)
  {
    v10 = (IOHIDServiceVirtualCallbacksV2 *)malloc_type_calloc(1uLL, 0x58uLL, 0x10800405B6EA996uLL);
    Private->_service.virtualService.callbacks = v10;
    if (v10)
    {
      if (*a3 == 2)
      {
        v11 = a3;
        v12 = 88;
      }
      else
      {
        v10 = (IOHIDServiceVirtualCallbacksV2 *)((char *)v10 + 8);
        v11 = a3;
        v12 = 72;
      }
      memmove(v10, v11, v12);
      Private->_service.virtualService.target = a4;
      Private->_service.virtualService.refcon = a5;
      Private->_service.regID = a2;
    }
    else
    {
      CFRelease(Private);
      return 0;
    }
  }
  return Private;
}

HIDEventService *_IOHIDServiceCreatePrivate(uint64_t a1)
{
  return -[HIDEventService init](+[HIDEventService allocWithZone:](HIDEventService, "allocWithZone:", a1), "init");
}

id IOHIDServiceFilterSchedule(uint64_t a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  id result;
  const char *v5;
  const char *v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*(_QWORD *)v2 + 72);
    if (v3)
      return (id)v3();
  }
  result = *(id *)(a1 + 96);
  if (result)
  {
    v5 = *(const char **)(a1 + 168);
    if (v5)
    {
      objc_msgSend(result, v5, *(_QWORD *)(a1 + 48));
      result = *(id *)(a1 + 96);
    }
    v6 = *(const char **)(a1 + 160);
    if (v6)
    {
      objc_msgSend(result, v6, *(_QWORD *)(a1 + 32));
      result = *(id *)(a1 + 96);
    }
    *(_DWORD *)(a1 + 72) |= 1u;
    return objc_msgSend(result, *(SEL *)(a1 + 144));
  }
  return result;
}

HIDEvent *IOHIDEventCreateProximtyEvent(uint64_t a1, uint64_t a2, __int16 a3, int a4)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 14, a2, a4 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = 0;
  }
  return result;
}

HIDEvent *IOHIDEventCreateVendorDefinedEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, const void *a6, size_t a7, int a8)
{
  uint64_t v13;
  HIDEvent *v14;
  IOHIDEventData *eventData;

  v13 = a2;
  v14 = _IOHIDEventCreate(a1, a7 + 28, 1, a2, a8 | 1u);
  if (v14)
  {
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      v13 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v13);
    }
    v14->_event.timeStamp = v13;
    eventData = v14->_event.eventData;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = a4;
    *((_DWORD *)eventData + 5) = a5;
    *((_DWORD *)eventData + 6) = a7;
    memmove((char *)eventData + 28, a6, a7);
  }
  return v14;
}

Boolean IODataQueueDataAvailable(IODataQueueMemory *dataQueue)
{
  if (dataQueue)
    LOBYTE(dataQueue) = dataQueue->head != dataQueue->tail;
  return dataQueue;
}

HIDEvent *IOHIDEventCreateProximtyProbabilityEvent(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 14, a2, a5 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = 1;
    *((_DWORD *)eventData + 5) = a4;
  }
  return result;
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  CFIndex Count;
  uint64_t v3;
  CFIndex v4;
  size_t v5;
  size_t v6;
  const __CFArray *v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  Count = CFDictionaryGetCount(*((CFDictionaryRef *)client + 12));
  if (Count)
  {
    v4 = Count;
    v5 = 8 * Count;
    MEMORY[0x1E0C80A78](Count, v3);
    if (v5 >= 0x200)
      v6 = 512;
    else
      v6 = v5;
    bzero((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v6);
    bzero((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
    CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)client + 12), 0, (const void **)((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0)));
    v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0)), v4, MEMORY[0x1E0C9B378]);
  }
  else
  {
    v7 = 0;
  }
  os_unfair_recursive_lock_unlock();
  return v7;
}

void _IOHIDEventSystemRemoveConnection(CFDictionaryRef *a1, void *a2)
{
  int Type;
  NSObject *v5;
  const __CFAllocator *v6;
  CFDictionaryRef Copy;
  CFDictionaryRef *v8;
  CFDictionaryRef v9;
  void (*v10)(CFDictionaryRef, CFDictionaryRef, void *);
  CFDictionaryRef v11;
  const __CFAllocator *v12;
  const __CFSet *v13;
  int v14;
  void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  Type = IOHIDEventSystemConnectionGetType((uint64_t)a2);
  CFRetain(a2);
  v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v14 = 138543362;
    v15 = a2;
    _os_log_impl(&dword_18AAAF000, v5, OS_LOG_TYPE_DEFAULT, "Connection removed: %{public}@", (uint8_t *)&v14, 0xCu);
  }
  _IOHIDEventSystemUnregisterEventFilter((uint64_t)a1, a2);
  os_unfair_recursive_lock_lock_with_options();
  v6 = CFGetAllocator(a1);
  Copy = CFDictionaryCreateCopy(v6, a1[2]);
  v8 = &a1[3 * Type];
  v9 = v8[38];
  v10 = (void (*)(CFDictionaryRef, CFDictionaryRef, void *))v8[39];
  v11 = v8[40];
  CFSetRemoveValue(a1[7], a2);
  CFSetRemoveValue(a1[8], a2);
  CFSetRemoveValue(a1[9], a2);
  CFSetRemoveValue(a1[6], a2);
  v12 = CFGetAllocator(a1);
  v13 = CFSetCreateCopy(v12, a1[53]);
  os_unfair_recursive_lock_unlock();
  _IOHIDEventSystemRemoveServicesForConnection((uint64_t)a1, Copy, (uint64_t)a2);
  if (v13)
  {
    CFSetApplyFunction(v13, (CFSetApplierFunction)_IOHIDEventSystemConnectionRecordClientChanged, 0);
    CFRelease(v13);
  }
  if (Copy)
  {
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__RemoveServiceConnectionPropertyFunction, a2);
    CFRelease(Copy);
  }
  if (v10)
    v10(v9, v11, a2);
  CFRelease(a2);
}

void _IOHIDEventSystemUnregisterEventFilter(uint64_t a1, void *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const void *ValueAtIndex;
  const void *v9;
  const __CFSet *v10;
  const __CFSet *v11;

  os_unfair_recursive_lock_lock_with_options();
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count < 1)
  {
LABEL_8:
    v9 = 0;
  }
  else
  {
    v5 = Count;
    v6 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v6);
      if (ValueAtIndex && ValueAtIndex == a2)
        break;
      if (v5 == ++v6)
        goto LABEL_8;
    }
    CFRetain(a2);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), v6);
    v9 = a2;
  }
  os_unfair_recursive_lock_unlock();
  v10 = _IOHIDEventSystemConnectionCopyServices((CFSetRef *)a2);
  v11 = v10;
  if (v10)
    CFSetApplyFunction(v10, (CFSetApplierFunction)__IOHIDEventSystemFilterEventServiceUnregister, a2);
  if (v9)
    CFRelease(v9);
  if (v11)
    CFRelease(v11);
}

CFSetRef _IOHIDEventSystemConnectionCopyServices(CFSetRef *a1)
{
  const __CFAllocator *v2;
  CFSetRef Copy;

  os_unfair_recursive_lock_lock_with_options();
  v2 = CFGetAllocator(a1);
  Copy = CFSetCreateCopy(v2, a1[10]);
  os_unfair_recursive_lock_unlock();
  return Copy;
}

uint64_t IOHIDEventSystemClientRegisterEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 200) = a2;
  *(_QWORD *)(a1 + 216) = a3;
  *(_QWORD *)(a1 + 224) = a4;
  os_unfair_recursive_lock_unlock();
  return __IOHIDEventSystemClientStartQueue(a1);
}

uint64_t IOHIDEventQueueIsActive(uint64_t a1)
{
  uint64_t v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(unsigned int *)(a1 + 148);
  os_unfair_recursive_lock_unlock();
  return v2;
}

void __setAsyncAssertionProperties_block_invoke(uint64_t a1)
{
  int *v2;
  const void *v3;
  void *v4;
  CFTypeID TypeID;
  void *v6;
  uint64_t v7;
  int v8;
  const __CFNumber *v9;
  __CFDictionary *Mutable;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFNumber *v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  void *value;

  v2 = (int *)(a1 + 56);
  v3 = (const void *)(*(_WORD *)(a1 + 58) & 0x7FFF);
  value = 0;
  v29 = 0;
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)gAssertionsDict, v3, (const void **)&value))
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        __setAsyncAssertionProperties_block_invoke_cold_2();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __setAsyncAssertionProperties_block_invoke_cold_1();
    }
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v8 = -536870911;
    goto LABEL_20;
  }
  v4 = value;
  TypeID = CFDictionaryGetTypeID();
  if (!v4 || CFGetTypeID(v4) != TypeID)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        __setAsyncAssertionProperties_block_invoke_cold_4();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __setAsyncAssertionProperties_block_invoke_cold_3();
    }
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v8 = -536870199;
LABEL_20:
    *(_DWORD *)(v7 + 24) = v8;
    return;
  }
  v6 = value;
  CFDictionarySetValue((CFMutableDictionaryRef)value, *(const void **)(a1 + 40), *(const void **)(a1 + 48));
  if (CFStringCompare(*(CFStringRef *)(a1 + 40), CFSTR("TimeoutSeconds"), 0) == kCFCompareEqualTo)
  {
    if (CFDictionaryContainsKey((CFDictionaryRef)gActiveAssertionsDict, v3))
    {
      removeFromTimedList(*v2);
      insertIntoTimedList(v6);
      goto LABEL_24;
    }
    if (!CFDictionaryContainsKey((CFDictionaryRef)gInactiveAssertionsDict, v3))
      goto LABEL_24;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        __setAsyncAssertionProperties_block_invoke_cold_6();
    }
    else
    {
      v20 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (v20)
        __setAsyncAssertionProperties_block_invoke_cold_5(v20, v21, v22, v23, v24, v25, v26, v27);
    }
    v28 = 255;
    v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v28);
LABEL_40:
    Mutable = v19;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = handleAssertionLevel(v19, *(unsigned int *)(a1 + 56), 0);
    CFDictionaryContainsKey((CFDictionaryRef)v6, CFSTR("AsyncRemoteAssertionId"));
    if (Mutable)
      goto LABEL_41;
    return;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 40), CFSTR("AssertLevel"), 0) == kCFCompareEqualTo)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        __setAsyncAssertionProperties_block_invoke_cold_8();
    }
    else
    {
      v11 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (v11)
        __setAsyncAssertionProperties_block_invoke_cold_7(v11, v12, v13, v14, v15, v16, v17, v18);
    }
    v19 = (const __CFNumber *)CFRetain(*(CFTypeRef *)(a1 + 48));
    goto LABEL_40;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 40), CFSTR("AssertName"), 0) == kCFCompareEqualTo)
    logAsyncAssertionActivity(5u, *v2);
LABEL_24:
  if (CFDictionaryContainsKey((CFDictionaryRef)v6, CFSTR("AsyncRemoteAssertionId")))
  {
    v9 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v6, CFSTR("AsyncRemoteAssertionId"));
    v28 = 0;
    CFNumberGetValue(v9, kCFNumberIntType, &v28);
    if (v28 == gCurrentRemoteAssertion)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, *(const void **)(a1 + 40), *(const void **)(a1 + 48));
      CFDictionarySetValue(Mutable, CFSTR("AsyncRemoteAssertionId"), v9);
      sendAsyncAssertionMsg(0, (uint64_t)Mutable, &v29, 0);
LABEL_41:
      CFRelease(Mutable);
    }
  }
}

uint64_t handleAssertionLevel(const __CFNumber *a1, uint64_t a2, char a3)
{
  __CFDictionary *Value;
  __CFDictionary *v6;
  int v7;
  int v8;
  CFAbsoluteTime Current;
  CFDateRef v10;
  CFDateRef v11;
  uint64_t v12;
  CFAbsoluteTime v13;
  CFDateRef v14;
  CFDateRef v15;
  NSObject *v16;
  int valuePtr;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  __CFDictionary *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
  Value = (__CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)gAssertionsDict, (const void *)(WORD1(a2) & 0x7FFF));
  if (Value)
  {
    v6 = Value;
    v7 = CFDictionaryContainsKey((CFDictionaryRef)gActiveAssertionsDict, (const void *)(WORD1(a2) & 0x7FFF));
    v8 = CFDictionaryContainsKey((CFDictionaryRef)gInactiveAssertionsDict, (const void *)(WORD1(a2) & 0x7FFF));
    if (v7 | v8)
    {
      if (valuePtr)
      {
        if (valuePtr == 255 && v8)
        {
          Current = CFAbsoluteTimeGetCurrent();
          v10 = CFDateCreate(0, Current);
          if (v10)
          {
            v11 = v10;
            CFDictionarySetValue(v6, CFSTR("AssertStartWhen"), v10);
            CFRelease(v11);
          }
          if (CFDictionaryContainsKey(v6, CFSTR("AssertReleaseWhen")))
            CFDictionaryRemoveValue(v6, CFSTR("AssertReleaseWhen"));
          CFDictionaryRemoveValue((CFMutableDictionaryRef)gInactiveAssertionsDict, (const void *)(WORD1(a2) & 0x7FFF));
          activateAsyncAssertion(a2, 4);
        }
      }
      else if (v7)
      {
        v13 = CFAbsoluteTimeGetCurrent();
        v14 = CFDateCreate(0, v13);
        if (v14)
        {
          v15 = v14;
          CFDictionarySetValue(v6, CFSTR("AssertReleaseWhen"), v14);
          CFRelease(v15);
        }
        CFArrayAppendValue((CFMutableArrayRef)gReleasedAssertionsList, v6);
        CFDictionarySetValue((CFMutableDictionaryRef)gInactiveAssertionsDict, (const void *)(WORD1(a2) & 0x7FFF), v6);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)gActiveAssertionsDict, (const void *)(WORD1(a2) & 0x7FFF));
        if ((a3 & 1) == 0)
          logAsyncAssertionActivity(3u, a2);
        if ((int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) <= 0 && gCurrentAssertion)
        {
          if (assertions_log)
          {
            if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
              handleAssertionLevel_cold_5();
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
          {
            handleAssertionLevel_cold_4();
          }
          sendAsyncReleaseMsg(gCurrentRemoteAssertion, 1, gCurrentRemoteAssertionIsCoalesced);
          gCurrentAssertion = 0;
          gCurrentRemoteAssertion = 0;
          gCurrentRemoteAssertionIsCoalesced = 0;
        }
      }
      v16 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109634;
          v20 = a2;
          v21 = 1024;
          v22 = valuePtr;
          v23 = 2112;
          v24 = v6;
          _os_log_debug_impl(&dword_18AAAF000, v16, OS_LOG_TYPE_DEBUG, "handleAssertionLevel for 0x%x to %d: %@", buf, 0x18u);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        handleAssertionLevel_cold_3(&valuePtr, (uint64_t)v6, a2);
      }
      return 0;
    }
    else
    {
      v12 = 3758097084;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          handleAssertionLevel_cold_7();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        handleAssertionLevel_cold_6();
      }
    }
  }
  else if (assertions_log)
  {
    v12 = 3758097090;
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      handleAssertionLevel_cold_2();
  }
  else
  {
    v12 = 3758097090;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      handleAssertionLevel_cold_1();
  }
  return v12;
}

uint64_t __releaseAsyncAssertion_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = _releaseAsycnAssertion(*(_DWORD *)(a1 + 40), 1, 1);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t _releaseAsycnAssertion(unsigned int a1, int a2, int a3)
{
  const void *v6;
  CFAbsoluteTime Current;
  CFDateRef v8;
  CFDateRef v9;
  NSObject *v10;
  uint64_t result;
  void *value;

  v6 = (const void *)(HIWORD(a1) & 0x7FFF);
  value = 0;
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)gAssertionsDict, v6, (const void **)&value))
  {
    Current = CFAbsoluteTimeGetCurrent();
    v8 = CFDateCreate(0, Current);
    if (v8)
    {
      v9 = v8;
      CFDictionarySetValue((CFMutableDictionaryRef)value, CFSTR("AssertReleaseWhen"), v8);
      CFRelease(v9);
    }
    if (a3)
      logAsyncAssertionActivity(1u, a1);
    if (CFDictionaryContainsKey((CFDictionaryRef)gActiveAssertionsDict, v6))
    {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gActiveAssertionsDict, v6);
      if (CFArrayGetCount((CFArrayRef)gReleasedAssertionsList) <= 127)
        CFArrayAppendValue((CFMutableArrayRef)gReleasedAssertionsList, value);
    }
    else if (CFDictionaryContainsKey((CFDictionaryRef)gInactiveAssertionsDict, v6))
    {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gInactiveAssertionsDict, v6);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gAssertionsDict, v6);
    if (a2)
      removeFromTimedList(a1);
    if ((int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) <= 0 && gCurrentAssertion)
    {
      sendAsyncReleaseMsg(gCurrentRemoteAssertion, 1, gCurrentRemoteAssertionIsCoalesced);
      gCurrentAssertion = 0;
      gCurrentRemoteAssertion = 0;
      gCurrentRemoteAssertionIsCoalesced = 0;
      v10 = assertions_log;
      if (assertions_log)
      {
        result = os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG);
        if (!(_DWORD)result)
          return result;
        _releaseAsycnAssertion_cold_6(a1, v10);
      }
      else
      {
        result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
        if (!(_DWORD)result)
          return result;
        _releaseAsycnAssertion_cold_5(a1);
      }
    }
    else if (assertions_log)
    {
      result = os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      _releaseAsycnAssertion_cold_4();
    }
    else
    {
      result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      _releaseAsycnAssertion_cold_3();
    }
    return 0;
  }
  else
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        _releaseAsycnAssertion_cold_2();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      _releaseAsycnAssertion_cold_1();
    }
    return 3758096385;
  }
}

void insertIntoTimedList(void *value)
{
  __CFArray *v1;
  NSObject *PMQueue;
  NSObject *v3;
  _BOOL8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int MonotonicTime;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v14;
  int v15;
  NSObject *v16;
  dispatch_time_t v17;
  uint64_t v18;
  uint8_t *v19;
  NSObject *v20;
  __int16 v21;
  __int16 v22;
  uint64_t valuePtr;
  CFRange v24;

  CFArrayAppendValue((CFMutableArrayRef)gTimedAssertionsList, value);
  v1 = (__CFArray *)gTimedAssertionsList;
  v24.length = CFArrayGetCount((CFArrayRef)gTimedAssertionsList);
  v24.location = 0;
  CFArraySortValues(v1, v24, (CFComparatorFunction)compare_assertion, 0);
  if (gAssertionTimer)
  {
    if (!assertion_timer_suspended)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          insertIntoTimedList_cold_4();
      }
      else
      {
        v4 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
        if (v4)
          insertIntoTimedList_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
      }
      dispatch_suspend((dispatch_object_t)gAssertionTimer);
      assertion_timer_suspended = 1;
    }
  }
  else
  {
    PMQueue = getPMQueue();
    v3 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, PMQueue);
    gAssertionTimer = (uint64_t)v3;
    if (v3)
    {
      dispatch_source_set_event_handler(v3, &__block_literal_global_85);
      dispatch_source_set_cancel_handler((dispatch_source_t)gAssertionTimer, &__block_literal_global_87);
    }
  }
  MonotonicTime = getMonotonicTime();
  valuePtr = 0;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, 0);
  v14 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TimeoutTimeStamp"));
  CFNumberGetValue(v14, kCFNumberSInt64Type, &valuePtr);
  v15 = valuePtr - MonotonicTime;
  if (v15 <= 0)
  {
    handleAssertionTimeout();
    return;
  }
  if (gAssertionTimer)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        insertIntoTimedList_cold_2();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      insertIntoTimedList_cold_1();
    }
    v16 = gAssertionTimer;
    v17 = dispatch_time(0, 1000000000 * v15);
    dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
    if (assertion_timer_suspended)
    {
      v18 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        {
          v22 = 0;
          v19 = (uint8_t *)&v22;
          v20 = v18;
LABEL_25:
          _os_log_impl(&dword_18AAAF000, v20, OS_LOG_TYPE_DEFAULT, "Resuming timer", v19, 2u);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v21 = 0;
        v20 = MEMORY[0x1E0C81028];
        v19 = (uint8_t *)&v21;
        goto LABEL_25;
      }
      assertion_timer_suspended = 0;
      dispatch_resume((dispatch_object_t)gAssertionTimer);
    }
  }
}

void __createAsyncAssertion_block_invoke(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  _BOOL8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v13;
  CFAbsoluteTime Current;
  CFDateRef v15;
  CFDateRef v16;
  unsigned int **v17;
  unsigned int *v18;
  CFNumberRef v19;
  const void *Value;
  CFTypeID TypeID;
  NSObject *v22;
  uint64_t MonotonicTime;
  CFNumberRef v24;
  CFNumberRef v25;
  int valuePtr;
  uint64_t v27;

  v27 = 0;
  initialSetup();
  if (gAsyncModeDisableOverride)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        createAsyncAssertion_cold_2();
    }
    else
    {
      v4 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (v4)
        createAsyncAssertion_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    goto LABEL_21;
  }
  LODWORD(v2) = createAsyncAssertion_gNextAssertionIdx;
  while (1)
  {
    v3 = v2;
    if (CFDictionaryContainsKey((CFDictionaryRef)gAssertionsDict, (const void *)v2) != 1)
      break;
    v2 = ((_BYTE)v2 + 1) & 0x7F;
    if ((_DWORD)v2 == createAsyncAssertion_gNextAssertionIdx)
    {
      v3 = v2;
      break;
    }
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)gAssertionsDict, (const void *)v3) == 1)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        __createAsyncAssertion_block_invoke_cold_2();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __createAsyncAssertion_block_invoke_cold_1();
    }
    return;
  }
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, *(CFDictionaryRef *)(a1 + 40));
  if (!MutableCopy
    || (v13 = MutableCopy, Current = CFAbsoluteTimeGetCurrent(), (v15 = CFDateCreate(0, Current)) == 0))
  {
LABEL_21:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  v16 = v15;
  CFDictionarySetValue(v13, CFSTR("AssertStartWhen"), v15);
  CFRelease(v16);
  CFDictionarySetValue((CFMutableDictionaryRef)gAssertionsDict, (const void *)v3, v13);
  createAsyncAssertion_gNextAssertionIdx = ((_BYTE)v2 + 1) & 0x7F;
  v18 = *(unsigned int **)(a1 + 48);
  v17 = (unsigned int **)(a1 + 48);
  *v18 = ((_DWORD)v2 << 16) | 0x80000000;
  v19 = CFNumberCreate(0, kCFNumberSInt32Type, v18);
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
    {
      __createAsyncAssertion_block_invoke_cold_8();
      if (!v19)
        goto LABEL_28;
LABEL_27:
      CFDictionarySetValue(v13, CFSTR("AsyncClientAssertionId"), v19);
      CFRelease(v19);
      goto LABEL_28;
    }
LABEL_26:
    if (!v19)
      goto LABEL_28;
    goto LABEL_27;
  }
  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    goto LABEL_26;
  __createAsyncAssertion_block_invoke_cold_7();
  if (v19)
    goto LABEL_27;
LABEL_28:
  valuePtr = 255;
  Value = CFDictionaryGetValue(v13, CFSTR("AssertLevel"));
  TypeID = CFNumberGetTypeID();
  if (Value
    && CFGetTypeID(Value) == TypeID
    && (CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, &valuePtr), !valuePtr))
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        __createAsyncAssertion_block_invoke_cold_6();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      __createAsyncAssertion_block_invoke_cold_5();
    }
    CFDictionarySetValue((CFMutableDictionaryRef)gInactiveAssertionsDict, (const void *)v3, v13);
    MonotonicTime = getMonotonicTime();
    v27 = (getpid() << 16) | (MonotonicTime << 32) | *((unsigned __int16 *)*v17 + 1);
    v24 = CFNumberCreate(0, kCFNumberSInt64Type, &v27);
    if (v24)
    {
      v25 = v24;
      CFDictionarySetValue(v13, CFSTR("GlobalUniqueID"), v24);
      CFRelease(v25);
    }
  }
  else
  {
    activateAsyncAssertion(**v17, 0);
  }
  v22 = assertions_log;
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      __createAsyncAssertion_block_invoke_cold_4((int **)v17, (uint64_t)v13, v22);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    __createAsyncAssertion_block_invoke_cold_3((int **)v17, (uint64_t)v13);
  }
  CFRelease(v13);
}

void activateAsyncAssertion(unsigned int a1, unsigned int a2)
{
  const void *v4;
  __CFDictionary *Value;
  __CFDictionary *v6;
  uint64_t MonotonicTime;
  CFNumberRef v8;
  CFNumberRef v9;
  const void *v10;
  CFTypeID TypeID;
  uint64_t v12;
  CFNumberRef v13;
  CFNumberRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  dispatch_time_t v20;
  uint64_t valuePtr;
  unint64_t v22;
  uint64_t v23;
  uint8_t buf[4];
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v23 = 0;
  v4 = (const void *)(HIWORD(a1) & 0x7FFF);
  Value = (__CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)gAssertionsDict, v4);
  if (Value)
  {
    v6 = Value;
    CFDictionarySetValue((CFMutableDictionaryRef)gActiveAssertionsDict, v4, Value);
    MonotonicTime = getMonotonicTime();
    valuePtr = HIWORD(a1) | (MonotonicTime << 32) | (getpid() << 16);
    v8 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
    if (v8)
    {
      v9 = v8;
      CFDictionarySetValue(v6, CFSTR("GlobalUniqueID"), v8);
      CFRelease(v9);
    }
    logAsyncAssertionActivity(a2, a1);
    if (gCurrentRemoteAssertion && !gCurrentRemoteAssertionIsCoalesced)
      gCurrentRemoteAssertionIsCoalesced = (int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) >= 2;
    v10 = CFDictionaryGetValue(v6, CFSTR("TimeoutSeconds"));
    TypeID = CFNumberGetTypeID();
    if (!v10)
      goto LABEL_14;
    if (CFGetTypeID(v10) != TypeID)
      goto LABEL_14;
    CFNumberGetValue((CFNumberRef)v10, kCFNumberSInt64Type, &v23);
    v12 = v23;
    if (!v23)
      goto LABEL_14;
    v22 = getMonotonicTime() + v12;
    v13 = CFNumberCreate(0, kCFNumberSInt64Type, &v22);
    if (v13)
    {
      v14 = v13;
      CFDictionarySetValue(v6, CFSTR("TimeoutTimeStamp"), v13);
      CFRelease(v14);
    }
    insertIntoTimedList(v6);
    if (v23 == 1)
    {
      v15 = 1;
    }
    else
    {
LABEL_14:
      v23 = 1;
      v16 = getMonotonicTime();
      v15 = v23;
      v22 = v23 + v16;
    }
    if (!gCurrentAssertion && (!nextOffload_ts || v22 && v22 < nextOffload_ts))
    {
      v17 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          v25 = v15;
          v18 = v17;
LABEL_29:
          _os_log_impl(&dword_18AAAF000, v18, OS_LOG_TYPE_DEFAULT, "Setting gAssertionsOffloader timeout to %llu\n", buf, 0xCu);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v25 = v15;
        v18 = MEMORY[0x1E0C81028];
        goto LABEL_29;
      }
      v19 = gAssertionsOffloader;
      v20 = dispatch_time(0, 1000000000 * v23);
      dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0);
      if (!nextOffload_ts)
        dispatch_resume((dispatch_object_t)gAssertionsOffloader);
      nextOffload_ts = v23 + getMonotonicTime();
    }
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      activateAsyncAssertion_cold_2();
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    activateAsyncAssertion_cold_1();
  }
}

uint64_t getMonotonicTime()
{
  if (!dword_1ECD378B4)
    mach_timebase_info((mach_timebase_info_t)&getMonotonicTime_timebaseInfo);
  return mach_absolute_time()
       * getMonotonicTime_timebaseInfo
       / (1000000000
        * (unint64_t)dword_1ECD378B4);
}

void logAsyncAssertionActivity(unsigned int a1, unsigned int a2)
{
  const __CFDictionary *Value;
  const __CFDictionary *v4;
  __CFString *v5;
  CFIndex Count;
  CFIndex v7;
  void *Mutable;
  CFAbsoluteTime Current;
  CFDateRef v10;
  CFDateRef v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  uint64_t v23;
  uint8_t *v24;
  NSObject *v25;
  __int16 v26;
  __int16 v27;

  Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)gAssertionsDict, (const void *)(HIWORD(a2) & 0x7FFF));
  if (!Value)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        logAsyncAssertionActivity_cold_2();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      logAsyncAssertionActivity_cold_1();
    }
    return;
  }
  if (a1 > 5)
    return;
  v4 = Value;
  v5 = off_1E2003CF8[a1];
  if (!gAsyncAssertionActivityLog_1)
  {
    gAsyncAssertionActivityLog_1 = (uint64_t)CFArrayCreateMutable(0, 24, MEMORY[0x1E0C9B378]);
    if (!gAsyncAssertionActivityLog_1)
      return;
    gAsyncAssertionActivityLog_2 = 0;
    v23 = assertions_log;
    if (assertions_log)
    {
      if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_4;
      v27 = 0;
      v24 = (uint8_t *)&v27;
      v25 = v23;
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_4;
      v26 = 0;
      v25 = MEMORY[0x1E0C81028];
      v24 = (uint8_t *)&v26;
    }
    _os_log_impl(&dword_18AAAF000, v25, OS_LOG_TYPE_DEFAULT, "Async sssertion bufffer initialized.", v24, 2u);
  }
LABEL_4:
  Count = CFArrayGetCount((CFArrayRef)gAsyncAssertionActivityLog_1);
  v7 = gAsyncAssertionActivityLog_0 % 0x18u;
  if (Count <= v7)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 16, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
      return;
  }
  else
  {
    Mutable = (void *)CFArrayGetValueAtIndex((CFArrayRef)gAsyncAssertionActivityLog_1, v7);
    CFRetain(Mutable);
    CFDictionaryRemoveAllValues((CFMutableDictionaryRef)Mutable);
    if (!Mutable)
      return;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v10 = CFDateCreate(0, Current);
  if (v10)
  {
    v11 = v10;
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("ActivityTime"), v10);
    CFRelease(v11);
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("Action"), v5);
    v12 = CFDictionaryGetValue(v4, CFSTR("AssertStartWhen"));
    if (v12)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("AssertStartWhen"), v12);
    v13 = CFDictionaryGetValue(v4, CFSTR("AssertType"));
    if (v13)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("AssertType"), v13);
    v14 = CFDictionaryGetValue(v4, CFSTR("AssertName"));
    if (v14)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("AssertName"), v14);
    v15 = CFDictionaryGetValue(v4, CFSTR("GlobalUniqueID"));
    if (v15)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("GlobalUniqueID"), v15);
    v16 = CFDictionaryGetValue(v4, CFSTR("AssertionOnBehalfOfPID"));
    if (v16)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("AssertionOnBehalfOfPID"), v16);
    v17 = CFDictionaryGetValue(v4, CFSTR("AssertionOnBehalfOfPIDReason"));
    if (v17)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("AssertionOnBehalfOfPIDReason"), v17);
    v18 = CFDictionaryGetValue(v4, CFSTR("AssertionOnBehalfOfBundleID"));
    if (v18)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("AssertionOnBehalfOfBundleID"), v18);
    v19 = CFDictionaryGetValue(v4, CFSTR("FrameworkBundleID"));
    if (v19)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("FrameworkBundleID"), v19);
    v20 = CFDictionaryGetValue(v4, CFSTR("InstanceMetadata"));
    if (v20)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("InstanceMetadata"), v20);
    v21 = CFDictionaryGetValue(v4, CFSTR("Category"));
    if (v21)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("Category"), v21);
    v22 = CFDictionaryGetValue(v4, CFSTR("IsCoalesced"));
    if (v22)
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, CFSTR("IsCoalesced"), v22);
    CFArraySetValueAtIndex((CFMutableArrayRef)gAsyncAssertionActivityLog_1, gAsyncAssertionActivityLog_0 % 0x18u, Mutable);
    ++gAsyncAssertionActivityLog_0;
    if (gAsyncAssertionActivityLog_2 != -1)
      ++gAsyncAssertionActivityLog_2;
  }
  CFRelease(Mutable);
}

void initialSetup()
{
  NSObject *PMQueue;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  _BOOL8 v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  xpc_connection_t mach_service;
  _xpc_connection_s *v11;
  NSObject *v12;
  xpc_object_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  _BOOL8 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL8 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint8_t v33[8];
  _QWORD handler[5];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  if (!gAsyncModeSetupDone)
  {
    if (setupLogging_onceToken != -1)
      dispatch_once(&setupLogging_onceToken, &__block_literal_global_13);
    v35 = 0;
    v36 = &v35;
    v37 = 0x2000000000;
    v38 = 0;
    PMQueue = getPMQueue();
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = __initialSetup_block_invoke;
    handler[3] = &unk_1E2003918;
    handler[4] = &v35;
    if (notify_register_dispatch("com.apple.powerd.assertionoffloadtimer", &initialSetup_notify_token, PMQueue, handler))
    {
      v1 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          initialSetup_cold_8(v1, v2, v3);
      }
      else
      {
        v4 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v4)
          initialSetup_cold_7(v4, v5, v6);
      }
    }
    else
    {
      notify_get_state(initialSetup_notify_token, (uint64_t *)v36 + 3);
      handleAsyncAssertionDisableOverride(*((_DWORD *)v36 + 6));
    }
    v7 = getPMQueue();
    if (notify_register_dispatch("com.apple.system.powermanagement.assertionresync", &initialSetup_resync_token, v7, &__block_literal_global_22))
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          initialSetup_cold_6();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        initialSetup_cold_5();
      }
    }
    if (gAssertionsDict
      || (gAssertionsDict = (uint64_t)CFDictionaryCreateMutable(0, 128, 0, MEMORY[0x1E0C9B3A0])) != 0)
    {
      if (!gReleasedAssertionsList)
        gReleasedAssertionsList = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      if (!gTimedAssertionsList)
        gTimedAssertionsList = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      if (!gActiveAssertionsDict)
        gActiveAssertionsDict = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 128, 0, MEMORY[0x1E0C9B3A0]);
      if (!gInactiveAssertionsDict)
        gInactiveAssertionsDict = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 128, 0, MEMORY[0x1E0C9B3A0]);
      if (gAssertionConnection)
        goto LABEL_28;
      mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E0C80D38], 0);
      gAssertionConnection = (uint64_t)mach_service;
      if (mach_service)
      {
        v11 = mach_service;
        v12 = getPMQueue();
        xpc_connection_set_target_queue(v11, v12);
        xpc_connection_set_event_handler((xpc_connection_t)gAssertionConnection, &__block_literal_global_25);
        xpc_connection_resume((xpc_connection_t)gAssertionConnection);
        v13 = xpc_dictionary_create(0, 0, 0);
        if (v13)
        {
          v14 = v13;
          xpc_dictionary_set_BOOL(v13, "assertionInitialConnection", 1);
          xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v14);
          v15 = assertions_log;
          if (assertions_log)
          {
            if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v33 = 0;
              v16 = v15;
LABEL_47:
              _os_log_impl(&dword_18AAAF000, v16, OS_LOG_TYPE_DEFAULT, "Sending initial message to powerd for async assertions", v33, 2u);
            }
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v33 = 0;
            v16 = MEMORY[0x1E0C81028];
            goto LABEL_47;
          }
          xpc_release(v14);
LABEL_28:
          v8 = gAssertionsOffloader;
          if (gAssertionsOffloader
            || (v9 = getPMQueue(),
                v8 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v9),
                (gAssertionsOffloader = (uint64_t)v8) != 0))
          {
            dispatch_source_set_event_handler(v8, &__block_literal_global_29);
            dispatch_source_set_cancel_handler((dispatch_source_t)gAssertionsOffloader, &__block_literal_global_31);
          }
          gAsyncModeSetupDone = 1;
LABEL_63:
          _Block_object_dispose(&v35, 8);
          return;
        }
      }
      else if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          __checkFeatureEnabled_block_invoke_2_cold_2();
      }
      else
      {
        v25 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v25)
          __checkFeatureEnabled_block_invoke_2_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
      }
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        initialSetup_cold_2();
    }
    else
    {
      v17 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v17)
        initialSetup_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    gAsyncModeSetupDone = 0;
    if (gAssertionsDict)
    {
      CFRelease((CFTypeRef)gAssertionsDict);
      gAssertionsDict = 0;
    }
    if (gReleasedAssertionsList)
    {
      CFRelease((CFTypeRef)gReleasedAssertionsList);
      gReleasedAssertionsList = 0;
    }
    if (gAssertionsOffloader)
    {
      dispatch_resume((dispatch_object_t)gAssertionsOffloader);
      dispatch_source_cancel((dispatch_source_t)gAssertionsOffloader);
    }
    if (gInactiveAssertionsDict)
    {
      CFRelease((CFTypeRef)gInactiveAssertionsDict);
      gInactiveAssertionsDict = 0;
    }
    if (gActiveAssertionsDict)
    {
      CFRelease((CFTypeRef)gActiveAssertionsDict);
      gActiveAssertionsDict = 0;
    }
    if (gAssertionConnection)
      xpc_connection_cancel((xpc_connection_t)gAssertionConnection);
    goto LABEL_63;
  }
}

void removeFromTimedList(int a1)
{
  uint64_t v2;
  CFIndex v3;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  int valuePtr;

  if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) >= 1)
  {
    v2 = 0;
    v3 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, v3);
      Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("AsyncClientAssertionId"));
      valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr == a1)
        break;
      ++v3;
      v2 += 0x100000000;
      if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) <= v3)
        return;
    }
    if ((_DWORD)v3 != -1)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          removeFromTimedList_cold_2();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        removeFromTimedList_cold_1();
      }
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)gTimedAssertionsList, v2 >> 32);
    }
  }
}

void sendAsyncReleaseMsg(unsigned int a1, int a2, BOOL a3)
{
  xpc_object_t v6;
  void *v7;
  void *v8;
  NSObject *v9;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v6 = xpc_dictionary_create(0, 0, 0);
  if (v6)
  {
    v7 = v6;
    if (gAssertionConnection)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          sendAsyncReleaseMsg_cold_8();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        sendAsyncReleaseMsg_cold_7();
      }
      xpc_dictionary_set_uint64(v7, "assertionRelease", a1);
      xpc_dictionary_set_BOOL(v7, "assertionWasCoalesced", a3);
      v8 = 0;
      if (a2 && gAsyncAssertionActivityLog_2)
      {
        if (CFArrayGetCount((CFArrayRef)gAsyncAssertionActivityLog_1))
        {
          v9 = assertions_log;
          if (assertions_log)
          {
            if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
              sendAsyncReleaseMsg_cold_6(v9);
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
          {
            sendAsyncReleaseMsg_cold_5();
          }
          v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          xpc_dictionary_set_value(v7, "assertionActivityLog", v8);
        }
        else
        {
          v8 = 0;
        }
      }
      xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v7);
      if (a2)
      {
        CFArrayRemoveAllValues((CFMutableArrayRef)gReleasedAssertionsList);
        gAsyncAssertionActivityLog_2 = 0;
        gAsyncAssertionActivityLog_0 = 0;
        if (gAsyncAssertionActivityLog_1)
          CFArrayRemoveAllValues((CFMutableArrayRef)gAsyncAssertionActivityLog_1);
      }
      if (v8)
        xpc_release(v8);
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        sendAsyncReleaseMsg_cold_4();
    }
    else
    {
      v18 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v18)
        sendAsyncReleaseMsg_cold_3(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    xpc_release(v7);
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      sendAsyncReleaseMsg_cold_2();
  }
  else
  {
    v10 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v10)
      sendAsyncReleaseMsg_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  CFRunLoopSourceRef result;
  const __CFString *v3;
  const __CFString *v4;
  char *v5;
  Boolean shouldFreeInfo;
  CFMachPortContext context;
  char buffer[255];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  shouldFreeInfo = 0;
  result = (CFRunLoopSourceRef)*((_QWORD *)notify + 2);
  if (!result)
  {
    context.version = 1;
    context.info = notify;
    memset(&context.retain, 0, 24);
    result = CFMachPortCreateWithPort(0, *((_DWORD *)notify + 1), (CFMachPortCallBack)IODispatchCalloutFromCFMessage, &context, &shouldFreeInfo);
    *((_QWORD *)notify + 1) = result;
    if (result)
    {
      if (shouldFreeInfo)
      {
        v3 = CFCopyDescription(result);
        if (v3)
        {
          v4 = v3;
          v5 = buffer;
          CFStringGetCString(v3, buffer, 255, 0x8000100u);
          CFRelease(v4);
        }
        else
        {
          v5 = "No Description";
        }
        asl_log(0, 0, 3, "IOKit.framework:IONotificationPortGetRunLoopSource bad CFMachPort, %s\n", v5);
        CFRelease(*((CFTypeRef *)notify + 1));
        *((_QWORD *)notify + 1) = 0;
        return (CFRunLoopSourceRef)*((_QWORD *)notify + 2);
      }
      else
      {
        result = CFMachPortCreateRunLoopSource(0, result, 0);
        *((_QWORD *)notify + 2) = result;
      }
    }
  }
  return result;
}

IOReturn IODataQueueWaitForAvailableData(IODataQueueMemory *dataQueue, mach_port_t notificationPort)
{
  IOReturn result;
  _BYTE v4[32];

  result = -536870206;
  if (dataQueue)
  {
    if (notificationPort)
    {
      memset(v4, 0, sizeof(v4));
      return mach_msg((mach_msg_header_t *)v4, 2, 0, 0x20u, notificationPort, 0, 0);
    }
  }
  return result;
}

HIDServiceClient *IOHIDVirtualServiceClientCreateWithCallbacks(void *cf, const void *a2, __int128 *a3, void *a4, void *a5)
{
  const __CFAllocator *v10;
  const __CFData *v11;
  const __CFData *v12;
  const UInt8 *BytePtr;
  int Length;
  const __CFAllocator *v15;
  CFNumberRef v16;
  const __CFAllocator *v17;
  HIDServiceClient *Virtual;
  NSObject *v20;
  NSObject *v21;
  const void *valuePtr;

  valuePtr = 0;
  if (*((_QWORD *)cf + 48) || *((_QWORD *)cf + 50))
  {
    v10 = CFGetAllocator(cf);
    v11 = (const __CFData *)_IOHIDCreateBinaryData(v10, a2);
    v12 = v11;
    if (v11)
    {
      BytePtr = CFDataGetBytePtr(v11);
      Length = CFDataGetLength(v12);
    }
    else
    {
      BytePtr = 0;
      Length = 0;
    }
    os_unfair_recursive_lock_lock_with_options();
    if (io_hideventsystem_create_virtual_service(*((_DWORD *)cf + 8), (uint64_t)BytePtr, Length, &valuePtr)|| !valuePtr)
    {
      v20 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        IOHIDVirtualServiceClientCreateWithCallbacks_cold_2();
      Virtual = 0;
      v16 = 0;
    }
    else
    {
      v15 = CFGetAllocator(cf);
      v16 = CFNumberCreate(v15, kCFNumberSInt64Type, &valuePtr);
      if (v16)
      {
        v17 = CFGetAllocator(cf);
        Virtual = _IOHIDServiceClientCreateVirtual(v17, (__IOHIDEventSystemClient *)cf, v16, a3, a4, a5);
        if (Virtual)
          CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 13), valuePtr, Virtual);
        else
          io_hideventsystem_remove_virtual_service(*((_DWORD *)cf + 8), (uint64_t)valuePtr);
      }
      else
      {
        Virtual = 0;
      }
    }
    os_unfair_recursive_lock_unlock();
    if (v12)
      CFRelease(v12);
    if (v16)
      CFRelease(v16);
  }
  else
  {
    v21 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      IOHIDVirtualServiceClientCreateWithCallbacks_cold_1();
    return 0;
  }
  return Virtual;
}

HIDServiceClient *_IOHIDServiceClientCreateVirtual(const __CFAllocator *a1, __IOHIDEventSystemClient *a2, const void *a3, __int128 *a4, void *a5, void *a6)
{
  HIDServiceClient *Private;
  char *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  if (!a3)
    return 0;
  Private = _IOHIDServiceClientCreatePrivate();
  if (!Private)
    return Private;
  v13 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0x10800405737D6B9uLL);
  Private->_client.virtualService.callbacks = (__IOHIDVirtualServiceClientCallbacksV2 *)v13;
  if (!v13)
  {
    CFRelease(Private);
    return 0;
  }
  v14 = *a4;
  v15 = a4[1];
  if (*(_QWORD *)a4 == 2)
  {
    v16 = a4[2];
    *((_QWORD *)v13 + 6) = *((_QWORD *)a4 + 6);
    *((_OWORD *)v13 + 1) = v15;
    *((_OWORD *)v13 + 2) = v16;
    *(_OWORD *)v13 = v14;
  }
  else
  {
    *((_QWORD *)v13 + 5) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(v13 + 24) = v15;
    *(_OWORD *)(v13 + 8) = v14;
  }
  Private->_client.system = a2;
  Private->_client.virtualService.target = a5;
  Private->_client.virtualService.refcon = a6;
  Private->_client.serviceID = (void *)CFRetain(a3);
  Private->_client.cachedProperties = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Private->_client.serviceLock = 0;
  Private->_client.callbackLock = 0;
  return Private;
}

uint64_t io_hideventsystem_create_virtual_service(mach_port_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  mach_port_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  mach_msg_header_t msg;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  v12 = 1;
  v13 = a2;
  LODWORD(v14) = 16777472;
  HIDWORD(v14) = a3;
  v15 = *MEMORY[0x1E0C804E8];
  v16 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x1118A00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v7 = mach_msg(&msg, 3162115, 0x38u, 0x34u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (msg.msgh_id == 71)
      {
        v8 = 4294966988;
      }
      else if (msg.msgh_id == 70126)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 44)
          {
            if (!msg.msgh_remote_port)
            {
              v8 = HIDWORD(v13);
              if (!HIDWORD(v13))
              {
                *a4 = v14;
                return v8;
              }
              goto LABEL_25;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v9 = 1;
            else
              v9 = HIDWORD(v13) == 0;
            if (v9)
              v8 = 4294966996;
            else
              v8 = HIDWORD(v13);
            goto LABEL_25;
          }
        }
        v8 = 4294966996;
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&msg);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v8 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
    goto LABEL_25;
  }
  return v8;
}

uint64_t __IOHIDServiceNotification(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  const __CFAllocator *v5;
  CFSetRef v6;
  CFSetRef v7;
  NSObject *global_queue;
  _QWORD *v9;
  CFIndex Count;
  const __CFAllocator *v11;
  CFSetRef Copy;
  CFSetRef v13;
  _QWORD v14[6];
  _QWORD v15[6];
  uint64_t v16;
  _OWORD v17[5];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v4 = result;
  _IOHIDDebugTrace(8260, 0, result, a3, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(v4 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v16, v17);
  ++**(_DWORD **)(v4 + 72);
  switch(a3)
  {
    case 0xE0000010:
      Count = CFSetGetCount(*(CFSetRef *)(v4 + 104));
      __IOHIDServiceCompleteInProgressEvents((CFTypeRef *)v4);
      *(_DWORD *)(v4 + 224) |= 1u;
      if (Count)
      {
        v11 = CFGetAllocator(*(CFTypeRef *)(v4 + 104));
        Copy = CFSetCreateCopy(v11, *(CFSetRef *)(v4 + 104));
        if (Copy)
        {
          v13 = Copy;
          CFRetain((CFTypeRef)v4);
          global_queue = dispatch_get_global_queue(0, 0);
          v14[0] = MEMORY[0x1E0C809B0];
          v14[1] = 0x40000000;
          v14[2] = ____IOHIDServiceNotification_block_invoke_2;
          v14[3] = &__block_descriptor_tmp_199;
          v14[4] = v13;
          v14[5] = v4;
          v9 = v14;
          goto LABEL_12;
        }
      }
      break;
    case 0xE0000100:
      __IOHIDServiceCompleteInProgressEvents((CFTypeRef *)v4);
      break;
    case 0xE0000130:
      if (CFSetGetCount(*(CFSetRef *)(v4 + 112)))
      {
        v5 = CFGetAllocator(*(CFTypeRef *)(v4 + 112));
        v6 = CFSetCreateCopy(v5, *(CFSetRef *)(v4 + 112));
        if (v6)
        {
          v7 = v6;
          CFRetain((CFTypeRef)v4);
          global_queue = dispatch_get_global_queue(0, 0);
          v15[0] = MEMORY[0x1E0C809B0];
          v15[1] = 0x40000000;
          v15[2] = ____IOHIDServiceNotification_block_invoke;
          v15[3] = &__block_descriptor_tmp_198;
          v15[4] = v7;
          v15[5] = v4;
          v9 = v15;
LABEL_12:
          dispatch_async(global_queue, v9);
        }
      }
      break;
  }
  result = *(_QWORD *)(v4 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v16, v17);
  }
  return result;
}

void __IOHIDServiceCompleteInProgressEvents(CFTypeRef *cf)
{
  CFAllocatorRef v2;
  uint64_t v3;
  HIDEvent *ScrollEvent;
  HIDEvent *v5;
  uint64_t v6;
  uint64_t v7;
  CFAllocatorRef v8;
  uint64_t v9;
  HIDEvent *DigitizerEvent;
  uint64_t v11;
  uint64_t v12;
  HIDEvent *v13;
  const __CFAllocator *v14;
  const __CFSet *Copy;
  const __CFSet *v16;
  uint64_t i;
  CFAllocatorRef v18;
  uint64_t v19;
  HIDEvent *v20;
  uint64_t v21;
  uint64_t v22;
  HIDEvent *v23;
  CFAllocatorRef v24;
  uint64_t v25;
  HIDEvent *v26;
  uint64_t v27;
  uint64_t v28;
  HIDEvent *v29;

  if (*((_DWORD *)cf + 72))
  {
    v2 = CFGetAllocator(cf);
    v3 = mach_absolute_time();
    ScrollEvent = IOHIDEventCreateScrollEvent((uint64_t)v2, v3, 0x800000, 0.0, 0.0, 0.0);
    if (ScrollEvent)
    {
      v5 = ScrollEvent;
      IOHIDEventSetScrollMomentum((uint64_t)ScrollEvent, 4);
      __IOHIDServiceEventCallback((uint64_t)cf, v6, v7, v5);
      CFRelease(v5);
    }
  }
  if (*((_DWORD *)cf + 73))
  {
    v8 = CFGetAllocator(cf);
    v9 = mach_absolute_time();
    DigitizerEvent = IOHIDEventCreateDigitizerEvent((uint64_t)v8, v9, 0, 0, 0, 8, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0x800000);
    if (DigitizerEvent)
    {
      v13 = DigitizerEvent;
      __IOHIDServiceEventCallback((uint64_t)cf, v11, v12, DigitizerEvent);
      CFRelease(v13);
    }
  }
  v14 = CFGetAllocator(cf[33]);
  Copy = CFSetCreateCopy(v14, (CFSetRef)cf[33]);
  if (Copy)
  {
    v16 = Copy;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDServiceCompleteEventsInProgressApplier, cf);
    CFRelease(v16);
  }
  if (cf[34])
  {
    for (i = 0; i != 64; ++i)
    {
      if ((((unint64_t)cf[34] >> i) & 1) != 0)
      {
        v18 = CFGetAllocator(cf);
        v19 = mach_absolute_time();
        v20 = IOHIDEventCreate((uint64_t)v18, i, v19, 0x800000);
        if (v20)
        {
          v23 = v20;
          __IOHIDServiceEventCallback((uint64_t)cf, v21, v22, v20);
          CFRelease(v23);
        }
      }
    }
  }
  v24 = CFGetAllocator(cf);
  v25 = mach_absolute_time();
  v26 = IOHIDEventCreate((uint64_t)v24, 0, v25, 0x800000);
  if (v26)
  {
    v29 = v26;
    __IOHIDServiceEventCallback((uint64_t)cf, v27, v28, v26);
    CFRelease(v29);
  }
}

uint64_t IOHIDEventSystemClientActivate(uint64_t result)
{
  BOOL v1;
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  __CFMachPort *v6;

  if (*(_QWORD *)(result + 400))
    v1 = *(_QWORD *)(result + 384) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
  }
  v2 = result;
  v3 = (unsigned int *)(result + 312);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if ((v4 & 1) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    v5 = *(_QWORD *)(v2 + 40);
    if (v5)
      IOMIGMachPortScheduleWithDispatchQueue(v5, *(NSObject **)(v2 + 400));
    CFMachPortGetPort(*(CFMachPortRef *)(v2 + 280));
    dispatch_mach_connect();
    v6 = *(__CFMachPort **)(v2 + 56);
    if (v6)
    {
      CFMachPortGetPort(v6);
      dispatch_mach_connect();
    }
    os_unfair_recursive_lock_unlock();
    __IOHIDEventSystemClientStartQueue(v2);
    return __IOHIDEventSystemClientStartFilter(v2);
  }
  return result;
}

uint64_t IOHIDServiceFilterFilterCopyEvent(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t v6;
  uint64_t result;
  const __CFString *v8;
  NSObject *v9;
  int Type;
  uint64_t SenderID;
  uint64_t v12;
  _DWORD v13[2];
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  const __CFString *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v4 = a1[2];
  if (v4 && (v5 = *(uint64_t (**)(void))(*(_QWORD *)v4 + 48)) != 0
    || (v6 = a1[3]) != 0 && (v5 = *(uint64_t (**)(void))(*(_QWORD *)v6 + 48)) != 0)
  {
    result = v5();
    if (result)
      return result;
    v8 = _IOHIDEventDebugInfo(a2);
    v9 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      Type = IOHIDEventGetType((uint64_t)a2);
      SenderID = _IOHIDServiceGetSenderID(a1[6]);
      v12 = a1[11];
      v13[0] = 67109890;
      v13[1] = Type;
      v14 = 2048;
      v15 = SenderID;
      v16 = 2112;
      v17 = v8;
      v18 = 2112;
      v19 = v12;
      _os_log_impl(&dword_18AAAF000, v9, OS_LOG_TYPE_INFO, "Copy Event filtered type:%d sender:0x%llx eventInfo:(%@) service filter:%@", (uint8_t *)v13, 0x26u);
    }
    CFRelease(v8);
    return 0;
  }
  return (uint64_t)a2;
}

void processRemoteMsg(void *a1)
{
  uint64_t v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BOOL8 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v2 = MEMORY[0x18D773128]();
  if (v2 == MEMORY[0x1E0C812F8])
  {
    if (xpc_dictionary_get_value(a1, "assertionCheck"))
    {
      processCheckAssertionsMsg(a1);
    }
    else if (xpc_dictionary_get_value(a1, "assertionTimeout"))
    {
      processAssertionTimeout(a1);
    }
    else if (xpc_dictionary_get_value(a1, "assertionUpdateActivity"))
    {
      processAssertionUpdateActivity(a1);
    }
    else if (xpc_dictionary_get_value(a1, "assertionUpdateActives"))
    {
      processCurrentActiveAssertions(a1);
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        processRemoteMsg_cold_2();
    }
    else
    {
      v27 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v27)
        processRemoteMsg_cold_1(v27, v28, v29, v30, v31, v32, v33, v34);
    }
  }
  else if (v2 == MEMORY[0x1E0C81310])
  {
    if (a1 == (void *)MEMORY[0x1E0C81258])
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          processRemoteMsg_cold_4();
      }
      else
      {
        v11 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v11)
          processRemoteMsg_cold_3(v11, v12, v13, v14, v15, v16, v17, v18);
      }
      if (gAssertionConnection)
      {
        xpc_release((xpc_object_t)gAssertionConnection);
        gAssertionConnection = 0;
        gAsyncModeSetupDone = 0;
        gCurrentRemoteAssertion = 0;
        gCurrentAssertion = 0;
        gCurrentRemoteAssertionIsCoalesced = 0;
      }
    }
    else if (a1 == (void *)MEMORY[0x1E0C81260])
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          processRemoteMsg_cold_4();
      }
      else
      {
        v19 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v19)
          processRemoteMsg_cold_3(v19, v20, v21, v22, v23, v24, v25, v26);
      }
      if (gAssertionConnection)
      {
        xpc_release((xpc_object_t)gAssertionConnection);
        gAssertionConnection = 0;
        gAsyncModeSetupDone = 0;
      }
    }
    else
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          processRemoteMsg_cold_8();
      }
      else
      {
        v3 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v3)
          processRemoteMsg_cold_7(v3, v4, v5, v6, v7, v8, v9, v10);
      }
      gAsyncMode = 0;
    }
  }
}

BOOL IOPSDrawingUnlimitedPower()
{
  uint64_t v1;
  int out_token;

  out_token = 0;
  v1 = 0;
  if (notify_register_check("com.apple.system.powersources.percent", &out_token))
    return 1;
  notify_get_state(out_token, &v1);
  notify_cancel(out_token);
  return (v1 & 0x90000) != 0x80000;
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 168) = a2;
  *(_QWORD *)(a1 + 184) = a3;
  *(_QWORD *)(a1 + 192) = a4;
  return os_unfair_recursive_lock_unlock();
}

uint64_t io_connect_get_service(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  mach_msg_header_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  *(_QWORD *)&v5.msgh_bits = 0x1800001513;
  *(_QWORD *)&v5.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v5.msgh_voucher_port = 0xB0100000000;
  v1 = mach_msg2_internal();
  v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t io_connect_map_memory_into_task(unsigned int a1, int a2, int a3, uint64_t *a4, uint64_t *a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  mach_msg_header_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  v10 = 1;
  v11 = a3;
  v12 = 0x13000000000000;
  v13 = *MEMORY[0x1E0C804E8];
  v14 = a2;
  v15 = *a4;
  v16 = *a5;
  v17 = a6;
  *(_QWORD *)&v9.msgh_bits = 0x4880001513;
  *(_QWORD *)&v9.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v9.msgh_voucher_port = 0xB2F00000000;
  v6 = mach_msg2_internal();
  v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v9.msgh_local_port);
  }
  else if ((_DWORD)v6)
  {
    mig_dealloc_reply_port(v9.msgh_local_port);
  }
  else
  {
    v7 = 4294966995;
    mach_msg_destroy(&v9);
  }
  return v7;
}

uint64_t io_registry_entry_get_path(unsigned int a1, const char *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  _OWORD v9[33];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(v9, 0, 480);
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  else
    v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v8 = 0xB0A00000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

void processAssertionUpdateActivity(void *a1)
{
  uint64_t v2;
  uint8_t *v3;
  NSObject *v4;
  xpc_object_t reply;
  void *v6;
  uint64_t uint64;
  void *v8;
  _BOOL8 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL8 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  __int16 v26;

  v2 = assertions_log;
  if (assertions_log)
  {
    if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_7;
    v26 = 0;
    v3 = (uint8_t *)&v26;
    v4 = v2;
  }
  else
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_7;
    v25 = 0;
    v4 = MEMORY[0x1E0C81028];
    v3 = (uint8_t *)&v25;
  }
  _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_DEFAULT, "Powerd has requested assertion activity update", v3, 2u);
LABEL_7:
  if (gAssertionConnection)
  {
    reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      v6 = reply;
      uint64 = xpc_dictionary_get_uint64(a1, "assertionCheckToken");
      xpc_dictionary_set_uint64(v6, "assertionCheckToken", uint64);
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          processAssertionUpdateActivity_cold_6();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        processAssertionUpdateActivity_cold_5();
      }
      if (gAsyncAssertionActivityLog_2 && CFArrayGetCount((CFArrayRef)gAsyncAssertionActivityLog_1))
      {
        v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        xpc_dictionary_set_value(v6, "assertionActivityLog", v8);
        if (gAsyncAssertionActivityLog_2 >= 0x19)
          xpc_dictionary_set_BOOL(v6, "assertionActivityUpdateOverflow", 1);
        xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v6);
        if (v8)
          xpc_release(v8);
      }
      else
      {
        xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v6);
      }
      xpc_release(v6);
      gAsyncAssertionActivityLog_2 = 0;
      gAsyncAssertionActivityLog_0 = 0;
      if (gAsyncAssertionActivityLog_1)
        CFArrayRemoveAllValues((CFMutableArrayRef)gAsyncAssertionActivityLog_1);
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        processAssertionUpdateActivity_cold_4();
    }
    else
    {
      v17 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v17)
        processAssertionUpdateActivity_cold_3(v17, v18, v19, v20, v21, v22, v23, v24);
    }
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      processAssertionUpdateActivity_cold_2();
  }
  else
  {
    v9 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v9)
      processAssertionUpdateActivity_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
  }
}

void offloadAssertions(char a1)
{
  _BOOL8 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v11;
  NSObject *v12;
  void *v13;
  CFTypeID TypeID;
  const __CFNumber *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  uint32_t v21;
  int v22;
  CFNumberRef v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  _BOOL8 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFNumberRef v35;
  unint64_t v36;
  NSObject *v37;
  void *value;
  int v39;
  uint64_t valuePtr;
  uint8_t v41[4];
  uint64_t v42;
  uint8_t buf[4];
  _QWORD v44[3];
  uint8_t v45[4];
  _DWORD v46[3];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!gAsyncMode)
    return;
  valuePtr = 0;
  v39 = 0;
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      offloadAssertions_cold_8();
  }
  else
  {
    v2 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
    if (v2)
      offloadAssertions_cold_7(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (!gCurrentAssertion
    && (int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) <= 0
    && gAsyncAssertionActivityLog_2 != 0)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        offloadAssertions_cold_6();
    }
    else
    {
      v27 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (v27)
        offloadAssertions_cold_5(v27, v28, v29, v30, v31, v32, v33, v34);
    }
    sendAsyncAssertionMsg(0, 0, &v39, 1);
    CFArrayRemoveAllValues((CFMutableArrayRef)gReleasedAssertionsList);
LABEL_60:
    if ((a1 & 1) != 0)
      return;
    goto LABEL_61;
  }
  if (gCurrentRemoteAssertion)
  {
    if (assertions_log)
    {
      if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        goto LABEL_60;
      offloadAssertions_cold_4();
      if ((a1 & 1) != 0)
        return;
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_60;
      offloadAssertions_cold_3();
      if ((a1 & 1) != 0)
        return;
    }
LABEL_61:
    nextOffload_ts = 0;
    dispatch_suspend((dispatch_object_t)gAssertionsOffloader);
    return;
  }
  v11 = 0;
  v12 = MEMORY[0x1E0C81028];
  while (1)
  {
    value = 0;
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)gActiveAssertionsDict, v11, (const void **)&value))
      goto LABEL_45;
    v13 = value;
    TypeID = CFDictionaryGetTypeID();
    if (v13)
    {
      if (CFGetTypeID(v13) == TypeID)
        break;
    }
    v18 = assertions_log;
    if (!assertions_log)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        offloadAssertions_cold_1(v45, (int)v11, v46);
      goto LABEL_45;
    }
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v44[0]) = (_DWORD)v11;
      v19 = v18;
      v20 = "Not a dictinary for 0x%x";
      v21 = 8;
LABEL_28:
      _os_log_error_impl(&dword_18AAAF000, v19, OS_LOG_TYPE_ERROR, v20, buf, v21);
    }
LABEL_45:
    if (++v11 == (char *)128)
      goto LABEL_60;
  }
  v39 = 0;
  v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)value, CFSTR("AsyncClientAssertionId"));
  CFNumberGetValue(v15, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  v16 = assertions_log;
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109378;
      LODWORD(v44[0]) = HIDWORD(valuePtr);
      WORD2(v44[0]) = 2112;
      *(_QWORD *)((char *)v44 + 6) = value;
      v17 = v16;
LABEL_48:
      _os_log_debug_impl(&dword_18AAAF000, v17, OS_LOG_TYPE_DEBUG, "Sending assertion create msg for id 0x%x:%@\n", buf, 0x12u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109378;
    LODWORD(v44[0]) = HIDWORD(valuePtr);
    WORD2(v44[0]) = 2112;
    *(_QWORD *)((char *)v44 + 6) = value;
    v17 = v12;
    goto LABEL_48;
  }
  LODWORD(valuePtr) = sendAsyncAssertionMsg(1, (uint64_t)value, &v39, 1);
  CFArrayRemoveAllValues((CFMutableArrayRef)gReleasedAssertionsList);
  v22 = v39;
  if (v39 || !(_DWORD)valuePtr)
  {
    v25 = assertions_log;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109378;
        LODWORD(v44[0]) = v22;
        WORD2(v44[0]) = 2112;
        *(_QWORD *)((char *)v44 + 6) = value;
        v26 = v25;
        goto LABEL_50;
      }
    }
    else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      LODWORD(v44[0]) = v22;
      WORD2(v44[0]) = 2112;
      *(_QWORD *)((char *)v44 + 6) = value;
      v26 = v12;
LABEL_50:
      _os_log_error_impl(&dword_18AAAF000, v26, OS_LOG_TYPE_ERROR, "powerd returned err 0x%x to create assertion %@. Dropping the assertion\n", buf, 0x12u);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gActiveAssertionsDict, v11);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gAssertionsDict, v11);
    goto LABEL_45;
  }
  v23 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  v24 = assertions_log;
  if (!v23)
  {
    if (!assertions_log)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        offloadAssertions_cold_2(v41, (uint64_t *)&value, &v42);
      goto LABEL_45;
    }
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v44[0] = value;
      v19 = v24;
      v20 = "Failed to create the remoteID to CF for id %@\n";
      v21 = 12;
      goto LABEL_28;
    }
    goto LABEL_45;
  }
  v35 = v23;
  if (assertions_log)
  {
    v36 = 0x1EDF7B000;
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      LODWORD(v44[0]) = valuePtr;
      WORD2(v44[0]) = 1024;
      *(_DWORD *)((char *)v44 + 6) = HIDWORD(valuePtr);
      v37 = v24;
      goto LABEL_68;
    }
  }
  else
  {
    v36 = 0x1EDF7B000uLL;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      LODWORD(v44[0]) = valuePtr;
      WORD2(v44[0]) = 1024;
      *(_DWORD *)((char *)v44 + 6) = HIDWORD(valuePtr);
      v37 = MEMORY[0x1E0C81028];
LABEL_68:
      _os_log_impl(&dword_18AAAF000, v37, OS_LOG_TYPE_DEFAULT, "powerd returned assertion id 0x%x for async id 0x%x \n", buf, 0xEu);
    }
  }
  gCurrentAssertion = HIDWORD(valuePtr);
  *(_DWORD *)(v36 + 3584) = valuePtr;
  gCurrentRemoteAssertionIsCoalesced = (int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) > 1;
  CFDictionarySetValue((CFMutableDictionaryRef)value, CFSTR("AsyncRemoteAssertionId"), v35);
  CFRelease(v35);
  if ((a1 & 1) == 0)
    goto LABEL_61;
}

uint64_t sendAsyncAssertionMsg(int a1, uint64_t a2, _DWORD *a3, int a4)
{
  xpc_object_t v8;
  void *v9;
  int v10;
  void *v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t uint64;
  NSObject *v29;
  void *v30;
  xpc_object_t v31;
  _BOOL8 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BOOL8 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _BOOL8 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;

  if (!gAssertionConnection)
    initialSetup();
  v8 = xpc_dictionary_create(0, 0, 0);
  if (!v8)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        sendAsyncReleaseMsg_cold_2();
    }
    else
    {
      v12 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v12)
        sendAsyncReleaseMsg_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
    return 0;
  }
  v9 = v8;
  if (gAsyncAssertionActivityLog_2)
    v10 = a4;
  else
    v10 = 0;
  if (!a2 && (v10 & 1) == 0)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
        sendAsyncAssertionMsg_cold_12();
    }
    else
    {
      v20 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v20)
        sendAsyncAssertionMsg_cold_11(v20, v21, v22, v23, v24, v25, v26, v27);
    }
    return 0;
  }
  if (a2)
  {
    v11 = (void *)_CFXPCCreateXPCMessageWithCFObject();
    if (!v11)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          sendAsyncAssertionMsg_cold_4();
      }
      else
      {
        v33 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v33)
          sendAsyncAssertionMsg_cold_3(v33, v34, v35, v36, v37, v38, v39, v40);
      }
      return 0;
    }
  }
  else
  {
    v11 = 0;
  }
  if (v10)
  {
    v29 = assertions_log;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        sendAsyncReleaseMsg_cold_6(v29);
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      sendAsyncReleaseMsg_cold_5();
    }
    v30 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(v9, "assertionActivityLog", v30);
    if (a1)
      goto LABEL_37;
LABEL_31:
    if (a2)
      xpc_dictionary_set_value(v9, "assertionProperties", v11);
    xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v9);
    v31 = 0;
    goto LABEL_39;
  }
  v30 = 0;
  if (!a1)
    goto LABEL_31;
LABEL_37:
  xpc_dictionary_set_value(v9, "assertionCreate", v11);
  v31 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)gAssertionConnection, v9);
  if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
  {
    uint64 = xpc_dictionary_get_uint64(v31, "assertionId");
    if (a3)
      *a3 = xpc_dictionary_get_uint64(v31, "returnCode");
    goto LABEL_40;
  }
  if (MEMORY[0x18D773128](v31) == MEMORY[0x1E0C81310])
  {
    if (v31 == (xpc_object_t)MEMORY[0x1E0C81258])
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          sendAsyncAssertionMsg_cold_6();
      }
      else
      {
        v41 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v41)
          sendAsyncAssertionMsg_cold_5(v41, v42, v43, v44, v45, v46, v47, v48);
      }
      uint64 = 0;
      v31 = (xpc_object_t)MEMORY[0x1E0C81258];
      goto LABEL_40;
    }
    if (v31 == (xpc_object_t)MEMORY[0x1E0C81260])
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          sendAsyncAssertionMsg_cold_8();
      }
      else
      {
        v49 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v49)
          sendAsyncAssertionMsg_cold_7(v49, v50, v51, v52, v53, v54, v55, v56);
      }
      uint64 = 0;
      v31 = (xpc_object_t)MEMORY[0x1E0C81260];
      goto LABEL_40;
    }
  }
LABEL_39:
  uint64 = 0;
LABEL_40:
  if (v11)
    xpc_release(v11);
  if (v30)
    xpc_release(v30);
  if (v31)
    xpc_release(v31);
  if (v10)
  {
    gAsyncAssertionActivityLog_2 = 0;
    gAsyncAssertionActivityLog_0 = 0;
    if (gAsyncAssertionActivityLog_1)
      CFArrayRemoveAllValues((CFMutableArrayRef)gAsyncAssertionActivityLog_1);
  }
  xpc_release(v9);
  return uint64;
}

void IOHIDEventSystemClientRegisterResetCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableArrayRef Mutable;
  CFDataRef v10;
  CFDataRef v11;
  UInt8 bytes[8];
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)bytes = a2;
  v13 = a3;
  v14 = a4;
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (*(_QWORD *)(a1 + 136)
      || (Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]), (*(_QWORD *)(a1 + 136) = Mutable) != 0))
    {
      if (__IOHIDEventSystemClientFindCallback(a1, a2, a3, a4) == -1)
      {
        v10 = CFDataCreate(0, bytes, 24);
        if (v10)
        {
          v11 = v10;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 136), v10);
          os_unfair_recursive_lock_unlock();
          CFRelease(v11);
        }
        else
        {
          os_unfair_recursive_lock_unlock();
        }
      }
      else
      {
        os_unfair_recursive_lock_unlock();
      }
    }
  }
}

uint64_t __IOHIDEventSystemClientFindCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFIndex v8;
  const __CFArray *v9;
  const __CFData *ValueAtIndex;
  const __CFData *v11;
  CFTypeID TypeID;
  const UInt8 *BytePtr;

  os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 160));
  v8 = -1;
  if (a2)
  {
    v9 = *(const __CFArray **)(a1 + 136);
    if (v9)
    {
      if (CFArrayGetCount(v9) >= 1)
      {
        v8 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), v8);
          if (ValueAtIndex)
          {
            v11 = ValueAtIndex;
            TypeID = CFDataGetTypeID();
            if (TypeID == CFGetTypeID(v11))
            {
              BytePtr = CFDataGetBytePtr(v11);
              if (*(_QWORD *)BytePtr == a2 && *((_QWORD *)BytePtr + 1) == a3 && *((_QWORD *)BytePtr + 2) == a4)
                break;
            }
          }
          if (++v8 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 136)))
            return -1;
        }
      }
    }
  }
  return v8;
}

uint64_t IOPSGetPercentRemaining(int *a1, BOOL *a2, _BYTE *a3)
{
  uint64_t v6;
  __CFBundle *MainBundle;
  const __CFString *Identifier;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v13;
  int out_token;

  v6 = 3758097089;
  out_token = 0;
  v13 = 0;
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    Identifier = CFBundleGetIdentifier(MainBundle);
    if (Identifier)
    {
      if (!CFStringHasPrefix(Identifier, CFSTR("com.apple.")))
        return v6;
    }
  }
  if (!a1)
    return 3758097090;
  if (notify_register_check("com.apple.system.powersources.percent", &out_token))
  {
    v6 = 3758097097;
    goto LABEL_10;
  }
  notify_get_state(out_token, &v13);
  notify_cancel(out_token);
  v9 = v13;
  if ((v13 & 0x80000) == 0)
  {
    v6 = 3758097112;
LABEL_10:
    *a1 = 100;
    if (a2)
      *a2 = 0;
    if (a3)
    {
      LOBYTE(v10) = 1;
LABEL_20:
      *a3 = v10;
      return v6;
    }
    return v6;
  }
  v11 = v13;
  if (v13 >= 0x64uLL)
    v11 = 100;
  *a1 = v11;
  if (a2)
    *a2 = (v9 & 0x20000) != 0;
  v6 = 0;
  if (a3)
  {
    v10 = (v9 >> 21) & 1;
    goto LABEL_20;
  }
  return v6;
}

uint64_t _Xio_hideventsystem_set_properties(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  int v5;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    v4 = *MEMORY[0x1E0C804E8];
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    v5 = -300;
    goto LABEL_9;
  }
  result = _io_hideventsystem_set_properties(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v4 = *MEMORY[0x1E0C804E8];
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_10:
  *(_QWORD *)(a2 + 24) = v4;
  return result;
}

uint64_t _io_hideventsystem_set_properties(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  mach_vm_size_t v7;
  CFTypeID TypeID;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const void *v11;
  uint64_t v12;
  CFTypeID v13;
  uint64_t System;
  const void *v15;
  _QWORD context[7];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = -536870212;
  v7 = a3;
  TypeID = CFDictionaryGetTypeID();
  v9 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a2, v7, TypeID);
  if (v9)
  {
    v10 = v9;
    v11 = IOMIGMachPortCacheCopy(a1);
    if (v11)
    {
      v12 = (uint64_t)v11;
      v13 = CFGetTypeID(v11);
      if (v13 == IOHIDEventSystemConnectionGetTypeID())
      {
        System = _IOHIDEventSystemConnectionGetSystem(v12);
        if (CFDictionaryGetCount(v10))
        {
          *((_DWORD *)v19 + 6) = 0;
          context[0] = MEMORY[0x1E0C809B0];
          context[1] = 0x40000000;
          context[2] = ___io_hideventsystem_set_properties_block_invoke;
          context[3] = &unk_1E20037C8;
          context[4] = &v18;
          context[5] = v12;
          context[6] = System;
          _IOHIDCFDictionaryApplyBlock(v10, context);
        }
        else
        {
          *((_DWORD *)v19 + 6) = -536870206;
        }
      }
      else
      {
        *((_DWORD *)v19 + 6) = -536870185;
      }
      CFRelease(v10);
      v15 = (const void *)v12;
    }
    else
    {
      *((_DWORD *)v19 + 6) = -536870185;
      v15 = v10;
    }
    CFRelease(v15);
  }
  else
  {
    *((_DWORD *)v19 + 6) = -536870206;
  }
  *a4 = *((_DWORD *)v19 + 6);
  _Block_object_dispose(&v18, 8);
  return 0;
}

Boolean IOHIDEventSystemClientSetProperty(IOHIDEventSystemClientRef client, CFStringRef key, CFTypeRef property)
{
  Boolean v3;
  const __CFAllocator *v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  const __CFData *v10;
  const __CFData *v11;
  mach_port_t v12;
  const UInt8 *BytePtr;
  int Length;
  uint64_t v15;
  int v16;
  mach_port_t v17;
  const UInt8 *v18;
  int v19;
  NSObject *v20;
  int v22;
  void *values;
  void *keys;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v3 = 0;
  v29 = *MEMORY[0x1E0C80C00];
  values = (void *)property;
  keys = (void *)key;
  if (client && key && property)
  {
    if (CFSetContainsValue((CFSetRef)__propertyCache, key))
    {
      os_unfair_recursive_lock_lock_with_options();
      CFDictionarySetValue(*((CFMutableDictionaryRef *)client + 16), key, property);
      os_unfair_recursive_lock_unlock();
    }
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v8)
    {
      v9 = v8;
      v10 = (const __CFData *)_IOHIDCreateBinaryData(v7, v8);
      if (v10)
      {
        v11 = v10;
        if (CFSetContainsValue((CFSetRef)__restrictedRemapKeys, keys)
          && _IOHIDIsRestrictedRemappingProperty((const __CFString *)values)
          && IOHIDCheckAccess(kIOHIDRequestTypeListenEvent))
        {
          IOHIDRequestAccess(kIOHIDRequestTypeListenEvent);
        }
        v22 = 0;
        os_unfair_recursive_lock_lock_with_options();
        v12 = *((_DWORD *)client + 8);
        BytePtr = CFDataGetBytePtr(v11);
        Length = CFDataGetLength(v11);
        v15 = io_hideventsystem_set_properties(v12, (uint64_t)BytePtr, Length, &v22);
        v16 = v15;
        if ((_DWORD)v15 == 268435459)
        {
          if (*((_QWORD *)client + 48))
          {
            v16 = 268435459;
          }
          else
          {
            v16 = 268435459;
            if (!*((_QWORD *)client + 50))
            {
              __IOHIDEventSystemClientTerminationCallback(v15, client, 0);
              v17 = *((_DWORD *)client + 8);
              v18 = CFDataGetBytePtr(v11);
              v19 = CFDataGetLength(v11);
              v16 = io_hideventsystem_set_properties(v17, (uint64_t)v18, v19, &v22);
            }
          }
        }
        os_unfair_recursive_lock_unlock();
        if (v16 | v22)
        {
          v20 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109376;
            v26 = v16;
            v27 = 1024;
            v28 = v22;
            _os_log_impl(&dword_18AAAF000, v20, OS_LOG_TYPE_INFO, "io_hideventsystem_set_properties:0x%08x result:%d", buf, 0xEu);
          }
          v3 = 0;
        }
        else
        {
          v3 = 1;
        }
        CFRelease(v11);
      }
      else
      {
        v3 = 0;
      }
      CFRelease(v9);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t io_hideventsystem_set_properties(mach_port_t a1, uint64_t a2, int a3, int *a4)
{
  mach_port_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  mach_msg_header_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v12 = 1;
  v13 = a2;
  v14 = 16777472;
  v15 = a3;
  v16 = *MEMORY[0x1E0C804E8];
  v17 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v11.msgh_bits = 2147489043;
  v11.msgh_remote_port = a1;
  v11.msgh_local_port = special_reply_port;
  *(_QWORD *)&v11.msgh_voucher_port = 0x1117D00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v11);
    special_reply_port = v11.msgh_local_port;
  }
  v7 = mach_msg(&v11, 3162115, 0x38u, 0x30u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (v11.msgh_id == 71)
      {
        v8 = 4294966988;
      }
      else if (v11.msgh_id == 70113)
      {
        if ((v11.msgh_bits & 0x80000000) == 0)
        {
          if (v11.msgh_size == 40)
          {
            if (!v11.msgh_remote_port)
            {
              v8 = HIDWORD(v13);
              if (!HIDWORD(v13))
              {
                *a4 = v14;
                return v8;
              }
              goto LABEL_25;
            }
          }
          else if (v11.msgh_size == 36)
          {
            if (v11.msgh_remote_port)
              v9 = 1;
            else
              v9 = HIDWORD(v13) == 0;
            if (v9)
              v8 = 4294966996;
            else
              v8 = HIDWORD(v13);
            goto LABEL_25;
          }
        }
        v8 = 4294966996;
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&v11);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v8 - 268435459) <= 1)
  {
    if ((v11.msgh_bits & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v11.msgh_local_port);
    goto LABEL_25;
  }
  return v8;
}

void IOHIDEventSystemClientSetMatching(uint64_t a1, void *a2)
{
  const __CFArray *v3;
  void *values;

  values = a2;
  if (a2)
  {
    v3 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    IOHIDEventSystemClientSetMatchingMultiple(a1, v3);
    if (v3)
      CFRelease(v3);
  }
  else
  {
    IOHIDEventSystemClientSetMatchingMultiple(a1, 0);
  }
}

uint64_t io_registry_entry_get_child_iterator(unsigned int a1, const char *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  mach_port_t reply_port[4];
  __int128 v8;
  _OWORD v9[8];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)reply_port = 0u;
  v8 = 0u;
  *((_QWORD *)&v8 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  else
    v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(_QWORD *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v8 = 0xAFD00000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

void processAssertionTimeout_cold_12()
{
  NSObject *v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_28(&dword_18AAAF000, v0, (uint64_t)v0, "Received a release not for gCurrentRemoteAssertion:0x%x. Received 0x%x", v1);
  OUTLINED_FUNCTION_3();
}

void processAssertionTimeout(void *a1)
{
  int uint64;
  int v2;
  uint64_t v3;
  NSObject *v4;
  const void *v5;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  const __CFString *v8;
  NSObject *PMQueue;
  int v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  uint64 = xpc_dictionary_get_uint64(a1, "assertionTimeout");
  v2 = gCurrentRemoteAssertion;
  v3 = assertions_log;
  if (gCurrentRemoteAssertion == uint64)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
      {
        v10 = 67109376;
        v11 = uint64;
        v12 = 1024;
        v13 = gCurrentAssertion;
        v4 = v3;
LABEL_10:
        _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_DEFAULT, "Current assertion has been released by powerd gCurrentRemoteAssertion 0x%x gCurrentAssertion 0x%x", (uint8_t *)&v10, 0xEu);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v10 = 67109376;
      v11 = uint64;
      v12 = 1024;
      v13 = gCurrentAssertion;
      v4 = MEMORY[0x1E0C81028];
      goto LABEL_10;
    }
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      processAssertionTimeout_cold_12();
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    processAssertionTimeout_cold_11();
  }
  v5 = (const void *)(HIWORD(gCurrentAssertion) & 0x7FFF);
  Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)gAssertionsDict, v5);
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    removeFromTimedList(gCurrentAssertion);
    if (CFDictionaryContainsKey((CFDictionaryRef)gActiveAssertionsDict, v5))
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          processAssertionTimeout_cold_10();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        processAssertionTimeout_cold_9();
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gActiveAssertionsDict, v5);
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        processAssertionTimeout_cold_8();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      processAssertionTimeout_cold_7();
    }
    if (CFDictionaryContainsValue(Value, CFSTR("TimeoutAction")))
      v8 = (const __CFString *)CFDictionaryGetValue(Value, CFSTR("TimeoutAction"));
    else
      v8 = CFSTR("TimeoutActionTurnOff");
    if (CFStringCompare(v8, CFSTR("TimeoutActionRelease"), 0))
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          processAssertionTimeout_cold_6();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        processAssertionTimeout_cold_5();
      }
      CFDictionarySetValue((CFMutableDictionaryRef)gInactiveAssertionsDict, v5, Value);
    }
    else
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          processAssertionTimeout_cold_4();
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        processAssertionTimeout_cold_3();
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gAssertionsDict, v5);
    }
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      processAssertionTimeout_cold_2();
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    processAssertionTimeout_cold_1();
  }
  if (v2 == uint64)
  {
    gCurrentAssertion = 0;
    gCurrentRemoteAssertion = 0;
    gCurrentRemoteAssertionIsCoalesced = 0;
  }
  PMQueue = getPMQueue();
  dispatch_async(PMQueue, &__block_literal_global_79);
}

uint64_t io_pm_assertion_copy_details(mach_port_t a1, unsigned int a2, unsigned int a3, uint64_t a4, int a5, _QWORD *a6, _DWORD *a7, _DWORD *a8)
{
  mach_port_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  mach_msg_header_t msg;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  __int128 v23;

  msg.msgh_id = 0;
  v22 = 0;
  v23 = 0u;
  *(_OWORD *)&msg.msgh_size = 0u;
  v18 = 1;
  v19 = a4;
  v20 = 16777472;
  v21 = a5;
  v22 = *MEMORY[0x1E0C804E8];
  *(_QWORD *)&v23 = __PAIR64__(a3, a2);
  DWORD2(v23) = a5;
  special_reply_port = mig_get_special_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x11D3200000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3162115, 0x40u, 0x44u, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 73110)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v14 = 4294966996;
            if (HIDWORD(v19))
            {
              if (msg.msgh_remote_port)
                v14 = 4294966996;
              else
                v14 = HIDWORD(v19);
            }
          }
          else
          {
            v14 = 4294966996;
          }
          goto LABEL_24;
        }
        v14 = 4294966996;
        if (v18 == 1 && msg.msgh_size == 60 && !msg.msgh_remote_port && HIBYTE(v20) == 1)
        {
          v15 = v21;
          if (v21 == (_DWORD)v23)
          {
            v14 = 0;
            *a6 = v19;
            *a7 = v15;
            *a8 = DWORD1(v23);
            return v14;
          }
        }
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

uint64_t io_connect_unmap_memory_from_task(unsigned int a1, int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  mach_msg_header_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v8 = 1;
  v9 = a3;
  v10 = 0x13000000000000;
  v11 = *MEMORY[0x1E0C804E8];
  v12 = a2;
  v13 = a4;
  *(_QWORD *)&v7.msgh_bits = 0x3C80001513;
  *(_QWORD *)&v7.msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(_QWORD *)&v7.msgh_voucher_port = 0xB3000000000;
  v4 = mach_msg2_internal();
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v7.msgh_local_port);
  }
  else if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(v7.msgh_local_port);
  }
  else
  {
    v5 = 4294966995;
    mach_msg_destroy(&v7);
  }
  return v5;
}

void handleAssertionTimeout()
{
  uint64_t MonotonicTime;
  CFIndex v1;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  const __CFNumber *v4;
  const __CFNumber *v5;
  unsigned int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  const __CFString *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  const __CFNumber *v15;
  _BOOL8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const __CFDictionary *v24;
  const __CFNumber *v25;
  NSObject *v26;
  dispatch_time_t v27;
  _BOOL8 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFAllocator *allocator;
  unsigned int v37;
  unsigned int v38;
  uint64_t valuePtr;
  uint8_t v40[4];
  int v41[3];
  uint8_t buf[4];
  unsigned int v43;
  __int16 v44;
  const __CFDictionary *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  MonotonicTime = getMonotonicTime();
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      handleAssertionTimeout_cold_9();
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    handleAssertionTimeout_cold_8();
  }
  valuePtr = 0;
  if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) >= 1)
  {
    v1 = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, v1);
      Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TimeoutTimeStamp"));
      CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
      v4 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("AsyncClientAssertionId"));
      v38 = 0;
      CFNumberGetValue(v4, kCFNumberSInt32Type, &v38);
      if (valuePtr > MonotonicTime)
      {
LABEL_42:
        while ((_DWORD)v1)
        {
          CFArrayRemoveValueAtIndex((CFMutableArrayRef)gTimedAssertionsList, 0);
          LODWORD(v1) = v1 - 1;
        }
        goto LABEL_44;
      }
      if (!CFDictionaryContainsKey(ValueAtIndex, CFSTR("AsyncRemoteAssertionId")))
        break;
      v5 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("AsyncRemoteAssertionId"));
      v37 = 0;
      CFNumberGetValue(v5, kCFNumberIntType, &v37);
      v6 = v37;
      if (v37 != gCurrentRemoteAssertion)
        break;
      v7 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          v43 = v6;
          v8 = v7;
LABEL_33:
          _os_log_impl(&dword_18AAAF000, v8, OS_LOG_TYPE_DEFAULT, "Powerd knows about this assertion 0x%0x. let powerd time it out", buf, 8u);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v43 = v6;
        v8 = MEMORY[0x1E0C81028];
        goto LABEL_33;
      }
LABEL_36:
      if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) <= ++v1)
        goto LABEL_42;
    }
    v9 = assertions_log;
    if (assertions_log)
    {
      if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        goto LABEL_18;
      *(_DWORD *)buf = 67109376;
      v43 = v38;
      v44 = 2048;
      v45 = (const __CFDictionary *)valuePtr;
      v10 = v9;
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
        goto LABEL_18;
      *(_DWORD *)buf = 67109376;
      v43 = v38;
      v44 = 2048;
      v45 = (const __CFDictionary *)valuePtr;
      v10 = MEMORY[0x1E0C81028];
    }
    _os_log_debug_impl(&dword_18AAAF000, v10, OS_LOG_TYPE_DEBUG, "Timeout: assertion id 0x%x with time %llu", buf, 0x12u);
LABEL_18:
    logAsyncAssertionActivity(2u, v38);
    if (CFDictionaryContainsValue(ValueAtIndex, CFSTR("TimeoutAction")))
      v11 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TimeoutAction"));
    else
      v11 = CFSTR("TimeoutActionTurnOff");
    if (CFStringCompare(v11, CFSTR("TimeoutActionRelease"), 0) == kCFCompareEqualTo)
    {
      if (_releaseAsycnAssertion(v38, 0, 0))
      {
        v14 = assertions_log;
        if (assertions_log)
        {
          if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            v43 = v38;
            _os_log_error_impl(&dword_18AAAF000, v14, OS_LOG_TYPE_ERROR, "Failed to release assertion 0x%x on timeout", buf, 8u);
          }
        }
        else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          handleAssertionTimeout_cold_7(v40, (int *)&v38, v41);
        }
      }
      goto LABEL_36;
    }
    v12 = assertions_log;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109378;
        v43 = v38;
        v44 = 2112;
        v45 = ValueAtIndex;
        v13 = v12;
LABEL_41:
        _os_log_debug_impl(&dword_18AAAF000, v13, OS_LOG_TYPE_DEBUG, "Turning off assertion 0x%x: %@", buf, 0x12u);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109378;
      v43 = v38;
      v44 = 2112;
      v45 = ValueAtIndex;
      v13 = MEMORY[0x1E0C81028];
      goto LABEL_41;
    }
    *(_DWORD *)buf = 0;
    v15 = CFNumberCreate(allocator, kCFNumberSInt32Type, buf);
    handleAssertionLevel(v15, v38, 1);
    CFRelease(v15);
    goto LABEL_36;
  }
LABEL_44:
  if (!assertion_timer_suspended)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        insertIntoTimedList_cold_4();
    }
    else
    {
      v16 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
      if (v16)
        insertIntoTimedList_cold_3(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    dispatch_suspend((dispatch_object_t)gAssertionTimer);
    assertion_timer_suspended = 1;
  }
  if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList))
  {
    v24 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, 0);
    v25 = (const __CFNumber *)CFDictionaryGetValue(v24, CFSTR("TimeoutTimeStamp"));
    CFNumberGetValue(v25, kCFNumberSInt64Type, &valuePtr);
    v26 = gAssertionTimer;
    v27 = dispatch_time(0, 1000000000 * (valuePtr - MonotonicTime));
    dispatch_source_set_timer(v26, v27, 0xFFFFFFFFFFFFFFFFLL, 0);
    if (assertion_timer_suspended)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
          handleAssertionTimeout_cold_4();
      }
      else
      {
        v28 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
        if (v28)
          handleAssertionTimeout_cold_3(v28, v29, v30, v31, v32, v33, v34, v35);
      }
      dispatch_resume((dispatch_object_t)gAssertionTimer);
      assertion_timer_suspended = 0;
    }
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
        handleAssertionTimeout_cold_2();
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      handleAssertionTimeout_cold_1();
    }
  }
}

uint64_t _copyPMServerObject(unsigned int a1, unsigned int a2, const __CFData *a3, CFPropertyListRef *a4)
{
  uint64_t result;
  const __CFData *Data;
  const UInt8 *BytePtr;
  int v11;
  int v12;
  const __CFData *v13;
  const __CFData *v14;
  _DWORD length[3];
  mach_port_t v16;
  int v17;

  v16 = 0;
  memset(length, 0, sizeof(length));
  *a4 = 0;
  v17 = pm_connect_init(&v16);
  if (v17)
    return 3758097136;
  if (a3 && (Data = CFPropertyListCreateData(0, a3, kCFPropertyListBinaryFormat_v1_0, 0, 0), (a3 = Data) != 0))
  {
    BytePtr = CFDataGetBytePtr(Data);
    v11 = CFDataGetLength(a3);
  }
  else
  {
    BytePtr = 0;
    v11 = 0;
  }
  v12 = io_pm_assertion_copy_details(v16, a2, a1, (uint64_t)BytePtr, v11, &length[1], length, &v17);
  if (!(v12 | v17))
  {
    v13 = CFDataCreate(0, *(const UInt8 **)&length[1], length[0]);
    if (v13)
    {
      v14 = v13;
      *a4 = CFPropertyListCreateWithData(0, v13, 0, 0, 0);
      CFRelease(v14);
    }
    if (*(_QWORD *)&length[1] && length[0])
      mach_vm_deallocate(*MEMORY[0x1E0C83DA0], *(mach_vm_address_t *)&length[1], length[0]);
  }
  if (a3)
    CFRelease(a3);
  result = v16;
  if (v16)
  {
    _pm_disconnect();
    return 0;
  }
  return result;
}

void __processAssertionTimeout_block_invoke()
{
  offloadAssertions(1);
}

uint64_t __IOHIDPlugInInstanceCacheApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
}

uint64_t __IOHIDManagerRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDManagerTypeID = result;
  return result;
}

uint64_t __ApplyToDevices(CFSetRef *a1, int a2)
{
  uint64_t v3;
  const __CFAllocator *v4;
  const __CFSet *Copy;
  CFSetRef *v7;
  int v8;
  unsigned int v9;

  v7 = a1;
  v3 = 3758097084;
  v8 = a2;
  v9 = 0;
  os_unfair_recursive_lock_lock_with_options();
  if (a1[4])
  {
    v4 = CFGetAllocator(a1);
    Copy = CFSetCreateCopy(v4, a1[4]);
    os_unfair_recursive_lock_unlock();
    if (Copy)
    {
      CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDManagerDeviceApplier, &v7);
      v3 = v9;
      CFRelease(Copy);
    }
  }
  else
  {
    os_unfair_recursive_lock_unlock();
    return 3758097088;
  }
  return v3;
}

void _IOHIDPlugInInstanceCacheClear()
{
  if (__hidPlugInInstanceCache)
  {
    CFDictionaryApplyFunction((CFDictionaryRef)__hidPlugInInstanceCache, (CFDictionaryApplierFunction)__IOHIDPlugInInstanceCacheApplier, 0);
    CFDictionaryRemoveAllValues((CFMutableDictionaryRef)__hidPlugInInstanceCache);
  }
}

const __CFString *_IOHIDEventDebugInfo(_QWORD *a1)
{
  int v2;
  const __CFAllocator **v3;
  uint64_t v4;
  uint64_t v5;
  const __CFAllocator *v6;
  uint64_t EventWithOptions;
  uint64_t v8;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFAllocator *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = *(_DWORD *)(a1[13] + 4);
  switch(v2)
  {
    case 3:
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      EventWithOptions = IOHIDEventGetEventWithOptions(a1, 3, 4026531840);
      if (EventWithOptions)
        v8 = *(unsigned int *)(*(_QWORD *)(EventWithOptions + 104) + 20);
      else
        v8 = 0;
      return CFStringCreateWithFormat(v6, 0, CFSTR("keyboardPress: %d"), v8);
    case 2:
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v10 = IOHIDEventGetEventWithOptions(a1, 2, 4026531840);
      if (v10)
        v11 = *(unsigned int *)(*(_QWORD *)(v10 + 104) + 28);
      else
        v11 = 0;
      return CFStringCreateWithFormat(v9, 0, CFSTR("buttonState: %d"), v11);
    case 1:
      v3 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
      v4 = IOHIDEventGetEventWithOptions(a1, 1, 4026531840);
      if (v4)
        v5 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 104) + 16);
      else
        v5 = 0;
      v13 = *v3;
      v14 = IOHIDEventGetEventWithOptions(a1, 1, 4026531840);
      if (v14)
        v15 = *(unsigned __int16 *)(*(_QWORD *)(v14 + 104) + 18);
      else
        v15 = 0;
      v16 = IOHIDEventGetEventWithOptions(a1, 1, 4026531840);
      if (v16)
        v17 = *(unsigned int *)(*(_QWORD *)(v16 + 104) + 24);
      else
        v17 = 0;
      return CFStringCreateWithFormat(v13, 0, CFSTR("vendorUsagePage: %d vendorUsage:%d dataLength:%d"), v5, v15, v17);
    default:
      return &stru_1E2005170;
  }
}

double OUTLINED_FUNCTION_4_2(_QWORD *a1, _OWORD *a2)
{
  double result;

  *a1 = 0;
  result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

void OUTLINED_FUNCTION_4_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 8u);
}

CFTimeInterval IOPSGetTimeRemainingEstimate(void)
{
  double v0;
  uint64_t v2;
  int out_token;

  out_token = 0;
  v2 = 0;
  v0 = -2.0;
  if (!notify_register_check("com.apple.system.powersources.timeremaining", &out_token))
  {
    notify_get_state(out_token, &v2);
    notify_cancel(out_token);
    if ((v2 & 0x90000) == 0x80000)
    {
      v0 = -1.0;
      if ((v2 & 0x40000) == 0)
        return (double)(unsigned __int16)v2 * 60.0;
    }
  }
  return v0;
}

CFArrayRef IOPMCopyScheduledPowerEvents(void)
{
  const __CFArray *v1;

  v1 = 0;
  _copyPMServerObject(4u, 0, 0, (CFPropertyListRef *)&v1);
  return v1;
}

uint64_t IOPMAssertionDeclareSystemActivity(const void *a1, int *a2, int *a3)
{
  uint64_t v3;
  __CFDictionary *Mutable;

  v3 = 3758097090;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        CFDictionarySetValue(Mutable, CFSTR("AssertName"), a1);
        v3 = IOPMAssertionDeclareSystemActivityWithProperties(Mutable, a2, a3);
        if (Mutable)
          CFRelease(Mutable);
      }
    }
  }
  return v3;
}

void IOHIDManagerScheduleWithRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  __CFRunLoopSource *v6;
  IONotificationPort *v7;
  __CFRunLoopSource *RunLoopSource;

  os_unfair_recursive_lock_lock_with_options();
  if (*((_QWORD *)manager + 10) | *((_QWORD *)manager + 12))
  {
    manager = (IOHIDManagerRef)MEMORY[0x1E0C81028];
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *((_QWORD *)manager + 10) = runLoop;
  *((_QWORD *)manager + 11) = runLoopMode;
  if (runLoop)
  {
    if (*((_QWORD *)manager + 15))
    {
      v6 = (__CFRunLoopSource *)*((_QWORD *)manager + 16);
      if (v6)
      {
        CFRunLoopAddSource(runLoop, v6, runLoopMode);
        CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)manager + 16));
        CFRunLoopWakeUp(*((CFRunLoopRef *)manager + 10));
      }
    }
    v7 = (IONotificationPort *)*((_QWORD *)manager + 9);
    if (v7)
    {
      RunLoopSource = IONotificationPortGetRunLoopSource(v7);
      if (RunLoopSource)
        CFRunLoopAddSource(*((CFRunLoopRef *)manager + 10), RunLoopSource, *((CFRunLoopMode *)manager + 11));
    }
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 64);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerRegisterDeviceRemovalCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  *((_QWORD *)manager + 28) = context;
  *((_QWORD *)manager + 29) = callback;
  os_unfair_recursive_lock_unlock();
}

void IOHIDManagerRegisterDeviceMatchingCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  *((_QWORD *)manager + 26) = context;
  *((_QWORD *)manager + 27) = callback;
  os_unfair_recursive_lock_unlock();
}

IOReturn IOHIDManagerOpen(IOHIDManagerRef manager, IOOptionBits options)
{
  int v2;
  int v3;

  if (*((_BYTE *)manager + 144))
    return 0;
  *((_BYTE *)manager + 144) = 1;
  *((_DWORD *)manager + 37) = options;
  if (!*((_QWORD *)manager + 4))
    return 0;
  if (*((_QWORD *)manager + 30))
    v2 = 9;
  else
    v2 = 1;
  if (*((_QWORD *)manager + 22))
    v2 |= 0x10u;
  if (*((_QWORD *)manager + 24))
    v2 |= 0x20u;
  if (*((_QWORD *)manager + 25))
    v3 = v2 | 0x1000;
  else
    v3 = v2;
  return __ApplyToDevices((CFSetRef *)manager, v3);
}

IOHIDManagerRef IOHIDManagerCreate(CFAllocatorRef allocator, IOOptionBits options)
{
  uint64_t v4;
  uint64_t Instance;
  __IOHIDManager *v6;
  dispatch_queue_t v7;

  v4 = __kIOHIDManagerTypeID;
  if (!__kIOHIDManagerTypeID)
  {
    pthread_once(&__sessionTypeInit, (void (*)(void))__IOHIDManagerRegister);
    v4 = __kIOHIDManagerTypeID;
  }
  Instance = _IOHIDObjectCreateInstance((uint64_t)allocator, v4, 0xF8uLL);
  v6 = (__IOHIDManager *)Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 24) = 0;
    *(_QWORD *)(Instance + 160) = 0;
    *(_DWORD *)(Instance + 152) = options;
    if ((options & 3) == 1)
      __IOHIDManagerLoadProperties(Instance);
    v7 = dispatch_queue_create("IOHIDManagerStateQueue", 0);
    *((_QWORD *)v6 + 32) = v7;
    if (v7)
      *((_QWORD *)v6 + 31) = os_state_add_handler();
  }
  return v6;
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  kern_return_t v2;

  v2 = ((uint64_t (*)(IOCFPlugInInterface **))(*interface)->Stop)(interface);
  ((void (*)(IOCFPlugInInterface **))(*interface)->Release)(interface);
  return v2;
}

BOOL __IOHIDEventHasLegacyEventData(int a1)
{
  return a1 == 11 || a1 == 17 || a1 == 4;
}

uint64_t __IOHIDEventDataAppendFromLegacyEvent()
{
  return 0;
}

void IOHIDPreferencesSet(const __CFString *a1, const void *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  NSObject *v10;
  int v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__setPtr)
  {
    __setPtr(a1, a2, a3, a4, a5);
  }
  else
  {
    v10 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = 136315138;
      v12 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18AAAF000, v10, OS_LOG_TYPE_INFO, "Failed to find %s for set, switch to default CFPreferences", (uint8_t *)&v11, 0xCu);
    }
    CFPreferencesSetValue(a1, a2, a5, a3, a4);
  }
}

void IOHIDPreferencesSetMultiple(const __CFDictionary *a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  NSObject *v10;
  int v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__setMultiplePtr)
  {
    __setMultiplePtr(a1, a2, a3, a4, a5);
  }
  else
  {
    v10 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = 136315138;
      v12 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18AAAF000, v10, OS_LOG_TYPE_INFO, "Failed to find %s for set multiple , switch to default CFPreferences", (uint8_t *)&v11, 0xCu);
    }
    CFPreferencesSetMultiple(a1, a2, a5, a3, a4);
  }
}

CFPropertyListRef IOHIDPreferencesCopy(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  NSObject *v9;
  int v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__copyPtr)
    return (CFPropertyListRef)__copyPtr(a1, a2, a3, a4);
  v9 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v10 = 136315138;
    v11 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v9, OS_LOG_TYPE_INFO, "Failed to find %s for copy, switch to default CFPreferences", (uint8_t *)&v10, 0xCu);
  }
  return CFPreferencesCopyValue(a1, a4, a2, a3);
}

CFDictionaryRef IOHIDPreferencesCopyMultiple(const __CFArray *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  NSObject *v9;
  int v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__copyMultiplePtr)
    return (CFDictionaryRef)__copyMultiplePtr(a1, a2, a3, a4);
  v9 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v10 = 136315138;
    v11 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v9, OS_LOG_TYPE_INFO, "Failed to find %s for copy multiple, switch to default CFPreferences", (uint8_t *)&v10, 0xCu);
  }
  return CFPreferencesCopyMultiple(a1, a4, a2, a3);
}

uint64_t IOHIDPreferencesSynchronize(const __CFString *a1, const __CFString *a2, const __CFString *a3)
{
  NSObject *v7;
  int v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__synchronizePtr)
    return __synchronizePtr(a1, a2, a3);
  v7 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = 136315138;
    v9 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v7, OS_LOG_TYPE_INFO, "Failed to find %s for synchronize, switch to default CFPreferences", (uint8_t *)&v8, 0xCu);
  }
  return CFPreferencesSynchronize(a3, a1, a2);
}

CFPropertyListRef IOHIDPreferencesCopyDomain(const __CFString *a1, const __CFString *a2)
{
  NSObject *v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__copyDomainPtr)
    return (CFPropertyListRef)__copyDomainPtr(a1, a2);
  v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = 136315138;
    v7 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v5, OS_LOG_TYPE_INFO, "Failed to find %s for copy domain, switch to default CFPreferences", (uint8_t *)&v6, 0xCu);
  }
  return CFPreferencesCopyAppValue(a1, a2);
}

void IOHIDPreferencesSetDomain(const __CFString *a1, const void *a2, const __CFString *a3)
{
  NSObject *v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__setDomainPtr)
  {
    __setDomainPtr(a1, a2, a3);
  }
  else
  {
    v6 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = 136315138;
      v8 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18AAAF000, v6, OS_LOG_TYPE_INFO, "Failed to find %s for set domain, switch to default CFPreferences", (uint8_t *)&v7, 0xCu);
    }
    CFPreferencesSetAppValue(a1, a2, a3);
  }
}

uint64_t IOHIDPreferencesCreateInstance(uint64_t a1)
{
  NSObject *v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__createPtr)
    return __createPtr(a1);
  v3 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    v4 = 136315138;
    v5 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v3, OS_LOG_TYPE_INFO, "Failed to find %s for create", (uint8_t *)&v4, 0xCu);
  }
  return 0;
}

void IOHIDPreferencesSetForInstance(uint64_t a1, const __CFString *a2, const void *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  NSObject *v12;
  int v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__setForInstancePtr)
  {
    __setForInstancePtr(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    v12 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = 136315138;
      v14 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18AAAF000, v12, OS_LOG_TYPE_INFO, "Failed to find %s for set, switch to default CFPreferences", (uint8_t *)&v13, 0xCu);
    }
    CFPreferencesSetValue(a2, a3, a6, a4, a5);
  }
}

void IOHIDPreferencesSetMultipleForInstance(uint64_t a1, const __CFDictionary *a2, const __CFArray *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  NSObject *v12;
  int v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__setMultipleForInstancePtr)
  {
    __setMultipleForInstancePtr(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    v12 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = 136315138;
      v14 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18AAAF000, v12, OS_LOG_TYPE_INFO, "Failed to find %s for set multiple , switch to default CFPreferences", (uint8_t *)&v13, 0xCu);
    }
    CFPreferencesSetMultiple(a2, a3, a6, a4, a5);
  }
}

CFPropertyListRef IOHIDPreferencesCopyForInstance(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  NSObject *v11;
  int v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__copyForInstancePtr)
    return (CFPropertyListRef)__copyForInstancePtr(a1, a2, a3, a4, a5);
  v11 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v12 = 136315138;
    v13 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v11, OS_LOG_TYPE_INFO, "Failed to find %s for copy, switch to default CFPreferences", (uint8_t *)&v12, 0xCu);
  }
  return CFPreferencesCopyValue(a2, a5, a3, a4);
}

CFDictionaryRef IOHIDPreferencesCopyMultipleForInstance(uint64_t a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  NSObject *v11;
  int v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__copyMultipleForInstancePtr)
    return (CFDictionaryRef)__copyMultipleForInstancePtr(a1, a2, a3, a4, a5);
  v11 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v12 = 136315138;
    v13 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v11, OS_LOG_TYPE_INFO, "Failed to find %s for copy multiple, switch to default CFPreferences", (uint8_t *)&v12, 0xCu);
  }
  return CFPreferencesCopyMultiple(a2, a5, a3, a4);
}

uint64_t IOHIDPreferencesSynchronizeForInstance(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  NSObject *v9;
  int v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__synchronizeForInstancePtr)
    return __synchronizeForInstancePtr(a1, a2, a3, a4);
  v9 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v10 = 136315138;
    v11 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v9, OS_LOG_TYPE_INFO, "Failed to find %s for synchronize, switch to default CFPreferences", (uint8_t *)&v10, 0xCu);
  }
  return CFPreferencesSynchronize(a4, a2, a3);
}

CFPropertyListRef IOHIDPreferencesCopyDomainForInstance(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  NSObject *v7;
  int v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__copyDomainForInstancePtr)
    return (CFPropertyListRef)__copyDomainForInstancePtr(a1, a2, a3);
  v7 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = 136315138;
    v9 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v7, OS_LOG_TYPE_INFO, "Failed to find %s for copy domain, switch to default CFPreferences", (uint8_t *)&v8, 0xCu);
  }
  return CFPreferencesCopyAppValue(a2, a3);
}

void IOHIDPreferencesSetDomainForInstance(uint64_t a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  NSObject *v8;
  int v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (__loadFramework_haOnce != -1)
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  if (__setDomainForInstancePtr)
  {
    __setDomainForInstancePtr(a1, a2, a3, a4);
  }
  else
  {
    v8 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = 136315138;
      v10 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18AAAF000, v8, OS_LOG_TYPE_INFO, "Failed to find %s for set domain, switch to default CFPreferences", (uint8_t *)&v9, 0xCu);
    }
    CFPreferencesSetAppValue(a2, a3, a4);
  }
}

void ____loadFramework_block_invoke()
{
  void *v0;
  void *v1;
  uint64_t (*v2)(_QWORD);
  void *v3;
  NSObject *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v0 = dlopen("/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences", 1);
  __loadFramework_haHandle = (uint64_t)v0;
  if (v0)
  {
    __setPtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym(v0, "HIDPreferencesSet");
    if (__loadFramework_haHandle)
    {
      __setMultiplePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetMultiple");
      if (__loadFramework_haHandle)
      {
        __copyPtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopy");
        if (__loadFramework_haHandle)
        {
          __copyMultiplePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyMultiple");
          if (__loadFramework_haHandle)
          {
            __synchronizePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSynchronize");
            if (__loadFramework_haHandle)
            {
              __copyDomainPtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyDomain");
              if (__loadFramework_haHandle)
              {
                __setDomainPtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetDomain");
                if (__loadFramework_haHandle)
                {
                  __setForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetForInstance");
                  if (__loadFramework_haHandle)
                  {
                    __setMultipleForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetMultipleForInstance");
                    if (__loadFramework_haHandle)
                    {
                      __copyForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyForInstance");
                      if (__loadFramework_haHandle)
                      {
                        __copyMultipleForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyMultipleForInstance");
                        if (__loadFramework_haHandle)
                        {
                          __synchronizeForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSynchronizeForInstance");
                          if (__loadFramework_haHandle)
                          {
                            v1 = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyDomainForInstance");
                            v2 = (uint64_t (*)(_QWORD))__loadFramework_haHandle;
                            __copyDomainForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD))v1;
                            if (__loadFramework_haHandle)
                            {
                              v3 = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetDomainForInstance");
                              v2 = (uint64_t (*)(_QWORD))__loadFramework_haHandle;
                              __setDomainForInstancePtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))v3;
                              if (__loadFramework_haHandle)
                                v2 = (uint64_t (*)(_QWORD))dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCreateInstance");
                              goto LABEL_32;
                            }
LABEL_31:
                            __setDomainForInstancePtr = 0;
LABEL_32:
                            __createPtr = v2;
                            return;
                          }
LABEL_30:
                          v2 = 0;
                          __copyDomainForInstancePtr = 0;
                          goto LABEL_31;
                        }
LABEL_29:
                        __synchronizeForInstancePtr = 0;
                        goto LABEL_30;
                      }
LABEL_28:
                      __copyMultipleForInstancePtr = 0;
                      goto LABEL_29;
                    }
LABEL_27:
                    __copyForInstancePtr = 0;
                    goto LABEL_28;
                  }
LABEL_26:
                  __setMultipleForInstancePtr = 0;
                  goto LABEL_27;
                }
LABEL_25:
                __setForInstancePtr = 0;
                goto LABEL_26;
              }
LABEL_24:
              __setDomainPtr = 0;
              goto LABEL_25;
            }
LABEL_23:
            __copyDomainPtr = 0;
            goto LABEL_24;
          }
LABEL_22:
          __synchronizePtr = 0;
          goto LABEL_23;
        }
LABEL_21:
        __copyMultiplePtr = 0;
        goto LABEL_22;
      }
    }
    else
    {
      __setMultiplePtr = 0;
    }
    __copyPtr = 0;
    goto LABEL_21;
  }
  v4 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315138;
    v6 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_DEFAULT, "Failed to load %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t __IOHIDEventRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDEventTypeID = result;
  return result;
}

uint64_t IOHIDEventGetTypeID()
{
  uint64_t result;

  result = __kIOHIDEventTypeID;
  if (!__kIOHIDEventTypeID)
  {
    pthread_once(&__eventTypeInit, (void (*)(void))__IOHIDEventRegister);
    return __kIOHIDEventTypeID;
  }
  return result;
}

uint64_t IOHIDSessionGetTypeID()
{
  return objc_opt_self();
}

HIDSession *_IOHIDSessionCreatePrivate(uint64_t a1)
{
  return -[HIDSession init](+[HIDSession allocWithZone:](HIDSession, "allocWithZone:", a1), "init");
}

CFTypeID IOHIDElementGetTypeID(void)
{
  return objc_opt_self();
}

HIDElement *_IOHIDElementCreatePrivate()
{
  return objc_alloc_init(HIDElement);
}

CFTypeID IOHIDServiceClientGetTypeID(void)
{
  return objc_opt_self();
}

CFTypeID IOHIDDeviceGetTypeID(void)
{
  return objc_opt_self();
}

HIDDevice *_IOHIDDeviceCreatePrivate()
{
  return objc_alloc_init(HIDDevice);
}

uint64_t isCrossLinking()
{
  return __sCrossLinkEnabled;
}

uint64_t setCrossLinkPageSize(uint64_t a1)
{
  uint8x8_t v1;
  uint64_t result;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] != 1)
    return 0;
  __sCrossLinkPageSize = a1;
  result = 1;
  __sCrossLinkEnabled = 1;
  return result;
}

uint64_t getEffectivePageSize()
{
  uint64_t *v0;

  if (__sCrossLinkEnabled)
    v0 = &__sCrossLinkPageSize;
  else
    v0 = (uint64_t *)MEMORY[0x1E0C85AD8];
  return *v0;
}

uint64_t roundPageCrossSafe(uint64_t a1)
{
  uint64_t *v1;

  if (__sCrossLinkEnabled)
    v1 = &__sCrossLinkPageSize;
  else
    v1 = (uint64_t *)MEMORY[0x1E0C85AD8];
  return (a1 + *v1 - 1) & -*v1;
}

uint64_t roundPageCrossSafeFixedWidth(uint64_t a1)
{
  if (__sCrossLinkEnabled == 1)
    return (a1 + __sCrossLinkPageSize - 1) & -__sCrossLinkPageSize;
  else
    return ~*MEMORY[0x1E0C85AC0] & (unint64_t)(*MEMORY[0x1E0C85AC0] + a1);
}

void DoCFSerializeBoolean(const __CFBoolean *a1, CFMutableDataRef *a2)
{
  int Value;
  const char *v4;
  CFIndex v5;

  Value = CFBooleanGetValue(a1);
  if (Value)
    v4 = "<true/>";
  else
    v4 = "<false/>";
  if (Value)
    v5 = 7;
  else
    v5 = 8;
  CFDataAppendBytes(*a2, (const UInt8 *)v4, v5);
}

uint64_t DoCFSerializeSet(const void *a1, CFMutableDataRef *a2)
{
  CFIndex Count;
  uint64_t v5;
  uint64_t result;
  void *v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  int v11;

  if (!previouslySerialized(a1, a2))
  {
    addStartTag(a1, 0, (uint64_t)a2);
    Count = CFSetGetCount((CFSetRef)a1);
    if (Count)
    {
      v5 = Count;
      result = (uint64_t)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (!result)
        return result;
      v7 = (void *)result;
      CFSetGetValues((CFSetRef)a1, (const void **)result);
      if (v5 < 1)
      {
        free(v7);
      }
      else
      {
        v8 = 0;
        do
        {
          v9 = DoCFSerialize(*((_QWORD *)v7 + v8++), a2);
          if (v9)
            v10 = v8 < v5;
          else
            v10 = 0;
        }
        while (v10);
        v11 = v9;
        free(v7);
        if (!v11)
          return 0;
      }
    }
    addEndTag(a1, a2);
  }
  return 1;
}

CFStringRef IOCFUnserializeerror(CFStringRef result, uint64_t a2)
{
  CFStringRef v2;

  if (result[1].data)
  {
    v2 = result;
    result = CFStringCreateWithFormat((CFAllocatorRef)result->data, 0, CFSTR("IOCFUnserialize: %s near line %d"), a2, HIDWORD(result->info));
    *(_QWORD *)v2[1].data = result;
  }
  return result;
}

CFStringRef IOObjectCopyClass(io_object_t object)
{
  return _IOObjectCopyClass(object, 0);
}

CFStringRef _IOObjectCopyClass(io_registry_entry_t a1, char a2)
{
  _OWORD v3[8];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  memset(v3, 0, sizeof(v3));
  _IOObjectGetClass(a1, a2, (char *)v3);
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)v3, 0x8000100u);
}

CFStringRef IOObjectCopySuperclassForClass(CFStringRef classname)
{
  const __CFString *v1;
  char *v2;
  mach_port_t v3;
  mach_port_t v4;
  int superclass;
  mach_port_t mainPort;
  char __dst[128];
  _OWORD cStr[8];
  uint64_t v10;

  v1 = classname;
  v10 = *MEMORY[0x1E0C80C00];
  if (classname)
  {
    memset(cStr, 0, sizeof(cStr));
    v2 = (char *)malloc_type_malloc(0x80uLL, 0x1000040AE2C30F4uLL);
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    CFStringGetCString(v1, v2, 128, 0x8000100u);
    v3 = strncpy(__dst, v2, 0x80uLL);
    mainPort = 0;
    if (IOMasterPort(v3, &mainPort))
      v4 = 0;
    else
      v4 = mainPort;
    superclass = io_object_get_superclass(v4, __dst);
    if (v4)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
    if (superclass)
      v1 = 0;
    else
      v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)cStr, 0x8000100u);
    free(v2);
  }
  return v1;
}

CFStringRef IOObjectCopyBundleIdentifierForClass(CFStringRef classname)
{
  const __CFString *v1;
  char *v2;
  mach_port_t v3;
  mach_port_t v4;
  int bundle_identifier;
  mach_port_t mainPort;
  char __dst[128];
  _OWORD cStr[8];
  uint64_t v10;

  v1 = classname;
  v10 = *MEMORY[0x1E0C80C00];
  if (classname)
  {
    memset(cStr, 0, sizeof(cStr));
    v2 = (char *)malloc_type_malloc(0x80uLL, 0x1000040AE2C30F4uLL);
    CFStringGetCString(v1, v2, 128, 0x8000100u);
    v3 = strncpy(__dst, v2, 0x80uLL);
    mainPort = 0;
    if (IOMasterPort(v3, &mainPort))
      v4 = 0;
    else
      v4 = mainPort;
    bundle_identifier = io_object_get_bundle_identifier(v4, __dst);
    if (v4)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
    if (bundle_identifier)
      v1 = 0;
    else
      v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)cStr, 0x8000100u);
    free(v2);
  }
  return v1;
}

BOOLean_t IOObjectIsEqualTo(io_object_t object, io_object_t anObject)
{
  return object == anObject;
}

uint32_t IOObjectGetKernelRetainCount(io_object_t object)
{
  if (io_object_get_retain_count(object))
    return 0;
  else
    return 0;
}

uint32_t IOObjectGetRetainCount(io_object_t object)
{
  if (io_object_get_retain_count(object))
    return 0;
  else
    return 0;
}

uint32_t IOObjectGetUserRetainCount(io_object_t object)
{
  uint32_t v2;

  v2 = 0;
  if (MEMORY[0x18D772984](*MEMORY[0x1E0C83DA0], *(_QWORD *)&object, 0, &v2))
    return 0;
  else
    return v2;
}

BOOLean_t IOIteratorIsValid(io_iterator_t iterator)
{
  if (io_iterator_is_valid(iterator))
    return 0;
  else
    return 0;
}

kern_return_t IOServiceMatchPropertyTable(io_service_t service, CFDictionaryRef matching, BOOLean_t *matches)
{
  kern_return_t v3;
  const __CFData *v5;
  const __CFData *v6;
  unint64_t Length;
  int v8;
  const char *BytePtr;
  kern_return_t matched;
  const UInt8 *v11;
  kern_return_t v12;

  v3 = -536870206;
  if (matching)
  {
    v5 = IOCFSerialize(matching, gIOKitLibSerializeOptions);
    if (v5)
    {
      v6 = v5;
      Length = CFDataGetLength(v5);
      v8 = Length;
      if ((gIOKitLibSerializeOptions & 1) != 0)
      {
        if (Length <= 0xFFF)
        {
          CFDataGetBytePtr(v6);
          matched = io_service_match_property_table_bin();
          goto LABEL_9;
        }
      }
      else if (Length <= 0x1FF)
      {
        BytePtr = (const char *)CFDataGetBytePtr(v6);
        matched = io_service_match_property_table(service, BytePtr);
LABEL_9:
        v3 = matched;
LABEL_13:
        CFRelease(v6);
        return v3;
      }
      v11 = CFDataGetBytePtr(v6);
      v12 = io_service_match_property_table_ool(service, (uint64_t)v11, v8);
      if (v12)
        v3 = v12;
      else
        v3 = 0;
      goto LABEL_13;
    }
    return -536870201;
  }
  return v3;
}

kern_return_t IOServiceAddNotification(mach_port_t mainPort, const io_name_t notificationType, CFDictionaryRef matching, mach_port_t wakePort, uintptr_t reference, io_iterator_t *notification)
{
  uintptr_t v7;

  v7 = reference;
  return InternalIOServiceAddNotification(mainPort, notificationType, matching, wakePort, &v7, 1u, notification);
}

kern_return_t IONotificationPortSetImportanceReceiver(IONotificationPortRef notify)
{
  kern_return_t result;

  result = MEMORY[0x18D7729B4](*MEMORY[0x1E0C83DA0], *((unsigned int *)notify + 1), 5, 0, 0);
  if (result)
    IONotificationPortSetImportanceReceiver_cold_1();
  return result;
}

CFMutableDictionaryRef IOOpenFirmwarePathMatching(mach_port_t mainPort, uint32_t options, const char *path)
{
  _OWORD v5[32];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  memset(v5, 0, sizeof(v5));
  __strlcpy_chk();
  if ((int)strlen(path) > 498)
    return 0;
  __strlcpy_chk();
  return MakeOneStringProp(CFSTR("IOPathMatch"), (const char *)v5);
}

kern_return_t OSGetNotificationFromMessage(mach_msg_header_t *msg, uint32_t index, uint32_t *type, uintptr_t *reference, void **content, vm_size_t *size)
{
  kern_return_t v6;
  mach_msg_header_t *v7;

  v6 = -536870210;
  if (msg->msgh_id != 53)
    return -536870202;
  if (!index && msg->msgh_size >= 0x60)
  {
    if (type)
      *type = msg[1].msgh_size & 0xFFF;
    if (reference)
      *reference = *(_QWORD *)&msg[1].msgh_remote_port;
    if (size)
      *size = msg[1].msgh_bits;
    v6 = 0;
    if (content)
    {
      if (msg[1].msgh_bits)
        v7 = msg + 4;
      else
        v7 = 0;
      *content = v7;
    }
  }
  return v6;
}

uint64_t IOServiceGetBusyStateAndTime(unsigned int a1, _QWORD *a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t result;

  result = io_service_get_state(a1);
  if ((_DWORD)result)
  {
    *a2 = 0;
    *a3 = 0;
    *a4 = 0;
  }
  return result;
}

kern_return_t IOServiceGetBusyState(io_service_t service, uint32_t *busyState)
{
  kern_return_t result;

  result = io_service_get_state(service);
  if (result)
    *busyState = 0;
  return result;
}

uint64_t IOServiceGetState(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  result = io_service_get_state(a1);
  if ((_DWORD)result)
    *a2 = 0;
  return result;
}

kern_return_t IOKitGetBusyState(mach_port_t mainPort, uint32_t *busyState)
{
  mach_port_t v4;
  kern_return_t v5;
  kern_return_t state;
  mach_port_t mainPorta[2];

  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta[0] = 0;
    if (IOMasterPort(0, mainPorta))
      v4 = 0;
    else
      v4 = mainPorta[0];
  }
  v5 = io_registry_entry_from_path(v4, "IOService:/");
  if (v5)
  {
    state = v5;
    *busyState = 0;
    if (!v4)
      return state;
    goto LABEL_11;
  }
  *(_QWORD *)mainPorta = 0;
  state = io_service_get_state(0);
  if (state)
    *busyState = 0;
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], 0);
  if (v4)
  {
LABEL_11:
    if (v4 != mainPort)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  }
  return state;
}

kern_return_t IOServiceWaitQuiet(io_service_t service, mach_timespec_t *waitTime)
{
  uint64_t *v2;

  v2 = (uint64_t *)&unk_18AB45FE0;
  if (waitTime)
    v2 = (uint64_t *)waitTime;
  return io_service_wait_quiet(service, *v2);
}

kern_return_t IOKitWaitQuietWithOptions(mach_port_t mainPort, mach_timespec_t *waitTime, IOOptionBits options)
{
  mach_port_t v6;
  kern_return_t v7;
  uint64_t *v8;
  mach_port_t mainPorta;

  v6 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v6 = 0;
    else
      v6 = mainPorta;
  }
  v7 = io_registry_entry_from_path(v6, "IOService:/");
  if (!v7)
  {
    v8 = (uint64_t *)&unk_18AB45FE0;
    if (waitTime)
      v8 = (uint64_t *)waitTime;
    v7 = io_service_wait_quiet_with_options(0, *v8, options);
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], 0);
  }
  if (v6 && v6 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v6);
  return v7;
}

kern_return_t IOKitWaitQuiet(mach_port_t mainPort, mach_timespec_t *waitTime)
{
  mach_port_t v4;
  kern_return_t v5;
  uint64_t *v6;
  mach_port_t mainPorta;

  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v4 = 0;
    else
      v4 = mainPorta;
  }
  v5 = io_registry_entry_from_path(v4, "IOService:/");
  if (!v5)
  {
    v6 = (uint64_t *)&unk_18AB45FE0;
    if (waitTime)
      v6 = (uint64_t *)waitTime;
    v5 = io_service_wait_quiet(0, *v6);
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], 0);
  }
  if (v4 && v4 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  return v5;
}

kern_return_t IOServiceAuthorize(io_service_t service, uint32_t options)
{
  kern_return_t uint64;
  xpc_object_t v4;
  void *v5;
  _xpc_connection_s *v6;
  _xpc_connection_s *v7;
  xpc_object_t v8;
  void *v9;

  uint64 = -536870211;
  if (io_registry_entry_get_registry_entry_id(service))
    return -536870206;
  v4 = xpc_dictionary_create(0, 0, 0);
  if (v4)
  {
    v5 = v4;
    xpc_dictionary_set_uint64(v4, "options", options);
    xpc_dictionary_set_uint64(v5, "service", 0);
    v6 = xpc_connection_create("com.apple.iokit.IOServiceAuthorizeAgent", 0);
    if (v6)
    {
      v7 = v6;
      xpc_connection_set_event_handler(v6, &__block_literal_global_0);
      xpc_connection_resume(v7);
      v8 = xpc_connection_send_message_with_reply_sync(v7, v5);
      if (v8)
      {
        v9 = v8;
        if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
          uint64 = xpc_dictionary_get_uint64(v9, "status");
        else
          uint64 = -536870202;
        xpc_release(v9);
      }
      else
      {
        uint64 = -536870207;
      }
      xpc_release(v7);
    }
    else
    {
      uint64 = -536870201;
    }
    xpc_release(v5);
  }
  return uint64;
}

int IOServiceOpenAsFileDescriptor(io_service_t service, int oflag)
{
  int v3;
  int uint64;
  xpc_object_t v6;
  void *v7;
  _xpc_connection_s *v8;
  _xpc_connection_s *v9;
  xpc_object_t v10;
  void *v11;

  if (io_registry_entry_get_registry_entry_id(service))
  {
    v3 = -1;
    uint64 = 49174;
    goto LABEL_3;
  }
  v6 = xpc_dictionary_create(0, 0, 0);
  if (v6)
  {
    v7 = v6;
    xpc_dictionary_set_int64(v6, "oflag", oflag);
    xpc_dictionary_set_uint64(v7, "service", 0);
    v8 = xpc_connection_create("com.apple.iokit.ioserviceauthorized", 0);
    if (v8)
    {
      v9 = v8;
      xpc_connection_set_event_handler(v8, &__block_literal_global_28);
      xpc_connection_resume(v9);
      v10 = xpc_connection_send_message_with_reply_sync(v9, v7);
      if (!v10)
      {
        uint64 = 49165;
        v3 = -1;
        goto LABEL_17;
      }
      v11 = v10;
      if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
      {
        uint64 = xpc_dictionary_get_uint64(v11, "status");
        if (!uint64)
        {
          v3 = xpc_dictionary_dup_fd(v11, "fd");
          goto LABEL_16;
        }
      }
      else
      {
        uint64 = 49246;
      }
      v3 = -1;
LABEL_16:
      xpc_release(v11);
LABEL_17:
      xpc_release(v9);
      xpc_release(v7);
      if (!uint64)
        return v3;
      goto LABEL_3;
    }
    xpc_release(v7);
    v3 = -1;
    uint64 = 49197;
  }
  else
  {
    v3 = -1;
    uint64 = 49164;
  }
LABEL_3:
  if ((uint64 & 0x3FFF | 0xC000) == uint64)
    *__error() = uint64 & 0x3FFF;
  return v3;
}

kern_return_t IOConnectAddRef(io_connect_t connect)
{
  return mach_port_mod_refs(*MEMORY[0x1E0C83DA0], connect, 0, 1);
}

kern_return_t IOConnectRelease(io_connect_t connect)
{
  return mach_port_mod_refs(*MEMORY[0x1E0C83DA0], connect, 0, -1);
}

kern_return_t IOConnectCallAsyncStructMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return IOConnectCallAsyncMethod(connection, selector, wake_port, reference, referenceCnt, 0, 0, inputStruct, inputStructCnt, 0, 0, outputStruct, outputStructCnt);
}

kern_return_t IOConnectTrap0(io_connect_t connect, uint32_t index)
{
  return iokit_user_client_trap(*(void **)&connect, index, 0, 0, 0, 0, 0, 0);
}

kern_return_t IOConnectTrap4(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, (void *)p3, (void *)p4, 0, 0);
}

kern_return_t IOConnectTrap5(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, (void *)p3, (void *)p4, (void *)p5, 0);
}

io_registry_entry_t IORegistryEntryCopyFromPath(mach_port_t mainPort, CFStringRef path)
{
  mach_port_name_t v4;
  const char *CStringPtr;
  const char *v6;
  char *v7;
  CFIndex Length;
  CFIndex v10;
  char *v11;
  int CString;
  mach_port_t mainPorta;

  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v4 = 0;
    else
      v4 = mainPorta;
  }
  CStringPtr = CFStringGetCStringPtr(path, 0x8000100u);
  if (CStringPtr)
  {
    v6 = CStringPtr;
    v7 = 0;
    goto LABEL_7;
  }
  Length = CFStringGetLength(path);
  v10 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 4;
  v11 = (char *)malloc_type_malloc(v10, 0x6F47E89uLL);
  if (!v11)
  {
    v7 = 0;
    goto LABEL_18;
  }
  v6 = v11;
  CString = CFStringGetCString(path, v11, v10, 0x8000100u);
  v7 = (char *)v6;
  if (!CString)
  {
LABEL_18:
    if (!v7)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_7:
  strlen(v6);
  if (io_registry_entry_from_path_ool())
    goto LABEL_18;
  if (v7)
LABEL_9:
    free(v7);
LABEL_10:
  if (v4 && v4 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  return 0;
}

CFStringRef IORegistryEntryCopyPath(io_registry_entry_t entry, const io_name_t plane)
{
  const __CFString *v2;
  char cStr[16];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  MEMORY[0x1E0C80A78](*(_QWORD *)&entry, plane);
  v36 = *MEMORY[0x1E0C80C00];
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  *(_OWORD *)cStr = 0u;
  v5 = 0u;
  v2 = 0;
  if (!io_registry_entry_get_path_ool())
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  return v2;
}

BOOLean_t IORegistryEntryInPlane(io_registry_entry_t entry, const io_name_t plane)
{
  if (io_registry_entry_in_plane(entry, plane))
    return 0;
  else
    return 0;
}

kern_return_t IORegistryEntryGetNameInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t name)
{
  if (!plane)
    plane = "";
  return io_registry_entry_get_name_in_plane(entry, plane);
}

kern_return_t IORegistryEntryGetLocationInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t location)
{
  if (!plane)
    plane = "";
  return io_registry_entry_get_location_in_plane(entry, plane);
}

kern_return_t IORegistryEntryGetChildEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *child)
{
  kern_return_t result;

  result = io_registry_entry_get_child_iterator(entry, plane);
  if (!result)
  {
    io_iterator_next(0);
    *child = 0;
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], 0);
    if (*child)
      return 0;
    else
      return -536870208;
  }
  return result;
}

kern_return_t IOServiceOFPathToBSDName(mach_port_t mainPort, const io_name_t openFirmwarePath, io_name_t bsdName)
{
  const __CFDictionary *v5;
  kern_return_t MatchingServices;
  int v7;
  mach_port_name_t v8;
  BOOL v9;
  ipc_space_t *v10;
  kern_return_t property_bytes;
  io_iterator_t existing;
  mach_port_name_t v14;

  existing = 0;
  *bsdName = 0;
  v5 = IOOpenFirmwarePathMatching(mainPort, (uint32_t)openFirmwarePath, openFirmwarePath);
  MatchingServices = IOServiceGetMatchingServices(mainPort, v5, &existing);
  if (!MatchingServices)
  {
    v14 = 0;
    v7 = io_iterator_next(existing);
    v8 = v14;
    if (v7)
      v9 = 1;
    else
      v9 = v14 == 0;
    v10 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    if (v9)
    {
      MatchingServices = 5;
    }
    else
    {
      property_bytes = io_registry_entry_get_property_bytes(v14, (uint64_t)"BSD Name");
      MatchingServices = property_bytes;
      if (property_bytes)
        *bsdName = 0;
      mach_port_deallocate(*v10, v8);
    }
    mach_port_deallocate(*v10, existing);
  }
  return MatchingServices;
}

kern_return_t IOCatalogueSendData(mach_port_t mainPort, uint32_t flag, const char *buffer, uint32_t size)
{
  mach_port_t v8;
  kern_return_t v9;
  mach_port_t mainPorta;

  v8 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v8 = 0;
    else
      v8 = mainPorta;
  }
  v9 = io_catalog_send_data(v8, flag, (uint64_t)buffer, size);
  if (v8 && v8 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v8);
  if (v9)
    return v9;
  else
    return 0;
}

kern_return_t IOCatalogueTerminate(mach_port_t mainPort, uint32_t flag, io_name_t description)
{
  mach_port_t v6;
  kern_return_t v7;
  mach_port_t mainPorta;

  v6 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v6 = 0;
    else
      v6 = mainPorta;
  }
  v7 = io_catalog_terminate(v6, flag, description);
  if (v6 && v6 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v6);
  return v7;
}

kern_return_t IOCatalogueGetData(mach_port_t mainPort, uint32_t flag, char **buffer, uint32_t *size)
{
  mach_port_t v6;
  kern_return_t data;
  mach_port_t mainPorta;

  v6 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v6 = 0;
    else
      v6 = mainPorta;
  }
  data = io_catalog_get_data(v6, flag);
  if (v6 && v6 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v6);
  return data;
}

uint64_t IOCatlogueGetGenCount(mach_port_t a1)
{
  mach_port_t v2;
  uint64_t gen_count;
  mach_port_t mainPort;

  v2 = a1;
  if (!a1)
  {
    mainPort = 0;
    if (IOMasterPort(0, &mainPort))
      v2 = 0;
    else
      v2 = mainPort;
  }
  gen_count = io_catalog_get_gen_count(v2);
  if (v2 && v2 != a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v2);
  return gen_count;
}

kern_return_t IOCatalogueModuleLoaded(mach_port_t mainPort, io_name_t name)
{
  mach_port_t v4;
  kern_return_t v5;
  mach_port_t mainPorta;

  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v4 = 0;
    else
      v4 = mainPorta;
  }
  v5 = io_catalog_module_loaded(v4, name);
  if (v4 && v4 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  return v5;
}

kern_return_t IOCatalogueReset(mach_port_t mainPort, uint32_t flag)
{
  mach_port_t v4;
  kern_return_t v5;
  mach_port_t mainPorta;

  v4 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta))
      v4 = 0;
    else
      v4 = mainPorta;
  }
  v5 = io_catalog_reset(v4, flag);
  if (v4 && v4 != mainPort)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  return v5;
}

uint64_t IORegistryCreateEnumerator(mach_port_t a1, _DWORD *a2)
{
  mach_port_t v4;
  uint64_t iterator;
  mach_port_t mainPort;

  v4 = a1;
  if (!a1)
  {
    mainPort = 0;
    if (IOMasterPort(0, &mainPort))
      v4 = 0;
    else
      v4 = mainPort;
  }
  iterator = io_registry_create_iterator(v4, "IOService", 1, a2);
  if (v4 && v4 != a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
  return iterator;
}

uint64_t IORegistryEnumeratorNextConforming(unsigned int a1)
{
  io_iterator_next(a1);
  lastRegIter = 0;
  return 3758097088;
}

uint64_t IOOpenConnection(uint64_t a1, int a2, int a3)
{
  unsigned int v3;
  uint64_t v4;

  v3 = io_service_open_extended(lastRegIter, a2, a3, *MEMORY[0x1E0C804E8], 0, 0);
  if (v3)
    v4 = v3;
  else
    v4 = 0;
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], lastRegIter);
  return v4;
}

uint64_t IOSetNotificationPort(unsigned int a1, int a2, int a3)
{
  return io_connect_set_notification_port(a1, a2, a3, 0);
}

uint64_t IORegistryDisposeEnumerator(mach_port_name_t name)
{
  return mach_port_deallocate(*MEMORY[0x1E0C83DA0], name);
}

uint64_t IOCompatibiltyNumber(uint64_t a1, _DWORD *a2)
{
  *a2 = 1;
  return 0;
}

uint64_t readFile(const char *a1, _QWORD *a2, off_t *a3)
{
  int v5;
  int v6;
  uint64_t v7;
  off_t st_size;
  _QWORD *v9;
  void *v10;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  *a2 = 0;
  *a3 = 0;
  v5 = open(a1, 0, *(_OWORD *)&v12.st_dev, *(_OWORD *)&v12.st_uid, *(_OWORD *)&v12.st_atimespec, *(_OWORD *)&v12.st_mtimespec, *(_OWORD *)&v12.st_ctimespec, *(_OWORD *)&v12.st_birthtimespec);
  if (v5 != -1)
  {
    v6 = v5;
    if (fstat(v5, &v12) != -1)
    {
      if (((__int16)v12.st_mode & 0x80000000) == 0)
      {
        *a2 = 0;
        *a3 = 0;
        v7 = 3758097102;
LABEL_10:
        close(v6);
        return v7;
      }
      st_size = v12.st_size;
      v9 = (_QWORD *)MEMORY[0x1E0C85AD8];
      *a3 = v12.st_size;
      v10 = mmap(0, (st_size + *v9 - 1) & -*v9, 1, 2, v6, 0);
      *a2 = v10;
      if (v10)
      {
        v7 = 0;
        goto LABEL_10;
      }
      *a3 = 0;
    }
    v7 = *__error();
    goto LABEL_10;
  }
  return *__error();
}

CFPropertyListRef readPlist(const char *a1)
{
  CFPropertyListRef v1;
  const __CFAllocator *v2;
  const UInt8 *v3;
  mach_vm_size_t v4;
  const __CFData *v5;
  const __CFData *v6;
  mach_vm_size_t v8;
  const UInt8 *v9;

  v8 = 0;
  v9 = 0;
  v1 = 0;
  if (!readFile(a1, &v9, (off_t *)&v8))
  {
    v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v4 = v8;
    v3 = v9;
    v5 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, v8, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v5)
    {
      v6 = v5;
      v1 = CFPropertyListCreateFromXMLData(v2, v5, 1uLL, 0);
      CFRelease(v6);
    }
    else
    {
      v1 = 0;
    }
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v3, v4);
  }
  return v1;
}

BOOL writePlist(const char *a1, const void *a2)
{
  CFDataRef XMLData;
  const __CFData *v4;
  int v5;
  int v6;
  CFIndex Length;
  size_t v8;
  const UInt8 *BytePtr;
  _BOOL8 v10;

  XMLData = CFPropertyListCreateXMLData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  if (!XMLData)
    return 0;
  v4 = XMLData;
  v5 = open(a1, 1537, 420);
  if (v5 < 0)
  {
    v10 = 0;
  }
  else
  {
    v6 = v5;
    Length = CFDataGetLength(v4);
    if (Length)
    {
      v8 = Length;
      BytePtr = CFDataGetBytePtr(v4);
      v10 = v8 == write(v6, BytePtr, v8);
    }
    else
    {
      v10 = 1;
    }
    close(v6);
  }
  CFRelease(v4);
  return v10;
}

uint64_t ev_try_lock()
{
  return _os_nospin_lock_trylock();
}

uint64_t IOServiceCopySystemStateNotificationService(mach_port_t a1, io_service_t *a2)
{
  __CFDictionary *OneStringProp;
  io_service_t MatchingService;

  OneStringProp = MakeOneStringProp(CFSTR("IOProviderClass"), "IOSystemStateNotification");
  MatchingService = IOServiceGetMatchingService(a1, OneStringProp);
  *a2 = MatchingService;
  if (MatchingService)
    return 0;
  else
    return 3758097095;
}

uint64_t IOServiceStateNotificationItemCreate(io_registry_entry_t a1, const void *a2, const __CFDictionary *a3)
{
  __CFDictionary *MutableCopy;
  uint64_t v6;

  if (!a2 || !a3)
    return 3758097090;
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3);
  CFDictionarySetValue(MutableCopy, CFSTR("com.apple.iokit.statenotification.name"), a2);
  v6 = IORegistryEntrySetCFProperty(a1, CFSTR("com.apple.iokit.statenotification.create"), MutableCopy);
  CFRelease(MutableCopy);
  return v6;
}

uint64_t IOServiceStateNotificationItemSet(io_registry_entry_t a1, const void *a2, const __CFDictionary *a3)
{
  __CFDictionary *MutableCopy;
  uint64_t v6;

  if (!a2 || !a3)
    return 3758097090;
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3);
  CFDictionarySetValue(MutableCopy, CFSTR("com.apple.iokit.statenotification.name"), a2);
  v6 = IORegistryEntrySetCFProperty(a1, CFSTR("com.apple.iokit.statenotification.set"), MutableCopy);
  CFRelease(MutableCopy);
  return v6;
}

uint64_t IOServiceStateNotificationItemCopy(io_registry_entry_t a1, const void *a2, _QWORD *a3, IOOptionBits a4)
{
  uint64_t result;
  const void *Value;
  const void *v8;
  CFMutableDictionaryRef properties;

  properties = 0;
  result = IORegistryEntryCreateCFProperties(a1, &properties, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], a4);
  if (!(_DWORD)result)
  {
    Value = CFDictionaryGetValue(properties, a2);
    v8 = Value;
    if (Value)
    {
      CFRetain(Value);
      result = 0;
    }
    else
    {
      result = 3758097136;
    }
    *a3 = v8;
  }
  return result;
}

uint64_t _IOReadBytesFromFile(uint64_t result, char *a2, void **a3, off_t *a4, off_t st_size)
{
  const __CFAllocator *v8;
  int v9;
  int v10;
  void *v12;
  int v13;
  int *v14;
  int *v15;
  stat v16;

  if (result)
  {
    v8 = (const __CFAllocator *)result;
    *a3 = 0;
    v9 = open(a2, 0, 438);
    if (v9 < 0)
      return 0;
    v10 = v9;
    memset(&v16, 0, sizeof(v16));
    if (fstat(v9, &v16) < 0)
    {
      v13 = *__error();
      close(v10);
      v14 = __error();
      result = 0;
      *v14 = v13;
    }
    else if ((v16.st_mode & 0xF000) == 0x8000)
    {
      if (v16.st_size)
      {
        if (v16.st_size <= st_size || st_size == 0)
          st_size = v16.st_size;
        v12 = CFAllocatorAllocate(v8, st_size, 0);
        *a3 = v12;
        if (read(v10, v12, st_size) < 0)
        {
          CFAllocatorDeallocate(v8, *a3);
          *a3 = 0;
          close(v10);
          return 0;
        }
      }
      else
      {
        st_size = 0;
        *a3 = CFAllocatorAllocate(v8, 4, 0);
      }
      *a4 = st_size;
      close(v10);
      return 1;
    }
    else
    {
      close(v10);
      v15 = __error();
      result = 0;
      *v15 = 13;
    }
  }
  return result;
}

uint64_t _IOWriteBytesToFile(const char *a1, const void *a2, size_t a3)
{
  mode_t v6;
  int v7;
  int v8;
  uint64_t result;
  int v10;
  int *v11;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  v6 = umask(0);
  umask(v6);
  if (stat(a1, &v12) && *__error() != 2)
    return 0;
  v7 = open(a1, 1537, 438);
  if (v7 < 0)
    return 0;
  v8 = v7;
  if (a3 && write(v7, a2, a3) != a3)
  {
    v10 = *__error();
    close(v8);
    v11 = __error();
    result = 0;
    *v11 = v10;
  }
  else
  {
    fsync(v8);
    close(v8);
    return 1;
  }
  return result;
}

uint64_t _IODataQueueEnqueueWithReadCallback(unsigned int *a1, uint64_t a2, mach_msg_header_t *a3, size_t a4, void (*a5)(uint64_t, char *, size_t), uint64_t a6)
{
  return __IODataQueueEnqueue(a1, a2, a3, a4, 0, a5, a6, 0);
}

IOReturn IODataQueueSetNotificationPort(IODataQueueMemory *dataQueue, mach_port_t notifyPort)
{
  IOReturn result;
  char *v4;

  if (!dataQueue)
    return -536870206;
  result = 0;
  v4 = (char *)dataQueue + dataQueue->queueSize;
  *((_QWORD *)v4 + 2) = 0x1800000013;
  *((_DWORD *)v4 + 6) = notifyPort;
  *((_DWORD *)v4 + 7) = 0;
  *((_DWORD *)v4 + 9) = 0;
  return result;
}

__CFDictionary *IOHIDServiceConnectionCacheCopyDebugInfo(uint64_t a1)
{
  const __CFDictionary *v2;
  __CFDictionary *MutableCopy;
  __CFDictionary *v4;
  const void *v5;

  v2 = *(const __CFDictionary **)(a1 + 40);
  if (v2 && CFDictionaryGetCount(v2))
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, *(CFDictionaryRef *)(a1 + 40));
  else
    MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = MutableCopy;
  if (MutableCopy)
  {
    v5 = *(const void **)(a1 + 24);
    if (v5)
      CFDictionarySetValue(MutableCopy, CFSTR("ReportInterval"), v5);
    if (!CFDictionaryGetCount(v4))
    {
      CFRelease(v4);
      return 0;
    }
  }
  return v4;
}

void __IOHIDServiceConnectionCacheFree(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
}

io_connect_t IOPMFindPowerManagement(mach_port_t master_device_port)
{
  io_connect_t result;
  io_object_t v2;
  kern_return_t v3;
  io_connect_t connect;

  result = IORegistryEntryFromPath(master_device_port, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (result)
  {
    v2 = result;
    connect = 0;
    v3 = IOServiceOpen(result, *MEMORY[0x1E0C83DA0], 0, &connect);
    IOObjectRelease(v2);
    if (v3)
      return 0;
    else
      return connect;
  }
  return result;
}

IOReturn IOPMGetAggressiveness(io_connect_t fb, unint64_t type, unint64_t *aggressiveness)
{
  kern_return_t v4;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  output = 0;
  input = type;
  outputCnt = 1;
  v4 = IOConnectCallScalarMethod(fb, 1u, &input, 1u, &output, &outputCnt);
  *aggressiveness = output;
  if (v4)
    return -536870212;
  else
    return 0;
}

IOReturn IOPMSetAggressiveness(io_connect_t fb, unint64_t type, unint64_t aggressiveness)
{
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x1E0C80C00];
  input[0] = type;
  input[1] = aggressiveness;
  output = 0;
  outputCnt = 1;
  if (IOConnectCallScalarMethod(fb, 0, input, 2u, &output, &outputCnt))
    return -536870212;
  else
    return output;
}

IOReturn IOPMSleepSystem(io_connect_t fb)
{
  uint32_t outputCnt;
  uint64_t output;

  output = 0;
  outputCnt = 1;
  if (IOConnectCallScalarMethod(fb, 2u, 0, 0, &output, &outputCnt))
    return -536870212;
  else
    return output;
}

uint64_t IOPMSleepSystemWithOptions(mach_port_t connection, CFTypeRef object)
{
  const __CFData *v3;
  const __CFData *v4;
  const UInt8 *BytePtr;
  size_t Length;
  uint64_t v7;
  size_t v9;
  uint64_t outputStruct;
  uint32_t outputCnt;
  uint64_t output;

  v9 = 4;
  outputStruct = 0;
  if (object)
  {
    v3 = IOCFSerialize(object, 0);
    if (v3)
    {
      v4 = v3;
      BytePtr = CFDataGetBytePtr(v3);
      Length = CFDataGetLength(v4);
      v7 = IOConnectCallStructMethod(connection, 7u, BytePtr, Length, &outputStruct, &v9);
      CFRelease(v4);
      if (!(_DWORD)v7)
        return outputStruct;
    }
    else
    {
      return 3758097097;
    }
  }
  else
  {
    output = 0;
    outputCnt = 1;
    if (IOConnectCallScalarMethod(connection, 2u, 0, 0, &output, &outputCnt))
      return 3758097084;
    else
      return output;
  }
  return v7;
}

IOReturn IOPMCopyBatteryInfo(mach_port_t masterPort, CFArrayRef *info)
{
  IOReturn v3;
  io_registry_entry_t v4;
  io_object_t v5;
  const __CFAllocator *v6;
  IOReturn result;
  CFMutableArrayRef Mutable;
  __CFArray *v9;
  const __CFDictionary *v10;
  io_object_t v11;
  io_registry_entry_t v12;
  int v13;
  CFTypeRef CFProperty;
  const void *v15;
  io_iterator_t existing;

  v3 = -536870201;
  *info = 0;
  v4 = IORegistryEntryFromPath(masterPort, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v4)
    return -536870201;
  v5 = v4;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *info = (CFArrayRef)IORegistryEntryCreateCFProperty(v4, CFSTR("IOBatteryInfo"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  IOObjectRelease(v5);
  result = 0;
  if (*info)
    return result;
  existing = 0;
  Mutable = CFArrayCreateMutable(v6, 1, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return -536870211;
  v9 = Mutable;
  v10 = IOServiceMatching("IOPMPowerSource");
  if (!IOServiceGetMatchingServices(0, v10, &existing))
  {
    v11 = IOIteratorNext(existing);
    if (v11)
    {
      v12 = v11;
      v13 = 0;
      do
      {
        CFProperty = IORegistryEntryCreateCFProperty(v12, CFSTR("LegacyBatteryInfo"), v6, 0);
        if (CFProperty)
        {
          v15 = CFProperty;
          ++v13;
          CFArrayAppendValue(v9, CFProperty);
          CFRelease(v15);
          IOObjectRelease(v12);
        }
        v12 = IOIteratorNext(existing);
      }
      while (v12);
      IOObjectRelease(existing);
      if (v13 >= 1)
      {
        v3 = 0;
        *info = v9;
        return v3;
      }
    }
    else
    {
      IOObjectRelease(existing);
    }
    CFRelease(v9);
    return v3;
  }
  CFRelease(v9);
  return -536870212;
}

io_connect_t IORegisterApp(void *refcon, io_service_t theDriver, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  kern_return_t v10;
  io_connect_t result;
  BOOL v12;
  kern_return_t v13;
  io_connect_t connect;

  connect = 0;
  *notifier = 0;
  if (!theDriver)
    return 0;
  v10 = IOServiceOpen(theDriver, *MEMORY[0x1E0C83DA0], 0, &connect);
  result = connect;
  if (v10)
    v12 = 1;
  else
    v12 = connect == 0;
  if (v12
    || (v13 = IOServiceAddInterestNotification(*thePortRef, theDriver, "IOAppPowerStateInterest", callback, refcon, notifier), result = connect, v13))
  {
    if (result)
      IOServiceClose(result);
    result = *notifier;
    if (*notifier)
    {
      IOObjectRelease(result);
      return 0;
    }
  }
  return result;
}

IOReturn IODeregisterApp(io_object_t *notifier)
{
  io_object_t v2;

  v2 = *notifier;
  if (v2)
  {
    IOObjectRelease(v2);
    *notifier = 0;
  }
  return 0;
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  uint64_t input;

  input = notificationID;
  if (IOConnectCallScalarMethod(kernelPort, 3u, &input, 1u, 0, 0))
    return -536870212;
  else
    return 0;
}

IOReturn IOCancelPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  uint64_t input;

  input = notificationID;
  if (IOConnectCallScalarMethod(kernelPort, 4u, &input, 1u, 0, 0))
    return -536870212;
  else
    return 0;
}

BOOLean_t IOPMSleepEnabled(void)
{
  io_registry_entry_t v0;
  io_object_t v1;
  CFTypeRef CFProperty;
  BOOLean_t v3;

  v0 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v0)
    return 0;
  v1 = v0;
  CFProperty = IORegistryEntryCreateCFProperty(v0, CFSTR("IOSleepSupported"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (CFProperty)
  {
    CFRelease(CFProperty);
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  IOObjectRelease(v1);
  return v3;
}

IOSystemLoadAdvisoryLevel IOGetSystemLoadAdvisory(void)
{
  uint64_t v1;
  int out_token;

  out_token = 0;
  v1 = 0;
  if (notify_register_check("com.apple.system.powermanagement.SystemLoadAdvisory", &out_token))
    return 2;
  notify_get_state(out_token, &v1);
  notify_cancel(out_token);
  return v1;
}

CFDictionaryRef IOCopySystemLoadAdvisoryDetailed(void)
{
  uint64_t v0;
  CFStringRef v1;
  uint64_t (*v2)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v3)(uint64_t, uint64_t, uint64_t, uint64_t);
  BOOL v4;
  uint64_t (*v5)(uint64_t, uint64_t);
  uint64_t (*v7)(uint64_t, uint64_t);
  CFTypeID TypeID;

  v0 = *MEMORY[0x1E0C9AE00];
  v1 = _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("%@%@"), CFSTR("State:"), CFSTR("/IOKit/PowerManagement/SystemLoad/Detailed"));
  v2 = _io_SCDynamicStoreCreate(v0, (uint64_t)CFSTR("IOKit IOGetSystemLoadAdvisoryDetailed"), 0, 0);
  v3 = v2;
  if (v2)
    v4 = v1 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v7 = _io_SCDynamicStoreCopyValue((uint64_t)v2, (uint64_t)v1);
    v5 = v7;
    if (v7)
    {
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v5) != TypeID)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
LABEL_13:
    CFRelease(v1);
    if (!v3)
      return (CFDictionaryRef)v5;
    goto LABEL_8;
  }
  v5 = 0;
  if (v1)
    goto LABEL_13;
  if (v2)
LABEL_8:
    CFRelease(v3);
  return (CFDictionaryRef)v5;
}

void *IOPMRegisterPrefsChangeNotification(NSObject *a1, void *a2)
{
  void *v4;

  v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4 && notify_register_dispatch("com.apple.system.powermanagement.prefschange", (int *)v4, a1, a2))
  {
    free(v4);
    return 0;
  }
  return v4;
}

void IOPMUnregisterPrefsChangeNotification(int *a1)
{
  int v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      notify_cancel(v2);
    *a1 = 0;
    free(a1);
  }
}

const __CFString *getGenericPrefsPath()
{
  return CFSTR("com.apple.PowerManagement");
}

uint64_t getHostPrefsPath()
{
  const void *v0;
  CFTypeID TypeID;
  int v2;
  int v3;
  timespec v5;
  uint8_t buf[4];
  int v7;
  uuid_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = (timespec)xmmword_18AB46010;
  v0 = (const void *)getHostPrefsPath_uuidStr;
  TypeID = CFStringGetTypeID();
  if (!v0 || CFGetTypeID(v0) != TypeID)
  {
    memset(v8, 0, sizeof(v8));
    v2 = gethostuuid(v8, &v5);
    if (v2)
    {
      v3 = v2;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v7 = v3;
        _os_log_impl(&dword_18AAAF000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Failed to get UUID. rc=%d\n", buf, 8u);
      }
    }
    else
    {
      snprintf((char *)buf, 0x64uLL, "%s.%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X", "com.apple.PowerManagement", v8[0], v8[1], v8[2], v8[3], v8[4], v8[5], v8[6], v8[7], v8[8], v8[9], v8[10], v8[11], v8[12], v8[13], v8[14],
        v8[15]);
      getHostPrefsPath_uuidStr = (uint64_t)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)buf, 0);
    }
  }
  return getHostPrefsPath_uuidStr;
}

const __CFSet *isA_GenericPref(void *value)
{
  const __CFSet *result;
  _OWORD v3[6];
  const __CFString *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v3[4] = xmmword_1E2001BD0;
  v3[5] = *(_OWORD *)off_1E2001BE0;
  v4 = CFSTR("VAC-T");
  v3[0] = xmmword_1E2001B90;
  v3[1] = *(_OWORD *)&off_1E2001BA0;
  v3[2] = xmmword_1E2001BB0;
  v3[3] = *(_OWORD *)&off_1E2001BC0;
  result = (const __CFSet *)isA_GenericPref_genericSet;
  if (isA_GenericPref_genericSet)
    return (const __CFSet *)(CFSetContainsValue(result, value) != 0);
  result = CFSetCreate(0, (const void **)v3, 13, MEMORY[0x1E0C9B3B0]);
  isA_GenericPref_genericSet = (uint64_t)result;
  if (result)
    return (const __CFSet *)(CFSetContainsValue(result, value) != 0);
  return result;
}

__CFDictionary *copyPreferencesForSrc(__CFString *a1)
{
  const __CFString *HostPrefsPath;
  const __CFDictionary *v3;
  CFTypeID TypeID;
  __CFDictionary *MutableCopy;
  CFPropertyListRef v6;
  CFTypeID v7;

  HostPrefsPath = (const __CFString *)getHostPrefsPath();
  v3 = (const __CFDictionary *)IOPMCopyFromPrefs(CFSTR("com.apple.PowerManagement"), a1);
  TypeID = CFDictionaryGetTypeID();
  if (v3 && CFGetTypeID(v3) == TypeID)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v3);
  else
    MutableCopy = 0;
  v6 = IOPMCopyFromPrefs(HostPrefsPath, a1);
  v7 = CFDictionaryGetTypeID();
  if (!v6 || CFGetTypeID(v6) != v7)
  {
LABEL_9:
    if (!v3)
      goto LABEL_11;
    goto LABEL_10;
  }
  if (MutableCopy)
  {
    mergeDictIntoMutable(MutableCopy, (CFDictionaryRef)v6, 0);
    goto LABEL_9;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v6);
  if (v3)
LABEL_10:
    CFRelease(v3);
LABEL_11:
  if (v6)
    CFRelease(v6);
  return MutableCopy;
}

CFPropertyListRef IOPMCopyFromPrefs(const __CFString *a1, __CFString *value)
{
  const __CFString *HostPrefsPath;
  CFTypeID TypeID;
  CFTypeID v5;
  CFTypeID v6;

  HostPrefsPath = a1;
  if (!a1)
  {
    if (!isA_GenericPref(value))
    {
      HostPrefsPath = (const __CFString *)getHostPrefsPath();
      TypeID = CFStringGetTypeID();
      if (!HostPrefsPath)
        return 0;
      goto LABEL_5;
    }
    HostPrefsPath = CFSTR("com.apple.PowerManagement");
  }
  TypeID = CFStringGetTypeID();
LABEL_5:
  v5 = TypeID;
  v6 = CFGetTypeID(HostPrefsPath);
  if (HostPrefsPath && v6 == v5)
    return CFPreferencesCopyValue(value, HostPrefsPath, (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]);
  return 0;
}

void mergeDictIntoMutable(__CFDictionary *a1, CFDictionaryRef theDict, int a3)
{
  int Count;
  uint64_t v7;
  const void **v8;
  const void **v9;
  const void **v10;
  const void **v11;
  const void **v12;
  const void *v13;
  const void *v14;

  Count = CFDictionaryGetCount(theDict);
  LODWORD(v7) = Count;
  if (Count)
  {
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
    v9 = (const void **)malloc_type_malloc(8 * (int)v7, 0xC0040B8AA526DuLL);
    v10 = v9;
    if (v8 && v9)
    {
      CFDictionaryGetKeysAndValues(theDict, v8, v9);
      if ((int)v7 >= 1)
      {
        v7 = v7;
        v11 = v8;
        v12 = v10;
        do
        {
          v13 = *v11;
          v14 = *v12;
          if (a3)
            CFDictionarySetValue(a1, v13, v14);
          else
            CFDictionaryAddValue(a1, v13, v14);
          ++v12;
          ++v11;
          --v7;
        }
        while (v7);
      }
    }
    else if (!v8)
    {
      goto LABEL_13;
    }
    free(v8);
LABEL_13:
    if (v10)
      free(v10);
  }
}

uint64_t setPreferencesForSrc(__CFString *a1, const __CFDictionary *a2, int a3)
{
  const __CFString *HostPrefsPath;
  CFIndex Count;
  uint64_t v7;
  size_t v8;
  const void **v9;
  const void **v10;
  const void **v11;
  __CFDictionary *v12;
  char v13;
  uint64_t v14;
  __CFDictionary *v15;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  uint64_t v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  __CFDictionary *v25;

  HostPrefsPath = (const __CFString *)getHostPrefsPath();
  if (!a2)
  {
    CFPreferencesSetValue(a1, 0, CFSTR("com.apple.PowerManagement"), (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]);
    goto LABEL_26;
  }
  Count = CFDictionaryGetCount(a2);
  if (!Count)
  {
LABEL_26:
    v12 = 0;
    v15 = 0;
    v11 = 0;
    v9 = 0;
    goto LABEL_27;
  }
  v7 = Count;
  v8 = 8 * Count;
  v9 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  v10 = (const void **)malloc_type_malloc(v8, 0xC0040B8AA526DuLL);
  v11 = v10;
  v12 = 0;
  v13 = 1;
  if (!v9 || !v10)
  {
    v15 = 0;
    goto LABEL_32;
  }
  CFDictionaryGetKeysAndValues(a2, v9, v10);
  if (v7 >= 1)
  {
    v14 = 0;
    v12 = 0;
    v15 = 0;
    while (1)
    {
      if (isA_GenericPref((void *)v9[v14]))
      {
        if (v15)
        {
          MutableCopy = v15;
        }
        else
        {
          v17 = (const __CFDictionary *)IOPMCopyFromPrefs(CFSTR("com.apple.PowerManagement"), a1);
          if (v17)
          {
            v18 = v17;
            MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v17);
            CFRelease(v18);
            if (!MutableCopy)
              goto LABEL_22;
          }
          else
          {
            MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (!MutableCopy)
            {
LABEL_22:
              v15 = 0;
              goto LABEL_19;
            }
          }
          v15 = MutableCopy;
        }
      }
      else if (v12)
      {
        MutableCopy = v12;
      }
      else
      {
        v19 = (const __CFDictionary *)IOPMCopyFromPrefs(HostPrefsPath, a1);
        if (v19)
        {
          v20 = v19;
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v19);
          CFRelease(v20);
          if (!MutableCopy)
            goto LABEL_24;
        }
        else
        {
          MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (!MutableCopy)
          {
LABEL_24:
            v12 = 0;
            goto LABEL_19;
          }
        }
        v12 = MutableCopy;
      }
      CFDictionarySetValue(MutableCopy, v9[v14], v11[v14]);
LABEL_19:
      if (v7 == ++v14)
      {
        if (v15)
        {
          CFPreferencesSetValue(a1, v15, CFSTR("com.apple.PowerManagement"), (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]);
          v13 = 0;
          goto LABEL_32;
        }
LABEL_27:
        v13 = 1;
        goto LABEL_32;
      }
    }
  }
  v12 = 0;
  v15 = 0;
LABEL_32:
  if (a3)
  {
    v21 = CFPreferencesSynchronize(CFSTR("com.apple.PowerManagement"), (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]) != 0;
    if (!HostPrefsPath)
      goto LABEL_42;
  }
  else
  {
    v21 = 0;
    if (!HostPrefsPath)
      goto LABEL_42;
  }
  if (v12)
  {
    v22 = (const __CFString *)*MEMORY[0x1E0C9B240];
    v23 = (const __CFString *)*MEMORY[0x1E0C9B250];
    v24 = a1;
    v25 = v12;
LABEL_38:
    CFPreferencesSetValue(v24, v25, HostPrefsPath, v22, v23);
    goto LABEL_40;
  }
  if (!a2)
  {
    v22 = (const __CFString *)*MEMORY[0x1E0C9B240];
    v23 = (const __CFString *)*MEMORY[0x1E0C9B250];
    v24 = a1;
    v25 = 0;
    goto LABEL_38;
  }
LABEL_40:
  if (a3)
    v21 = (v21 & CFPreferencesSynchronize(HostPrefsPath, (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]));
LABEL_42:
  if (v9)
    free(v9);
  if (v11)
    free(v11);
  if ((v13 & 1) == 0)
    CFRelease(v15);
  if (v12)
    CFRelease(v12);
  return v21;
}

__CFDictionary *IOPMCopyPreferencesOnFile()
{
  __CFDictionary *Mutable;
  uint64_t i;
  __CFString *v2;
  __CFDictionary *v3;
  CFTypeID TypeID;

  Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    for (i = 0; i != 3; ++i)
    {
      v2 = off_1E2001BF8[i];
      v3 = copyPreferencesForSrc(v2);
      TypeID = CFDictionaryGetTypeID();
      if (v3 && CFGetTypeID(v3) == TypeID)
      {
        CFDictionarySetValue(Mutable, v2, v3);
        CFRelease(v3);
      }
    }
  }
  return Mutable;
}

__CFDictionary *IOPMCopyPMPreferences()
{
  __CFDictionary *v0;
  __CFDictionary *v1;
  __CFDictionary *v2;
  __CFDictionary *Mutable;
  __CFDictionary *SystemProvidedPreferences;
  const __CFDictionary *v5;
  const __CFDictionary *Value;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  __CFDictionary *v14;
  CFIndex v15;
  __CFDictionary *v16;
  __CFDictionary *v17;
  CFIndex v18;
  __CFDictionary *v19;
  __CFDictionary *v20;

  v0 = copyPreferencesForSrc(CFSTR("AC Power"));
  v1 = copyPreferencesForSrc(CFSTR("Battery Power"));
  v2 = copyPreferencesForSrc(CFSTR("UPS Power"));
  Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    SystemProvidedPreferences = getSystemProvidedPreferences();
    if (SystemProvidedPreferences)
    {
      v5 = SystemProvidedPreferences;
      Value = (const __CFDictionary *)CFDictionaryGetValue(SystemProvidedPreferences, CFSTR("AC Power"));
      if (Value)
      {
        v7 = Value;
        v8 = (const __CFDictionary *)CFDictionaryGetValue(v5, CFSTR("Battery Power"));
        if (v8)
        {
          v9 = v8;
          v10 = (const __CFDictionary *)CFDictionaryGetValue(v5, CFSTR("Battery Power"));
          if (v10)
          {
            v11 = v10;
            if (v0)
            {
              Count = CFDictionaryGetCount(v0);
              MutableCopy = CFDictionaryCreateMutableCopy(0, Count, v0);
            }
            else
            {
              MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            }
            v14 = MutableCopy;
            if (MutableCopy)
            {
              mergeDictIntoMutable(MutableCopy, v7, 0);
              CFDictionarySetValue(Mutable, CFSTR("AC Power"), v14);
              CFRelease(v14);
              if (v1)
              {
                v15 = CFDictionaryGetCount(v1);
                v16 = CFDictionaryCreateMutableCopy(0, v15, v1);
              }
              else
              {
                v16 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              }
              v17 = v16;
              if (v16)
              {
                mergeDictIntoMutable(v16, v9, 0);
                CFDictionarySetValue(Mutable, CFSTR("Battery Power"), v17);
                CFRelease(v17);
                if (v2)
                {
                  v18 = CFDictionaryGetCount(v2);
                  v19 = CFDictionaryCreateMutableCopy(0, v18, v2);
                }
                else
                {
                  v19 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                }
                v20 = v19;
                if (v19)
                {
                  mergeDictIntoMutable(v19, v11, 0);
                  CFDictionarySetValue(Mutable, CFSTR("UPS Power"), v20);
                  CFRelease(v20);
                  IOPMRemoveIrrelevantProperties(Mutable);
                }
              }
            }
          }
        }
      }
      CFRelease(v5);
    }
  }
  if (v0)
    CFRelease(v0);
  if (v1)
    CFRelease(v1);
  if (v2)
    CFRelease(v2);
  return Mutable;
}

__CFDictionary *getSystemProvidedPreferences()
{
  io_registry_entry_t v0;
  const __CFAllocator *v1;
  const __CFDictionary *CFProperty;
  CFTypeID TypeID;
  const __CFDictionary *Value;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _BOOL4 v8;
  BOOL v9;
  BOOL v10;
  int v11;
  __CFDictionary *v12;
  __CFDictionary *v13;
  const __CFDictionary *v14;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v16;
  const CFDictionaryKeyCallBacks *v17;
  const CFDictionaryValueCallBacks *v18;
  __CFDictionary *Mutable;
  __CFDictionary *v20;
  __CFDictionary *v21;
  uint64_t i;
  CFStringRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  __CFDictionary *v30;
  const __CFDictionary *v31;
  CFIndex Count;
  const __CFDictionary *v33;
  CFIndex v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  CFIndex v37;
  __CFDictionary *v38;
  char v40;
  const __CFDictionary *Copy;
  const __CFDictionary *theDict;
  const __CFDictionary *cf;
  int v44;
  int valuePtr;
  BOOL v46;

  v0 = getPMRootDomainRef_cached_root_domain;
  if (!getPMRootDomainRef_cached_root_domain)
  {
    v0 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    getPMRootDomainRef_cached_root_domain = v0;
    if (!v0)
      return 0;
  }
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(v0, CFSTR("SystemPowerProfileOverrideDict"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  TypeID = CFDictionaryGetTypeID();
  if (CFProperty && CFGetTypeID(CFProperty) == TypeID)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(CFProperty, CFSTR("AC Power"));
    v5 = (const __CFDictionary *)CFDictionaryGetValue(CFProperty, CFSTR("Battery Power"));
    v6 = (const __CFDictionary *)CFDictionaryGetValue(CFProperty, CFSTR("UPS Power"));
    v7 = (unint64_t)Value | (unint64_t)v5 | (unint64_t)v6;
    v8 = v7 != 0;
    if (v7)
    {
      if (Value)
        v9 = v5 == 0;
      else
        v9 = 1;
      v10 = v9 || v6 == 0;
      theDict = v5;
      cf = Value;
      Copy = v6;
      if (v10)
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v14 = 0;
        MutableCopy = 0;
        v16 = 0;
        goto LABEL_77;
      }
    }
    else
    {
      cf = CFDictionaryCreateCopy(0, CFProperty);
      theDict = CFDictionaryCreateCopy(0, CFProperty);
      Copy = CFDictionaryCreateCopy(0, CFProperty);
    }
    v40 = 0;
    v11 = !v8;
    overridesSet = 1;
  }
  else
  {
    theDict = 0;
    cf = 0;
    Copy = 0;
    v11 = 0;
    v40 = 1;
  }
  v17 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v18 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v20 = CFDictionaryCreateMutable(0, 0, v17, v18);
  v21 = CFDictionaryCreateMutable(0, 0, v17, v18);
  for (i = 0; i != 81; i += 3)
  {
    v23 = CFStringCreateWithCString(0, (&defaultSettings)[i], 0);
    if (Mutable)
    {
      v24 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&defaultSettings + 8 * i + 12);
      CFDictionarySetValue(Mutable, v23, v24);
      CFRelease(v24);
    }
    if (v20)
    {
      v25 = CFNumberCreate(0, kCFNumberSInt32Type, &(&defaultSettings)[i + 1]);
      CFDictionarySetValue(v20, v23, v25);
      CFRelease(v25);
    }
    if (v21)
    {
      v26 = CFNumberCreate(0, kCFNumberSInt32Type, &(&defaultSettings)[i + 2]);
      CFDictionarySetValue(v21, v23, v26);
      CFRelease(v26);
    }
    CFRelease(v23);
  }
  if (Mutable)
    CFDictionarySetValue(Mutable, CFSTR("Hibernate File"), CFSTR("/var/vm/sleepimage"));
  if (v20)
    CFDictionarySetValue(v20, CFSTR("Hibernate File"), CFSTR("/var/vm/sleepimage"));
  if (v21)
    CFDictionarySetValue(v21, CFSTR("Hibernate File"), CFSTR("/var/vm/sleepimage"));
  v46 = 0;
  if (!IOPSGetSupportedPowerSources(0, &v46, 0) && v46)
  {
    valuePtr = 3;
    v27 = CFNumberCreate(v1, kCFNumberSInt32Type, &valuePtr);
    if (Mutable)
      CFDictionarySetValue(Mutable, CFSTR("Hibernate Mode"), v27);
    if (v20)
      CFDictionarySetValue(v20, CFSTR("Hibernate Mode"), v27);
    if (v21)
      CFDictionarySetValue(v21, CFSTR("Hibernate Mode"), v27);
    CFRelease(v27);
    v44 = 1;
    v28 = CFNumberCreate(v1, kCFNumberSInt32Type, &v44);
    if (v28)
    {
      v29 = v28;
      if (Mutable)
        CFDictionarySetValue(Mutable, CFSTR("Standby Enabled"), v28);
      if (v20)
        CFDictionarySetValue(v20, CFSTR("Standby Enabled"), v29);
      if (v21)
        CFDictionarySetValue(v21, CFSTR("Standby Enabled"), v29);
      CFRelease(v29);
    }
  }
  v30 = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v12 = v30;
  if (v30)
  {
    CFDictionaryAddValue(v30, CFSTR("AC Power"), v20);
    CFDictionaryAddValue(v12, CFSTR("Battery Power"), Mutable);
    CFDictionaryAddValue(v12, CFSTR("UPS Power"), v21);
  }
  if (v20)
    CFRelease(v20);
  if (Mutable)
    CFRelease(Mutable);
  if (v21)
    CFRelease(v21);
  if (!v12)
  {
    v16 = 0;
    MutableCopy = 0;
LABEL_68:
    v14 = 0;
    goto LABEL_69;
  }
  v31 = (const __CFDictionary *)CFDictionaryGetValue(v12, CFSTR("AC Power"));
  MutableCopy = v31;
  if (v31)
  {
    Count = CFDictionaryGetCount(v31);
    MutableCopy = CFDictionaryCreateMutableCopy(0, Count, MutableCopy);
    if (!MutableCopy)
    {
      v16 = 0;
      goto LABEL_68;
    }
  }
  v33 = (const __CFDictionary *)CFDictionaryGetValue(v12, CFSTR("Battery Power"));
  v14 = v33;
  if (v33)
  {
    v34 = CFDictionaryGetCount(v33);
    v14 = CFDictionaryCreateMutableCopy(0, v34, v14);
    if (!v14)
    {
      v16 = 0;
LABEL_69:
      v13 = 0;
      if (!CFProperty)
        goto LABEL_78;
      goto LABEL_77;
    }
  }
  v35 = (const __CFDictionary *)CFDictionaryGetValue(v12, CFSTR("UPS Power"));
  if (v35)
  {
    v36 = v35;
    v37 = CFDictionaryGetCount(v35);
    v13 = CFDictionaryCreateMutableCopy(0, v37, v36);
    if (!v13)
    {
      v16 = 0;
      if (!CFProperty)
        goto LABEL_78;
      goto LABEL_77;
    }
  }
  else
  {
    v13 = 0;
  }
  if ((v40 & 1) == 0)
  {
    mergeDictIntoMutable(MutableCopy, cf, 1);
    mergeDictIntoMutable(v14, theDict, 1);
    mergeDictIntoMutable(v13, Copy, 1);
  }
  v38 = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v16 = v38;
  if (v38)
  {
    CFDictionaryAddValue(v38, CFSTR("AC Power"), MutableCopy);
    CFDictionaryAddValue(v16, CFSTR("Battery Power"), v14);
    CFDictionaryAddValue(v16, CFSTR("UPS Power"), v13);
  }
  if (!CFProperty)
    goto LABEL_78;
LABEL_77:
  CFRelease(CFProperty);
LABEL_78:
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (v14)
    CFRelease(v14);
  if (v13)
    CFRelease(v13);
  if (v12)
  {
    CFRelease(v12);
    if ((v11 & 1) == 0)
      return v16;
  }
  else if (!v11)
  {
    return v16;
  }
  if (cf)
    CFRelease(cf);
  if (theDict)
    CFRelease(theDict);
  if (Copy)
    CFRelease(Copy);
  return v16;
}

uint64_t comparePrefsToDefaults(const __CFDictionary *a1, const void *a2)
{
  CFIndex Count;
  uint64_t v5;
  __CFDictionary *SystemProvidedPreferences;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void **v9;
  const void **v10;
  const void **v11;
  const void **v12;
  CFTypeRef *v13;
  uint64_t v14;
  void *value;

  value = 0;
  if (!a1)
    return 1;
  Count = CFDictionaryGetCount(a1);
  if (!Count)
    return 1;
  v5 = Count;
  SystemProvidedPreferences = getSystemProvidedPreferences();
  v7 = (const __CFDictionary *)CFDictionaryGetValue(SystemProvidedPreferences, a2);
  if (v7)
  {
    v8 = v7;
    if (CFDictionaryGetCount(v7))
    {
      v9 = (const void **)malloc_type_malloc(8 * v5, 0x6004044C4A2DFuLL);
      v10 = (const void **)malloc_type_malloc(8 * v5, 0xC0040B8AA526DuLL);
      v11 = v10;
      if (v9 && v10)
      {
        CFDictionaryGetKeysAndValues(a1, v9, v10);
        if (v5 < 1)
        {
LABEL_12:
          v14 = 1;
        }
        else
        {
          v12 = v9;
          v13 = v11;
          while (1)
          {
            value = 0;
            if (!CFDictionaryGetValueIfPresent(v8, *v12, (const void **)&value) || !CFEqual(value, *v13))
              break;
            ++v13;
            ++v12;
            if (!--v5)
              goto LABEL_12;
          }
          v14 = 0;
        }
      }
      else
      {
        v14 = 0;
        if (!v9)
        {
LABEL_19:
          if (v11)
            free(v11);
          goto LABEL_21;
        }
      }
      free(v9);
      goto LABEL_19;
    }
  }
  v14 = 0;
LABEL_21:
  if (SystemProvidedPreferences)
    CFRelease(SystemProvidedPreferences);
  return v14;
}

uint64_t IOPMUsingDefaultPreferences(__CFString *a1)
{
  CFTypeID TypeID;
  __CFDictionary *v3;
  uint64_t v4;
  __CFDictionary *v5;
  __CFDictionary *v6;

  TypeID = CFStringGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    v3 = copyPreferencesForSrc(a1);
    v4 = comparePrefsToDefaults(v3, a1);
    goto LABEL_12;
  }
  v5 = copyPreferencesForSrc(CFSTR("AC Power"));
  v6 = copyPreferencesForSrc(CFSTR("Battery Power"));
  v3 = copyPreferencesForSrc(CFSTR("UPS Power"));
  if (!comparePrefsToDefaults(v5, CFSTR("AC Power"))
    || !comparePrefsToDefaults(v6, CFSTR("Battery Power")))
  {
    v4 = 0;
    if (!v5)
      goto LABEL_10;
    goto LABEL_9;
  }
  v4 = comparePrefsToDefaults(v3, CFSTR("UPS Power"));
  if (v5)
LABEL_9:
    CFRelease(v5);
LABEL_10:
  if (v6)
    CFRelease(v6);
LABEL_12:
  if (v3)
    CFRelease(v3);
  return v4;
}

uint64_t IOPMRevertPMPreferences(const __CFArray *a1)
{
  __CFDictionary *v2;
  const __CFDictionary *v3;
  uint64_t v4;
  int Count;
  CFIndex v6;
  uint64_t v7;
  const void *ValueAtIndex;
  CFTypeID TypeID;
  const __CFDictionary *v10;

  v2 = IOPMCopyPreferencesOnFile();
  if (!v2)
    return 3758097097;
  v3 = v2;
  if ((IOPMUsingDefaultPreferences(0) & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (a1 && (Count = CFArrayGetCount(a1)) != 0)
    {
      if (Count >= 1)
      {
        v6 = 0;
        v7 = Count;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a1, v6);
          TypeID = CFStringGetTypeID();
          if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == TypeID)
          {
            updatePrefsDict(v3, CFSTR("AC Power"), ValueAtIndex, 0);
            updatePrefsDict(v3, CFSTR("Battery Power"), ValueAtIndex, 0);
            updatePrefsDict(v3, CFSTR("UPS Power"), ValueAtIndex, 0);
          }
          ++v6;
        }
        while (v7 != v6);
      }
      v10 = v3;
    }
    else
    {
      v10 = 0;
    }
    v4 = IOPMSetPMPreferences(v10);
  }
  CFRelease(v3);
  return v4;
}

uint64_t IOPMSetPMPreferences(const __CFDictionary *a1)
{
  uint64_t v2;
  const __CFDictionary *Value;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  char v6;
  char v7;
  int v8;

  v2 = 3758097084;
  if (getuid() && geteuid())
    return 3758097089;
  if (!a1)
  {
    setPreferencesForSrc(CFSTR("AC Power"), 0, 0);
    setPreferencesForSrc(CFSTR("Battery Power"), 0, 0);
    if ((setPreferencesForSrc(CFSTR("UPS Power"), 0, 1) & 1) == 0)
      return v2;
    goto LABEL_8;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("AC Power"));
  v4 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("Battery Power"));
  v5 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("UPS Power"));
  v6 = setPreferencesForSrc(CFSTR("AC Power"), Value, ((unint64_t)v4 | (unint64_t)v5) == 0);
  v7 = setPreferencesForSrc(CFSTR("Battery Power"), v4, v5 == 0);
  v8 = setPreferencesForSrc(CFSTR("UPS Power"), v5, 1);
  if ((v6 & 1) != 0 || (v7 & 1) != 0 || v8)
  {
LABEL_8:
    notify_post("com.apple.system.powermanagement.prefschange");
    return 0;
  }
  return v2;
}

void updatePrefsDict(const __CFDictionary *a1, const void *a2, const void *a3, const void *a4)
{
  const __CFDictionary *Value;
  const __CFDictionary *v9;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  __CFDictionary *v12;

  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    v9 = Value;
    Count = CFDictionaryGetCount(Value);
    MutableCopy = CFDictionaryCreateMutableCopy(0, Count, v9);
    if (MutableCopy)
    {
      v12 = MutableCopy;
      if (a4)
        CFDictionarySetValue(MutableCopy, a3, a4);
      else
        CFDictionaryRemoveValue(MutableCopy, a3);
      CFDictionarySetValue(a1, a2, v12);
      CFRelease(v12);
    }
  }
}

uint64_t IOPMSetPMPreference(const void *a1, const void *a2, const __CFString *a3)
{
  uint64_t v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFString *v10;

  v6 = 3758097084;
  v7 = IOPMCopyPreferencesOnFile();
  if (!v7)
    return v6;
  v8 = v7;
  if (a3)
  {
    if (!CFDictionaryContainsKey(v7, a3))
    {
      v6 = 3758097090;
      goto LABEL_11;
    }
    v9 = v8;
    v10 = a3;
    if (!a1)
    {
      CFDictionaryRemoveValue(v8, a3);
LABEL_9:
      v6 = IOPMSetPMPreferences(v8);
LABEL_11:
      CFRelease(v8);
      return v6;
    }
LABEL_8:
    updatePrefsDict(v9, v10, a1, a2);
    goto LABEL_9;
  }
  if (a1)
  {
    updatePrefsDict(v7, CFSTR("AC Power"), a1, a2);
    updatePrefsDict(v8, CFSTR("Battery Power"), a1, a2);
    v10 = CFSTR("UPS Power");
    v9 = v8;
    goto LABEL_8;
  }
  CFRelease(v7);
  return IOPMSetPMPreferences(0);
}

uint64_t IOPMWriteToPrefs(__CFString *a1, const void *a2, int a3, int a4)
{
  const __CFString *HostPrefsPath;
  const __CFString *v10;
  const __CFString *v11;
  int v12;
  BOOL v13;

  if (getuid() && geteuid())
    return 3758097089;
  if ((isA_GenericPref(a1) & 1) != 0)
    HostPrefsPath = CFSTR("com.apple.PowerManagement");
  else
    HostPrefsPath = (const __CFString *)getHostPrefsPath();
  v10 = (const __CFString *)*MEMORY[0x1E0C9B240];
  v11 = (const __CFString *)*MEMORY[0x1E0C9B250];
  CFPreferencesSetValue(a1, a2, HostPrefsPath, (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]);
  if (a3)
  {
    v12 = CFPreferencesSynchronize(HostPrefsPath, v10, v11);
    if (v12)
      v13 = a4 == 0;
    else
      v13 = 1;
    if (v13)
    {
      if (!v12)
        return 3758097084;
    }
    else
    {
      notify_post("com.apple.system.powermanagement.prefschange");
    }
  }
  return 0;
}

uint64_t IOPMFeatureIsAvailable(const void *a1, const __CFString *a2)
{
  io_registry_entry_t v4;
  const __CFDictionary *CFProperty;
  const __CFDictionary *v6;
  uint64_t IsAvailableWithSupportedTable;

  v4 = getPMRootDomainRef_cached_root_domain;
  if (!getPMRootDomainRef_cached_root_domain)
  {
    v4 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    getPMRootDomainRef_cached_root_domain = v4;
    if (!v4)
      return 0;
  }
  CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(v4, CFSTR("Supported Features"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!CFProperty)
    return 0;
  v6 = CFProperty;
  if (CFEqual(a1, CFSTR("DarkWakeBackgroundTasks")) || CFEqual(a1, CFSTR("SleepServices")))
    IsAvailableWithSupportedTable = 1;
  else
    IsAvailableWithSupportedTable = IOPMFeatureIsAvailableWithSupportedTable(a1, a2, v6);
  CFRelease(v6);
  return IsAvailableWithSupportedTable;
}

uint64_t getPMRootDomainRef()
{
  uint64_t result;

  result = getPMRootDomainRef_cached_root_domain;
  if (!getPMRootDomainRef_cached_root_domain)
  {
    result = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    getPMRootDomainRef_cached_root_domain = result;
  }
  return result;
}

uint64_t IOPMFeatureIsAvailableWithSupportedTable(const void *a1, const __CFString *a2, const __CFDictionary *a3)
{
  const __CFString *v3;
  uint64_t result;
  const void *v7;
  __int16 v8;

  if (a2)
    v3 = a2;
  else
    v3 = CFSTR("AC Power");
  if (!a3)
    return 0;
  if (CFEqual(a1, CFSTR("Display Sleep Timer"))
    || CFEqual(a1, CFSTR("System Sleep Timer"))
    || CFEqual(a1, CFSTR("Disk Sleep Timer"))
    || CFEqual(a1, CFSTR("TTYSPreventSleep"))
    || CFEqual(a1, CFSTR("SleepDisabled"))
    || CFEqual(a1, CFSTR("DestroyFVKeyOnStandby"))
    || CFEqual(a1, CFSTR("UnifiedSleepSliderPref"))
    || CFEqual(a1, CFSTR("PowerNap"))
    || CFEqual(a1, CFSTR("SleepServices"))
    || CFEqual(a1, CFSTR("Standby Enabled")))
  {
    return 1;
  }
  if (CFEqual(a1, CFSTR("RestartAfterKernelPanic")) || CFEqual(a1, CFSTR("Sleep On Power Button")))
    return 0;
  if (CFEqual(a1, CFSTR("ReduceBrightness")))
  {
    v8 = 0;
    IOPSGetSupportedPowerSources(0, (BOOL *)&v8 + 1, (BOOL *)&v8);
    return HIBYTE(v8) && !CFEqual(v3, CFSTR("AC Power"))
        || (_BYTE)v8 && CFDictionaryGetValue(a3, CFSTR("DisplayDims")) && !CFEqual(v3, CFSTR("AC Power"));
  }
  if (CFEqual(a1, CFSTR("Carrier Mode"))
    || CFEqual(a1, CFSTR("Carrier Mode Low Voltage"))
    || CFEqual(a1, CFSTR("Carrier Mode High Voltage")))
  {
    return 1;
  }
  result = (uint64_t)supportedNameForPMName(a1);
  if (result)
  {
    v7 = (const void *)result;
    if (CFEqual((CFTypeRef)result, CFSTR("Hibernation")) && overridesSet != 1)
      return 0;
    result = (uint64_t)CFDictionaryGetValue(a3, v7);
    if (result)
      return featureSupportsPowerSource((const __CFNumber *)result, v3);
  }
  return result;
}

const __CFString *supportedNameForPMName(const void *a1)
{
  const __CFString *result;
  int v3;
  int v4;

  if (CFEqual(a1, CFSTR("ReduceBrightness")) || CFEqual(a1, CFSTR("Display Sleep Uses Dim")))
    return CFSTR("DisplayDims");
  if (CFEqual(a1, CFSTR("Wake On LAN")) || CFEqual(a1, CFSTR("PrioritizeNetworkReachabilityOverSleep")))
    return CFSTR("WakeOnMagicPacket");
  if (CFEqual(a1, CFSTR("Mobile Motion Module")))
    return CFSTR("MobileMotionModule");
  if (CFEqual(a1, CFSTR("Hibernate Mode"))
    || CFEqual(a1, CFSTR("Hibernate Free Ratio"))
    || CFEqual(a1, CFSTR("Hibernate Free Time"))
    || CFEqual(a1, CFSTR("Hibernate File")))
  {
    return CFSTR("Hibernation");
  }
  v3 = CFEqual(a1, CFSTR("Hibernation"));
  result = CFSTR("Hibernation");
  if (!v3)
  {
    if (CFEqual(a1, CFSTR("Standby Enabled"))
      || CFEqual(a1, CFSTR("Standby Delay"))
      || CFEqual(a1, CFSTR("High Standby Delay"))
      || CFEqual(a1, CFSTR("Standby Battery Threshold")))
    {
      return CFSTR("DeepSleep");
    }
    else if (CFEqual(a1, CFSTR("AutoPowerOff Enabled")) || CFEqual(a1, CFSTR("AutoPowerOff Delay")))
    {
      return CFSTR("AutoPowerOff");
    }
    else if (CFEqual(a1, CFSTR("ProximityDarkWake")))
    {
      return CFSTR("ProximityWake");
    }
    else if (CFEqual(a1, CFSTR("Carrier Mode")))
    {
      return CFSTR("CarrierChargingMode");
    }
    else
    {
      v4 = CFEqual(a1, CFSTR("Carrier Mode High Voltage"));
      result = CFSTR("CarrierChargingMode");
      if (!v4)
      {
        if (CFEqual(a1, CFSTR("Carrier Mode Low Voltage")))
          return CFSTR("CarrierChargingMode");
        else
          return (const __CFString *)a1;
      }
    }
  }
  return result;
}

uint64_t featureSupportsPowerSource(const __CFNumber *a1, const void *a2)
{
  CFTypeID TypeID;
  CFTypeID v5;
  uint64_t Count;
  int v7;
  CFIndex v8;
  const __CFNumber *ValueAtIndex;
  CFTypeID v10;
  uint64_t result;
  uint64_t valuePtr;

  valuePtr = 0;
  TypeID = CFNumberGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID)
    {
      CFNumberGetValue(a1, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    }
    else
    {
      v5 = CFArrayGetTypeID();
      if (CFGetTypeID(a1) == v5)
      {
        Count = CFArrayGetCount(a1);
        if (Count)
        {
          v7 = 0;
          v8 = 0;
          do
          {
            ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, v8);
            v10 = CFNumberGetTypeID();
            if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v10)
            {
              CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
              v7 |= valuePtr;
              HIDWORD(valuePtr) = v7;
            }
            ++v8;
          }
          while (Count != v8);
        }
      }
    }
  }
  else
  {
    CFArrayGetTypeID();
  }
  if (!a2)
    return HIDWORD(valuePtr) != 0;
  if (CFEqual(CFSTR("AC Power"), a2))
    return BYTE4(valuePtr) & 1;
  if (CFEqual(CFSTR("Battery Power"), a2))
    return (BYTE4(valuePtr) >> 1) & 1;
  result = CFEqual(CFSTR("UPS Power"), a2);
  if ((_DWORD)result)
    return (BYTE4(valuePtr) >> 2) & 1;
  return result;
}

void IOPMRemoveIrrelevantProperties(const __CFDictionary *a1)
{
  io_registry_entry_t v2;
  const __CFDictionary *CFProperty;
  int Count;
  const void **v5;
  const void **v6;
  const void **v7;
  int v8;
  char v9;
  int v10;
  CFTypeRef *v11;
  int v12;
  char v13;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  CFMutableDictionaryRef MutableCopy;
  BOOL v17;
  CFMutableDictionaryRef v18;
  const void **v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  const __CFDictionary *v23;
  const void **v24;
  const void **v25;
  const void **v26;
  void **keys;

  v2 = getPMRootDomainRef_cached_root_domain;
  if (getPMRootDomainRef_cached_root_domain
    || (v2 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain"),
        (getPMRootDomainRef_cached_root_domain = v2) != 0))
  {
    CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(v2, CFSTR("Supported Features"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  }
  else
  {
    CFProperty = 0;
  }
  Count = CFDictionaryGetCount(a1);
  v5 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  v6 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  v7 = v6;
  if (!v5 || !v6)
    goto LABEL_40;
  v8 = checkPowerSourceSupported(CFSTR("Battery Power"));
  v9 = checkPowerSourceSupported(CFSTR("UPS Power"));
  CFDictionaryGetKeysAndValues(a1, v5, v7);
  if (Count < 1)
  {
LABEL_41:
    free(v5);
    goto LABEL_42;
  }
  v24 = v7;
  v25 = 0;
  v26 = v5;
  keys = 0;
  do
  {
    v10 = Count--;
    v11 = &v5[v10 - 1];
    while (1)
    {
      if (CFEqual(*v11, CFSTR("Battery Power")))
        v12 = v8;
      else
        v12 = 1;
      if (v12 != 1 || (!CFEqual(*v11, CFSTR("UPS Power")) ? (v13 = 1) : (v13 = v9), (v13 & 1) == 0))
      {
        CFDictionaryRemoveValue(a1, *v11);
LABEL_24:
        v5 = v26;
        goto LABEL_25;
      }
      Value = (const __CFDictionary *)CFDictionaryGetValue(a1, *v11);
      TypeID = CFDictionaryGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == TypeID)
        {
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
          if (MutableCopy)
            break;
        }
      }
      --Count;
      --v11;
      v17 = __OFSUB__(v10--, 1);
      if ((v10 < 0) ^ v17 | (v10 == 0))
      {
        v5 = v26;
        goto LABEL_36;
      }
    }
    v18 = MutableCopy;
    CFDictionarySetValue(a1, *v11, MutableCopy);
    CFRelease(v18);
    v22 = CFDictionaryGetCount(v18);
    keys = (void **)malloc_type_malloc(8 * v22, 0x6004044C4A2DFuLL);
    v19 = (const void **)malloc_type_malloc(8 * v22, 0x6004044C4A2DFuLL);
    v25 = v19;
    if (!keys || !v19)
      goto LABEL_24;
    v23 = CFProperty;
    CFDictionaryGetKeysAndValues(v18, (const void **)keys, v19);
    if (v22 >= 1)
    {
      v20 = v22 + 1;
      do
      {
        v21 = (v20 - 2);
        if (!CFEqual(keys[v21], CFSTR("DarkWakeBackgroundTasks"))
          && (IOPMFeatureIsAvailableWithSupportedTable(keys[v21], (const __CFString *)*v11, v23) & 1) == 0)
        {
          CFDictionaryRemoveValue(v18, keys[v21]);
        }
        --v20;
      }
      while (v20 > 1);
    }
    free(keys);
    free(v25);
    keys = 0;
    v25 = 0;
    CFProperty = v23;
    v5 = v26;
LABEL_25:
    ;
  }
  while (v10 > 1);
LABEL_36:
  if (keys)
    free(keys);
  v7 = v24;
  if (v25)
    free(v25);
LABEL_40:
  if (v5)
    goto LABEL_41;
LABEL_42:
  if (v7)
    free(v7);
  if (CFProperty)
    CFRelease(CFProperty);
}

uint64_t checkPowerSourceSupported(const void *a1)
{
  uint64_t result;
  int v3;
  __int16 v4;

  if (CFEqual(a1, CFSTR("AC Power")))
    return 1;
  v4 = 0;
  IOPSGetSupportedPowerSources(0, (BOOL *)&v4 + 1, (BOOL *)&v4);
  if (CFEqual(a1, CFSTR("Battery Power")))
  {
    v3 = HIBYTE(v4);
  }
  else
  {
    result = CFEqual(a1, CFSTR("UPS Power"));
    if (!(_DWORD)result)
      return result;
    v3 = v4;
  }
  return v3 != 0;
}

uint64_t IOPMActivateSystemPowerSettings()
{
  return 3758097095;
}

CFPropertyListRef IOPMCopySystemPowerSettings()
{
  CFPropertyListRef v0;
  CFTypeID TypeID;

  v0 = CFPreferencesCopyValue(CFSTR("SystemPowerSettings"), CFSTR("com.apple.PowerManagement"), (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B250]);
  TypeID = CFDictionaryGetTypeID();
  if (!v0)
    return 0;
  if (CFGetTypeID(v0) == TypeID)
    return v0;
  return 0;
}

uint64_t IOPMSetSystemPowerSetting()
{
  return 3758097084;
}

IOReturn IOPMSchedulePowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type)
{
  CFDateRef v6;
  char v7;
  const __CFData *v8;
  const __CFString *v10;
  double Current;
  CFNumberRef v12;
  CFNumberRef v13;
  const __CFData *Data;
  mach_port_t v15;
  const UInt8 *BytePtr;
  int Length;
  int valuePtr;
  CFTypeRef cf;
  mach_port_t v20;
  IOReturn v21;

  v20 = 0;
  v21 = -536870212;
  cf = 0;
  if ((inputsValid(time_to_wake, type) & 1) != 0)
  {
    if (CFEqual(type, CFSTR("MaintenanceImmediate")))
    {
      v6 = time_to_wake;
      v7 = 1;
LABEL_8:
      v8 = 0;
      v21 = doAMaintenanceWake((uint64_t)v6, v7);
      goto LABEL_9;
    }
    if (CFEqual(type, CFSTR("SleepServiceImmediate")))
    {
      v6 = time_to_wake;
      v7 = 2;
      goto LABEL_8;
    }
    if (CFEqual(type, CFSTR("WakeImmediate")))
    {
      v10 = CFSTR("wake");
LABEL_20:
      tellClockController(v10, (uint64_t)time_to_wake);
      v8 = 0;
      v21 = 0;
      goto LABEL_9;
    }
    if (CFEqual(type, CFSTR("PowerOnImmediate")))
    {
      v10 = CFSTR("poweron");
      goto LABEL_20;
    }
    if (CFEqual(type, CFSTR("WakeRelativeToSleep")) || CFEqual(type, CFSTR("PowerRelativeToShutdown")))
    {
      if (time_to_wake)
      {
        Current = CFAbsoluteTimeGetCurrent();
        valuePtr = (int)MEMORY[0x18D771BE0](time_to_wake) - (int)Current;
        if (valuePtr < 1)
          return -536870162;
      }
      else
      {
        valuePtr = 0;
      }
      v12 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      if (v12)
      {
        v13 = v12;
        v21 = _setRootDomainProperty(type, v12);
        CFRelease(v13);
      }
LABEL_29:
      v8 = 0;
      goto LABEL_9;
    }
    if (_pm_connect(&v20))
    {
      v8 = 0;
      v21 = -536870199;
      goto LABEL_9;
    }
    v21 = _IOPMCreatePowerOnDictionary(time_to_wake, my_id, type, (__CFDictionary **)&cf);
    if (v21)
      goto LABEL_29;
    Data = CFPropertyListCreateData(0, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    v8 = Data;
    if (Data)
    {
      v15 = v20;
      BytePtr = CFDataGetBytePtr(Data);
      Length = CFDataGetLength(v8);
      if (io_pm_schedule_power_event(v15, (uint64_t)BytePtr, Length, 1, &v21))
        v21 = -536870199;
      notify_post("com.apple.system.IOPMSchedulePowerEventNotification");
      goto LABEL_9;
    }
  }
  else
  {
    v8 = 0;
  }
  v21 = -536870206;
LABEL_9:
  if (v20)
    _pm_disconnect();
  if (cf)
    CFRelease(cf);
  if (v8)
    CFRelease(v8);
  return v21;
}

uint64_t doAMaintenanceWake(uint64_t a1, char a2)
{
  uint64_t v4;
  CFTimeZoneRef v5;
  const __CFTimeZone *v6;
  CFAbsoluteTime v7;
  CFGregorianDate GregorianDate;
  io_registry_entry_t v9;
  io_object_t v10;
  kern_return_t v11;
  _BOOL4 v12;
  io_connect_t connect;
  size_t outputStructCnt;
  int outputStruct;
  SInt32 inputStruct;
  SInt8 month;
  SInt8 day;
  SInt8 hour;
  SInt8 minute;
  int second;

  v4 = 3758097084;
  outputStruct = 0;
  outputStructCnt = 4;
  connect = 0;
  v5 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
  if (v5)
  {
    v6 = v5;
    v7 = MEMORY[0x18D771BE0](a1);
    GregorianDate = CFAbsoluteTimeGetGregorianDate(v7, v6);
    CFRelease(v6);
    inputStruct = GregorianDate.year;
    month = GregorianDate.month;
    day = GregorianDate.day;
    hour = GregorianDate.hour;
    minute = GregorianDate.minute;
    second = (int)GregorianDate.second;
    BYTE1(second) = a2;
    v9 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    if (v9)
    {
      v10 = v9;
      v11 = IOServiceOpen(v9, *MEMORY[0x1E0C83DA0], 0, &connect);
      if (!v11)
      {
        v11 = IOConnectCallStructMethod(connect, 8u, &inputStruct, 0xCuLL, &outputStruct, &outputStructCnt);
        IOServiceClose(connect);
      }
      IOObjectRelease(v10);
      v12 = outputStruct != 0;
    }
    else
    {
      v12 = 0;
      v11 = -1;
    }
    if (v11)
      v12 = 1;
    if (v12)
      return 3758097084;
    else
      return 0;
  }
  return v4;
}

void tellClockController(const void *a1, uint64_t a2)
{
  __CFData *Mutable;
  const UInt8 *BytePtr;
  UInt8 *v6;
  CFAbsoluteTime v7;
  const __CFTimeZone *v8;
  CFGregorianDate GregorianDate;
  char v10;
  const __CFString *v11;
  CFNumberRef v12;
  double Current;
  const __CFString *v14;
  unint64_t valuePtr;

  if (!a1)
    return;
  valuePtr = 0;
  Mutable = CFDataCreateMutable(0, 12);
  CFDataSetLength(Mutable, 12);
  BytePtr = CFDataGetBytePtr(Mutable);
  *(_QWORD *)BytePtr = 0;
  *((_DWORD *)BytePtr + 2) = 0;
  if (a2)
  {
    v6 = (UInt8 *)BytePtr;
    v7 = MEMORY[0x18D771BE0](a2);
    v8 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
    GregorianDate = CFAbsoluteTimeGetGregorianDate(v7, v8);
    CFRelease(v8);
    v10 = llround(GregorianDate.second);
    if (v10 == 60)
      v10 = 59;
    v6[8] = v10;
    v6[7] = GregorianDate.minute;
    v6[6] = GregorianDate.hour;
    v6[5] = GregorianDate.day;
    v6[4] = GregorianDate.month;
    *(_DWORD *)v6 = GregorianDate.year;
  }
  if (CFEqual(a1, CFSTR("wake")))
    v11 = CFSTR("WakeByCalendarDate");
  else
    v11 = CFSTR("PowerByCalendarDate");
  if (_setRootDomainProperty(v11, Mutable))
    goto LABEL_10;
  if (!a2)
  {
    valuePtr = 0;
LABEL_20:
    v12 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    if (v12)
    {
      if (CFEqual(a1, CFSTR("wake")))
        v14 = CFSTR("wake");
      else
        v14 = CFSTR("poweron");
      _setRootDomainProperty(v14, v12);
    }
    goto LABEL_11;
  }
  Current = CFAbsoluteTimeGetCurrent();
  valuePtr = llround(MEMORY[0x18D771BE0](a2) - Current);
  if ((valuePtr & 0x8000000000000000) == 0)
    goto LABEL_20;
LABEL_10:
  v12 = 0;
LABEL_11:
  if (Mutable)
    CFRelease(Mutable);
  if (v12)
    CFRelease(v12);
}

uint64_t _setRootDomainProperty(const __CFString *a1, const void *a2)
{
  io_registry_entry_t v4;
  io_object_t v5;
  uint64_t v6;

  v4 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v4)
    return 3758097084;
  v5 = v4;
  v6 = IORegistryEntrySetCFProperty(v4, a1, a2);
  IOObjectRelease(v5);
  return v6;
}

uint64_t IOPMCancelAllScheduledPowerEvents()
{
  mach_port_t v1;
  unsigned int v2;

  v1 = 0;
  v2 = -536870199;
  if (_pm_connect(&v1))
    v2 = -536870199;
  else
    io_pm_schedule_power_event(v1, 0, 0, 2, (int *)&v2);
  if (v1)
    _pm_disconnect();
  return v2;
}

CFTypeRef IOHIDSessionFilterCreate(const __CFAllocator *a1, CFBundleRef bundle, const __CFUUID *a3)
{
  const __CFString *Identifier;
  const char *CStringPtr;
  NSObject *v7;
  uint64_t Private;
  const __CFAllocator *v9;
  const __CFUUID *v10;
  void *v11;
  void *v12;
  unsigned int (*v13)(void *, _QWORD, _QWORD, uint64_t);
  const __CFUUID *v14;
  CFUUIDBytes v15;
  _QWORD *v16;
  unsigned int (*v17)(void *, _QWORD, _QWORD, uint64_t);
  const __CFUUID *v18;
  CFUUIDBytes v19;
  _QWORD *v20;
  CFTypeRef v21;
  NSObject *v22;
  uint8_t buf[4];
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  Identifier = CFBundleGetIdentifier(bundle);
  CStringPtr = CFStringGetCStringPtr(Identifier, 0x8000100u);
  v7 = _IOHIDLog();
  if (os_signpost_enabled(v7))
  {
    *(_DWORD *)buf = 136315138;
    v25 = CStringPtr;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v7, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilter", "%s", buf, 0xCu);
  }
  Private = __IOHIDSessionFilterCreatePrivate(a1);
  if (!Private)
  {
    v12 = 0;
    goto LABEL_23;
  }
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
  v10 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x7Fu, 0x1Au, 0x3Au, 0xE6u, 0x3Eu, 0x3Du, 0x47u, 0xAu, 0xBDu, 0x15u, 0xA2u, 0xDDu, 0x7Eu, 0x1Bu, 0xB7u, 0x19u);
  v11 = CFPlugInInstanceCreate(a1, a3, v10);
  v12 = v11;
  if (!v11)
  {
LABEL_23:
    v21 = 0;
    goto LABEL_15;
  }
  v13 = *(unsigned int (**)(void *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v11 + 8);
  v14 = CFUUIDGetConstantUUIDWithBytes(v9, 0x19u, 0xD7u, 0x74u, 0x41u, 0xBBu, 0xC4u, 0x45u, 0x11u, 0x91u, 0x49u, 0x60u, 0x57u, 0x2Au, 0xBu, 1u, 0x5Cu);
  v15 = CFUUIDGetUUIDBytes(v14);
  v16 = (_QWORD *)(Private + 24);
  if (v13(v12, *(_QWORD *)&v15.byte0, *(_QWORD *)&v15.byte8, Private + 24))
    *v16 = 0;
  v17 = *(unsigned int (**)(void *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v12 + 8);
  v18 = CFUUIDGetConstantUUIDWithBytes(v9, 0x3Du, 0xC3u, 0x5Au, 0xA6u, 0xD3u, 0x5Cu, 0x44u, 0x5Bu, 0x9Au, 0x59u, 0xCAu, 3u, 0xDAu, 0x40u, 0x8Bu, 0x97u);
  v19 = CFUUIDGetUUIDBytes(v18);
  v20 = (_QWORD *)(Private + 16);
  if (v17(v12, *(_QWORD *)&v19.byte0, *(_QWORD *)&v19.byte8, Private + 16))
  {
    *v20 = 0;
  }
  else if (*v20)
  {
    goto LABEL_12;
  }
  if (!*v16)
    goto LABEL_23;
LABEL_12:
  *(_QWORD *)(Private + 40) = Identifier;
  if (Identifier)
    CFRetain(Identifier);
  *(_BYTE *)(Private + 48) = 1;
  v21 = CFRetain((CFTypeRef)Private);
LABEL_15:
  v22 = _IOHIDLog();
  if (os_signpost_enabled(v22))
  {
    *(_DWORD *)buf = 136315138;
    v25 = CStringPtr;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v22, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilter", "%s", buf, 0xCu);
  }
  if (v12)
    (*(void (**)(void *))(*(_QWORD *)v12 + 24))(v12);
  if (Private)
    CFRelease((CFTypeRef)Private);
  return v21;
}

uint64_t __IOHIDSessionFilterCreatePrivate(const __CFAllocator *a1)
{
  uint64_t Instance;
  uint64_t v3;

  if (!__kIOHIDSessionFilterTypeID)
    pthread_once(&__systemFilterClientTypeInit, (void (*)(void))__IOHIDSessionFilterRegister);
  Instance = _CFRuntimeCreateInstance();
  v3 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 128) = 0;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_QWORD *)(Instance + 32) = CFUUIDCreate(a1);
  }
  return v3;
}

uint64_t IOHIDSessionFilterCreateWithClass(const __CFAllocator *a1, objc_class *a2, uint64_t a3, char a4)
{
  NSObject *v8;
  id v9;
  Protocol *Protocol;
  uint64_t Private;
  uint64_t v12;
  const __CFAllocator *v13;
  const char *ClassName;
  const char *Uid;
  const char *v16;
  const char *v17;
  const char *v18;
  char v19;
  NSObject *v20;
  const char *v21;
  char v22;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  const char *Name;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v8 = _IOHIDLog();
  if (os_signpost_enabled(v8))
  {
    v48 = 136315138;
    Name = class_getName(a2);
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilterClass", "%s", (uint8_t *)&v48, 0xCu);
  }
  v9 = objc_msgSend(a2, sel_getUid("alloc"));
  if (!v9)
    goto LABEL_31;
  if (!objc_msgSend(v9, sel_getUid("initWithSession:"), a3))
  {
    v24 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      IOHIDSessionFilterCreateWithClass_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    v12 = 0;
    v9 = 0;
    goto LABEL_32;
  }
  Protocol = objc_getProtocol("HIDSessionFilter");
  if (!Protocol)
  {
    v32 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      IOHIDSessionFilterCreateWithClass_cold_2(v32, v33, v34, v35, v36, v37, v38, v39);
    goto LABEL_31;
  }
  if (!class_conformsToProtocol(a2, Protocol))
  {
    v40 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      IOHIDSessionFilterCreateWithClass_cold_3(v40, v41, v42, v43, v44, v45, v46, v47);
LABEL_31:
    v12 = 0;
    goto LABEL_32;
  }
  Private = __IOHIDSessionFilterCreatePrivate(a1);
  v12 = Private;
  if (!Private)
  {
LABEL_32:
    v19 = 1;
    goto LABEL_17;
  }
  *(_QWORD *)(Private + 56) = v9;
  *(_QWORD *)(Private + 64) = sel_getUid("propertyForKey:");
  *(_QWORD *)(v12 + 72) = sel_getUid("setProperty:forKey:");
  *(_QWORD *)(v12 + 80) = sel_getUid("filterEvent:forService:");
  *(_QWORD *)(v12 + 88) = sel_getUid("activate");
  v13 = CFGetAllocator((CFTypeRef)v12);
  ClassName = object_getClassName(*(id *)(v12 + 56));
  *(_QWORD *)(v12 + 40) = CFStringCreateWithCString(v13, ClassName, 0);
  Uid = sel_getUid("cancel");
  if (class_respondsToSelector(a2, Uid))
    *(_QWORD *)(v12 + 96) = sel_getUid("cancel");
  v16 = sel_getUid("serviceNotification:added:");
  if (class_respondsToSelector(a2, v16))
    *(_QWORD *)(v12 + 104) = sel_getUid("serviceNotification:added:");
  v17 = sel_getUid("setDispatchQueue:");
  if (class_respondsToSelector(a2, v17))
    *(_QWORD *)(v12 + 112) = sel_getUid("setDispatchQueue:");
  v18 = sel_getUid("filterEvent:toConnection:fromService:");
  if (class_respondsToSelector(a2, v18))
    *(_QWORD *)(v12 + 120) = sel_getUid("filterEvent:toConnection:fromService:");
  v19 = 0;
  *(_BYTE *)(v12 + 48) = a4;
LABEL_17:
  v20 = _IOHIDLog();
  if (os_signpost_enabled(v20))
  {
    v21 = class_getName(a2);
    v48 = 136315138;
    Name = v21;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v20, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilterClass", "%s", (uint8_t *)&v48, 0xCu);
  }
  v22 = v19 ^ 1;
  if (!v9)
    v22 = 1;
  if ((v22 & 1) == 0)
    CFRelease(v9);
  return v12;
}

uint64_t IOHIDSessionFilterGetTypeID()
{
  uint64_t result;

  result = __kIOHIDSessionFilterTypeID;
  if (!__kIOHIDSessionFilterTypeID)
  {
    pthread_once(&__systemFilterClientTypeInit, (void (*)(void))__IOHIDSessionFilterRegister);
    return __kIOHIDSessionFilterTypeID;
  }
  return result;
}

uint64_t __IOHIDSessionFilterRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDSessionFilterTypeID = result;
  return result;
}

BOOL IOHIDSessionFilterGetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) == 0;
}

uint64_t IOHIDSessionFilterFilterCopyEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t (*v7)(void);
  uint64_t v8;
  uint64_t result;
  NSObject *v10;
  int Type;
  uint64_t SenderID;
  uint64_t v13;
  _DWORD v14[2];
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 16);
  if ((!v6 || (v7 = *(uint64_t (**)(void))(*(_QWORD *)v6 + 40)) == 0)
    && ((v8 = *(_QWORD *)(a1 + 24)) == 0 || (v7 = *(uint64_t (**)(void))(*(_QWORD *)v8 + 40)) == 0)
    || (result = v7()) == 0)
  {
    if (*(_BYTE *)(a1 + 48))
    {
      v10 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        Type = IOHIDEventGetType(a3);
        if (a2)
          SenderID = _IOHIDServiceGetSenderID(a2);
        else
          SenderID = 0;
        v13 = *(_QWORD *)(a1 + 32);
        v14[0] = 67109634;
        v14[1] = Type;
        v15 = 2048;
        v16 = SenderID;
        v17 = 2112;
        v18 = v13;
        _os_log_impl(&dword_18AAAF000, v10, OS_LOG_TYPE_INFO, "Event filtered type:%d service:0x%llx session filter:%@", (uint8_t *)v14, 0x1Cu);
      }
    }
    return 0;
  }
  return result;
}

uint64_t IOHIDSessionFilterCopyEvent(uint64_t a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*(_QWORD *)v2 + 48);
    if (v3)
      return v3();
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (v4 && (v3 = *(uint64_t (**)(void))(*(_QWORD *)v4 + 48)) != 0)
    return v3();
  else
    return 0;
}

uint64_t IOHIDSessionFilterOpen(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(a1 + 16);
  if (v1 && (v2 = *(uint64_t (**)(void))(*(_QWORD *)v1 + 56)) != 0)
    return v2();
  else
    return 1;
}

id IOHIDSessionFilterClose(id result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD);
  const char *v3;

  v1 = *((_QWORD *)result + 2);
  if (v1)
  {
    v2 = *(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 64);
    if (v2)
      return (id)v2(*((_QWORD *)result + 2));
  }
  if (*((_QWORD *)result + 7))
  {
    v3 = (const char *)*((_QWORD *)result + 12);
    if (v3)
      return objc_msgSend(*((id *)result + 7), v3);
  }
  return result;
}

id IOHIDSessionFilterScheduleWithDispatchQueue(uint64_t a1, dispatch_object_t object)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t (*v6)(void);
  id result;
  const char *v8;

  v4 = *(NSObject **)(a1 + 128);
  if (v4)
  {
    dispatch_release(v4);
    *(_QWORD *)(a1 + 128) = 0;
  }
  if (object)
  {
    *(_QWORD *)(a1 + 128) = object;
    dispatch_retain(object);
  }
  v5 = *(_QWORD *)(a1 + 16);
  if (v5)
  {
    v6 = *(uint64_t (**)(void))(*(_QWORD *)v5 + 104);
    if (v6)
      return (id)v6();
  }
  result = *(id *)(a1 + 56);
  if (result)
  {
    v8 = *(const char **)(a1 + 112);
    if (v8)
    {
      objc_msgSend(result, v8, object);
      result = *(id *)(a1 + 56);
    }
    return objc_msgSend(result, *(SEL *)(a1 + 88));
  }
  return result;
}

void IOHIDSessionFilterUnscheduleFromDispatchQueue(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3;
  void (*v4)(void);

  if (*(dispatch_object_t *)(a1 + 128) == object)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      v4 = *(void (**)(void))(*(_QWORD *)v3 + 112);
      if (v4)
      {
        v4();
        object = *(dispatch_object_t *)(a1 + 128);
      }
    }
    if (object)
    {
      dispatch_release(object);
      *(_QWORD *)(a1 + 128) = 0;
    }
  }
}

void __IOHIDSessionFilterRelease(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  const void *v7;

  v2 = a1[3];
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = a1[2];
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = (const void *)a1[5];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[7];
  if (v5)
    CFRelease(v5);
  v6 = a1[16];
  if (v6)
    dispatch_release(v6);
  v7 = (const void *)a1[4];
  if (v7)
    CFRelease(v7);
}

CFStringRef __IOHIDSessionFilterCopyDebugDescription(_QWORD *a1)
{
  const void *v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  CFStringRef v6;

  v2 = (const void *)a1[7];
  if (v2)
    v3 = CFCopyDescription(v2);
  else
    v3 = 0;
  v4 = CFGetAllocator(a1);
  v5 = &stru_1E2005170;
  if (v3)
    v5 = v3;
  v6 = CFStringCreateWithFormat(v4, 0, CFSTR("IOHIDSessionFilterRef uuid:%@ name:%@ %@"), a1[4], a1[5], v5);
  if (v3)
    CFRelease(v3);
  return v6;
}

uint64_t IOPMScheduleRepeatingPowerEvent(const void *a1)
{
  uint64_t v2;
  CFTypeID TypeID;
  const __CFData *v4;
  const __CFData *Data;
  mach_port_t v7;
  const UInt8 *BytePtr;
  int Length;
  mach_port_t v10;
  unsigned int v11;

  v2 = 3758097090;
  v10 = 0;
  v11 = -536870212;
  TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return v2;
  if (_pm_connect(&v10))
  {
    v4 = 0;
  }
  else
  {
    Data = CFPropertyListCreateData(0, a1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    v4 = Data;
    if (!Data)
    {
      v11 = -536870206;
      goto LABEL_6;
    }
    v7 = v10;
    BytePtr = CFDataGetBytePtr(Data);
    Length = CFDataGetLength(v4);
    if (!io_pm_schedule_repeat_event(v7, (uint64_t)BytePtr, Length, 1, (int *)&v11))
      goto LABEL_6;
  }
  v11 = -536870199;
LABEL_6:
  if (v10)
    _pm_disconnect();
  if (v4)
    CFRelease(v4);
  return v11;
}

CFPropertyListRef IOPMCopyRepeatingPowerEvents()
{
  CFPropertyListRef v1;

  v1 = 0;
  _copyPMServerObject(5u, 0, 0, &v1);
  return v1;
}

uint64_t IOPMCancelAllRepeatingPowerEvents()
{
  int v1;
  unsigned int v2;

  v1 = 0;
  v2 = -536870212;
  if (_pm_connect(&v1))
  {
    return -536870199;
  }
  else
  {
    if (io_pm_cancel_repeat_events(v1, &v2))
      v2 = -536870199;
    if (v1)
      _pm_disconnect();
  }
  return v2;
}

uint64_t IOPMSetUPSShutdownLevels(__CFString *a1, const void *a2)
{
  uint64_t v2;
  int valid;
  BOOL v7;

  v2 = 3758097090;
  v7 = 0;
  if (a2)
  {
    valid = _validUPSShutdownSettings(a2);
    if (a1)
    {
      if (valid && _validUPSIdentifier(a1))
      {
        IOPSGetSupportedPowerSources(0, 0, &v7);
        if (v7)
          return IOPMWriteToPrefs(a1, a2, 1, 1);
        else
          return 3758097088;
      }
    }
  }
  return v2;
}

uint64_t _validUPSShutdownSettings(const void *a1)
{
  CFTypeID TypeID;
  const void *Value;
  const void *v4;
  CFTypeID v5;
  const void *v6;
  const void *v7;
  CFTypeID v8;
  CFTypeID v9;
  const void *v10;
  const void *v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  CFTypeID v15;
  CFTypeID v16;
  const void *v17;
  const void *v18;
  CFTypeID v19;
  const void *v20;
  const void *v21;
  CFTypeID v22;
  CFTypeID v23;

  TypeID = CFDictionaryGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) != TypeID)
    return 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("UPSShutdownAtLevel"));
  if (Value)
  {
    v4 = Value;
    v5 = CFDictionaryGetTypeID();
    if (CFGetTypeID(v4) != v5)
      return 0;
    v6 = CFDictionaryGetValue((CFDictionaryRef)v4, CFSTR("Value"));
    v7 = CFDictionaryGetValue((CFDictionaryRef)v4, CFSTR("Enabled"));
    v8 = CFNumberGetTypeID();
    if (!v6)
      return 0;
    if (CFGetTypeID(v6) != v8)
      return 0;
    v9 = CFBooleanGetTypeID();
    if (!v7 || CFGetTypeID(v7) != v9)
      return 0;
  }
  v10 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("UPSShutdownAfterMinutes"));
  if (v10)
  {
    v11 = v10;
    v12 = CFDictionaryGetTypeID();
    if (CFGetTypeID(v11) != v12)
      return 0;
    v13 = CFDictionaryGetValue((CFDictionaryRef)v11, CFSTR("Value"));
    v14 = CFDictionaryGetValue((CFDictionaryRef)v11, CFSTR("Enabled"));
    v15 = CFNumberGetTypeID();
    if (!v13)
      return 0;
    if (CFGetTypeID(v13) != v15)
      return 0;
    v16 = CFBooleanGetTypeID();
    if (!v14 || CFGetTypeID(v14) != v16)
      return 0;
  }
  v17 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("UPSShutdownAtMinutesLeft"));
  if (!v17)
    return 1;
  v18 = v17;
  v19 = CFDictionaryGetTypeID();
  if (CFGetTypeID(v18) == v19
    && (v20 = CFDictionaryGetValue((CFDictionaryRef)v18, CFSTR("Value")),
        v21 = CFDictionaryGetValue((CFDictionaryRef)v18, CFSTR("Enabled")),
        v22 = CFNumberGetTypeID(),
        v20)
    && CFGetTypeID(v20) == v22
    && (v23 = CFBooleanGetTypeID(), v21)
    && CFGetTypeID(v21) == v23)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

BOOL _validUPSIdentifier(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFStringGetTypeID();
  return a1 && CFGetTypeID(a1) == TypeID && CFEqual(a1, CFSTR("UPSDefaultThresholds")) != 0;
}

__CFDictionary *IOPMCopyUPSShutdownLevels(__CFString *a1)
{
  CFPropertyListRef v2;
  const __CFAllocator **v3;
  CFMutableDictionaryRef Mutable;
  uint64_t v5;
  const __CFAllocator *v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;
  const void *v9;
  __CFDictionary *v10;
  CFNumberRef v11;
  __CFDictionary *v12;
  uint64_t i;
  __CFDictionary *theDict;
  CFTypeRef cf;
  BOOL v17;
  int valuePtr;
  void *value;
  void *v20;
  void *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  if (!a1)
    return 0;
  if (!_validUPSIdentifier(a1))
    return 0;
  IOPSGetSupportedPowerSources(0, 0, &v17);
  if (!v17)
    return 0;
  v2 = IOPMCopyFromPrefs(0, a1);
  v3 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  if (!v2)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
      goto LABEL_6;
LABEL_18:
    v12 = 0;
    if (!v2)
      return v12;
LABEL_19:
    CFRelease(v2);
    return v12;
  }
  Mutable = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v2);
  if (!Mutable)
    goto LABEL_18;
LABEL_6:
  theDict = Mutable;
  cf = v2;
  v5 = 0;
  value = 0;
  v20 = 0;
  v21 = 0;
  v6 = *v3;
  v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v9 = (const void *)*MEMORY[0x1E0C9AE40];
  do
  {
    valuePtr = 0;
    v10 = CFDictionaryCreateMutable(v6, 0, v7, v8);
    v11 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(v10, CFSTR("Value"), v11);
    CFRelease(v11);
    CFDictionarySetValue(v10, CFSTR("Enabled"), v9);
    *(void **)((char *)&value + v5) = v10;
    v5 += 8;
  }
  while (v5 != 24);
  v12 = theDict;
  CFDictionaryAddValue(theDict, CFSTR("UPSShutdownAtLevel"), value);
  CFDictionaryAddValue(theDict, CFSTR("UPSShutdownAfterMinutes"), v20);
  CFDictionaryAddValue(theDict, CFSTR("UPSShutdownAtMinutesLeft"), v21);
  for (i = 0; i != 24; i += 8)
    CFRelease(*(void **)((char *)&value + i));
  if (!CFDictionaryGetCount(theDict) || (_validUPSShutdownSettings(theDict) & 1) == 0)
  {
    CFRelease(theDict);
    v12 = 0;
  }
  v2 = cf;
  if (cf)
    goto LABEL_19;
  return v12;
}

IOReturn IONetworkOpen(io_object_t obj, io_connect_t *con)
{
  return IOServiceOpen(obj, *MEMORY[0x1E0C83DA0], 0xFF000001, con);
}

IOReturn IONetworkWriteData(io_connect_t conObj, IONDHandle dataHandle, UInt8 *srcBuf, UInt32 inSize)
{
  IOReturn v4;
  uint64_t input;

  v4 = -536870206;
  if (srcBuf && inSize)
  {
    input = dataHandle;
    return IOConnectCallMethod(conObj, 1u, &input, 1u, srcBuf, inSize, 0, 0, 0, 0);
  }
  return v4;
}

IOReturn IONetworkReadData(io_connect_t conObj, IONDHandle dataHandle, UInt8 *destBuf, UInt32 *inOutSizeP)
{
  kern_return_t v4;
  size_t v7;
  uint64_t input;

  v4 = -536870206;
  if (destBuf && inOutSizeP)
  {
    v7 = *inOutSizeP;
    input = dataHandle;
    v4 = IOConnectCallMethod(conObj, 2u, &input, 1u, 0, 0, 0, 0, destBuf, &v7);
    *inOutSizeP = v7;
  }
  return v4;
}

IOReturn IONetworkResetData(io_connect_t conObject, IONDHandle dataHandle)
{
  uint64_t input;

  input = dataHandle;
  return IOConnectCallScalarMethod(conObject, 0, &input, 1u, 0, 0);
}

IOReturn IONetworkGetDataCapacity(io_connect_t conObject, IONDHandle dataHandle, UInt32 *capacityP)
{
  IOReturn result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  if (!capacityP)
    return -536870206;
  output = *capacityP;
  input = dataHandle;
  outputCnt = 1;
  result = IOConnectCallScalarMethod(conObject, 3u, &input, 1u, &output, &outputCnt);
  *capacityP = output;
  return result;
}

IOReturn IONetworkGetDataHandle(io_connect_t conObject, const char *dataName, IONDHandle *dataHandleP)
{
  IOReturn result;
  size_t v7;
  size_t outputStructCnt;

  result = -536870206;
  if (dataName)
  {
    if (dataHandleP)
    {
      outputStructCnt = 4;
      v7 = strlen(dataName);
      return IOConnectCallStructMethod(conObject, 4u, dataName, v7 + 1, dataHandleP, &outputStructCnt);
    }
  }
  return result;
}

IOReturn IONetworkGetPacketFiltersMask(io_connect_t connect, const io_name_t filterGroup, UInt32 *filtersMask, IOOptionBits options)
{
  char v4;
  kern_return_t ParentEntry;
  io_registry_entry_t v8;
  const __CFAllocator *v9;
  IOReturn v10;
  const __CFArray *v11;
  CFStringRef v12;
  CFStringEncoding SystemEncoding;
  CFStringRef v15;
  __CFString *v16;
  CFTypeRef v17;
  CFTypeID TypeID;
  CFTypeRef cf;
  io_service_t service;
  io_registry_entry_t parent[2];
  void *values;
  CFStringRef v23;
  uint64_t v24;
  CFRange v25;

  v4 = options;
  v24 = *MEMORY[0x1E0C80C00];
  service = 0;
  cf = 0;
  values = 0;
  v23 = 0;
  *filtersMask = 0;
  ParentEntry = IOConnectGetService(connect, &service);
  if (ParentEntry)
    goto LABEL_6;
  v8 = service;
  if ((v4 & 1) != 0)
  {
    parent[0] = 0;
    ParentEntry = IORegistryEntryGetParentEntry(service, "IOService", parent);
    if (ParentEntry)
    {
LABEL_6:
      v10 = ParentEntry;
      v11 = 0;
      v12 = 0;
      goto LABEL_7;
    }
    IOObjectRelease(service);
    v8 = parent[0];
    service = parent[0];
  }
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ParentEntry = IORegistryEntryCreateCFProperties(v8, (CFMutableDictionaryRef *)&cf, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (ParentEntry)
    goto LABEL_6;
  v10 = -536870211;
  SystemEncoding = CFStringGetSystemEncoding();
  v15 = CFStringCreateWithCString(v9, filterGroup, SystemEncoding);
  v12 = v15;
  if (v15)
  {
    v16 = CFSTR("IOPacketFilters");
    if ((v4 & 1) == 0)
      v16 = CFSTR("IORequiredPacketFilters");
    values = v16;
    v23 = v15;
    v11 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
    if (v11)
    {
      v17 = cf;
      TypeID = CFNumberGetTypeID();
      *(_QWORD *)parent = v17;
      v25.length = CFArrayGetCount(v11);
      v25.location = 0;
      CFArrayApplyFunction(v11, v25, (CFArrayApplierFunction)GetDictionaryValueUsingKeysApplier, parent);
      if (*(_QWORD *)parent && CFGetTypeID(*(CFTypeRef *)parent) == TypeID && *(_QWORD *)parent)
      {
        CFNumberGetValue(*(CFNumberRef *)parent, kCFNumberSInt32Type, filtersMask);
        v10 = 0;
      }
      else
      {
        v10 = -536870160;
      }
    }
  }
  else
  {
    v11 = 0;
  }
LABEL_7:
  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
  if (v11)
    CFRelease(v11);
  if (service)
    IOObjectRelease(service);
  return v10;
}

IOReturn IONetworkSetPacketFiltersMask(io_connect_t connect, const io_name_t filterGroup, UInt32 filtersMask, IOOptionBits options)
{
  kern_return_t v6;
  const __CFAllocator *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFStringEncoding SystemEncoding;
  CFStringRef v11;
  CFStringRef v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFIndex Count;
  CFDictionaryRef v16;
  const CFDictionaryKeyCallBacks *v17;
  const CFDictionaryValueCallBacks *v18;
  void *ValueAtIndex;
  CFDictionaryRef v21;
  CFDictionaryRef v22;
  UInt32 valuePtr;
  void *values[3];
  void *v26;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v6 = -536870211;
  valuePtr = filtersMask;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  if (v8)
  {
    v9 = v8;
    SystemEncoding = CFStringGetSystemEncoding();
    v11 = CFStringCreateWithCString(v7, filterGroup, SystemEncoding);
    if (!v11)
    {
      v16 = v9;
LABEL_20:
      CFRelease(v16);
      return v6;
    }
    v12 = v11;
    values[0] = CFSTR("IONetworkInterfaceProperties");
    values[1] = CFSTR("IORequiredPacketFilters");
    values[2] = (void *)v11;
    v13 = CFArrayCreate(0, (const void **)values, 3, MEMORY[0x1E0C9B378]);
    v14 = v13;
    if (v13)
    {
      v26 = 0;
      keys[0] = 0;
      Count = CFArrayGetCount(v13);
      v16 = 0;
      v17 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9AEB8];
      v18 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      while (Count-- >= 1)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v14, Count);
        if (v16)
          v21 = v16;
        else
          v21 = v9;
        v26 = v21;
        keys[0] = ValueAtIndex;
        v22 = CFDictionaryCreate(0, (const void **)keys, (const void **)&v26, 1, v17, v18);
        if (v16)
          CFRelease(v16);
        v16 = v22;
        if (!v22)
          goto LABEL_17;
      }
      if (v16)
        v6 = IOConnectSetCFProperties(connect, v16);
    }
    else
    {
      v16 = 0;
    }
LABEL_17:
    CFRelease(v9);
    CFRelease(v12);
    if (v14)
      CFRelease(v14);
    if (v16)
      goto LABEL_20;
  }
  return v6;
}

CFDictionaryRef GetDictionaryValueUsingKeysApplier(const void *a1, CFDictionaryRef *a2)
{
  CFDictionaryRef result;
  CFTypeID v5;

  result = *a2;
  if (*a2)
  {
    v5 = CFGetTypeID(result);
    if (v5 == CFDictionaryGetTypeID())
      result = (CFDictionaryRef)CFDictionaryGetValue(*a2, a1);
    else
      result = 0;
  }
  *a2 = result;
  return result;
}

NXEventHandle NXOpenEventStatus(void)
{
  kern_return_t v0;
  NXEventHandle result;
  io_object_t v2;
  mach_port_t mainPort[2];

  *(_QWORD *)mainPort = 0;
  v0 = IOMasterPort(0, mainPort);
  result = 0;
  if (!v0)
  {
    result = IORegistryEntryFromPath(mainPort[0], "IOService:/IOResources/IOHIDSystem");
    if (result)
    {
      v2 = result;
      IOServiceOpen(result, *MEMORY[0x1E0C83DA0], 1u, &mainPort[1]);
      IOObjectRelease(v2);
      return mainPort[1];
    }
  }
  return result;
}

NXEventSystemInfoType NXEventSystemInfo(NXEventHandle handle, char *flavor, int *evs_info, unsigned int *evs_info_cnt)
{
  unsigned int v6;
  const __CFArray *CFProperty;
  unsigned int v8;
  signed int Count;
  uint64_t v10;
  CFIndex v11;
  int *v12;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  const __CFNumber *Value;
  const __CFNumber *v16;
  io_service_t v17;
  const __CFNumber *v18;
  io_service_t v19;
  unsigned int v20;
  io_service_t service[2];

  v6 = *evs_info_cnt;
  *(_QWORD *)service = 0;
  if (IOConnectGetService(handle, &service[1]))
    return 0;
  CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(service[1], CFSTR("NXSystemInfo"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  IOObjectRelease(service[1]);
  if (CFProperty)
  {
    v8 = v6 >> 2;
    Count = CFArrayGetCount(CFProperty);
    if ((int)v8 >= Count)
      v10 = Count;
    else
      v10 = v8;
    if ((int)v10 >= 1)
    {
      v11 = 0;
      v12 = evs_info + 2;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(CFProperty, v11);
        if (ValueAtIndex)
        {
          v14 = ValueAtIndex;
          Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("HIDKind"));
          if (Value)
          {
            CFNumberGetValue(Value, kCFNumberSInt32Type, service);
            *v12 = service[0];
            v16 = (const __CFNumber *)CFDictionaryGetValue(v14, CFSTR("HIDInterfaceID"));
            if (v16)
            {
              CFNumberGetValue(v16, kCFNumberSInt32Type, service);
              v17 = service[0];
            }
            else
            {
              v17 = 0;
              service[0] = 0;
            }
            *(v12 - 2) = v17;
            v18 = (const __CFNumber *)CFDictionaryGetValue(v14, CFSTR("HIDSubinterfaceID"));
            if (v18)
            {
              CFNumberGetValue(v18, kCFNumberSInt32Type, service);
              v19 = service[0];
            }
            else
            {
              v19 = 0;
              service[0] = 0;
            }
            v12[1] = v19;
            *(v12 - 1) = 0;
          }
        }
        ++v11;
        v12 += 4;
      }
      while (v10 != v11);
    }
    CFRelease(CFProperty);
    v20 = 4 * v10;
  }
  else
  {
    v20 = 0;
  }
  *evs_info_cnt = v20;
  return evs_info;
}

uint64_t IOHIDCopyHIDParameterFromEventSystem(io_connect_t a1, const __CFString *a2, _QWORD *a3)
{
  uint64_t v6;
  __IOHIDEventSystemClient *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef v18;
  __IOHIDServiceClient *v19;
  __IOHIDServiceClient *v20;
  uint64_t v21;
  io_service_t service;

  v6 = IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 2, 0);
  if (v6)
  {
    v7 = (__IOHIDEventSystemClient *)v6;
    service = 0;
    if (!IOConnectGetService(a1, &service))
    {
      if (IOObjectConformsTo(service, "IOHIDSystem"))
      {
        v18 = IOHIDEventSystemClientCopyProperty(v7, a2);
      }
      else
      {
        v21 = 0;
        v18 = 0;
        if (!IORegistryEntryGetRegistryEntryID(service, &v21))
        {
          v19 = (__IOHIDServiceClient *)IOHIDEventSystemClientCopyServiceForRegistryID((uint64_t)v7, v21);
          if (v19)
          {
            v20 = v19;
            v18 = IOHIDServiceClientCopyProperty(v19, a2);
            CFRelease(v20);
          }
          else
          {
            v18 = 0;
          }
        }
      }
      IOObjectRelease(service);
      if (v18)
      {
        *a3 = v18;
        CFRelease(v7);
        return 0;
      }
    }
    CFRelease(v7);
  }
  v8 = 3758097112;
  v9 = _IOHIDLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    IOHIDCopyHIDParameterFromEventSystem_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
  return v8;
}

uint64_t IOHIDSetHIDParameterToEventSystem(io_connect_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  __IOHIDServiceClient *v9;
  __IOHIDServiceClient *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  io_service_t service;

  v6 = 3758097095;
  v7 = IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 2, 0);
  if (!v7)
  {
    v6 = 3758097112;
LABEL_14:
    v11 = _IOHIDLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      IOHIDSetHIDParameterToEventSystem_cold_1(v6, v11, v12, v13, v14, v15, v16, v17);
    return v6;
  }
  v8 = (void *)v7;
  service = 0;
  if (IOConnectGetService(a1, &service))
  {
    CFRelease(v8);
    goto LABEL_14;
  }
  if (IOObjectConformsTo(service, "IOHIDSystem"))
  {
    IOHIDEventSystemClientSetProperty((IOHIDEventSystemClientRef)v8, a2, a3);
    v6 = 0;
  }
  else
  {
    v19 = 0;
    if (!IORegistryEntryGetRegistryEntryID(service, &v19))
    {
      v9 = (__IOHIDServiceClient *)IOHIDEventSystemClientCopyServiceForRegistryID((uint64_t)v8, v19);
      if (v9)
      {
        v10 = v9;
        if (IOHIDServiceClientSetProperty(v9, a2, a3))
          v6 = 0;
        else
          v6 = 3758097097;
        CFRelease(v10);
      }
    }
  }
  IOObjectRelease(service);
  CFRelease(v8);
  if ((_DWORD)v6)
    goto LABEL_14;
  return v6;
}

kern_return_t IOHIDSetParameter(io_connect_t handle, CFStringRef key, const void *bytes, IOByteCount size)
{
  kern_return_t v4;
  CFNumberType v7;
  CFNumberRef v8;
  CFNumberRef v9;
  kern_return_t v10;

  v4 = -536870212;
  if (!bytes || !size)
    return v4;
  if (size > 8)
    v7 = kCFNumberSInt32Type;
  else
    v7 = qword_18AB46060[size - 1];
  v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, bytes);
  if (!v8)
    return -536870211;
  v9 = v8;
  if (!CFEqual(CFSTR("HIDWaitCursorFrameInterval"), key))
    IOHIDSetHIDParameterToEventSystem(handle, key, v9);
  v10 = IOConnectSetCFProperty(handle, key, v9);
  CFRelease(v9);
  return v10;
}

kern_return_t IOHIDSetCFTypeParameter(io_connect_t handle, CFStringRef key, CFTypeRef parameter)
{
  if (!parameter)
    return -536870206;
  IOHIDSetHIDParameterToEventSystem(handle, key, parameter);
  return IOConnectSetCFProperty(handle, key, parameter);
}

kern_return_t IOHIDGetParameter(io_connect_t handle, CFStringRef key, IOByteCount maxSize, void *bytes, IOByteCount *actualSize)
{
  kern_return_t v5;
  IOByteCount v8;
  kern_return_t result;
  CFTypeRef v10;
  CFTypeID v11;
  CFTypeID TypeID;
  const __CFData *v13;
  IOByteCount Length;
  const UInt8 *BytePtr;
  CFTypeID v16;
  const __CFNumber *v17;
  IOByteCount ByteSize;
  IOByteCount v19;
  unint64_t v20;
  CFNumberType v21;
  CFTypeRef parameter;

  parameter = 0;
  v5 = -536870206;
  if (maxSize && bytes)
  {
    v8 = maxSize;
    result = IOHIDCopyCFTypeParameter(handle, key, &parameter);
    if (result)
      return result;
    v10 = parameter;
    if (parameter)
    {
      bzero(bytes, v8);
      v11 = CFGetTypeID(v10);
      TypeID = CFDataGetTypeID();
      v13 = (const __CFData *)parameter;
      if (v11 == TypeID)
      {
        Length = CFDataGetLength((CFDataRef)parameter);
        *actualSize = Length;
        if (Length < v8)
          v8 = Length;
        BytePtr = CFDataGetBytePtr(v13);
        memmove(bytes, BytePtr, v8);
      }
      else
      {
        v16 = CFGetTypeID(parameter);
        if (v16 != CFNumberGetTypeID())
        {
LABEL_20:
          CFRelease(parameter);
          return v5;
        }
        v17 = (const __CFNumber *)parameter;
        ByteSize = CFNumberGetByteSize((CFNumberRef)parameter);
        *actualSize = ByteSize;
        if (ByteSize >= v8)
          v19 = v8;
        else
          v19 = ByteSize;
        v20 = v19 - 1;
        if (v20 > 7)
          v21 = kCFNumberSInt32Type;
        else
          v21 = qword_18AB46060[v20];
        CFNumberGetValue(v17, v21, bytes);
      }
      v5 = 0;
      goto LABEL_20;
    }
  }
  return -536870206;
}

kern_return_t IOHIDCopyCFTypeParameter(io_connect_t handle, CFStringRef key, CFTypeRef *parameter)
{
  kern_return_t v6;
  const __CFAllocator *v8;
  const __CFDictionary *CFProperty;
  const __CFDictionary *v10;
  const void *Value;
  const void *v12;
  CFTypeRef v13;
  io_service_t service;

  service = 0;
  if (!parameter)
    return -536870212;
  if (IOConnectGetService(handle, &service))
    goto LABEL_3;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(service, CFSTR("HIDParameters"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (CFProperty)
  {
    v10 = CFProperty;
    Value = CFDictionaryGetValue(CFProperty, key);
    if (Value)
    {
      v12 = Value;
      CFRetain(Value);
      CFRelease(v10);
      v6 = 0;
      *parameter = v12;
      goto LABEL_4;
    }
    CFRelease(v10);
  }
  v13 = IORegistryEntryCreateCFProperty(service, key, v8, 0);
  v6 = 0;
  *parameter = v13;
  if (!v13)
LABEL_3:
    v6 = IOHIDCopyHIDParameterFromEventSystem(handle, key, parameter);
LABEL_4:
  if (service)
    IOObjectRelease(service);
  return v6;
}

void NXResetKeyboard(NXEventHandle handle)
{
  CFNumberRef v2;
  CFNumberRef v3;
  _BYTE valuePtr[4];

  v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
  if (v2)
  {
    v3 = v2;
    IOHIDSetHIDParameterToEventSystem(handle, CFSTR("HIDResetKeyboard"), v2);
    IOConnectSetCFProperty(handle, CFSTR("HIDResetKeyboard"), v3);
    CFRelease(v3);
  }
}

void NXSetKeyRepeatInterval(NXEventHandle handle, double seconds)
{
  unint64_t bytes;

  bytes = (unint64_t)(seconds * 1000000000.0);
  IOHIDSetParameter(handle, CFSTR("HIDKeyRepeat"), &bytes, 8uLL);
}

double NXKeyRepeatInterval(NXEventHandle handle)
{
  kern_return_t v1;
  double result;
  IOByteCount v3;
  unint64_t bytes;

  bytes = 0;
  v1 = IOHIDGetParameter(handle, CFSTR("HIDKeyRepeat"), 8uLL, &bytes, &v3);
  result = 0.0;
  if (!v1)
    return (double)bytes / 1000.0 / 1000.0 / 1000.0;
  return result;
}

void NXSetKeyRepeatThreshold(NXEventHandle handle, double threshold)
{
  unint64_t bytes;

  bytes = (unint64_t)(threshold * 1000000000.0);
  IOHIDSetParameter(handle, CFSTR("HIDInitialKeyRepeat"), &bytes, 8uLL);
}

double NXKeyRepeatThreshold(NXEventHandle handle)
{
  kern_return_t v1;
  double result;
  IOByteCount v3;
  unint64_t bytes;

  bytes = 0;
  v1 = IOHIDGetParameter(handle, CFSTR("HIDInitialKeyRepeat"), 8uLL, &bytes, &v3);
  result = 0.0;
  if (!v1)
    return (double)bytes / 1000.0 / 1000.0 / 1000.0;
  return result;
}

CFDataRef NXSetKeyMapping(io_connect_t a1, const UInt8 **a2)
{
  CFIndex v2;
  CFDataRef result;
  CFDataRef v6;
  kern_return_t v7;

  v2 = *(int *)a2;
  if ((int)v2 > 4096)
    return 0;
  result = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2[1], v2);
  if (result)
  {
    v6 = result;
    IOHIDSetHIDParameterToEventSystem(a1, CFSTR("HIDKeyMapping"), result);
    v7 = IOConnectSetCFProperty(a1, CFSTR("HIDKeyMapping"), v6);
    CFRelease(v6);
    if (v7)
      return 0;
    else
      return (CFDataRef)a2;
  }
  return result;
}

uint64_t NXKeyMappingLength()
{
  return 0;
}

IOByteCount *NXGetKeyMapping(io_connect_t a1, IOByteCount *actualSize)
{
  if (IOHIDGetParameter(a1, CFSTR("HIDKeyMapping"), *(int *)actualSize, (void *)actualSize[1], actualSize))
    return 0;
  else
    return actualSize;
}

void NXResetMouse(NXEventHandle handle)
{
  CFNumberRef v2;
  CFNumberRef v3;
  _BYTE valuePtr[4];

  v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
  if (v2)
  {
    v3 = v2;
    IOHIDSetHIDParameterToEventSystem(handle, CFSTR("HIDResetPointer"), v2);
    IOConnectSetCFProperty(handle, CFSTR("HIDResetPointer"), v3);
    CFRelease(v3);
  }
}

void NXSetClickTime(NXEventHandle handle, double seconds)
{
  unint64_t bytes;

  bytes = (unint64_t)(seconds * 1000000000.0);
  IOHIDSetParameter(handle, CFSTR("HIDClickTime"), &bytes, 8uLL);
}

double NXClickTime(NXEventHandle handle)
{
  kern_return_t v1;
  double result;
  IOByteCount v3;
  unint64_t bytes;

  bytes = 0;
  v1 = IOHIDGetParameter(handle, CFSTR("HIDClickTime"), 8uLL, &bytes, &v3);
  result = 0.0;
  if (!v1)
    return (double)bytes / 1000.0 / 1000.0 / 1000.0;
  return result;
}

void NXSetClickSpace(NXEventHandle handle, NXSize *area)
{
  const __CFAllocator *v3;
  CFMutableArrayRef Mutable;
  __CFArray *v5;
  CFIndex v6;
  char v7;
  char v8;
  CFNumberRef v9;
  CFNumberRef v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v11[0] = vcvt_u32_f32((float32x2_t)*area);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v5 = Mutable;
    v6 = 0;
    v7 = 1;
    do
    {
      v8 = v7;
      v9 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)v11 + 4 * v6);
      if (v9)
      {
        v10 = v9;
        CFArraySetValueAtIndex(v5, v6, v9);
        CFRelease(v10);
      }
      v7 = 0;
      v6 = 1;
    }
    while ((v8 & 1) != 0);
    IOHIDSetHIDParameterToEventSystem(handle, CFSTR("HIDClickSpace"), v5);
    IOConnectSetCFProperty(handle, CFSTR("HIDClickSpace"), v5);
    CFRelease(v5);
  }
}

void NXGetClickSpace(NXEventHandle handle, NXSize *area)
{
  NXSize v3;
  CFTypeID v4;
  const __CFArray *v5;
  unsigned int Count;
  uint64_t v7;
  CFIndex v8;
  uint32x2_t *v9;
  const __CFNumber *ValueAtIndex;
  CFTypeRef parameter;
  uint32x2_t v12[2];

  v12[1] = *(uint32x2_t *)MEMORY[0x1E0C80C00];
  parameter = 0;
  v3 = 0;
  if (!IOHIDCopyCFTypeParameter(handle, CFSTR("HIDClickSpace"), &parameter))
  {
    if (parameter)
    {
      v4 = CFGetTypeID(parameter);
      if (v4 == CFArrayGetTypeID())
      {
        v5 = (const __CFArray *)parameter;
        Count = CFArrayGetCount((CFArrayRef)parameter);
        if (Count >= 2)
          v7 = 2;
        else
          v7 = Count;
        if ((_DWORD)v7)
        {
          v8 = 0;
          v9 = v12;
          do
          {
            ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v5, v8);
            if (ValueAtIndex)
              CFNumberGetValue(ValueAtIndex, kCFNumberIntType, v9);
            ++v8;
            v9 = (uint32x2_t *)((char *)v9 + 4);
          }
          while (v7 != v8);
        }
        CFRelease(v5);
        v3 = (NXSize)vcvt_f32_u32(v12[0]);
      }
    }
  }
  *area = v3;
}

kern_return_t IOHIDGetScrollAcceleration(io_connect_t handle, double *acceleration)
{
  kern_return_t result;
  unint64_t v4;
  IOByteCount v5;
  int bytes;

  bytes = 0;
  result = IOHIDGetParameter(handle, CFSTR("HIDScrollAcceleration"), 4uLL, &bytes, &v5);
  if (!result)
  {
    LODWORD(v4) = bytes;
    *acceleration = (double)v4 * 0.0000152587891;
  }
  return result;
}

kern_return_t IOHIDSetScrollAcceleration(io_connect_t handle, double acceleration)
{
  unsigned int bytes;

  bytes = vcvtd_n_u64_f64(acceleration, 0x10uLL);
  return IOHIDSetParameter(handle, CFSTR("HIDScrollAcceleration"), &bytes, 4uLL);
}

kern_return_t IOHIDGetMouseButtonMode(io_connect_t handle, int *mode)
{
  IOByteCount actualSize;

  return IOHIDGetParameter(handle, CFSTR("HIDPointerButtonMode"), 4uLL, mode, &actualSize);
}

kern_return_t IOHIDSetMouseButtonMode(io_connect_t handle, int mode)
{
  int bytes;

  bytes = mode;
  return IOHIDSetParameter(handle, CFSTR("HIDPointerButtonMode"), &bytes, 4uLL);
}

kern_return_t IOHIDGetMouseAcceleration(io_connect_t handle, double *acceleration)
{
  kern_return_t result;
  unint64_t v4;
  IOByteCount v5;
  int bytes;

  bytes = 0;
  result = IOHIDGetParameter(handle, CFSTR("HIDPointerAcceleration"), 4uLL, &bytes, &v5);
  if (!result)
  {
    LODWORD(v4) = bytes;
    *acceleration = (double)v4 * 0.0000152587891;
  }
  return result;
}

kern_return_t IOHIDSetMouseAcceleration(io_connect_t handle, double acceleration)
{
  unsigned int bytes;

  bytes = vcvtd_n_u64_f64(acceleration, 0x10uLL);
  return IOHIDSetParameter(handle, CFSTR("HIDPointerAcceleration"), &bytes, 4uLL);
}

kern_return_t IOHIDGetAccelerationWithKey(io_connect_t handle, CFStringRef key, double *acceleration)
{
  kern_return_t result;
  unint64_t v5;
  IOByteCount v6;
  int bytes;

  bytes = 0;
  result = IOHIDGetParameter(handle, key, 4uLL, &bytes, &v6);
  if (!result)
  {
    LODWORD(v5) = bytes;
    *acceleration = (double)v5 * 0.0000152587891;
  }
  return result;
}

kern_return_t IOHIDSetAccelerationWithKey(io_connect_t handle, CFStringRef key, double acceleration)
{
  unsigned int bytes;

  bytes = vcvtd_n_u64_f64(acceleration, 0x10uLL);
  return IOHIDSetParameter(handle, key, &bytes, 4uLL);
}

IOHIDAccessType IOHIDCheckAccess(IOHIDRequestType requestType)
{
  BOOL v2;
  const __CFString *v3;
  int v5;
  IOHIDAccessType v6;

  if (__loadTCCFramework_onceToken != -1)
    dispatch_once(&__loadTCCFramework_onceToken, &__block_literal_global_15);
  if (__loadTCCFramework_tccFramework)
    v2 = _preflightFunc == 0;
  else
    v2 = 1;
  if (v2)
    return 2;
  if (requestType == kIOHIDRequestTypePostEvent)
  {
    v3 = CFSTR("kTCCServicePostEvent");
    goto LABEL_12;
  }
  if (requestType != kIOHIDRequestTypeListenEvent)
    return 2;
  v3 = CFSTR("kTCCServiceListenEvent");
LABEL_12:
  v5 = _preflightFunc(v3, 0);
  if (v5 == 1)
    v6 = kIOHIDAccessTypeDenied;
  else
    v6 = kIOHIDAccessTypeUnknown;
  if (v5)
    return v6;
  else
    return 0;
}

BOOL IOHIDRequestAccess(IOHIDRequestType requestType)
{
  const __CFString *v2;
  dispatch_semaphore_t v3;
  char v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (__loadTCCFramework_onceToken != -1)
    dispatch_once(&__loadTCCFramework_onceToken, &__block_literal_global_15);
  if (__loadTCCFramework_tccFramework && _requestFunc)
  {
    if (requestType)
    {
      if (requestType != kIOHIDRequestTypeListenEvent)
        goto LABEL_11;
      v2 = CFSTR("kTCCServiceListenEvent");
    }
    else
    {
      v2 = CFSTR("kTCCServicePostEvent");
    }
    v3 = dispatch_semaphore_create(0);
    v8[3] = (uint64_t)v3;
    if (v3)
    {
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __IOHIDRequestAccess_block_invoke;
      v6[3] = &unk_1E2001C18;
      v6[4] = &v11;
      v6[5] = &v7;
      _requestFunc(v2, 0, v6);
      dispatch_semaphore_wait((dispatch_semaphore_t)v8[3], 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release((dispatch_object_t)v8[3]);
    }
  }
LABEL_11:
  v4 = *((_BYTE *)v12 + 24);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  return v4;
}

BOOL IOHIDAccessCheckAuditToken(int a1, _OWORD *a2)
{
  BOOL v4;
  const __CFString *v6;
  __int128 v7;
  _OWORD v8[2];

  if (__loadTCCFramework_onceToken != -1)
    dispatch_once(&__loadTCCFramework_onceToken, &__block_literal_global_15);
  if (__loadTCCFramework_tccFramework)
    v4 = _checkAuditTokenFunc == 0;
  else
    v4 = 1;
  if (v4)
    return 1;
  if (!a1)
  {
    v6 = CFSTR("kTCCServicePostEvent");
    goto LABEL_13;
  }
  if (a1 == 1)
  {
    v6 = CFSTR("kTCCServiceListenEvent");
LABEL_13:
    v7 = a2[1];
    v8[0] = *a2;
    v8[1] = v7;
    return _checkAuditTokenFunc(v6, v8, 0) != 0;
  }
  return 0;
}

kern_return_t IOHIDCreateSharedMemory(io_connect_t connect, unsigned int version)
{
  uint64_t input;

  input = version;
  return IOConnectCallMethod(connect, 0, &input, 1u, 0, 0, 0, 0, 0, 0);
}

kern_return_t IOHIDSetEventsEnable(io_connect_t connect, BOOLean_t enable)
{
  uint64_t input;

  input = enable;
  return IOConnectCallMethod(connect, 1u, &input, 1u, 0, 0, 0, 0, 0, 0);
}

kern_return_t IOHIDSetCursorEnable(io_connect_t connect, BOOLean_t enable)
{
  NSObject *v4;
  const char *v5;
  kern_return_t v6;
  NSObject *v7;
  uint64_t input;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  input = enable;
  v4 = _IOHIDLogCategory(0xAu);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = "YES";
    if (!enable)
      v5 = "NO";
    *(_DWORD *)buf = 136315138;
    v11 = v5;
    _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_INFO, "Set cursor enable:%s", buf, 0xCu);
  }
  v6 = IOConnectCallMethod(connect, 2u, &input, 1u, 0, 0, 0, 0, 0, 0);
  if (v6)
  {
    v7 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      IOHIDSetCursorEnable_cold_1();
  }
  return v6;
}

kern_return_t IOHIDPostEvent(io_connect_t connect, UInt32 eventType, IOGPoint location, const NXEventData *eventData, UInt32 eventDataVersion, IOOptionBits eventFlags, IOOptionBits options)
{
  char v11;
  __int128 v12;
  __int128 v13;
  int v15;
  mach_port_name_t name;
  _DWORD inputStruct[3];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  IOOptionBits v21;
  IOOptionBits v22;
  pid_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  inputStruct[1] = eventType;
  inputStruct[2] = location;
  v21 = options;
  v22 = eventFlags;
  v11 = options & 6;
  inputStruct[0] = options & 6;
  v23 = getpid();
  if (eventDataVersion > 1)
  {
    v13 = *(_OWORD *)&eventData->proximity.uniqueID;
    v18 = *(_OWORD *)&eventData->mouse.subx;
    v19 = v13;
    v20 = *(_OWORD *)eventData->proximity.reserved2;
    LOBYTE(eventDataVersion) = v11;
  }
  else
  {
    inputStruct[0] = eventDataVersion;
    v12 = *(_OWORD *)&eventData->proximity.uniqueID;
    v18 = *(_OWORD *)&eventData->mouse.subx;
    v19 = v12;
    v20 = 0uLL;
  }
  v15 = 1;
  name = 0;
  if (!bootstrap_look_up2())
  {
    io_pm_hid_event_report_activity(name, eventType, &v15);
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], name);
    if (!v15)
      return 0;
  }
  if (eventDataVersion & 2 | eventType)
  {
    if (IOHIDPostEvent_onceToken != -1)
      dispatch_once(&IOHIDPostEvent_onceToken, &__block_literal_global_2);
  }
  return IOConnectCallMethod(connect, 3u, 0, 0, inputStruct, 0x48uLL, 0, 0, 0, 0);
}

uint64_t IOHIDSetCursorBounds(mach_port_t a1, __int16 *a2)
{
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 3758097090;
  v4 = _IOHIDLogCategory(0xAu);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = *a2;
    v6 = a2[2];
    v7 = a2[1];
    v8 = a2[3];
    *(_DWORD *)buf = 67109888;
    v13 = v5;
    v14 = 1024;
    v15 = v6;
    v16 = 1024;
    v17 = v7;
    v18 = 1024;
    v19 = v8;
    _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_INFO, "Set cursor bounds minx:%d miny:%d maxx:%d maxy:%d", buf, 0x1Au);
  }
  v9 = IOConnectCallMethod(a1, 6u, 0, 0, a2, 8uLL, 0, 0, 0, 0);
  if ((_DWORD)v9)
  {
    v10 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      IOHIDSetCursorBounds_cold_1();
  }
  return v9;
}

uint64_t IOHIDSetOnScreenCursorBounds(mach_port_t a1, __int16 *a2, int16x4_t *a3)
{
  uint64_t v3;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  uint8_t buf[4];
  _BYTE v17[10];
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = 3758097090;
  if (a2 && a3)
  {
    v7 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = *a2;
      v9 = a2[1];
      v10 = a3->i16[0];
      v11 = a3->i16[2];
      v12 = a3->i16[1];
      v13 = a3->i16[3];
      *(_DWORD *)buf = 67110400;
      *(_DWORD *)v17 = v8;
      *(_WORD *)&v17[4] = 1024;
      *(_DWORD *)&v17[6] = v9;
      v18 = 1024;
      v19 = v10;
      v20 = 1024;
      v21 = v11;
      v22 = 1024;
      v23 = v12;
      v24 = 1024;
      v25 = v13;
      _os_log_impl(&dword_18AAAF000, v7, OS_LOG_TYPE_INFO, "Set on screen cursor bounds px:%d py:%d minx:%d miny:%d maxx:%d maxy:%d", buf, 0x26u);
    }
    *(_DWORD *)buf = *(_DWORD *)a2;
    *(int16x4_t *)v17 = vuzp1_s16(*a3, vrev32_s16(*a3));
    v3 = IOConnectCallMethod(a1, 0xCu, 0, 0, buf, 0xCuLL, 0, 0, 0, 0);
    if ((_DWORD)v3)
    {
      v14 = _IOHIDLogCategory(0xAu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        IOHIDSetOnScreenCursorBounds_cold_1();
    }
  }
  return v3;
}

kern_return_t IOHIDSetMouseLocation(io_connect_t connect, int x, int y)
{
  NXEventData v4;
  IOGPoint v5;

  memset(&v4, 0, sizeof(v4));
  v5.y = y;
  v5.x = x;
  return IOHIDPostEvent(connect, 0, v5, &v4, 2u, 0xFFFFFFFF, 2u);
}

uint64_t _IOHIDSetFixedMouseLocation(mach_port_t a1, void *inputStruct)
{
  uint64_t v2;
  NSObject *v3;

  v2 = IOConnectCallMethod(a1, 4u, 0, 0, inputStruct, 0x1CuLL, 0, 0, 0, 0);
  if ((_DWORD)v2)
  {
    v3 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      _IOHIDSetFixedMouseLocation_cold_1();
  }
  return v2;
}

uint64_t IOHIDSetFixedMouseLocation(mach_port_t a1, int a2, int a3)
{
  _QWORD v7[2];
  int v8;
  int v9;
  pid_t v10;

  v7[0] = 0;
  v7[1] = mach_absolute_time();
  v8 = a2;
  v9 = a3;
  v10 = getpid();
  return _IOHIDSetFixedMouseLocation(a1, v7);
}

uint64_t IOHIDSetFixedMouseLocationWithTimeStamp(mach_port_t a1, int a2, int a3, uint64_t a4)
{
  _QWORD v8[2];
  int v9;
  int v10;
  pid_t v11;

  v8[0] = a4;
  v8[1] = mach_absolute_time();
  v9 = a2;
  v10 = a3;
  v11 = getpid();
  return _IOHIDSetFixedMouseLocation(a1, v8);
}

kern_return_t IOHIDGetButtonEventNum(io_connect_t connect, NXMouseButton button, int *eventNum)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  input = button;
  output = 0;
  outputCnt = 1;
  result = IOConnectCallMethod(connect, 5u, &input, 1u, 0, 0, &output, &outputCnt, 0, 0);
  *eventNum = output;
  return result;
}

kern_return_t IOHIDGetStateForSelector(io_connect_t handle, int selector, UInt32 *state)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x1E0C80C00];
  output = 0;
  input[0] = selector;
  outputCnt = 1;
  result = IOConnectCallMethod(handle, 5u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
  *state = output;
  return result;
}

kern_return_t IOHIDSetStateForSelector(io_connect_t handle, int selector, UInt32 state)
{
  kern_return_t v3;
  kern_return_t v4;
  NSObject *v5;
  CFNumberRef v7;
  NSObject *v8;
  io_service_t service;
  uint32_t outputCnt;
  UInt32 valuePtr;
  uint64_t input[3];

  input[2] = *MEMORY[0x1E0C80C00];
  outputCnt = 0;
  valuePtr = state;
  input[0] = selector;
  input[1] = state;
  if (selector != 3)
    return IOConnectCallMethod(handle, 6u, input, 2u, 0, 0, 0, &outputCnt, 0, 0);
  service = 0;
  v3 = IOConnectGetService(handle, &service);
  if (!v3)
  {
    v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    v4 = IORegistryEntrySetCFProperty(service, CFSTR("IOHIDActivityUserIdle"), v7);
    if (v4 && (v8 = _IOHIDLogCategory(0), os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)))
    {
      IOHIDSetStateForSelector_cold_1();
      if (!v7)
        return v4;
    }
    else if (!v7)
    {
      return v4;
    }
    CFRelease(v7);
    return v4;
  }
  v4 = v3;
  v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    IOHIDSetStateForSelector_cold_2();
  return v4;
}

kern_return_t IOHIDGetModifierLockState(io_connect_t handle, int selector, BOOL *state)
{
  kern_return_t result;
  UInt32 statea;

  statea = 0;
  result = IOHIDGetStateForSelector(handle, selector, &statea);
  *state = statea != 0;
  return result;
}

kern_return_t IOHIDSetModifierLockState(io_connect_t handle, int selector, BOOL state)
{
  kern_return_t v3;
  _BOOL4 v4;
  __IOHIDEventSystemClient *v6;
  __IOHIDEventSystemClient *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex v10;
  const __CFString *v11;
  const void **v12;
  const void *v13;
  __IOHIDServiceClient *ValueAtIndex;
  __IOHIDServiceClient *v15;
  NSObject *v16;

  v3 = -536870212;
  if ((selector - 3) < 0xFFFFFFFE)
    return -536870206;
  v4 = state;
  v6 = (__IOHIDEventSystemClient *)IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 2, 0);
  if (v6)
  {
    v7 = v6;
    v8 = IOHIDEventSystemClientCopyServices(v6);
    v3 = -536870208;
    if (v8)
    {
      v9 = v8;
      if (CFArrayGetCount(v8))
      {
        if (CFArrayGetCount(v9) >= 1)
        {
          v10 = 0;
          if (selector == 1)
            v11 = CFSTR("HIDCapsLockState");
          else
            v11 = CFSTR("HIDNumLockState");
          v12 = (const void **)MEMORY[0x1E0C9AE40];
          if (v4)
            v12 = (const void **)MEMORY[0x1E0C9AE50];
          v13 = *v12;
          do
          {
            ValueAtIndex = (__IOHIDServiceClient *)CFArrayGetValueAtIndex(v9, v10);
            if (ValueAtIndex)
            {
              v15 = ValueAtIndex;
              if (IOHIDServiceClientConformsTo(ValueAtIndex, 1u, 6u))
                IOHIDServiceClientSetProperty(v15, v11, v13);
            }
            ++v10;
          }
          while (v10 < CFArrayGetCount(v9));
        }
        v3 = 0;
      }
      CFRelease(v9);
    }
    CFRelease(v7);
  }
  else
  {
    v16 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      IOHIDSetModifierLockState_cold_1();
  }
  return v3;
}

kern_return_t IOHIDRegisterVirtualDisplay(io_connect_t handle, UInt32 *display_token)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x1E0C80C00];
  output[0] = 0;
  outputCnt = 1;
  result = IOConnectCallMethod(handle, 7u, 0, 0, 0, 0, output, &outputCnt, 0, 0);
  *display_token = output[0];
  return result;
}

kern_return_t IOHIDUnregisterVirtualDisplay(io_connect_t handle, UInt32 display_token)
{
  uint32_t outputCnt;
  uint64_t input[2];

  input[1] = *MEMORY[0x1E0C80C00];
  input[0] = display_token;
  outputCnt = 0;
  return IOConnectCallMethod(handle, 8u, input, 1u, 0, 0, 0, &outputCnt, 0, 0);
}

kern_return_t IOHIDSetVirtualDisplayBounds(io_connect_t handle, UInt32 display_token, const IOGBounds *bounds)
{
  uint64_t minx;
  uint64_t miny;
  uint32_t outputCnt;
  uint64_t input[6];

  input[5] = *MEMORY[0x1E0C80C00];
  minx = bounds->minx;
  input[0] = display_token;
  input[1] = minx;
  miny = bounds->miny;
  input[2] = bounds->maxx;
  input[3] = miny;
  input[4] = bounds->maxy;
  outputCnt = 0;
  return IOConnectCallMethod(handle, 9u, input, 5u, 0, 0, 0, &outputCnt, 0, 0);
}

kern_return_t IOHIDGetActivityState(io_connect_t handle, BOOL *hidActivityIdle)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x1E0C80C00];
  output[0] = 0;
  outputCnt = 1;
  if (!hidActivityIdle)
    return -536870206;
  result = IOConnectCallMethod(handle, 0xAu, 0, 0, 0, 0, output, &outputCnt, 0, 0);
  *hidActivityIdle = output[0] != 0;
  return result;
}

void ____loadTCCFramework_block_invoke()
{
  void *v0;
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;

  v0 = dlopen("/System/Library/PrivateFrameworks/TCC.framework/TCC", 5);
  __loadTCCFramework_tccFramework = (uint64_t)v0;
  if (v0)
  {
    _preflightFunc = (uint64_t (*)(_QWORD, _QWORD))dlsym(v0, "TCCAccessPreflight");
    if (_preflightFunc)
    {
      _requestFunc = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym((void *)__loadTCCFramework_tccFramework, "TCCAccessRequest");
      if (_requestFunc)
      {
        _checkAuditTokenFunc = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym((void *)__loadTCCFramework_tccFramework, "TCCAccessCheckAuditToken");
        if (!_requestFunc)
        {
          v1 = _IOHIDLogCategory(0);
          if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
            ____loadTCCFramework_block_invoke_cold_4();
        }
      }
      else
      {
        v4 = _IOHIDLogCategory(0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          ____loadTCCFramework_block_invoke_cold_3();
      }
    }
    else
    {
      v3 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        ____loadTCCFramework_block_invoke_cold_2();
    }
  }
  else
  {
    v2 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ____loadTCCFramework_block_invoke_cold_1();
  }
}

uint64_t __OSKextVersionStageForString(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  unsigned int v2;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  if (!a1)
    return 0;
  v1 = *a1;
  if (!*a1)
    return 0;
  v2 = *v1;
  if (v2 > 0x20 || ((1 << v2) & 0x100002601) == 0)
  {
    v4 = 0;
    switch((char)v2)
    {
      case 'a':
        v6 = v1[1];
        v5 = v1 + 1;
        if ((v6 - 58) < 0xFFFFFFF6)
          return 0;
        v4 = 3;
        goto LABEL_22;
      case 'b':
        v7 = v1[1];
        v5 = v1 + 1;
        if ((v7 - 58) < 0xFFFFFFF6)
          return 0;
        v4 = 5;
        goto LABEL_22;
      case 'd':
        v8 = v1[1];
        v5 = v1 + 1;
        if ((v8 - 58) < 0xFFFFFFF6)
          return 0;
        v4 = 1;
        goto LABEL_22;
      case 'f':
        v9 = v1[1];
        if ((v9 - 58) > 0xFFFFFFF5)
        {
          v4 = 7;
          v5 = v1 + 1;
        }
        else
        {
          if (v9 != 99)
            return 0;
          v10 = v1[2];
          v5 = v1 + 2;
          if ((v10 - 58) < 0xFFFFFFF6)
            return 0;
          v4 = 7;
        }
LABEL_22:
        *a1 = v5;
        return v4;
      default:
        return v4;
    }
  }
  return 9;
}

uint64_t OSKextVersionGetString(unint64_t a1, void *a2, unsigned int a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  const char *v16;
  const char *v17;

  result = 0;
  if (a2 && a3 >= 0x14)
  {
    bzero(a2, a3);
    if ((a1 & 0x8000000000000000) == 0)
    {
      if (!a1)
      {
        v16 = "(missing)";
        goto LABEL_13;
      }
      if (a1 < 0x2386F26FC10000)
      {
        v7 = (uint64_t)(a1 % 0xE8D4A51000) / 100000000;
        v8 = 1000000000000 * (a1 / 0xE8D4A51000) + 100000000 * v7;
        v9 = a1 - v8;
        v10 = (uint64_t)(a1 - v8) / 10000;
        v11 = a1 - (v8 + 10000 * v10);
        v12 = v11 / 1000;
        if (v11 % 1000 < 256)
        {
          v13 = snprintf((char *)a2, a3, "%u", a1 / 0xE8D4A51000);
          *((_BYTE *)a2 + v13) = 46;
          v14 = snprintf((char *)a2 + v13 + 1, a3 - (v13 + 1), "%u", v7) + (uint64_t)(v13 + 1);
          if (v9 + 9999 >= 0x4E1F)
          {
            *((_BYTE *)a2 + v14) = 46;
            LODWORD(v14) = snprintf((char *)a2 + v14 + 1, a3 - ((_DWORD)v14 + 1), "%u", v10) + v14 + 1;
          }
          v15 = v12 - 1;
          if ((v12 - 1) < 9 && ((0x155u >> v15) & 1) != 0)
          {
            v17 = (&off_1E2001C98)[v15];
            if (*v17)
            {
              strlcat((char *)a2, v17, a3);
              LODWORD(v14) = v14 + strlen(v17);
            }
            if (v11 <= 8999)
              snprintf((char *)a2 + (int)v14, a3 - v14, "%u", v11 % 1000);
            return 1;
          }
        }
      }
    }
    v16 = "(invalid)";
LABEL_13:
    strlcpy((char *)a2, v16, a3);
    return 1;
  }
  return result;
}

uint64_t OSKextParseVersionCFString(const __CFString *a1)
{
  char buffer[20];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (CFStringGetCString(a1, buffer, 20, 0x600u))
    return OSKextParseVersionString(buffer);
  else
    return -1;
}

void *createUTF8CStringForCFString(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  void *v4;

  if (!a1)
    return 0;
  Length = CFStringGetLength(a1);
  v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 4;
  v4 = malloc_type_malloc(v3, 0x100004077774924uLL);
  if (v4 && !CFStringGetCString(a1, (char *)v4, v3, 0x8000100u))
  {
    free(v4);
    return 0;
  }
  return v4;
}

__CFString *createCFStringForData(const __CFData *a1, CFIndex a2)
{
  __CFString *Mutable;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v7;
  const UInt8 *v8;
  CFIndex v9;
  uint64_t v10;
  CFIndex v11;
  const char *v14;
  const char *v15;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (Mutable)
  {
    Length = CFDataGetLength(a1);
    CFStringAppend(Mutable, CFSTR("<"));
    if (Length)
    {
      BytePtr = CFDataGetBytePtr(a1);
      if (Length >= a2)
        v7 = a2;
      else
        v7 = Length;
      if (v7 >= 1)
      {
        v8 = BytePtr;
        v9 = 0;
        do
        {
          v10 = v8[v9];
          v11 = v9 + 1;
          if (((v9 + 1) & 3) == 0 && v11 < Length)
            v14 = " ";
          else
            v14 = "";
          if (v9)
            v15 = v14;
          else
            v15 = "";
          CFStringAppendFormat(Mutable, 0, CFSTR("%02x%s"), v10, v15);
          v9 = v11;
        }
        while (v7 != v11);
      }
      if (Length > a2)
        CFStringAppendFormat(Mutable, 0, CFSTR("...(%u bytes total)"), Length);
    }
    CFStringAppend(Mutable, CFSTR(">"));
  }
  return Mutable;
}

void printPList_new(FILE *a1, const void *a2, uint64_t a3)
{
  __CFString *CFStringForPlist_new;
  const __CFString *v5;
  CFIndex Length;
  CFIndex v7;
  char *v8;
  char *v9;

  CFStringForPlist_new = createCFStringForPlist_new(a2, a3);
  if (CFStringForPlist_new)
  {
    v5 = CFStringForPlist_new;
    Length = CFStringGetLength(CFStringForPlist_new);
    v7 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 4;
    v8 = (char *)malloc_type_malloc(v7, 0x748A3EB9uLL);
    if (v8)
    {
      v9 = v8;
      if (CFStringGetCString(v5, v8, v7, 0x8000100u))
        fputs(v9, a1);
      CFRelease(v5);
      free(v9);
    }
    else
    {
      CFRelease(v5);
    }
  }
}

__CFString *createCFStringForPlist_new(const void *a1, uint64_t a2)
{
  __CFString *Mutable;
  __CFString *v5;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v5 = Mutable;
  if (Mutable)
    _appendPlist(Mutable, a1, a1, a2, 0);
  return v5;
}

void showPList_new(const void *a1, uint64_t a2)
{
  printPList_new((FILE *)*MEMORY[0x1E0C80C20], a1, a2);
}

void _appendPlist(__CFString *a1, const void *a2, const void *a3, uint64_t a4, int a5)
{
  int v10;
  CFTypeID v11;
  CFIndex Count;
  BOOL v13;
  unint64_t v14;
  size_t v15;
  const void **v16;
  const void **v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  int v23;
  CFTypeID TypeID;
  CFTypeID v25;
  CFTypeID v26;
  CFIndex Length;
  int v28;
  _BOOL4 v29;
  CFIndex v30;
  const char *v32;
  CFIndex v33;
  uint64_t v34;
  int v35;
  const void *ValueAtIndex;
  const char *v37;
  BOOL v38;
  const char *v39;
  CFURLRef v40;
  CFURLRef v41;
  CFStringRef v42;
  CFStringRef v43;
  const void *v44;
  __CFString *CFStringForData;
  __CFString *v46;
  int Value;
  const char *v48;
  char *cStr;
  _BOOL4 v50;
  void **keys;
  uint64_t v52;
  UInt8 buffer[1024];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return;
  v10 = 4 * (a2 != a3);
  v11 = CFGetTypeID(a2);
  if (v11 == CFDictionaryGetTypeID())
  {
    Count = CFDictionaryGetCount((CFDictionaryRef)a2);
    v13 = Count < 0;
    v52 = Count;
    if (Count >= 0)
      v14 = Count;
    else
      v14 = -Count;
    if (Count >= 0)
      v15 = 8 * v14;
    else
      v15 = -8 * v14;
    if (!(8 * v14))
      v13 = 0;
    if (!(v14 >> 61) && !v13)
    {
      keys = (void **)malloc_type_malloc(v15, 0x10AB4EB7uLL);
      if (keys)
      {
        v16 = (const void **)malloc_type_malloc(v15, 0x1A7C8BD4uLL);
        if (v16)
        {
          v17 = v16;
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a2, (const void **)keys, v16);
          if ((_DWORD)a4 != 2 || a2 != a3)
          {
            if ((_DWORD)a4 == 2)
              v18 = "\n";
            else
              v18 = "{\n";
            CFStringAppendCString(a1, v18, 0x8000100u);
          }
          if (v52 >= 1)
          {
            v19 = 0;
            v50 = a2 != a3;
            v20 = (v10 + a5);
            if ((_DWORD)a4 == 2)
              v21 = "";
            else
              v21 = "\"";
            v22 = " = ";
            if ((_DWORD)a4 == 2)
              v22 = ": ";
            cStr = (char *)v22;
            do
            {
              if ((_DWORD)v20)
              {
                v23 = v20;
                do
                {
                  CFStringAppendCString(a1, " ", 0x8000100u);
                  --v23;
                }
                while (v23);
              }
              CFStringAppendFormat(a1, 0, CFSTR("%s%@%s"), v21, keys[v19], v21);
              TypeID = CFBooleanGetTypeID();
              v25 = CFGetTypeID(v17[v19]);
              if ((_DWORD)a4 == 2 && TypeID == v25)
              {
                CFStringAppendFormat(a1, 0, CFSTR("\n"));
                ++v19;
              }
              else
              {
                CFStringAppendCString(a1, cStr, 0x8000100u);
                v26 = CFGetTypeID(v17[v19]);
                if (v26 == CFStringGetTypeID())
                {
                  Length = CFStringGetLength((CFStringRef)keys[v19]);
                  if (Length + v20 + CFStringGetLength((CFStringRef)v17[v19]) >= 73)
                  {
                    CFStringAppendCString(a1, "\n", 0x8000100u);
                    if ((_DWORD)v20 != -4)
                    {
                      v28 = v20 + 4;
                      do
                      {
                        CFStringAppendCString(a1, " ", 0x8000100u);
                        --v28;
                      }
                      while (v28);
                    }
                  }
                }
                _appendPlist(a1, v17[v19++], a3, a4, v20);
                v29 = a4 != 2;
                if (v19 >= v52)
                  v29 = 1;
                if (!v29 && !v50)
                  CFStringAppendCString(a1, "\n", 0x8000100u);
              }
            }
            while (v19 != v52);
          }
          if ((_DWORD)a4 != 2)
          {
            for (; a5; --a5)
              CFStringAppendCString(a1, " ", 0x8000100u);
            CFStringAppendCString(a1, "}\n", 0x8000100u);
          }
          free(keys);
          free(v17);
        }
        else
        {
          free(keys);
        }
      }
    }
    return;
  }
  if (v11 != CFArrayGetTypeID())
  {
    if (v11 == CFStringGetTypeID())
    {
      if (a5)
        v38 = (_DWORD)a4 == 2;
      else
        v38 = 1;
      v39 = "\"";
      if (v38)
        v39 = "";
      CFStringAppendFormat(a1, 0, CFSTR("%s%@%s"), v39, a2, v39);
      goto LABEL_73;
    }
    if (v11 == CFURLGetTypeID())
    {
      v40 = CFURLCopyAbsoluteURL((CFURLRef)a2);
      if (v40)
      {
        v41 = v40;
        v42 = CFURLCopyFileSystemPath((CFURLRef)a2, kCFURLPOSIXPathStyle);
        if (v42)
        {
          v43 = v42;
          CFURLGetFileSystemRepresentation((CFURLRef)a2, 1u, buffer, 1024);
          CFStringAppendCString(a1, (const char *)buffer, 0x8000100u);
          CFRelease(v41);
          v44 = v43;
        }
        else
        {
          v44 = v41;
        }
        CFRelease(v44);
      }
      CFStringAppendCString(a1, "\n", 0x8000100u);
      return;
    }
    if (v11 == CFDataGetTypeID())
    {
      CFStringForData = createCFStringForData((const __CFData *)a2, 16);
      if (CFStringForData)
      {
        v46 = CFStringForData;
        CFStringAppend(a1, CFStringForData);
        CFStringAppendCString(a1, "\n", 0x8000100u);
        CFRelease(v46);
        return;
      }
      v37 = "(data object)\n";
    }
    else
    {
      if (v11 == CFNumberGetTypeID())
      {
        CFStringAppendFormat(a1, 0, CFSTR("%@"), a2);
LABEL_73:
        v37 = "\n";
        goto LABEL_74;
      }
      if (v11 == CFBooleanGetTypeID())
      {
        Value = CFBooleanGetValue((CFBooleanRef)a2);
        v48 = "true";
        if (!Value)
          v48 = "false";
        CFStringAppendFormat(a1, 0, CFSTR("%s\n"), v48);
        return;
      }
      if (v11 == CFDateGetTypeID())
        v37 = "(date object)\n";
      else
        v37 = "(unknown object)\n";
    }
LABEL_74:
    CFStringAppendCString(a1, v37, 0x8000100u);
    return;
  }
  v30 = CFArrayGetCount((CFArrayRef)a2);
  if ((_DWORD)a4 != 2 || a2 == a3)
    v32 = "(\n";
  else
    v32 = "\n";
  CFStringAppendCString(a1, v32, 0x8000100u);
  if (v30 >= 1)
  {
    v33 = 0;
    v34 = (v10 + a5);
    do
    {
      if ((_DWORD)v34)
      {
        v35 = v34;
        do
        {
          CFStringAppendCString(a1, " ", 0x8000100u);
          --v35;
        }
        while (v35);
      }
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v33);
      _appendPlist(a1, ValueAtIndex, a3, a4, v34);
      ++v33;
    }
    while (v33 != v30);
  }
  if ((_DWORD)a4 != 2)
  {
    for (; a5; --a5)
      CFStringAppendCString(a1, " ", 0x8000100u);
    v37 = ")\n";
    goto LABEL_74;
  }
}

IOPSLowBatteryWarningLevel IOPSGetBatteryWarningLevel(void)
{
  IOPSLowBatteryWarningLevel v0;
  const __CFAllocator *v1;
  uint64_t (*v2)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v3)(uint64_t, uint64_t, uint64_t, uint64_t);
  CFStringRef v4;
  CFStringRef v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  const __CFNumber *v7;
  CFTypeID TypeID;
  IOPSLowBatteryWarningLevel valuePtr;

  v0 = kIOPSLowBatteryWarningNone;
  valuePtr = kIOPSLowBatteryWarningNone;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = _io_SCDynamicStoreCreate(*MEMORY[0x1E0C9AE00], (uint64_t)CFSTR("IOKit Power Source Copy"), 0, 0);
  if (v2)
  {
    v3 = v2;
    v4 = _io_SCDynamicStoreKeyCreate(v1, CFSTR("%@%@"), CFSTR("State:"), CFSTR("/IOKit/LowBatteryWarning"));
    if (v4)
    {
      v5 = v4;
      v6 = _io_SCDynamicStoreCopyValue((uint64_t)v3, (uint64_t)v4);
      if (v6)
      {
        v7 = (const __CFNumber *)v6;
        TypeID = CFNumberGetTypeID();
        if (CFGetTypeID(v7) == TypeID)
          CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
        CFRelease(v7);
      }
      CFRelease(v3);
      CFRelease(v5);
      return valuePtr;
    }
    else
    {
      CFRelease(v3);
    }
  }
  return v0;
}

uint64_t IOPSGetSupportedPowerSources(_DWORD *a1, BOOL *a2, BOOL *a3)
{
  uint64_t result;
  uint64_t v7;
  int out_token;

  out_token = 0;
  v7 = 0;
  if (notify_register_check("com.apple.system.powersources.timeremaining", &out_token))
    return 3758097084;
  notify_get_state(out_token, &v7);
  notify_cancel(out_token);
  if (a2)
    *a2 = (v7 & 0x400000) != 0;
  if (a3)
    *a3 = (v7 & 0x800000) != 0;
  result = 0;
  if (a1)
    *a1 = HIBYTE(v7);
  return result;
}

CFStringRef IOPSGetProvidingPowerSourceType(CFTypeRef snapshot)
{
  int v1;
  CFStringRef result;
  const __CFString *v3;
  int v4;

  v4 = 0;
  v1 = IOPSGetSupportedPowerSources(&v4, 0, 0);
  result = CFSTR("AC Power");
  if (!v1)
  {
    v3 = CFSTR("Battery Power");
    if (v4 != 2)
      v3 = CFSTR("AC Power");
    if (v4 == 3)
      return CFSTR("UPS Power");
    else
      return v3;
  }
  return result;
}

CFRunLoopSourceRef IOPSNotificationCreateRunLoopSource(IOPowerSourceCallbackType callback, void *context)
{
  return doCreatePSRLS("com.apple.system.powersources.timeremaining", (uint64_t)callback, (uint64_t)context);
}

CFRunLoopSourceRef doCreatePSRLS(const char *a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopSourceRef RunLoopSource;
  _QWORD *v6;
  unsigned int v7;
  __CFMachPort *v8;
  BOOL v9;
  __CFMachPort *v11;
  Boolean shouldFreeInfo;
  CFMachPortContext context;
  int out_token[2];

  *(_QWORD *)out_token = 0;
  shouldFreeInfo = 0;
  if (notify_register_mach_port(a1, (mach_port_t *)out_token, 0, &out_token[1]))
    return 0;
  v6 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A0040E9DA1FB1uLL);
  *v6 = a2;
  v6[1] = a3;
  *((_DWORD *)v6 + 4) = out_token[1];
  context.version = 0;
  context.retain = 0;
  context.release = (void (__cdecl *)(const void *))IOPSRLSMachPortRelease;
  context.copyDescription = 0;
  context.info = v6;
  v7 = 5;
  do
  {
    v8 = CFMachPortCreateWithPort(0, out_token[0], (CFMachPortCallBack)IOPSRLSMachPortCallback, &context, &shouldFreeInfo);
    if (v8)
      v9 = 1;
    else
      v9 = shouldFreeInfo == 0;
  }
  while (!v9 && v7-- > 1);
  v11 = v8;
  if (!v8)
    return 0;
  if (shouldFreeInfo)
  {
    RunLoopSource = 0;
  }
  else
  {
    v6[3] = v8;
    RunLoopSource = CFMachPortCreateRunLoopSource(0, v8, 0);
  }
  CFRelease(v11);
  return RunLoopSource;
}

CFRunLoopSourceRef IOPSCreateLimitedPowerNotification(IOPowerSourceCallbackType callback, void *context)
{
  return doCreatePSRLS("com.apple.system.powersources.source", (uint64_t)callback, (uint64_t)context);
}

CFRunLoopSourceRef IOPSAccNotificationCreateRunLoopSource(uint64_t a1, uint64_t a2)
{
  return doCreatePSRLS("com.apple.system.accpowersources.timeremaining", a1, a2);
}

CFRunLoopSourceRef IOPSAccCreateLimitedPowerNotification(uint64_t a1, uint64_t a2)
{
  return doCreatePSRLS("com.apple.system.accpowersources.source", a1, a2);
}

CFRunLoopSourceRef IOPSAccCreateAttachNotification(uint64_t a1, uint64_t a2)
{
  return doCreatePSRLS("com.apple.system.accpowersources.attach", a1, a2);
}

void IOPSRLSMachPortRelease(void *a1)
{
  int v2;
  __CFMachPort *v3;

  if (a1)
  {
    v2 = *((_DWORD *)a1 + 4);
    if (v2)
      notify_cancel(v2);
    v3 = (__CFMachPort *)*((_QWORD *)a1 + 3);
    if (v3)
    {
      CFMachPortInvalidate(v3);
      CFRelease(*((CFTypeRef *)a1 + 3));
    }
    free(a1);
  }
}

uint64_t IOPSRLSMachPortCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (a4)
  {
    if (*(_QWORD *)a4)
      return (*(uint64_t (**)(_QWORD))a4)(*(_QWORD *)(a4 + 8));
  }
  return result;
}

__CFArray *IOPSCopyInternalBatteriesArray(const void *a1)
{
  CFArrayRef v2;
  CFTypeID TypeID;
  int Count;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFDictionary *v8;
  CFTypeID v9;
  const void *Value;
  CFTypeID v11;

  v2 = IOPSCopyPowerSourcesList(a1);
  if (v2)
  {
    TypeID = CFArrayGetTypeID();
    if (CFGetTypeID(v2) != TypeID)
    {
      Mutable = 0;
      goto LABEL_18;
    }
  }
  Count = CFArrayGetCount(v2);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    goto LABEL_14;
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
      v8 = IOPSGetPowerSourceDescription(a1, ValueAtIndex);
      v9 = CFDictionaryGetTypeID();
      if (v8)
      {
        if (CFGetTypeID(v8) == v9)
        {
          Value = CFDictionaryGetValue(v8, CFSTR("Transport Type"));
          v11 = CFStringGetTypeID();
          if (Value)
          {
            if (CFGetTypeID(Value) == v11 && CFEqual(Value, CFSTR("Internal")))
              CFArrayAppendValue(Mutable, ValueAtIndex);
          }
        }
      }
    }
  }
  if (CFArrayGetCount(Mutable))
  {
LABEL_14:
    if (!v2)
      return Mutable;
    goto LABEL_18;
  }
  CFRelease(Mutable);
  Mutable = 0;
  if (v2)
LABEL_18:
    CFRelease(v2);
  return Mutable;
}

__CFArray *IOPSCopyUPSArray(const void *a1)
{
  CFArrayRef v2;
  CFTypeID TypeID;
  int Count;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFDictionary *v8;
  CFTypeID v9;
  const void *Value;
  CFTypeID v11;

  v2 = IOPSCopyPowerSourcesList(a1);
  if (v2)
  {
    TypeID = CFArrayGetTypeID();
    if (CFGetTypeID(v2) != TypeID)
    {
      Mutable = 0;
      goto LABEL_20;
    }
  }
  Count = CFArrayGetCount(v2);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    goto LABEL_16;
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
      v8 = IOPSGetPowerSourceDescription(a1, ValueAtIndex);
      v9 = CFDictionaryGetTypeID();
      if (v8)
      {
        if (CFGetTypeID(v8) == v9)
        {
          Value = CFDictionaryGetValue(v8, CFSTR("Transport Type"));
          v11 = CFStringGetTypeID();
          if (Value)
          {
            if (CFGetTypeID(Value) == v11
              && (CFEqual(Value, CFSTR("Serial")) || CFEqual(Value, CFSTR("USB")) || CFEqual(Value, CFSTR("Ethernet"))))
            {
              CFArrayAppendValue(Mutable, ValueAtIndex);
            }
          }
        }
      }
    }
  }
  if (CFArrayGetCount(Mutable))
  {
LABEL_16:
    if (!v2)
      return Mutable;
    goto LABEL_20;
  }
  CFRelease(Mutable);
  Mutable = 0;
  if (v2)
LABEL_20:
    CFRelease(v2);
  return Mutable;
}

__CFArray *IOPSGetActiveUPS(const void *a1)
{
  __CFArray *result;
  __CFArray *v2;
  const void *ValueAtIndex;

  result = IOPSCopyUPSArray(a1);
  if (result)
  {
    v2 = result;
    ValueAtIndex = CFArrayGetValueAtIndex(result, 0);
    CFRelease(v2);
    return (__CFArray *)ValueAtIndex;
  }
  return result;
}

__CFArray *IOPSGetActiveBattery(const void *a1)
{
  __CFArray *result;
  __CFArray *v2;
  const void *ValueAtIndex;

  result = IOPSCopyInternalBatteriesArray(a1);
  if (result)
  {
    v2 = result;
    ValueAtIndex = CFArrayGetValueAtIndex(result, 0);
    CFRelease(v2);
    return (__CFArray *)ValueAtIndex;
  }
  return result;
}

uint64_t IOPSPowerSourceSupported(const void *a1, const void *a2)
{
  CFTypeID TypeID;
  uint64_t v5;
  io_registry_entry_t v6;
  io_object_t v7;
  CFTypeRef CFProperty;
  CFTypeID v9;

  TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_17;
  if (CFEqual(a2, CFSTR("AC Power")))
    goto LABEL_4;
  if (CFEqual(a2, CFSTR("Battery Power")))
  {
    v6 = IORegistryEntryFromPath(0, "IODeviceTree:/product");
    if (v6)
    {
      v7 = v6;
      CFProperty = IORegistryEntryCreateCFProperty(v6, CFSTR("builtin-battery"), 0, 0);
      IOObjectRelease(v7);
      if (CFProperty)
      {
        v9 = CFGetTypeID(CFProperty);
        if (v9 == CFDataGetTypeID())
        {
          CFDataGetBytePtr((CFDataRef)CFProperty);
          if ((unint64_t)CFDataGetLength((CFDataRef)CFProperty) <= 8)
            CFDataGetLength((CFDataRef)CFProperty);
          __memcpy_chk();
          CFRelease(CFProperty);
        }
      }
    }
  }
  if (a1
    && (CFEqual(a2, CFSTR("Battery Power")) && IOPSGetActiveBattery(a1)
     || CFEqual(a2, CFSTR("UPS Power")) && IOPSGetActiveUPS(a1)))
  {
LABEL_4:
    v5 = MEMORY[0x1E0C9AE50];
  }
  else
  {
LABEL_17:
    v5 = MEMORY[0x1E0C9AE40];
  }
  return *(_QWORD *)v5;
}

dispatch_queue_t _getPSDispatchQueue()
{
  dispatch_queue_t result;

  result = (dispatch_queue_t)_getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    result = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)result;
  }
  return result;
}

uint64_t IOPSCreatePowerSource(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = _getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    v2 = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)v2;
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __IOPSCreatePowerSource_block_invoke;
  v5[3] = &unk_1E2001D28;
  v5[4] = &v6;
  v5[5] = a1;
  dispatch_sync(v2, v5);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t createPowerSource(uint64_t a1)
{
  int v2;
  unsigned int v4;
  int v5;

  v5 = 0;
  v4 = _pm_connect(&v5);
  if (v4)
  {
    v2 = -536870195;
  }
  else
  {
    if (!io_ps_new_pspowersource(v5, (_DWORD *)(a1 + 8), &v4))
      goto LABEL_6;
    v2 = -536870163;
  }
  v4 = v2;
LABEL_6:
  if (v5)
    _pm_disconnect();
  return v4;
}

uint64_t setPowerSourceDetails(uint64_t a1, const void *a2)
{
  uint64_t v2;
  CFTypeID TypeID;
  CFDataRef v6;
  const __CFData *v7;
  mach_port_t v8;
  int v9;
  const UInt8 *BytePtr;
  int Length;
  CFMutableDictionaryRef MutableCopy;
  CFTypeRef v13;
  CFTypeID v14;
  mach_port_t v16;
  unsigned int v17;

  v2 = 3758097090;
  v16 = 0;
  if (a1)
  {
    TypeID = CFDictionaryGetTypeID();
    if (a2)
    {
      if (CFGetTypeID(a2) == TypeID)
      {
        if (*(_DWORD *)(a1 + 8))
        {
          v6 = IOCFSerialize(a2, 0);
          if (v6)
          {
            v7 = v6;
            v17 = _pm_connect(&v16);
            if (v17)
            {
              v17 = -536870195;
            }
            else
            {
              v8 = v16;
              v9 = *(_DWORD *)(a1 + 8);
              BytePtr = CFDataGetBytePtr(v7);
              Length = CFDataGetLength(v7);
              io_ps_update_pspowersource(v8, v9, (uint64_t)BytePtr, Length, (int *)&v17);
              if (!v17)
              {
                MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a2);
                v13 = *(CFTypeRef *)a1;
                v14 = CFDictionaryGetTypeID();
                if (v13 && CFGetTypeID(v13) == v14)
                  CFRelease(*(CFTypeRef *)a1);
                *(_QWORD *)a1 = MutableCopy;
              }
              _pm_disconnect();
            }
            CFRelease(v7);
            return v17;
          }
        }
      }
    }
  }
  return v2;
}

uint64_t IOPSSetPowerSourceDetails(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v4 = _getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    v4 = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)v4;
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOPSSetPowerSourceDetails_block_invoke;
  block[3] = &unk_1E2001D50;
  block[4] = &v8;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync(v4, block);
  v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t IOPSReleasePowerSource(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = _getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    v2 = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)v2;
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __IOPSReleasePowerSource_block_invoke;
  v5[3] = &unk_1E2001D78;
  v5[4] = &v6;
  v5[5] = a1;
  dispatch_sync(v2, v5);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t IOPSGaugingMitigationGetState(uint64_t *a1)
{
  uint64_t uint64;
  NSObject *PMQueue;
  NSObject *v4;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;
  const __CFAllocator *v9;
  CFDictionaryRef v10;
  void *v11;
  xpc_object_t v12;
  _BOOL8 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL8 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  uint64 = 3758097085;
  PMQueue = getPMQueue();
  valuePtr = 1;
  if (!a1)
    return 3758097090;
  v4 = PMQueue;
  if (!PMQueue)
    return 3758097089;
  values = 0;
  keys[0] = 0;
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
  if (mach_service)
  {
    v6 = mach_service;
    xpc_connection_set_target_queue(mach_service, v4);
    xpc_connection_set_event_handler(v6, &__block_literal_global_4);
    xpc_connection_resume(v6);
    v7 = xpc_dictionary_create(0, 0, 0);
    if (v7)
    {
      v8 = v7;
      keys[0] = CFSTR("batteryGaugingMitigationAction");
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, &valuePtr);
      v10 = CFDictionaryCreate(v9, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      CFRelease(v10);
      CFRelease(values);
      values = 0;
      xpc_dictionary_set_value(v8, "batteryGaugingMitigation", v11);
      v12 = xpc_connection_send_message_with_reply_sync(v6, v8);
      if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
      {
        uint64 = xpc_dictionary_get_uint64(v12, "returnCode");
        if (!(_DWORD)uint64)
        {
          xpc_dictionary_get_value(v12, "batteryGaugingMitigationState");
          *a1 = _CFXPCCreateCFObjectFromXPCObject();
        }
      }
      else
      {
        uint64 = 3758097087;
      }
      if (v11)
        xpc_release(v11);
      if (v12)
        xpc_release(v12);
      xpc_release(v8);
    }
    else
    {
      v21 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v21)
        IOPSGaugingMitigationGetState_cold_2(v21, v22, v23, v24, v25, v26, v27, v28);
    }
    xpc_release(v6);
  }
  else
  {
    v13 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    uint64 = 3758097088;
    if (v13)
      IOPSGaugingMitigationGetState_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  return uint64;
}

uint64_t IOPSLimitBatteryLevelRegister(uint64_t *a1)
{
  uint64_t uint64;
  NSObject *PMQueue;
  NSObject *v4;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;
  const __CFAllocator *v9;
  CFDictionaryRef v10;
  void *v11;
  xpc_object_t v12;
  _BOOL8 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL8 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  char valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  uint64 = 3758097084;
  PMQueue = getPMQueue();
  valuePtr = 1;
  if (!a1)
    return 3758097090;
  v4 = PMQueue;
  if (PMQueue)
  {
    values = 0;
    keys[0] = 0;
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      v6 = mach_service;
      xpc_connection_set_target_queue(mach_service, v4);
      xpc_connection_set_event_handler(v6, &__block_literal_global_39);
      xpc_connection_resume(v6);
      v7 = xpc_dictionary_create(0, 0, 0);
      if (!v7)
      {
        v21 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        uint64 = 3758097085;
        if (v21)
          IOPSGaugingMitigationGetState_cold_2(v21, v22, v23, v24, v25, v26, v27, v28);
        goto LABEL_18;
      }
      v8 = v7;
      keys[0] = CFSTR("chargeSocLimitAction");
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, &valuePtr);
      v10 = CFDictionaryCreate(v9, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      CFRelease(v10);
      CFRelease(values);
      xpc_dictionary_set_value(v8, "chargeSocLimit", v11);
      v12 = xpc_connection_send_message_with_reply_sync(v6, v8);
      if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
      {
        uint64 = xpc_dictionary_get_uint64(v12, "returnCode");
        if ((_DWORD)uint64)
          goto LABEL_13;
        if (xpc_dictionary_get_value(v12, "chargeSocLimitToken"))
        {
          v30 = _CFXPCCreateCFObjectFromXPCObject();
          uint64 = 3758097084;
          if (v30)
          {
            uint64 = 0;
            *a1 = v30;
          }
          goto LABEL_13;
        }
      }
      uint64 = 3758097084;
LABEL_13:
      if (v11)
        xpc_release(v11);
      if (v12)
        xpc_release(v12);
      xpc_release(v8);
LABEL_18:
      xpc_release(v6);
      return uint64;
    }
    v13 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v13)
      IOPSGaugingMitigationGetState_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  return uint64;
}

uint64_t IOPSLimitBatteryLevelCancel(const void *a1)
{
  uint64_t uint64;
  NSObject *PMQueue;
  NSObject *v4;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;
  const __CFAllocator *v9;
  CFNumberRef v10;
  CFDictionaryRef v11;
  void *v12;
  xpc_object_t v13;
  _BOOL8 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL8 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char valuePtr;
  void *values;
  CFTypeRef cf;
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  uint64 = 3758097084;
  PMQueue = getPMQueue();
  valuePtr = 2;
  if (!a1)
    return 3758097090;
  v4 = PMQueue;
  if (PMQueue)
  {
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      v6 = mach_service;
      xpc_connection_set_target_queue(mach_service, v4);
      xpc_connection_set_event_handler(v6, &__block_literal_global_45);
      xpc_connection_resume(v6);
      v7 = xpc_dictionary_create(0, 0, 0);
      if (v7)
      {
        v8 = v7;
        keys[0] = CFSTR("chargeSocLimitAction");
        v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, &valuePtr);
        keys[1] = CFSTR("chargeSocLimitToken");
        values = v10;
        cf = a1;
        CFRetain(a1);
        v11 = CFDictionaryCreate(v9, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v12 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        CFRelease(v11);
        CFRelease(values);
        CFRelease(cf);
        xpc_dictionary_set_value(v8, "chargeSocLimit", v12);
        v13 = xpc_connection_send_message_with_reply_sync(v6, v8);
        if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
          uint64 = xpc_dictionary_get_uint64(v13, "returnCode");
        if (v12)
          xpc_release(v12);
        if (v13)
          xpc_release(v13);
        xpc_release(v8);
        xpc_release(v6);
        if (!(_DWORD)uint64)
          CFRelease(a1);
      }
      else
      {
        v22 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v22)
          IOPSGaugingMitigationGetState_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
        xpc_release(v6);
        return 3758097085;
      }
    }
    else
    {
      v14 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v14)
        IOPSGaugingMitigationGetState_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  return uint64;
}

uint64_t IOPSLimitBatteryLevel(void *a1, char a2, char a3, const __CFString *a4)
{
  uint64_t uint64;
  NSObject *PMQueue;
  uint64_t result;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v11;
  xpc_object_t v12;
  void *v13;
  const __CFAllocator *v14;
  CFNumberRef v15;
  CFDictionaryRef v16;
  void *v17;
  uint64_t i;
  xpc_object_t v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL8 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char valuePtr;
  BOOL v37;
  char v38;
  char v39;
  void *values[2];
  __int128 v41;
  __int128 v42;
  void *keys[2];
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  uint64 = 3758097084;
  v39 = a2;
  PMQueue = getPMQueue();
  v38 = a3 & 1;
  v37 = (a3 & 2) != 0;
  valuePtr = 3;
  result = 3758097090;
  if (!a1 || !a4)
    return result;
  if (!PMQueue)
    return 3758097084;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  *(_OWORD *)keys = 0u;
  *(_OWORD *)values = 0u;
  v41 = 0u;
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
  if (!mach_service)
  {
    v20 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v20)
      IOPSGaugingMitigationGetState_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
    return 3758097084;
  }
  v11 = mach_service;
  xpc_connection_set_target_queue(mach_service, PMQueue);
  xpc_connection_set_event_handler(v11, &__block_literal_global_49);
  xpc_connection_resume(v11);
  v12 = xpc_dictionary_create(0, 0, 0);
  if (v12)
  {
    v13 = v12;
    keys[0] = CFSTR("chargeSocLimitAction");
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, &valuePtr);
    keys[1] = CFSTR("chargeSocLimitToken");
    values[0] = v15;
    values[1] = a1;
    CFRetain(a1);
    *(_QWORD *)&v44 = CFSTR("chargeSocLimitSoc");
    *(_QWORD *)&v41 = CFNumberCreate(v14, kCFNumberSInt8Type, &v39);
    *((_QWORD *)&v44 + 1) = CFSTR("chargeSocLimitDrain");
    *((_QWORD *)&v41 + 1) = CFNumberCreate(v14, kCFNumberSInt8Type, &v38);
    *(_QWORD *)&v45 = CFSTR("chargeSocLimitNoChargeToFull");
    *(_QWORD *)&v42 = CFNumberCreate(v14, kCFNumberSInt8Type, &v37);
    *((_QWORD *)&v45 + 1) = CFSTR("chargeSocLimitReason");
    *((_QWORD *)&v42 + 1) = CFStringCreateCopy(v14, a4);
    v16 = CFDictionaryCreate(v14, (const void **)keys, (const void **)values, 6, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v17 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    CFRelease(v16);
    for (i = 0; i != 6; ++i)
      CFRelease(values[i]);
    xpc_dictionary_set_value(v13, "chargeSocLimit", v17);
    v19 = xpc_connection_send_message_with_reply_sync(v11, v13);
    if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
      uint64 = xpc_dictionary_get_uint64(v19, "returnCode");
    if (v17)
      xpc_release(v17);
    if (v19)
      xpc_release(v19);
    xpc_release(v13);
  }
  else
  {
    v28 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    uint64 = 3758097085;
    if (v28)
      IOPSGaugingMitigationGetState_cold_2(v28, v29, v30, v31, v32, v33, v34, v35);
  }
  xpc_release(v11);
  return uint64;
}

uint64_t IOPSCopyBatteryLevelLimits()
{
  NSObject *PMQueue;
  NSObject *v1;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v3;
  xpc_object_t v4;
  void *v5;
  const __CFAllocator *v6;
  CFDictionaryRef v7;
  void *v8;
  xpc_object_t v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  PMQueue = getPMQueue();
  valuePtr = 4;
  if (PMQueue)
  {
    v1 = PMQueue;
    values = 0;
    keys[0] = 0;
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      v3 = mach_service;
      xpc_connection_set_target_queue(mach_service, v1);
      xpc_connection_set_event_handler(v3, &__block_literal_global_59);
      xpc_connection_resume(v3);
      v4 = xpc_dictionary_create(0, 0, 0);
      if (!v4)
      {
        v19 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        if (v19)
          IOPSGaugingMitigationGetState_cold_2(v19, v20, v21, v22, v23, v24, v25, v26);
        v10 = 0;
        goto LABEL_17;
      }
      v5 = v4;
      keys[0] = CFSTR("chargeSocLimitAction");
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, &valuePtr);
      v7 = CFDictionaryCreate(v6, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      CFRelease(v7);
      CFRelease(values);
      xpc_dictionary_set_value(v5, "chargeSocLimit", v8);
      v9 = xpc_connection_send_message_with_reply_sync(v3, v5);
      if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8]
        && !xpc_dictionary_get_uint64(v9, "returnCode")
        && xpc_dictionary_get_value(v9, "chargeSocLimit"))
      {
        v10 = _CFXPCCreateCFObjectFromXPCObject();
        if (!v8)
          goto LABEL_8;
      }
      else
      {
        v10 = 0;
        if (!v8)
        {
LABEL_8:
          if (v9)
            xpc_release(v9);
          xpc_release(v5);
LABEL_17:
          xpc_release(v3);
          return v10;
        }
      }
      xpc_release(v8);
      goto LABEL_8;
    }
    v11 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v11)
      IOPSGaugingMitigationGetState_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return 0;
}

uint64_t IOPSSetBatteryDateOfFirstUse(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4)
{
  uint64_t uint64;
  NSObject *PMQueue;
  NSObject *v10;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v12;
  xpc_object_t v13;
  void *v14;
  void *v15;
  void *v16;
  xpc_object_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL8 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v35[6];

  uint64 = 3758097084;
  PMQueue = getPMQueue();
  if (!a1)
    return 3758097090;
  v10 = PMQueue;
  if (PMQueue)
  {
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      v12 = mach_service;
      xpc_connection_set_target_queue(mach_service, v10);
      xpc_connection_set_event_handler(v12, &__block_literal_global_61);
      xpc_connection_resume(v12);
      v13 = xpc_dictionary_create(0, 0, 0);
      if (v13)
      {
        v14 = v13;
        v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v15)
        {
          v16 = v15;
          xpc_dictionary_set_value(v14, "setBatteryDofu", v15);
          v17 = xpc_connection_send_message_with_reply_sync(v12, v14);
          if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
            uint64 = xpc_dictionary_get_uint64(v17, "returnCode");
          else
            uint64 = 3758097097;
          xpc_release(v16);
          if (v17)
            xpc_release(v17);
        }
        else
        {
          uint64 = 3758097085;
        }
        xpc_release(v14);
      }
      else
      {
        v26 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
        uint64 = 3758097085;
        if (v26)
          IOPSGaugingMitigationGetState_cold_2(v26, v27, v28, v29, v30, v31, v32, v33);
      }
      xpc_release(v12);
      if (a2 && a4 && !(_DWORD)uint64)
      {
        v35[0] = MEMORY[0x1E0C809B0];
        v35[1] = 0x40000000;
        v35[2] = __IOPSSetBatteryDateOfFirstUse_block_invoke_63;
        v35[3] = &unk_1E2001EA0;
        v35[4] = a4;
        v35[5] = a3;
        dispatch_async(a2, v35);
      }
    }
    else
    {
      v18 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v18)
        IOPSGaugingMitigationGetState_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
    }
  }
  return uint64;
}

uint64_t IOPSGetBatteryHealthState(uint64_t *a1)
{
  uint64_t uint64;
  NSObject *PMQueue;
  NSObject *v4;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v10;
  void *v11;
  void *v12;
  xpc_object_t v13;
  _BOOL8 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL8 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  uint64 = 3758097085;
  PMQueue = getPMQueue();
  if (!a1)
    return 3758097090;
  v4 = PMQueue;
  if (!PMQueue)
    return 3758097084;
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
  if (mach_service)
  {
    v6 = mach_service;
    xpc_connection_set_target_queue(mach_service, v4);
    xpc_connection_set_event_handler(v6, &__block_literal_global_68);
    xpc_connection_resume(v6);
    v7 = xpc_dictionary_create(0, 0, 0);
    if (v7)
    {
      v8 = v7;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v10 = Mutable;
        v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v11)
        {
          v12 = v11;
          xpc_dictionary_set_value(v8, "getBatteryHealthState", v11);
          v13 = xpc_connection_send_message_with_reply_sync(v6, v8);
          if (MEMORY[0x18D773128]() == MEMORY[0x1E0C812F8])
          {
            uint64 = xpc_dictionary_get_uint64(v13, "returnCode");
            if (!(_DWORD)uint64)
            {
              xpc_dictionary_get_value(v13, "IOPSPrivateBatteryHealthState");
              *a1 = _CFXPCCreateCFObjectFromXPCObject();
            }
          }
          else
          {
            uint64 = 3758097105;
          }
          if (v13)
            xpc_release(v13);
          xpc_release(v12);
        }
        CFRelease(v10);
      }
      xpc_release(v8);
    }
    else
    {
      v22 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v22)
        IOPSGaugingMitigationGetState_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
      CFRelease((CFTypeRef)v22);
    }
    xpc_release(v6);
  }
  else
  {
    v14 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    uint64 = 3758097088;
    if (v14)
      IOPSGaugingMitigationGetState_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
  return uint64;
}

uint64_t IOPSCopyPowerSourcesInfoPrecise(uint64_t *a1)
{
  return IOPSCopyPowerSourcesByTypePrecise(3, a1);
}

uint64_t IOPSGetYearAndWeekOfManufactureFromBatterySerial(const __CFString *a1, _QWORD *a2)
{
  uint64_t v4;
  const char *CStringPtr;
  uint64_t v6;
  int v7;
  char v8;
  unint64_t v9;
  const __CFAllocator *v10;
  const __CFDate *v11;
  CFCalendarRef v12;
  __CFDateFormatter *ISO8601Formatter;
  const __CFString *StringWithDate;
  CFIndex Length;
  __CFString *MutableCopy;
  char __str[4];
  CFRange v19;
  CFRange v20;
  CFRange v21;

  if (CFStringGetLength(a1) != 17)
  {
    if (CFStringGetLength(a1) != 18)
      return 0;
    *(_DWORD *)__str = 0;
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    v6 = 0;
    *(_WORD *)__str = *(_WORD *)(CStringPtr + 3);
    __str[2] = CStringPtr[5];
    while (1)
    {
      v7 = __str[v6];
      if (v7 > 79)
        break;
      if (v7 >= 74)
      {
        v8 = -1;
        goto LABEL_9;
      }
LABEL_10:
      if (++v6 == 3)
      {
        v9 = strtoull(__str, 0, 34);
        v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v11 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (double)(86400 * v9) - *MEMORY[0x1E0C9ADF8]);
        v12 = CFCalendarCreateWithIdentifier(v10, (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
        ISO8601Formatter = CFDateFormatterCreateISO8601Formatter(v10, 5uLL);
        StringWithDate = CFDateFormatterCreateStringWithDate(v10, ISO8601Formatter, v11);
        Length = CFStringGetLength(StringWithDate);
        MutableCopy = CFStringCreateMutableCopy(v10, Length, StringWithDate);
        v19.location = 0;
        v19.length = 3;
        CFStringDelete(MutableCopy, v19);
        v4 = 1;
        v20.location = 1;
        v20.length = 1;
        CFStringDelete(MutableCopy, v20);
        *a2 = MutableCopy;
        CFRelease(v11);
        CFRelease(v12);
        CFRelease(ISO8601Formatter);
        CFRelease(StringWithDate);
        return v4;
      }
    }
    v8 = -2;
LABEL_9:
    __str[v6] = v7 + v8;
    goto LABEL_10;
  }
  v21.location = 3;
  v21.length = 3;
  *a2 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v21);
  return 1;
}

void OUTLINED_FUNCTION_1_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_5(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

dispatch_queue_t __getPMQueue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("PM Notifications", 0);
  getPMQueue_pmQueue = (uint64_t)result;
  return result;
}

uint64_t getUserActiveValidDict()
{
  uint64_t result;
  _BOOL8 v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = getUserActiveValidDict__useractiveValid;
  if (!getUserActiveValidDict__useractiveValid)
  {
    if (getUserActiveValidDict__token != -1)
      dispatch_once(&getUserActiveValidDict__token, &__block_literal_global_5);
    result = getUserActiveValidDict__useractiveValid;
    if (!getUserActiveValidDict__useractiveValid)
    {
      v1 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      if (v1)
        getUserActiveValidDict_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
      return 0;
    }
  }
  return result;
}

CFMutableDictionaryRef __getUserActiveValidDict_block_invoke()
{
  CFMutableDictionaryRef result;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  getUserActiveValidDict__useractiveValid = (uint64_t)result;
  return result;
}

uint64_t IOPMUserIsActive()
{
  return gIOPMUserIsActive;
}

uint64_t decodeIOPMUserIsActive(char a1)
{
  return a1 & 1;
}

_QWORD *IOPMScheduleUserActiveChangedNotification(NSObject *a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __IOPMScheduleUserActiveChangedNotification_block_invoke;
  v3[3] = &unk_1E2001FA8;
  v3[4] = a2;
  return IOPMScheduleUserActivityLevelNotificationWithTimeout(a1, -1, v3);
}

_QWORD *IOPMScheduleUserActivityLevelNotificationWithTimeout(NSObject *a1, int a2, const void *a3)
{
  _QWORD *v6;
  xpc_connection_t mach_service;
  _xpc_connection_s *v8;
  NSObject *PMQueue;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  _QWORD v14[6];
  _QWORD handler[5];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  _QWORD block[5];

  v6 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A00403A6C22E7uLL);
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  if (v6)
  {
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E0C80D38], 0);
    if (!mach_service)
    {
      free(v6);
      goto LABEL_6;
    }
    v8 = mach_service;
    PMQueue = getPMQueue();
    xpc_connection_set_target_queue(v8, PMQueue);
    v10 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = __IOPMScheduleUserActivityLevelNotificationWithTimeout_block_invoke;
    handler[3] = &__block_descriptor_tmp_17;
    handler[4] = v6;
    xpc_connection_set_event_handler(v8, handler);
    v6[6] = v8;
    dispatch_retain(a1);
    *v6 = a1;
    v6[4] = _Block_copy(a3);
    *((_DWORD *)v6 + 14) = a2;
    xpc_connection_resume(v8);
    v11 = getPMQueue();
    v14[0] = v10;
    v14[1] = 0x40000000;
    v14[2] = __IOPMScheduleUserActivityLevelNotificationWithTimeout_block_invoke_2;
    v14[3] = &unk_1E2002058;
    v14[4] = &v16;
    v14[5] = v6;
    dispatch_sync(v11, v14);
    if (!*((_BYTE *)v17 + 24))
    {
      v12 = getPMQueue();
      block[0] = v10;
      block[1] = 0x40000000;
      block[2] = __IOPMUnregisterNotification_block_invoke;
      block[3] = &__block_descriptor_tmp_8;
      block[4] = v6;
      dispatch_sync(v12, block);
LABEL_6:
      v6 = 0;
    }
  }
  _Block_object_dispose(&v16, 8);
  return v6;
}

void IOPMUnregisterNotification(uint64_t a1)
{
  NSObject *PMQueue;
  _QWORD block[5];

  PMQueue = getPMQueue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOPMUnregisterNotification_block_invoke;
  block[3] = &__block_descriptor_tmp_8;
  block[4] = a1;
  dispatch_sync(PMQueue, block);
}

uint64_t IOPMGetUserActivityLevel(unint64_t *a1, unint64_t *a2)
{
  uint32_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v9;
  int out_token;

  out_token = 0;
  v9 = 0;
  v4 = notify_register_check("com.apple.system.powermanagement.useractivity2", &out_token);
  v5 = 0;
  if (v4)
  {
    if (!a1)
      goto LABEL_4;
    goto LABEL_3;
  }
  notify_get_state(out_token, &v9);
  notify_cancel(out_token);
  v5 = v9;
  if (a1)
LABEL_3:
    *a1 = v5;
LABEL_4:
  if (a2)
  {
    v6 = v5 & (1 << __clz(__rbit64(v5)));
    if (v5)
      v7 = v6;
    else
      v7 = 0;
    *a2 = v7;
  }
  return 0;
}

BOOL sendUserActivityMsg(uint64_t a1, const char *a2)
{
  NSObject *PMQueue;
  xpc_object_t v5;
  xpc_object_t v6;
  void *v7;
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  PMQueue = getPMQueue();
  dispatch_assert_queue_V2(PMQueue);
  if (!a1 || !*(_QWORD *)(a1 + 48))
  {
    result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    sendUserActivityMsg_cold_1(result, v9, v10, v11, v12, v13, v14, v15);
    return 0;
  }
  v5 = xpc_dictionary_create(0, 0, 0);
  v6 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v5, "ActivityTimeout", *(unsigned int *)(a1 + 56));
      xpc_dictionary_set_value(v7, a2, v5);
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 48), v7);
      xpc_release(v7);
      xpc_release(v5);
      return 1;
    }
  }
  result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
  if (result)
  {
    sendUserActivityMsg_cold_2(result, v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  return result;
}

void processUserActivityMsg(uint64_t a1, void *a2)
{
  uint64_t v4;
  __CFDictionary *UserActiveValidDict;
  CFNumberRef v6;
  const void *v7;
  const void *v8;
  IONotificationPort *v9;
  io_object_t v10;
  int v11;
  void *v12;
  uint64_t uint64;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  dispatch_object_t v18;
  _QWORD *v19;
  NSObject *PMQueue;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[5];
  _QWORD block[7];
  uint8_t buf[4];
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v4 = MEMORY[0x18D773128](a2);
  if (v4 == MEMORY[0x1E0C812F8])
  {
    uint64 = xpc_dictionary_get_uint64(a2, "UserActivityLevels");
    *(_QWORD *)(a1 + 64) = uint64;
    v14 = 1 << __clz(__rbit64(uint64));
    if (uint64)
      v15 = v14;
    else
      v15 = 0;
    v16 = _Block_copy(*(const void **)(a1 + 32));
    v17 = *(_QWORD *)(a1 + 64);
    v18 = *(dispatch_object_t *)a1;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __processUserActivityMsg_block_invoke;
    block[3] = &unk_1E2001FF0;
    block[4] = v16;
    block[5] = v17;
    block[6] = v15;
    v19 = block;
    PMQueue = v18;
    goto LABEL_30;
  }
  if (v4 != MEMORY[0x1E0C81310])
    return;
  if (a2 == (void *)MEMORY[0x1E0C81258])
  {
    PMQueue = getPMQueue();
    v35[0] = MEMORY[0x1E0C809B0];
    v35[1] = 0x40000000;
    v35[2] = __processUserActivityMsg_block_invoke_2;
    v35[3] = &__block_descriptor_tmp_14_0;
    v35[4] = a1;
    v19 = v35;
LABEL_30:
    dispatch_async(PMQueue, v19);
    return;
  }
  if (a2 == (void *)MEMORY[0x1E0C81288])
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      processUserActivityMsg_cold_1(a1, v21, v22, v23, v24, v25, v26, v27);
  }
  else
  {
    if (a2 != (void *)MEMORY[0x1E0C81260])
      return;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v38 = a1;
      _os_log_error_impl(&dword_18AAAF000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Received connection invalid error for connection 0x%lx. UnregisterNotification", buf, 0xCu);
      if (!a1)
        return;
    }
    else if (!a1)
    {
      return;
    }
    UserActiveValidDict = (__CFDictionary *)getUserActiveValidDict();
    v6 = CFNumberCreate(0, kCFNumberSInt64Type, (const void *)a1);
    if (CFDictionaryGetValue(UserActiveValidDict, v6))
    {
      CFDictionaryRemoveValue(UserActiveValidDict, v6);
      if (v6)
        CFRelease(v6);
      v7 = *(const void **)(a1 + 8);
      if (v7)
        _Block_release(v7);
      v8 = *(const void **)(a1 + 32);
      if (v8)
        _Block_release(v8);
      v9 = *(IONotificationPort **)(a1 + 16);
      if (v9)
        IONotificationPortDestroy(v9);
      v10 = *(_DWORD *)(a1 + 24);
      if (v10)
        IOObjectRelease(v10);
      v11 = *(_DWORD *)(a1 + 40);
      if (v11)
        notify_cancel(v11);
      v12 = *(void **)(a1 + 48);
      if (v12)
        xpc_release(v12);
      if (*(_QWORD *)a1)
        dispatch_release(*(dispatch_object_t *)a1);
      *(_QWORD *)(a1 + 64) = 0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      processUserActivityMsg_cold_2(a1, v28, v29, v30, v31, v32, v33, v34);
    }
  }
}

void __processUserActivityMsg_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  _Block_release(*(const void **)(a1 + 32));
}

BOOL __processUserActivityMsg_block_invoke_2(uint64_t a1)
{
  return sendUserActivityMsg(*(_QWORD *)(a1 + 32), "userActivityRegister");
}

uint64_t IOPMSetUserActivityIdleTimeout(uint64_t a1, int a2)
{
  NSObject *PMQueue;
  uint64_t v5;
  _QWORD block[6];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = -536870199;
  PMQueue = getPMQueue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOPMSetUserActivityIdleTimeout_block_invoke;
  block[3] = &unk_1E2002080;
  block[4] = &v9;
  block[5] = a1;
  v8 = a2;
  dispatch_sync(PMQueue, block);
  v5 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v5;
}

int *IOPMScheduleUserActivityLevelNotification(NSObject *a1, uint64_t a2)
{
  int *v4;
  int *v5;
  _QWORD v7[6];

  v4 = (int *)malloc_type_calloc(1uLL, 0x48uLL, 0x10A00403A6C22E7uLL);
  v5 = v4;
  if (v4)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __IOPMScheduleUserActivityLevelNotification_block_invoke;
    v7[3] = &unk_1E20020A8;
    v7[4] = a2;
    v7[5] = v4;
    if (notify_register_dispatch("com.apple.system.powermanagement.useractivity2", v4 + 10, a1, v7))
    {
      free(v5);
      return 0;
    }
  }
  return v5;
}

__CFString *IOPMCopyUserActivityLevelDescription(uint64_t a1)
{
  __CFString *Mutable;
  __CFString *v3;
  const __CFString *v4;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = Mutable;
  if (!a1)
  {
    v4 = CFSTR("Inactive");
LABEL_22:
    CFStringAppend(v3, v4);
    return v3;
  }
  if ((a1 & 1) != 0)
  {
    CFStringAppend(Mutable, CFSTR("PresentActive"));
    if ((a1 & 2) == 0)
    {
      if ((a1 & 0x10) != 0)
      {
LABEL_16:
        CFStringAppend(v3, CFSTR(" "));
LABEL_17:
        CFStringAppend(v3, CFSTR("RemoteActive"));
        if ((a1 & 0x20) != 0)
          goto LABEL_18;
        goto LABEL_12;
      }
LABEL_11:
      if ((a1 & 0x20) != 0)
      {
LABEL_18:
        CFStringAppend(v3, CFSTR(" "));
        goto LABEL_19;
      }
LABEL_12:
      if ((a1 & 0x40) == 0)
        return v3;
      goto LABEL_20;
    }
    CFStringAppend(v3, CFSTR(" "));
LABEL_15:
    CFStringAppend(v3, CFSTR("PresentPassive"));
    if ((a1 & 0x10) != 0)
      goto LABEL_16;
    goto LABEL_11;
  }
  if ((a1 & 2) != 0)
    goto LABEL_15;
  if ((a1 & 0x10) != 0)
    goto LABEL_17;
  if ((a1 & 0x20) == 0)
  {
    if ((a1 & 0x40) == 0)
      return v3;
    goto LABEL_21;
  }
LABEL_19:
  CFStringAppend(v3, CFSTR("NotificationActive"));
  if ((a1 & 0x40) != 0)
  {
LABEL_20:
    CFStringAppend(v3, CFSTR(" "));
LABEL_21:
    v4 = CFSTR("AbsentWithDisplay");
    goto LABEL_22;
  }
  return v3;
}

uint64_t IOPMAllowRemotePowerChange(uint64_t a1, int a2)
{
  NSObject *PMQueue;
  uint64_t v5;
  _QWORD block[6];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  if (a1)
  {
    PMQueue = getPMQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __IOPMAllowRemotePowerChange_block_invoke;
    block[3] = &unk_1E20020D0;
    v8 = a2;
    block[4] = &v9;
    block[5] = a1;
    dispatch_sync(PMQueue, block);
    v5 = *((unsigned int *)v10 + 6);
  }
  else
  {
    v5 = 3758097090;
  }
  _Block_object_dispose(&v9, 8);
  return v5;
}

void _systemPowerCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  NSObject *v4;
  _QWORD v5[5];
  int v6;

  *(_DWORD *)(a1 + 40) = a3;
  *(_QWORD *)(a1 + 48) = a4;
  v4 = *(NSObject **)(a1 + 32);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___systemPowerCallback_block_invoke;
  v5[3] = &__block_descriptor_tmp_37;
  v5[4] = a1;
  v6 = a3;
  dispatch_async(v4, v5);
}

uint64_t ___systemPowerCallback_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 16))(**(_QWORD **)(a1 + 32), *(unsigned int *)(a1 + 40), 0);
}

io_object_t *IOPMRegisterForRemoteSystemPower(NSObject *a1, const void *a2)
{
  io_object_t *v4;
  IONotificationPortRef v5;
  IONotificationPort *v6;
  NSObject *PMQueue;
  const __CFDictionary *v8;
  io_service_t MatchingService;
  io_object_t v10;
  kern_return_t v12;

  if (!a1)
    return 0;
  v4 = (io_object_t *)malloc_type_calloc(1uLL, 0x38uLL, 0x10A0040A50803A1uLL);
  if (v4)
  {
    dispatch_retain(a1);
    *((_QWORD *)v4 + 4) = a1;
    *(_QWORD *)v4 = _Block_copy(a2);
    v5 = IONotificationPortCreate(0);
    *((_QWORD *)v4 + 2) = v5;
    if (v5)
    {
      v6 = v5;
      PMQueue = getPMQueue();
      IONotificationPortSetDispatchQueue(v6, PMQueue);
    }
    v8 = IOServiceMatching("AppleEmbeddedSleepWakeHandler");
    MatchingService = IOServiceGetMatchingService(0, v8);
    if (MatchingService)
    {
      v10 = MatchingService;
      if (IOServiceOpen(MatchingService, *MEMORY[0x1E0C83DA0], 0, v4 + 6) || !v4[6])
      {
        IOObjectRelease(v10);
      }
      else
      {
        v12 = IOServiceAddInterestNotification(*((IONotificationPortRef *)v4 + 2), v10, "IOGeneralInterest", (IOServiceInterestCallback)_systemPowerCallback, v4, v4 + 2);
        IOObjectRelease(v10);
        if (!v12)
          return v4;
      }
    }
    IODeregisterForRemoteSystemPower((uint64_t)v4);
    return 0;
  }
  return v4;
}

void IODeregisterForRemoteSystemPower(uint64_t a1)
{
  NSObject *PMQueue;
  _QWORD block[5];

  if (a1)
  {
    PMQueue = getPMQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __IODeregisterForRemoteSystemPower_block_invoke;
    block[3] = &__block_descriptor_tmp_40;
    block[4] = a1;
    dispatch_sync(PMQueue, block);
  }
}

uint64_t IOPMCopyHIDPostEventHistory(CFPropertyListRef *a1)
{
  uint64_t v2;
  const __CFData *v3;
  const __CFData *v4;
  uint64_t v6;
  mach_vm_size_t v7;
  const UInt8 *v8;

  v7 = 0;
  v8 = 0;
  v2 = 3758097084;
  v6 = 0;
  if (!_pm_connect((_DWORD *)&v6 + 1)
    && !io_pm_hid_event_copy_history(SHIDWORD(v6), &v8, &v7, &v6))
  {
    v3 = CFDataCreate(0, v8, v7);
    if (v3)
    {
      v4 = v3;
      *a1 = CFPropertyListCreateWithData(0, v3, 0, 0, 0);
      CFRelease(v4);
    }
    if (*a1)
      v2 = 0;
    else
      v2 = 3758097084;
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v8, v7);
  }
  return v2;
}

uint64_t IOPMGetLastWakeTime(double *a1, _QWORD *a2)
{
  uint64_t v2;
  size_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = 3758097090;
  v6 = 16;
  if (a1)
  {
    if (a2)
    {
      v7 = 0;
      v8 = 0;
      *a1 = 0.0;
      *a2 = 0;
      v2 = 3758097112;
      if (!sysctlbyname("kern.waketime", &v7, &v6, 0, 0))
      {
        if (v7)
        {
          v2 = 0;
          *a1 = (double)(int)v8 / 1000000.0 + (double)v7 - *MEMORY[0x1E0C9ADF8];
          *a2 = 0;
        }
      }
    }
  }
  return v2;
}

uint64_t IOPMCopyPowerHistory(CFMutableArrayRef *a1)
{
  uint64_t v2;
  CFMutableArrayRef Mutable;
  DIR *v4;
  DIR *v5;
  dirent *v6;
  int v7;
  const __CFAllocator *v8;
  const char *d_name;
  CFMutableDictionaryRef v10;
  char *v11;
  char *v12;
  int v13;
  CFStringRef v14;
  __CFDictionary *v15;
  const __CFString *v16;
  CFMutableDictionaryRef v17;
  CFMutableArrayRef v18;
  char *v20;
  __CFArray *theArray;
  CFMutableArrayRef *v22;
  char *__stringp;
  char *v24;

  v2 = 3758097084;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v4 = opendir("/System/Library/PowerEvents");
  if (!v4)
    return v2;
  v5 = v4;
  __stringp = 0;
  v24 = 0;
  v6 = readdir(v4);
  v7 = 0;
  if (!v6)
    goto LABEL_20;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  do
  {
    while (1)
    {
      d_name = v6->d_name;
      if (strcmp(v6->d_name, "."))
      {
        if (strcmp(d_name, ".."))
          break;
      }
      v6 = readdir(v5);
      if (!v6)
        goto LABEL_20;
    }
    theArray = Mutable;
    v22 = a1;
    v10 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v20 = strdup(d_name);
    __stringp = v20;
    v11 = strsep(&__stringp, "_");
    v24 = v11;
    if (v11)
    {
      v12 = v11;
      v13 = 1;
      while (1)
      {
        if (v13 == 3)
        {
          v24 = strsep(&v24, ".");
          v14 = CFStringCreateWithCString(v8, v24, 0x8000100u);
          v15 = v10;
          v16 = CFSTR("ClearTime");
          goto LABEL_16;
        }
        if (v13 == 2)
          break;
        if (v13 == 1)
        {
          v14 = CFStringCreateWithCString(v8, v12, 0x8000100u);
          v15 = v10;
          v16 = CFSTR("Timestamp");
LABEL_16:
          CFDictionarySetValue(v15, v16, v14);
          CFRelease(v14);
        }
        ++v13;
        v12 = strsep(&__stringp, "_");
        v24 = v12;
        if (!v12)
          goto LABEL_18;
      }
      v14 = CFStringCreateWithCString(v8, v12, 0x8000100u);
      v15 = v10;
      v16 = CFSTR("UUID");
      goto LABEL_16;
    }
LABEL_18:
    ++v7;
    CFArrayAppendValue(theArray, v10);
    v17 = v10;
    Mutable = theArray;
    CFRelease(v17);
    free(v20);
    v6 = readdir(v5);
    a1 = v22;
  }
  while (v6);
  v7 = 1;
LABEL_20:
  closedir(v5);
  if (v7)
    v18 = Mutable;
  else
    v18 = 0;
  if (v7)
    v2 = 0;
  else
    v2 = 3758097136;
  *a1 = v18;
  return v2;
}

uint64_t IOPMCopyPowerHistoryDetailed(const __CFString *a1, CFPropertyListRef *a2)
{
  const __CFAllocator *v4;
  CFMutableStringRef Mutable;
  uint64_t v6;
  DIR *v7;
  DIR *v8;
  dirent *v9;
  CFURLRef v10;
  const char *d_name;
  const __CFString *v12;
  int v13;
  SInt32 errorCode;
  CFDataRef resourceData;
  char buffer[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  resourceData = 0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 255);
  CFStringAppend(Mutable, CFSTR("/System/Library/PowerEvents"));
  CFStringAppend(Mutable, CFSTR("/"));
  v6 = 3758097090;
  if (!a1 || !a2)
    goto LABEL_20;
  *a2 = 0;
  if (!CFStringGetCString(a1, buffer, 128, 0))
  {
    v6 = 3758097090;
    goto LABEL_20;
  }
  v7 = opendir("/System/Library/PowerEvents");
  if (!v7)
  {
LABEL_19:
    v6 = 3758097084;
    goto LABEL_20;
  }
  v8 = v7;
  v9 = readdir(v7);
  if (!v9)
  {
    closedir(v8);
    goto LABEL_19;
  }
  v10 = 0;
  do
  {
    d_name = v9->d_name;
    if (strstr(v9->d_name, buffer))
    {
      v12 = CFStringCreateWithCString(v4, d_name, 0x8000100u);
      CFStringAppend(Mutable, v12);
      if (v10)
        CFRelease(v10);
      v10 = CFURLCreateWithFileSystemPath(v4, Mutable, kCFURLPOSIXPathStyle, 0);
      CFRelease(v12);
    }
    v9 = readdir(v8);
  }
  while (v9);
  closedir(v8);
  v6 = 3758097084;
  if (v10)
  {
    errorCode = 0;
    v13 = CFURLCreateDataAndPropertiesFromResource(v4, v10, &resourceData, 0, 0, &errorCode);
    if (resourceData && v13)
    {
      *a2 = CFPropertyListCreateWithData(0, resourceData, 0, 0, 0);
      CFRelease(resourceData);
    }
    CFRelease(v10);
    v6 = 0;
  }
LABEL_20:
  CFRelease(Mutable);
  return v6;
}

uint64_t IOPMSetSleepServicesWakeTimeCap(double a1)
{
  uint64_t result;
  unsigned int v3;
  int v4;

  v3 = -1;
  v4 = 0;
  result = _pm_connect(&v4);
  if (!(_DWORD)result)
  {
    LODWORD(result) = io_pm_set_sleepservice_wake_time_cap(v4, (int)a1, &v3);
    if (v3)
      return v3;
    else
      return result;
  }
  return result;
}

uint64_t IOPMSleepWakeSetUUID(const void *a1)
{
  uint64_t result;
  io_object_t v3;
  const void *v4;
  uint64_t v5;

  result = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if ((_DWORD)result)
  {
    v3 = result;
    if (a1)
      v4 = a1;
    else
      v4 = (const void *)*MEMORY[0x1E0C9AE40];
    v5 = IORegistryEntrySetCFProperty(result, CFSTR("SleepWakeUUID"), v4);
    IOObjectRelease(v3);
    return v5;
  }
  return result;
}

CFTypeRef IOPMSleepWakeCopyUUID()
{
  io_registry_entry_t v0;
  io_object_t v1;
  CFTypeRef CFProperty;

  v0 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v0)
    return 0;
  v1 = v0;
  CFProperty = IORegistryEntryCreateCFProperty(v0, CFSTR("SleepWakeUUID"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  IOObjectRelease(v1);
  return CFProperty;
}

BOOL IOPMGetUUID(int a1, char *a2, int a3)
{
  const __CFString *v5;
  _BOOL8 v6;
  int CString;
  int uuid;
  int v10;
  int v11;
  char __src[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1 != 1001)
  {
    if (a1 == 1000)
    {
      v5 = (const __CFString *)IOPMSleepWakeCopyUUID();
      v6 = (_BOOL8)v5;
      if (v5)
      {
        CString = CFStringGetCString(v5, a2, a3, 0x8000100u);
        CFRelease((CFTypeRef)v6);
        return CString != 0;
      }
      return v6;
    }
    return 0;
  }
  v10 = -1;
  v11 = 0;
  if (_pm_connect(&v11))
    return 0;
  bzero(__src, 0x400uLL);
  uuid = io_pm_get_uuid(v11, 1001, __src, &v10);
  v6 = (uuid | v10) == 0;
  if (!(uuid | v10))
  {
    bzero(a2, a3);
    strncpy(a2, __src, a3 - 1);
  }
  return v6;
}

uint64_t IOPMLogWakeProgress(int a1, int a2)
{
  uint64_t v3;
  const __CFString *v4;
  io_registry_entry_t v5;
  io_registry_entry_t v6;
  CFNumberRef v7;
  CFNumberRef v8;
  int valuePtr;

  valuePtr = a2;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    IOPMLogWakeProgress_cold_1();
  v3 = 3758097084;
  if ((a1 - 1) > 2)
    return 3758097090;
  v4 = off_1E20024D0[a1 - 1];
  v5 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (v5)
  {
    v6 = v5;
    v7 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (v7)
    {
      v8 = v7;
      v3 = IORegistryEntrySetCFProperty(v6, v4, v7);
      CFRelease(v8);
    }
    IOObjectRelease(v6);
  }
  return v3;
}

uint64_t (*IOPMCopySleepWakeFailure())(uint64_t, uint64_t)
{
  uint64_t (*v0)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v1)(uint64_t, uint64_t, uint64_t, uint64_t);
  CFStringRef v2;
  CFStringRef v3;
  uint64_t (*v4)(uint64_t, uint64_t);
  CFTypeID TypeID;

  v0 = _io_SCDynamicStoreCreate(0, (uint64_t)CFSTR("IOPMSleepFailure"), 0, 0);
  if (!v0)
    return 0;
  v1 = v0;
  v2 = _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("%@%@/%@"), CFSTR("State:"), CFSTR("PowerManagement"), CFSTR("SleepFailure"));
  if (v2)
  {
    v3 = v2;
    v4 = _io_SCDynamicStoreCopyValue((uint64_t)v1, (uint64_t)v2);
    if (v4)
    {
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v4) != TypeID)
      {
        CFRelease(v4);
        v4 = 0;
      }
    }
    CFRelease(v1);
  }
  else
  {
    v4 = 0;
    v3 = (CFStringRef)v1;
  }
  CFRelease(v3);
  return v4;
}

void IOPMClaimSystemWakeEvent(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  NSObject *global_queue;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v8;
  xpc_object_t v9;
  void *v10;
  void *v11;
  xpc_object_t v12;
  void *v13;
  char buffer[255];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  global_queue = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (mach_service)
  {
    v8 = mach_service;
    xpc_connection_set_target_queue(mach_service, global_queue);
    xpc_connection_set_event_handler(v8, &__block_literal_global_74);
    v9 = xpc_dictionary_create(0, 0, 0);
    if (v9)
    {
      if (a1)
      {
        CFStringGetCString(a1, buffer, 255, 0x8000100u);
        xpc_dictionary_set_string(v9, "identity", buffer);
      }
      if (a2)
      {
        CFStringGetCString(a2, buffer, 255, 0x8000100u);
        xpc_dictionary_set_string(v9, "reason", buffer);
      }
      if (a3)
      {
        v10 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v10)
        {
          v11 = v10;
          xpc_dictionary_set_value(v9, "description", v10);
          xpc_release(v11);
        }
      }
    }
    v12 = xpc_dictionary_create(0, 0, 0);
    if (v12)
    {
      v13 = v12;
      xpc_dictionary_set_value(v12, "claimSystemWakeEvent", v9);
      xpc_connection_resume(v8);
      xpc_connection_send_message(v8, v13);
      xpc_release(v13);
    }
    if (v9)
      xpc_release(v9);
    xpc_release(v8);
  }
}

uint64_t IOPMSetActivePushConnectionState(int a1)
{
  return IOPMSetValueInt(11, a1);
}

uint64_t IOPMSetValueInt(int a1, int a2)
{
  unsigned int v5;
  int v6;

  v5 = -536870212;
  v6 = 0;
  if (_pm_connect(&v6))
    return 3758097112;
  io_pm_set_value_int(v6, a1, a2, &v5);
  return v5;
}

uint64_t IOPMGetActivePushConnectionState(BOOL *a1)
{
  int v2;
  uint64_t result;

  if (!a1)
    return 3758097090;
  v2 = IOPMGetValueInt(11);
  result = 0;
  *a1 = v2 != 0;
  return result;
}

uint64_t IOPMGetValueInt(int a1)
{
  int v2;
  uint64_t result;
  uint64_t v4;

  v4 = 0;
  v2 = _pm_connect((_DWORD *)&v4 + 1);
  result = 0;
  if (!v2)
  {
    if (io_pm_get_value_int(SHIDWORD(v4), a1, &v4))
      return 0;
    else
      return v4;
  }
  return result;
}

uint64_t IOPMConnectionSetNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = 3758097090;
  if (a1)
  {
    if (a3)
    {
      result = 0;
      *(_QWORD *)(a1 + 56) = a3;
      *(_QWORD *)(a1 + 64) = a2;
    }
  }
  return result;
}

uint64_t IOPMConnectionScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *PMQueue;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = -536870212;
  v3 = 3758097090;
  if (a1 && a2 && a3)
  {
    PMQueue = getPMQueue();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __IOPMConnectionScheduleWithRunLoop_block_invoke;
    v9[3] = &unk_1E2002178;
    v9[4] = &v10;
    v9[5] = a1;
    v9[6] = a2;
    v9[7] = a3;
    dispatch_sync(PMQueue, v9);
    v3 = *((unsigned int *)v11 + 6);
  }
  _Block_object_dispose(&v10, 8);
  return v3;
}

uint64_t iopm_mach_port_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(_QWORD, uint64_t, _QWORD, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(a4 + 56);
    if (v4)
      return v4(*(_QWORD *)(a4 + 64), a4, *(unsigned int *)(a2 + 32), *(unsigned int *)(a2 + 28));
  }
  return result;
}

uint64_t _conveyMachPortToPowerd(int *a1, int a2, int a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v10;
  uint64_t v11;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v6 = 0;
  if (!_pm_connect((_DWORD *)&v11 + 1))
  {
    v7 = io_pm_connection_schedule_notification(SHIDWORD(v11), *a1, a2, a3 ^ 1u, (int *)&v11);
    if (v7)
    {
      v8 = v7;
      v6 = 3758097097;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        _conveyMachPortToPowerd_cold_1(a1, v8);
    }
    else
    {
      v6 = v11;
      if ((_DWORD)v11 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v10 = *a1;
        *(_DWORD *)buf = 67109376;
        v13 = v10;
        v14 = 1024;
        v15 = v6;
        _os_log_error_impl(&dword_18AAAF000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to update machport for IOPMConnection id 0x%x. rc:0x%x\n", buf, 0xEu);
        return v11;
      }
    }
  }
  return v6;
}

uint64_t IOPMConnectionUnscheduleFromRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *PMQueue;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v3 = 3758097090;
  if (a1 && a2 && a3)
  {
    PMQueue = getPMQueue();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __IOPMConnectionUnscheduleFromRunLoop_block_invoke;
    v9[3] = &unk_1E20021A0;
    v9[6] = a2;
    v9[7] = a3;
    v9[4] = &v10;
    v9[5] = a1;
    dispatch_sync(PMQueue, v9);
    v3 = *((unsigned int *)v11 + 6);
  }
  _Block_object_dispose(&v10, 8);
  return v3;
}

void setDispatchQueue(uint64_t a1, NSObject *a2)
{
  ipc_space_t *v4;
  mach_port_name_t *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD v10[5];
  _QWORD handler[5];
  int v12;

  if (a2)
  {
    v4 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    v5 = (mach_port_name_t *)(a1 + 24);
    if (!mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, (mach_port_name_t *)(a1 + 24)))
    {
      mach_port_insert_right(*v4, *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 24), 0x14u);
      v6 = dispatch_source_create(MEMORY[0x1E0C80D98], *(unsigned int *)(a1 + 24), 0, a2);
      *(_QWORD *)(a1 + 32) = v6;
      if (v6)
      {
        v7 = *(_DWORD *)(a1 + 24);
        v8 = MEMORY[0x1E0C809B0];
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 0x40000000;
        handler[2] = __setDispatchQueue_block_invoke;
        handler[3] = &__block_descriptor_tmp_81;
        handler[4] = v6;
        v12 = v7;
        dispatch_source_set_cancel_handler(v6, handler);
        v9 = *(NSObject **)(a1 + 32);
        v10[0] = v8;
        v10[1] = 0x40000000;
        v10[2] = __setDispatchQueue_block_invoke_2;
        v10[3] = &__block_descriptor_tmp_82;
        v10[4] = a1;
        dispatch_source_set_event_handler(v9, v10);
        dispatch_resume(*(dispatch_object_t *)(a1 + 32));
        _conveyMachPortToPowerd((int *)a1, *(_DWORD *)(a1 + 24), 1);
      }
      else
      {
        mach_port_deallocate(*v4, *v5);
        mach_port_mod_refs(*v4, *v5, 1u, -1);
        *v5 = 0;
      }
    }
  }
  else if (*(_QWORD *)(a1 + 32))
  {
    _conveyMachPortToPowerd((int *)a1, *(_DWORD *)(a1 + 24), 0);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
  }
}

uint64_t __setDispatchQueue_block_invoke(uint64_t a1)
{
  ipc_space_t *v2;

  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  v2 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  mach_port_mod_refs(*MEMORY[0x1E0C83DA0], *(_DWORD *)(a1 + 40), 1u, -1);
  return mach_port_deallocate(*v2, *(_DWORD *)(a1 + 40));
}

uint64_t __setDispatchQueue_block_invoke_2(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t (*v4)(_QWORD, uint64_t, _QWORD, _QWORD);
  BOOL v5;
  mach_msg_header_t v6[2];

  memset(v6, 0, 44);
  result = mach_msg(v6, 258, 0, 0x2Cu, *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24), 0, 0);
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    v4 = *(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(v3 + 56);
    if (v4)
      v5 = (_DWORD)result == 0;
    else
      v5 = 0;
    if (v5)
      return v4(*(_QWORD *)(v3 + 64), v3, v6[1].msgh_remote_port, v6[1].msgh_size);
  }
  return result;
}

void IOPMConnectionSetDispatchQueue(uint64_t a1, NSObject *a2)
{
  if (a1)
    setDispatchQueue(a1, a2);
}

uint64_t IOPMConnectionCreate(const __CFString *a1, int a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *PMQueue;
  _QWORD v9[7];
  int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;

  v3 = 3758097090;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = -536870212;
  if (a1 && a2 && a3 && CFStringGetLength(a1) <= 128)
  {
    PMQueue = getPMQueue();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __IOPMConnectionCreate_block_invoke;
    v9[3] = &unk_1E2002228;
    v9[4] = &v11;
    v9[5] = a3;
    v9[6] = a1;
    v10 = a2;
    dispatch_sync(PMQueue, v9);
    v3 = *((unsigned int *)v12 + 6);
  }
  _Block_object_dispose(&v11, 8);
  return v3;
}

uint64_t _connectionCreate(uint64_t a1)
{
  int v2;
  int v4;
  unsigned int v5;
  mach_port_name_t v6;
  uint8_t buf[4];
  int v8;
  char buffer[128];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v4 = 0;
  v5 = _pm_connect(&v6);
  if (!v5)
  {
    CFStringGetCString(*(CFStringRef *)(a1 + 8), buffer, 128, 0);
    if (io_pm_connection_create(v6, buffer, *(_DWORD *)(a1 + 16), &v4, &v5))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        _connectionCreate_cold_2();
      return -536870199;
    }
    else if (v5)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        _connectionCreate_cold_1();
    }
    else
    {
      v2 = v4;
      *(_DWORD *)a1 = v4;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109120;
        v8 = v2;
        _os_log_impl(&dword_18AAAF000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "Created IOPMConnection with id 0x%x\n", buf, 8u);
      }
    }
  }
  return v5;
}

uint64_t IOPMConnectionRelease(uint64_t a1)
{
  NSObject *PMQueue;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = -536870212;
  PMQueue = getPMQueue();
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __IOPMConnectionRelease_block_invoke;
  v5[3] = &unk_1E2002250;
  v5[4] = &v6;
  v5[5] = a1;
  dispatch_sync(PMQueue, v5);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t IOPMConnectionAcknowledgeEvent()
{
  return 3758097095;
}

uint64_t IOPMConnectionAcknowledgeEventWithOptions()
{
  return 3758097095;
}

uint64_t IOPMCopyConnectionStatus(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  int v4;

  v4 = 0;
  result = _pm_connect(&v4);
  if ((_DWORD)result)
    return 3758097097;
  *a2 = 0;
  return result;
}

uint64_t IOPMConnectionGetSystemCapabilities()
{
  uint64_t v0;
  int v2;
  unsigned int v3;
  int v4;

  v0 = 31;
  v3 = 31;
  v4 = 0;
  v2 = _pm_connect(&v4);
  if (v4)
  {
    io_pm_get_capability_bits(v4, &v3, &v2);
    return v3;
  }
  return v0;
}

BOOL IOPMIsADarkWake(char a1)
{
  return (a1 & 3) == 1;
}

uint64_t IOPMAllowsPushServiceTask(unsigned int a1)
{
  return (a1 >> 5) & 1;
}

uint64_t IOPMIsASilentWake(unsigned int a1)
{
  return (a1 >> 7) & 1;
}

uint64_t IOPMIsAUserWake(unsigned int a1)
{
  return (a1 >> 1) & 1;
}

BOOL IOPMIsASleep(char a1)
{
  return (a1 & 1) == 0;
}

BOOL IOPMGetCapabilitiesDescription(char *a1, int a2, char a3)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;

  if ((a3 & 1) != 0)
  {
    if ((a3 & 3) == 1)
    {
      v3 = "DarkWake";
    }
    else
    {
      v3 = "FullWake";
      if ((a3 & 2) == 0)
        v3 = "Unknown";
    }
  }
  else
  {
    v3 = "Sleep";
  }
  v4 = "cpu ";
  if ((a3 & 1) == 0)
    v4 = "<off> ";
  v5 = "disk ";
  if ((a3 & 0x10) == 0)
    v5 = "";
  v6 = "net ";
  if ((a3 & 8) == 0)
    v6 = "";
  v7 = "aud ";
  if ((a3 & 4) == 0)
    v7 = "";
  v8 = "vid ";
  if ((a3 & 2) == 0)
    v8 = "";
  v9 = "push ";
  if ((a3 & 0x20) == 0)
    v9 = "";
  if ((a3 & 0x40) != 0)
    v10 = "bg ";
  else
    v10 = "";
  return snprintf(a1, a2, "%s:%s%s%s%s%s%s%s", v3, v4, v5, v6, v7, v8, v9, v10) <= a2;
}

uint64_t IOPMGetSleepServicesActive()
{
  uint32_t v0;
  uint64_t result;
  uint64_t v2;
  int out_token;

  out_token = 0;
  v2 = 0;
  v0 = notify_register_check("com.apple.powermanagement.sleepservices", &out_token);
  result = 0;
  if (!v0)
  {
    notify_get_state(out_token, &v2);
    notify_cancel(out_token);
    return v2 & 1;
  }
  return result;
}

uint64_t IOPMGetDarkWakeThermalEmergencyCount()
{
  return IOPMGetValueInt(4);
}

uint64_t IOPMSetDebugFlags(int a1, _DWORD *a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = _pm_connect(&v7);
  if (!v7)
    return 3758097112;
  v4 = io_pm_set_debug_flags(v7, a1, 2, (_DWORD *)&v6 + 1, &v6);
  result = v6;
  if (!(v4 | v6))
  {
    result = 0;
    if (a2)
      *a2 = HIDWORD(v6);
  }
  return result;
}

uint64_t IOPMSetBTWakeInterval()
{
  return 0;
}

uint64_t IOPMSetDWLingerInterval()
{
  return 0;
}

uint64_t IOPMChangeSystemActivityAssertionBehavior(int a1, _DWORD *a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = _pm_connect(&v7);
  if (!v7)
    return 3758097112;
  v4 = io_pm_change_sa_assertion_behavior(v7, a1, (_DWORD *)&v6 + 1, &v6);
  result = v6;
  if (!(v4 | v6))
  {
    result = 0;
    if (HIDWORD(v6))
      *a2 = HIDWORD(v6);
  }
  return result;
}

uint64_t IOPMCtlAssertionType(const char *a1, int a2)
{
  int v4;
  unsigned int v6;
  mach_port_name_t v7;

  v7 = 0;
  v6 = _pm_connect(&v7);
  if (!v7)
    return 3758097112;
  v4 = io_pm_ctl_assertion_type(v7, a1, a2, &v6);
  if (v4 | v6)
    return v6;
  else
    return 0;
}

uint64_t IOPMCopyPowerStateInfo(__int16 a1)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  int valuePtr;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return -536870211;
  v3 = Mutable;
  valuePtr = a1 & 0xF;
  v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (v4)
  {
    v5 = v4;
    CFDictionarySetValue(v3, CFSTR("CurrentState"), v4);
    CFRelease(v5);
  }
  valuePtr = a1 >> 4;
  v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (v6)
  {
    v7 = v6;
    CFDictionarySetValue(v3, CFSTR("MaxState"), v6);
    CFRelease(v7);
  }
  v8 = (const void *)*MEMORY[0x1E0C9AE40];
  v9 = (const void *)*MEMORY[0x1E0C9AE50];
  if ((a1 & 0x100) != 0)
    v10 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v10 = (const void *)*MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(v3, CFSTR("IsPowerOn"), v10);
  if ((a1 & 0x200) != 0)
    v11 = v9;
  else
    v11 = v8;
  CFDictionarySetValue(v3, CFSTR("IsDeviceUsable"), v11);
  if ((a1 & 0x400) != 0)
    v12 = v9;
  else
    v12 = v8;
  CFDictionarySetValue(v3, CFSTR("IsLowPower"), v12);
  return (uint64_t)v3;
}

uint64_t IOPMAssertionNotify(const char *a1, int a2)
{
  int v4;
  unsigned int v6;
  mach_port_name_t v7;

  v7 = 0;
  v6 = _pm_connect(&v7);
  if (!v7)
    return 3758097112;
  v4 = io_pm_assertion_notify(v7, a1, a2, &v6);
  if (v4 | v6)
    return v6;
  else
    return 0;
}

uint64_t _copySleepPreventersList(const __CFString *a1, _QWORD *a2)
{
  io_registry_entry_t v4;
  io_object_t v5;
  CFTypeRef CFProperty;
  uint64_t result;

  v4 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v4)
    return 3758097097;
  v5 = v4;
  CFProperty = IORegistryEntryCreateCFProperty(v4, a1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  IOObjectRelease(v5);
  result = 0;
  *a2 = CFProperty;
  return result;
}

uint64_t IOPMCopySleepPreventersList(int a1, _QWORD *a2)
{
  const __CFString *v2;

  if (a2)
  {
    if (!a1)
    {
      v2 = CFSTR("IdleSleepPreventers");
      return _copySleepPreventersList(v2, a2);
    }
    if (a1 == 1)
    {
      v2 = CFSTR("SystemSleepPreventers");
      return _copySleepPreventersList(v2, a2);
    }
  }
  return 3758097090;
}

uint64_t IOPMCopySleepPreventersListWithID(int a1, _QWORD *a2)
{
  const __CFString *v2;

  if (a2)
  {
    if (!a1)
    {
      v2 = CFSTR("IdleSleepPreventersWithID");
      return _copySleepPreventersList(v2, a2);
    }
    if (a1 == 1)
    {
      v2 = CFSTR("SystemSleepPreventersWithID");
      return _copySleepPreventersList(v2, a2);
    }
  }
  return 3758097090;
}

uint64_t IOPMCopyBatteryHeatMap(int a1, uint64_t a2, uint64_t a3)
{
  return copyBatteryData("batteryHeatMapData", a1, a2, a3);
}

uint64_t copyBatteryData(const char *a1, int a2, uint64_t a3, uint64_t a4)
{
  _xpc_connection_s *mach_service;
  uint64_t v9;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  xpc_object_t v18;
  void *v19;
  NSObject *PMQueue;
  _BOOL8 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v30[8];

  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E0C80D38], 0);
  if (mach_service)
  {
    v9 = 0;
  }
  else
  {
    v9 = 3758097084;
    v10 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v10)
      IOPSGaugingMitigationGetState_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  xpc_connection_set_target_queue(mach_service, MEMORY[0x1E0C80D38]);
  xpc_connection_set_event_handler(mach_service, &__block_literal_global_150);
  xpc_connection_resume(mach_service);
  v18 = xpc_dictionary_create(0, 0, 0);
  if (v18)
  {
    v19 = v18;
    xpc_dictionary_set_uint64(v18, a1, a2);
    PMQueue = getPMQueue();
    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 0x40000000;
    v30[2] = __copyBatteryData_block_invoke_151;
    v30[3] = &unk_1E20024B0;
    v30[4] = a4;
    v30[5] = a3;
    v30[6] = a1;
    v30[7] = mach_service;
    xpc_connection_send_message_with_reply(mach_service, v19, PMQueue, v30);
    xpc_release(v19);
    if (!mach_service)
      return v9;
    goto LABEL_10;
  }
  v9 = 3758097084;
  v21 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
  if (v21)
  {
    copyBatteryData_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
    if (!mach_service)
      return v9;
    goto LABEL_10;
  }
  if (mach_service)
LABEL_10:
    xpc_release(mach_service);
  return v9;
}

uint64_t IOPMCopyCycleCountData(uint64_t a1, uint64_t a2)
{
  return copyBatteryData("batteryCycleCountData", 0, a1, a2);
}

uint64_t IOPMCopyKioskModeData(uint64_t a1, uint64_t a2)
{
  return copyBatteryData("batteryKioskModeData", 0, a1, a2);
}

uint64_t IOPMCopyCurrentScheduledWake(uint64_t a1, uint64_t a2)
{
  _xpc_connection_s *mach_service;
  uint64_t v5;
  _BOOL8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *PMQueue;
  xpc_object_t v15;
  void *v16;
  NSObject *v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD handler[7];

  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E0C80D38], 0);
  if (mach_service)
  {
    v5 = 0;
  }
  else
  {
    v5 = 3758097084;
    v6 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v6)
      IOPSGaugingMitigationGetState_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  PMQueue = getPMQueue();
  xpc_connection_set_target_queue(mach_service, PMQueue);
  xpc_connection_set_event_handler(mach_service, &__block_literal_global_124);
  xpc_connection_resume(mach_service);
  v15 = xpc_dictionary_create(0, 0, 0);
  if (v15)
  {
    v16 = v15;
    xpc_dictionary_set_uint64(v15, "wakeData", 0);
    v17 = getPMQueue();
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = __IOPMCopyCurrentScheduledWake_block_invoke_126;
    handler[3] = &unk_1E20022E0;
    handler[4] = a2;
    handler[5] = a1;
    handler[6] = mach_service;
    xpc_connection_send_message_with_reply(mach_service, v16, v17, handler);
    xpc_release(v16);
    if (!mach_service)
      return v5;
    goto LABEL_10;
  }
  v5 = 3758097084;
  v18 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
  if (v18)
  {
    copyBatteryData_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
    if (!mach_service)
      return v5;
    goto LABEL_10;
  }
  if (mach_service)
LABEL_10:
    xpc_release(mach_service);
  return v5;
}

uint64_t IOPMSetDesktopMode(BOOL a1)
{
  return IOPMSetDesktopModeWithOptions(a1, 0);
}

uint64_t IOPMSetDesktopModeWithOptions(BOOL a1, const __CFDictionary *a2)
{
  NSObject *global_queue;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;
  BOOL v9;

  global_queue = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service)
    return 3758097084;
  v6 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v6, &__block_literal_global_130);
  v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    v8 = v7;
    xpc_dictionary_set_BOOL(v7, "DesktopMode", a1);
    if (a2)
    {
      if (CFDictionaryContainsKey(a2, CFSTR("DesktopModeAppliesOnBatteryPower")))
      {
        v9 = CFDictionaryGetValue(a2, CFSTR("DesktopModeAppliesOnBatteryPower")) != 0;
        xpc_dictionary_set_BOOL(v8, "DesktopModeAppliesOnBatteryPower", v9);
      }
    }
    xpc_connection_resume(v6);
    xpc_connection_send_message(v6, v8);
    xpc_release(v8);
  }
  xpc_release(v6);
  return 0;
}

uint64_t IOPMSkylightCheckInWithCapability(BOOL a1, uint64_t a2)
{
  NSObject *global_queue;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;

  global_queue = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service)
    return 3758097084;
  v6 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v6, &__block_literal_global_136);
  v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    v8 = v7;
    xpc_dictionary_set_BOOL(v7, "SLCheckIn", a1);
    xpc_dictionary_set_uint64(v8, "SLCheckInCapability", a2);
    xpc_connection_resume(v6);
    xpc_connection_send_message(v6, v8);
    xpc_release(v8);
  }
  xpc_release(v6);
  return 0;
}

uint64_t IOPMSkylightCheckIn(BOOL a1)
{
  return IOPMSkylightCheckInWithCapability(a1, 1uLL);
}

uint64_t IOPMSetSystemAssertionTimeout(unsigned int a1)
{
  NSObject *global_queue;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v4;
  xpc_object_t v5;
  void *v6;

  global_queue = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service)
    return 3758097084;
  v4 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v4, &__block_literal_global_140);
  v5 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    v6 = v5;
    xpc_dictionary_set_uint64(v5, "systemAssertionTimeout", a1);
    xpc_connection_resume(v4);
    xpc_connection_send_message(v4, v6);
    xpc_release(v6);
  }
  xpc_release(v4);
  return 0;
}

uint64_t IOPMUpdateDominoState(BOOL a1, BOOL a2)
{
  NSObject *global_queue;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v6;
  xpc_object_t v7;
  void *v8;

  global_queue = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service)
    return 3758097084;
  v6 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v6, &__block_literal_global_143);
  v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    v8 = v7;
    xpc_dictionary_set_BOOL(v7, "dominoState", a1);
    xpc_dictionary_set_BOOL(v8, "dominoMainDisplay", a2);
    xpc_connection_resume(v6);
    xpc_connection_send_message(v6, v8);
    xpc_release(v8);
  }
  xpc_release(v6);
  return 0;
}

uint64_t IOPMUpdateOnenessState(BOOL a1)
{
  NSObject *global_queue;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v4;
  xpc_object_t v5;
  void *v6;

  global_queue = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service)
    return 3758097084;
  v4 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v4, &__block_literal_global_147);
  v5 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    v6 = v5;
    xpc_dictionary_set_BOOL(v5, "onenessState", a1);
    xpc_connection_resume(v4);
    xpc_connection_send_message(v4, v6);
    xpc_release(v6);
  }
  xpc_release(v4);
  return 0;
}

void _reset_connection()
{
  powerd_connection = 0;
  lock = 0;
}

void __copyBatteryData_block_invoke_151(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD v12[6];

  if (MEMORY[0x18D773128](a2) == MEMORY[0x1E0C812F8])
  {
    v10 = _CFXPCCreateCFObjectFromXPCObject();
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __copyBatteryData_block_invoke_2;
    v12[3] = &unk_1E2002488;
    v11 = *(NSObject **)(a1 + 40);
    v12[4] = *(_QWORD *)(a1 + 32);
    v12[5] = v10;
    dispatch_async(v11, v12);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    __copyBatteryData_block_invoke_151_cold_1(a1, v3, v4, v5, v6, v7, v8, v9);
  }
  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 56));
}

uint64_t __copyBatteryData_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t IOAVControlInterfaceGetTypeID()
{
  uint64_t result;

  result = __kIOAVControlInterfaceTypeID;
  if (!__kIOAVControlInterfaceTypeID)
  {
    pthread_once(&__interfaceTypeInit, (void (*)(void))__IOAVControlInterfaceRegister);
    return __kIOAVControlInterfaceTypeID;
  }
  return result;
}

uint64_t __IOAVControlInterfaceRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOAVControlInterfaceTypeID = result;
  return result;
}

uint64_t IOAVControlInterfaceCreate(uint64_t a1)
{
  if (*MEMORY[0x1E0C9AE00] == a1)
    return __IOAVCopyFirstMatchingIOAVObjectOfType((uint64_t)"IOAVControlInterface", (uint64_t (*)(_QWORD, uint64_t))IOAVControlInterfaceCreateWithService, 0, 2u, -1);
  else
    return 0;
}

io_connect_t *IOAVControlInterfaceCreateWithService(uint64_t a1, io_registry_entry_t a2)
{
  io_connect_t *Instance;
  io_connect_t *v4;
  io_service_t *v5;
  io_connect_t *CFProperty;
  io_connect_t *v7;

  if (!a2 || !IOAVObjectConformsTo(a2, (uint64_t)"IOAVControlInterface"))
    return 0;
  if (!__kIOAVControlInterfaceTypeID)
    pthread_once(&__interfaceTypeInit, (void (*)(void))__IOAVControlInterfaceRegister);
  Instance = (io_connect_t *)_CFRuntimeCreateInstance();
  v4 = Instance;
  if (Instance)
  {
    *((_QWORD *)Instance + 2) = 0;
    *((_QWORD *)Instance + 3) = 0;
    v5 = Instance + 4;
    *((_QWORD *)Instance + 4) = 0;
    Instance[4] = a2;
    IOObjectRetain(a2);
    if (IOServiceOpen(*v5, *MEMORY[0x1E0C83DA0], 0, v4 + 5))
    {
      v7 = v4;
      v4 = 0;
LABEL_10:
      CFRelease(v7);
      return v4;
    }
    CFProperty = (io_connect_t *)IORegistryEntryCreateCFProperty(*v5, CFSTR("Location"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (CFProperty)
    {
      v7 = CFProperty;
      if (CFEqual(CFProperty, CFSTR("Embedded")))
        v4[6] = 1;
      goto LABEL_10;
    }
  }
  return v4;
}

CFTypeRef IOAVControlInterfaceCopyProperty(uint64_t a1, const __CFString *a2)
{
  return IORegistryEntryCreateCFProperty(*(_DWORD *)(a1 + 16), a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
}

io_connect_t *IOAVControlInterfaceGetService(uint64_t a1)
{
  io_connect_t *result;
  io_registry_entry_t parent;

  result = *(io_connect_t **)(a1 + 32);
  if (!result)
  {
    parent = 0;
    if (IORegistryEntryGetParentEntry(*(_DWORD *)(a1 + 16), "IOService", &parent))
    {
      result = IOAVServiceCreateWithService(*MEMORY[0x1E0C9AE00], parent);
      *(_QWORD *)(a1 + 32) = result;
    }
    else
    {
      return *(io_connect_t **)(a1 + 32);
    }
  }
  return result;
}

uint64_t IOAVControlInterfaceSetLogLevel(uint64_t a1, unsigned int a2)
{
  mach_port_t v2;
  uint64_t input[2];

  input[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)(a1 + 20);
  input[0] = a2;
  return IOConnectCallMethod(v2, 0, input, 1u, 0, 0, 0, 0, 0, 0);
}

uint64_t IOAVControlInterfaceSetLogLevelMask(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t input[3];

  input[2] = *MEMORY[0x1E0C80C00];
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallMethod(*(_DWORD *)(a1 + 20), 1u, input, 2u, 0, 0, 0, 0, 0, 0);
}

CFArrayRef IOAVControlInterfaceCopyProperties(uint64_t a1)
{
  const __CFAllocator *v1;
  CFArrayRef v2;
  CFMutableDictionaryRef properties;

  properties = 0;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (IORegistryEntryCreateCFProperties(*(_DWORD *)(a1 + 16), &properties, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0))
    return 0;
  v2 = IOAVPropertyListCreateWithCFProperties(v1, properties);
  CFRelease(properties);
  return v2;
}

uint64_t IOAVControlInterfaceSetProperty(uint64_t a1, const __CFString *a2, const void *a3)
{
  return IORegistryEntrySetCFProperty(*(_DWORD *)(a1 + 16), a2, a3);
}

uint64_t IOAVControlInterfaceGetLocation(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t IOAVControlInterfaceCopyDiagnosticsString()
{
  return 0;
}

void __IOAVControlInterfaceFree(uint64_t a1)
{
  io_connect_t v2;
  io_object_t v3;
  const void *v4;

  v2 = *(_DWORD *)(a1 + 20);
  if (v2)
    IOServiceClose(v2);
  v3 = *(_DWORD *)(a1 + 16);
  if (v3)
    IOObjectRelease(v3);
  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
}

uint64_t (*_io_SCDynamicStoreAddWatchedKey(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreAddWatchedKey_dyfunc;
  if (_io_SCDynamicStoreAddWatchedKey_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreAddWatchedKey");
  v6 = result;
  _io_SCDynamicStoreAddWatchedKey_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

void *symAddrInSC(char *__symbol)
{
  void *result;
  char *v3;
  char *v4;
  stat v5;
  char v6[1024];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  result = (void *)symAddrInSC_handle;
  if (!symAddrInSC_handle)
  {
    memset(&v5, 0, sizeof(v5));
    v3 = getenv("DYLD_IMAGE_SUFFIX");
    __strlcpy_chk();
    if (v3)
      __strlcat_chk();
    if (stat(v6, &v5) < 0)
      v4 = "/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration";
    else
      v4 = v6;
    result = dlopen(v4, 1);
    if (result)
    {
      symAddrInSC_handle = (uint64_t)result;
    }
    else
    {
      result = (void *)symAddrInSC_handle;
      if (!symAddrInSC_handle)
        return result;
    }
  }
  return dlsym(result, __symbol);
}

uint64_t _io_SCError()
{
  uint64_t (*v0)(void);

  v0 = (uint64_t (*)(void))_io_SCError_dyfunc;
  if (_io_SCError_dyfunc)
    return v0();
  v0 = (uint64_t (*)(void))symAddrInSC("SCError");
  _io_SCError_dyfunc = v0;
  if (v0)
    return v0();
  else
    return 1001;
}

uint64_t (*_io_SCDynamicStoreCopyMultiple(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreCopyMultiple_dyfunc;
  if (_io_SCDynamicStoreCopyMultiple_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCopyMultiple");
  v6 = result;
  _io_SCDynamicStoreCopyMultiple_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

uint64_t (*_io_SCDynamicStoreCopyValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t);

  v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCDynamicStoreCopyValue_dyfunc;
  if (_io_SCDynamicStoreCopyValue_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCopyValue");
  v4 = result;
  _io_SCDynamicStoreCopyValue_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  return result;
}

uint64_t (*_io_SCDynamicStoreCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t, uint64_t);

  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreCreate_dyfunc;
  if (_io_SCDynamicStoreCreate_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8(a1, a2, a3, a4);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCreate");
  v8 = result;
  _io_SCDynamicStoreCreate_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8(a1, a2, a3, a4);
  return result;
}

uint64_t (*_io_SCDynamicStoreCreateRunLoopSource(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreCreateRunLoopSource_dyfunc;
  if (_io_SCDynamicStoreCreateRunLoopSource_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCreateRunLoopSource");
  v6 = result;
  _io_SCDynamicStoreCreateRunLoopSource_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

CFStringRef _io_SCDynamicStoreKeyCreate(const __CFAllocator *a1, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  return CFStringCreateWithFormatAndArguments(a1, 0, format, va);
}

uint64_t (*_io_SCDynamicStoreKeyCreatePreferences(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreKeyCreatePreferences_dyfunc;
  if (_io_SCDynamicStoreKeyCreatePreferences_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreKeyCreatePreferences");
  v6 = result;
  _io_SCDynamicStoreKeyCreatePreferences_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

uint64_t (*_io_SCDynamicStoreSetNotificationKeys(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreSetNotificationKeys_dyfunc;
  if (_io_SCDynamicStoreSetNotificationKeys_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreSetNotificationKeys");
  v6 = result;
  _io_SCDynamicStoreSetNotificationKeys_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

uint64_t (*_io_SCDynamicStoreNotifyValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t);

  v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCDynamicStoreNotifyValue_dyfunc;
  if (_io_SCDynamicStoreNotifyValue_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCDynamicStoreNotifyValue");
  v4 = result;
  _io_SCDynamicStoreNotifyValue_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  return result;
}

uint64_t (*_io_SCDynamicStoreSetValue(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreSetValue_dyfunc;
  if (_io_SCDynamicStoreSetValue_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreSetValue");
  v6 = result;
  _io_SCDynamicStoreSetValue_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

uint64_t (*_io_SCPreferencesApplyChanges(uint64_t a1))(uint64_t)
{
  uint64_t (*v2)(uint64_t);
  uint64_t (*result)(uint64_t);

  v2 = (uint64_t (*)(uint64_t))_io_SCPreferencesApplyChanges_dyfunc;
  if (_io_SCPreferencesApplyChanges_dyfunc)
    return (uint64_t (*)(uint64_t))v2(a1);
  result = (uint64_t (*)(uint64_t))symAddrInSC("SCPreferencesApplyChanges");
  v2 = result;
  _io_SCPreferencesApplyChanges_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t))v2(a1);
  return result;
}

uint64_t (*_io_SCPreferencesCommitChanges(uint64_t a1))(uint64_t)
{
  uint64_t (*v2)(uint64_t);
  uint64_t (*result)(uint64_t);

  v2 = (uint64_t (*)(uint64_t))_io_SCPreferencesCommitChanges_dyfunc;
  if (_io_SCPreferencesCommitChanges_dyfunc)
    return (uint64_t (*)(uint64_t))v2(a1);
  result = (uint64_t (*)(uint64_t))symAddrInSC("SCPreferencesCommitChanges");
  v2 = result;
  _io_SCPreferencesCommitChanges_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t))v2(a1);
  return result;
}

uint64_t (*_io_SCPreferencesCreate(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCPreferencesCreate_dyfunc;
  if (_io_SCPreferencesCreate_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCPreferencesCreate");
  v6 = result;
  _io_SCPreferencesCreate_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

uint64_t (*_io_SCPreferencesCreateWithAuthorization(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t, uint64_t);

  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))_io_SCPreferencesCreateWithAuthorization_dyfunc;
  if (_io_SCPreferencesCreateWithAuthorization_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8(a1, a2, a3, a4);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))symAddrInSC("SCPreferencesCreateWithAuthorization");
  v8 = result;
  _io_SCPreferencesCreateWithAuthorization_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8(a1, a2, a3, a4);
  return result;
}

uint64_t (*_io_SCPreferencesGetValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t);

  v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCPreferencesGetValue_dyfunc;
  if (_io_SCPreferencesGetValue_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCPreferencesGetValue");
  v4 = result;
  _io_SCPreferencesGetValue_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  return result;
}

uint64_t (*_io_SCPreferencesLock(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t);

  v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCPreferencesLock_dyfunc;
  if (_io_SCPreferencesLock_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCPreferencesLock");
  v4 = result;
  _io_SCPreferencesLock_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  return result;
}

uint64_t (*_io_SCPreferencesRemoveValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t);

  v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCPreferencesRemoveValue_dyfunc;
  if (_io_SCPreferencesRemoveValue_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCPreferencesRemoveValue");
  v4 = result;
  _io_SCPreferencesRemoveValue_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  return result;
}

uint64_t (*_io_SCPreferencesSetValue(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t (*result)(uint64_t, uint64_t, uint64_t);

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCPreferencesSetValue_dyfunc;
  if (_io_SCPreferencesSetValue_dyfunc)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCPreferencesSetValue");
  v6 = result;
  _io_SCPreferencesSetValue_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  return result;
}

uint64_t (*_io_SCPreferencesUnlock(uint64_t a1))(uint64_t)
{
  uint64_t (*v2)(uint64_t);
  uint64_t (*result)(uint64_t);

  v2 = (uint64_t (*)(uint64_t))_io_SCPreferencesUnlock_dyfunc;
  if (_io_SCPreferencesUnlock_dyfunc)
    return (uint64_t (*)(uint64_t))v2(a1);
  result = (uint64_t (*)(uint64_t))symAddrInSC("SCPreferencesUnlock");
  v2 = result;
  _io_SCPreferencesUnlock_dyfunc = result;
  if (result)
    return (uint64_t (*)(uint64_t))v2(a1);
  return result;
}

uint64_t __IOHIDValueRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __valueTypeID = result;
  return result;
}

CFTypeID IOHIDValueGetTypeID(void)
{
  CFTypeID result;

  result = __valueTypeID;
  if (!__valueTypeID)
  {
    pthread_once(&__valueTypeInit, (void (*)(void))__IOHIDValueRegister);
    return __valueTypeID;
  }
  return result;
}

uint64_t _IOHIDValueCreateWithElementValuePtr(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t Private;
  int64_t Length;
  int64_t v8;
  _QWORD *v9;

  Private = 0;
  if (a2 && a3)
  {
    Length = _IOHIDElementGetLength((uint64_t)a2);
    v8 = ((unint64_t)*(unsigned int *)(a3 + 4) >> 8) - 20;
    if (Length < v8)
      LODWORD(v8) = _IOHIDElementGetLength((uint64_t)a2);
    Private = __IOHIDValueCreatePrivate(a1, v8);
    if (Private)
    {
      *(_QWORD *)(Private + 16) = CFRetain(a2);
      *(_QWORD *)(Private + 32) = *(_QWORD *)(a3 + 8);
      *(_BYTE *)(Private + 44) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(Private + 40) = v8;
      v9 = (_QWORD *)(a3 + 20);
      if ((*(_BYTE *)(a3 + 4) & 1) != 0)
        v9 = (_QWORD *)*v9;
      memmove((void *)(Private + 56), v9, v8);
    }
  }
  return Private;
}

uint64_t __IOHIDValueCreatePrivate(uint64_t a1, int a2)
{
  unsigned int v2;
  uint64_t Instance;
  uint64_t v4;

  v2 = a2 + 40;
  if (!__valueTypeID)
    pthread_once(&__valueTypeInit, (void (*)(void))__IOHIDValueRegister);
  Instance = _CFRuntimeCreateInstance();
  v4 = Instance;
  if (Instance)
    bzero((void *)(Instance + 16), v2);
  return v4;
}

uint64_t _IOHIDValueCreateWithStruct(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t Private;
  _BOOL4 v7;
  unsigned int Length;
  uint64_t v9;
  int v10;
  void *v11;
  const void *v12;
  size_t v13;

  Private = 0;
  if (a2 && a3)
  {
    v7 = *(_QWORD *)(a3 + 24) && *(_DWORD *)(a3 + 20) != 0;
    Length = _IOHIDElementGetLength((uint64_t)a2);
    Private = __IOHIDValueCreatePrivate(a1, Length);
    if (Private)
    {
      *(_QWORD *)(Private + 16) = CFRetain(a2);
      v9 = *(_QWORD *)(a3 + 12);
      *(_QWORD *)(Private + 32) = v9;
      if (dynLinkrosetta_is_current_process_translated[0])
      {
        v10 = dynLinkrosetta_is_current_process_translated[0]();
        v9 = *(_QWORD *)(Private + 32);
        if (v10)
        {
          if (dynLinkrosetta_convert_to_system_absolute_time[0])
            v9 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(v9);
        }
      }
      *(_QWORD *)(Private + 32) = v9;
      *(_DWORD *)(Private + 40) = Length;
      if (v7)
      {
        v11 = (void *)(Private + 56);
        v12 = *(const void **)(a3 + 24);
        v13 = Length;
      }
      else
      {
        v12 = (const void *)(a3 + 8);
        v11 = (void *)(Private + 56);
        if (Length >= 4uLL)
          v13 = 4;
        else
          v13 = Length;
      }
      memmove(v11, v12, v13);
    }
  }
  return Private;
}

IOHIDValueRef IOHIDValueCreateWithIntegerValue(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, CFIndex value)
{
  unsigned int Length;
  uint64_t Private;
  int v10;
  size_t v11;
  CFIndex __src;

  if (!element)
    return 0;
  Length = _IOHIDElementGetLength((uint64_t)element);
  Private = __IOHIDValueCreatePrivate((uint64_t)allocator, Length);
  if (Private)
  {
    *(_QWORD *)(Private + 16) = CFRetain(element);
    *(_QWORD *)(Private + 32) = timeStamp;
    if (dynLinkrosetta_is_current_process_translated[0])
    {
      v10 = dynLinkrosetta_is_current_process_translated[0]();
      timeStamp = *(_QWORD *)(Private + 32);
      if (v10)
      {
        if (dynLinkrosetta_convert_to_system_absolute_time[0])
          timeStamp = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(*(_QWORD *)(Private + 32));
      }
    }
    *(_QWORD *)(Private + 32) = timeStamp;
    *(_DWORD *)(Private + 40) = Length;
    __src = value;
    if (Length >= 8uLL)
      v11 = 8;
    else
      v11 = Length;
    memmove((void *)(Private + 56), &__src, v11);
  }
  return (IOHIDValueRef)Private;
}

IOHIDValueRef IOHIDValueCreateWithBytes(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, const uint8_t *bytes, CFIndex length)
{
  uint64_t Private;
  CFIndex v11;
  int v12;
  size_t v13;

  Private = 0;
  if (element)
  {
    if (bytes)
    {
      if (length)
      {
        v11 = _IOHIDElementGetLength((uint64_t)element);
        Private = __IOHIDValueCreatePrivate((uint64_t)allocator, v11);
        if (Private)
        {
          *(_QWORD *)(Private + 16) = CFRetain(element);
          *(_QWORD *)(Private + 32) = timeStamp;
          if (dynLinkrosetta_is_current_process_translated[0])
          {
            v12 = dynLinkrosetta_is_current_process_translated[0]();
            timeStamp = *(_QWORD *)(Private + 32);
            if (v12)
            {
              if (dynLinkrosetta_convert_to_system_absolute_time[0])
                timeStamp = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(*(_QWORD *)(Private + 32));
            }
          }
          *(_QWORD *)(Private + 32) = timeStamp;
          *(_DWORD *)(Private + 40) = v11;
          if (v11 >= length)
            v13 = length;
          else
            v13 = v11;
          memmove((void *)(Private + 56), bytes, v13);
        }
      }
    }
  }
  return (IOHIDValueRef)Private;
}

IOHIDValueRef IOHIDValueCreateWithBytesNoCopy(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, const uint8_t *bytes, CFIndex length)
{
  uint64_t Private;
  CFIndex v7;
  int v10;

  Private = 0;
  if (element)
  {
    if (bytes)
    {
      v7 = length;
      if (length)
      {
        Private = __IOHIDValueCreatePrivate((uint64_t)allocator, 0);
        if (Private)
        {
          *(_QWORD *)(Private + 16) = CFRetain(element);
          *(_QWORD *)(Private + 32) = timeStamp;
          if (dynLinkrosetta_is_current_process_translated[0])
          {
            v10 = dynLinkrosetta_is_current_process_translated[0]();
            timeStamp = *(_QWORD *)(Private + 32);
            if (v10)
            {
              if (dynLinkrosetta_convert_to_system_absolute_time[0])
                timeStamp = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(*(_QWORD *)(Private + 32));
            }
          }
          *(_QWORD *)(Private + 32) = timeStamp;
          if ((uint64_t)_IOHIDElementGetLength((uint64_t)element) <= v7)
            LODWORD(v7) = _IOHIDElementGetLength((uint64_t)element);
          *(_DWORD *)(Private + 40) = v7;
          *(_QWORD *)(Private + 48) = bytes;
        }
      }
    }
  }
  return (IOHIDValueRef)Private;
}

uint64_t _IOHIDValueCreateWithValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Private;
  uint64_t v6;

  Private = __IOHIDValueCreatePrivate(a1, *(_DWORD *)(a2 + 40));
  v6 = Private;
  if (Private)
  {
    *(_QWORD *)(Private + 16) = a3;
    *(_BYTE *)(Private + 24) = 1;
    *(_QWORD *)(Private + 32) = *(_QWORD *)(a2 + 32);
    *(_DWORD *)(Private + 40) = *(_DWORD *)(a2 + 40);
    memmove((void *)(Private + 56), (const void *)(a2 + 56), *(unsigned int *)(a2 + 40));
  }
  return v6;
}

IOHIDElementRef IOHIDValueGetElement(IOHIDValueRef value)
{
  return (IOHIDElementRef)*((_QWORD *)value + 2);
}

uint64_t IOHIDValueGetTimeStamp(IOHIDValueRef value)
{
  uint64_t result;

  if (!dynLinkrosetta_is_current_process_translated[0]
    || !dynLinkrosetta_is_current_process_translated[0]())
  {
    return *((_QWORD *)value + 4);
  }
  result = *((_QWORD *)value + 4);
  if (dynLinkrosetta_convert_to_rosetta_absolute_time[0])
    return ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_rosetta_absolute_time[0])(result);
  return result;
}

uint64_t _IOHIDValueGetFlags(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 44);
}

CFIndex IOHIDValueGetIntegerValue(IOHIDValueRef value)
{
  __IOHIDElement *v1;
  int v2;
  unint64_t v3;

  v1 = (__IOHIDElement *)*((_QWORD *)value + 2);
  if (*((_DWORD *)value + 10) >= 8u)
    v2 = 8;
  else
    v2 = *((_DWORD *)value + 10);
  if (IOHIDElementGetLogicalMin(*((IOHIDElementRef *)value + 2)) < 0)
    LOBYTE(v3) = 1;
  else
    v3 = (unint64_t)IOHIDElementGetLogicalMax(v1) >> 63;
  __memmove_chk();
  if (v2 && (v3 & 1) != 0)
    return 0;
  else
    return 0;
}

const uint8_t *__cdecl IOHIDValueGetBytePtr(IOHIDValueRef value)
{
  if (*((_QWORD *)value + 6))
    return (const uint8_t *)*((_QWORD *)value + 6);
  else
    return (const uint8_t *)value + 56;
}

double_t IOHIDValueGetScaledValue(IOHIDValueRef value, IOHIDValueScaleType type)
{
  __IOHIDElement *v3;
  CFIndex IntegerValue;
  CFIndex LogicalMin;
  CFIndex LogicalMax;
  CFIndex PhysicalMin;
  CFIndex PhysicalMax;
  double v9;
  uint64_t CalibrationInfo;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex v15;
  double_t result;
  uint32_t v17;
  double v18;
  double v19;
  double v20;

  v3 = (__IOHIDElement *)*((_QWORD *)value + 2);
  IntegerValue = IOHIDValueGetIntegerValue(value);
  LogicalMin = IOHIDElementGetLogicalMin(v3);
  LogicalMax = IOHIDElementGetLogicalMax(v3);
  PhysicalMin = IOHIDElementGetPhysicalMin(v3);
  PhysicalMax = IOHIDElementGetPhysicalMax(v3);
  v9 = 0.0;
  if (type == 2)
  {
    v17 = IOHIDElementGetUnitExponent(v3) & 0xF;
    if (v17 > 7)
    {
      v19 = __exp10((double)(int)(16 - v17));
      v18 = 0.0;
      v9 = 1.0 / v19;
      goto LABEL_25;
    }
    v9 = __exp10((double)v17);
    goto LABEL_16;
  }
  if (type || (CalibrationInfo = _IOHIDElementGetCalibrationInfo((uint64_t)v3)) == 0)
  {
LABEL_16:
    v18 = 0.0;
    goto LABEL_25;
  }
  v11 = *(_QWORD *)(CalibrationInfo + 32);
  v12 = *(_QWORD *)(CalibrationInfo + 40);
  if (v11 == v12)
    PhysicalMin = -1;
  else
    PhysicalMin = *(_QWORD *)(CalibrationInfo + 32);
  if (v11 == v12)
    PhysicalMax = 1;
  else
    PhysicalMax = *(_QWORD *)(CalibrationInfo + 40);
  v13 = *(_QWORD *)(CalibrationInfo + 8);
  if (*(_QWORD *)CalibrationInfo != v13)
  {
    if (IntegerValue <= *(_QWORD *)CalibrationInfo)
      return (double)PhysicalMin;
    if (IntegerValue >= v13)
      return (double)PhysicalMax;
    LogicalMin = *(_QWORD *)CalibrationInfo;
    LogicalMax = *(_QWORD *)(CalibrationInfo + 8);
  }
  v15 = *(_QWORD *)(CalibrationInfo + 16);
  v14 = *(_QWORD *)(CalibrationInfo + 24);
  if (v15 != v14)
  {
    result = (double)(PhysicalMax - PhysicalMin) * 0.5 + (double)PhysicalMin;
    if (IntegerValue >= v15)
    {
      if (IntegerValue <= v14)
        return result;
      PhysicalMin = (uint64_t)result;
      LogicalMin = *(_QWORD *)(CalibrationInfo + 24);
    }
    else
    {
      PhysicalMax = (uint64_t)result;
      LogicalMax = *(_QWORD *)(CalibrationInfo + 16);
    }
  }
  v18 = *(double *)(CalibrationInfo + 48);
LABEL_25:
  v20 = 1.0;
  if (v9 != 0.0)
    v20 = v9;
  result = v20
         * ((double)(IntegerValue - LogicalMin)
          * (double)(PhysicalMax - PhysicalMin)
          / (double)(LogicalMax - LogicalMin)
          + (double)PhysicalMin);
  if (v18 != 0.0)
    return v18 * (double)(uint64_t)llround(result / v18);
  return result;
}

CFIndex IOHIDValueGetLength(IOHIDValueRef value)
{
  return *((unsigned int *)value + 10);
}

void *_IOHIDValueCopyToElementValuePtr(uint64_t a1, uint64_t a2)
{
  __IOHIDElement *v4;
  void *v5;
  size_t v6;
  unint64_t v7;
  void *v8;

  v4 = *(__IOHIDElement **)(a1 + 16);
  v5 = *(void **)(a1 + 48);
  v6 = *(unsigned int *)(a1 + 40);
  if (IOHIDElementGetLogicalMin(v4) < 0)
    LODWORD(v7) = 1;
  else
    v7 = (unint64_t)IOHIDElementGetLogicalMax(v4) >> 63;
  if (v5)
    v8 = v5;
  else
    v8 = (void *)(a1 + 56);
  return __IOHIDValueConvertByteToWord(v8, (void *)(a2 + 20), v6, v7);
}

void *__IOHIDValueConvertByteToWord(void *__src, void *__dst, size_t __len, int a4)
{
  unsigned int v5;
  void *result;
  char v8;
  uint64_t v9;
  unsigned int v10;

  v5 = __len;
  result = memmove(__dst, __src, __len);
  if (v5 && a4 && (v5 & 3) != 0)
  {
    v8 = 8 * (v5 & 3);
    v9 = v5 >> 2;
    v10 = *((_DWORD *)__dst + v9);
    if (((v10 >> (v8 - 1)) & 1) != 0)
      *((_DWORD *)__dst + v9) = v10 | (-1 << v8);
  }
  return result;
}

void *_IOHIDValueCopyToElementValueHeader(uint64_t a1, IOHIDElementCookie *a2)
{
  __IOHIDElement *v4;
  void *v5;
  size_t v6;
  unint64_t v7;
  void *v8;

  v4 = *(__IOHIDElement **)(a1 + 16);
  *a2 = IOHIDElementGetCookie(v4);
  a2[1] = *(_DWORD *)(a1 + 40);
  v5 = *(void **)(a1 + 48);
  v6 = *(unsigned int *)(a1 + 40);
  if (IOHIDElementGetLogicalMin(v4) < 0)
    LODWORD(v7) = 1;
  else
    v7 = (unint64_t)IOHIDElementGetLogicalMax(v4) >> 63;
  if (v5)
    v8 = v5;
  else
    v8 = (void *)(a1 + 56);
  return __IOHIDValueConvertByteToWord(v8, a2 + 2, v6, v7);
}

void __IOHIDValueRelease(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 24))
      CFRelease(v2);
  }
}

uint64_t initrosetta_convert_to_system_absolute_time(uint64_t a1)
{
  void *v2;
  uint64_t (*v3)();

  v2 = (void *)RosettaLibrary_libLibrary;
  if (!RosettaLibrary_libLibrary)
  {
    v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary = (uint64_t)v2;
  }
  v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_system_absolute_time");
  dynLinkrosetta_convert_to_system_absolute_time[0] = v3;
  if (v3)
    return ((uint64_t (*)(uint64_t))v3)(a1);
  else
    return a1;
}

uint64_t initrosetta_convert_to_rosetta_absolute_time(uint64_t a1)
{
  void *v2;
  uint64_t (*v3)();

  v2 = (void *)RosettaLibrary_libLibrary;
  if (!RosettaLibrary_libLibrary)
  {
    v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary = (uint64_t)v2;
  }
  v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_rosetta_absolute_time");
  dynLinkrosetta_convert_to_rosetta_absolute_time[0] = v3;
  if (v3)
    return ((uint64_t (*)(uint64_t))v3)(a1);
  else
    return a1;
}

void _IOHIDElementReleasePrivate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  void *v10;

  v2 = (const void *)a1[7];
  if (v2)
  {
    CFRelease(v2);
    a1[7] = 0;
  }
  v3 = (const void *)a1[8];
  if (v3)
  {
    CFRelease(v3);
    a1[8] = 0;
  }
  v4 = (const void *)a1[9];
  if (v4)
  {
    CFRelease(v4);
    a1[9] = 0;
  }
  v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  v6 = (const void *)a1[10];
  if (v6)
  {
    CFRelease(v6);
    a1[10] = 0;
  }
  v7 = (const void *)a1[12];
  if (v7)
  {
    CFRelease(v7);
    a1[12] = 0;
  }
  v8 = (const void *)a1[13];
  if (v8)
  {
    CFRelease(v8);
    a1[13] = 0;
  }
  v9 = (const void *)a1[3];
  if (v9)
  {
    CFRelease(v9);
    a1[3] = 0;
  }
  v10 = (void *)a1[11];
  if (v10)
    free(v10);
  a1[11] = 0;
}

HIDElement *_IOHIDElementCreateWithParentAndData(uint64_t a1, const void *a2, const void *a3, IOHIDElementStruct *a4, unsigned int a5)
{
  HIDElement *Private;
  __IOHIDElement *v10;

  if (!a4)
    return 0;
  Private = _IOHIDElementCreatePrivate();
  if (Private)
  {
    Private->_element.data = (__CFData *)CFRetain(a3);
    Private->_element.elementStructPtr = a4;
    Private->_element.index = a5;
    if (a2)
      v10 = (__IOHIDElement *)CFRetain(a2);
    else
      v10 = 0;
    Private->_element.parentElement = v10;
  }
  return Private;
}

HIDElement *_IOHIDElementCreateWithElement(const __CFAllocator *a1, uint64_t a2, int a3, int a4)
{
  HIDElement *Private;
  HIDElement *v9;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  int v12;
  int *elementStructPtr;

  if (!a2)
    return 0;
  Private = _IOHIDElementCreatePrivate();
  v9 = Private;
  if (Private)
  {
    Private->_element.index = 0;
    Private->_element.originalElement = (__IOHIDElement *)CFRetain((CFTypeRef)a2);
    Mutable = CFDataCreateMutable(a1, 96);
    v9->_element.data = Mutable;
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v9->_element.elementStructPtr = (IOHIDElementStruct *)MutableBytePtr;
    memmove(MutableBytePtr, *(const void **)(a2 + 32), 0x60uLL);
    v12 = -*(_DWORD *)(a2 + 40) - **(_DWORD **)(a2 + 32);
    elementStructPtr = (int *)v9->_element.elementStructPtr;
    *elementStructPtr = v12;
    elementStructPtr[1] = v12;
    elementStructPtr[6] = a3;
    elementStructPtr[7] = a4;
    elementStructPtr[8] = a4;
    elementStructPtr[19] = 0;
    elementStructPtr[20] = 0;
  }
  return v9;
}

IOHIDElementCookie IOHIDElementGetCookie(IOHIDElementRef element)
{
  return *((_DWORD *)element + 10) + **((_DWORD **)element + 4);
}

uint64_t _IOHIDElementSetDevice(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t _IOHIDElementSetDeviceInterface(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

unint64_t _IOHIDElementGetLength(uint64_t a1)
{
  _DWORD *v1;
  unsigned int v2;

  v1 = *(_DWORD **)(a1 + 32);
  v2 = v1[13];
  if (v1[19] && *(_DWORD *)(a1 + 40))
    v2 = v1[14];
  return ((unint64_t)v2 + 7) >> 3;
}

IOHIDElementType IOHIDElementGetType(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 12);
}

IOHIDElementRef IOHIDElementCreateWithDictionary(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  HIDElement *Private;
  HIDElement *v4;
  __CFData *Mutable;

  if (!dictionary)
    return 0;
  Private = _IOHIDElementCreatePrivate();
  v4 = Private;
  if (Private)
  {
    Private->_element.index = 0;
    Mutable = CFDataCreateMutable(allocator, 96);
    v4->_element.data = Mutable;
    if (Mutable)
    {
      v4->_element.elementStructPtr = (IOHIDElementStruct *)CFDataGetMutableBytePtr(Mutable);
      return (IOHIDElementRef)v4;
    }
    CFRelease(v4);
    return 0;
  }
  return (IOHIDElementRef)v4;
}

IOHIDElementCollectionType IOHIDElementGetCollectionType(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 16);
}

uint32_t IOHIDElementGetUsagePage(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 24);
}

uint32_t IOHIDElementGetUsage(IOHIDElementRef element)
{
  uint64_t v1;
  int v2;
  int v3;

  v1 = *((_QWORD *)element + 4);
  v2 = *(_DWORD *)(v1 + 28);
  if (v2 == *(_DWORD *)(v1 + 32))
    v3 = 0;
  else
    v3 = *((_DWORD *)element + 10);
  return v3 + v2;
}

uint64_t _IOHIDElementGetFlags(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 32) + 20);
}

Boolean IOHIDElementIsVirtual(IOHIDElementRef element)
{
  return *((_QWORD *)element + 10) != 0;
}

Boolean IOHIDElementIsRelative(IOHIDElementRef element)
{
  return (*(unsigned __int8 *)(*((_QWORD *)element + 4) + 20) >> 2) & 1;
}

Boolean IOHIDElementIsWrapping(IOHIDElementRef element)
{
  return (*(unsigned __int8 *)(*((_QWORD *)element + 4) + 20) >> 3) & 1;
}

Boolean IOHIDElementIsArray(IOHIDElementRef element)
{
  return (*(_BYTE *)(*((_QWORD *)element + 4) + 20) & 2) == 0;
}

Boolean IOHIDElementIsNonLinear(IOHIDElementRef element)
{
  return (*(unsigned __int8 *)(*((_QWORD *)element + 4) + 20) >> 4) & 1;
}

Boolean IOHIDElementHasPreferredState(IOHIDElementRef element)
{
  return (*(_BYTE *)(*((_QWORD *)element + 4) + 20) & 0x20) == 0;
}

Boolean IOHIDElementHasNullState(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 20) & 0x40;
}

CFStringRef IOHIDElementGetName(IOHIDElementRef element)
{
  CFStringRef result;
  const __CFString *v2;
  CFTypeID v3;

  result = (CFStringRef)*((_QWORD *)element + 12);
  if (result)
  {
    result = (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("Name"));
    if (result)
    {
      v2 = result;
      v3 = CFGetTypeID(result);
      if (v3 == CFStringGetTypeID())
        return v2;
      else
        return 0;
    }
  }
  return result;
}

CFTypeRef IOHIDElementGetProperty(IOHIDElementRef element, CFStringRef key)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)element + 12);
  if (result)
    return CFDictionaryGetValue((CFDictionaryRef)result, key);
  return result;
}

uint32_t IOHIDElementGetReportID(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 64);
}

uint32_t IOHIDElementGetReportSize(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 56);
}

uint32_t IOHIDElementGetReportCount(IOHIDElementRef element)
{
  uint64_t v2;
  uint32_t result;

  v2 = *((_QWORD *)element + 4);
  result = *(_DWORD *)(v2 + 92);
  if (*(_DWORD *)(v2 + 76))
  {
    if (*((_DWORD *)element + 10))
      return 1;
  }
  return result;
}

uint32_t IOHIDElementGetUnit(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 68);
}

uint32_t IOHIDElementGetUnitExponent(IOHIDElementRef element)
{
  return *(_DWORD *)(*((_QWORD *)element + 4) + 72);
}

CFIndex IOHIDElementGetLogicalMin(IOHIDElementRef element)
{
  return *(int *)(*((_QWORD *)element + 4) + 36);
}

CFIndex IOHIDElementGetLogicalMax(IOHIDElementRef element)
{
  return *(int *)(*((_QWORD *)element + 4) + 40);
}

CFIndex IOHIDElementGetPhysicalMin(IOHIDElementRef element)
{
  return *(int *)(*((_QWORD *)element + 4) + 44);
}

CFIndex IOHIDElementGetPhysicalMax(IOHIDElementRef element)
{
  return *(int *)(*((_QWORD *)element + 4) + 48);
}

uint64_t IOHIDElementGetDuplicateIndex(uint64_t a1)
{
  int v1;
  BOOL v2;
  unsigned int v3;

  if (!*(_DWORD *)(*(_QWORD *)(a1 + 32) + 76))
    return 0;
  v1 = *(_DWORD *)(a1 + 40);
  v2 = v1 != 0;
  v3 = v1 - 1;
  if (v2)
    return v3;
  else
    return 0;
}

IOHIDDeviceRef IOHIDElementGetDevice(IOHIDElementRef element)
{
  return (IOHIDDeviceRef)*((_QWORD *)element + 2);
}

IOHIDElementRef IOHIDElementGetParent(IOHIDElementRef element)
{
  IOHIDElementRef result;
  const __CFAllocator *v3;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  const __CFAllocator *v6;
  CFNumberRef v7;
  const void *ValueAtIndex;
  int valuePtr;
  CFArrayRef theArray;

  result = (IOHIDElementRef)*((_QWORD *)element + 9);
  if (!result)
  {
    if (*((_QWORD *)element + 1))
    {
      theArray = 0;
      v3 = CFGetAllocator(element);
      Mutable = CFDictionaryCreateMutable(v3, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v5 = Mutable;
        valuePtr = *(_DWORD *)(*((_QWORD *)element + 4) + 8);
        v6 = CFGetAllocator(element);
        v7 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(v5, CFSTR("ElementCookie"), v7);
        CFRelease(v7);
        (*(void (**)(_QWORD, __CFDictionary *, CFArrayRef *, _QWORD))(**((_QWORD **)element + 1) + 72))(*((_QWORD *)element + 1), v5, &theArray, 0);
        if (theArray)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
          *((_QWORD *)element + 9) = CFRetain(ValueAtIndex);
          CFRelease(theArray);
        }
        CFRelease(v5);
      }
      return (IOHIDElementRef)*((_QWORD *)element + 9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFArrayRef IOHIDElementGetChildren(IOHIDElementRef element)
{
  CFArrayRef result;
  const __CFAllocator *v3;
  __CFDictionary *v4;
  const __CFAllocator *v5;
  CFNumberRef v6;
  int valuePtr;
  const __CFArray *v8;

  v8 = 0;
  result = (CFArrayRef)*((_QWORD *)element + 8);
  if (!result)
  {
    if (*((_QWORD *)element + 1))
    {
      v3 = CFGetAllocator(element);
      result = CFDictionaryCreateMutable(v3, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (result)
      {
        v4 = result;
        valuePtr = *((_DWORD *)element + 10) + **((_DWORD **)element + 4);
        v5 = CFGetAllocator(element);
        v6 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(v4, CFSTR("CollectionCookie"), v6);
        CFRelease(v6);
        (*(void (**)(_QWORD, __CFDictionary *, const __CFArray **, _QWORD))(**((_QWORD **)element + 1) + 72))(*((_QWORD *)element + 1), v4, &v8, 0);
        if (v8)
          *((_QWORD *)element + 8) = v8;
        CFRelease(v4);
        return v8;
      }
    }
  }
  return result;
}

void IOHIDElementAttach(IOHIDElementRef element, IOHIDElementRef toAttach)
{
  char v3;
  const CFArrayCallBacks *v4;
  char v5;
  CFMutableArrayRef *v6;
  const __CFArray *Mutable;
  const __CFAllocator *v8;
  CFRange v9;

  v3 = 0;
  v4 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  do
  {
    v5 = v3;
    v6 = (CFMutableArrayRef *)element;
    Mutable = (const __CFArray *)*((_QWORD *)element + 7);
    if (!Mutable)
    {
      v8 = CFGetAllocator(element);
      Mutable = CFArrayCreateMutable(v8, 0, v4);
      v6[7] = Mutable;
      if (!Mutable)
        break;
    }
    v9.length = CFArrayGetCount(Mutable);
    v9.location = 0;
    if (CFArrayGetFirstIndexOfValue(Mutable, v9, toAttach) != -1)
      break;
    CFArrayAppendValue(v6[7], toAttach);
    v3 = 1;
    element = toAttach;
    toAttach = (IOHIDElementRef)v6;
  }
  while ((v5 & 1) == 0);
}

void IOHIDElementDetach(IOHIDElementRef element, IOHIDElementRef toDetach)
{
  char v3;
  const __CFArray *v4;
  char v5;
  CFMutableArrayRef *v6;
  CFIndex FirstIndexOfValue;
  CFRange v8;

  v3 = 0;
  do
  {
    v4 = (const __CFArray *)*((_QWORD *)element + 7);
    if (!v4)
      break;
    v5 = v3;
    v6 = (CFMutableArrayRef *)element;
    v8.length = CFArrayGetCount(*((CFArrayRef *)element + 7));
    v8.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v8, toDetach);
    if (FirstIndexOfValue == -1)
      break;
    CFArrayRemoveValueAtIndex(v6[7], FirstIndexOfValue);
    v3 = 1;
    element = toDetach;
    toDetach = (IOHIDElementRef)v6;
  }
  while ((v5 & 1) == 0);
}

CFArrayRef IOHIDElementCopyAttached(IOHIDElementRef element)
{
  const __CFAllocator *v2;

  if (!*((_QWORD *)element + 7))
    return 0;
  v2 = CFGetAllocator(element);
  return CFArrayCreateCopy(v2, *((CFArrayRef *)element + 7));
}

uint64_t _IOHIDElementGetValue(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

void _IOHIDElementSetValue(uint64_t a1, uint64_t a2)
{
  const void *v3;

  v3 = *(const void **)(a1 + 24);
  if (v3 != (const void *)a2)
  {
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 24) = 0;
    }
    if (a2)
      *(_QWORD *)(a1 + 24) = _IOHIDValueCreateWithValue(*MEMORY[0x1E0C9AE00], a2, a1);
  }
}

uint64_t _IOHIDElementGetCalibrationInfo(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

Boolean IOHIDElementSetProperty(IOHIDElementRef element, CFStringRef key, CFTypeRef property)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  CFTypeID v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _OWORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t valuePtr;

  if (*((_QWORD *)element + 12)
    || (v6 = CFGetAllocator(element),
        Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
        (*((_QWORD *)element + 12) = Mutable) != 0))
  {
    *((_BYTE *)element + 112) = 1;
    v8 = CFGetTypeID(property);
    if (v8 == CFNumberGetTypeID())
    {
      v9 = CFEqual(key, CFSTR("CalibrationMin"));
      if (v9)
      {
        v10 = 0;
LABEL_8:
        v12 = 0;
LABEL_9:
        v13 = 0;
LABEL_10:
        v14 = 0;
LABEL_11:
        v15 = 0;
LABEL_12:
        v16 = 0;
LABEL_13:
        if (*((_QWORD *)element + 11)
          || (v17 = malloc_type_malloc(0x38uLL, 0x100004021716A34uLL),
              *((_QWORD *)element + 11) = v17,
              *v17 = 0u,
              v17[1] = 0u,
              v17[2] = 0u,
              *((_QWORD *)v17 + 6) = 0,
              *((_QWORD *)element + 11)))
        {
          valuePtr = 0;
          CFNumberGetValue((CFNumberRef)property, kCFNumberCFIndexType, &valuePtr);
          if (v9)
          {
            *(_QWORD *)(*((_QWORD *)element + 11) + 32) = valuePtr;
          }
          else if (v10)
          {
            *(_QWORD *)(*((_QWORD *)element + 11) + 40) = valuePtr;
          }
          else if (v12)
          {
            **((_QWORD **)element + 11) = valuePtr;
          }
          else if (v13)
          {
            *(_QWORD *)(*((_QWORD *)element + 11) + 8) = valuePtr;
          }
          else if (v14)
          {
            *(_QWORD *)(*((_QWORD *)element + 11) + 16) = valuePtr;
          }
          else if (v15)
          {
            *(_QWORD *)(*((_QWORD *)element + 11) + 24) = valuePtr;
          }
          else if (v16)
          {
            CFNumberGetValue((CFNumberRef)property, kCFNumberFloat64Type, (void *)(*((_QWORD *)element + 11) + 48));
          }
        }
        goto LABEL_39;
      }
      v11 = CFEqual(key, CFSTR("CalibrationMax"));
      if (v11)
      {
        v10 = v11;
        goto LABEL_8;
      }
      v18 = CFEqual(key, CFSTR("CalibrationSaturationMin"));
      if (v18)
      {
        v12 = v18;
        v10 = 0;
        goto LABEL_9;
      }
      v19 = CFEqual(key, CFSTR("CalibrationSaturationMax"));
      if (v19)
      {
        v13 = v19;
        v10 = 0;
        v12 = 0;
        goto LABEL_10;
      }
      v20 = CFEqual(key, CFSTR("CalibrationDeadZoneMin"));
      if (v20)
      {
        v14 = v20;
        v10 = 0;
        v12 = 0;
        v13 = 0;
        goto LABEL_11;
      }
      v21 = CFEqual(key, CFSTR("CalibrationDeadZoneMax"));
      if (v21)
      {
        v15 = v21;
        v10 = 0;
        v12 = 0;
        v13 = 0;
        v14 = 0;
        goto LABEL_12;
      }
      v22 = CFEqual(key, CFSTR("CalibrationGranularity"));
      if (v22)
      {
        v16 = v22;
        v10 = 0;
        v12 = 0;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        goto LABEL_13;
      }
    }
LABEL_39:
    CFDictionarySetValue(*((CFMutableDictionaryRef *)element + 12), key, property);
    LOBYTE(Mutable) = 1;
  }
  return Mutable;
}

CFStringRef __IOHIDElementGetRootKey(uint64_t a1)
{
  CFStringRef result;
  CFStringRef UUIDKey;
  _DWORD *v4;
  int v5;
  int v6;

  result = *(CFStringRef *)(a1 + 104);
  if (!result)
  {
    UUIDKey = __IOHIDDeviceGetUUIDKey(*(__IOHIDDevice **)(a1 + 16));
    v4 = *(_DWORD **)(a1 + 32);
    v5 = v4[7];
    if (v5 == v4[8])
      v6 = 0;
    else
      v6 = *(_DWORD *)(a1 + 40);
    result = CFStringCreateWithFormat(0, 0, CFSTR("%@#%04lx#%04lx#%016lx#%ld"), UUIDKey, v4[6], (v6 + v5), (*(_DWORD *)(a1 + 40) + *v4), v4[3]);
    *(_QWORD *)(a1 + 104) = result;
  }
  return result;
}

void __IOHIDElementSaveProperties(uint64_t a1, CFStringRef *a2)
{
  const __CFDictionary *v3;
  const __CFString *RootKey;

  if (*(_BYTE *)(a1 + 112))
  {
    v3 = *(const __CFDictionary **)(a1 + 96);
    if (v3)
    {
      RootKey = __IOHIDElementGetRootKey(a1);
      __IOHIDPropertySaveToKeyWithSpecialKeys(v3, RootKey, __KIOHIDElementSpecialKeys, a2);
      *(_BYTE *)(a1 + 112) = 0;
    }
  }
}

CFTypeID __IOHIDElementLoadProperties(uint64_t a1)
{
  const __CFString *RootKey;
  CFTypeID result;
  const __CFDictionary *v4;
  const void *v5;
  const __CFNumber *Value;
  const __CFNumber *v7;
  CFTypeID v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  CFTypeID v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  CFTypeID v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  CFTypeID v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  CFTypeID v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  CFTypeID v23;
  const __CFNumber *v24;
  CFTypeID v25;

  RootKey = __IOHIDElementGetRootKey(a1);
  result = (CFTypeID)__IOHIDPropertyLoadFromKeyWithSpecialKeys(RootKey, (uint64_t *)__KIOHIDElementSpecialKeys);
  if (result)
  {
    v4 = (const __CFDictionary *)result;
    v5 = *(const void **)(a1 + 96);
    if (v5)
      CFRelease(v5);
    *(_QWORD *)(a1 + 96) = v4;
    Value = (const __CFNumber *)CFDictionaryGetValue(v4, CFSTR("CalibrationMin"));
    if (Value)
    {
      v7 = Value;
      v8 = CFGetTypeID(Value);
      if (v8 == CFNumberGetTypeID())
        CFNumberGetValue(v7, kCFNumberCFIndexType, (void *)(*(_QWORD *)(a1 + 88) + 32));
    }
    v9 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("CalibrationMax"));
    if (v9)
    {
      v10 = v9;
      v11 = CFGetTypeID(v9);
      if (v11 == CFNumberGetTypeID())
        CFNumberGetValue(v10, kCFNumberCFIndexType, (void *)(*(_QWORD *)(a1 + 88) + 40));
    }
    v12 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("CalibrationSaturationMin"));
    if (v12)
    {
      v13 = v12;
      v14 = CFGetTypeID(v12);
      if (v14 == CFNumberGetTypeID())
        CFNumberGetValue(v13, kCFNumberCFIndexType, *(void **)(a1 + 88));
    }
    v15 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("CalibrationSaturationMax"));
    if (v15)
    {
      v16 = v15;
      v17 = CFGetTypeID(v15);
      if (v17 == CFNumberGetTypeID())
        CFNumberGetValue(v16, kCFNumberCFIndexType, (void *)(*(_QWORD *)(a1 + 88) + 8));
    }
    v18 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("CalibrationDeadZoneMin"));
    if (v18)
    {
      v19 = v18;
      v20 = CFGetTypeID(v18);
      if (v20 == CFNumberGetTypeID())
        CFNumberGetValue(v19, kCFNumberCFIndexType, (void *)(*(_QWORD *)(a1 + 88) + 16));
    }
    v21 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("CalibrationDeadZoneMax"));
    if (v21)
    {
      v22 = v21;
      v23 = CFGetTypeID(v21);
      if (v23 == CFNumberGetTypeID())
        CFNumberGetValue(v22, kCFNumberCFIndexType, (void *)(*(_QWORD *)(a1 + 88) + 24));
    }
    result = (CFTypeID)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("CalibrationGranularity"));
    if (result)
    {
      v24 = (const __CFNumber *)result;
      v25 = CFGetTypeID((CFTypeRef)result);
      result = CFNumberGetTypeID();
      if (v25 == result)
        result = CFNumberGetValue(v24, kCFNumberFloat64Type, (void *)(*(_QWORD *)(a1 + 88) + 48));
    }
    *(_BYTE *)(a1 + 112) = 0;
  }
  return result;
}

void __IOHIDSaveElementSet(uint64_t a1, CFStringRef *a2)
{
  if (a1)
    __IOHIDElementSaveProperties(a1, a2);
}

uint64_t __IOHIDLoadElementSet(uint64_t a1)
{
  if (a1)
    return __IOHIDElementLoadProperties(a1);
  return a1;
}

_OWORD *fat_iterator_open(const char *a1, int a2)
{
  int v3;
  int v4;
  _OWORD *v5;
  uint64_t v6;
  int *v7;
  _OWORD *v8;
  __int128 v9;
  stat v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v3 = open(a1, 0);
  if (v3 == -1)
    return 0;
  v4 = v3;
  memset(&v11, 0, sizeof(v11));
  v5 = 0;
  v6 = -1;
  if (fstat(v3, &v11) != -1 && v11.st_size >= 28)
  {
    v7 = (int *)mmap(0, v11.st_size, 1, 2, v4, 0);
    v6 = (uint64_t)v7;
    if (v7 == (int *)-1
      || (BYTE8(v14) = 1,
          __fat_iterator_init((uint64_t)&v12, v7, (unint64_t)v7 + v11.st_size, a2) == -1))
    {
      v5 = 0;
    }
    else
    {
      v8 = malloc_type_malloc(0x30uLL, 0x10A0040D39FF539uLL);
      v5 = v8;
      if (v8)
      {
        v9 = v13;
        *v8 = v12;
        v8[1] = v9;
        v8[2] = v14;
      }
    }
  }
  close(v4);
  if (!v5 && v6 != -1)
  {
    munmap((void *)v6, v11.st_size);
    return 0;
  }
  return v5;
}

uint64_t __fat_iterator_init(uint64_t a1, int *a2, unint64_t a3, int a4)
{
  unint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v8;

  v4 = a3 - (_QWORD)a2;
  if (a3 - (unint64_t)a2 < 4)
    return 0xFFFFFFFFLL;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  v5 = *a2;
  if (*a2 > -17958195)
  {
    if ((v5 + 17958194) >= 2)
      goto LABEL_6;
LABEL_9:
    if (v4 < 0x1C)
      return 0xFFFFFFFFLL;
    *(_BYTE *)(a1 + 40) |= 2u;
    *(_QWORD *)(a1 + 32) = 1;
    return 0;
  }
  if (v5 != -1095041334)
  {
    if (v5 != -822415874 && v5 != -805638658)
    {
LABEL_6:
      if (!a4)
        return 0;
      return 0xFFFFFFFFLL;
    }
    goto LABEL_9;
  }
  if (v4 < 8)
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = a2 + 2;
  v8 = bswap32(a2[1]);
  *(_DWORD *)(a1 + 32) = v8;
  v6 = 0xFFFFFFFFLL;
  if (v8 <= 0x20 && (unint64_t)&a2[5 * v8 + 2] <= a3)
  {
    *(_BYTE *)(a1 + 40) |= 2u;
    return 0;
  }
  return v6;
}

_OWORD *fat_iterator_for_data(int *a1, unint64_t a2, int a3)
{
  _OWORD *result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v6 = 0u;
  v7 = 0u;
  v5 = 0u;
  if (__fat_iterator_init((uint64_t)&v5, a1, a2, a3) == -1)
    return 0;
  result = malloc_type_malloc(0x30uLL, 0x10A0040D39FF539uLL);
  if (result)
  {
    v4 = v6;
    *result = v5;
    result[1] = v4;
    result[2] = v7;
  }
  return result;
}

void fat_iterator_close(void **a1)
{
  void *v2;

  if (((_BYTE)a1[5] & 1) != 0)
  {
    v2 = *a1;
    if (*a1)
      munmap(v2, (_BYTE *)a1[1] - (_BYTE *)v2);
  }
  free(a1);
}

uint64_t fat_iterator_num_arches(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t fat_iterator_is_iterable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 40) << 30 >> 31);
}

uint64_t fat_iterator_next_arch(uint64_t *a1, unint64_t *a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;

  v2 = *((_DWORD *)a1 + 9);
  if (a1[2])
  {
    v3 = *((_DWORD *)a1 + 8);
    if (v2 < v3)
    {
      v4 = a1[3] + 20 * v2;
      v5 = *(_DWORD *)(v4 + 12);
      v6 = *a1 + bswap32(*(_DWORD *)(v4 + 8));
      v7 = v6 + bswap32(v5);
      if (v7 <= a1[1])
      {
        if (a2)
          *a2 = v7;
        v3 = v2 + 1;
      }
      else
      {
        v6 = 0;
      }
LABEL_13:
      *((_DWORD *)a1 + 9) = v3;
      return v6;
    }
  }
  else if (!v2)
  {
    v6 = *a1;
    if (a2)
      *a2 = a1[1];
    v3 = 1;
    goto LABEL_13;
  }
  return 0;
}

uint64_t fat_iterator_reset(uint64_t result)
{
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t fat_iterator_find_fat_arch(int **a1, cpu_type_t a2, cpu_subtype_t a3, uint64_t a4)
{
  uint64_t v8;
  fat_arch *v9;
  fat_arch *v10;
  uint64_t i;
  int8x16_t *v12;
  fat_arch *v13;
  int *v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  fat_arch *v19;
  __int128 v20;
  uint64_t v22;
  uint64_t v23;
  int v24;

  v22 = 0;
  v23 = 0;
  v24 = 0;
  if (a1[2])
  {
    v8 = *((unsigned int *)a1 + 8);
    v9 = (fat_arch *)malloc_type_malloc((20 * v8), 0x9AE2AB23uLL);
    if (!v9)
      return 0;
    v10 = v9;
    memcpy(v9, a1[3], (20 * v8));
    if ((_DWORD)v8)
    {
      for (i = 0; i != v8; ++i)
      {
        v12 = (int8x16_t *)&v10[i];
        *v12 = vrev32q_s8(*(int8x16_t *)&v10[i].cputype);
        v12[1].i32[0] = bswap32(v10[i].align);
      }
    }
    v13 = v10;
  }
  else
  {
    v14 = *a1;
    v16 = **a1;
    v15 = (*a1)[1];
    LODWORD(v22) = 0;
    if ((v16 & 0xFEFFFFFF) == 0xCEFAEDFE)
    {
      LODWORD(v22) = bswap32(v15);
      v17 = bswap32(v14[2]);
    }
    else
    {
      LODWORD(v22) = v15;
      v17 = v14[2];
    }
    v13 = 0;
    HIDWORD(v22) = v17;
    LODWORD(v23) = 0;
    LODWORD(v8) = 1;
    HIDWORD(v23) = *((_DWORD *)a1 + 2) - (_DWORD)v14;
    v24 = 1;
    v10 = (fat_arch *)&v22;
  }
  v19 = NXFindBestFatArch(a2, a3, v10, v8);
  if (!v19)
  {
    v18 = 0;
    if (!v13)
      return v18;
    goto LABEL_16;
  }
  if (a4)
  {
    v20 = *(_OWORD *)&v19->cputype;
    *(_DWORD *)(a4 + 16) = v19->align;
    *(_OWORD *)a4 = v20;
  }
  v18 = 1;
  if (v13)
LABEL_16:
    free(v13);
  return v18;
}

char *fat_iterator_find_arch(int **a1, cpu_type_t a2, cpu_subtype_t a3, _QWORD *a4)
{
  char *result;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  if (!fat_iterator_find_fat_arch(a1, a2, a3, (uint64_t)&v7))
    return 0;
  result = (char *)*a1 + v8;
  if (a4)
    *a4 = &result[HIDWORD(v8)];
  return result;
}

char *fat_iterator_find_host_arch(int **a1, _QWORD *a2)
{
  char *result;

  result = (char *)NXGetLocalArchInfo();
  if (result)
    return fat_iterator_find_arch(a1, *((_DWORD *)result + 2), *((_DWORD *)result + 3), a2);
  return result;
}

uint64_t fat_iterator_file_start(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t fat_iterator_file_end(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t macho_find_symbol(int *a1, unint64_t a2, char *a3, _BYTE *a4, _QWORD *a5)
{
  uint64_t result;
  int v11;
  int v12;
  _BOOL4 v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  char *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  unsigned int v26;
  char *v27;
  unsigned __int8 *v28;
  char *v29;
  unint64_t v30;
  char *v31;
  unsigned int v32;
  BOOL v33;
  const char *v34;
  char v35;
  char *v36;
  int v37;
  unsigned int v38;
  uint64_t section_numbered;
  unint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unint64_t v43;
  _QWORD *v44;
  _BYTE *v45;
  char *__s1;
  char *v47;
  unint64_t v48;
  unsigned int v49;
  _DWORD *v50;

  if (a5)
    *a5 = 0;
  v50 = 0;
  if (macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_symtab, (uint64_t)&v50))return 2;
  v11 = *a1;
  v12 = *a1 + 822415874;
  v14 = *a1 != -17958193 && v11 != -805638658;
  v15 = v50[2];
  v49 = v12 & 0xFEFFFFFF;
  if ((v12 & 0xFEFFFFFF) != 0)
  {
    v16 = v50[3];
    v17 = v50[4];
  }
  else
  {
    v15 = bswap32(v15);
    v17 = bswap32(v50[4]);
    v16 = bswap32(v50[3]);
  }
  v18 = (char *)a1 + v15;
  if (v14)
    v19 = 12 * v16;
  else
    v19 = 16 * v16;
  if ((unint64_t)&v18[v19] > a2 || (unint64_t)a1 + v17 > a2)
    return 0xFFFFFFFFLL;
  if (!v16)
    return 2;
  __s1 = a3;
  v47 = (char *)a1 + v17;
  v44 = a5;
  v45 = a4;
  v21 = 0;
  v22 = v15;
  v23 = v16;
  for (i = v15; ; i += 12)
  {
    if (v11 == -17958193 || v11 == -805638658)
    {
      v26 = *(int *)((char *)a1 + v22);
      if (v49)
      {
        v27 = &v18[16 * v21];
        v28 = (unsigned __int8 *)(v27 + 4);
        v29 = v27 + 5;
        v30 = *(_QWORD *)((char *)a1 + v22 + 8);
      }
      else
      {
        v26 = bswap32(v26);
        v31 = &v18[16 * v21];
        v28 = (unsigned __int8 *)(v31 + 4);
        v29 = v31 + 5;
        v30 = bswap64(*(_QWORD *)((char *)a1 + v22 + 8));
      }
    }
    else
    {
      v26 = *(int *)((char *)a1 + i);
      if (v49)
      {
        LODWORD(v30) = *(int *)((char *)a1 + i + 8);
      }
      else
      {
        v26 = bswap32(v26);
        LODWORD(v30) = bswap32(*(int *)((char *)a1 + i + 8));
      }
      v28 = (unsigned __int8 *)a1 + i + 4;
      v29 = (char *)a1 + i + 5;
      v30 = v30;
    }
    v48 = v30;
    v32 = *v28;
    if (v26)
      v33 = v32 > 0x1F;
    else
      v33 = 1;
    if (v33)
      goto LABEL_49;
    v34 = &v47[v26];
    if ((unint64_t)v34 > a2)
      return 0xFFFFFFFFLL;
    v35 = *v29;
    v36 = v18;
    v37 = strcmp(__s1, v34);
    v18 = v36;
    if (v37)
      goto LABEL_49;
    if (v45)
      *v45 = v32;
    v38 = (v32 >> 1) & 7;
    if (v38 != 7)
      break;
    section_numbered = macho_find_section_numbered(a1, a2, v35);
    if (v44 && section_numbered)
    {
      if (v11 == -17958193 || v11 == -805638658)
      {
        v40 = *(_QWORD *)(section_numbered + 32);
        if (v49)
        {
          v41 = *(_DWORD *)(section_numbered + 48);
        }
        else
        {
          v40 = bswap64(v40);
          v41 = bswap32(*(_DWORD *)(section_numbered + 48));
        }
        result = 0;
        v43 = v48 - v40;
      }
      else
      {
        v42 = *(_DWORD *)(section_numbered + 32);
        if (v49)
        {
          v41 = *(_DWORD *)(section_numbered + 40);
        }
        else
        {
          v42 = bswap32(v42);
          v41 = bswap32(*(_DWORD *)(section_numbered + 40));
        }
        result = 0;
        v43 = v48 - v42;
      }
      *v44 = (char *)a1 + v41 + v43;
      return result;
    }
    v18 = v36;
    if (section_numbered)
      return 0;
LABEL_49:
    ++v21;
    v22 += 16;
    if (!--v23)
      return 2;
  }
  if (v38 <= 5 && ((1 << v38) & 0x23) != 0)
    return 1;
  return 2;
}

uint64_t macho_find_symtab(int *a1, unint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_symtab, (uint64_t)&v5);
  *a3 = 0;
  result = macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_symtab, (uint64_t)&v5);
  if (!(_DWORD)result)
    *a3 = v5;
  return result;
}

uint64_t macho_find_section_numbered(int *a1, unint64_t a2, char a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  BYTE1(v5) = a3;
  if (*a1 == -17958193 || *a1 == -805638658)
    LOBYTE(v5) = 1;
  if (macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_sect_in_lc, (uint64_t)&v5))return 0;
  else
    return v6;
}

uint64_t macho_scan_load_commands(int *a1, unint64_t a2, uint64_t (*a3)(int *, unint64_t, uint64_t, uint64_t), uint64_t a4)
{
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int *v13;
  unsigned int v14;
  unsigned int v15;
  int *v16;
  uint64_t v17;
  unsigned int v18;
  int *v19;
  int v21;

  v7 = *a1;
  v8 = 0xFFFFFFFFLL;
  if (*a1 <= -17958195)
  {
    if (v7 != -822415874)
    {
      if (v7 != -805638658)
        return v8;
      v9 = 0;
      v10 = 1;
      goto LABEL_7;
    }
    v9 = 0;
    v10 = 1;
LABEL_9:
    v11 = 3;
    v12 = 7;
    goto LABEL_10;
  }
  v10 = 0;
  v9 = 1;
  if (v7 == -17958194)
    goto LABEL_9;
  if (v7 != -17958193)
    return v8;
LABEL_7:
  v11 = 7;
  v12 = 8;
LABEL_10:
  if ((unint64_t)a1 < a2)
  {
    v13 = &a1[v12];
    if ((unint64_t)v13 <= a2)
    {
      v14 = a1[4];
      if ((v9 & 1) != 0)
      {
        v15 = a1[5];
      }
      else
      {
        v14 = bswap32(v14);
        v15 = bswap32(a1[5]);
      }
      v16 = (int *)((char *)v13 + v15);
      if ((unint64_t)v16 <= a2)
      {
        if (!v14)
          return 2;
        while (1)
        {
          LODWORD(v17) = v13[1];
          v18 = bswap32(v17);
          v17 = v9 ? v17 : v18;
          v19 = (int *)((char *)v13 + v17);
          if ((v17 & v11) != 0 || v19 > v16)
            break;
          v21 = a3(v13, a2, v10, a4);
          if (v21 != 2)
          {
            if (v21 == 3)
              LODWORD(v8) = 2;
            else
              LODWORD(v8) = -1;
            if (v21)
              return v8;
            else
              return 0;
          }
          v8 = 2;
          v13 = v19;
          if (!--v14)
            return v8;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v8;
}

uint64_t __macho_lc_is_symtab(int *a1, unint64_t a2, int a3, int **a4)
{
  uint64_t v4;
  int v5;
  unsigned int v6;

  if ((unint64_t)(a1 + 16) > a2)
    return 0xFFFFFFFFLL;
  v5 = *a1;
  if (a3)
  {
    if (v5 == 0x2000000)
    {
      v6 = bswap32(a1[1]);
      goto LABEL_8;
    }
    return 2;
  }
  if (v5 != 2)
    return 2;
  v6 = a1[1];
LABEL_8:
  if (v6 == 24 && (unint64_t)(a1 + 48) <= a2)
  {
    v4 = 0;
    *a4 = a1;
    return v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t macho_find_dysymtab(int *a1, unint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_dysymtab, (uint64_t)&v5);
  *a3 = 0;
  result = macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_dysymtab, (uint64_t)&v5);
  if (!(_DWORD)result)
    *a3 = v5;
  return result;
}

uint64_t __macho_lc_is_dysymtab(int *a1, unint64_t a2, int a3, int **a4)
{
  uint64_t v4;
  int v5;
  unsigned int v6;

  if ((unint64_t)(a1 + 16) > a2)
    return 0xFFFFFFFFLL;
  v5 = *a1;
  if (a3)
  {
    if (v5 == 184549376)
    {
      v6 = bswap32(a1[1]);
      goto LABEL_8;
    }
    return 2;
  }
  if (v5 != 11)
    return 2;
  v6 = a1[1];
LABEL_8:
  if (v6 == 80 && (unint64_t)(a1 + 160) <= a2)
  {
    v4 = 0;
    *a4 = a1;
    return v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t __uuid_callback(_DWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (*a1 != 27)
    return 2;
  if ((unint64_t)a1 + a1[1] > a2)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_DWORD *)a4 = 16;
  *(_QWORD *)(a4 + 8) = a1 + 2;
  return result;
}

uint64_t macho_find_uuid(int *a1, unint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  result = macho_scan_load_commands(a1, a2, __uuid_callback, (uint64_t)&v5);
  if (a3)
  {
    if (!(_DWORD)result)
      *a3 = v6;
  }
  return result;
}

uint64_t __macho_sect_in_lc(unsigned int *a1, unint64_t a2, int a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;

  v4 = *(unsigned __int8 *)(a4 + 2);
  v5 = *(unsigned __int8 *)(a4 + 1);
  if (v4 > v5)
    return 3;
  v7 = a1 + 16;
  if ((unint64_t)(a1 + 16) > a2)
    return 0xFFFFFFFFLL;
  v8 = *a1;
  v9 = bswap32(*a1);
  if (a3)
    v8 = v9;
  if (v8 == 1)
  {
    v12 = a1[1];
    if (a3)
    {
      v12 = bswap32(v12);
      v13 = bswap32(a1[12]);
    }
    else
    {
      v13 = a1[12];
    }
    v6 = 0xFFFFFFFFLL;
    if ((unint64_t)a1 + v12 <= a2 && 68 * v13 + 56 == v12)
    {
      if (v13)
      {
        v14 = a1 + 14;
        while (1)
        {
          LOBYTE(v4) = v4 + 1;
          if (v5 == v4)
            break;
          v14 += 17;
          if (!--v13)
          {
LABEL_28:
            *(_BYTE *)(a4 + 2) = v4;
            return 2;
          }
        }
        goto LABEL_31;
      }
      return 2;
    }
  }
  else
  {
    if (v8 != 25)
      return 2;
    v10 = a1[1];
    if (a3)
    {
      v10 = bswap32(v10);
      v11 = bswap32(*v7);
    }
    else
    {
      v11 = *v7;
    }
    v6 = 0xFFFFFFFFLL;
    if ((unint64_t)a1 + v10 <= a2 && 80 * v11 + 72 == v10)
    {
      if (v11)
      {
        v14 = a1 + 18;
        while (1)
        {
          LOBYTE(v4) = v4 + 1;
          if (v5 == v4)
            break;
          v14 += 20;
          if (!--v11)
            goto LABEL_28;
        }
LABEL_31:
        v6 = 0;
        *(_BYTE *)(a4 + 2) = v5;
        *(_QWORD *)(a4 + 8) = v14;
        return v6;
      }
      return 2;
    }
  }
  return v6;
}

uint64_t macho_find_source_version(int *a1, unint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  return macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__source_version_callback, (uint64_t)a3);
}

uint64_t __source_version_callback(uint64_t a1, unint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;

  if (*(_DWORD *)a1 != 42)
    return 2;
  if (a1 + (unint64_t)*(unsigned int *)(a1 + 4) > a2)
    return 0xFFFFFFFFLL;
  result = 0;
  *a4 = *(_QWORD *)(a1 + 8);
  return result;
}

uint64_t macho_swap(mach_header_64 *mh)
{
  uint64_t v2;
  uint32_t v3;
  uint64_t v4;
  segment_command *v5;
  unsigned int v6;
  uint32_t v7;
  uint64_t v8;
  segment_command_64 *v9;
  unsigned int v10;

  if (mh->magic == -805638658)
  {
    v2 = 1;
    swap_mach_header_64(mh, NX_LittleEndian);
    if (mh->ncmds)
    {
      v7 = 0;
      v8 = 32;
      do
      {
        v9 = (segment_command_64 *)((char *)mh + v8);
        v10 = *(int32_t *)((char *)&mh->cputype + v8);
        if (*(uint32_t *)((char *)&mh->magic + v8) == 419430400)
          swap_segment_command_64(v9, NX_LittleEndian);
        else
          swap_load_command((load_command *)v9, NX_LittleEndian);
        v8 += bswap32(v10);
        ++v7;
      }
      while (v7 < mh->ncmds);
      return 1;
    }
  }
  else
  {
    if (mh->magic != -822415874)
      return 0;
    v2 = 1;
    swap_mach_header((mach_header *)mh, NX_LittleEndian);
    if (mh->ncmds)
    {
      v3 = 0;
      v4 = 28;
      do
      {
        v5 = (segment_command *)((char *)mh + v4);
        v6 = *(int32_t *)((char *)&mh->cputype + v4);
        if (*(uint32_t *)((char *)&mh->magic + v4) == 0x1000000)
          swap_segment_command(v5, NX_LittleEndian);
        else
          swap_load_command((load_command *)v5, NX_LittleEndian);
        v4 += bswap32(v6);
        ++v3;
      }
      while (v3 < mh->ncmds);
      return 1;
    }
  }
  return v2;
}

uint64_t macho_unswap(mach_header_64 *mh)
{
  uint32_t v2;
  uint64_t v3;
  segment_command *v4;
  uint64_t v5;
  uint32_t v6;
  uint64_t v7;
  segment_command_64 *v8;
  uint64_t v9;

  if (mh->magic == -17958193)
  {
    if (mh->ncmds)
    {
      v6 = 0;
      v7 = 32;
      do
      {
        v8 = (segment_command_64 *)((char *)mh + v7);
        v9 = *(unsigned int *)((char *)&mh->cputype + v7);
        if (*(uint32_t *)((char *)&mh->magic + v7) == 25)
          swap_segment_command_64(v8, NX_BigEndian);
        else
          swap_load_command((load_command *)v8, NX_BigEndian);
        v7 += v9;
        ++v6;
      }
      while (v6 < mh->ncmds);
    }
    swap_mach_header_64(mh, NX_BigEndian);
    return 1;
  }
  if (mh->magic == -17958194)
  {
    if (mh->ncmds)
    {
      v2 = 0;
      v3 = 28;
      do
      {
        v4 = (segment_command *)((char *)mh + v3);
        v5 = *(unsigned int *)((char *)&mh->cputype + v3);
        if (*(uint32_t *)((char *)&mh->magic + v3) == 1)
          swap_segment_command(v4, NX_BigEndian);
        else
          swap_load_command((load_command *)v4, NX_BigEndian);
        v3 += v5;
        ++v2;
      }
      while (v2 < mh->ncmds);
    }
    swap_mach_header((mach_header *)mh, NX_BigEndian);
    return 1;
  }
  return 0;
}

char *macho_get_segment_by_name(_DWORD *a1, char *__s2)
{
  int v3;
  uint64_t v5;
  char *v6;

  if (*a1 != -17958194)
    return 0;
  v3 = a1[4];
  if (!v3)
    return 0;
  v5 = 28;
  while (1)
  {
    v6 = (char *)a1 + v5;
    if (*(_DWORD *)((char *)a1 + v5) == 1 && !strncmp(v6 + 8, __s2, 0x10uLL))
      break;
    v5 += *((unsigned int *)v6 + 1);
    if (!--v3)
      return 0;
  }
  return v6;
}

char *macho_get_segment_by_name_64(_DWORD *a1, char *__s2)
{
  int v3;
  uint64_t v5;
  char *v6;

  if (*a1 != -17958193)
    return 0;
  v3 = a1[4];
  if (!v3)
    return 0;
  v5 = 32;
  while (1)
  {
    v6 = (char *)a1 + v5;
    if (*(_DWORD *)((char *)a1 + v5) == 25 && !strncmp(v6 + 8, __s2, 0x10uLL))
      break;
    v5 += *((unsigned int *)v6 + 1);
    if (!--v3)
      return 0;
  }
  return v6;
}

char *macho_get_section_by_name(_DWORD *a1, char *a2, const char *a3)
{
  char *result;
  const char *v5;
  int v6;
  int v7;
  uint64_t v8;

  if (*a1 != -17958194)
    return 0;
  result = macho_get_segment_by_name(a1, a2);
  if (result)
  {
    v5 = result + 56;
    v6 = *((_DWORD *)result + 12);
    if (v6)
    {
      v7 = 0;
      v8 = (uint64_t)&result[68 * (v6 - 1) + 124];
      while (strncmp(v5, a3, 0x10uLL))
      {
        ++v7;
        v5 += 68;
        if (v6 == v7)
        {
          v5 = (const char *)v8;
          v7 = v6;
          break;
        }
      }
    }
    else
    {
      v7 = 0;
    }
    if (v7 == v6)
      return 0;
    else
      return (char *)v5;
  }
  return result;
}

char *macho_get_section_by_name_64(_DWORD *a1, char *a2, const char *a3)
{
  char *result;
  const char *v5;
  int v6;
  int v7;
  uint64_t v8;

  if (*a1 != -17958193)
    return 0;
  result = macho_get_segment_by_name_64(a1, a2);
  if (result)
  {
    v5 = result + 72;
    v6 = *((_DWORD *)result + 16);
    if (v6)
    {
      v7 = 0;
      v8 = (uint64_t)&result[80 * (v6 - 1) + 152];
      while (strncmp(v5, a3, 0x10uLL))
      {
        ++v7;
        v5 += 80;
        if (v6 == v7)
        {
          v5 = (const char *)v8;
          v7 = v6;
          break;
        }
      }
    }
    else
    {
      v7 = 0;
    }
    if (v7 == v6)
      return 0;
    else
      return (char *)v5;
  }
  return result;
}

uint64_t macho_remove_linkedit(mach_header_64 *a1, _QWORD *a2)
{
  int v4;
  int v5;
  mach_header_64 *p_reserved;
  uint32_t ncmds;
  mach_header_64 *v8;
  int magic;
  size_t cputype;
  uint64_t reserved;
  uint32_t v12;
  uint64_t v13;

  v4 = macho_swap(a1);
  v5 = v4;
  if (a1->magic == -17958193)
  {
    p_reserved = a1 + 1;
  }
  else
  {
    if (a1->magic != -17958194)
    {
      v13 = 0;
      if (!v4)
        return v13;
      goto LABEL_22;
    }
    p_reserved = (mach_header_64 *)&a1->reserved;
  }
  ncmds = a1->ncmds;
  if (ncmds)
  {
    v8 = p_reserved;
    do
    {
      magic = v8->magic;
      cputype = v8->cputype;
      if ((int)v8->magic > 10)
      {
        if (magic == 11)
          goto LABEL_19;
        if (magic == 25 && !strncmp((const char *)&v8->cpusubtype, "__LINKEDIT", 0xAuLL))
        {
          reserved = *(_QWORD *)&v8[1].magic;
LABEL_18:
          *a2 = reserved;
LABEL_19:
          v12 = a1->sizeofcmds - cputype;
          --a1->ncmds;
          a1->sizeofcmds = v12;
          bzero(v8, cputype);
          goto LABEL_20;
        }
      }
      else if (magic == 1)
      {
        if (!strncmp((const char *)&v8->cpusubtype, "__LINKEDIT", 0xAuLL))
        {
          reserved = v8->reserved;
          goto LABEL_18;
        }
      }
      else if (magic == 2)
      {
        goto LABEL_19;
      }
      memmove(p_reserved, v8, cputype);
      p_reserved = (mach_header_64 *)((char *)p_reserved + cputype);
LABEL_20:
      v8 = (mach_header_64 *)((char *)v8 + cputype);
      --ncmds;
    }
    while (ncmds);
  }
  v13 = 1;
  if (v5)
LABEL_22:
    macho_unswap(a1);
  return v13;
}

uint64_t macho_trim_linkedit(mach_header_64 *a1, _QWORD *a2)
{
  int v4;
  mach_header_64 *p_reserved;
  uint32_t ncmds;
  mach_header_64 *v7;
  unsigned int *p_magic;
  mach_header_64 *v9;
  uint32_t v10;
  mach_header_64 *v11;
  int v12;
  uint64_t cputype;
  unsigned int v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  unint64_t reserved;
  unint64_t v20;
  uint64_t v21;
  uint64_t cpusubtype;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int *v26;
  size_t v27;
  uint32_t v28;
  _QWORD *v29;
  uint32_t magic;
  int v31;

  *a2 = 0;
  v4 = macho_swap(a1);
  if (a1->magic == -17958194)
  {
    p_reserved = (mach_header_64 *)&a1->reserved;
  }
  else
  {
    if (a1->magic != -17958193)
      goto LABEL_27;
    p_reserved = a1 + 1;
  }
  ncmds = a1->ncmds;
  if (!ncmds)
  {
LABEL_27:
    v17 = 0;
    if (!v4)
      return v17;
    goto LABEL_30;
  }
  magic = a1->magic;
  v31 = v4;
  v29 = a2;
  v7 = 0;
  p_magic = 0;
  v9 = 0;
  v10 = a1->ncmds;
  v11 = p_reserved;
  do
  {
    v12 = v11->magic;
    cputype = v11->cputype;
    if ((int)v11->magic > 10)
    {
      if (v12 == 11)
      {
        v7 = v11;
        goto LABEL_18;
      }
      if (v12 != 25)
        goto LABEL_18;
    }
    else if (v12 != 1)
    {
      if (v12 == 2)
        p_magic = &v11->magic;
      goto LABEL_18;
    }
    if (!strncmp((const char *)&v11->cpusubtype, "__LINKEDIT", 0xAuLL))
      v9 = v11;
LABEL_18:
    v11 = (mach_header_64 *)((char *)v11 + cputype);
    --v10;
  }
  while (v10);
  if (!v9)
    goto LABEL_29;
  if (v7)
  {
    if (p_magic)
    {
      v14 = 16;
      v15 = 8 * v7[2].filetype;
      if (magic == -17958194)
        v14 = 12;
      v16 = (p_magic[5] + v14 * (unint64_t)p_magic[3] + 7) & 0x3FFFFFFFF8;
      if (magic == -17958194)
        reserved = v9->reserved;
      else
        reserved = *(_QWORD *)&v9[1].magic;
      v20 = roundPageCrossSafe(8 * v7[2].filetype);
      v21 = p_magic[2];
      cpusubtype = v7[2].cpusubtype;
      v23 = (char *)a1 + v21;
      if (v21 < cpusubtype)
      {
        memmove(v23, (char *)a1 + cpusubtype, v15);
        v24 = p_magic[2];
        v7[2].cpusubtype = v24;
        v23 = (char *)a1 + v24 + v15;
      }
      bzero(v23, v16);
      if (v20 >= reserved)
        v25 = reserved;
      else
        v25 = v20;
      if (magic == -17958194)
      {
        v9[1].cputype = v25;
        v9->reserved = v25;
      }
      else
      {
        *(_QWORD *)&v9[1].ncmds = v25;
        *(_QWORD *)&v9[1].magic = v25;
      }
      *v29 = reserved - v25;
      v26 = &p_reserved->magic;
      do
      {
        v27 = v26[1];
        if (*v26 == 2)
        {
          v28 = a1->sizeofcmds - v27;
          --a1->ncmds;
          a1->sizeofcmds = v28;
          bzero(v26, v27);
        }
        else
        {
          if (p_reserved != (mach_header_64 *)v26)
            memmove(p_reserved, v26, v26[1]);
          p_reserved = (mach_header_64 *)((char *)p_reserved + v27);
        }
        v26 = (unsigned int *)((char *)v26 + v27);
        --ncmds;
      }
      while (ncmds);
      v17 = 1;
      if (!v31)
        return v17;
LABEL_30:
      macho_unswap(a1);
      return v17;
    }
LABEL_29:
    v17 = 0;
    if (!v31)
      return v17;
    goto LABEL_30;
  }
  if (v31)
    macho_unswap(a1);
  return macho_remove_linkedit(a1, v29);
}

__CFString *IOHIDDeviceCopyDescription(io_object_t *a1)
{
  io_registry_entry_t v2;
  io_registry_entry_t v3;
  const __CFAllocator *v4;
  __CFString *Mutable;
  const __CFAllocator *v6;
  CFAllocatorRef v7;
  const __CFString *v8;
  uint64_t v9;
  const __CFString *v10;
  const __CFNumber *Property;
  const __CFNumber *v12;
  CFTypeID v13;
  const __CFAllocator *v14;
  CFStringRef v15;
  CFTypeID v16;
  const __CFAllocator *v17;
  io_registry_entry_t v19;
  unsigned int valuePtr;
  io_name_t name;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  memset(name, 0, sizeof(name));
  v2 = a1[2];
  if (v2)
  {
    if (IOObjectRetain(a1[2]))
      v3 = 0;
    else
      v3 = v2;
  }
  else
  {
    v3 = 0;
  }
  v4 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v4, 0);
  if (Mutable)
  {
    IORegistryEntryGetName(v3, name);
    if (!name[0])
      IOObjectGetClass(v3, name);
    v19 = v3;
    v6 = CFGetAllocator(a1);
    v7 = CFGetAllocator(a1);
    v8 = CFStringCreateWithFormat(v6, 0, CFSTR("<IOHIDDevice %p [%p]  'ClassName=%s'"), a1, v7, name);
    if (v8)
    {
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
    }
    v9 = 0;
    while (1)
    {
      v10 = __debugKeys[v9];
      Property = (const __CFNumber *)IOHIDDeviceGetProperty((IOHIDDeviceRef)a1, v10);
      if (Property)
        break;
LABEL_20:
      if (++v9 == 12)
      {
        CFStringAppend(Mutable, CFSTR(">"));
        v3 = v19;
        goto LABEL_22;
      }
    }
    v12 = Property;
    v13 = CFGetTypeID(Property);
    if (v13 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
      v14 = CFGetAllocator(a1);
      v15 = CFStringCreateWithFormat(v14, 0, CFSTR(" %@=%d"), v10, valuePtr);
    }
    else
    {
      v16 = CFGetTypeID(v12);
      if (v16 != CFStringGetTypeID())
        goto LABEL_18;
      v17 = CFGetAllocator(a1);
      v15 = CFStringCreateWithFormat(v17, 0, CFSTR(" %@=%@"), v10, v12);
    }
    v8 = v15;
LABEL_18:
    if (v8)
    {
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
    }
    goto LABEL_20;
  }
LABEL_22:
  if (v3)
    IOObjectRelease(v3);
  return Mutable;
}

CFTypeRef IOHIDDeviceGetProperty(IOHIDDeviceRef device, CFStringRef key)
{
  BOOL v4;
  const __CFDictionary *v5;
  const void *Value;

  Value = 0;
  os_unfair_recursive_lock_lock_with_options();
  if ((*(unsigned int (**)(_QWORD, CFStringRef, const void **))(**((_QWORD **)device + 3) + 48))(*((_QWORD *)device + 3), key, &Value))
  {
    v4 = 1;
  }
  else
  {
    v4 = Value == 0;
  }
  if (v4)
  {
    v5 = (const __CFDictionary *)*((_QWORD *)device + 7);
    if (v5)
      Value = CFDictionaryGetValue(v5, key);
    else
      Value = 0;
  }
  os_unfair_recursive_lock_unlock();
  return Value;
}

void _IOHIDDeviceReleasePrivate(uint64_t a1)
{
  unsigned int v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  io_object_t v13;
  io_object_t v14;
  IONotificationPort *v15;
  IOCFPlugInInterface **v16;
  const void *v18;
  const void *v20;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  uint64_t v26;
  _OWORD v27[5];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 208))
  {
    v2 = atomic_load((unsigned int *)(a1 + 224));
    if (v2 != 3)
      _IOHIDDeviceReleasePrivate_cold_1(&v26, v27, (unsigned int *)(a1 + 224));
  }
  v3 = *(const void **)(a1 + 240);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 248);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 248) = 0;
  }
  v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v6 = *(const void **)(a1 + 64);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v7 = *(const void **)(a1 + 72);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v8 = *(const void **)(a1 + 296);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 296) = 0;
  }
  v9 = *(const void **)(a1 + 312);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 312) = 0;
  }
  v10 = *(const void **)(a1 + 304);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 304) = 0;
  }
  v11 = *(_QWORD *)(a1 + 24);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v12 = *(_QWORD *)(a1 + 32);
  if (v12)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v13 = *(_DWORD *)(a1 + 8);
  if (v13)
  {
    IOObjectRelease(v13);
    *(_DWORD *)(a1 + 8) = 0;
  }
  v14 = *(_DWORD *)(a1 + 96);
  if (v14)
  {
    IOObjectRelease(v14);
    *(_DWORD *)(a1 + 96) = 0;
  }
  v15 = *(IONotificationPort **)(a1 + 88);
  if (v15)
  {
    IONotificationPortDestroy(v15);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v16 = *(IOCFPlugInInterface ***)(a1 + 40);
  if (v16)
  {
    IODestroyPlugInInterface(v16);
    *(_QWORD *)(a1 + 40) = 0;
  }
  if (atomic_load((unint64_t *)(a1 + 320)))
  {
    v18 = (const void *)atomic_load((unint64_t *)(a1 + 320));
    _Block_release(v18);
  }
  if (atomic_load((unint64_t *)(a1 + 328)))
  {
    v20 = (const void *)atomic_load((unint64_t *)(a1 + 328));
    _Block_release(v20);
  }
  if (atomic_load((unint64_t *)(a1 + 336)))
  {
    v22 = (const void *)atomic_load((unint64_t *)(a1 + 336));
    _Block_release(v22);
  }
  v23 = *(const void **)(a1 + 280);
  if (v23)
    CFRelease(v23);
  v24 = *(const void **)(a1 + 264);
  if (v24)
    CFRelease(v24);
  v25 = *(const void **)(a1 + 288);
  if (v25)
    CFRelease(v25);
}

uint64_t _IOHIDDeviceGetIOCFPlugInInterface(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

IOHIDDeviceRef IOHIDDeviceCreate(CFAllocatorRef allocator, io_service_t service)
{
  uint64_t v3;
  const __CFUUID *v4;
  const __CFUUID *v5;
  kern_return_t v6;
  IOCFPlugInInterface **v7;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFUUID *v9;
  CFUUIDBytes v10;
  uint64_t v11;
  IOCFPlugInInterface **v12;
  HRESULT (__cdecl *v13)(void *, REFIID, LPVOID *);
  const __CFUUID *v14;
  CFUUIDBytes v15;
  HIDDevice *Private;
  __IOHIDDevice *v17;
  IOCFPlugInInterface **v18;
  IOHIDDeviceTimeStampedDeviceInterface **v19;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t entryID;
  SInt32 theScore;
  IOHIDDeviceTimeStampedDeviceInterface **v41;
  IOHIDDeviceDeviceInterface **v42;
  IOCFPlugInInterface **theInterface;

  theInterface = 0;
  v41 = 0;
  v42 = 0;
  theScore = 0;
  entryID = 0;
  if (__deviceInit != -1)
    dispatch_once(&__deviceInit, &__block_literal_global_6);
  v3 = IOObjectRetain(service);
  if ((_DWORD)v3)
  {
    v21 = v3;
    v22 = _IOHIDLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      IOHIDDeviceCreate_cold_3(v21, v22, v23, v24, v25, v26, v27, v28);
    return 0;
  }
  IORegistryEntryGetRegistryEntryID(service, &entryID);
  v4 = CFUUIDGetConstantUUIDWithBytes(0, 0x7Du, 0xDEu, 0xECu, 0xA8u, 0xA7u, 0xB4u, 0x11u, 0xDAu, 0x8Au, 0xEu, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  v5 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  v6 = IOCreatePlugInInterfaceForService(service, v4, v5, &theInterface, &theScore);
  if (v6)
  {
    v29 = v6;
    v30 = _IOHIDLog();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      IOHIDDeviceCreate_cold_2((uint64_t *)&entryID, v29, v30);
    goto LABEL_22;
  }
  v7 = theInterface;
  QueryInterface = (*theInterface)->QueryInterface;
  v9 = CFUUIDGetConstantUUIDWithBytes(0, 0x47u, 0x4Bu, 0xDCu, 0x8Eu, 0x9Fu, 0x4Au, 0x11u, 0xDAu, 0xB3u, 0x66u, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
  v10 = CFUUIDGetUUIDBytes(v9);
  v11 = ((uint64_t (*)(IOCFPlugInInterface **, _QWORD, _QWORD, IOHIDDeviceDeviceInterface ***))QueryInterface)(v7, *(_QWORD *)&v10.byte0, *(_QWORD *)&v10.byte8, &v42);
  if ((_DWORD)v11)
  {
    v31 = v11;
    v32 = _IOHIDLog();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      IOHIDDeviceCreate_cold_1(v31, v32, v33, v34, v35, v36, v37, v38);
    goto LABEL_21;
  }
  v12 = theInterface;
  v13 = (*theInterface)->QueryInterface;
  v14 = CFUUIDGetConstantUUIDWithBytes(0, 0xB4u, 0x73u, 0x25u, 0x6Cu, 0x6Au, 0x72u, 0x4Eu, 4u, 0xB6u, 0x94u, 0xC4u, 0, 0x1Du, 0x20u, 0x20u, 0x20u);
  v15 = CFUUIDGetUUIDBytes(v14);
  if (((unsigned int (*)(IOCFPlugInInterface **, _QWORD, _QWORD, IOHIDDeviceTimeStampedDeviceInterface ***))v13)(v12, *(_QWORD *)&v15.byte0, *(_QWORD *)&v15.byte8, &v41))
  {
    v41 = 0;
  }
  Private = _IOHIDDeviceCreatePrivate();
  if (!Private)
  {
    if (v42)
      ((void (*)(IOHIDDeviceDeviceInterface **))(*v42)->Release)(v42);
    if (v41)
      ((void (*)(IOHIDDeviceDeviceInterface **))(*v41)->Release)(v42);
LABEL_21:
    IODestroyPlugInInterface(theInterface);
LABEL_22:
    IOObjectRelease(service);
    return 0;
  }
  v17 = (__IOHIDDevice *)Private;
  v18 = theInterface;
  v19 = v41;
  Private->_device.deviceInterface = v42;
  Private->_device.deviceTimeStampedInterface = v19;
  Private->_device.plugInInterface = v18;
  Private->_device.service = service;
  Private->_device.deviceLock = 0;
  Private->_device.callbackLock = 0;
  IORegistryEntryGetRegistryEntryID(service, &Private->_device.regID);
  return v17;
}

BOOL __IOHIDDeviceCallbackBaseDataIsEqual(CFDataRef theData, const __CFData *a2)
{
  _BOOL8 result;
  const UInt8 *BytePtr;
  const UInt8 *v6;

  if (theData == a2)
    return 1;
  result = 0;
  if (theData)
  {
    if (a2)
    {
      BytePtr = CFDataGetBytePtr(theData);
      v6 = CFDataGetBytePtr(a2);
      result = 0;
      if (BytePtr)
      {
        if (v6)
          return *(_QWORD *)BytePtr == *(_QWORD *)v6;
      }
    }
  }
  return result;
}

io_service_t IOHIDDeviceGetService(IOHIDDeviceRef device)
{
  return *((_DWORD *)device + 2);
}

IOReturn IOHIDDeviceOpen(IOHIDDeviceRef device, IOOptionBits options)
{
  uint64_t v2;

  v2 = *(_QWORD *)&options;
  os_unfair_recursive_lock_lock_with_options();
  LODWORD(v2) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)device + 3) + 32))(*((_QWORD *)device + 3), v2);
  os_unfair_recursive_lock_unlock();
  return v2;
}

IOReturn IOHIDDeviceClose(IOHIDDeviceRef device, IOOptionBits options)
{
  uint64_t v2;

  v2 = *(_QWORD *)&options;
  os_unfair_recursive_lock_lock_with_options();
  LODWORD(v2) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)device + 3) + 40))(*((_QWORD *)device + 3), v2);
  os_unfair_recursive_lock_unlock();
  return v2;
}

Boolean IOHIDDeviceConformsTo(IOHIDDeviceRef device, uint32_t usagePage, uint32_t usage)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  const __CFAllocator *v9;
  CFNumberRef v10;
  const __CFAllocator *v11;
  CFNumberRef v12;
  const __CFAllocator *v13;
  CFNumberRef v14;
  const __CFArray *v15;
  const __CFArray *v16;
  CFIndex Count;
  CFIndex v18;
  CFIndex v19;
  __IOHIDElement *ValueAtIndex;
  Boolean v21;
  uint32_t valuePtr;

  v6 = CFGetAllocator(device);
  Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v8 = Mutable;
  valuePtr = 513;
  v9 = CFGetAllocator(device);
  v10 = CFNumberCreate(v9, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v8, CFSTR("Type"), v10);
  CFRelease(v10);
  valuePtr = usagePage;
  v11 = CFGetAllocator(device);
  v12 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v8, CFSTR("UsagePage"), v12);
  CFRelease(v12);
  valuePtr = usage;
  v13 = CFGetAllocator(device);
  v14 = CFNumberCreate(v13, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v8, CFSTR("Usage"), v14);
  CFRelease(v14);
  v15 = IOHIDDeviceCopyMatchingElements(device, v8, 0);
  if (v15)
  {
    v16 = v15;
    Count = CFArrayGetCount(v15);
    if (Count < 1)
    {
LABEL_8:
      v21 = 0;
    }
    else
    {
      v18 = Count;
      v19 = 0;
      while (1)
      {
        ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(v16, v19);
        if (IOHIDElementGetCollectionType(ValueAtIndex) == kIOHIDElementCollectionTypePhysical
          || IOHIDElementGetCollectionType(ValueAtIndex) == kIOHIDElementCollectionTypeApplication)
        {
          break;
        }
        if (v18 == ++v19)
          goto LABEL_8;
      }
      v21 = 1;
    }
    CFRelease(v16);
  }
  else
  {
    v21 = 0;
  }
  CFRelease(v8);
  return v21;
}

CFArrayRef IOHIDDeviceCopyMatchingElements(IOHIDDeviceRef device, CFDictionaryRef matching, IOOptionBits options)
{
  BOOL v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const CFSetCallBacks *v8;
  const void *ValueAtIndex;
  const __CFSet *Mutable;
  const __CFAllocator *v11;
  CFArrayRef theArray;

  theArray = 0;
  if ((*(unsigned int (**)(_QWORD, CFDictionaryRef, CFArrayRef *, _QWORD))(**((_QWORD **)device + 3) + 72))(*((_QWORD *)device + 3), matching, &theArray, *(_QWORD *)&options))
  {
    v4 = theArray == 0;
  }
  else
  {
    v4 = 1;
  }
  if (v4)
  {
    if (theArray)
    {
      Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        v6 = Count;
        v7 = 0;
        v8 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
          _IOHIDElementSetDevice((uint64_t)ValueAtIndex, (uint64_t)device);
          os_unfair_recursive_lock_lock_with_options();
          Mutable = (const __CFSet *)*((_QWORD *)device + 8);
          if (Mutable
            || (v11 = CFGetAllocator(device),
                Mutable = CFSetCreateMutable(v11, 0, v8),
                (*((_QWORD *)device + 8) = Mutable) != 0))
          {
            if (!CFSetContainsValue(Mutable, ValueAtIndex))
            {
              CFSetSetValue(*((CFMutableSetRef *)device + 8), ValueAtIndex);
              if (*((_BYTE *)device + 256))
                __IOHIDElementLoadProperties((uint64_t)ValueAtIndex);
            }
          }
          os_unfair_recursive_lock_unlock();
          ++v7;
        }
        while (v6 != v7);
      }
    }
  }
  else
  {
    CFRelease(theArray);
    return 0;
  }
  return theArray;
}

Boolean IOHIDDeviceSetProperty(IOHIDDeviceRef device, CFStringRef key, CFTypeRef property)
{
  __CFDictionary *Mutable;
  const __CFAllocator *v7;
  CFTypeID v8;
  __IOHIDQueue *v9;

  os_unfair_recursive_lock_lock_with_options();
  Mutable = (__CFDictionary *)*((_QWORD *)device + 7);
  if (Mutable
    || (v7 = CFGetAllocator(device),
        Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
        (*((_QWORD *)device + 7) = Mutable) != 0))
  {
    *((_BYTE *)device + 257) = 1;
    CFDictionarySetValue(Mutable, key, property);
    if (CFEqual(key, CFSTR("IOHIDDeviceSuspend")))
    {
      v8 = CFGetTypeID(property);
      if (v8 == CFBooleanGetTypeID())
      {
        v9 = (__IOHIDQueue *)*((_QWORD *)device + 30);
        if (v9)
        {
          if ((CFTypeRef)*MEMORY[0x1E0C9AE50] == property)
            IOHIDQueueStop(v9);
          else
            IOHIDQueueStart(v9);
        }
      }
    }
    os_unfair_recursive_lock_unlock();
    return (*(unsigned int (**)(_QWORD, CFStringRef, CFTypeRef))(**((_QWORD **)device + 3) + 56))(*((_QWORD *)device + 3), key, property) == 0;
  }
  else
  {
    os_unfair_recursive_lock_unlock();
    return 0;
  }
}

void IOHIDDeviceScheduleWithRunLoop(IOHIDDeviceRef device, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  __CFRunLoop *v6;
  const __CFString *v7;
  __CFRunLoopSource *RunLoopSource;
  __IOHIDQueue *v9;

  os_unfair_recursive_lock_lock_with_options();
  if (*((_QWORD *)device + 24))
    IOHIDDeviceUnscheduleFromRunLoop(device, v6, v7);
  __IOHIDDeviceSetupAsyncSupport((uint64_t)device);
  *((_QWORD *)device + 24) = runLoop;
  *((_QWORD *)device + 25) = runLoopMode;
  CFRunLoopAddSource(runLoop, *((CFRunLoopSourceRef *)device + 13), runLoopMode);
  RunLoopSource = IONotificationPortGetRunLoopSource(*((IONotificationPortRef *)device + 11));
  if (RunLoopSource)
    CFRunLoopAddSource(*((CFRunLoopRef *)device + 24), RunLoopSource, *((CFRunLoopMode *)device + 25));
  v9 = (__IOHIDQueue *)*((_QWORD *)device + 30);
  os_unfair_recursive_lock_unlock();
  if (v9)
  {
    IOHIDQueueScheduleWithRunLoop(v9, runLoop, runLoopMode);
    IOHIDQueueStart(v9);
  }
}

void IOHIDDeviceUnscheduleFromRunLoop(IOHIDDeviceRef device, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  __CFRunLoop *v4;
  __IOHIDQueue *v5;
  const __CFString *v6;
  IONotificationPort *v7;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoopSource *v9;

  os_unfair_recursive_lock_lock_with_options();
  v4 = (__CFRunLoop *)*((_QWORD *)device + 24);
  if (v4)
  {
    v5 = (__IOHIDQueue *)*((_QWORD *)device + 30);
    v6 = (const __CFString *)*((_QWORD *)device + 25);
    os_unfair_recursive_lock_unlock();
    if (v5)
    {
      IOHIDQueueStop(v5);
      IOHIDQueueUnscheduleFromRunLoop(v5, v4, v6);
    }
    os_unfair_recursive_lock_lock_with_options();
    v7 = (IONotificationPort *)*((_QWORD *)device + 11);
    if (v7)
    {
      RunLoopSource = IONotificationPortGetRunLoopSource(v7);
      if (RunLoopSource)
        CFRunLoopRemoveSource(*((CFRunLoopRef *)device + 24), RunLoopSource, *((CFRunLoopMode *)device + 25));
    }
    v9 = (__CFRunLoopSource *)*((_QWORD *)device + 13);
    if (v9)
      CFRunLoopRemoveSource(*((CFRunLoopRef *)device + 24), v9, *((CFRunLoopMode *)device + 25));
    *((_QWORD *)device + 24) = 0;
    *((_QWORD *)device + 25) = 0;
  }
  os_unfair_recursive_lock_unlock();
}

void __IOHIDDeviceSetupAsyncSupport(uint64_t a1)
{
  int v2;
  void (__cdecl *perform)(void *);
  BOOL v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  IONotificationPortRef v8;
  int v9;
  CFRunLoopSourceContext context;
  uint64_t v11;
  __int16 v12;
  void (__cdecl *v13)(void *);
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  memset(&context.info, 0, 72);
  context.version = 1;
  if (*(_QWORD *)(a1 + 192) || *(_QWORD *)(a1 + 208))
    __IOHIDDeviceSetupAsyncSupport_cold_3();
  if (!*(_QWORD *)(a1 + 104))
  {
    v2 = (*(uint64_t (**)(_QWORD, void (__cdecl **)(void *)))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24), &context.perform);
    perform = context.perform;
    if (v2)
      v4 = 1;
    else
      v4 = context.perform == 0;
    if (v4)
    {
      v9 = v2;
      memset(v14, 0, sizeof(v14));
      os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      LODWORD(v11) = 67109376;
      HIDWORD(v11) = v9;
      v12 = 2048;
      v13 = perform;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      *(_QWORD *)(a1 + 104) = context.perform;
      CFRunLoopSourceGetContext((CFRunLoopSourceRef)perform, &context);
      v5 = *(_OWORD *)&context.retain;
      *(_OWORD *)(a1 + 112) = *(_OWORD *)&context.version;
      *(_OWORD *)(a1 + 128) = v5;
      v6 = *(_OWORD *)&context.hash;
      *(_OWORD *)(a1 + 144) = *(_OWORD *)&context.copyDescription;
      *(_OWORD *)(a1 + 160) = v6;
      v7 = *(_QWORD *)(a1 + 120);
      *(_QWORD *)(a1 + 176) = context.cancel;
      *(_QWORD *)(a1 + 184) = v7;
      if (v7)
      {
        if (!*(_QWORD *)(a1 + 88))
        {
          v8 = IONotificationPortCreate(0);
          *(_QWORD *)(a1 + 88) = v8;
          if (!v8)
            __IOHIDDeviceSetupAsyncSupport_cold_2(&v11, v14);
        }
        return;
      }
    }
    __IOHIDDeviceSetupAsyncSupport_cold_1(&v11, v14);
  }
}

void IOHIDDeviceSetDispatchQueue(IOHIDDeviceRef device, dispatch_queue_t queue)
{
  const char *label;
  const char *v5;
  dispatch_queue_t v6;
  uint64_t v7;
  uint64_t v8;
  __IOHIDQueue *v9;
  __IOHIDQueue *v10;
  _QWORD handler[10];
  char __str[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  __IOHIDDeviceSetupAsyncSupport((uint64_t)device);
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)__str = 0u;
  v13 = 0u;
  label = dispatch_queue_get_label(queue);
  v5 = "";
  if (label)
    v5 = label;
  snprintf(__str, 0x100uLL, "%s.IOHIDDeviceRef:0x%llx", v5, *((_QWORD *)device + 2));
  v6 = dispatch_queue_create_with_target_V2(__str, 0, queue);
  *((_QWORD *)device + 26) = v6;
  if (v6)
  {
    CFRetain(device);
    v7 = MEMORY[0x1E0C809B0];
    handler[5] = MEMORY[0x1E0C809B0];
    handler[6] = 0x40000000;
    handler[7] = __IOHIDDeviceSetDispatchQueue_block_invoke;
    handler[8] = &__block_descriptor_tmp_19;
    handler[9] = device;
    v8 = dispatch_mach_create();
    *((_QWORD *)device + 27) = v8;
    if (v8)
    {
      v9 = (__IOHIDQueue *)*((_QWORD *)device + 30);
      if (v9)
      {
        IOHIDQueueSetDispatchQueue(v9, *((dispatch_queue_t *)device + 26));
        CFRetain(device);
        v10 = (__IOHIDQueue *)*((_QWORD *)device + 30);
        handler[0] = v7;
        handler[1] = 0x40000000;
        handler[2] = __IOHIDDeviceSetDispatchQueue_block_invoke_2;
        handler[3] = &__block_descriptor_tmp_20_0;
        handler[4] = device;
        IOHIDQueueSetCancelHandler(v10, handler);
      }
    }
    else
    {
      CFRelease(device);
    }
  }
  os_unfair_recursive_lock_unlock();
}

void IOHIDDeviceSetCancelHandler(IOHIDDeviceRef device, dispatch_block_t handler)
{
  uint64_t v4;
  _OWORD v5[5];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (!handler || *((_QWORD *)device + 29))
    IOHIDDeviceSetCancelHandler_cold_1(&v4, v5);
  *((_QWORD *)device + 29) = _Block_copy(handler);
  os_unfair_recursive_lock_unlock();
}

void IOHIDDeviceActivate(IOHIDDeviceRef device)
{
  BOOL v1;
  IOHIDDeviceRef v2;
  unsigned int *v3;
  unsigned int v4;
  __IOHIDQueue *v5;

  if (*((_QWORD *)device + 26))
    v1 = *((_QWORD *)device + 24) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    device = (IOHIDDeviceRef)_os_crash_msg();
    __break(1u);
  }
  v2 = device;
  v3 = (unsigned int *)((char *)device + 224);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if ((v4 & 1) == 0)
  {
    CFMachPortGetPort(*((CFMachPortRef *)device + 23));
    dispatch_mach_connect();
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)v2 + 11), *((dispatch_queue_t *)v2 + 26));
    v5 = (__IOHIDQueue *)*((_QWORD *)v2 + 30);
    if (v5)
      IOHIDQueueActivate(v5);
  }
}

void IOHIDDeviceCancel(IOHIDDeviceRef device)
{
  BOOL v1;
  IOHIDDeviceRef v2;
  unsigned int *v3;
  unsigned int v4;
  IONotificationPort *v5;
  __IOHIDQueue *v6;

  if (*((_QWORD *)device + 26))
    v1 = *((_QWORD *)device + 24) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    device = (IOHIDDeviceRef)_os_crash_msg();
    __break(1u);
  }
  v2 = device;
  v3 = (unsigned int *)((char *)device + 224);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 2, v3));
  if ((v4 & 2) == 0)
  {
    dispatch_mach_cancel();
    v5 = (IONotificationPort *)*((_QWORD *)v2 + 11);
    if (v5)
    {
      IONotificationPortDestroy(v5);
      *((_QWORD *)v2 + 11) = 0;
    }
    v6 = (__IOHIDQueue *)*((_QWORD *)v2 + 30);
    if (v6)
      IOHIDQueueCancel(v6);
  }
}

void IOHIDDeviceRegisterRemovalCallback(IOHIDDeviceRef device, IOHIDCallback callback, void *context)
{
  CFMutableSetRef Mutable;
  const __CFAllocator *v7;
  CFDataRef v8;
  CFDataRef v9;
  __CFSet *v10;
  IONotificationPort *v11;
  __CFRunLoopSource *RunLoopSource;
  _QWORD v13[2];

  v13[0] = context;
  v13[1] = callback;
  if (atomic_load((unsigned int *)device + 56))
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  if ((*((_QWORD *)device + 37)
     || (Mutable = CFSetCreateMutable(0, 0, (const CFSetCallBacks *)&__callbackBaseSetCallbacks),
         (*((_QWORD *)device + 37) = Mutable) != 0))
    && (v7 = CFGetAllocator(device), (v8 = CFDataCreate(v7, (const UInt8 *)v13, 16)) != 0))
  {
    v9 = v8;
    v10 = (__CFSet *)*((_QWORD *)device + 37);
    if (callback)
    {
      CFSetAddValue(v10, v9);
      v11 = (IONotificationPort *)*((_QWORD *)device + 11);
      if (v11
        || (v11 = IONotificationPortCreate(0), (*((_QWORD *)device + 11) = v11) != 0) && *((_DWORD *)device + 2))
      {
        if (*((_QWORD *)device + 24))
        {
          RunLoopSource = IONotificationPortGetRunLoopSource(v11);
          if (RunLoopSource)
            CFRunLoopAddSource(*((CFRunLoopRef *)device + 24), RunLoopSource, *((CFRunLoopMode *)device + 25));
        }
        if (!*((_DWORD *)device + 24))
          IOServiceAddInterestNotification(*((IONotificationPortRef *)device + 11), *((_DWORD *)device + 2), "IOGeneralInterest", (IOServiceInterestCallback)__IOHIDDeviceNotification, device, (io_object_t *)device + 24);
      }
    }
    else
    {
      CFSetRemoveValue(v10, v9);
    }
    os_unfair_recursive_lock_unlock();
    CFRelease(v9);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void __IOHIDDeviceNotification(CFSetRef *a1, uint64_t a2, int a3)
{
  const __CFSet *v4;
  CFIndex Count;
  uint64_t v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  CFDataRef *v10;
  size_t v11;
  const UInt8 *BytePtr;
  void (*v13)(_QWORD, _QWORD, CFSetRef *);
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  if (a1 && a3 == -536870896)
  {
    os_unfair_recursive_lock_lock_with_options();
    v4 = a1[37];
    if (v4 && (Count = CFSetGetCount(v4)) != 0)
    {
      v6 = Count;
      v7 = CFRetain(a1);
      v8 = 8 * v6;
      MEMORY[0x1E0C80A78](v7, v9);
      v10 = (CFDataRef *)((char *)v14 - ((8 * v6 + 15) & 0xFFFFFFFFFFFFFFF0));
      if ((unint64_t)(8 * v6) >= 0x200)
        v11 = 512;
      else
        v11 = 8 * v6;
      bzero((char *)v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v11);
      bzero((char *)v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), 8 * v6);
      CFSetGetValues(a1[37], (const void **)((char *)v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0)));
      if (v6 >= 1)
      {
        do
        {
          if (*v10)
          {
            BytePtr = CFDataGetBytePtr(*v10);
            if (BytePtr)
            {
              v13 = (void (*)(_QWORD, _QWORD, CFSetRef *))*((_QWORD *)BytePtr + 1);
              if (v13)
                v13(*(_QWORD *)BytePtr, 0, a1);
            }
          }
          ++v10;
          --v6;
        }
        while (v6);
      }
      os_unfair_recursive_lock_unlock();
      CFRelease(a1);
    }
    else
    {
      os_unfair_recursive_lock_unlock();
    }
  }
}

void IOHIDDeviceRegisterInputValueCallback(IOHIDDeviceRef device, IOHIDValueCallback callback, void *context)
{
  CFMutableSetRef Mutable;
  const __CFAllocator *v7;
  CFDataRef v8;
  CFDataRef v9;
  const __CFAllocator *v10;
  __IOHIDQueue *v11;
  __CFRunLoop *v12;
  NSObject *v13;
  __IOHIDQueue *v14;
  __IOHIDQueue *v15;
  _QWORD handler[5];
  UInt8 bytes[8];
  IOHIDValueCallback v18;

  *(_QWORD *)bytes = context;
  v18 = callback;
  if (atomic_load((unsigned int *)device + 56))
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  CFRetain(device);
  os_unfair_recursive_lock_lock_with_options();
  if (*((_QWORD *)device + 39))
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    Mutable = CFSetCreateMutable(0, 0, (const CFSetCallBacks *)&__callbackBaseSetCallbacks);
    *((_QWORD *)device + 39) = Mutable;
    os_unfair_recursive_lock_unlock();
    if (!Mutable)
      goto LABEL_18;
  }
  v7 = CFGetAllocator(device);
  v8 = CFDataCreate(v7, bytes, 16);
  if (v8)
  {
    v9 = v8;
    if (callback)
    {
      os_unfair_recursive_lock_lock_with_options();
      if (!*((_QWORD *)device + 30))
      {
        v10 = CFGetAllocator(device);
        v11 = IOHIDQueueCreate(v10, device, 20, 0);
        *((_QWORD *)device + 30) = v11;
        if (!v11)
        {
LABEL_17:
          os_unfair_recursive_lock_unlock();
          CFRelease(v9);
          goto LABEL_18;
        }
        __IOHIDDeviceRegisterMatchingInputElements(device, v11, *((const __CFArray **)device + 31));
        v12 = (__CFRunLoop *)*((_QWORD *)device + 24);
        if (v12)
        {
          IOHIDQueueScheduleWithRunLoop(*((IOHIDQueueRef *)device + 30), v12, *((CFStringRef *)device + 25));
          IOHIDQueueStart(*((IOHIDQueueRef *)device + 30));
        }
        v13 = *((_QWORD *)device + 26);
        if (v13)
        {
          IOHIDQueueSetDispatchQueue(*((IOHIDQueueRef *)device + 30), v13);
          CFRetain(device);
          v14 = (__IOHIDQueue *)*((_QWORD *)device + 30);
          handler[0] = MEMORY[0x1E0C809B0];
          handler[1] = 0x40000000;
          handler[2] = __IOHIDDeviceRegisterInputValueCallback_block_invoke;
          handler[3] = &__block_descriptor_tmp_23_0;
          handler[4] = device;
          IOHIDQueueSetCancelHandler(v14, handler);
        }
      }
      os_unfair_recursive_lock_unlock();
      os_unfair_recursive_lock_lock_with_options();
      CFSetAddValue(*((CFMutableSetRef *)device + 39), v9);
    }
    else
    {
      os_unfair_recursive_lock_lock_with_options();
      CFSetRemoveValue(*((CFMutableSetRef *)device + 39), v9);
    }
    os_unfair_recursive_lock_unlock();
    os_unfair_recursive_lock_lock_with_options();
    v15 = (__IOHIDQueue *)*((_QWORD *)device + 30);
    if (v15)
      IOHIDQueueRegisterValueAvailableCallback(v15, (IOHIDCallback)__IOHIDDeviceInputElementValueCallback, device);
    goto LABEL_17;
  }
LABEL_18:
  CFRelease(device);
}

void __IOHIDDeviceRegisterMatchingInputElements(void *a1, __IOHIDQueue *a2, const __CFArray *cf)
{
  __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  __IOHIDElement *ValueAtIndex;

  v4 = __IOHIDDeviceCopyMatchingInputElements(a1, cf);
  if (v4)
  {
    v5 = v4;
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i != v7; ++i)
      {
        ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(v5, i);
        if (ValueAtIndex)
          IOHIDQueueAddElement(a2, ValueAtIndex);
      }
    }
    CFRelease(v5);
  }
}

void __IOHIDDeviceInputElementValueCallback(CFSetRef *cf, int a2, __IOHIDQueue *a3)
{
  CFIndex Count;
  uint64_t v6;
  size_t v7;
  CFDataRef *v8;
  size_t v9;
  IOHIDValueRef Value;
  IOHIDValueRef v11;
  CFDataRef *v12;
  uint64_t v13;
  const UInt8 *BytePtr;
  void (*v15)(_QWORD, _QWORD, CFSetRef *, IOHIDValueRef);
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  if (!a2 && cf[30] == a3)
  {
    CFRetain(cf);
    os_unfair_recursive_lock_lock_with_options();
    Count = CFSetGetCount(cf[39]);
    if (Count)
    {
      v6 = Count;
      v7 = 8 * Count;
      MEMORY[0x1E0C80A78]();
      v8 = (CFDataRef *)((char *)v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
      v9 = v7 >= 0x200 ? 512 : v7;
      bzero((char *)v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v9);
      bzero((char *)v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
      CFSetGetValues(cf[39], (const void **)((char *)v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0)));
      Value = IOHIDQueueCopyNextValue(a3);
      if (Value)
      {
        v11 = Value;
        do
        {
          if (v6 >= 1)
          {
            v12 = v8;
            v13 = v6;
            do
            {
              if (*v12)
              {
                BytePtr = CFDataGetBytePtr(*v12);
                v15 = (void (*)(_QWORD, _QWORD, CFSetRef *, IOHIDValueRef))*((_QWORD *)BytePtr + 1);
                if (v15)
                  v15(*(_QWORD *)BytePtr, 0, cf, v11);
              }
              ++v12;
              --v13;
            }
            while (v13);
          }
          CFRelease(v11);
          v11 = IOHIDQueueCopyNextValue(a3);
        }
        while (v11);
      }
    }
    os_unfair_recursive_lock_unlock();
    CFRelease(cf);
  }
}

void IOHIDDeviceSetInputValueMatching(IOHIDDeviceRef device, CFDictionaryRef matching)
{
  const __CFAllocator *v3;
  const __CFArray *v4;
  void *values;

  values = matching;
  if (matching)
  {
    v3 = CFGetAllocator(device);
    v4 = CFArrayCreate(v3, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    IOHIDDeviceSetInputValueMatchingMultiple(device, v4);
    CFRelease(v4);
  }
  else
  {
    IOHIDDeviceSetInputValueMatchingMultiple(device, 0);
  }
}

void IOHIDDeviceSetInputValueMatchingMultiple(IOHIDDeviceRef device, CFArrayRef multiple)
{
  __IOHIDQueue *v4;
  IOHIDValueRef Value;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  __IOHIDQueue *v11;
  __IOHIDElement *ValueAtIndex;
  const void *v13;
  CFTypeRef v14;

  os_unfair_recursive_lock_lock_with_options();
  v4 = (__IOHIDQueue *)*((_QWORD *)device + 30);
  if (v4)
  {
    IOHIDQueueStop(v4);
    while (1)
    {
      Value = IOHIDQueueCopyNextValue(*((IOHIDQueueRef *)device + 30));
      if (!Value)
        break;
      CFRelease(Value);
    }
    v6 = _IOHIDQueueCopyElements(*((CFSetRef **)device + 30));
    if (v6)
    {
      v7 = v6;
      Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        v9 = Count;
        for (i = 0; i != v9; ++i)
        {
          v11 = (__IOHIDQueue *)*((_QWORD *)device + 30);
          ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(v7, i);
          IOHIDQueueRemoveElement(v11, ValueAtIndex);
        }
      }
      CFRelease(v7);
    }
    __IOHIDDeviceRegisterMatchingInputElements(device, *((__IOHIDQueue **)device + 30), multiple);
    IOHIDQueueStart(*((IOHIDQueueRef *)device + 30));
  }
  v13 = (const void *)*((_QWORD *)device + 31);
  if (v13)
    CFRelease(v13);
  if (multiple)
    v14 = CFRetain(multiple);
  else
    v14 = 0;
  *((_QWORD *)device + 31) = v14;
  os_unfair_recursive_lock_unlock();
}

IOReturn IOHIDDeviceSetValue(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef value)
{
  return (*(uint64_t (**)(_QWORD, IOHIDElementRef, IOHIDValueRef, _QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)device + 3) + 80))(*((_QWORD *)device + 3), element, value, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceSetValueMultiple(IOHIDDeviceRef device, CFDictionaryRef multiple)
{
  return IOHIDDeviceSetValueMultipleWithCallback(device, multiple, 0.0, 0, 0);
}

IOReturn IOHIDDeviceSetValueMultipleWithCallback(IOHIDDeviceRef device, CFDictionaryRef multiple, CFTimeInterval timeout, IOHIDValueMultipleCallback callback, void *context)
{
  IOReturn v5;
  CFIndex Count;
  CFIndex v12;
  const __CFAllocator *v13;
  IOHIDTransactionRef v14;
  __IOHIDTransaction *v15;
  const void **v16;
  const void **v17;
  const void **v18;
  __IOHIDValue **v19;
  IOHIDElementRef *v20;
  __IOHIDValue **v21;
  CFIndex v22;
  __IOHIDElement *v23;
  IOHIDElementRef v24;
  __IOHIDValue *v25;
  _QWORD *v26;
  const void **v27;
  _QWORD *v28;
  const __CFAllocator *v29;
  const void **v30;
  const void **v32;

  v5 = -536870211;
  if (!multiple)
    return -536870206;
  Count = CFDictionaryGetCount(multiple);
  if (!Count)
    return -536870206;
  v12 = Count;
  v13 = CFGetAllocator(device);
  v14 = IOHIDTransactionCreate(v13, device, kIOHIDTransactionDirectionTypeOutput, 0);
  if (v14)
  {
    v15 = v14;
    v16 = (const void **)malloc_type_malloc(8 * v12, 0x2004093837F09uLL);
    if (v16)
    {
      v17 = v16;
      v18 = (const void **)malloc_type_malloc(8 * v12, 0x2004093837F09uLL);
      if (v18)
      {
        v19 = (__IOHIDValue **)v18;
        v32 = v17;
        CFDictionaryGetKeysAndValues(multiple, v17, v18);
        if (v12 >= 1)
        {
          v20 = (IOHIDElementRef *)v17;
          v21 = v19;
          v22 = v12;
          do
          {
            IOHIDTransactionAddElement(v15, *v20);
            v24 = *v20++;
            v23 = v24;
            v25 = *v21++;
            IOHIDTransactionSetValue(v15, v23, v25, 0);
            --v22;
          }
          while (v22);
        }
        if (callback)
        {
          v26 = malloc_type_malloc(0x20uLL, 0xE0040BF2FBCEAuLL);
          v27 = v32;
          if (v26)
          {
            v28 = v26;
            v26[1] = callback;
            v26[2] = device;
            *v26 = context;
            v29 = CFGetAllocator(device);
            v28[3] = CFArrayCreate(v29, v32, v12, MEMORY[0x1E0C9B378]);
            v5 = IOHIDTransactionCommitWithCallback(v15, timeout, (IOHIDCallback)__IOHIDDeviceTransactionCallback, v28);
            if (v5)
              free(v28);
            else
              CFRetain(v15);
          }
        }
        else
        {
          v5 = IOHIDTransactionCommit(v15);
          v27 = v32;
        }
        CFRelease(v15);
        free(v27);
        v30 = (const void **)v19;
      }
      else
      {
        CFRelease(v15);
        v30 = v17;
      }
      free(v30);
    }
    else
    {
      CFRelease(v15);
    }
  }
  return v5;
}

IOReturn IOHIDDeviceSetValueWithCallback(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef value, CFTimeInterval timeout, IOHIDValueCallback callback, void *context)
{
  _QWORD *v12;
  void *v13;
  IOReturn v14;

  v12 = malloc_type_malloc(0x18uLL, 0xA0040114AFA65uLL);
  if (!v12)
    return -536870211;
  v13 = v12;
  v12[1] = callback;
  v12[2] = device;
  *v12 = context;
  v14 = (*(uint64_t (**)(_QWORD, IOHIDElementRef, IOHIDValueRef, _QWORD, void (*)(_QWORD *, uint64_t), _QWORD *, _QWORD))(**((_QWORD **)device + 3) + 80))(*((_QWORD *)device + 3), element, value, timeout, __IOHIDDeviceValueCallback, v12, 0);
  if (v14)
    free(v13);
  return v14;
}

void __IOHIDDeviceValueCallback(_QWORD *a1, uint64_t a2)
{
  void (*v3)(_QWORD, uint64_t, _QWORD);

  v3 = (void (*)(_QWORD, uint64_t, _QWORD))a1[1];
  if (v3)
    v3(*a1, a2, a1[2]);
  free(a1);
}

void __IOHIDDeviceTransactionCallback(_QWORD *a1, int a2, CFTypeRef cf)
{
  void (*v5)(uint64_t);
  const void *v6;
  uint64_t v7;
  const void *v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v14;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v17;
  const void *Value;

  if (cf)
  {
    v5 = (void (*)(uint64_t))a1[1];
    if (v5)
    {
      v6 = (const void *)a1[2];
      if (a2)
      {
        v7 = *a1;
LABEL_5:
        v5(v7);
        goto LABEL_6;
      }
      v9 = (const __CFArray *)a1[3];
      if (v9)
      {
        Count = CFArrayGetCount(v9);
        if (Count)
        {
          v11 = Count;
          v12 = CFGetAllocator(v6);
          Mutable = CFDictionaryCreateMutable(v12, v11, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
          if (Mutable)
          {
            v14 = Mutable;
            if (v11 >= 1)
            {
              for (i = 0; i != v11; ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1[3], i);
                if (ValueAtIndex)
                {
                  v17 = ValueAtIndex;
                  Value = (const void *)_IOHIDElementGetValue((uint64_t)ValueAtIndex);
                  if (Value)
                    CFDictionarySetValue(v14, v17, Value);
                }
              }
            }
            if (!CFDictionaryGetCount(v14))
            {
              CFRelease(v14);
              v7 = *a1;
              goto LABEL_5;
            }
            ((void (*)(_QWORD, _QWORD, const void *, __CFDictionary *))v5)(*a1, 0, v6, v14);
            CFRelease(v14);
          }
        }
      }
    }
  }
LABEL_6:
  v8 = (const void *)a1[3];
  if (v8)
    CFRelease(v8);
  if (cf)
    CFRelease(cf);
  free(a1);
}

IOReturn IOHIDDeviceGetValue(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef *pValue)
{
  return (*(uint64_t (**)(_QWORD, IOHIDElementRef, IOHIDValueRef *, _QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)device + 3) + 88))(*((_QWORD *)device + 3), element, pValue, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceGetValueWithOptions(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef *pValue, uint32_t options)
{
  return (*(uint64_t (**)(_QWORD, IOHIDElementRef, IOHIDValueRef *, _QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)device + 3) + 88))(*((_QWORD *)device + 3), element, pValue, 0, 0, 0, *(_QWORD *)&options);
}

IOReturn IOHIDDeviceCopyValueMultiple(IOHIDDeviceRef device, CFArrayRef elements, CFDictionaryRef *pMultiple)
{
  return IOHIDDeviceCopyValueMultipleWithCallback(device, elements, pMultiple, 0.0, 0, 0);
}

IOReturn IOHIDDeviceCopyValueMultipleWithCallback(IOHIDDeviceRef device, CFArrayRef elements, CFDictionaryRef *pMultiple, CFTimeInterval timeout, IOHIDValueMultipleCallback callback, void *context)
{
  IOReturn v6;
  CFIndex Count;
  CFIndex v14;
  const __CFAllocator *v15;
  IOHIDTransactionRef v16;
  __IOHIDTransaction *v17;
  CFIndex i;
  __IOHIDElement *ValueAtIndex;
  _QWORD *v20;
  _QWORD *v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v25;
  CFIndex j;
  const void *v27;
  const void *Value;

  v6 = -536870206;
  if (elements && pMultiple)
  {
    Count = CFArrayGetCount(elements);
    if (Count)
    {
      v14 = Count;
      v15 = CFGetAllocator(device);
      v16 = IOHIDTransactionCreate(v15, device, kIOHIDTransactionDirectionTypeInput, 0);
      if (v16)
      {
        v17 = v16;
        if (v14 >= 1)
        {
          for (i = 0; i != v14; ++i)
          {
            ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(elements, i);
            IOHIDTransactionAddElement(v17, ValueAtIndex);
          }
        }
        if (callback)
        {
          v20 = malloc_type_malloc(0x20uLL, 0xE0040BF2FBCEAuLL);
          v6 = -536870211;
          if (v20)
          {
            v21 = v20;
            v20[1] = callback;
            v20[2] = device;
            *v20 = context;
            v22 = CFGetAllocator(device);
            v21[3] = CFArrayCreateCopy(v22, elements);
            v6 = IOHIDTransactionCommitWithCallback(v17, timeout, (IOHIDCallback)__IOHIDDeviceTransactionCallback, v21);
            if (v6)
              free(v21);
            else
              CFRetain(v17);
          }
        }
        else
        {
          v6 = IOHIDTransactionCommit(v17);
          if (!v6)
          {
            v23 = CFGetAllocator(device);
            Mutable = CFDictionaryCreateMutable(v23, v14, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
            v6 = -536870211;
            if (Mutable)
            {
              v25 = Mutable;
              if (v14 >= 1)
              {
                for (j = 0; j != v14; ++j)
                {
                  v27 = CFArrayGetValueAtIndex(elements, j);
                  Value = (const void *)_IOHIDElementGetValue((uint64_t)v27);
                  if (Value)
                    CFDictionarySetValue(v25, v27, Value);
                }
              }
              if (!CFDictionaryGetCount(v25))
              {
                CFRelease(v25);
                v25 = 0;
              }
              v6 = 0;
              *pMultiple = v25;
            }
          }
        }
        CFRelease(v17);
      }
      else
      {
        return -536870211;
      }
    }
    else
    {
      return -536870206;
    }
  }
  return v6;
}

IOReturn IOHIDDeviceGetValueWithCallback(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef *pValue, CFTimeInterval timeout, IOHIDValueCallback callback, void *context)
{
  _QWORD *v12;
  void *v13;
  IOReturn v14;

  v12 = malloc_type_malloc(0x18uLL, 0xA0040114AFA65uLL);
  if (!v12)
    return -536870211;
  v13 = v12;
  v12[1] = callback;
  v12[2] = device;
  *v12 = context;
  v14 = (*(uint64_t (**)(_QWORD, IOHIDElementRef, IOHIDValueRef *, _QWORD, void (*)(_QWORD *, uint64_t), _QWORD *, _QWORD))(**((_QWORD **)device + 3) + 88))(*((_QWORD *)device + 3), element, pValue, timeout, __IOHIDDeviceValueCallback, v12, 0);
  if (v14)
    free(v13);
  return v14;
}

void IOHIDDeviceRegisterInputReportCallback(IOHIDDeviceRef device, uint8_t *report, CFIndex reportLength, IOHIDReportCallback callback, void *context)
{
  if (atomic_load((unsigned int *)device + 56))
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  __IOHIDDeviceRegisterInputReportCallback(device, (uint64_t)report, reportLength, (uint64_t)callback, 0, (uint64_t)context);
}

void __IOHIDDeviceRegisterInputReportCallback(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const __CFAllocator *v11;
  CFDataRef v12;
  CFDataRef v13;
  __CFSet *v14;
  uint64_t v15;
  _QWORD v16[4];

  v16[0] = a6;
  v16[1] = a4;
  v16[2] = a5;
  v16[3] = a1;
  CFRetain(a1);
  os_unfair_recursive_lock_lock_with_options();
  if (!a1[38])
    a1[38] = CFSetCreateMutable(0, 0, (const CFSetCallBacks *)&__callbackBaseSetCallbacks);
  os_unfair_recursive_lock_unlock();
  if (a1[38])
  {
    v11 = CFGetAllocator(a1);
    v12 = CFDataCreate(v11, (const UInt8 *)v16, 32);
    if (v12)
    {
      v13 = v12;
      os_unfair_recursive_lock_lock_with_options();
      v14 = (__CFSet *)a1[38];
      if (a4 | a5)
      {
        CFSetAddValue(v14, v13);
        os_unfair_recursive_lock_unlock();
        v15 = a1[4];
        if (v15)
          (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t (*)(CFSetRef *, unsigned int, uint64_t, int, int, uint64_t, uint64_t, uint64_t), _QWORD *, _QWORD))(*(_QWORD *)v15 + 120))(a1[3], a2, a3, __IOHIDDeviceInputReportWithTimeStampCallback, a1, 0);
        else
          (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t (*)(CFSetRef *, unsigned int, uint64_t, int, int, uint64_t, uint64_t), _QWORD *, _QWORD))(*(_QWORD *)a1[3] + 96))(a1[3], a2, a3, __IOHIDDeviceInputReportCallback, a1, 0);
      }
      else
      {
        CFSetRemoveValue(v14, v13);
        os_unfair_recursive_lock_unlock();
      }
      CFRelease(v13);
    }
  }
  CFRelease(a1);
}

void IOHIDDeviceRegisterInputReportWithTimeStampCallback(IOHIDDeviceRef device, uint8_t *report, CFIndex reportLength, IOHIDReportWithTimeStampCallback callback, void *context)
{
  if (atomic_load((unsigned int *)device + 56))
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  __IOHIDDeviceRegisterInputReportCallback(device, (uint64_t)report, reportLength, 0, (uint64_t)callback, (uint64_t)context);
}

IOReturn IOHIDDeviceSetReport(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, const uint8_t *report, CFIndex reportLength)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, CFIndex, const uint8_t *, CFIndex, _QWORD, _QWORD, _QWORD, _DWORD))(**((_QWORD **)device + 3) + 104))(*((_QWORD *)device + 3), *(_QWORD *)&reportType, reportID, report, reportLength, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceSetReportWithCallback(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, const uint8_t *report, CFIndex reportLength, CFTimeInterval timeout, IOHIDReportCallback callback, void *context)
{
  uint64_t v14;
  _QWORD *v16;
  void *v17;
  IOReturn v18;

  v14 = *(_QWORD *)&reportType;
  v16 = malloc_type_malloc(0x20uLL, 0xA00400770BE9BuLL);
  if (!v16)
    return -536870211;
  v17 = v16;
  *v16 = context;
  v16[1] = callback;
  v16[3] = device;
  v18 = (*(uint64_t (**)(_QWORD, uint64_t, CFIndex, const uint8_t *, CFIndex, _QWORD, void (*)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), _QWORD *, _DWORD))(**((_QWORD **)device + 3) + 104))(*((_QWORD *)device + 3), v14, reportID, report, reportLength, timeout, __IOHIDDeviceReportCallbackOnce, v16, 0);
  if (v18)
    free(v17);
  return v18;
}

void __IOHIDDeviceReportCallbackOnce(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v14;
  void (*v15)(_QWORD, uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  void (*v16)(_QWORD, uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);

  v14 = (_QWORD *)a1[3];
  CFRetain(v14);
  v15 = (void (*)(_QWORD, uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))a1[1];
  if (v15 && v14[3] == a3)
  {
    v15(*a1, a2, v14, a4, a5, a6, a7);
  }
  else
  {
    v16 = (void (*)(_QWORD, uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))a1[2];
    if (v16 && v14[4] == a3)
      v16(*a1, a2, v14, a4, a5, a6, a7, 0);
  }
  free(a1);
  CFRelease(v14);
}

IOReturn IOHIDDeviceGetReport(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, uint8_t *report, CFIndex *pReportLength)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, CFIndex, uint8_t *, CFIndex *, _QWORD, _QWORD, _QWORD, _DWORD))(**((_QWORD **)device + 3) + 112))(*((_QWORD *)device + 3), *(_QWORD *)&reportType, reportID, report, pReportLength, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceGetReportWithCallback(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, uint8_t *report, CFIndex *pReportLength, CFTimeInterval timeout, IOHIDReportCallback callback, void *context)
{
  uint64_t v14;
  _QWORD *v16;
  void *v17;
  IOReturn v18;

  v14 = *(_QWORD *)&reportType;
  v16 = malloc_type_malloc(0x20uLL, 0xA00400770BE9BuLL);
  if (!v16)
    return -536870211;
  v17 = v16;
  *v16 = context;
  v16[1] = callback;
  v16[2] = 0;
  v16[3] = device;
  v18 = (*(uint64_t (**)(_QWORD, uint64_t, CFIndex, uint8_t *, CFIndex *, _QWORD, void (*)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), _QWORD *, _DWORD))(**((_QWORD **)device + 3) + 112))(*((_QWORD *)device + 3), v14, reportID, report, pReportLength, timeout, __IOHIDDeviceReportCallbackOnce, v16, 0);
  if (v18)
    free(v17);
  return v18;
}

uint64_t IOHIDDeviceGetRegistryEntryID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t __IOHIDDeviceGetRootKey(__IOHIDDevice *a1)
{
  const __CFString *RootKey;
  const __CFString *Property;
  CFTypeRef v4;
  CFTypeRef v5;
  const __CFString *v6;
  CFTypeID v7;
  CFTypeRef *v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;

  os_unfair_recursive_lock_lock_with_options();
  if (!*((_QWORD *)a1 + 9))
  {
    RootKey = __IOHIDManagerGetRootKey();
    Property = (const __CFString *)IOHIDDeviceGetProperty(a1, CFSTR("Transport"));
    v4 = IOHIDDeviceGetProperty(a1, CFSTR("VendorID"));
    v5 = IOHIDDeviceGetProperty(a1, CFSTR("ProductID"));
    v6 = (const __CFString *)IOHIDDeviceGetProperty(a1, CFSTR("SerialNumber"));
    if (!Property || (v7 = CFGetTypeID(Property), v7 != CFStringGetTypeID()))
      Property = CFSTR("unknown");
    v8 = (CFTypeRef *)MEMORY[0x1E0C9B208];
    if (!v4 || (v9 = CFGetTypeID(v4), v9 != CFNumberGetTypeID()))
      v4 = *v8;
    if (!v5 || (v10 = CFGetTypeID(v5), v10 != CFNumberGetTypeID()))
      v5 = *v8;
    if (!v6 || (v11 = CFGetTypeID(v6), v11 != CFStringGetTypeID()))
      v6 = CFSTR("none");
    *((_QWORD *)a1 + 9) = CFStringCreateWithFormat(0, 0, CFSTR("%@#%@#%@#%@#%@"), RootKey, Property, v4, v5, v6);
  }
  os_unfair_recursive_lock_unlock();
  return *((_QWORD *)a1 + 9);
}

CFStringRef __IOHIDDeviceGetUUIDString(__IOHIDDevice *a1)
{
  const __CFString *Property;
  CFStringRef v3;
  CFTypeID v4;
  const __CFUUID *v5;

  Property = (const __CFString *)IOHIDDeviceGetProperty(a1, CFSTR("com.apple.iohidmanager.uuid"));
  if (!Property || (v3 = Property, v4 = CFGetTypeID(Property), v4 != CFStringGetTypeID()))
  {
    v5 = CFUUIDCreate(0);
    v3 = CFUUIDCreateString(0, v5);
    IOHIDDeviceSetProperty(a1, CFSTR("com.apple.iohidmanager.uuid"), v3);
    CFRelease(v5);
    CFRelease(v3);
  }
  return v3;
}

CFStringRef __IOHIDDeviceGetUUIDKey(__IOHIDDevice *a1)
{
  CFStringRef result;
  const __CFString *RootKey;
  CFStringRef UUIDString;

  result = (CFStringRef)*((_QWORD *)a1 + 10);
  if (!result)
  {
    RootKey = __IOHIDManagerGetRootKey();
    UUIDString = __IOHIDDeviceGetUUIDString(a1);
    result = CFStringCreateWithFormat(0, 0, CFSTR("%@#%@"), RootKey, UUIDString);
    *((_QWORD *)a1 + 10) = result;
  }
  return result;
}

void __IOHIDDeviceSaveProperties(uint64_t a1, CFStringRef *context)
{
  __CFString *UUIDString;
  const __CFString *RootKey;
  const __CFArray *v6;
  const __CFArray *v7;
  CFTypeID v8;
  CFIndex Count;
  __CFArray *MutableCopy;
  const __CFString *v11;
  __CFArray *v12;
  const __CFDictionary *v13;
  const __CFString *UUIDKey;
  const __CFSet *v15;
  void *values;
  CFRange v17;

  if (!*(_BYTE *)(a1 + 257) || !*(_QWORD *)(a1 + 56))
    goto LABEL_17;
  UUIDString = (__CFString *)__IOHIDDeviceGetUUIDString((__IOHIDDevice *)a1);
  values = UUIDString;
  RootKey = (const __CFString *)__IOHIDDeviceGetRootKey((__IOHIDDevice *)a1);
  v6 = (const __CFArray *)IOHIDPreferencesCopyDomain(RootKey, (const __CFString *)*MEMORY[0x1E0C9B248]);
  v7 = v6;
  if (!v6)
  {
    MutableCopy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    if (!MutableCopy)
      goto LABEL_16;
    goto LABEL_11;
  }
  v8 = CFGetTypeID(v6);
  if (v8 == CFArrayGetTypeID())
  {
    v17.length = CFArrayGetCount(v7);
    v17.location = 0;
    if (CFArrayContainsValue(v7, v17, UUIDString))
      goto LABEL_14;
    Count = CFArrayGetCount(v7);
    MutableCopy = CFArrayCreateMutableCopy(0, Count + 1, v7);
    CFArrayAppendValue(MutableCopy, UUIDString);
    if (!MutableCopy)
      goto LABEL_14;
LABEL_11:
    v11 = (const __CFString *)__IOHIDDeviceGetRootKey((__IOHIDDevice *)a1);
    __IOHIDPropertySaveWithContext(v11, MutableCopy, context);
    if (v7)
      CFRelease(v7);
    v12 = MutableCopy;
    goto LABEL_15;
  }
  MutableCopy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (MutableCopy)
    goto LABEL_11;
LABEL_14:
  v12 = v7;
LABEL_15:
  CFRelease(v12);
LABEL_16:
  v13 = *(const __CFDictionary **)(a1 + 56);
  UUIDKey = __IOHIDDeviceGetUUIDKey((__IOHIDDevice *)a1);
  __IOHIDPropertySaveToKeyWithSpecialKeys(v13, UUIDKey, 0, context);
  *(_BYTE *)(a1 + 257) = 0;
LABEL_17:
  v15 = *(const __CFSet **)(a1 + 64);
  if (v15)
    CFSetApplyFunction(v15, (CFSetApplierFunction)__IOHIDSaveElementSet, context);
}

void __IOHIDDeviceLoadProperties(uint64_t a1)
{
  CFTypeRef Property;
  const void *ValueAtIndex;
  CFTypeID v4;
  const __CFString *RootKey;
  const __CFArray *v6;
  const __CFArray *v7;
  CFTypeID v8;
  CFTypeID v9;
  const __CFUUID *v10;
  const __CFString *UUIDKey;
  __CFDictionary *DictionaryFromKey;
  __CFDictionary *v13;
  const void *v14;
  const __CFSet *v15;

  Property = IOHIDDeviceGetProperty((IOHIDDeviceRef)a1, CFSTR("com.apple.iohidmanager.uuid"));
  ValueAtIndex = Property;
  *(_BYTE *)(a1 + 256) = 1;
  if (!*(_QWORD *)(a1 + 80))
  {
    if (!Property || (v4 = CFGetTypeID(Property), v4 != CFStringGetTypeID()))
    {
      RootKey = (const __CFString *)__IOHIDDeviceGetRootKey((__IOHIDDevice *)a1);
      v6 = (const __CFArray *)IOHIDPreferencesCopyDomain(RootKey, (const __CFString *)*MEMORY[0x1E0C9B248]);
      if (v6)
      {
        v7 = v6;
        v8 = CFGetTypeID(v6);
        if (v8 == CFArrayGetTypeID())
        {
          if (CFArrayGetCount(v7))
            ValueAtIndex = CFArrayGetValueAtIndex(v7, 0);
        }
      }
      if (!ValueAtIndex)
        goto LABEL_10;
    }
    v9 = CFGetTypeID(ValueAtIndex);
    if (v9 != CFStringGetTypeID())
    {
LABEL_10:
      v10 = CFUUIDCreate(0);
      ValueAtIndex = CFUUIDCreateString(0, v10);
      CFRelease(v10);
    }
    IOHIDDeviceSetProperty((IOHIDDeviceRef)a1, CFSTR("com.apple.iohidmanager.uuid"), ValueAtIndex);
  }
  UUIDKey = __IOHIDDeviceGetUUIDKey((__IOHIDDevice *)a1);
  DictionaryFromKey = __IOHIDPropertyLoadDictionaryFromKey(UUIDKey);
  if (DictionaryFromKey)
  {
    v13 = DictionaryFromKey;
    v14 = *(const void **)(a1 + 56);
    if (v14)
      CFRelease(v14);
    *(_QWORD *)(a1 + 56) = v13;
    *(_BYTE *)(a1 + 257) = 0;
  }
  IOHIDDeviceSetProperty((IOHIDDeviceRef)a1, CFSTR("com.apple.iohidmanager.uuid"), ValueAtIndex);
  v15 = *(const __CFSet **)(a1 + 64);
  if (v15)
    CFSetApplyFunction(v15, (CFSetApplierFunction)__IOHIDLoadElementSet, 0);
}

__IOHIDDevice *__IOHIDApplyPropertyToDeviceSet(__IOHIDDevice *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
      return (__IOHIDDevice *)IOHIDDeviceSetProperty(result, *(CFStringRef *)a2, *(CFTypeRef *)(a2 + 8));
  }
  return result;
}

const __CFString *__IOHIDApplyPropertiesToDeviceFromDictionary(const __CFString *key, CFTypeRef property, IOHIDDeviceRef device)
{
  if (property && key)
  {
    if (device)
      return (const __CFString *)IOHIDDeviceSetProperty(device, key, property);
  }
  return key;
}

void __IOHIDSaveDeviceSet(uint64_t a1, CFStringRef *context)
{
  if (a1)
    __IOHIDDeviceSaveProperties(a1, context);
}

__CFArray *__IOHIDDeviceCopyMatchingInputElements(void *a1, const __CFArray *cf)
{
  const __CFArray *v3;
  uint64_t v4;
  __int128 *v5;
  const CFDictionaryKeyCallBacks *v6;
  const CFDictionaryValueCallBacks *v7;
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  const __CFAllocator *v10;
  uint64_t i;
  CFIndex Count;
  CFIndex v13;
  __CFArray *MutableCopy;
  CFIndex j;
  const __CFDictionary *ValueAtIndex;
  const __CFArray *v17;
  const __CFArray *v18;
  const __CFAllocator *v19;
  const void *v21[4];
  void *values;
  void *keys;
  __int128 v24;
  uint64_t v25;
  CFRange v26;

  v25 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v3 = cf;
    CFRetain(cf);
  }
  else
  {
    v24 = xmmword_18AB460E0;
    MEMORY[0x1E0C80A78]();
    v4 = 0;
    memset(v21, 0, sizeof(v21));
    keys = CFSTR("Type");
    v5 = &v24;
    v6 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9AEB8];
    v7 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    do
    {
      values = 0;
      v8 = CFGetAllocator(a1);
      values = CFNumberCreate(v8, kCFNumberIntType, v5);
      v9 = CFGetAllocator(a1);
      v21[v4] = CFDictionaryCreate(v9, (const void **)&keys, (const void **)&values, 1, v6, v7);
      CFRelease(values);
      ++v4;
      v5 = (__int128 *)((char *)v5 + 4);
    }
    while (v4 != 4);
    v10 = CFGetAllocator(a1);
    v3 = CFArrayCreate(v10, v21, 4, MEMORY[0x1E0C9B378]);
    for (i = 0; i != 4; ++i)
      CFRelease(v21[i]);
    if (!v3)
      return 0;
  }
  Count = CFArrayGetCount(v3);
  if (Count < 1)
  {
    MutableCopy = 0;
  }
  else
  {
    v13 = Count;
    MutableCopy = 0;
    for (j = 0; j != v13; ++j)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, j);
      v17 = IOHIDDeviceCopyMatchingElements((IOHIDDeviceRef)a1, ValueAtIndex, 0);
      if (v17)
      {
        v18 = v17;
        if (MutableCopy)
        {
          v26.length = CFArrayGetCount(v17);
          v26.location = 0;
          CFArrayAppendArray(MutableCopy, v18, v26);
        }
        else
        {
          v19 = CFGetAllocator(a1);
          MutableCopy = CFArrayCreateMutableCopy(v19, 0, v18);
        }
        CFRelease(v18);
      }
    }
  }
  CFRelease(v3);
  return MutableCopy;
}

uint64_t __IOHIDDeviceInputReportWithTimeStampCallback(CFSetRef *a1, unsigned int a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD context[3];
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  os_unfair_recursive_lock_lock_with_options();
  if (CFSetGetCount(a1[38]))
  {
    context[0] = a1;
    context[1] = a2;
    context[2] = a1;
    v17 = a4;
    v18 = a5;
    v19 = a6;
    v20 = a7;
    v21 = a8;
    CFRetain(a1);
    CFSetApplyFunction(a1[38], (CFSetApplierFunction)__IOHIDDeviceInputReportApplier, context);
    CFRelease(a1);
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDDeviceInputReportCallback(CFSetRef *a1, unsigned int a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  _QWORD context[3];
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  os_unfair_recursive_lock_lock_with_options();
  if (CFSetGetCount(a1[38]))
  {
    context[0] = a1;
    context[1] = a2;
    context[2] = a1;
    v15 = a4;
    v16 = a5;
    v17 = a6;
    v18 = a7;
    v19 = 0;
    CFRetain(a1);
    CFSetApplyFunction(a1[38], (CFSetApplierFunction)__IOHIDDeviceInputReportApplier, context);
    CFRelease(a1);
  }
  return os_unfair_recursive_lock_unlock();
}

const UInt8 *__IOHIDDeviceInputReportApplier(const UInt8 *result, uint64_t a2)
{
  const UInt8 *v3;
  uint64_t (*v4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t (*v5)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

  if (result)
  {
    if (a2)
    {
      result = CFDataGetBytePtr((CFDataRef)result);
      if (result)
      {
        v3 = result;
        v4 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)result + 1);
        if (v4)
          result = (const UInt8 *)v4(*(_QWORD *)result, *(unsigned int *)(a2 + 8), *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24), *(unsigned int *)(a2 + 28), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40));
        v5 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)v3 + 2);
        if (v5)
          return (const UInt8 *)v5(*(_QWORD *)v3, *(unsigned int *)(a2 + 8), *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24), *(unsigned int *)(a2 + 28), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48));
      }
    }
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_0_2()
{
  return _os_log_send_and_compose_impl();
}

uint64_t OUTLINED_FUNCTION_1_3()
{
  return _os_log_send_and_compose_impl();
}

BOOL OUTLINED_FUNCTION_2_0(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_ERROR);
}

uint64_t OUTLINED_FUNCTION_5_0()
{
  return _os_crash_msg();
}

uint64_t _IOObjectCFRelease(int a1, io_object_t object)
{
  return IOObjectRelease(object);
}

uint64_t (*_IOHIDCallbackApplier(uint64_t (*result)(uint64_t, _QWORD, _QWORD), uint64_t a2, unsigned int *a3))(uint64_t, _QWORD, _QWORD)
{
  if (result)
  {
    if (a3)
      return (uint64_t (*)(uint64_t, _QWORD, _QWORD))result(a2, *a3, *((_QWORD *)a3 + 1));
  }
  return result;
}

uint64_t _IOHIDGetMonotonicTime()
{
  if (!dword_1EDF7BF04)
    mach_timebase_info((mach_timebase_info_t)&_IOHIDGetMonotonicTime_timebaseInfo);
  return mach_absolute_time() * _IOHIDGetMonotonicTime_timebaseInfo / dword_1EDF7BF04;
}

uint64_t _IOHIDSimpleQueuePeek(const __CFData *a1)
{
  const UInt8 *BytePtr;
  uint64_t v2;

  BytePtr = CFDataGetBytePtr(a1);
  v2 = *((_QWORD *)BytePtr + 3);
  if (v2 == *((_QWORD *)BytePtr + 2))
    return 0;
  else
    return (uint64_t)&BytePtr[*((_QWORD *)BytePtr + 1) * v2 + 8];
}

const UInt8 *_IOHIDSimpleQueueApplyBlock(const __CFData *a1, uint64_t a2, uint64_t a3)
{
  const UInt8 *result;
  unint64_t v6;
  const UInt8 *v7;
  const UInt8 *v8;

  result = CFDataGetBytePtr(a1);
  v6 = *((_QWORD *)result + 2);
  if (*((_QWORD *)result + 3) != v6)
  {
    v7 = result;
    v8 = result + 32;
    do
    {
      result = (const UInt8 *)(*(uint64_t (**)(uint64_t, const UInt8 *, uint64_t))(a2 + 16))(a2, &v8[*((_QWORD *)v7 + 1) * v6], a3);
      v6 = (v6 + 1) % *(_QWORD *)v7;
    }
    while (*((_QWORD *)v7 + 3) != v6);
  }
  return result;
}

uint64_t _IOHIDSimpleQueueDequeue(const __CFData *a1, void *a2)
{
  const UInt8 *BytePtr;
  uint64_t v5;
  const UInt8 *v7;
  uint64_t v8;
  const UInt8 *v9;
  const UInt8 *v10;

  BytePtr = CFDataGetBytePtr(a1);
  v5 = *((_QWORD *)BytePtr + 3);
  if (v5 == *((_QWORD *)BytePtr + 2))
    return 0;
  v7 = BytePtr + 8;
  v8 = *((_QWORD *)BytePtr + 1);
  v9 = CFDataGetBytePtr(a1);
  v10 = v9;
  if (a2)
    memcpy(a2, &v7[v8 * v5], *((_QWORD *)v9 + 1));
  *((_QWORD *)v10 + 2) = (unint64_t)(*((_QWORD *)v10 + 2) + 1) % *(_QWORD *)v10;
  return 1;
}

void _IOHIDDictionaryAddCStr(void *a1, const void *a2, const char *a3)
{
  const __CFAllocator *v6;
  CFStringRef v7;
  CFStringRef v8;

  v6 = CFGetAllocator(a1);
  v7 = CFStringCreateWithCString(v6, a3, 0);
  if (v7)
  {
    v8 = v7;
    CFDictionaryAddValue((CFMutableDictionaryRef)a1, a2, v7);
    CFRelease(v8);
  }
}

void _IOHIDCFSetApplyBlock(const __CFSet *a1, void *context)
{
  CFSetApplyFunction(a1, (CFSetApplierFunction)__IOHIDCFSetFunctionApplier, context);
}

uint64_t __IOHIDCFSetFunctionApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t _IOHIDIsAlphaNumericKey(int a1, int a2)
{
  unsigned int v3;
  uint64_t result;

  if (a2 != 7)
    return 0;
  v3 = a1 - 45;
  result = 1;
  if (v3 >= 0xC
    && (a1 - 4) >= 0x24
    && (a1 - 89) >= 0xC
    && a1 != 103
    && (a1 & 0xFFFFFFFC) != 0x54)
  {
    return 0;
  }
  return result;
}

uint64_t _IOHIDIsRestrictedRemappingProperty(const __CFString *a1)
{
  CFTypeID v2;
  CFIndex v3;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v5;
  CFTypeID v6;
  const __CFNumber *Value;
  const __CFNumber *v8;
  CFTypeID v9;
  CFTypeID v10;
  uint64_t result;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;
  __int16 v17;
  int v18;
  unsigned int v19;
  char *valuePtr;

  v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID())
  {
    v10 = CFGetTypeID(a1);
    if (v10 == CFStringGetTypeID() && a1)
    {
      result = (uint64_t)CFStringGetCStringPtr(a1, 0);
      if (!result)
        return result;
      v12 = strdup((const char *)result);
      valuePtr = v12;
      v13 = strsep(&valuePtr, ",");
      if (v13)
      {
        v14 = v13;
        do
        {
          v15 = strsep(&valuePtr, ",");
          if (!v15)
            break;
          if (strtoul(v15, 0, 0))
          {
            v16 = strtoul(v14, 0, 0);
            v17 = v16;
            if ((v16 & 0xFFFF0000) == 0x70000)
            {
              v18 = (unsigned __int16)v16;
              v19 = (unsigned __int16)v16 - 45;
              result = 1;
              if (v19 < 0xC
                || (v18 - 4) < 0x24
                || (v18 - 89) < 0xC
                || v18 == 103
                || (v17 & 0xFFFC) == 0x54)
              {
                return result;
              }
            }
          }
          v14 = strsep(&valuePtr, ",");
        }
        while (v14);
      }
      if (v12)
        free(v12);
    }
    return 0;
  }
  if (CFArrayGetCount((CFArrayRef)a1) < 1)
    return 0;
  v3 = 0;
  while (1)
  {
    valuePtr = 0;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, v3);
    if (ValueAtIndex)
    {
      v5 = ValueAtIndex;
      v6 = CFGetTypeID(ValueAtIndex);
      if (v6 == CFDictionaryGetTypeID())
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(v5, CFSTR("HIDKeyboardModifierMappingSrc"));
        if (Value)
        {
          v8 = Value;
          v9 = CFGetTypeID(Value);
          if (v9 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v8, kCFNumberSInt64Type, &valuePtr);
            if (HIDWORD(valuePtr) == 7
              && (((_DWORD)valuePtr - 45) < 0xC
               || ((_DWORD)valuePtr - 4) < 0x24
               || ((_DWORD)valuePtr - 89) < 0xC
               || (_DWORD)valuePtr == 103
               || (valuePtr & 0xFFFFFFFC) == 0x54))
            {
              break;
            }
          }
        }
      }
    }
    if (++v3 >= CFArrayGetCount((CFArrayRef)a1))
      return 0;
  }
  return 1;
}

CFTypeID IOHIDManagerGetTypeID(void)
{
  CFTypeID result;

  result = __kIOHIDManagerTypeID;
  if (!__kIOHIDManagerTypeID)
  {
    pthread_once(&__sessionTypeInit, (void (*)(void))__IOHIDManagerRegister);
    return __kIOHIDManagerTypeID;
  }
  return result;
}

uint64_t __IOHIDManagerLoadProperties(uint64_t a1)
{
  __CFDictionary *DictionaryFromKey;
  const void *v3;

  DictionaryFromKey = __IOHIDPropertyLoadDictionaryFromKey(CFSTR("com.apple.iohidmanager"));
  os_unfair_recursive_lock_lock_with_options();
  if (DictionaryFromKey)
  {
    v3 = *(const void **)(a1 + 56);
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 56) = DictionaryFromKey;
    *(_BYTE *)(a1 + 156) = 0;
  }
  return os_unfair_recursive_lock_unlock();
}

IOReturn IOHIDManagerClose(IOHIDManagerRef manager, IOOptionBits options)
{
  __CFRunLoop *v4;
  IOReturn v5;

  v4 = (__CFRunLoop *)*((_QWORD *)manager + 10);
  if (v4)
    IOHIDManagerUnscheduleFromRunLoop(manager, v4, *((CFStringRef *)manager + 11));
  if (*((_BYTE *)manager + 144))
  {
    *((_BYTE *)manager + 144) = 0;
    *((_DWORD *)manager + 37) = options;
    if (*((_QWORD *)manager + 4))
      v5 = __ApplyToDevices((CFSetRef *)manager, 2);
    else
      v5 = 0;
  }
  else
  {
    v5 = -536870195;
  }
  if ((*((_DWORD *)manager + 38) & 5) == 1)
    __IOHIDManagerSaveProperties((uint64_t)manager, 0);
  return v5;
}

void IOHIDManagerUnscheduleFromRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  const void *v6;
  __CFSet *v7;
  __CFDictionary *v8;

  os_unfair_recursive_lock_lock_with_options();
  v6 = (const void *)*((_QWORD *)manager + 10);
  if (v6 && CFEqual(v6, runLoop) && CFEqual(*((CFTypeRef *)manager + 11), runLoopMode))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 128);
    os_unfair_recursive_lock_lock_with_options();
    v7 = (__CFSet *)*((_QWORD *)manager + 5);
    if (v7)
      CFSetRemoveAllValues(v7);
    v8 = (__CFDictionary *)*((_QWORD *)manager + 6);
    if (v8)
      CFDictionaryRemoveAllValues(v8);
    *((_QWORD *)manager + 10) = 0;
    *((_QWORD *)manager + 11) = 0;
  }
  os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDManagerSaveProperties(uint64_t a1, CFStringRef *a2)
{
  const __CFDictionary *v4;
  const __CFAllocator *v5;
  const __CFSet *Copy;
  const __CFSet *v7;

  os_unfair_recursive_lock_lock_with_options();
  if (*(_BYTE *)(a1 + 156))
  {
    v4 = *(const __CFDictionary **)(a1 + 56);
    if (v4)
    {
      __IOHIDPropertySaveToKeyWithSpecialKeys(v4, CFSTR("com.apple.iohidmanager"), 0, a2);
      *(_BYTE *)(a1 + 156) = 0;
    }
  }
  if (*(_QWORD *)(a1 + 32))
  {
    v5 = CFGetAllocator((CFTypeRef)a1);
    Copy = CFSetCreateCopy(v5, *(CFSetRef *)(a1 + 32));
    if (Copy)
    {
      v7 = Copy;
      CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDSaveDeviceSet, a2);
      CFRelease(v7);
    }
  }
  return os_unfair_recursive_lock_unlock();
}

CFTypeRef IOHIDManagerGetProperty(IOHIDManagerRef manager, CFStringRef key)
{
  const __CFDictionary *v4;
  const void *Value;

  os_unfair_recursive_lock_lock_with_options();
  v4 = (const __CFDictionary *)*((_QWORD *)manager + 7);
  if (v4)
    Value = CFDictionaryGetValue(v4, key);
  else
    Value = 0;
  os_unfair_recursive_lock_unlock();
  return Value;
}

Boolean IOHIDManagerSetProperty(IOHIDManagerRef manager, CFStringRef key, CFTypeRef value)
{
  __CFDictionary *Mutable;
  const __CFAllocator *v7;
  const __CFAllocator *v8;
  const __CFSet *Copy;
  _QWORD v11[2];

  v11[0] = key;
  v11[1] = value;
  os_unfair_recursive_lock_lock_with_options();
  Mutable = (__CFDictionary *)*((_QWORD *)manager + 7);
  if (!Mutable)
  {
    v7 = CFGetAllocator(manager);
    Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)manager + 7) = Mutable;
    if (!Mutable)
    {
      os_unfair_recursive_lock_unlock();
      return 0;
    }
  }
  *((_BYTE *)manager + 156) = 1;
  CFDictionarySetValue(Mutable, key, value);
  if (!*((_QWORD *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    return 1;
  }
  v8 = CFGetAllocator(manager);
  Copy = CFSetCreateCopy(v8, *((CFSetRef *)manager + 4));
  os_unfair_recursive_lock_unlock();
  if (!Copy)
    return 0;
  CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDApplyPropertyToDeviceSet, v11);
  CFRelease(Copy);
  return 1;
}

void IOHIDManagerSetDeviceMatching(IOHIDManagerRef manager, CFDictionaryRef matching)
{
  const __CFAllocator *v4;
  const __CFArray *v5;
  void *values;

  values = matching;
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  if (values)
  {
    v4 = CFGetAllocator(manager);
    v5 = CFArrayCreate(v4, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    IOHIDManagerSetDeviceMatchingMultiple(manager, v5);
    if (v5)
      CFRelease(v5);
  }
  else
  {
    IOHIDManagerSetDeviceMatchingMultiple(manager, 0);
  }
}

CFSetRef IOHIDManagerCopyDevices(IOHIDManagerRef manager)
{
  const __CFAllocator *v2;
  const __CFSet *Copy;

  os_unfair_recursive_lock_lock_with_options();
  if (*((_QWORD *)manager + 4))
  {
    v2 = CFGetAllocator(manager);
    Copy = CFSetCreateCopy(v2, *((CFSetRef *)manager + 4));
  }
  else
  {
    Copy = 0;
  }
  os_unfair_recursive_lock_unlock();
  return Copy;
}

void IOHIDManagerRegisterInputReportCallback(IOHIDManagerRef manager, IOHIDReportCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  *((_QWORD *)manager + 23) = context;
  *((_QWORD *)manager + 24) = callback;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((_BYTE *)manager + 144) && *((_QWORD *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 32);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerRegisterInputReportWithTimeStampCallback(IOHIDManagerRef manager, IOHIDReportWithTimeStampCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  *((_QWORD *)manager + 25) = callback;
  *((_QWORD *)manager + 23) = context;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((_BYTE *)manager + 144) && *((_QWORD *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 4096);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerRegisterInputValueCallback(IOHIDManagerRef manager, IOHIDValueCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  *((_QWORD *)manager + 21) = context;
  *((_QWORD *)manager + 22) = callback;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((_BYTE *)manager + 144) && *((_QWORD *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 16);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerSetInputValueMatching(IOHIDManagerRef manager, CFDictionaryRef matching)
{
  const __CFAllocator *v4;
  const __CFArray *v5;
  void *values;

  values = matching;
  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  if (values)
  {
    v4 = CFGetAllocator(manager);
    v5 = CFArrayCreate(v4, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    IOHIDManagerSetInputValueMatchingMultiple(manager, v5);
    CFRelease(v5);
  }
  else
  {
    IOHIDManagerSetInputValueMatchingMultiple(manager, 0);
  }
}

void IOHIDManagerSetInputValueMatchingMultiple(IOHIDManagerRef manager, CFArrayRef multiple)
{
  const void *v5;

  if (atomic_load((unsigned int *)manager + 29))
    IOHIDManagerSetDeviceMatching_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  v5 = (const void *)*((_QWORD *)manager + 30);
  if (v5)
    CFRelease(v5);
  if (multiple)
    CFRetain(multiple);
  *((_QWORD *)manager + 30) = multiple;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((_BYTE *)manager + 144) && *((_QWORD *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 8);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerSetDispatchQueue(IOHIDManagerRef manager, dispatch_queue_t queue)
{
  const char *label;
  const char *v5;
  dispatch_queue_t v6;
  uint64_t v7;
  char __str[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (*((_QWORD *)manager + 10) || *((_QWORD *)manager + 12))
    IOHIDManagerSetDispatchQueue_cold_1(&v7, __str);
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  *(_OWORD *)__str = 0u;
  v9 = 0u;
  label = dispatch_queue_get_label(queue);
  v5 = "";
  if (label)
    v5 = label;
  snprintf(__str, 0x100uLL, "%s.IOHIDManagerRef", v5);
  v6 = dispatch_queue_create_with_target_V2(__str, 0, queue);
  *((_QWORD *)manager + 12) = v6;
  os_unfair_recursive_lock_unlock();
  if (v6)
    __ApplyToDevices((CFSetRef *)manager, 256);
}

void IOHIDManagerSetCancelHandler(IOHIDManagerRef manager, dispatch_block_t handler)
{
  uint64_t v4;
  _OWORD v5[5];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (!handler || *((_QWORD *)manager + 13))
    IOHIDManagerSetCancelHandler_cold_1(&v4, v5);
  _IOHIDObjectInternalRetain(manager);
  *((_QWORD *)manager + 13) = _Block_copy(handler);
  os_unfair_recursive_lock_unlock();
  __ApplyToDevices((CFSetRef *)manager, 512);
}

void IOHIDManagerActivate(IOHIDManagerRef manager)
{
  BOOL v1;
  IOHIDManagerRef v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  IONotificationPort *v6;

  if (*((_QWORD *)manager + 12))
    v1 = *((_QWORD *)manager + 10) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    manager = (IOHIDManagerRef)_os_crash_msg();
    __break(1u);
  }
  v2 = manager;
  v3 = (unsigned int *)((char *)manager + 116);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if ((v4 & 1) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (*((_QWORD *)v2 + 27))
      v5 = 1028;
    else
      v5 = 1024;
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)v2, v5);
    os_unfair_recursive_lock_lock_with_options();
    v6 = (IONotificationPort *)*((_QWORD *)v2 + 9);
    if (v6)
      IONotificationPortSetDispatchQueue(v6, *((dispatch_queue_t *)v2 + 12));
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerCancel(IOHIDManagerRef manager)
{
  BOOL v1;
  IOHIDManagerRef v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  IONotificationPort *v6;
  __CFSet *v7;
  __CFDictionary *v8;
  const __CFSet *v9;
  uint64_t v10;

  if (*((_QWORD *)manager + 12))
    v1 = *((_QWORD *)manager + 10) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    manager = (IOHIDManagerRef)_os_crash_msg();
    __break(1u);
  }
  v2 = manager;
  v3 = (unsigned int *)((char *)manager + 116);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 2, v3));
  if ((v4 & 2) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    v6 = (IONotificationPort *)*((_QWORD *)v2 + 9);
    if (v6)
    {
      IONotificationPortDestroy(v6);
      *((_QWORD *)v2 + 9) = 0;
    }
    v7 = (__CFSet *)*((_QWORD *)v2 + 5);
    if (v7)
      CFSetRemoveAllValues(v7);
    v8 = (__CFDictionary *)*((_QWORD *)v2 + 6);
    if (v8)
      CFDictionaryRemoveAllValues(v8);
    v9 = (const __CFSet *)*((_QWORD *)v2 + 4);
    if (v9 && CFSetGetCount(v9) && *((_DWORD *)v2 + 28))
    {
      __ApplyToDevices((CFSetRef *)v2, 2048);
    }
    else
    {
      v10 = *((_QWORD *)v2 + 13);
      if (v10)
      {
        (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v10, v5);
        _Block_release(*((const void **)v2 + 13));
        *((_QWORD *)v2 + 13) = 0;
        _IOHIDObjectInternalRelease(v2);
      }
    }
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerSaveToPropertyDomain(IOHIDManagerRef manager, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName, IOOptionBits options)
{
  CFStringRef v5[4];

  v5[0] = applicationID;
  v5[1] = userName;
  v5[2] = hostName;
  v5[3] = (CFStringRef)options;
  if (manager && applicationID && userName)
  {
    if (hostName)
      __IOHIDManagerSaveProperties((uint64_t)manager, v5);
  }
}

const __CFString *__IOHIDManagerGetRootKey()
{
  return CFSTR("com.apple.iohidmanager");
}

void __IOHIDPropertySaveToKeyWithSpecialKeys(CFDictionaryRef theDict, const __CFString *a2, _QWORD *a3, CFStringRef *a4)
{
  const __CFDictionary *MutableCopy;
  const void *v8;
  const void *Value;
  const void *v10;
  const __CFString *v11;
  const void *v12;
  CFNumberRef v13;
  CFAbsoluteTime valuePtr;

  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  if (a3)
  {
    v8 = (const void *)*a3;
    if (*a3)
    {
      do
      {
        Value = CFDictionaryGetValue(MutableCopy, v8);
        if (Value)
        {
          v10 = Value;
          v11 = CFStringCreateWithFormat(0, 0, CFSTR("%@#%@"), a2, *a3);
          __IOHIDPropertySaveWithContext(v11, v10, a4);
          CFDictionaryRemoveValue(MutableCopy, (const void *)*a3);
          CFRelease(v11);
        }
        v12 = (const void *)a3[1];
        ++a3;
        v8 = v12;
      }
      while (v12);
    }
  }
  valuePtr = CFAbsoluteTimeGetCurrent();
  v13 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionaryAddValue(MutableCopy, CFSTR("time of last save"), v13);
  CFRelease(v13);
  __IOHIDPropertySaveWithContext(a2, MutableCopy, a4);
  CFRelease(MutableCopy);
}

__CFDictionary *__IOHIDPropertyLoadDictionaryFromKey(const __CFString *a1)
{
  const __CFString *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  CFTypeID v5;
  __CFDictionary *Mutable;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  CFTypeID v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  CFTypeID v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  CFTypeID v23;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  CFTypeID v26;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  CFTypeID v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  CFTypeID v32;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  CFTypeID v35;
  const __CFString *hostName;

  v2 = (const __CFString *)*MEMORY[0x1E0C9B248];
  v3 = (const __CFDictionary *)CFPreferencesCopyAppValue(a1, (CFStringRef)*MEMORY[0x1E0C9B248]);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = CFGetTypeID(v3);
  if (v5 == CFDictionaryGetTypeID())
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v7 = (const __CFString *)*MEMORY[0x1E0C9B228];
    v8 = (const __CFString *)*MEMORY[0x1E0C9B240];
    v9 = (const __CFString *)*MEMORY[0x1E0C9B230];
    v10 = (const __CFDictionary *)CFPreferencesCopyValue(a1, (CFStringRef)*MEMORY[0x1E0C9B228], (CFStringRef)*MEMORY[0x1E0C9B240], (CFStringRef)*MEMORY[0x1E0C9B230]);
    if (v10)
    {
      v11 = v10;
      v12 = CFGetTypeID(v10);
      if (v12 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v11, Mutable);
      CFRelease(v11);
    }
    hostName = (const __CFString *)*MEMORY[0x1E0C9B250];
    v13 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v7, v8, (CFStringRef)*MEMORY[0x1E0C9B250]);
    if (v13)
    {
      v14 = v13;
      v15 = CFGetTypeID(v13);
      if (v15 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v14, Mutable);
      CFRelease(v14);
    }
    v16 = (const __CFString *)*MEMORY[0x1E0C9B260];
    v17 = v9;
    v18 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v7, (CFStringRef)*MEMORY[0x1E0C9B260], v9);
    if (v18)
    {
      v19 = v18;
      v20 = CFGetTypeID(v18);
      if (v20 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v19, Mutable);
      CFRelease(v19);
    }
    v21 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v7, v16, hostName);
    if (v21)
    {
      v22 = v21;
      v23 = CFGetTypeID(v21);
      if (v23 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v22, Mutable);
      CFRelease(v22);
    }
    v24 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v8, v17);
    if (v24)
    {
      v25 = v24;
      v26 = CFGetTypeID(v24);
      if (v26 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v25, Mutable);
      CFRelease(v25);
    }
    v27 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v8, hostName);
    if (v27)
    {
      v28 = v27;
      v29 = CFGetTypeID(v27);
      if (v29 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v28, Mutable);
      CFRelease(v28);
    }
    v30 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v16, v17);
    if (v30)
    {
      v31 = v30;
      v32 = CFGetTypeID(v30);
      if (v32 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v31, Mutable);
      CFRelease(v31);
    }
    v33 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v16, hostName);
    if (v33)
    {
      v34 = v33;
      v35 = CFGetTypeID(v33);
      if (v35 == CFDictionaryGetTypeID())
        __IOHIDManagerMergeDictionaries(v34, Mutable);
      CFRelease(v34);
    }
    __IOHIDManagerMergeDictionaries(v4, Mutable);
  }
  else
  {
    Mutable = 0;
  }
  CFRelease(v4);
  return Mutable;
}

void __IOHIDPropertySaveWithContext(const __CFString *a1, const void *a2, CFStringRef *a3)
{
  const __CFString *v3;
  const __CFString *v4;

  if (a1 && a2)
  {
    if (a3 && *a3 && (v3 = a3[1]) != 0 && (v4 = a3[2]) != 0)
      CFPreferencesSetValue(a1, a2, *a3, v3, v4);
    else
      CFPreferencesSetAppValue(a1, a2, (CFStringRef)*MEMORY[0x1E0C9B248]);
  }
}

__CFDictionary *__IOHIDPropertyLoadFromKeyWithSpecialKeys(const __CFString *a1, uint64_t *a2)
{
  __CFDictionary *DictionaryFromKey;
  uint64_t v5;
  const __CFString *v6;
  uint64_t *v7;
  const __CFString *v8;
  CFPropertyListRef v9;
  const void *v10;
  uint64_t v11;

  DictionaryFromKey = __IOHIDPropertyLoadDictionaryFromKey(a1);
  if (!DictionaryFromKey)
    DictionaryFromKey = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v5 = *a2;
  if (*a2)
  {
    v6 = (const __CFString *)*MEMORY[0x1E0C9B248];
    v7 = a2 + 1;
    do
    {
      v8 = CFStringCreateWithFormat(0, 0, CFSTR("%@#%@"), a1, v5);
      v9 = CFPreferencesCopyAppValue(v8, v6);
      if (v9)
      {
        v10 = v9;
        CFDictionarySetValue(DictionaryFromKey, (const void *)*(v7 - 1), v9);
        CFRelease(v10);
      }
      CFRelease(v8);
      v11 = *v7++;
      v5 = v11;
    }
    while (v11);
  }
  return DictionaryFromKey;
}

uint64_t __IOHIDManagerExtRelease(uint64_t a1)
{
  unsigned int v2;
  __CFRunLoop *v3;
  IONotificationPort *v4;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoopSource *v6;
  NSObject *v7;
  uint64_t v9;
  _OWORD v10[5];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (*(_QWORD *)(a1 + 96))
  {
    v2 = atomic_load((unsigned int *)(a1 + 116));
    if (v2 != 3)
      __IOHIDManagerExtRelease_cold_1(&v9, v10, (unsigned int *)(a1 + 116));
  }
  if ((*(_DWORD *)(a1 + 152) & 5) == 1)
    __IOHIDManagerSaveProperties(a1, 0);
  if (*(_BYTE *)(a1 + 144))
    IOHIDManagerClose((IOHIDManagerRef)a1, *(_DWORD *)(a1 + 148));
  v3 = *(__CFRunLoop **)(a1 + 80);
  if (v3)
    IOHIDManagerUnscheduleFromRunLoop((IOHIDManagerRef)a1, v3, *(CFStringRef *)(a1 + 88));
  v4 = *(IONotificationPort **)(a1 + 72);
  if (v4)
  {
    RunLoopSource = IONotificationPortGetRunLoopSource(v4);
    if (RunLoopSource)
      CFRunLoopSourceInvalidate(RunLoopSource);
  }
  v6 = *(__CFRunLoopSource **)(a1 + 128);
  if (v6)
    CFRunLoopSourceInvalidate(v6);
  if (*(_QWORD *)(a1 + 248))
    os_state_remove_handler();
  v7 = *(NSObject **)(a1 + 256);
  if (v7)
  {
    dispatch_set_context(v7, (void *)a1);
    dispatch_set_finalizer_f(*(dispatch_object_t *)(a1 + 256), (dispatch_function_t)__IOHIDManagerFinalizeStateHandler);
    _IOHIDObjectInternalRetain((const void *)a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 256));
  }
  return os_unfair_recursive_lock_unlock();
}

void __IOHIDManagerIntRelease(_QWORD *a1)
{
  IONotificationPort *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  NSObject *v10;
  const void *v11;
  const void *v12;

  v2 = (IONotificationPort *)a1[9];
  if (v2)
  {
    IONotificationPortDestroy(v2);
    a1[9] = 0;
  }
  v3 = (const void *)a1[15];
  if (v3)
  {
    CFRelease(v3);
    a1[15] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  v5 = (const void *)a1[8];
  if (v5)
  {
    CFRelease(v5);
    a1[8] = 0;
  }
  v6 = (const void *)a1[5];
  if (v6)
  {
    CFRelease(v6);
    a1[5] = 0;
  }
  v7 = (const void *)a1[7];
  if (v7)
  {
    CFRelease(v7);
    a1[7] = 0;
  }
  v8 = (const void *)a1[17];
  if (v8)
  {
    CFRelease(v8);
    a1[17] = 0;
  }
  v9 = (const void *)a1[30];
  if (v9)
  {
    CFRelease(v9);
    a1[30] = 0;
  }
  v10 = a1[12];
  if (v10)
    dispatch_release(v10);
  v11 = (const void *)a1[6];
  if (v11)
    CFRelease(v11);
  v12 = (const void *)a1[16];
  if (v12)
  {
    CFRelease(v12);
    a1[16] = 0;
  }
}

void __IOHIDManagerDeviceApplier(__IOHIDDevice *key, _BYTE *a2)
{
  uint64_t v4;
  const void *v5;
  __CFDictionary *v6;
  int v7;
  const __CFDictionary *Mutable;
  const __CFAllocator *v9;
  void *Value;
  const __CFNumber *Property;
  const __CFAllocator *v12;
  __CFData *v13;
  int v14;
  uint8_t *MutableBytePtr;
  CFIndex Length;
  CFTypeRef v17;
  void *v18;
  int v19;
  void (**v20)(_QWORD, const void *, CFTypeRef, __IOHIDDevice *);
  const __CFDictionary *v21;
  uint64_t v22;
  _QWORD v23[5];
  CFIndex valuePtr;

  v4 = *(_QWORD *)a2;
  if ((*(_BYTE *)(*(_QWORD *)a2 + 152) & 8) != 0)
  {
    v5 = 0;
    goto LABEL_34;
  }
  if ((a2[8] & 1) != 0)
  {
    v5 = (const void *)IOHIDDeviceOpen(key, *(_DWORD *)(v4 + 148));
    v6 = *(__CFDictionary **)(*(_QWORD *)a2 + 136);
    if (v6)
      CFDictionarySetValue(v6, key, v5);
  }
  else
  {
    v5 = 0;
  }
  v7 = *((_DWORD *)a2 + 2);
  if ((v7 & 2) != 0)
  {
    v5 = (const void *)IOHIDDeviceClose(key, *(_DWORD *)(*(_QWORD *)a2 + 148));
    v7 = *((_DWORD *)a2 + 2);
    if ((v7 & 8) == 0)
    {
LABEL_8:
      if ((v7 & 0x10) == 0)
        goto LABEL_10;
      goto LABEL_9;
    }
  }
  else if ((v7 & 8) == 0)
  {
    goto LABEL_8;
  }
  IOHIDDeviceSetInputValueMatchingMultiple(key, *(CFArrayRef *)(*(_QWORD *)a2 + 240));
  v7 = *((_DWORD *)a2 + 2);
  if ((v7 & 0x10) != 0)
  {
LABEL_9:
    IOHIDDeviceRegisterInputValueCallback(key, *(IOHIDValueCallback *)(*(_QWORD *)a2 + 176), *(void **)(*(_QWORD *)a2 + 168));
    v7 = *((_DWORD *)a2 + 2);
  }
LABEL_10:
  if ((v7 & 0x1020) != 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    Mutable = *(const __CFDictionary **)(*(_QWORD *)a2 + 64);
    if (!Mutable)
    {
      v9 = CFGetAllocator(*(CFTypeRef *)a2);
      Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *(_QWORD *)(*(_QWORD *)a2 + 64) = Mutable;
    }
    Value = (void *)CFDictionaryGetValue(Mutable, key);
    if (!Value)
    {
      Property = (const __CFNumber *)IOHIDDeviceGetProperty(key, CFSTR("MaxInputReportSize"));
      valuePtr = 64;
      if (Property)
        CFNumberGetValue(Property, kCFNumberCFIndexType, &valuePtr);
      v12 = CFGetAllocator(*(CFTypeRef *)a2);
      v13 = CFDataCreateMutable(v12, valuePtr);
      Value = v13;
      if (v13)
      {
        CFDataSetLength(v13, valuePtr);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)a2 + 64), key, Value);
        CFRelease(Value);
      }
    }
    os_unfair_recursive_lock_unlock();
    v14 = *((_DWORD *)a2 + 2);
    MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
    Length = CFDataGetLength((CFDataRef)Value);
    v17 = *(CFTypeRef *)a2;
    v18 = *(void **)(*(_QWORD *)a2 + 184);
    if ((v14 & 0x20) != 0)
      IOHIDDeviceRegisterInputReportCallback(key, MutableBytePtr, Length, *((IOHIDReportCallback *)v17 + 24), v18);
    else
      IOHIDDeviceRegisterInputReportWithTimeStampCallback(key, MutableBytePtr, Length, *((IOHIDReportWithTimeStampCallback *)v17 + 25), v18);
  }
  v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x40) != 0)
  {
    IOHIDDeviceScheduleWithRunLoop(key, *(CFRunLoopRef *)(*(_QWORD *)a2 + 80), *(CFStringRef *)(*(_QWORD *)a2 + 88));
    v19 = *((_DWORD *)a2 + 2);
    if ((v19 & 0x80) == 0)
    {
LABEL_26:
      if ((v19 & 0x100) == 0)
        goto LABEL_27;
      goto LABEL_41;
    }
  }
  else if ((v19 & 0x80) == 0)
  {
    goto LABEL_26;
  }
  IOHIDDeviceUnscheduleFromRunLoop(key, *(CFRunLoopRef *)(*(_QWORD *)a2 + 80), *(CFStringRef *)(*(_QWORD *)a2 + 88));
  v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x100) == 0)
  {
LABEL_27:
    if ((v19 & 0x200) == 0)
      goto LABEL_28;
    goto LABEL_42;
  }
LABEL_41:
  IOHIDDeviceSetDispatchQueue(key, *(dispatch_queue_t *)(v4 + 96));
  v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x200) == 0)
  {
LABEL_28:
    if ((v19 & 0x400) == 0)
      goto LABEL_29;
LABEL_43:
    IOHIDDeviceActivate(key);
    if ((*((_DWORD *)a2 + 2) & 0x800) == 0)
      goto LABEL_31;
    goto LABEL_30;
  }
LABEL_42:
  v22 = MEMORY[0x1E0C809B0];
  ++*(_DWORD *)(v4 + 112);
  v23[0] = v22;
  v23[1] = 0x40000000;
  v23[2] = ____IOHIDManagerDeviceApplier_block_invoke;
  v23[3] = &__block_descriptor_tmp_14_1;
  v23[4] = v4;
  IOHIDDeviceSetCancelHandler(key, v23);
  v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x400) != 0)
    goto LABEL_43;
LABEL_29:
  if ((v19 & 0x800) != 0)
LABEL_30:
    IOHIDDeviceCancel(key);
LABEL_31:
  if (!*((_DWORD *)a2 + 3) && v5)
    *((_DWORD *)a2 + 3) = (_DWORD)v5;
LABEL_34:
  if ((a2[8] & 4) != 0)
  {
    v20 = *(void (***)(_QWORD, const void *, CFTypeRef, __IOHIDDevice *))a2;
    v21 = *(const __CFDictionary **)(*(_QWORD *)a2 + 136);
    if (v21)
    {
      v5 = CFDictionaryGetValue(v21, key);
      v20 = *(void (***)(_QWORD, const void *, CFTypeRef, __IOHIDDevice *))a2;
    }
    v20[27](v20[26], v5, v20, key);
  }
}

void __IOHIDManagerDeviceRemoved(uint64_t a1, io_registry_entry_t entry, int a3)
{
  const __CFSet *v5;
  const void *v6;
  __CFDictionary *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(_QWORD, _QWORD, uint64_t, uint64_t);
  char v11;
  _QWORD context[6];
  uint64_t entryID;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  entryID = 0;
  IORegistryEntryGetRegistryEntryID(entry, &entryID);
  if (a3 == -536870896)
  {
    os_unfair_recursive_lock_lock_with_options();
    v5 = *(const __CFSet **)(a1 + 32);
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 0x40000000;
    context[2] = ____IOHIDManagerDeviceRemoved_block_invoke;
    context[3] = &unk_1E2002660;
    context[4] = &v14;
    context[5] = entryID;
    _IOHIDCFSetApplyBlock(v5, context);
    v6 = (const void *)v15[3];
    if (!v6)
    {
LABEL_17:
      os_unfair_recursive_lock_unlock();
      goto LABEL_18;
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), v6);
    v7 = *(__CFDictionary **)(a1 + 64);
    if (v7)
      CFDictionaryRemoveValue(v7, (const void *)v15[3]);
    if ((*(_DWORD *)(a1 + 152) & 5) == 1 && CFSetContainsValue(*(CFSetRef *)(a1 + 32), (const void *)v15[3]))
      __IOHIDDeviceSaveProperties(v15[3], 0);
    v8 = *(_QWORD *)(a1 + 96);
    v9 = *(_QWORD *)(a1 + 80);
    os_unfair_recursive_lock_unlock();
    if ((*(_BYTE *)(a1 + 152) & 8) == 0 && v8)
    {
      IOHIDDeviceCancel((IOHIDDeviceRef)v15[3]);
      IOHIDDeviceActivate((IOHIDDeviceRef)v15[3]);
    }
    os_unfair_recursive_lock_lock_with_options();
    v10 = *(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1 + 232);
    if (v10)
    {
      if (v9)
      {
LABEL_15:
        v10(*(_QWORD *)(a1 + 224), 0, a1, v15[3]);
        goto LABEL_16;
      }
      v11 = atomic_load((unsigned int *)(a1 + 116));
      if ((v11 & 1) != 0)
      {
        v10 = *(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1 + 232);
        goto LABEL_15;
      }
    }
LABEL_16:
    os_unfair_recursive_lock_unlock();
    os_unfair_recursive_lock_lock_with_options();
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 32), (const void *)v15[3]);
    goto LABEL_17;
  }
LABEL_18:
  _Block_object_dispose(&v14, 8);
}

uint64_t __IOHIDManagerInitialEnumCallback(uint64_t a1)
{
  uint64_t v2;
  __CFRunLoopSource *v3;
  const void *v4;
  const void *v5;
  _QWORD v7[2];

  v7[0] = a1;
  v7[1] = 4;
  os_unfair_recursive_lock_lock_with_options();
  v2 = *(_QWORD *)(a1 + 216);
  os_unfair_recursive_lock_unlock();
  if (v2)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFSetApplyFunction(*(CFSetRef *)(a1 + 120), (CFSetApplierFunction)__IOHIDManagerDeviceApplier, v7);
    os_unfair_recursive_lock_unlock();
  }
  os_unfair_recursive_lock_lock_with_options();
  v3 = *(__CFRunLoopSource **)(a1 + 128);
  if (v3)
  {
    CFRunLoopSourceInvalidate(v3);
    CFRelease(*(CFTypeRef *)(a1 + 128));
    *(_QWORD *)(a1 + 128) = 0;
  }
  v4 = *(const void **)(a1 + 120);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v5 = *(const void **)(a1 + 136);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 136) = 0;
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDQueueRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDQueueTypeID = result;
  return result;
}

CFTypeID IOHIDQueueGetTypeID(void)
{
  CFTypeID result;

  result = __kIOHIDQueueTypeID;
  if (!__kIOHIDQueueTypeID)
  {
    pthread_once(&__queueTypeInit, (void (*)(void))__IOHIDQueueRegister);
    return __kIOHIDQueueTypeID;
  }
  return result;
}

IOHIDQueueRef IOHIDQueueCreate(CFAllocatorRef allocator, IOHIDDeviceRef device, CFIndex depth, IOOptionBits options)
{
  uint64_t v4;
  uint64_t IOCFPlugInInterface;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, _QWORD, _QWORD, uint64_t *);
  const __CFUUID *v11;
  CFUUIDBytes v12;
  int v13;
  __IOHIDQueue *Instance;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;

  v19 = 0;
  if (!device)
    return 0;
  v4 = *(_QWORD *)&options;
  IOCFPlugInInterface = _IOHIDDeviceGetIOCFPlugInInterface((uint64_t)device);
  if (!IOCFPlugInInterface)
    return 0;
  v9 = IOCFPlugInInterface;
  v10 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t *))(*(_QWORD *)IOCFPlugInInterface + 8);
  v11 = CFUUIDGetConstantUUIDWithBytes(0, 0x2Eu, 0xC7u, 0x8Bu, 0xDBu, 0x9Fu, 0x4Eu, 0x11u, 0xDAu, 0xB6u, 0x5Cu, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
  v12 = CFUUIDGetUUIDBytes(v11);
  v13 = v10(v9, *(_QWORD *)&v12.byte0, *(_QWORD *)&v12.byte8, &v19);
  Instance = 0;
  if (v13)
    v15 = 1;
  else
    v15 = v19 == 0;
  if (!v15)
  {
    v16 = __kIOHIDQueueTypeID;
    if (!__kIOHIDQueueTypeID)
    {
      pthread_once(&__queueTypeInit, (void (*)(void))__IOHIDQueueRegister);
      v16 = __kIOHIDQueueTypeID;
    }
    Instance = (__IOHIDQueue *)_IOHIDObjectCreateInstance((uint64_t)allocator, v16, 0xB8uLL);
    v17 = v19;
    if (Instance)
    {
      *((_QWORD *)Instance + 22) = device;
      *((_QWORD *)Instance + 3) = v17;
      *((_QWORD *)Instance + 4) = v9;
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
      (*(void (**)(_QWORD, CFIndex, uint64_t))(**((_QWORD **)Instance + 3) + 40))(*((_QWORD *)Instance + 3), depth, v4);
    }
    else
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
    }
  }
  return Instance;
}

IOHIDDeviceRef IOHIDQueueGetDevice(IOHIDQueueRef queue)
{
  return (IOHIDDeviceRef)*((_QWORD *)queue + 22);
}

CFIndex IOHIDQueueGetDepth(IOHIDQueueRef queue)
{
  unsigned int v2;

  v2 = 0;
  (*(void (**)(_QWORD, unsigned int *))(**((_QWORD **)queue + 3) + 48))(*((_QWORD *)queue + 3), &v2);
  return v2;
}

void IOHIDQueueSetDepth(IOHIDQueueRef queue, CFIndex depth)
{
  (*(void (**)(_QWORD, CFIndex, _QWORD))(**((_QWORD **)queue + 3) + 40))(*((_QWORD *)queue + 3), depth, 0);
}

void IOHIDQueueAddElement(IOHIDQueueRef queue, IOHIDElementRef element)
{
  __CFSet *Mutable;
  const __CFAllocator *v5;

  (*(void (**)(_QWORD, IOHIDElementRef, _QWORD))(**((_QWORD **)queue + 3) + 56))(*((_QWORD *)queue + 3), element, 0);
  Mutable = (__CFSet *)*((_QWORD *)queue + 24);
  if (Mutable
    || (v5 = CFGetAllocator(queue),
        Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E0C9B3B0]),
        (*((_QWORD *)queue + 24) = Mutable) != 0))
  {
    CFSetAddValue(Mutable, element);
  }
}

void IOHIDQueueRemoveElement(IOHIDQueueRef queue, IOHIDElementRef element)
{
  __CFSet *v4;

  (*(void (**)(_QWORD, IOHIDElementRef, _QWORD))(**((_QWORD **)queue + 3) + 64))(*((_QWORD *)queue + 3), element, 0);
  v4 = (__CFSet *)*((_QWORD *)queue + 24);
  if (v4)
    CFSetRemoveValue(v4, element);
}

Boolean IOHIDQueueContainsElement(IOHIDQueueRef queue, IOHIDElementRef element)
{
  Boolean v3;

  v3 = 0;
  (*(void (**)(_QWORD, IOHIDElementRef, Boolean *, _QWORD))(**((_QWORD **)queue + 3) + 72))(*((_QWORD *)queue + 3), element, &v3, 0);
  return v3;
}

void IOHIDQueueStart(IOHIDQueueRef queue)
{
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)queue + 3) + 80))(*((_QWORD *)queue + 3), 0);
}

void IOHIDQueueStop(IOHIDQueueRef queue)
{
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)queue + 3) + 88))(*((_QWORD *)queue + 3), 0);
}

void IOHIDQueueScheduleWithRunLoop(IOHIDQueueRef queue, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!__IOHIDQueueSetupAsyncSupport((uint64_t)queue))
    IOHIDQueueScheduleWithRunLoop_cold_1(&v6, v7);
  *((_QWORD *)queue + 16) = runLoop;
  *((_QWORD *)queue + 17) = runLoopMode;
  CFRunLoopAddSource(runLoop, *((CFRunLoopSourceRef *)queue + 5), runLoopMode);
}

BOOL __IOHIDQueueSetupAsyncSupport(uint64_t a1)
{
  int v2;
  void (__cdecl *perform)(void *);
  BOOL v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  CFRunLoopSourceContext v9;

  memset(&v9.info, 0, 72);
  v9.version = 1;
  if (*(_QWORD *)(a1 + 128) || *(_QWORD *)(a1 + 144))
    __IOHIDQueueSetupAsyncSupport_cold_1();
  if (*(_QWORD *)(a1 + 40))
    return 1;
  v2 = (*(uint64_t (**)(_QWORD, void (__cdecl **)(void *)))(**(_QWORD **)(a1 + 24) + 32))(*(_QWORD *)(a1 + 24), &v9.perform);
  perform = v9.perform;
  if (v2)
    v4 = 1;
  else
    v4 = v9.perform == 0;
  if (v4)
    return 0;
  *(_QWORD *)(a1 + 40) = v9.perform;
  CFRunLoopSourceGetContext((CFRunLoopSourceRef)perform, &v9);
  v5 = *(_OWORD *)&v9.retain;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)&v9.version;
  *(_OWORD *)(a1 + 64) = v5;
  v6 = *(_OWORD *)&v9.hash;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)&v9.copyDescription;
  *(_OWORD *)(a1 + 96) = v6;
  v7 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 112) = v9.cancel;
  *(_QWORD *)(a1 + 120) = v7;
  return v7 != 0;
}

void IOHIDQueueUnscheduleFromRunLoop(IOHIDQueueRef queue, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  __CFRunLoop *v4;
  _QWORD *v5;

  v5 = (_QWORD *)((char *)queue + 128);
  v4 = (__CFRunLoop *)*((_QWORD *)queue + 16);
  if (v4)
  {
    CFRunLoopRemoveSource(v4, *((CFRunLoopSourceRef *)queue + 5), *((CFRunLoopMode *)queue + 17));
    *v5 = 0;
    v5[1] = 0;
  }
}

void IOHIDQueueSetDispatchQueue(IOHIDQueueRef queue, dispatch_queue_t dispatchQueue)
{
  const char *label;
  const char *v5;
  dispatch_queue_t v6;
  uint64_t v7;
  uint64_t v8;
  char __str[16];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!__IOHIDQueueSetupAsyncSupport((uint64_t)queue))
    IOHIDQueueScheduleWithRunLoop_cold_1(&v8, __str);
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  *(_OWORD *)__str = 0u;
  v10 = 0u;
  label = dispatch_queue_get_label(dispatchQueue);
  v5 = "";
  if (label)
    v5 = label;
  snprintf(__str, 0x100uLL, "%s.IOHIDQueueRef", v5);
  v6 = dispatch_queue_create_with_target_V2(__str, 0, dispatchQueue);
  *((_QWORD *)queue + 18) = v6;
  if (v6)
  {
    _IOHIDObjectInternalRetain(queue);
    v7 = dispatch_mach_create();
    *((_QWORD *)queue + 19) = v7;
    if (!v7)
      _IOHIDObjectInternalRelease(queue);
  }
}

void IOHIDQueueSetCancelHandler(IOHIDQueueRef queue, dispatch_block_t handler)
{
  uint64_t v2;
  _OWORD v3[5];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (!handler || *((_QWORD *)queue + 20))
    IOHIDQueueSetCancelHandler_cold_1(&v2, v3);
  *((_QWORD *)queue + 20) = _Block_copy(handler);
}

void IOHIDQueueActivate(IOHIDQueueRef queue)
{
  BOOL v1;
  IOHIDQueueRef v2;
  unsigned int *v3;
  unsigned int v4;

  if (*((_QWORD *)queue + 18))
    v1 = *((_QWORD *)queue + 16) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    queue = (IOHIDQueueRef)_os_crash_msg();
    __break(1u);
  }
  v2 = queue;
  v3 = (unsigned int *)((char *)queue + 168);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if ((v4 & 1) == 0)
  {
    CFMachPortGetPort(*((CFMachPortRef *)queue + 15));
    dispatch_mach_connect();
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v2 + 3) + 80))(*((_QWORD *)v2 + 3), 0);
  }
}

void IOHIDQueueCancel(IOHIDQueueRef queue)
{
  BOOL v1;
  unsigned int *v2;
  unsigned int v3;

  if (*((_QWORD *)queue + 18))
    v1 = *((_QWORD *)queue + 16) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    queue = (IOHIDQueueRef)_os_crash_msg();
    __break(1u);
  }
  v2 = (unsigned int *)((char *)queue + 168);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 | 2, v2));
  if ((v3 & 2) == 0)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)queue + 3) + 88))(*((_QWORD *)queue + 3), 0);
    dispatch_mach_cancel();
  }
}

void IOHIDQueueRegisterValueAvailableCallback(IOHIDQueueRef queue, IOHIDCallback callback, void *context)
{
  __CFDictionary *Mutable;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (atomic_load((unsigned int *)queue + 42))
    IOHIDQueueRegisterValueAvailableCallback_cold_3();
  if (callback)
  {
    Mutable = (__CFDictionary *)*((_QWORD *)queue + 23);
    if (Mutable
      || (Mutable = CFDictionaryCreateMutable(0, 0, 0, 0), (*((_QWORD *)queue + 23) = Mutable) != 0))
    {
      CFDictionarySetValue(Mutable, callback, context);
      (*(void (**)(_QWORD, void (*)(CFDictionaryRef *, unsigned int), IOHIDQueueRef))(**((_QWORD **)queue + 3) + 96))(*((_QWORD *)queue + 3), __IOHIDQueueValueAvailableCallback, queue);
    }
    else
    {
      v16 = _IOHIDLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        IOHIDQueueRegisterValueAvailableCallback_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  else
  {
    v8 = _IOHIDLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      IOHIDQueueRegisterValueAvailableCallback_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
}

void __IOHIDQueueValueAvailableCallback(CFDictionaryRef *cf, unsigned int a2)
{
  _QWORD v3[2];

  if (cf)
  {
    if (cf[23])
    {
      v3[1] = cf;
      v3[0] = a2;
      CFRetain(cf);
      CFDictionaryApplyFunction(cf[23], (CFDictionaryApplierFunction)_IOHIDCallbackApplier, v3);
      CFRelease(cf);
    }
  }
}

IOHIDValueRef IOHIDQueueCopyNextValue(IOHIDQueueRef queue)
{
  __IOHIDValue *v2;

  v2 = 0;
  (*(void (**)(_QWORD, __IOHIDValue **, _QWORD, _QWORD))(**((_QWORD **)queue + 3) + 104))(*((_QWORD *)queue + 3), &v2, 0, 0);
  return v2;
}

IOHIDValueRef IOHIDQueueCopyNextValueWithTimeout(IOHIDQueueRef queue, CFTimeInterval timeout)
{
  __IOHIDValue *v3;

  v3 = 0;
  (*(void (**)(_QWORD, __IOHIDValue **, _QWORD, _QWORD))(**((_QWORD **)queue + 3) + 104))(*((_QWORD *)queue + 3), &v3, (timeout * 1000.0), 0);
  return v3;
}

CFArrayRef _IOHIDQueueCopyElements(CFSetRef *a1)
{
  const __CFSet *v2;
  CFIndex Count;
  CFIndex v4;
  size_t v5;
  void *v6;
  const __CFAllocator *v7;
  CFArrayRef v8;

  v2 = a1[24];
  if (!v2)
    return 0;
  Count = CFSetGetCount(v2);
  if (!Count)
    return 0;
  v4 = Count;
  v5 = 8 * Count;
  v6 = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  bzero(v6, v5);
  CFSetGetValues(a1[24], (const void **)v6);
  v7 = CFGetAllocator(a1);
  v8 = CFArrayCreate(v7, (const void **)v6, v4, MEMORY[0x1E0C9B378]);
  free(v6);
  return v8;
}

void __IOHIDQueueExtRelease(uint64_t a1)
{
  unsigned int v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  _OWORD v6[5];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 144))
  {
    v2 = atomic_load((unsigned int *)(a1 + 168));
    if (v2 != 3)
      __IOHIDQueueExtRelease_cold_1(&v5, v6, (unsigned int *)(a1 + 168));
  }
  v3 = *(const void **)(a1 + 192);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 192) = 0;
  }
  if (*(_QWORD *)(a1 + 176))
    *(_QWORD *)(a1 + 176) = 0;
  v4 = *(const void **)(a1 + 184);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 184) = 0;
  }
}

uint64_t __IOHIDQueueIntRelease(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *(_QWORD *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t __IOHIDTransactionRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDTransactionTypeID = result;
  return result;
}

CFTypeID IOHIDTransactionGetTypeID(void)
{
  CFTypeID result;

  result = __kIOHIDTransactionTypeID;
  if (!__kIOHIDTransactionTypeID)
  {
    pthread_once(&__transactionTypeInit, (void (*)(void))__IOHIDTransactionRegister);
    return __kIOHIDTransactionTypeID;
  }
  return result;
}

IOHIDTransactionRef IOHIDTransactionCreate(CFAllocatorRef allocator, IOHIDDeviceRef device, IOHIDTransactionDirectionType direction, IOOptionBits options)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  uint64_t IOCFPlugInInterface;
  uint64_t Instance;
  uint64_t (*v10)(uint64_t, _QWORD, _QWORD, uint64_t *);
  const __CFUUID *v11;
  CFUUIDBytes v12;
  int v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v18 = 0;
  if (!device)
    return 0;
  v4 = *(_QWORD *)&options;
  v5 = *(_QWORD *)&direction;
  v6 = device;
  IOCFPlugInInterface = _IOHIDDeviceGetIOCFPlugInInterface((uint64_t)device);
  Instance = IOCFPlugInInterface;
  if (IOCFPlugInInterface)
  {
    v10 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t *))(*(_QWORD *)IOCFPlugInInterface + 8);
    v11 = CFUUIDGetConstantUUIDWithBytes(0, 0x1Fu, 0x2Eu, 0x78u, 0xFAu, 0x9Fu, 0xFAu, 0x11u, 0xDAu, 0x90u, 0xB4u, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
    v12 = CFUUIDGetUUIDBytes(v11);
    v13 = v10(Instance, *(_QWORD *)&v12.byte0, *(_QWORD *)&v12.byte8, &v18);
    Instance = 0;
    if (!v13 && v18 != 0)
    {
      v15 = __kIOHIDTransactionTypeID;
      if (!__kIOHIDTransactionTypeID)
      {
        pthread_once(&__transactionTypeInit, (void (*)(void))__IOHIDTransactionRegister);
        v15 = __kIOHIDTransactionTypeID;
      }
      Instance = _IOHIDObjectCreateInstance((uint64_t)allocator, v15, 0x38uLL);
      v16 = v18;
      if (Instance)
      {
        *(_QWORD *)(Instance + 24) = v18;
        *(_DWORD *)(Instance + 64) = v4;
        if ((v4 & 1) == 0)
        {
          v6 = CFRetain(v6);
          v16 = *(_QWORD *)(Instance + 24);
        }
        *(_QWORD *)(Instance + 56) = v6;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16 + 40))(v16, v5, v4);
      }
      else
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
      }
    }
  }
  return (IOHIDTransactionRef)Instance;
}

IOHIDDeviceRef IOHIDTransactionGetDevice(IOHIDTransactionRef transaction)
{
  return (IOHIDDeviceRef)*((_QWORD *)transaction + 7);
}

IOHIDTransactionDirectionType IOHIDTransactionGetDirection(IOHIDTransactionRef transaction)
{
  IOHIDTransactionDirectionType v2;

  v2 = kIOHIDTransactionDirectionTypeInput;
  (*(void (**)(_QWORD, IOHIDTransactionDirectionType *))(**((_QWORD **)transaction + 3) + 48))(*((_QWORD *)transaction + 3), &v2);
  return v2;
}

void IOHIDTransactionSetDirection(IOHIDTransactionRef transaction, IOHIDTransactionDirectionType direction)
{
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)transaction + 3) + 40))(*((_QWORD *)transaction + 3), *(_QWORD *)&direction, 0);
}

void IOHIDTransactionAddElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
  (*(void (**)(_QWORD, IOHIDElementRef, _QWORD))(**((_QWORD **)transaction + 3) + 56))(*((_QWORD *)transaction + 3), element, 0);
}

void IOHIDTransactionRemoveElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
  (*(void (**)(_QWORD, IOHIDElementRef, _QWORD))(**((_QWORD **)transaction + 3) + 64))(*((_QWORD *)transaction + 3), element, 0);
}

Boolean IOHIDTransactionContainsElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
  Boolean v3;

  v3 = 0;
  (*(void (**)(_QWORD, IOHIDElementRef, Boolean *, _QWORD))(**((_QWORD **)transaction + 3) + 72))(*((_QWORD *)transaction + 3), element, &v3, 0);
  return v3;
}

void IOHIDTransactionScheduleWithRunLoop(IOHIDTransactionRef transaction, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  CFTypeRef v6;
  CFTypeRef *v7;
  CFTypeID v8;
  CFTypeID v9;

  v7 = (CFTypeRef *)((char *)transaction + 32);
  v6 = (CFTypeRef)*((_QWORD *)transaction + 4);
  if (v6
    || !(*(unsigned int (**)(_QWORD, CFTypeRef *))(**((_QWORD **)transaction + 3) + 32))(*((_QWORD *)transaction + 3), v7)&& (v6 = *v7) != 0)
  {
    *((_QWORD *)transaction + 5) = runLoop;
    *((_QWORD *)transaction + 6) = runLoopMode;
    v8 = CFGetTypeID(v6);
    if (v8 == CFRunLoopSourceGetTypeID())
    {
      CFRunLoopAddSource(*((CFRunLoopRef *)transaction + 5), *((CFRunLoopSourceRef *)transaction + 4), *((CFRunLoopMode *)transaction + 6));
    }
    else
    {
      v9 = CFGetTypeID(*v7);
      if (v9 == CFRunLoopTimerGetTypeID())
        CFRunLoopAddTimer(*((CFRunLoopRef *)transaction + 5), *((CFRunLoopTimerRef *)transaction + 4), *((CFRunLoopMode *)transaction + 6));
    }
  }
}

void IOHIDTransactionUnscheduleFromRunLoop(IOHIDTransactionRef transaction, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  const void *v4;
  CFTypeID v7;
  CFTypeID v8;

  v4 = (const void *)*((_QWORD *)transaction + 4);
  if (v4)
  {
    v7 = CFGetTypeID(v4);
    if (v7 == CFRunLoopSourceGetTypeID())
    {
      CFRunLoopRemoveSource(runLoop, *((CFRunLoopSourceRef *)transaction + 4), runLoopMode);
    }
    else
    {
      v8 = CFGetTypeID(*((CFTypeRef *)transaction + 4));
      if (v8 == CFRunLoopTimerGetTypeID())
        CFRunLoopRemoveTimer(runLoop, *((CFRunLoopTimerRef *)transaction + 4), runLoopMode);
    }
    *((_QWORD *)transaction + 5) = 0;
    *((_QWORD *)transaction + 6) = 0;
  }
}

void IOHIDTransactionSetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOHIDValueRef value, IOOptionBits options)
{
  (*(void (**)(_QWORD, IOHIDElementRef, IOHIDValueRef, _QWORD))(**((_QWORD **)transaction + 3) + 80))(*((_QWORD *)transaction + 3), element, value, *(_QWORD *)&options);
}

IOHIDValueRef IOHIDTransactionGetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOOptionBits options)
{
  __IOHIDValue *v4;

  v4 = 0;
  if ((*(unsigned int (**)(_QWORD, IOHIDElementRef, __IOHIDValue **, _QWORD))(**((_QWORD **)transaction + 3)
                                                                                        + 88))(*((_QWORD *)transaction + 3), element, &v4, *(_QWORD *)&options))
  {
    return 0;
  }
  else
  {
    return v4;
  }
}

IOReturn IOHIDTransactionCommit(IOHIDTransactionRef transaction)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)transaction + 3) + 96))(*((_QWORD *)transaction + 3), 0, 0, 0, 0);
}

IOReturn IOHIDTransactionCommitWithCallback(IOHIDTransactionRef transaction, CFTimeInterval timeout, IOHIDCallback callback, void *context)
{
  _QWORD *v8;
  void *v9;
  IOReturn v10;

  v8 = malloc_type_malloc(0x18uLL, 0xA0040114AFA65uLL);
  if (!v8)
    return -536870211;
  v9 = v8;
  *v8 = context;
  v8[1] = callback;
  v8[2] = transaction;
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, void (*)(_QWORD *, uint64_t, uint64_t), _QWORD *, _QWORD))(**((_QWORD **)transaction + 3) + 96))(*((_QWORD *)transaction + 3), timeout, __IOHIDTransactionCommitCallback, v8, 0);
  if (v10)
    free(v9);
  return v10;
}

void __IOHIDTransactionCommitCallback(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  void (*v4)(_QWORD);

  if (a1)
  {
    if (*(_QWORD *)(a1[2] + 24) == a3)
    {
      v4 = (void (*)(_QWORD))a1[1];
      if (v4)
        v4(*a1);
    }
    free(a1);
  }
}

void IOHIDTransactionClear(IOHIDTransactionRef transaction)
{
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)transaction + 3) + 104))(*((_QWORD *)transaction + 3), 0);
}

void __IOHIDTransactionIntRelease(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  if ((*(_BYTE *)(a1 + 64) & 1) == 0)
  {
    v3 = *(const void **)(a1 + 56);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
}

void _IOHIDEventRemoveAttachment(uint64_t a1, const void *a2)
{
  __CFDictionary *v2;

  if (a1 && a2)
  {
    v2 = *(__CFDictionary **)(a1 + 56);
    if (v2)
      CFDictionaryRemoveValue(v2, a2);
  }
}

uint64_t _IOHIDEventSetContext(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = a2;
  return result;
}

uint64_t _IOHIDEventGetContext(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t IOHIDEventSetTimeStampOfType(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v5;
  unsigned int v6;

  v5 = result;
  if (dynLinkrosetta_is_current_process_translated_0[0])
  {
    result = dynLinkrosetta_is_current_process_translated_0[0]();
    if ((_DWORD)result)
    {
      if (dynLinkrosetta_convert_to_system_absolute_time_0[0])
      {
        result = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(a2);
        a2 = result;
      }
    }
  }
  *(_QWORD *)(v5 + 8) = a2;
  if (a3 == 1)
  {
    v6 = *(_DWORD *)(v5 + 32) | 0x80;
  }
  else
  {
    if (a3)
      return result;
    v6 = *(_DWORD *)(v5 + 32) & 0xFFFFFF7F;
  }
  *(_DWORD *)(v5 + 32) = v6;
  return result;
}

__CFData *IOHIDEventCreateDataInternal(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t LengthAndCount;
  CFIndex v5;
  __CFData *Mutable;
  __CFData *v7;
  UInt8 *MutableBytePtr;

  if (!a2)
    return 0;
  LengthAndCount = __IOHIDEventGetLengthAndCount(a2, (_QWORD *)(a2 + 96));
  if (!LengthAndCount)
    return 0;
  v5 = LengthAndCount + *(_QWORD *)(a2 + 88) + 28;
  Mutable = CFDataCreateMutable(a1, v5);
  v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    __IOHIDEventReadBytesHelper(a2, (uint64_t)MutableBytePtr, v5);
  }
  return v7;
}

HIDEvent *IOHIDEventCreateKeyboardEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, int a6)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 3, a2, a6 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = a4;
    *((_DWORD *)eventData + 5) = a5;
    *((_BYTE *)eventData + 28) = 1;
  }
  return result;
}

HIDEvent *IOHIDEventCreateUnicodeEvent(uint64_t a1, uint64_t a2, const void *a3, size_t a4, int a5, int a6)
{
  return IOHIDEventCreateUnicodeEventWithQuality(a1, a2, a3, a4, a5, a6, 1.0);
}

HIDEvent *IOHIDEventCreateUnicodeEventWithQuality(uint64_t a1, uint64_t a2, const void *a3, size_t a4, int a5, int a6, double a7)
{
  uint64_t v11;
  HIDEvent *v12;
  IOHIDEventData *eventData;

  v11 = a2;
  v12 = _IOHIDEventCreate(a1, a4 + 28, 30, a2, a6 | 1u);
  if (v12)
  {
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      v11 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v11);
    }
    v12->_event.timeStamp = v11;
    eventData = v12->_event.eventData;
    *((_DWORD *)eventData + 4) = a5;
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a7, 0x10uLL);
    *((_DWORD *)eventData + 6) = a4;
    memmove((char *)eventData + 28, a3, a4);
  }
  return v12;
}

HIDEvent *IOHIDEventCreateButtonEvent(uint64_t a1, uint64_t a2, int a3, int a4)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 2, a2, a4 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_WORD *)eventData + 12) = 256;
    *((_DWORD *)eventData + 7) = 0;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = 0x10000;
  }
  return result;
}

HIDEvent *__IOHIDEventCreateButtonEvent(uint64_t a1, uint64_t a2, int a3, char a4, int a5, int a6, double a7)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 2, a2, a6 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_BYTE *)eventData + 24) = a4;
    *((_DWORD *)eventData + 7) = a5;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a7, 0x10uLL);
    *((_BYTE *)eventData + 25) = 1;
  }
  return result;
}

HIDEvent *IOHIDEventCreateButtonEventWithPressure(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  return __IOHIDEventCreateButtonEvent(a1, a2, a3, 0, 0, a4, a5);
}

HIDEvent *IOHIDEventCreateMouseEvent(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, double a5, double a6, double a7)
{
  return IOHIDEventCreateRelativePointerEvent(a1, a2, a3, a3, a4, a5, a6, a7);
}

HIDEvent *IOHIDEventCreateRelativePointerEvent(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, double a6, double a7, double a8)
{
  HIDEvent *v15;
  HIDEvent *v16;
  IOHIDEventData *eventData;
  uint64_t EventWithOptions;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  double v22;
  HIDEvent *ButtonEvent;
  HIDEvent *v24;
  BOOL v25;

  v15 = IOHIDEventCreate(a1, 17, a2, a5);
  v16 = v15;
  if (v15)
  {
    eventData = v15->_event.eventData;
    if (eventData)
    {
      EventWithOptions = IOHIDEventGetEventWithOptions(v15, 17, 4026531840);
      if (EventWithOptions)
        *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 16) = vcvtd_n_s64_f64(a6, 0x10uLL);
      v19 = IOHIDEventGetEventWithOptions(v16, 17, 4026531840);
      if (v19)
        *(_DWORD *)(*(_QWORD *)(v19 + 104) + 20) = vcvtd_n_s64_f64(a7, 0x10uLL);
      v20 = IOHIDEventGetEventWithOptions(v16, 17, 4026531840);
      if (v20)
        *(_DWORD *)(*(_QWORD *)(v20 + 104) + 24) = vcvtd_n_s64_f64(a8, 0x10uLL);
      *((_DWORD *)eventData + 7) = a3;
      v21 = a4 ^ a3;
      if (a4 != a3)
      {
        do
        {
          if ((v21 & 1) != 0)
          {
            if ((a3 & 1) != 0)
              v22 = 1.0;
            else
              v22 = 0.0;
            ButtonEvent = __IOHIDEventCreateButtonEvent(a1, a2, *((_DWORD *)eventData + 7), 1, a3 & 1, 0, v22);
            if (ButtonEvent)
            {
              v24 = ButtonEvent;
              IOHIDEventAppendEvent((uint64_t)v16, ButtonEvent);
              CFRelease(v24);
            }
          }
          a3 >>= 1;
          v25 = v21 >= 2;
          v21 >>= 1;
        }
        while (v25);
      }
    }
    else
    {
      CFRelease(v15);
      return 0;
    }
  }
  return v16;
}

HIDEvent *IOHIDEventCreateTranslationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  HIDEvent *v9;
  HIDEvent *v10;
  uint64_t EventWithOptions;
  uint64_t v12;
  uint64_t v13;

  v9 = IOHIDEventCreate(a1, 4, a2, a3);
  v10 = v9;
  if (v9)
  {
    EventWithOptions = IOHIDEventGetEventWithOptions(v9, 4, 4026531840);
    if (EventWithOptions)
      *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 16) = vcvtd_n_s64_f64(a4, 0x10uLL);
    v12 = IOHIDEventGetEventWithOptions(v10, 4, 4026531840);
    if (v12)
      *(_DWORD *)(*(_QWORD *)(v12 + 104) + 20) = vcvtd_n_s64_f64(a5, 0x10uLL);
    v13 = IOHIDEventGetEventWithOptions(v10, 4, 4026531840);
    if (v13)
      *(_DWORD *)(*(_QWORD *)(v13 + 104) + 24) = vcvtd_n_s64_f64(a6, 0x10uLL);
  }
  return v10;
}

HIDEvent *IOHIDEventCreateRotationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 5, a3, a4, a5, a6);
}

HIDEvent *__IOHIDEventCreateAxisEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6, double a7)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, a3, a2, a4);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a6, 0x10uLL);
    *((_DWORD *)eventData + 6) = vcvtd_n_s64_f64(a7, 0x10uLL);
  }
  return result;
}

HIDEvent *IOHIDEventCreateScrollEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 6, a3, a4, a5, a6);
}

HIDEvent *IOHIDEventCreateScaleEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 7, a3, a4, a5, a6);
}

HIDEvent *IOHIDEventCreateVelocityEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 9, a3, a4, a5, a6);
}

HIDEvent *IOHIDEventCreateDeviceOrientationEventWithUsage(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 10, a2, a4);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 8) = 1;
    *((_DWORD *)eventData + 4) = a3;
  }
  return result;
}

HIDEvent *IOHIDEventCreatePolarOrientationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 10, a2, a3);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = vcvtd_n_s64_f64(a4, 0x10uLL);
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *((_DWORD *)eventData + 6) = vcvtd_n_s64_f64(a6, 0x10uLL);
    *((_DWORD *)eventData + 8) = 0;
  }
  return result;
}

HIDEvent *IOHIDEventCreateQuaternionOrientationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 10, a2, a3);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = vcvtd_n_s64_f64(a4, 0x10uLL);
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *((_DWORD *)eventData + 6) = vcvtd_n_s64_f64(a6, 0x10uLL);
    *((_DWORD *)eventData + 7) = vcvtd_n_s64_f64(a7, 0x10uLL);
    *((_DWORD *)eventData + 8) = 3;
  }
  return result;
}

HIDEvent *IOHIDEventCreateAccelerometerEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 13, 0, 0, 0, a3, a4, a5, a6);
}

HIDEvent *IOHIDEventCreateAccelerometerEventWithType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 13, a3, a4, a5, a6, a7, a8, a9);
}

HIDEvent *__IOHIDEventCreateMotionEvent(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7, double a8, double a9, double a10)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, a3, a2, a7);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = vcvtd_n_s64_f64(a8, 0x10uLL);
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a9, 0x10uLL);
    *((_DWORD *)eventData + 6) = vcvtd_n_s64_f64(a10, 0x10uLL);
    *((_DWORD *)eventData + 7) = a4;
    *((_DWORD *)eventData + 8) = a5;
    *((_DWORD *)eventData + 9) = a6;
  }
  return result;
}

HIDEvent *IOHIDEventCreateGyroEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 20, 0, 0, 0, a3, a4, a5, a6);
}

HIDEvent *IOHIDEventCreateGyroEventWithType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 20, a3, a4, a5, a6, a7, a8, a9);
}

HIDEvent *IOHIDEventCreateCompassEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 21, 0, 0, 0, a3, a4, a5, a6);
}

HIDEvent *IOHIDEventCreateCompassEventWithType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 21, a3, a4, a5, a6, a7, a8, a9);
}

HIDEvent *IOHIDEventCreateAmbientLightSensorEvent(uint64_t a1, uint64_t a2, int a3, int a4)
{
  HIDEvent *result;

  result = IOHIDEventCreate(a1, 12, a2, a4 | 1u);
  if (result)
    *((_DWORD *)result->_event.eventData + 4) = a3;
  return result;
}

HIDEvent *IOHIDEventCreateProximtyLevelEvent(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 14, a2, a5 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = 0;
    *((_DWORD *)eventData + 5) = a4;
  }
  return result;
}

HIDEvent *IOHIDEventCreateDigitizerStylusEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, int a17)
{
  int v20;
  HIDEvent *DigitizerEvent;
  HIDEvent *v22;
  uint64_t EventWithOptions;

  v20 = a17;
  if (a7)
    v20 = a17 | 0x10000;
  if (a8)
    v20 |= 0x40000u;
  DigitizerEvent = IOHIDEventCreateDigitizerEvent(a1, a2, 0, a3, a4, a5, a6, a7, a9, a10, a11, a12, a14, 0, v20);
  v22 = DigitizerEvent;
  if (DigitizerEvent)
  {
    *((_DWORD *)DigitizerEvent->_event.eventData + 16) = 0;
    EventWithOptions = IOHIDEventGetEventWithOptions(DigitizerEvent, 11, 4026531840);
    if (EventWithOptions)
      *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 56) = vcvtd_n_s64_f64(a13, 0x10uLL);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB000Du, 4026531840, a15);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB000Eu, 4026531840, a16);
  }
  return v22;
}

HIDEvent *IOHIDEventCreateDigitizerStylusEventWithPolarOrientation(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, int a17)
{
  int v20;
  HIDEvent *DigitizerEvent;
  HIDEvent *v22;
  uint64_t EventWithOptions;

  v20 = a17;
  if (a7)
    v20 = a17 | 0x10000;
  if (a8)
    v20 |= 0x40000u;
  DigitizerEvent = IOHIDEventCreateDigitizerEvent(a1, a2, 0, a3, a4, a5, a6, a7, a9, a10, a11, a12, a14, 0, v20);
  v22 = DigitizerEvent;
  if (DigitizerEvent)
  {
    *((_DWORD *)DigitizerEvent->_event.eventData + 16) = 1;
    EventWithOptions = IOHIDEventGetEventWithOptions(DigitizerEvent, 11, 4026531840);
    if (EventWithOptions)
      *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 56) = vcvtd_n_s64_f64(a13, 0x10uLL);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB000Fu, 4026531840, a15);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0010u, 4026531840, a16);
  }
  return v22;
}

HIDEvent *IOHIDEventCreateDigitizerFingerEventWithQuality(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, double a17, double a18)
{
  HIDEvent *DigitizerEvent;
  HIDEvent *v22;

  DigitizerEvent = IOHIDEventCreateDigitizerEvent(a1, a2, 2, a3, a4, a5, 0, a6, a9, a10, a11, a12, a13, a7, a8);
  v22 = DigitizerEvent;
  if (DigitizerEvent)
  {
    *((_DWORD *)DigitizerEvent->_event.eventData + 16) = 2;
    IOHIDEventSetFloatValueWithOptions(DigitizerEvent, 0xB0011u, 4026531840, a16);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0012u, 4026531840, a17);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0013u, 4026531840, a18);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0014u, 4026531840, a15);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0015u, 4026531840, a14);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB001Au, 4026531840, 0.0);
  }
  return v22;
}

HIDEvent *IOHIDEventCreateTouchSensitiveButtonEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, uint64_t a6, double a7, double a8)
{
  HIDEvent *result;
  IOHIDEventData *eventData;
  int64x2_t v15;

  result = IOHIDEventCreate(a1, 42, a2, a6);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = a4;
    *((double *)eventData + 3) = a7;
    *((double *)eventData + 4) = a8;
    *((_BYTE *)eventData + 40) = a5 != 0;
    v15 = vdupq_n_s64(0x7FF8000000000000uLL);
    *((int64x2_t *)eventData + 3) = v15;
    *((int64x2_t *)eventData + 4) = v15;
    *((_DWORD *)eventData + 11) = 0;
  }
  return result;
}

HIDEvent *IOHIDEventCreateTouchSensitiveButtonEventWithRadius(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, int a6, uint64_t a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 42, a2, a7);
  if (result)
  {
    eventData = result->_event.eventData;
    *((double *)eventData + 6) = a8;
    *((double *)eventData + 7) = a9;
    *((double *)eventData + 3) = a10;
    *((double *)eventData + 4) = a11;
    *((double *)eventData + 8) = a12;
    *((double *)eventData + 9) = a13;
    *((_DWORD *)eventData + 11) = a5;
    *((_WORD *)eventData + 8) = a3;
    *((_WORD *)eventData + 9) = a4;
    *((_BYTE *)eventData + 40) = a6 != 0;
  }
  return result;
}

HIDEvent *IOHIDEventCreateSwipeEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 16, a2, a4);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 7) = a3;
    *((_QWORD *)eventData + 2) = 0;
    *((_QWORD *)eventData + 4) = 0;
  }
  return result;
}

HIDEvent *__IOHIDEventCreateSwipeEventOfTypeWithFlavor(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, __int16 a6, uint64_t a7, double a8, double a9, double a10)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, a3, a2, a7);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 7) = a4;
    *((_WORD *)eventData + 16) = a5;
    *((_WORD *)eventData + 17) = a6;
    *((_DWORD *)eventData + 9) = vcvtd_n_s64_f64(a8, 0x10uLL);
    *((_DWORD *)eventData + 4) = vcvtd_n_s64_f64(a9, 0x10uLL);
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a10, 0x10uLL);
  }
  return result;
}

HIDEvent *IOHIDEventCreateNavigationSwipeEvent(uint64_t a1, uint64_t a2, int a3, __int16 a4, uint64_t a5, double a6, double a7, double a8)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 16, a3, a4, 5, a5, a6, a7, a8);
}

HIDEvent *IOHIDEventCreateDockSwipeEvent(uint64_t a1, uint64_t a2, int a3, __int16 a4, uint64_t a5, double a6, double a7, double a8)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 23, a3, a4, 3, a5, a6, a7, a8);
}

HIDEvent *IOHIDEventCreateBoundaryScrollEvent(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, double a5, double a6, double a7)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 28, 0, a3, 0, a4, a5, a6, a7);
}

HIDEvent *IOHIDEventCreateFluidTouchGestureEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5, double a6, double a7, double a8)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 27, 0, a3, a4, a5, a6, a7, a8);
}

HIDEvent *IOHIDEventCreateProgressEvent(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 18, a2, a4 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = (int)a5;
  }
  return result;
}

HIDEvent *IOHIDEventCreateBiometricEvent(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 29, a2, a4 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *((_DWORD *)eventData + 6) = 0;
    *((_BYTE *)eventData + 32) = 0;
  }
  return result;
}

HIDEvent *IOHIDEventCreateAtmosphericPressureEvent(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 31, a2, a4 | 1u);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *((_DWORD *)eventData + 5) = a3;
  }
  return result;
}

HIDEvent *IOHIDEventCreateZoomToggleEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return IOHIDEventCreate(a1, 22, a2, a4);
}

HIDEvent *IOHIDEventCreateSymbolicHotKeyEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v6;
  HIDEvent *result;

  if (a4)
    v6 = a5 | 0x10001u;
  else
    v6 = a5 & 0xFFFEFFFE | 1;
  result = IOHIDEventCreate(a1, 24, a2, v6);
  if (result)
    *((_DWORD *)result->_event.eventData + 4) = a3;
  return result;
}

HIDEvent *IOHIDEventCreateLEDEvent(uint64_t a1, uint64_t a2, int a3, char a4, int a5, int a6)
{
  HIDEvent *result;
  BOOL v10;
  int v11;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 26, a2, a6 | 1u);
  if (result)
  {
    if (a5)
      v10 = a3 == 0;
    else
      v10 = 0;
    v11 = 1 << (a4 - 1);
    eventData = result->_event.eventData;
    if (!v10)
      v11 = a3;
    *((_DWORD *)eventData + 4) = v11;
    *((_BYTE *)eventData + 20) = a4;
    *((_DWORD *)eventData + 6) = a5;
  }
  return result;
}

HIDEvent *IOHIDEventCreateForceEvent(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, double a6, double a7)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 32, a2, a5);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a6, 0x10uLL);
    *((_DWORD *)eventData + 6) = a4;
    *((_DWORD *)eventData + 7) = vcvtd_n_s64_f64(a7, 0x10uLL);
  }
  return result;
}

HIDEvent *IOHIDEventCreateMotionActivtyEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 33, a2, a4);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a5, 0x10uLL);
  }
  return result;
}

HIDEvent *IOHIDEventCreateMotionGestureEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 34, a2, a4);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = vcvtd_n_s64_f64(a5, 0x10uLL);
  }
  return result;
}

HIDEvent *IOHIDEventCreateCollectionEvent(uint64_t a1, uint64_t a2, int a3)
{
  return IOHIDEventCreate(a1, 37, a2, a3 | 2u);
}

HIDEvent *IOHIDEventCreateBrightnessEvent(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 38, a2, a6);
  eventData = result->_event.eventData;
  *((_DWORD *)eventData + 4) = a3;
  *((_DWORD *)eventData + 5) = a4;
  *((_QWORD *)eventData + 3) = a5;
  return result;
}

HIDEvent *IOHIDEventCreateGameControllerEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, unsigned int a20)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 35, a2, a20);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_DWORD *)eventData + 5) = a4;
    *((_DWORD *)eventData + 6) = a5;
    *((_DWORD *)eventData + 7) = a6;
    *((_DWORD *)eventData + 8) = a7;
    *((_DWORD *)eventData + 9) = a8;
    *((_DWORD *)eventData + 10) = a9;
    *((_DWORD *)eventData + 11) = a10;
    *((_DWORD *)eventData + 12) = a11;
    *((_DWORD *)eventData + 13) = a12;
    *((_DWORD *)eventData + 14) = a13;
    *((_DWORD *)eventData + 15) = a14;
    *((_DWORD *)eventData + 16) = a15;
    *((_DWORD *)eventData + 17) = a16;
    *((_DWORD *)eventData + 18) = a17;
    *((_DWORD *)eventData + 19) = a18;
    *((_DWORD *)eventData + 20) = a19;
  }
  return result;
}

HIDEvent *IOHIDEventCreateGenericGestureEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  HIDEvent *result;

  result = IOHIDEventCreate(a1, 39, a2, a4);
  if (result)
    *((_DWORD *)result->_event.eventData + 4) = a3;
  return result;
}

HIDEvent *IOHIDEventCreateForceStageEvent(uint64_t a1, uint64_t a2, int a3, char a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  HIDEvent *result;
  IOHIDEventData *eventData;

  result = IOHIDEventCreate(a1, 41, a2, a5);
  if (result)
  {
    eventData = result->_event.eventData;
    *((_DWORD *)eventData + 4) = a3;
    *((_BYTE *)eventData + 20) = a4;
    *((double *)eventData + 3) = a6;
    *((double *)eventData + 4) = a7;
    *((double *)eventData + 5) = a8;
    *((double *)eventData + 6) = a9;
    *((double *)eventData + 7) = a10;
  }
  return result;
}

BOOL IOHIDEventConformsToWithOptions(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL8 v4;

  v3 = a1[3] & (1 << a2);
  v4 = v3 != 0;
  if (!(a3 >> 28) && v3)
    return IOHIDEventGetEventWithOptions(a1, a2, a3) != 0;
  return v4;
}

uint64_t IOHIDEventGetPhase(uint64_t a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 104) + 11);
}

uint64_t IOHIDEventSetPhase(uint64_t result, char a2)
{
  *(_BYTE *)(*(_QWORD *)(result + 104) + 11) = a2;
  return result;
}

uint64_t IOHIDEventGetScrollMomentum(uint64_t a1)
{
  return (*(_DWORD *)(*(_QWORD *)(a1 + 104) + 8) >> 6) & 0x18 | (*(_DWORD *)(*(_QWORD *)(a1 + 104) + 8) >> 28) & 7u;
}

uint64_t IOHIDEventSetScrollMomentum(uint64_t result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 104) + 8) = ((a2 << 28) | (a2 << 6)) & 0x70000600 | *(_DWORD *)(*(_QWORD *)(result + 104) + 8) & 0x8FFFF9FF;
  return result;
}

uint64_t IOHIDEventSetEventFlags(uint64_t result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 104) + 8) = a2;
  return result;
}

uint64_t IOHIDEventIsAbsolute(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8) & 1;
}

uint64_t IOHIDEventIsRepeat(uint64_t a1)
{
  return HIWORD(*(_DWORD *)(*(_QWORD *)(a1 + 104) + 8)) & 1;
}

uint64_t IOHIDEventSetRepeat(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(result + 104) + 8) |= 0x10000u;
  return result;
}

double IOHIDEventGetPosition(_QWORD *a1)
{
  return IOHIDEventGetPositionWithOptions(a1, 4026531840);
}

double IOHIDEventGetPositionWithOptions(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double v5;
  uint64_t EventWithOptions;
  int v8;

  v3 = a1[13];
  v4 = *(unsigned int *)(v3 + 4);
  v5 = 0.0;
  if (v4 <= 0xB && ((1 << v4) & 0xAF0) != 0)
  {
    if ((_DWORD)a2)
    {
      EventWithOptions = IOHIDEventGetEventWithOptions(a1, v4, a2);
      if (!EventWithOptions)
        return v5;
      v3 = *(_QWORD *)(EventWithOptions + 104);
    }
    v8 = *(_DWORD *)(v3 + 16);
    if (v8 == 0x80000000)
      return NAN;
    else
      return (double)v8 * 0.0000152587891;
  }
  return v5;
}

_QWORD *IOHIDEventSetPosition(_QWORD *a1, double a2, double a3, double a4)
{
  return IOHIDEventSetPositionWithOptions(a1, 4026531840, a2, a3, a4);
}

_QWORD *IOHIDEventSetPositionWithOptions(_QWORD *result, uint64_t a2, double a3, double a4, double a5)
{
  unsigned int *v6;
  uint64_t v7;

  v6 = (unsigned int *)result[13];
  v7 = v6[1];
  if (v7 <= 0xB && ((1 << v7) & 0xAF0) != 0)
  {
    if ((_DWORD)a2)
    {
      result = (_QWORD *)IOHIDEventGetEventWithOptions(result, v7, a2);
      if (!result)
        return result;
      v6 = (unsigned int *)result[13];
    }
    v6[4] = vcvtd_n_s64_f64(a3, 0x10uLL);
    v6[5] = vcvtd_n_s64_f64(a4, 0x10uLL);
    v6[6] = vcvtd_n_s64_f64(a5, 0x10uLL);
  }
  return result;
}

unint64_t IOHIDEventGetUInt64Value(_QWORD *a1, unsigned int a2)
{
  return IOHIDEventGetUInt64ValueWithOptions(a1, a2, 4026531840);
}

unint64_t IOHIDEventGetUInt64ValueWithOptions(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v4;
  unsigned int v5;
  unint64_t result;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  double v12;
  unint64_t v13;
  unint64_t v14;

  v4 = a1;
  v5 = HIWORD(a2);
  if (a1 && a2 < 0x10000
    || (result = IOHIDEventGetEventWithOptions(a1, HIWORD(a2), a3), (v4 = (_QWORD *)result) != 0))
  {
    result = 0;
    v7 = v4[13];
    switch(v5)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            LOBYTE(v7) = *(_BYTE *)(v7 + 8);
            goto LABEL_189;
          case 1u:
            v13 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_198;
          case 2u:
            goto LABEL_20;
          case 3u:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 3) & 1;
            break;
          case 4u:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 4) & 1;
            break;
          case 5u:
            v14 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_164;
          case 6u:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 6) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x10001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x10002u:
            return *(unsigned int *)(v7 + 20);
          case 0x10003u:
            return *(unsigned int *)(v7 + 24);
          case 0x10004u:
            goto LABEL_75;
          default:
            return 0;
        }
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            return *(unsigned int *)(v7 + 16);
          case 0x20001u:
            goto LABEL_120;
          case 0x20002u:
            goto LABEL_121;
          case 0x20003u:
            goto LABEL_142;
          case 0x20004u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x30001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x30002u:
            return *(unsigned int *)(v7 + 20);
          case 0x30003u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0x30004u:
            result = *(unsigned __int8 *)(v7 + 28);
            break;
          case 0x30005u:
            LODWORD(v7) = *(_DWORD *)(v7 + 24);
            goto LABEL_189;
          case 0x30006u:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 1) & 3;
            break;
          case 0x30007u:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 3) & 3;
            break;
          case 0x30008u:
            v14 = *(unsigned int *)(v7 + 24);
LABEL_164:
            result = (v14 >> 5) & 1;
            break;
          case 0x30009u:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 6) & 7;
            break;
          case 0x3000Au:
            result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 9) & 3;
            break;
          default:
            return 0;
        }
        return result;
      case 4u:
        if (a2 == 262146)
          goto LABEL_135;
        if (a2 == 262145)
          goto LABEL_142;
        if (a2 != 0x40000)
          return 0;
        goto LABEL_96;
      case 5u:
        if (a2 == 327682)
          goto LABEL_135;
        if (a2 == 327681)
          goto LABEL_142;
        if (a2 != 327680)
          return 0;
        goto LABEL_96;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_96;
          case 0x60001u:
            goto LABEL_142;
          case 0x60002u:
            goto LABEL_135;
          case 0x60003u:
LABEL_20:
            result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 2) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 7u:
        if (a2 == 458754)
          goto LABEL_135;
        if (a2 == 458753)
          goto LABEL_142;
        if (a2 != 458752)
          return 0;
        goto LABEL_96;
      case 9u:
        if (a2 == 589826)
        {
LABEL_135:
          v10 = *(_DWORD *)(v7 + 24);
          goto LABEL_143;
        }
        if (a2 == 589825)
          goto LABEL_142;
        if (a2 != 589824)
          return 0;
        goto LABEL_96;
      case 0xAu:
        if (a2 - 655360 > 0xB)
          return 0;
        if (a2 != 655363)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              if (a2 == 655362)
                goto LABEL_135;
              if (a2 == 655361)
                goto LABEL_142;
              if (a2 != 655360)
                return 0;
              goto LABEL_96;
            case 1:
              if (a2 == 655364)
                return *(unsigned int *)(v7 + 16);
              return 0;
            case 2:
              if (a2 == 655367)
                goto LABEL_135;
              if (a2 == 655366)
                goto LABEL_142;
              if (a2 != 655365)
                return 0;
              goto LABEL_96;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_96;
                case 0xA0009u:
                  goto LABEL_142;
                case 0xA000Au:
                  goto LABEL_135;
                case 0xA000Bu:
                  goto LABEL_136;
                default:
                  return 0;
              }
            default:
              return 0;
          }
        }
        return *(unsigned int *)(v7 + 32);
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_96;
          case 0xB0001u:
            goto LABEL_142;
          case 0xB0002u:
            goto LABEL_135;
          case 0xB0003u:
            goto LABEL_157;
          case 0xB0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xB0005u:
            return *(unsigned int *)(v7 + 28);
          case 0xB0006u:
            goto LABEL_114;
          case 0xB0007u:
            goto LABEL_158;
          case 0xB0008u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0xB0009u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 17) & 1;
          case 0xB000Au:
            goto LABEL_180;
          case 0xB000Bu:
            goto LABEL_181;
          case 0xB000Cu:
            goto LABEL_202;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            v8 = *(_DWORD *)(v7 + 64);
            if (v8)
            {
              if (v8 == 2)
              {
                result = 0;
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_171;
                  case 0xB0012u:
                    goto LABEL_172;
                  case 0xB0013u:
                    goto LABEL_182;
                  case 0xB0014u:
                    goto LABEL_183;
                  case 0xB0015u:
LABEL_209:
                    v10 = *(_DWORD *)(v7 + 84);
                    goto LABEL_143;
                  case 0xB001Au:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              else
              {
                if (v8 != 1)
                  return 0;
                result = 0;
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_171;
                  case 0xB0010u:
                    goto LABEL_172;
                  case 0xB0011u:
                    goto LABEL_182;
                  case 0xB0012u:
                    goto LABEL_183;
                  case 0xB0014u:
                    goto LABEL_209;
                  case 0xB0015u:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910)
              goto LABEL_172;
            if (a2 != 720909)
              return 0;
            goto LABEL_171;
          case 0xB0016u:
            v13 = *(unsigned int *)(v7 + 8);
            goto LABEL_198;
          case 0xB0017u:
            if (*(_DWORD *)(v7 + 32))
              return 0;
            goto LABEL_202;
          case 0xB0018u:
            return *(unsigned int *)(v7 + 44);
          case 0xB0019u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 19) & 1;
          case 0xB001Bu:
            return *(unsigned int *)(v7 + 92);
          case 0xB001Cu:
            return *(unsigned int *)(v7 + 96);
          case 0xB001Du:
            return *(unsigned int *)(v7 + 100);
          case 0xB001Eu:
            return (*(_DWORD *)(v7 + 40) >> 13) & 0x18000 | (*(_DWORD *)(v7 + 40) >> 20) & 0x400u | (*(_DWORD *)(v7 + 40) >> 31 << 23);
          case 0xB001Fu:
            return *(unsigned int *)(v7 + 64);
          default:
            return 0;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            return *(unsigned int *)(v7 + 16);
          case 0xC0001u:
            return *(unsigned int *)(v7 + 20);
          case 0xC0002u:
            return *(unsigned int *)(v7 + 24);
          case 0xC0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xC0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xC0005u:
            result = *(unsigned __int8 *)(v7 + 36);
            break;
          case 0xC0006u:
            result = *(unsigned __int8 *)(v7 + 37);
            break;
          case 0xC0007u:
            goto LABEL_124;
          case 0xC0008u:
            goto LABEL_117;
          case 0xC0009u:
            goto LABEL_118;
          case 0xC000Au:
            goto LABEL_137;
          case 0xC000Bu:
            goto LABEL_138;
          default:
            return 0;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_96;
          case 0xD0001u:
            goto LABEL_142;
          case 0xD0002u:
            goto LABEL_135;
          case 0xD0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xD0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xD0005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              v9 = 917507;
              goto LABEL_101;
            }
            result = 0;
            if (a2 != 917505 || *(_WORD *)(v7 + 18))
              return result;
            return *(unsigned int *)(v7 + 20);
          case 0xE0002u:
            return *(unsigned __int16 *)(v7 + 18);
          default:
            return 0;
        }
      case 0xFu:
        if (a2 != 983040)
          return 0;
        goto LABEL_96;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            return *(unsigned int *)(v7 + 28);
          case 0x100001u:
            goto LABEL_71;
          case 0x100002u:
            goto LABEL_110;
          case 0x100003u:
            goto LABEL_96;
          case 0x100004u:
            goto LABEL_142;
          case 0x100005u:
            goto LABEL_113;
          case 0x100006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_96;
          case 0x110001u:
            goto LABEL_142;
          case 0x110002u:
            goto LABEL_135;
          case 0x110003u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x12u:
        if (a2 == 1179649)
          goto LABEL_142;
        if (a2 != 1179648)
          return 0;
        return *(unsigned int *)(v7 + 16);
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_96;
          case 0x130001u:
            goto LABEL_142;
          case 0x130002u:
            goto LABEL_135;
          case 0x130003u:
            goto LABEL_89;
          case 0x130004u:
            goto LABEL_110;
          case 0x130005u:
            goto LABEL_149;
          case 0x130006u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_96;
          case 0x140001u:
            goto LABEL_142;
          case 0x140002u:
            goto LABEL_135;
          case 0x140003u:
            return *(unsigned int *)(v7 + 28);
          case 0x140004u:
            return *(unsigned int *)(v7 + 32);
          case 0x140005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_96;
          case 0x150001u:
            goto LABEL_142;
          case 0x150002u:
            goto LABEL_135;
          case 0x150003u:
            return *(unsigned int *)(v7 + 28);
          case 0x150004u:
            return *(unsigned int *)(v7 + 32);
          case 0x150005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            return *(unsigned int *)(v7 + 28);
          case 0x170001u:
            goto LABEL_71;
          case 0x170002u:
            goto LABEL_110;
          case 0x170003u:
            goto LABEL_96;
          case 0x170004u:
            goto LABEL_142;
          case 0x170005u:
            goto LABEL_113;
          case 0x170006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x18u:
        if (a2 == 1572864)
          return *(unsigned int *)(v7 + 16);
        if (a2 != 1572865)
          return 0;
        return (unint64_t)*(unsigned __int16 *)(v7 + 8) >> 15;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
            return *(unsigned int *)(v7 + 28);
          case 0x190001u:
            return *(unsigned int *)(v7 + 24);
          case 0x190000u:
            goto LABEL_96;
        }
        return 0;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1A0001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x1A0000u:
            return *(unsigned int *)(v7 + 16);
        }
        return 0;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1B0001u:
            goto LABEL_71;
          case 0x1B0002u:
            goto LABEL_110;
          case 0x1B0003u:
            goto LABEL_96;
          case 0x1B0004u:
            goto LABEL_142;
          case 0x1B0005u:
            goto LABEL_113;
          default:
            return 0;
        }
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1C0001u:
LABEL_71:
            result = *(unsigned __int16 *)(v7 + 32);
            break;
          case 0x1C0002u:
            goto LABEL_110;
          case 0x1C0003u:
            goto LABEL_96;
          case 0x1C0004u:
            goto LABEL_142;
          case 0x1C0005u:
LABEL_113:
            result = *(unsigned __int16 *)(v7 + 34);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1D0001u:
            goto LABEL_142;
          case 0x1D0002u:
            result = *(unsigned __int16 *)(v7 + 24);
            break;
          case 0x1D0003u:
            result = *(unsigned __int16 *)(v7 + 26);
            break;
          case 0x1D0004u:
            result = *(unsigned __int8 *)(v7 + 32);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1E0001u:
            goto LABEL_142;
          case 0x1E0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1E0003u:
LABEL_75:
            if (*(_DWORD *)(v7 + 24) < 8u)
              return 0;
            result = *(_QWORD *)(v7 + 28);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617)
          return *(unsigned int *)(v7 + 20);
        if (a2 != 2031616)
          return 0;
        goto LABEL_96;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            return *(unsigned int *)(v7 + 16);
          case 0x200001u:
            goto LABEL_142;
          case 0x200002u:
            return *(unsigned int *)(v7 + 24);
          case 0x200003u:
            goto LABEL_136;
          default:
            return 0;
        }
      case 0x21u:
        if (a2 == 2162689)
          goto LABEL_142;
        if (a2 != 2162688)
          return 0;
        return *(unsigned int *)(v7 + 16);
      case 0x22u:
        if (a2 == 2228225)
          goto LABEL_142;
        if (a2 != 2228224)
          return 0;
        return *(unsigned int *)(v7 + 16);
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            return *(unsigned int *)(v7 + 16);
          case 0x230001u:
            goto LABEL_142;
          case 0x230002u:
            goto LABEL_135;
          case 0x230003u:
LABEL_136:
            v10 = *(_DWORD *)(v7 + 28);
            goto LABEL_143;
          case 0x230004u:
LABEL_89:
            v10 = *(_DWORD *)(v7 + 32);
            goto LABEL_143;
          case 0x230005u:
            v10 = *(_DWORD *)(v7 + 44);
            goto LABEL_143;
          case 0x230006u:
            v10 = *(_DWORD *)(v7 + 48);
            goto LABEL_143;
          case 0x230007u:
LABEL_110:
            v10 = *(_DWORD *)(v7 + 36);
            goto LABEL_143;
          case 0x230008u:
LABEL_149:
            v10 = *(_DWORD *)(v7 + 40);
            goto LABEL_143;
          case 0x230009u:
LABEL_171:
            v10 = *(_DWORD *)(v7 + 68);
            goto LABEL_143;
          case 0x23000Au:
LABEL_182:
            v10 = *(_DWORD *)(v7 + 76);
            goto LABEL_143;
          case 0x23000Bu:
LABEL_172:
            v10 = *(_DWORD *)(v7 + 72);
            goto LABEL_143;
          case 0x23000Cu:
LABEL_183:
            v10 = *(_DWORD *)(v7 + 80);
            goto LABEL_143;
          case 0x23000Du:
LABEL_180:
            v10 = *(_DWORD *)(v7 + 52);
            goto LABEL_143;
          case 0x23000Eu:
LABEL_181:
            v10 = *(_DWORD *)(v7 + 56);
            goto LABEL_143;
          case 0x23000Fu:
LABEL_202:
            v10 = *(_DWORD *)(v7 + 60);
            goto LABEL_143;
          case 0x230010u:
            v10 = *(_DWORD *)(v7 + 64);
            goto LABEL_143;
          case 0x230011u:
            LOBYTE(v7) = *(_BYTE *)(v7 + 84);
LABEL_189:
            result = v7 & 1;
            break;
          case 0x230012u:
            v13 = *(unsigned __int8 *)(v7 + 84);
LABEL_198:
            result = (v13 >> 1) & 1;
            break;
          case 0x230013u:
LABEL_184:
            v10 = *(_DWORD *)(v7 + 88);
            goto LABEL_143;
          case 0x230014u:
            v10 = *(_DWORD *)(v7 + 92);
            goto LABEL_143;
          case 0x230015u:
            v10 = *(_DWORD *)(v7 + 96);
            goto LABEL_143;
          case 0x230016u:
            v10 = *(_DWORD *)(v7 + 100);
            goto LABEL_143;
          case 0x230017u:
            v10 = *(_DWORD *)(v7 + 104);
            goto LABEL_143;
          case 0x230018u:
            v10 = *(_DWORD *)(v7 + 108);
            goto LABEL_143;
          default:
            return 0;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
          return *(unsigned int *)(v7 + 20);
        if (a2 != 2359296)
          return 0;
        goto LABEL_96;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            return *(_QWORD *)(v7 + 24);
          case 0x260001u:
            goto LABEL_142;
          case 0x260000u:
LABEL_96:
            v10 = *(_DWORD *)(v7 + 16);
            goto LABEL_143;
        }
        return 0;
      case 0x27u:
        if (a2 - 2555905 >= 2)
        {
          if (a2 == 2555904)
            return *(unsigned int *)(v7 + 16);
          return 0;
        }
        v11 = *(_DWORD *)(v7 + 16);
        if (v11 == 1)
        {
          if (a2 != 2555906)
            return 0;
LABEL_142:
          v10 = *(_DWORD *)(v7 + 20);
LABEL_143:
          if (v10 == 0x80000000)
            result = 0xFFFFFFFF80000000;
          else
            result = (uint64_t)(v10 + (v10 < 0 ? 0xFFFF : 0)) >> 16;
        }
        else
        {
          if (!v11)
          {
            v9 = 2555905;
LABEL_101:
            if (a2 != v9)
              return 0;
            return *(unsigned int *)(v7 + 20);
          }
          result = 0;
          if (a2 == 2555905 && v11 == 2)
            return *(unsigned int *)(v7 + 20);
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            result = *(unsigned __int16 *)(v7 + 64);
            break;
          case 0x280001u:
            result = *(unsigned __int16 *)(v7 + 66);
            break;
          case 0x280002u:
            v12 = *(double *)(v7 + 16);
            goto LABEL_176;
          case 0x280003u:
LABEL_120:
            result = *(unsigned __int8 *)(v7 + 24);
            break;
          case 0x280004u:
LABEL_121:
            result = *(unsigned __int8 *)(v7 + 25);
            break;
          case 0x280005u:
            return *(unsigned int *)(v7 + 28);
          case 0x280006u:
            return *(unsigned int *)(v7 + 32);
          case 0x280007u:
LABEL_114:
            result = *(unsigned int *)(v7 + 36);
            break;
          case 0x280008u:
            result = *(unsigned __int8 *)(v7 + 44);
            break;
          case 0x280009u:
LABEL_157:
            result = *(unsigned int *)(v7 + 48);
            break;
          case 0x28000Au:
            result = *(_QWORD *)(v7 + 56);
            break;
          case 0x28000Bu:
            result = *(unsigned __int8 *)(v7 + 26);
            break;
          case 0x28000Cu:
LABEL_158:
            result = *(unsigned int *)(v7 + 40);
            break;
          default:
            return 0;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            return *(unsigned int *)(v7 + 16);
          case 0x290001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x290002u:
            goto LABEL_122;
          case 0x290003u:
            goto LABEL_123;
          case 0x290004u:
LABEL_124:
            v12 = *(double *)(v7 + 40);
            goto LABEL_176;
          case 0x290005u:
            goto LABEL_117;
          case 0x290006u:
            goto LABEL_118;
          default:
            return 0;
        }
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x2A0001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x2A0002u:
LABEL_122:
            v12 = *(double *)(v7 + 24);
            goto LABEL_176;
          case 0x2A0003u:
LABEL_123:
            v12 = *(double *)(v7 + 32);
            goto LABEL_176;
          case 0x2A0004u:
            return *(unsigned __int8 *)(v7 + 40);
          case 0x2A0005u:
            return *(unsigned int *)(v7 + 44);
          case 0x2A0006u:
LABEL_117:
            v12 = *(double *)(v7 + 48);
            goto LABEL_176;
          case 0x2A0007u:
LABEL_118:
            v12 = *(double *)(v7 + 56);
            goto LABEL_176;
          case 0x2A0008u:
LABEL_137:
            v12 = *(double *)(v7 + 64);
            goto LABEL_176;
          case 0x2A0009u:
LABEL_138:
            v12 = *(double *)(v7 + 72);
LABEL_176:
            result = (unint64_t)v12;
            break;
          default:
            return 0;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

_QWORD *IOHIDEventSetDoubleValue(_QWORD *a1, unsigned int a2, double a3)
{
  return IOHIDEventSetDoubleValueWithOptions(a1, a2, 4026531840, a3);
}

_QWORD *IOHIDEventSetDoubleValueWithOptions(_QWORD *result, unsigned int a2, uint64_t a3, double a4)
{
  unsigned int v6;
  uint64_t v7;
  char v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;

  v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (result = (_QWORD *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a3)) != 0)
  {
    v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFE | (a4 != 0.0);
            goto LABEL_168;
          case 1u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFD | (2 * (a4 != 0.0));
            goto LABEL_168;
          case 2u:
            goto LABEL_23;
          case 3u:
            v8 = *(_BYTE *)(v7 + 8) & 0xF7 | (8 * (a4 != 0.0));
            goto LABEL_168;
          case 4u:
            v8 = *(_BYTE *)(v7 + 8) & 0xEF | (16 * (a4 != 0.0));
            goto LABEL_168;
          case 5u:
            v8 = *(_BYTE *)(v7 + 8) & 0xDF | (32 * (a4 != 0.0));
            goto LABEL_168;
          case 6u:
            v8 = *(_BYTE *)(v7 + 8) & 0xBF | ((a4 != 0.0) << 6);
            goto LABEL_168;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10002u:
            v16 = a4;
            goto LABEL_158;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x10000u:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_139;
          case 0x20001u:
            goto LABEL_130;
          case 0x20002u:
            goto LABEL_131;
          case 0x20003u:
            goto LABEL_154;
          case 0x20004u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_113;
          case 0x30001u:
            goto LABEL_120;
          case 0x30002u:
            goto LABEL_157;
          case 0x30003u:
            goto LABEL_170;
          case 0x30004u:
            *(_BYTE *)(v7 + 28) = (int)a4;
            return result;
          case 0x30005u:
            v13 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a4 != 0.0);
            goto LABEL_148;
          case 0x30006u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a4 & 3));
            goto LABEL_181;
          case 0x30007u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a4 & 3));
            goto LABEL_181;
          case 0x30008u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a4 != 0.0));
            goto LABEL_181;
          case 0x30009u:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a4 & 7) << 6);
            goto LABEL_181;
          case 0x3000Au:
            v21 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a4 & 3) << 9);
LABEL_181:
            *(_DWORD *)(v7 + 24) = v21;
            break;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146)
          goto LABEL_147;
        if (a2 == 262145)
          goto LABEL_154;
        if (a2 != 0x40000)
          return result;
        goto LABEL_69;
      case 5u:
        if (a2 == 327682)
          goto LABEL_147;
        if (a2 == 327681)
          goto LABEL_154;
        if (a2 != 327680)
          return result;
        goto LABEL_69;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_69;
          case 0x60001u:
            goto LABEL_154;
          case 0x60002u:
            goto LABEL_147;
          case 0x60003u:
LABEL_23:
            v8 = *(_BYTE *)(v7 + 8) & 0xFB | (4 * (a4 != 0.0));
LABEL_168:
            *(_BYTE *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
            goto LABEL_147;
          case 0x70001u:
            goto LABEL_154;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_147:
          v13 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_148;
        }
        if (a2 == 589825)
          goto LABEL_154;
        if (a2 != 589824)
          return result;
        goto LABEL_69;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_147;
                case 0xA0001u:
                  goto LABEL_154;
                case 0xA0000u:
                  goto LABEL_69;
              }
              break;
            case 1:
              if (a2 == 655364)
                goto LABEL_139;
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_147;
                case 0xA0006u:
                  goto LABEL_154;
                case 0xA0005u:
                  goto LABEL_69;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_69;
                case 0xA0009u:
                  goto LABEL_154;
                case 0xA000Au:
                  goto LABEL_147;
                case 0xA000Bu:
                  goto LABEL_95;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_154;
          case 0xB0002u:
            goto LABEL_147;
          case 0xB0003u:
            goto LABEL_171;
          case 0xB0004u:
            goto LABEL_121;
          case 0xB0005u:
            goto LABEL_114;
          case 0xB0006u:
            goto LABEL_128;
          case 0xB0007u:
            goto LABEL_172;
          case 0xB0008u:
LABEL_170:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a4 != 0.0) << 16);
            goto LABEL_217;
          case 0xB0009u:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a4 != 0.0) << 17);
            goto LABEL_217;
          case 0xB000Au:
            goto LABEL_189;
          case 0xB000Bu:
            goto LABEL_190;
          case 0xB000Cu:
            goto LABEL_215;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_186;
                  case 0xB0012u:
                    goto LABEL_187;
                  case 0xB0013u:
                    goto LABEL_196;
                  case 0xB0014u:
                    goto LABEL_197;
                  case 0xB0015u:
LABEL_224:
                    *(_DWORD *)(v7 + 84) = vcvtd_n_s64_f64(a4, 0x10uLL);
                    break;
                  case 0xB001Au:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_186;
                  case 0xB0010u:
                    goto LABEL_187;
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_197;
                  case 0xB0014u:
                    goto LABEL_224;
                  case 0xB0015u:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910)
              goto LABEL_187;
            if (a2 != 720909)
              return result;
            goto LABEL_186;
          case 0xB0016u:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a4 != 0.0));
            goto LABEL_217;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32))
              goto LABEL_215;
            return result;
          case 0xB0018u:
            goto LABEL_169;
          case 0xB0019u:
            v19 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a4 != 0.0) << 19);
LABEL_217:
            *(_DWORD *)(v7 + 8) = v19;
            return result;
          case 0xB001Bu:
            v23 = a4;
            goto LABEL_219;
          case 0xB001Cu:
            v24 = a4;
            goto LABEL_221;
          case 0xB001Du:
            v25 = a4;
            goto LABEL_223;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_111;
          case 0xC0001u:
            goto LABEL_157;
          case 0xC0002u:
            goto LABEL_87;
          case 0xC0003u:
            goto LABEL_114;
          case 0xC0004u:
            goto LABEL_121;
          case 0xC0005u:
            *(_BYTE *)(v7 + 36) = a4 != 0.0;
            break;
          case 0xC0006u:
            *(_BYTE *)(v7 + 37) = (int)a4;
            break;
          case 0xC0007u:
            goto LABEL_134;
          case 0xC0008u:
            goto LABEL_122;
          case 0xC0009u:
            goto LABEL_123;
          case 0xC000Au:
            goto LABEL_149;
          case 0xC000Bu:
            goto LABEL_150;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_154;
          case 0xD0002u:
            goto LABEL_147;
          case 0xD0003u:
            goto LABEL_114;
          case 0xD0004u:
            goto LABEL_121;
          case 0xD0005u:
            goto LABEL_128;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_113;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507)
                goto LABEL_157;
            }
            else if (a2 == 917505 && !*(_WORD *)(v7 + 18))
            {
              goto LABEL_157;
            }
            break;
          case 0xE0002u:
            goto LABEL_120;
          default:
            return result;
        }
        return result;
      case 0xFu:
        if (a2 != 983040)
          return result;
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_76;
          case 0x100001u:
            goto LABEL_117;
          case 0x100002u:
            goto LABEL_116;
          case 0x100003u:
            goto LABEL_69;
          case 0x100004u:
            goto LABEL_154;
          case 0x100005u:
            goto LABEL_118;
          case 0x100006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_154;
          case 0x110002u:
            goto LABEL_147;
          case 0x110003u:
            goto LABEL_114;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649)
          goto LABEL_154;
        if (a2 != 1179648)
          return result;
        goto LABEL_111;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_69;
          case 0x130001u:
            goto LABEL_154;
          case 0x130002u:
            goto LABEL_147;
          case 0x130003u:
            goto LABEL_160;
          case 0x130004u:
            goto LABEL_116;
          case 0x130005u:
            goto LABEL_162;
          case 0x130006u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_69;
          case 0x140001u:
            goto LABEL_154;
          case 0x140002u:
            goto LABEL_147;
          case 0x140003u:
            goto LABEL_76;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_69;
          case 0x150001u:
            goto LABEL_154;
          case 0x150002u:
            goto LABEL_147;
          case 0x150003u:
            goto LABEL_76;
          case 0x150004u:
LABEL_61:
            v10 = a4;
            goto LABEL_161;
          case 0x150005u:
LABEL_124:
            v15 = a4;
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_76;
          case 0x170001u:
            goto LABEL_117;
          case 0x170002u:
            goto LABEL_116;
          case 0x170003u:
            goto LABEL_69;
          case 0x170004u:
            goto LABEL_154;
          case 0x170005u:
            goto LABEL_118;
          case 0x170006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864)
          goto LABEL_111;
        if (a2 == 1572865)
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a4 != 0.0) << 15);
        return result;
      case 0x19u:
        if (a2 == 1638402)
        {
LABEL_114:
          v12 = a4;
LABEL_115:
          *(_DWORD *)(v7 + 28) = v12;
          return result;
        }
        if (a2 == 1638401)
        {
LABEL_87:
          v13 = a4;
LABEL_148:
          *(_DWORD *)(v7 + 24) = v13;
          return result;
        }
        if (a2 != 1638400)
          return result;
        goto LABEL_69;
      case 0x1Au:
        if (a2 == 1703938)
          goto LABEL_87;
        if (a2 == 1703937)
        {
LABEL_119:
          *(_BYTE *)(v7 + 20) = (int)a4;
          return result;
        }
        if (a2 != 1703936)
          return result;
LABEL_139:
        v11 = a4;
        goto LABEL_140;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_76;
          case 0x1B0001u:
            goto LABEL_117;
          case 0x1B0002u:
            goto LABEL_116;
          case 0x1B0003u:
            goto LABEL_69;
          case 0x1B0004u:
            goto LABEL_154;
          case 0x1B0005u:
            goto LABEL_118;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_76:
            v12 = a4;
            goto LABEL_115;
          case 0x1C0001u:
LABEL_117:
            *(_WORD *)(v7 + 32) = (int)a4;
            break;
          case 0x1C0002u:
            goto LABEL_116;
          case 0x1C0003u:
            goto LABEL_69;
          case 0x1C0004u:
            goto LABEL_154;
          case 0x1C0005u:
LABEL_118:
            *(_WORD *)(v7 + 34) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_139;
          case 0x1D0001u:
            goto LABEL_154;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = (int)a4;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = (int)a4;
            break;
          case 0x1D0004u:
            *(_BYTE *)(v7 + 32) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        if (a2 == 1966082)
          goto LABEL_87;
        if (a2 == 1966081)
          goto LABEL_154;
        if (a2 != 1966080)
          return result;
        goto LABEL_139;
      case 0x1Fu:
        if (a2 == 2031617)
          goto LABEL_157;
        if (a2 != 2031616)
          return result;
        goto LABEL_69;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_111;
          case 0x200001u:
            goto LABEL_154;
          case 0x200002u:
            goto LABEL_87;
          case 0x200003u:
            goto LABEL_95;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689)
          goto LABEL_154;
        if (a2 != 2162688)
          return result;
        goto LABEL_139;
      case 0x22u:
        if (a2 == 2228225)
          goto LABEL_154;
        if (a2 != 2228224)
          return result;
LABEL_111:
        v11 = a4;
        goto LABEL_140;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_111;
          case 0x230001u:
            goto LABEL_154;
          case 0x230002u:
            goto LABEL_147;
          case 0x230003u:
LABEL_95:
            v12 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_115;
          case 0x230004u:
LABEL_160:
            v10 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_161;
          case 0x230005u:
            v18 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_200;
          case 0x230006u:
            v20 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_202;
          case 0x230007u:
LABEL_116:
            v15 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_129;
          case 0x230008u:
LABEL_162:
            v17 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_173;
          case 0x230009u:
LABEL_186:
            *(_DWORD *)(v7 + 68) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Au:
LABEL_196:
            *(_DWORD *)(v7 + 76) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Bu:
LABEL_187:
            *(_DWORD *)(v7 + 72) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Cu:
LABEL_197:
            *(_DWORD *)(v7 + 80) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Du:
LABEL_189:
            *(_DWORD *)(v7 + 52) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Eu:
LABEL_190:
            *(_DWORD *)(v7 + 56) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Fu:
LABEL_215:
            *(_DWORD *)(v7 + 60) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230010u:
            *(_DWORD *)(v7 + 64) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230011u:
            v22 = *(_BYTE *)(v7 + 84) & 0xFE | (a4 != 0.0);
            goto LABEL_206;
          case 0x230012u:
            v22 = *(_BYTE *)(v7 + 84) & 0xFD | (2 * (a4 != 0.0));
LABEL_206:
            *(_BYTE *)(v7 + 84) = v22;
            break;
          case 0x230013u:
LABEL_198:
            *(_DWORD *)(v7 + 88) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230014u:
            v23 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_219:
            *(_DWORD *)(v7 + 92) = v23;
            break;
          case 0x230015u:
            v24 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_221:
            *(_DWORD *)(v7 + 96) = v24;
            break;
          case 0x230016u:
            v25 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_223:
            *(_DWORD *)(v7 + 100) = v25;
            break;
          case 0x230017u:
            *(_DWORD *)(v7 + 104) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230018u:
            *(_DWORD *)(v7 + 108) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
          goto LABEL_157;
        if (a2 != 2359296)
          return result;
        goto LABEL_69;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(_QWORD *)(v7 + 24) = (unint64_t)a4;
            break;
          case 0x260001u:
            goto LABEL_154;
          case 0x260000u:
LABEL_69:
            v11 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_140:
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1)
          return result;
        v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 != 2555906)
            return result;
LABEL_154:
          v16 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_158;
        }
        if (!v14)
        {
          if (a2 != 2555905)
            return result;
          goto LABEL_157;
        }
        if (a2 == 2555905 && v14 == 2)
        {
LABEL_157:
          v16 = a4;
LABEL_158:
          *(_DWORD *)(v7 + 20) = v16;
          return result;
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = (int)a4;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = (int)a4;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = a4;
            break;
          case 0x280003u:
LABEL_130:
            *(_BYTE *)(v7 + 24) = (int)a4;
            break;
          case 0x280004u:
LABEL_131:
            *(_BYTE *)(v7 + 25) = (int)a4;
            break;
          case 0x280005u:
            goto LABEL_114;
          case 0x280006u:
LABEL_121:
            v10 = a4;
LABEL_161:
            *(_DWORD *)(v7 + 32) = v10;
            break;
          case 0x280007u:
LABEL_128:
            v15 = a4;
LABEL_129:
            *(_DWORD *)(v7 + 36) = v15;
            break;
          case 0x280008u:
            *(_BYTE *)(v7 + 44) = (int)a4;
            break;
          case 0x280009u:
LABEL_171:
            v20 = a4;
LABEL_202:
            *(_DWORD *)(v7 + 48) = v20;
            break;
          case 0x28000Au:
            *(_QWORD *)(v7 + 56) = (unint64_t)a4;
            break;
          case 0x28000Bu:
            *(_BYTE *)(v7 + 26) = (int)a4;
            break;
          case 0x28000Cu:
LABEL_172:
            v17 = a4;
LABEL_173:
            *(_DWORD *)(v7 + 40) = v17;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_111;
          case 0x290001u:
            goto LABEL_119;
          case 0x290002u:
            goto LABEL_132;
          case 0x290003u:
            goto LABEL_133;
          case 0x290004u:
LABEL_134:
            *(double *)(v7 + 40) = a4;
            break;
          case 0x290005u:
            goto LABEL_122;
          case 0x290006u:
            goto LABEL_123;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_113:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
          case 0x2A0001u:
LABEL_120:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x2A0002u:
LABEL_132:
            *(double *)(v7 + 24) = a4;
            break;
          case 0x2A0003u:
LABEL_133:
            *(double *)(v7 + 32) = a4;
            break;
          case 0x2A0004u:
            *(_BYTE *)(v7 + 40) = a4 != 0.0;
            break;
          case 0x2A0005u:
LABEL_169:
            v18 = a4;
LABEL_200:
            *(_DWORD *)(v7 + 44) = v18;
            break;
          case 0x2A0006u:
LABEL_122:
            *(double *)(v7 + 48) = a4;
            break;
          case 0x2A0007u:
LABEL_123:
            *(double *)(v7 + 56) = a4;
            break;
          case 0x2A0008u:
LABEL_149:
            *(double *)(v7 + 64) = a4;
            break;
          case 0x2A0009u:
LABEL_150:
            *(double *)(v7 + 72) = a4;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

_QWORD *IOHIDEventSetUInt64Value(_QWORD *a1, unsigned int a2, unint64_t a3)
{
  return IOHIDEventSetUInt64ValueWithOptions(a1, a2, a3, 4026531840);
}

_QWORD *IOHIDEventSetUInt64ValueWithOptions(_QWORD *result, unsigned int a2, unint64_t a3, uint64_t a4)
{
  unsigned int v6;
  uint64_t v7;
  char v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;

  v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (result = (_QWORD *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a4)) != 0)
  {
    v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFE | (a3 != 0);
            goto LABEL_179;
          case 1u:
            v8 = *(_BYTE *)(v7 + 8) & 0xFD | (2 * (a3 != 0));
            goto LABEL_179;
          case 2u:
            goto LABEL_21;
          case 3u:
            v8 = *(_BYTE *)(v7 + 8) & 0xF7 | (8 * (a3 != 0));
            goto LABEL_179;
          case 4u:
            v8 = *(_BYTE *)(v7 + 8) & 0xEF | (16 * (a3 != 0));
            goto LABEL_179;
          case 5u:
            v8 = *(_BYTE *)(v7 + 8) & 0xDF | (32 * (a3 != 0));
            goto LABEL_179;
          case 6u:
            v8 = *(_BYTE *)(v7 + 8) & 0xBF | ((a3 != 0) << 6);
            goto LABEL_179;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x10002u:
            goto LABEL_170;
          case 0x10004u:
            if (*(_DWORD *)(v7 + 24) >= 8u)
              *(_QWORD *)(v7 + 28) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_145;
          case 0x20001u:
            goto LABEL_133;
          case 0x20002u:
            goto LABEL_134;
          case 0x20003u:
            goto LABEL_151;
          case 0x20004u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_118;
          case 0x30001u:
            goto LABEL_126;
          case 0x30002u:
            goto LABEL_170;
          case 0x30003u:
            goto LABEL_182;
          case 0x30004u:
            *(_BYTE *)(v7 + 28) = a3;
            break;
          case 0x30005u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a3 != 0);
            goto LABEL_156;
          case 0x30006u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a3 & 3));
            goto LABEL_156;
          case 0x30007u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a3 & 3));
            goto LABEL_156;
          case 0x30008u:
            *(_DWORD *)(v7 + 24) = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a3 != 0));
            break;
          case 0x30009u:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a3 & 7) << 6);
            goto LABEL_156;
          case 0x3000Au:
            v10 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a3 & 3) << 9);
            goto LABEL_156;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146)
          goto LABEL_52;
        if (a2 == 262145)
          goto LABEL_165;
        if (a2 != 0x40000)
          return result;
        goto LABEL_69;
      case 5u:
        if (a2 == 327682)
          goto LABEL_154;
        if (a2 == 327681)
          goto LABEL_151;
        if (a2 != 327680)
          return result;
        goto LABEL_105;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_105;
          case 0x60001u:
            goto LABEL_151;
          case 0x60002u:
            goto LABEL_154;
          case 0x60003u:
LABEL_21:
            v8 = *(_BYTE *)(v7 + 8) & 0xFB | (4 * (a3 != 0));
LABEL_179:
            *(_BYTE *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
LABEL_52:
            v10 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v10 = 0x80000000;
            goto LABEL_156;
          case 0x70001u:
            goto LABEL_165;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_154:
          v10 = (_DWORD)a3 << 16;
          if ((_DWORD)a3 == 0x80000000)
            v10 = 0x80000000;
LABEL_156:
          *(_DWORD *)(v7 + 24) = v10;
          return result;
        }
        if (a2 == 589825)
          goto LABEL_151;
        if (a2 != 589824)
          return result;
        goto LABEL_105;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_154;
                case 0xA0001u:
                  goto LABEL_151;
                case 0xA0000u:
                  goto LABEL_105;
              }
              break;
            case 1:
              if (a2 == 655364)
                goto LABEL_145;
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_154;
                case 0xA0006u:
                  goto LABEL_151;
                case 0xA0005u:
                  goto LABEL_105;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_105;
                case 0xA0009u:
                  goto LABEL_151;
                case 0xA000Au:
                  goto LABEL_154;
                case 0xA000Bu:
                  goto LABEL_157;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_165;
          case 0xB0002u:
            goto LABEL_52;
          case 0xB0003u:
            goto LABEL_183;
          case 0xB0004u:
            goto LABEL_127;
          case 0xB0005u:
            goto LABEL_119;
          case 0xB0006u:
            goto LABEL_132;
          case 0xB0007u:
            goto LABEL_184;
          case 0xB0008u:
LABEL_182:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a3 != 0) << 16);
            goto LABEL_257;
          case 0xB0009u:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a3 != 0) << 17);
            goto LABEL_257;
          case 0xB000Au:
            goto LABEL_208;
          case 0xB000Bu:
            goto LABEL_211;
          case 0xB000Cu:
            goto LABEL_253;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_199;
                  case 0xB0013u:
                    goto LABEL_214;
                  case 0xB0014u:
                    goto LABEL_217;
                  case 0xB0015u:
LABEL_262:
                    v38 = (_DWORD)a3 << 16;
                    if ((_DWORD)a3 == 0x80000000)
                      v38 = 0x80000000;
                    *(_DWORD *)(v7 + 84) = v38;
                    break;
                  case 0xB001Au:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_196;
                  case 0xB0010u:
                    goto LABEL_199;
                  case 0xB0011u:
                    goto LABEL_214;
                  case 0xB0012u:
                    goto LABEL_217;
                  case 0xB0014u:
                    goto LABEL_262;
                  case 0xB0015u:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910)
              goto LABEL_199;
            if (a2 != 720909)
              return result;
            goto LABEL_196;
          case 0xB0016u:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a3 != 0));
            goto LABEL_257;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32))
              goto LABEL_253;
            return result;
          case 0xB0018u:
            goto LABEL_181;
          case 0xB0019u:
            v20 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a3 != 0) << 19);
LABEL_257:
            *(_DWORD *)(v7 + 8) = v20;
            return result;
          case 0xB001Bu:
            *(_DWORD *)(v7 + 92) = a3;
            return result;
          case 0xB001Cu:
            *(_DWORD *)(v7 + 96) = a3;
            return result;
          case 0xB001Du:
            *(_DWORD *)(v7 + 100) = a3;
            return result;
          case 0xB001Eu:
            *(_DWORD *)(v7 + 40) = ((_DWORD)a3 << 13) & 0x30000000 | (((a3 >> 10) & 1) << 30) & 0x70000000 | ((a3 >> 23) << 31) | *(_DWORD *)(v7 + 40) & 0xFFFFFFF;
            return result;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_116;
          case 0xC0001u:
            goto LABEL_170;
          case 0xC0002u:
            goto LABEL_88;
          case 0xC0003u:
            goto LABEL_119;
          case 0xC0004u:
            goto LABEL_127;
          case 0xC0005u:
            *(_BYTE *)(v7 + 36) = a3 != 0;
            break;
          case 0xC0006u:
            *(_BYTE *)(v7 + 37) = a3;
            break;
          case 0xC0007u:
            goto LABEL_137;
          case 0xC0008u:
            goto LABEL_128;
          case 0xC0009u:
            goto LABEL_129;
          case 0xC000Au:
            goto LABEL_160;
          case 0xC000Bu:
            goto LABEL_161;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_165;
          case 0xD0002u:
            goto LABEL_52;
          case 0xD0003u:
            goto LABEL_119;
          case 0xD0004u:
            goto LABEL_127;
          case 0xD0005u:
            goto LABEL_132;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_118;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507)
                goto LABEL_143;
              return result;
            }
            if (a2 != 917505 || *(_WORD *)(v7 + 18))
              return result;
            break;
          case 0xE0002u:
            goto LABEL_126;
          default:
            return result;
        }
        goto LABEL_143;
      case 0xFu:
        if (a2 != 983040)
          return result;
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_78;
          case 0x100001u:
            goto LABEL_123;
          case 0x100002u:
            goto LABEL_120;
          case 0x100003u:
            goto LABEL_105;
          case 0x100004u:
            goto LABEL_151;
          case 0x100005u:
            goto LABEL_124;
          case 0x100006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_165;
          case 0x110002u:
            goto LABEL_52;
          case 0x110003u:
            goto LABEL_119;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649)
          goto LABEL_165;
        if (a2 != 1179648)
          return result;
        goto LABEL_116;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_105;
          case 0x130001u:
            goto LABEL_151;
          case 0x130002u:
            goto LABEL_154;
          case 0x130003u:
            goto LABEL_96;
          case 0x130004u:
            goto LABEL_120;
          case 0x130005u:
            goto LABEL_171;
          case 0x130006u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_105;
          case 0x140001u:
            goto LABEL_151;
          case 0x140002u:
            goto LABEL_154;
          case 0x140003u:
            goto LABEL_78;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_130;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_105;
          case 0x150001u:
            goto LABEL_151;
          case 0x150002u:
            goto LABEL_154;
          case 0x150003u:
            goto LABEL_78;
          case 0x150004u:
LABEL_61:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x150005u:
LABEL_130:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_78;
          case 0x170001u:
            goto LABEL_123;
          case 0x170002u:
            goto LABEL_120;
          case 0x170003u:
            goto LABEL_105;
          case 0x170004u:
            goto LABEL_151;
          case 0x170005u:
            goto LABEL_124;
          case 0x170006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864)
          goto LABEL_116;
        if (a2 == 1572865)
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a3 != 0) << 15);
        return result;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
LABEL_119:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x190001u:
LABEL_88:
            *(_DWORD *)(v7 + 24) = a3;
            break;
          case 0x190000u:
LABEL_69:
            v11 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v11 = 0x80000000;
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            goto LABEL_88;
          case 0x1A0001u:
LABEL_125:
            *(_BYTE *)(v7 + 20) = a3;
            break;
          case 0x1A0000u:
LABEL_145:
            *(_DWORD *)(v7 + 16) = a3;
            break;
        }
        return result;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_78;
          case 0x1B0001u:
            goto LABEL_123;
          case 0x1B0002u:
            goto LABEL_120;
          case 0x1B0003u:
            goto LABEL_105;
          case 0x1B0004u:
            goto LABEL_151;
          case 0x1B0005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_78:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x1C0001u:
LABEL_123:
            *(_WORD *)(v7 + 32) = a3;
            break;
          case 0x1C0002u:
            goto LABEL_120;
          case 0x1C0003u:
            goto LABEL_105;
          case 0x1C0004u:
            goto LABEL_151;
          case 0x1C0005u:
LABEL_124:
            *(_WORD *)(v7 + 34) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_145;
          case 0x1D0001u:
            goto LABEL_151;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = a3;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = a3;
            break;
          case 0x1D0004u:
            *(_BYTE *)(v7 + 32) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            goto LABEL_145;
          case 0x1E0001u:
            goto LABEL_151;
          case 0x1E0002u:
            goto LABEL_88;
          case 0x1E0003u:
            if (*(_DWORD *)(v7 + 24) >= 8u)
              *(_QWORD *)(v7 + 28) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617)
          goto LABEL_143;
        if (a2 != 2031616)
          return result;
        goto LABEL_105;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_116;
          case 0x200001u:
            goto LABEL_165;
          case 0x200002u:
            goto LABEL_88;
          case 0x200003u:
            goto LABEL_157;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689)
          goto LABEL_151;
        if (a2 != 2162688)
          return result;
        goto LABEL_145;
      case 0x22u:
        if (a2 == 2228225)
          goto LABEL_165;
        if (a2 != 2228224)
          return result;
LABEL_116:
        *(_DWORD *)(v7 + 16) = a3;
        return result;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_116;
          case 0x230001u:
            goto LABEL_165;
          case 0x230002u:
            goto LABEL_52;
          case 0x230003u:
LABEL_157:
            v17 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v17 = 0x80000000;
            *(_DWORD *)(v7 + 28) = v17;
            return result;
          case 0x230004u:
LABEL_96:
            v12 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v12 = 0x80000000;
            *(_DWORD *)(v7 + 32) = v12;
            return result;
          case 0x230005u:
            v28 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v28 = 0x80000000;
            *(_DWORD *)(v7 + 44) = v28;
            return result;
          case 0x230006u:
            v29 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v29 = 0x80000000;
            *(_DWORD *)(v7 + 48) = v29;
            return result;
          case 0x230007u:
LABEL_120:
            v15 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v15 = 0x80000000;
            *(_DWORD *)(v7 + 36) = v15;
            return result;
          case 0x230008u:
LABEL_171:
            v19 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v19 = 0x80000000;
            *(_DWORD *)(v7 + 40) = v19;
            return result;
          case 0x230009u:
LABEL_196:
            v21 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v21 = 0x80000000;
            *(_DWORD *)(v7 + 68) = v21;
            return result;
          case 0x23000Au:
LABEL_214:
            v25 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v25 = 0x80000000;
            *(_DWORD *)(v7 + 76) = v25;
            return result;
          case 0x23000Bu:
LABEL_199:
            v22 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v22 = 0x80000000;
            *(_DWORD *)(v7 + 72) = v22;
            return result;
          case 0x23000Cu:
LABEL_217:
            v26 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v26 = 0x80000000;
            *(_DWORD *)(v7 + 80) = v26;
            return result;
          case 0x23000Du:
LABEL_208:
            v23 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v23 = 0x80000000;
            *(_DWORD *)(v7 + 52) = v23;
            return result;
          case 0x23000Eu:
LABEL_211:
            v24 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v24 = 0x80000000;
            *(_DWORD *)(v7 + 56) = v24;
            return result;
          case 0x23000Fu:
LABEL_253:
            v37 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v37 = 0x80000000;
            *(_DWORD *)(v7 + 60) = v37;
            return result;
          case 0x230010u:
            v30 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v30 = 0x80000000;
            *(_DWORD *)(v7 + 64) = v30;
            return result;
          case 0x230011u:
            v31 = *(_BYTE *)(v7 + 84) & 0xFE | (a3 != 0);
            goto LABEL_234;
          case 0x230012u:
            v31 = *(_BYTE *)(v7 + 84) & 0xFD | (2 * (a3 != 0));
LABEL_234:
            *(_BYTE *)(v7 + 84) = v31;
            break;
          case 0x230013u:
LABEL_220:
            v27 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v27 = 0x80000000;
            *(_DWORD *)(v7 + 88) = v27;
            break;
          case 0x230014u:
            v32 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v32 = 0x80000000;
            *(_DWORD *)(v7 + 92) = v32;
            break;
          case 0x230015u:
            v33 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v33 = 0x80000000;
            *(_DWORD *)(v7 + 96) = v33;
            break;
          case 0x230016u:
            v34 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v34 = 0x80000000;
            *(_DWORD *)(v7 + 100) = v34;
            break;
          case 0x230017u:
            v35 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v35 = 0x80000000;
            *(_DWORD *)(v7 + 104) = v35;
            break;
          case 0x230018u:
            v36 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v36 = 0x80000000;
            *(_DWORD *)(v7 + 108) = v36;
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
        {
LABEL_143:
          *(_DWORD *)(v7 + 20) = a3;
        }
        else if (a2 == 2359296)
        {
          goto LABEL_105;
        }
        return result;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(_QWORD *)(v7 + 24) = a3;
            break;
          case 0x260001u:
LABEL_151:
            v16 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v16 = 0x80000000;
            *(_DWORD *)(v7 + 20) = v16;
            break;
          case 0x260000u:
LABEL_105:
            v13 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v13 = 0x80000000;
            *(_DWORD *)(v7 + 16) = v13;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1)
          return result;
        v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 == 2555906)
          {
LABEL_165:
            v18 = (_DWORD)a3 << 16;
            if ((_DWORD)a3 == 0x80000000)
              v18 = 0x80000000;
            *(_DWORD *)(v7 + 20) = v18;
          }
        }
        else
        {
          if (!v14)
          {
            if (a2 != 2555905)
              return result;
            goto LABEL_170;
          }
          if (a2 == 2555905 && v14 == 2)
          {
LABEL_170:
            *(_DWORD *)(v7 + 20) = a3;
            return result;
          }
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = a3;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = a3;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = (double)a3;
            break;
          case 0x280003u:
LABEL_133:
            *(_BYTE *)(v7 + 24) = a3;
            break;
          case 0x280004u:
LABEL_134:
            *(_BYTE *)(v7 + 25) = a3;
            break;
          case 0x280005u:
            goto LABEL_119;
          case 0x280006u:
LABEL_127:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x280007u:
LABEL_132:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          case 0x280008u:
            *(_BYTE *)(v7 + 44) = a3;
            break;
          case 0x280009u:
LABEL_183:
            *(_DWORD *)(v7 + 48) = a3;
            break;
          case 0x28000Au:
            *(_QWORD *)(v7 + 56) = a3;
            break;
          case 0x28000Bu:
            *(_BYTE *)(v7 + 26) = a3;
            break;
          case 0x28000Cu:
LABEL_184:
            *(_DWORD *)(v7 + 40) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_116;
          case 0x290001u:
            goto LABEL_125;
          case 0x290002u:
            goto LABEL_135;
          case 0x290003u:
            goto LABEL_136;
          case 0x290004u:
LABEL_137:
            *(double *)(v7 + 40) = (double)a3;
            break;
          case 0x290005u:
            goto LABEL_128;
          case 0x290006u:
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_118:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x2A0001u:
LABEL_126:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x2A0002u:
LABEL_135:
            *(double *)(v7 + 24) = (double)a3;
            break;
          case 0x2A0003u:
LABEL_136:
            *(double *)(v7 + 32) = (double)a3;
            break;
          case 0x2A0004u:
            *(_BYTE *)(v7 + 40) = a3 != 0;
            break;
          case 0x2A0005u:
LABEL_181:
            *(_DWORD *)(v7 + 44) = a3;
            break;
          case 0x2A0006u:
LABEL_128:
            *(double *)(v7 + 48) = (double)a3;
            break;
          case 0x2A0007u:
LABEL_129:
            *(double *)(v7 + 56) = (double)a3;
            break;
          case 0x2A0008u:
LABEL_160:
            *(double *)(v7 + 64) = (double)a3;
            break;
          case 0x2A0009u:
LABEL_161:
            *(double *)(v7 + 72) = (double)a3;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

uint64_t IOHIDEventGetIntegerMultiple(uint64_t result, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v7;
  unsigned int v8;

  if (a4 >= 1)
  {
    v4 = a4;
    v7 = (_QWORD *)result;
    do
    {
      v8 = *a2++;
      result = IOHIDEventGetIntegerValueWithOptions(v7, v8, 0);
      *a3++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t IOHIDEventGetIntegerMultipleWithOptions(uint64_t result, unsigned int *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v9;
  unsigned int v10;

  if (a4 >= 1)
  {
    v6 = a4;
    v9 = (_QWORD *)result;
    do
    {
      v10 = *a2++;
      result = IOHIDEventGetIntegerValueWithOptions(v9, v10, a5);
      *a3++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

void IOHIDEventGetFloatMultiple(_QWORD *a1, unsigned int *a2, __n64 *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v8;

  if (a4 >= 1)
  {
    v4 = a4;
    do
    {
      v8 = *a2++;
      a3->n64_u64[0] = IOHIDEventGetFloatValueWithOptions(a1, v8, 0).n64_u64[0];
      ++a3;
      --v4;
    }
    while (v4);
  }
}

void IOHIDEventGetFloatMultipleWithOptions(_QWORD *a1, unsigned int *a2, __n64 *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unsigned int v10;

  if (a4 >= 1)
  {
    v6 = a4;
    do
    {
      v10 = *a2++;
      a3->n64_u64[0] = IOHIDEventGetFloatValueWithOptions(a1, v10, a5).n64_u64[0];
      ++a3;
      --v6;
    }
    while (v6);
  }
}

unint64_t IOHIDEventGetUInt64Multiple(unint64_t result, unsigned int *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v7;
  unsigned int v8;

  if (a4 >= 1)
  {
    v4 = a4;
    v7 = (_QWORD *)result;
    do
    {
      v8 = *a2++;
      result = IOHIDEventGetUInt64ValueWithOptions(v7, v8, 0);
      *a3++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

unint64_t IOHIDEventGetUInt64MultipleWithOptions(unint64_t result, unsigned int *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v9;
  unsigned int v10;

  if (a4 >= 1)
  {
    v6 = a4;
    v9 = (_QWORD *)result;
    do
    {
      v10 = *a2++;
      result = IOHIDEventGetUInt64ValueWithOptions(v9, v10, a5);
      *a3++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

_QWORD *IOHIDEventSetIntegerMultiple(_QWORD *result, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  if (a4 >= 1)
  {
    v4 = a4;
    v7 = result;
    do
    {
      v9 = *a2++;
      v8 = v9;
      v10 = *a3++;
      result = IOHIDEventSetIntegerValueWithOptions(v7, v8, v10, 0);
      --v4;
    }
    while (v4);
  }
  return result;
}

_QWORD *IOHIDEventSetIntegerMultipleWithOptions(_QWORD *result, unsigned int *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;

  if (a4 >= 1)
  {
    v6 = a4;
    v9 = result;
    do
    {
      v11 = *a2++;
      v10 = v11;
      v12 = *a3++;
      result = IOHIDEventSetIntegerValueWithOptions(v9, v10, v12, a5);
      --v6;
    }
    while (v6);
  }
  return result;
}

_QWORD *IOHIDEventSetFloatMultiple(_QWORD *result, unsigned int *a2, double *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  double v10;

  if (a4 >= 1)
  {
    v4 = a4;
    v7 = result;
    do
    {
      v9 = *a2++;
      v8 = v9;
      v10 = *a3++;
      result = IOHIDEventSetFloatValueWithOptions(v7, v8, 0, v10);
      --v4;
    }
    while (v4);
  }
  return result;
}

_QWORD *IOHIDEventSetFloatMultipleWithOptions(_QWORD *result, unsigned int *a2, double *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v9;
  unsigned int v10;
  unsigned int v11;
  double v12;

  if (a4 >= 1)
  {
    v6 = a4;
    v9 = result;
    do
    {
      v11 = *a2++;
      v10 = v11;
      v12 = *a3++;
      result = IOHIDEventSetFloatValueWithOptions(v9, v10, a5, v12);
      --v6;
    }
    while (v6);
  }
  return result;
}

_QWORD *IOHIDEventSetDoubleMultiple(_QWORD *result, unsigned int *a2, double *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  double v10;

  if (a4 >= 1)
  {
    v4 = a4;
    v7 = result;
    do
    {
      v9 = *a2++;
      v8 = v9;
      v10 = *a3++;
      result = IOHIDEventSetDoubleValueWithOptions(v7, v8, 0, v10);
      --v4;
    }
    while (v4);
  }
  return result;
}

_QWORD *IOHIDEventSetDoubleMultipleWithOptions(_QWORD *result, unsigned int *a2, double *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v9;
  unsigned int v10;
  unsigned int v11;
  double v12;

  if (a4 >= 1)
  {
    v6 = a4;
    v9 = result;
    do
    {
      v11 = *a2++;
      v10 = v11;
      v12 = *a3++;
      result = IOHIDEventSetDoubleValueWithOptions(v9, v10, a5, v12);
      --v6;
    }
    while (v6);
  }
  return result;
}

_QWORD *IOHIDEventSetUInt64Multiple(_QWORD *result, unsigned int *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  unint64_t v10;

  if (a4 >= 1)
  {
    v4 = a4;
    v7 = result;
    do
    {
      v9 = *a2++;
      v8 = v9;
      v10 = *a3++;
      result = IOHIDEventSetUInt64ValueWithOptions(v7, v8, v10, 0);
      --v4;
    }
    while (v4);
  }
  return result;
}

_QWORD *IOHIDEventSetUInt64MultipleWithOptions(_QWORD *result, unsigned int *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;

  if (a4 >= 1)
  {
    v6 = a4;
    v9 = result;
    do
    {
      v11 = *a2++;
      v10 = v11;
      v12 = *a3++;
      result = IOHIDEventSetUInt64ValueWithOptions(v9, v10, v12, a5);
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t IOHIDEventGetParent(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t IOHIDEventRemoveEvent(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  const __CFArray *v7;
  CFRange v8;

  if (a2)
  {
    if (*(_QWORD *)(result + 72))
    {
      v3 = a2[10];
      if (v3)
      {
        v4 = 0;
        v5 = (_QWORD *)a2[10];
        do
        {
          v6 = v5;
          if (v5 == (_QWORD *)result)
            v4 = v5;
          v5 = (_QWORD *)v5[10];
        }
        while (v5);
        if (v4)
        {
          v7 = *(const __CFArray **)(v3 + 72);
          v8.length = CFArrayGetCount(v7);
          v8.location = 0;
          result = CFArrayGetFirstIndexOfValue(v7, v8, a2);
          if (result != -1)
          {
            a2[10] = 0;
            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 72), result);
            return __IOHIDEventFixTypeEventMask(v6);
          }
        }
      }
    }
  }
  return result;
}

uint64_t __IOHIDEventFixTypeEventMask(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  CFIndex i;
  uint64_t v5;

  a1[3] = 1 << *(_DWORD *)(a1[13] + 4);
  result = a1[9];
  if (result)
  {
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v3 = result;
      for (i = 0; i != v3; ++i)
      {
        result = (uint64_t)CFArrayGetValueAtIndex((CFArrayRef)a1[9], i);
        if (result)
        {
          v5 = result;
          result = __IOHIDEventFixTypeEventMask();
          a1[3] |= *(_QWORD *)(v5 + 24);
        }
      }
    }
  }
  return result;
}

int64_t __IOHIDEventReadBytesHelper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t TimeStamp;
  uint64_t v8;
  int64x2_t v9;
  char *v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;

  v6 = *(_DWORD *)(a1 + 32);
  if ((v6 & 0x80) != 0)
  {
    TimeStamp = *(_QWORD *)(a1 + 8);
  }
  else
  {
    TimeStamp = IOHIDEventGetTimeStamp(a1);
    v6 = *(_DWORD *)(a1 + 32);
  }
  v8 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a2 = TimeStamp;
  *(_QWORD *)(a2 + 8) = v8;
  *(_DWORD *)(a2 + 16) = v6;
  v9 = *(int64x2_t *)(a1 + 88);
  *(int32x2_t *)(a2 + 20) = vmovn_s64(v9);
  v10 = (char *)(a2 + 28);
  v11 = a3 - 28;
  if (v9.i64[0])
  {
    v12 = *(const void **)(a1 + 40);
    if (v12)
    {
      memmove(v10, v12, v9.u64[0]);
      v13 = *(_QWORD *)(a1 + 88);
      v10 += v13;
      v11 -= v13;
    }
  }
  return __IOHIDEventDataAppendEventData(a1, v10, v11);
}

const void *__IOHIDEventCreateWithDataHelper(uint64_t a1, CFDataRef theData)
{
  const UInt8 *BytePtr;
  uint64_t v5;
  CFIndex Length;

  if (theData
    && (BytePtr = CFDataGetBytePtr(theData)) != 0
    && (v5 = (uint64_t)BytePtr, Length = CFDataGetLength(theData), Length >= 28))
  {
    return __IOHIDEventCreateWithBytesHelper(a1, v5, Length);
  }
  else
  {
    return 0;
  }
}

const void *__IOHIDEventCreateWithBytesHelper(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned int v4;
  int v7;
  const void *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  HIDEvent *v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  unsigned int v23;
  int64_t v24;
  char *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  unsigned int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a3 < 0x1C)
    return 0;
  v4 = a3 - 28;
  if (!*(_DWORD *)(a2 + 24) || *(_DWORD *)(a2 + 20) >= v4)
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v26 = (char *)(a2 + 28);
  v24 = *(unsigned int *)(a2 + 20);
  v10 = *(_DWORD *)(a2 + 20);
  while (1)
  {
    v11 = v9;
    if (v4 - v10 < 0x10)
      return v8;
    v12 = &v26[v10];
    v13 = *(unsigned int *)v12;
    if (v13 <= 0xF)
    {
      v20 = _IOHIDLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        __IOHIDEventCreateWithBytesHelper_cold_1(v7, v13, v20);
      return v8;
    }
    if (v4 - v10 < v13)
    {
      v21 = _IOHIDLog();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109632;
        v28 = v7;
        v29 = 1024;
        v30 = v4 - v10;
        v31 = 1024;
        v32 = v13;
        _os_log_error_impl(&dword_18AAAF000, v21, OS_LOG_TYPE_ERROR, "Failed to create event at index=%d , eventDataMaxSize: %u < eventDataSize: %u", buf, 0x14u);
      }
      return v8;
    }
    v14 = *(_QWORD *)a2;
    v15 = _IOHIDEventCreate(a1, *(unsigned int *)v12, *((unsigned int *)v12 + 1), *(_QWORD *)a2, *(unsigned int *)(a2 + 16));
    if (!v15)
      break;
    v9 = (uint64_t)v15;
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      v14 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v14);
    }
    *(_QWORD *)(v9 + 8) = v14;
    memmove(*(void **)(v9 + 104), v12, v13);
    *(_QWORD *)(v9 + 16) = *(_QWORD *)(a2 + 8);
    if (v8)
    {
      if (v11)
      {
        v16 = v12[12];
        if (v16 <= *(unsigned __int8 *)(*(_QWORD *)(v11 + 104) + 12))
        {
          while (1)
          {
            v17 = *(_QWORD *)(v11 + 80);
            if (!v17)
              break;
            v18 = *(unsigned __int8 *)(*(_QWORD *)(v11 + 104) + 12);
            v11 = *(_QWORD *)(v11 + 80);
            if (v16 >= v18)
              goto LABEL_23;
          }
        }
        v17 = v11;
LABEL_23:
        IOHIDEventAppendEvent(v17, (_QWORD *)v9);
        CFRelease((CFTypeRef)v9);
      }
    }
    else
    {
      IOHIDEventSetAttributeData(v9, v26, v24);
      v8 = (const void *)v9;
    }
    v10 += v13;
    if (++v7 >= *(_DWORD *)(a2 + 24) || v10 >= v4)
      return v8;
  }
  v22 = _IOHIDLog();
  if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (!v8)
      return v8;
    goto LABEL_37;
  }
  v23 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)buf = 67109888;
  v28 = v7;
  v29 = 1024;
  v30 = v23;
  v31 = 1024;
  v32 = v10;
  v33 = 1024;
  v34 = v4;
  _os_log_error_impl(&dword_18AAAF000, v22, OS_LOG_TYPE_ERROR, "Failed to create event at index=%d eventCount=%d eventDataOffset=%d totalEventDataSize=%d", buf, 0x1Au);
  if (v8)
  {
LABEL_37:
    CFRelease(v8);
    return 0;
  }
  return v8;
}

void *IOHIDEventGetAttributeData(uint64_t a1, void *__dst, int64_t a3)
{
  if (*(_QWORD *)(a1 + 88) < a3)
    a3 = *(_QWORD *)(a1 + 88);
  return memmove(__dst, *(const void **)(a1 + 40), a3);
}

const char *IOHIDEventGetTypeString(unsigned int a1)
{
  const __CFString *Name;
  CFStringEncoding SystemEncoding;

  Name = IOHIDEventTypeGetName(a1);
  SystemEncoding = CFStringGetSystemEncoding();
  return CFStringGetCStringPtr(Name, SystemEncoding);
}

void __IOHIDEventTypeDescriptorVendorDefined(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6;
  uint64_t TimeStamp;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v6 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "UsagePage:", *(unsigned __int16 *)(v6 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Usage:", *(unsigned __int16 *)(v6 + 18));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Version:", *(unsigned int *)(v6 + 20));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "DataLength:", *(unsigned int *)(v6 + 24));
  if (__PAIR64__(*(unsigned __int16 *)(v6 + 18), *(__int16 *)(v6 + 16)) == 0x26FFFFFF00)
  {
    TimeStamp = IOHIDEventGetTimeStamp(a1);
    v8 = *(_QWORD *)(v6 + 28);
    if (v8)
      v9 = _IOHIDGetTimestampDelta(v8, TimeStamp, 0x3E8u);
    else
      v9 = 0;
    v10 = *(_QWORD *)(v6 + 36);
    if (v10)
      v11 = _IOHIDGetTimestampDelta(v10, TimeStamp, 0x3E8u);
    else
      v11 = 0;
    v12 = *(_QWORD *)(v6 + 44);
    if (v12)
      v13 = _IOHIDGetTimestampDelta(v12, TimeStamp, 0x3E8u);
    else
      v13 = 0;
    v14 = *(_QWORD *)(v6 + 52);
    if (v14)
      v15 = _IOHIDGetTimestampDelta(v14, TimeStamp, 0x3E8u);
    else
      v15 = 0;
    v16 = *(_QWORD *)(v6 + 60);
    if (v16)
      v16 = _IOHIDGetTimestampDelta(v16, TimeStamp, 0x3E8u);
    _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %-8llu %-8llu %-8llu %-8llu %-8llu\n"), "Dispatch Latency:", v9, v11, v13, v15, v16);
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s "), "Data:");
  if (*(_DWORD *)(v6 + 24))
  {
    v17 = 0;
    do
      _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("%02x "), *(unsigned __int8 *)(v6 + 28 + v17++));
    while (v17 < *(unsigned int *)(v6 + 24));
  }
  _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("\n"));
}

void __IOHIDEventTypeDescriptorButton(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Mask:", *(unsigned int *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Number:", *(unsigned __int8 *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "State:", *(unsigned int *)(v5 + 28));
  v6 = *(_DWORD *)(v5 + 20);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Pressure:", *(_QWORD *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "ClickCount:", *(unsigned __int8 *)(v5 + 25));
}

void __IOHIDEventTypeDescriptorKeyboard(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  const char *v7;
  const char *v8;
  const char *v9;
  unsigned int v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  const char *v15;

  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_DWORD *)(v5 + 8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "UsagePage:", *(unsigned __int16 *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Usage:", *(unsigned __int16 *)(v5 + 18));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Down:", *(unsigned int *)(v5 + 20));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "PressCount:", *(unsigned __int8 *)(v5 + 28));
  if ((*(_DWORD *)(v5 + 24) & 1) != 0)
    v7 = "yes";
  else
    v7 = "no";
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "LongPress:", v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "ClickSpeed:", (*(_DWORD *)(v5 + 24) >> 1) & 3);
  v8 = "begin";
  v9 = "";
  if ((v6 & 0x1000000) == 0)
    v8 = "";
  if ((v6 & 0x4000000) != 0)
    v9 = "ended";
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s%s\n"), "Phase:", v8, v9);
  v10 = *(_DWORD *)(v5 + 24);
  v11 = (v10 >> 9) & 3;
  if ((_DWORD)v11)
  {
    v12 = "Off";
    if ((_DWORD)v11 == 1)
      v12 = "On";
    _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s (%d)\n"), "Sticky Key Toggle:", v12, v11);
    v10 = *(_DWORD *)(v5 + 24);
  }
  v13 = (v10 >> 6) & 7;
  if ((_DWORD)v13)
  {
    v14 = "Down";
    v15 = "Locked";
    if ((_DWORD)v13 == 3)
      v15 = "Up";
    if ((_DWORD)v13 != 1)
      v14 = v15;
    _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s (%d)\n"), "Sticky Key Phase:", v14, v13);
  }
}

void __IOHIDEventTypeDescriptorTranslation(_QWORD *a1, __CFString *a2, int a3)
{
  uint64_t EventWithOptions;
  double v7;
  double v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  double v14;

  EventWithOptions = IOHIDEventGetEventWithOptions(a1, 4, 4026531840);
  v7 = 0.0;
  v8 = 0.0;
  if (EventWithOptions)
  {
    v9 = *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 16);
    v8 = (double)v9 * 0.0000152587891;
    if (v9 == 0x80000000)
      v8 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v8);
  v10 = IOHIDEventGetEventWithOptions(a1, 4, 4026531840);
  if (v10)
  {
    v11 = *(_DWORD *)(*(_QWORD *)(v10 + 104) + 20);
    if (v11 == 0x80000000)
      v7 = NAN;
    else
      v7 = (double)v11 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v7);
  v12 = IOHIDEventGetEventWithOptions(a1, 4, 4026531840);
  if (v12)
  {
    v13 = *(_DWORD *)(*(_QWORD *)(v12 + 104) + 24);
    v14 = (double)v13 * 0.0000152587891;
    if (v13 == 0x80000000)
      v14 = NAN;
  }
  else
  {
    v14 = 0.0;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s %f\n"), "Z:", *(_QWORD *)&v14);
}

void __IOHIDEventTypeDescriptorScroll(uint64_t a1, __CFString *a2, int a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  __IOHIDEventTypeDescriptorAxis(a1, a2, a3);
  v6 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8);
  v7 = HIBYTE(v6);
  if ((_DWORD)v7)
  {
    _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s 0x%x\n"), "phase:", v7);
    v6 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8);
  }
  v8 = (v6 >> 6) & 0x18 | (v6 >> 28) & 7;
  if ((_DWORD)v8)
    _IOHIDStringAppendIndendationAndFormat(a2, a3, CFSTR("%-20.20s 0x%x\n"), "momentum:", v8);
}

void __IOHIDEventTypeDescriptorOrientation(uint64_t a1, CFMutableStringRef theString, int a3)
{
  _DWORD *v5;
  int v6;
  double v7;
  int v8;
  double v9;
  int v10;
  int v11;
  double v12;
  int v13;
  double v14;
  int v15;
  double v16;
  double v17;

  v5 = *(_DWORD **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Orientation type:", v5[8]);
  switch(v5[8])
  {
    case 0:
    case 2:
      v6 = v5[4];
      v7 = (double)v6 * 0.0000152587891;
      if (v6 == 0x80000000)
        v7 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v7);
      v8 = v5[5];
      v9 = (double)v8 * 0.0000152587891;
      if (v8 == 0x80000000)
        v9 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v9);
      v10 = v5[6];
      goto LABEL_15;
    case 1:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Orientation usage:", v5[4]);
      break;
    case 3:
      v11 = v5[4];
      v12 = (double)v11 * 0.0000152587891;
      if (v11 == 0x80000000)
        v12 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "W:", *(_QWORD *)&v12);
      v13 = v5[5];
      v14 = (double)v13 * 0.0000152587891;
      if (v13 == 0x80000000)
        v14 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v14);
      v15 = v5[6];
      v16 = (double)v15 * 0.0000152587891;
      if (v15 == 0x80000000)
        v16 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v16);
      v10 = v5[7];
LABEL_15:
      v17 = (double)v10 * 0.0000152587891;
      if (v10 == 0x80000000)
        v17 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Z:", *(_QWORD *)&v17);
      break;
    default:
      return;
  }
}

void __IOHIDEventTypeDescriptorAmbientLightSensor(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  const char *v6;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Level:", *(unsigned int *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "CH0:", *(unsigned int *)(v5 + 20));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "CH1:", *(unsigned int *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "CH2:", *(unsigned int *)(v5 + 28));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "CH3:", *(unsigned int *)(v5 + 32));
  if (*(_BYTE *)(v5 + 37) == 1)
    v6 = "XYZ";
  else
    v6 = "Undefined";
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "ColorSpace:", v6);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "ColorComponent0:", *(_QWORD *)(v5 + 40));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "ColorComponent1:", *(_QWORD *)(v5 + 48));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "ColorComponent2:", *(_QWORD *)(v5 + 56));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "BrightnessChanged:", *(unsigned __int8 *)(v5 + 36));
}

void __IOHIDEventTypeDescriptorMotion(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;

  v6 = *(_QWORD *)(a1 + 104);
  v7 = *(int *)(v6 + 28);
  if (v7 > 2)
    v8 = 0;
  else
    v8 = (&off_1E2002818)[v7];
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "Type:", v8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Sequence:", *(unsigned int *)(v6 + 36));
  __IOHIDEventTypeDescriptorAxis(a1, theString, a3);
}

void __IOHIDEventTypeDescriptorProximity(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  const char *v6;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Mask:", *(unsigned __int16 *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %u\n"), "Type:", *(unsigned __int16 *)(v5 + 18));
  if (*(_WORD *)(v5 + 18))
  {
    if (*(_WORD *)(v5 + 18) != 1)
      return;
    v6 = "Probability:";
  }
  else
  {
    v6 = "Level:";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), v6, *(unsigned int *)(v5 + 20));
}

void __IOHIDEventTypeDescriptorTemperature(uint64_t a1, CFMutableStringRef theString, int a3)
{
  int v3;
  double v4;

  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 16);
  v4 = (double)v3 * 0.0000152587891;
  if (v3 == 0x80000000)
    v4 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Level:", *(_QWORD *)&v4);
}

void __IOHIDEventTypeDescriptorSwipe(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6;
  int v7;
  double v8;

  v6 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Mask:", *(unsigned int *)(v6 + 28));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Motion:", *(unsigned __int16 *)(v6 + 32));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Flavor:", *(unsigned __int16 *)(v6 + 34));
  v7 = *(_DWORD *)(v6 + 36);
  v8 = (double)v7 * 0.0000152587891;
  if (v7 == 0x80000000)
    v8 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Progress:", *(_QWORD *)&v8);
  __IOHIDEventTypeDescriptorAxis(a1, theString, a3);
}

void __IOHIDEventTypeDescriptorPointer(_QWORD *a1, CFMutableStringRef theString, int a3)
{
  uint64_t EventWithOptions;
  double v7;
  double v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  double v14;

  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Button Mask:", *(unsigned int *)(a1[13] + 28));
  EventWithOptions = IOHIDEventGetEventWithOptions(a1, 17, 4026531840);
  v7 = 0.0;
  v8 = 0.0;
  if (EventWithOptions)
  {
    v9 = *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 16);
    v8 = (double)v9 * 0.0000152587891;
    if (v9 == 0x80000000)
      v8 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v8);
  v10 = IOHIDEventGetEventWithOptions(a1, 17, 4026531840);
  if (v10)
  {
    v11 = *(_DWORD *)(*(_QWORD *)(v10 + 104) + 20);
    if (v11 == 0x80000000)
      v7 = NAN;
    else
      v7 = (double)v11 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v7);
  v12 = IOHIDEventGetEventWithOptions(a1, 17, 4026531840);
  if (v12)
  {
    v13 = *(_DWORD *)(*(_QWORD *)(v12 + 104) + 24);
    v14 = (double)v13 * 0.0000152587891;
    if (v13 == 0x80000000)
      v14 = NAN;
  }
  else
  {
    v14 = 0.0;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Z:", *(_QWORD *)&v14);
}

void __IOHIDEventTypeDescriptorProgress(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Type:", *(unsigned int *)(v5 + 16));
  v6 = *(_DWORD *)(v5 + 20);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Level:", *(_QWORD *)&v7);
}

void __IOHIDEventTypeDescriptorMultiAxisPointer(_QWORD *a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6;
  uint64_t EventWithOptions;
  double v8;
  double v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  double v14;
  double v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  double v20;
  double v21;
  int v22;
  uint64_t v23;
  int v24;

  v6 = a1[13];
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s 0x%08x\n"), "Button Mask:", *(unsigned int *)(v6 + 28));
  EventWithOptions = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  v8 = 0.0;
  v9 = 0.0;
  if (EventWithOptions)
  {
    v10 = *(_DWORD *)(*(_QWORD *)(EventWithOptions + 104) + 16);
    v9 = (double)v10 * 0.0000152587891;
    if (v10 == 0x80000000)
      v9 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "X:", *(_QWORD *)&v9);
  v11 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  if (v11)
  {
    v12 = *(_DWORD *)(*(_QWORD *)(v11 + 104) + 20);
    if (v12 == 0x80000000)
      v8 = NAN;
    else
      v8 = (double)v12 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Y:", *(_QWORD *)&v8);
  v13 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  v14 = 0.0;
  v15 = 0.0;
  if (v13)
  {
    v16 = *(_DWORD *)(*(_QWORD *)(v13 + 104) + 24);
    v15 = (double)v16 * 0.0000152587891;
    if (v16 == 0x80000000)
      v15 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Z:", *(_QWORD *)&v15);
  v17 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  if (v17)
  {
    v18 = *(_DWORD *)(*(_QWORD *)(v17 + 104) + 32);
    if (v18 == 0x80000000)
      v14 = NAN;
    else
      v14 = (double)v18 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Rx:", *(_QWORD *)&v14);
  v19 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  v20 = 0.0;
  v21 = 0.0;
  if (v19)
  {
    v22 = *(_DWORD *)(*(_QWORD *)(v19 + 104) + 36);
    v21 = (double)v22 * 0.0000152587891;
    if (v22 == 0x80000000)
      v21 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Ry:", *(_QWORD *)&v21);
  v23 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  if (v23)
  {
    v24 = *(_DWORD *)(*(_QWORD *)(v23 + 104) + 40);
    if (v24 == 0x80000000)
      v20 = NAN;
    else
      v20 = (double)v24 * 0.0000152587891;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Rz:", *(_QWORD *)&v20);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Repeat:", HIWORD(*(_DWORD *)(v6 + 8)) & 1);
}

void __IOHIDEventTypeDescriptorSymbolicHotKey(uint64_t a1, CFMutableStringRef theString, int a3)
{
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Key:", *(unsigned int *)(*(_QWORD *)(a1 + 104) + 16));
}

void __IOHIDEventTypeDescriptorPower(uint64_t a1, CFMutableStringRef theString, int a3)
{
  _DWORD *v5;
  int v6;
  double v7;

  v5 = *(_DWORD **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Type:", v5[6]);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "SubType:", v5[7]);
  v6 = v5[4];
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Level:", *(_QWORD *)&v7);
}

void __IOHIDEventTypeDescriptorBiometric(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  int v7;
  double v8;
  const char *v9;
  const char *v10;

  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_DWORD *)(v5 + 8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "EventType:", *(unsigned int *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "UsagePage:", *(unsigned __int16 *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Usage:", *(unsigned __int16 *)(v5 + 26));
  v7 = *(_DWORD *)(v5 + 20);
  v8 = (double)v7 * 0.0000152587891;
  if (v7 == 0x80000000)
    v8 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Level:", *(_QWORD *)&v8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Tap Count:", *(unsigned __int8 *)(v5 + 32));
  v9 = "begin";
  v10 = "";
  if ((v6 & 0x1000000) == 0)
    v9 = "";
  if ((v6 & 0x4000000) != 0)
    v10 = "ended";
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s%s\n"), "Phase:", v9, v10);
}

void __IOHIDEventTypeDescriptorUnicode(uint64_t a1, CFMutableStringRef theString, int a3)
{
  _DWORD *v5;
  uint64_t v6;
  const char *v7;
  int v8;
  double v9;
  unint64_t v10;

  v5 = *(_DWORD **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s "), "Encoding:");
  v6 = (int)v5[4];
  if (v6 > 4)
    v7 = "UNKNOWN";
  else
    v7 = (&off_1E2002830)[v6];
  _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("%s\n"), v7);
  v8 = v5[5];
  v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000)
    v9 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Quality:", *(_QWORD *)&v9);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "DataLength:", v5[6]);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s "), "Data:");
  if (v5[6])
  {
    v10 = 0;
    do
      _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("%02x "), *((unsigned __int8 *)v5 + v10++ + 28));
    while (v10 < v5[6]);
  }
  _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("\n"));
}

void __IOHIDEventTypeDescriptorAtmosphericPressure(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;

  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_DWORD *)(v5 + 16);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Level:", *(_QWORD *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Sequence:", *(unsigned int *)(v5 + 20));
}

void __IOHIDEventTypeDescriptorForceEvent(uint64_t a1, CFMutableStringRef theString, int a3)
{
  unsigned int *v5;
  int v6;
  double v7;
  int v8;
  double v9;

  v5 = *(unsigned int **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Behavior:", v5[4]);
  v6 = v5[5];
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Progress:", *(_QWORD *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Stage:", v5[6]);
  v8 = v5[7];
  v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000)
    v9 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "StageProgress:", *(_QWORD *)&v9);
}

void __IOHIDEventTypeDescriptorMotionActivity(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Type:", *(unsigned int *)(v5 + 16));
  v6 = *(_DWORD *)(v5 + 20);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Confidence:", *(_QWORD *)&v7);
}

void __IOHIDEventTypeDescriptorMotionGesture(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Type:", *(unsigned int *)(v5 + 16));
  v6 = *(_DWORD *)(v5 + 20);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Progress:", *(_QWORD *)&v7);
}

void __IOHIDEventTypeDescriptorGameController(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  const char *v6;
  int v7;
  double v8;
  int v9;
  double v10;
  int v11;
  double v12;
  int v13;
  double v14;
  int v15;
  double v16;
  int v17;
  double v18;
  int v19;
  double v20;
  int v21;
  double v22;
  int v23;
  double v24;
  int v25;
  double v26;
  int v27;
  double v28;
  int v29;
  double v30;
  int v31;
  double v32;
  int v33;
  double v34;
  int v35;
  double v36;
  int v37;
  double v38;
  int v39;
  double v40;
  int v41;
  double v42;
  int v43;
  double v44;
  int v45;
  double v46;
  int v47;
  double v48;
  int v49;
  double v50;

  v5 = *(_QWORD *)(a1 + 104);
  if (*(_DWORD *)(v5 + 16))
    v6 = "Extended";
  else
    v6 = "Standard";
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "Type:", v6);
  v7 = *(_DWORD *)(v5 + 20);
  v8 = (double)v7 * 0.0000152587891;
  if (v7 == 0x80000000)
    v8 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Direction Pad Up:", *(_QWORD *)&v8);
  v9 = *(_DWORD *)(v5 + 24);
  v10 = (double)v9 * 0.0000152587891;
  if (v9 == 0x80000000)
    v10 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Direction Pad Down:", *(_QWORD *)&v10);
  v11 = *(_DWORD *)(v5 + 28);
  v12 = (double)v11 * 0.0000152587891;
  if (v11 == 0x80000000)
    v12 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Direction Pad Left:", *(_QWORD *)&v12);
  v13 = *(_DWORD *)(v5 + 32);
  v14 = (double)v13 * 0.0000152587891;
  if (v13 == 0x80000000)
    v14 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Direction Pad Right:", *(_QWORD *)&v14);
  v15 = *(_DWORD *)(v5 + 36);
  v16 = (double)v15 * 0.0000152587891;
  if (v15 == 0x80000000)
    v16 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Face Button X:", *(_QWORD *)&v16);
  v17 = *(_DWORD *)(v5 + 40);
  v18 = (double)v17 * 0.0000152587891;
  if (v17 == 0x80000000)
    v18 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Face Button Y:", *(_QWORD *)&v18);
  v19 = *(_DWORD *)(v5 + 44);
  v20 = (double)v19 * 0.0000152587891;
  if (v19 == 0x80000000)
    v20 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Face Button A:", *(_QWORD *)&v20);
  v21 = *(_DWORD *)(v5 + 48);
  v22 = (double)v21 * 0.0000152587891;
  if (v21 == 0x80000000)
    v22 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Face Button B:", *(_QWORD *)&v22);
  v23 = *(_DWORD *)(v5 + 68);
  v24 = (double)v23 * 0.0000152587891;
  if (v23 == 0x80000000)
    v24 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Shoulder Button L1:", *(_QWORD *)&v24);
  v25 = *(_DWORD *)(v5 + 76);
  v26 = (double)v25 * 0.0000152587891;
  if (v25 == 0x80000000)
    v26 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Shoulder Button R1:", *(_QWORD *)&v26);
  v27 = *(_DWORD *)(v5 + 72);
  v28 = (double)v27 * 0.0000152587891;
  if (v27 == 0x80000000)
    v28 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Shoulder Button L2:", *(_QWORD *)&v28);
  v29 = *(_DWORD *)(v5 + 80);
  v30 = (double)v29 * 0.0000152587891;
  if (v29 == 0x80000000)
    v30 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Shoulder Button R2:", *(_QWORD *)&v30);
  v31 = *(_DWORD *)(v5 + 52);
  v32 = (double)v31 * 0.0000152587891;
  if (v31 == 0x80000000)
    v32 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Joystick Axis X:", *(_QWORD *)&v32);
  v33 = *(_DWORD *)(v5 + 56);
  v34 = (double)v33 * 0.0000152587891;
  if (v33 == 0x80000000)
    v34 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Joystick Axis Y:", *(_QWORD *)&v34);
  v35 = *(_DWORD *)(v5 + 60);
  v36 = (double)v35 * 0.0000152587891;
  if (v35 == 0x80000000)
    v36 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Joystick Axis Z:", *(_QWORD *)&v36);
  v37 = *(_DWORD *)(v5 + 64);
  v38 = (double)v37 * 0.0000152587891;
  if (v37 == 0x80000000)
    v38 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Joystick Axis Rz:", *(_QWORD *)&v38);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %d\n"), "Thumbstick Button Left:", *(_BYTE *)(v5 + 84) & 1);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %d\n"), "Thumbstick Button Right:", (*(unsigned __int8 *)(v5 + 84) >> 1) & 1);
  v39 = *(_DWORD *)(v5 + 88);
  v40 = (double)v39 * 0.0000152587891;
  if (v39 == 0x80000000)
    v40 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %f\n"), "Extra Button L4:", *(_QWORD *)&v40);
  v41 = *(_DWORD *)(v5 + 92);
  v42 = (double)v41 * 0.0000152587891;
  if (v41 == 0x80000000)
    v42 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %f\n"), "Extra Button R4:", *(_QWORD *)&v42);
  v43 = *(_DWORD *)(v5 + 96);
  v44 = (double)v43 * 0.0000152587891;
  if (v43 == 0x80000000)
    v44 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %f\n"), "Bottom Button M1:", *(_QWORD *)&v44);
  v45 = *(_DWORD *)(v5 + 100);
  v46 = (double)v45 * 0.0000152587891;
  if (v45 == 0x80000000)
    v46 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %f\n"), "Bottom Button M2:", *(_QWORD *)&v46);
  v47 = *(_DWORD *)(v5 + 104);
  v48 = (double)v47 * 0.0000152587891;
  if (v47 == 0x80000000)
    v48 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %f\n"), "Bottom Button M3:", *(_QWORD *)&v48);
  v49 = *(_DWORD *)(v5 + 108);
  v50 = (double)v49 * 0.0000152587891;
  if (v49 == 0x80000000)
    v50 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-25.25s %f\n"), "Bottom Button M4:", *(_QWORD *)&v50);
}

void __IOHIDEventTypeDescriptorHumidity(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;

  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_DWORD *)(v5 + 16);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "rh:", *(_QWORD *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Sequence:", *(unsigned int *)(v5 + 20));
}

void __IOHIDEventTypeDescriptorBrightness(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;
  double v7;
  int v8;
  double v9;

  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_DWORD *)(v5 + 16);
  v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000)
    v7 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "CurrentBrightness:", *(_QWORD *)&v7);
  v8 = *(_DWORD *)(v5 + 20);
  v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000)
    v9 = NAN;
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "TargetBrightness:", *(_QWORD *)&v9);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %qd\n"), "TransitionTime,us:", *(_QWORD *)(v5 + 24));
}

void __IOHIDEventTypeDescriptorGenericGesture(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  const char *v7;
  int v8;
  double v9;
  int v10;
  const char *v11;
  const char *v12;

  v5 = *(_QWORD *)(a1 + 104);
  switch(*(_DWORD *)(v5 + 16))
  {
    case 0:
      v7 = "Tap";
      goto LABEL_7;
    case 1:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "GestureType:", "Swipe");
      v8 = *(_DWORD *)(v5 + 20);
      v9 = (double)v8 * 0.0000152587891;
      if (v8 == 0x80000000)
        v9 = NAN;
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "Progress:", *(_QWORD *)&v9);
      return;
    case 2:
      v7 = "HandTap";
LABEL_7:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "GestureType:", v7);
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Count:", *(unsigned int *)(v5 + 20));
      return;
    case 4:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "GestureType:", "HandTapHold");
      v10 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8);
      if ((v10 & 0x1000000) != 0)
        goto LABEL_23;
      if (v10 < 0)
        goto LABEL_24;
      if ((v10 & 0x2000000) != 0)
        goto LABEL_25;
      if ((v10 & 0x4000000) == 0)
        goto LABEL_13;
      goto LABEL_19;
    case 5:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), "GestureType:", "Squeeze");
      v10 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8);
      if ((v10 & 0x1000000) != 0)
      {
LABEL_23:
        v11 = "Begin";
      }
      else if (v10 < 0)
      {
LABEL_24:
        v11 = "MayBegin";
      }
      else if ((v10 & 0x2000000) != 0)
      {
LABEL_25:
        v11 = "Changed";
      }
      else if ((v10 & 0x4000000) != 0)
      {
LABEL_19:
        v11 = "Ended";
      }
      else
      {
LABEL_13:
        if ((v10 & 0x8000000) == 0)
          return;
        v11 = "Cancelled";
      }
      v12 = "Phase:";
LABEL_27:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s\n"), v12, v11);
      return;
    case 6:
      v11 = "LongSqueeze";
      goto LABEL_22;
    case 7:
      v11 = "DoubleSqueeze";
LABEL_22:
      v12 = "GestureType:";
      goto LABEL_27;
    default:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %s (%d)\n"), "GestureType:", "Unknown", *(unsigned int *)(v5 + 16));
      return;
  }
}

void __IOHIDEventTypeDescriptorForceStageEvent(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  unint64_t v6;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Stage:", *(unsigned int *)(v5 + 16));
  v6 = *(char *)(v5 + 20);
  if (v6 <= 2)
    _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s\n"), (&off_1E2002858)[v6]);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NextThreshold:", *(_QWORD *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "PressedThreshold:", *(_QWORD *)(v5 + 32));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "ReleasedThreshold:", *(_QWORD *)(v5 + 40));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NormalizedForce:", *(_QWORD *)(v5 + 48));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NormalizedForceVelocity:", *(_QWORD *)(v5 + 56));
}

void __IOHIDEventTypeDescriptorTouchSensitiveButton(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5;
  int v6;

  v5 = *(_QWORD *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %dx\n"), "Usage:", *(unsigned __int16 *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "UsagePage:", *(unsigned __int16 *)(v5 + 18));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NormalizedPositionX:", *(_QWORD *)(v5 + 48));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NormalizedPositionDeltaX:", *(_QWORD *)(v5 + 56));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NormalizedPositionY:", *(_QWORD *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %f\n"), "NormalizedPositionDeltaY:", *(_QWORD *)(v5 + 32));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "Touch:", *(unsigned __int8 *)(v5 + 40));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s %d\n"), "EventMask:", *(unsigned int *)(v5 + 44));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("%-20.20s "), "Events:");
  v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 1) != 0)
  {
    _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("FastSwipe "));
    v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
LABEL_9:
      _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("LiftOffPredicted "));
      if ((*(_DWORD *)(v5 + 44) & 8) == 0)
        goto LABEL_6;
      goto LABEL_5;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("LowSNRSwipe "));
  v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) != 0)
    goto LABEL_9;
LABEL_4:
  if ((v6 & 8) != 0)
LABEL_5:
    _IOHIDStringAppendIndendationAndFormat(theString, 0, CFSTR("ClickDownPredicted "));
LABEL_6:
  _IOHIDStringAppendIndendationAndFormat(theString, a3, CFSTR("\n"));
}

uint64_t initrosetta_convert_to_rosetta_absolute_time_0(uint64_t a1)
{
  void *v2;
  uint64_t (*v3)();

  v2 = (void *)RosettaLibrary_libLibrary_0;
  if (!RosettaLibrary_libLibrary_0)
  {
    v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_0 = (uint64_t)v2;
  }
  v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_rosetta_absolute_time");
  dynLinkrosetta_convert_to_rosetta_absolute_time_0[0] = v3;
  if (v3)
    return ((uint64_t (*)(uint64_t))v3)(a1);
  else
    return a1;
}

uint64_t initrosetta_convert_to_system_absolute_time_0(uint64_t a1)
{
  void *v2;
  uint64_t (*v3)();

  v2 = (void *)RosettaLibrary_libLibrary_0;
  if (!RosettaLibrary_libLibrary_0)
  {
    v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_0 = (uint64_t)v2;
  }
  v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_system_absolute_time");
  dynLinkrosetta_convert_to_system_absolute_time_0[0] = v3;
  if (v3)
    return ((uint64_t (*)(uint64_t))v3)(a1);
  else
    return a1;
}

uint64_t IOHIDConnectionFilterGetTypeID()
{
  uint64_t result;

  result = __kIOHIDConnectionFilterTypeID;
  if (!__kIOHIDConnectionFilterTypeID)
  {
    pthread_once(&__connectionFilterClientTypeInit, (void (*)(void))__IOHIDConnectionFilterRegister);
    return __kIOHIDConnectionFilterTypeID;
  }
  return result;
}

uint64_t __IOHIDConnectionFilterRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDConnectionFilterTypeID = result;
  return result;
}

id IOHIDConnectionFilterFilterEvent(uint64_t a1, uint64_t a2)
{
  void *v3;
  const char *v5;

  v3 = *(void **)(a1 + 16);
  if (v3 && (v5 = *(const char **)(a1 + 72)) != 0)
    return objc_msgSend(v3, v5, a2);
  else
    return 0;
}

id IOHIDConnectionFilterCopyProperty(uint64_t a1, uint64_t a2)
{
  void *v3;
  const char *v5;
  id v6;
  id v7;

  v3 = *(void **)(a1 + 16);
  if (!v3)
    return 0;
  v5 = *(const char **)(a1 + 24);
  if (!v5)
    return 0;
  v6 = objc_msgSend(v3, v5, a2);
  v7 = v6;
  if (v6)
    CFRetain(v6);
  return v7;
}

id IOHIDConnectionFilterSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  const char *v6;

  v4 = *(void **)(a1 + 16);
  if (v4 && (v6 = *(const char **)(a1 + 32)) != 0)
    return objc_msgSend(v4, v6, a3, a2);
  else
    return 0;
}

id IOHIDConnectionFilterActivate(uint64_t a1)
{
  id result;
  const char *v3;

  result = *(id *)(a1 + 16);
  if (result)
  {
    v3 = *(const char **)(a1 + 48);
    if (v3)
      return objc_msgSend(result, v3);
  }
  return result;
}

id IOHIDConnectionFilterCancel(uint64_t a1)
{
  id result;
  const char *v3;

  result = *(id *)(a1 + 16);
  if (result)
  {
    v3 = *(const char **)(a1 + 56);
    if (v3)
      return objc_msgSend(result, v3);
  }
  return result;
}

id IOHIDConnectionFilterSetDispatchQueue(uint64_t a1, uint64_t a2)
{
  id result;
  const char *v5;

  result = *(id *)(a1 + 16);
  if (result)
  {
    v5 = *(const char **)(a1 + 64);
    if (v5)
      return objc_msgSend(result, v5, a2);
  }
  return result;
}

id IOHIDConnectionFilterSetCancelHandler(uint64_t a1, uint64_t a2)
{
  id result;
  const char *v5;

  result = *(id *)(a1 + 16);
  if (result)
  {
    v5 = *(const char **)(a1 + 40);
    if (v5)
      return objc_msgSend(result, v5, a2);
  }
  return result;
}

CFStringRef __IOHIDConnectionFilterCopyDebugDescription(_QWORD *a1)
{
  const void *v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  CFStringRef v6;

  v2 = (const void *)a1[2];
  if (v2)
    v3 = CFCopyDescription(v2);
  else
    v3 = 0;
  v4 = CFGetAllocator(a1);
  v5 = &stru_1E2005170;
  if (v3)
    v5 = v3;
  v6 = CFStringCreateWithFormat(v4, 0, CFSTR("<IOHIDConnectionFilterRef:%@>"), v5);
  if (v3)
    CFRelease(v3);
  return v6;
}

__CFDictionary *__IOAVClassMatching(uint64_t a1, __CFString *a2, unsigned int a3, int a4)
{
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  const char *v11;
  CFStringRef v12;
  CFStringRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFRange v16;
  __CFDictionary *v17;
  __CFDictionary *v18;
  CFMutableDictionaryRef v19;
  CFStringRef v20;
  __CFDictionary *v21;
  __CFDictionary *v22;
  int valuePtr;

  valuePtr = a4;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v10 = Mutable;
  if (a3 <= 1)
  {
    v11 = IOAVLocationString(a3);
    v12 = CFStringCreateWithCString(v8, v11, 0x8000100u);
    if (!v12)
      goto LABEL_21;
    v13 = v12;
    CFDictionarySetValue(v10, CFSTR("Location"), v12);
    CFRelease(v13);
  }
  if (a4 != -1)
  {
    v14 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
    if (!v14)
      goto LABEL_21;
    v15 = v14;
    CFDictionarySetValue(v10, CFSTR("Unit"), v14);
    CFRelease(v15);
  }
  if (!a2)
    goto LABEL_15;
  v16 = CFStringFind(a2, CFSTR(":"), 0);
  if (v16.location == -1 || v16.location + v16.length >= CFStringGetLength(a2))
  {
    a2 = (__CFString *)CFStringCreateWithFormat(v8, 0, CFSTR("%s:%@"), "IODeviceTree", a2);
    if (a2)
      goto LABEL_13;
LABEL_21:
    v22 = 0;
    goto LABEL_19;
  }
  CFRetain(a2);
LABEL_13:
  v17 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v17)
  {
LABEL_22:
    v21 = v10;
    v10 = 0;
    goto LABEL_18;
  }
  v18 = v17;
  CFDictionarySetValue(v17, CFSTR("IOPathMatch"), a2);
  CFRelease(a2);
  CFDictionarySetValue(v10, CFSTR("IOParentMatch"), v18);
  CFRelease(v18);
LABEL_15:
  v19 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v19)
    goto LABEL_21;
  a2 = (__CFString *)v19;
  v20 = CFStringCreateWithFormat(v8, 0, CFSTR("%s%s"), a1, "UserInterfaceSupported");
  if (!v20)
    goto LABEL_22;
  v21 = (__CFDictionary *)v20;
  CFDictionarySetValue((CFMutableDictionaryRef)a2, v20, (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionarySetValue(v10, CFSTR("IOPropertyMatch"), a2);
LABEL_18:
  v22 = v10;
  CFRelease(a2);
  v10 = v21;
LABEL_19:
  CFRelease(v10);
  return v22;
}

uint64_t __IOAVCopyFirstMatchingIOAVObjectOfType(uint64_t a1, uint64_t (*a2)(_QWORD, uint64_t), __CFString *a3, unsigned int a4, int a5)
{
  __CFDictionary *v6;
  uint64_t MatchingService;
  io_object_t v8;
  uint64_t v9;

  v6 = __IOAVClassMatching(a1, a3, a4, a5);
  MatchingService = IOServiceGetMatchingService(0, v6);
  if (!(_DWORD)MatchingService)
    return 0;
  v8 = MatchingService;
  v9 = a2(*MEMORY[0x1E0C9AE00], MatchingService);
  IOObjectRelease(v8);
  return v9;
}

uint64_t IOHIDEventSystemGetTypeID()
{
  uint64_t result;

  result = __kIOHIDEventSystemTypeID;
  if (!__kIOHIDEventSystemTypeID)
  {
    pthread_once(&__systemTypeInit, (void (*)(void))__IOHIDEventSystemRegister);
    return __kIOHIDEventSystemTypeID;
  }
  return result;
}

uint64_t __IOHIDEventSystemRegister()
{
  unint64_t v0;
  unint64_t v1;
  uint64_t result;
  pthread_attr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  kIOHIDServiceInterruptWorkloop = (uint64_t)hid_workloop_create("IOHIDEvent Interrupt - Root", 63);
  kIOHIDServiceEnumerationWorkloop = (uint64_t)hid_workloop_create("IOHIDService Enumeration - Root", 63);
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    memset(&v3, 0, sizeof(v3));
    if (hid_pthread_attr_init(&v3, 63, 2))
      __IOHIDEventSystemRegister_cold_2();
    kIOHIDServerConnectionRootQueue = hid_dispatch_pthread_root_queue_create();
    if (!kIOHIDServerConnectionRootQueue)
      __IOHIDEventSystemRegister_cold_1();
    pthread_attr_destroy(&v3);
  }
  v3.__sig = 0;
  mach_timebase_info((mach_timebase_info_t)&v3);
  LODWORD(v1) = HIDWORD(v3.__sig);
  LODWORD(v0) = v3.__sig;
  *(double *)&__absoluteTime_to_nanoseconds_factor = 1.0 / ((double)v0 / (double)v1);
  _IOHIDLoadBundles();
  result = _CFRuntimeRegisterClass();
  __kIOHIDEventSystemTypeID = result;
  return result;
}

uint64_t IOHIDEventSystemCreate(const __CFAllocator *a1)
{
  uint64_t v2;
  NSObject *v3;
  CFPropertyListRef v4;
  const void *v5;
  mach_port_t v6;
  _OWORD *Instance;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v12;
  const __CFAllocator *v13;
  CFMutableDictionaryRef v14;
  CFMutableSetRef v15;
  CFMutableSetRef v16;
  CFMutableSetRef v17;
  CFMutableSetRef v18;
  CFMutableSetRef v19;
  CFMutableArrayRef v20;
  CFMutableSetRef v21;
  CFMutableSetRef v22;
  HIDSession *v23;
  _QWORD *v24;
  __CFDictionary *v25;
  CFDictionaryRef v26;
  IONotificationPort *v27;
  IONotificationPort *v28;
  NSObject *v29;
  NSObject *v30;
  dispatch_time_t v31;
  uint64_t v32;
  ipc_space_t *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  NSObject *v49;
  const char *v50;
  NSObject *v51;
  CFSetCallBacks v52;
  void *keys;
  uint8_t buf[4];
  unint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  keys = 0;
  v2 = mach_absolute_time();
  _IOHIDDebugTrace(8275, 1, 0, 0, 0, 0);
  v3 = _IOHIDLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v3, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemCreate", (const char *)&unk_18AB567C9, buf, 2u);
  }
  v4 = IOHIDPreferencesCopyDomain(CFSTR("allocator"), CFSTR("com.apple.iohid"));
  if (v4)
  {
    v5 = v4;
    if (CFEqual(v4, CFSTR("default")))
      a1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    CFRelease(v5);
  }
  v6 = *MEMORY[0x1E0C81720];
  *(_DWORD *)buf = 0;
  if (!bootstrap_look_up2())
  {
    v33 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)buf);
    if (bootstrap_check_in(v6, "com.apple.iohideventsystem", (mach_port_t *)buf))
    {
      v34 = _IOHIDLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v55) = 0;
        _os_log_impl(&dword_18AAAF000, v34, OS_LOG_TYPE_DEFAULT, "__bootstrap_status:0x%x", buf, 8u);
      }
      v8 = 0;
      goto LABEL_36;
    }
    mach_port_mod_refs(*v33, *(mach_port_name_t *)buf, 1u, -1);
  }
  if (!__kIOHIDEventSystemTypeID)
    pthread_once(&__systemTypeInit, (void (*)(void))__IOHIDEventSystemRegister);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v8 = (uint64_t)Instance;
  if (!Instance)
    goto LABEL_36;
  Instance[1] = 0u;
  Instance[26] = 0u;
  Instance[27] = 0u;
  Instance[24] = 0u;
  Instance[25] = 0u;
  Instance[22] = 0u;
  Instance[23] = 0u;
  Instance[20] = 0u;
  Instance[21] = 0u;
  Instance[18] = 0u;
  Instance[19] = 0u;
  Instance[16] = 0u;
  Instance[17] = 0u;
  Instance[14] = 0u;
  Instance[15] = 0u;
  Instance[12] = 0u;
  Instance[13] = 0u;
  Instance[10] = 0u;
  Instance[11] = 0u;
  Instance[8] = 0u;
  Instance[9] = 0u;
  Instance[6] = 0u;
  Instance[7] = 0u;
  Instance[4] = 0u;
  Instance[5] = 0u;
  Instance[2] = 0u;
  Instance[3] = 0u;
  *((_QWORD *)Instance + 20) = 0;
  v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v10 = hid_dispatch_queue_create("HID - IOService Enumeration", v9, kIOHIDServiceEnumerationWorkloop, (uint64_t)__IOHIDSystemEnumerationQueueWillExecute, (uint64_t)__IOHIDSystemEnumerationQueueDidExecute, v8);
  *(_QWORD *)(v8 + 144) = v10;
  if (!v10)
    goto LABEL_36;
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v8 + 16) = Mutable;
  if (!Mutable)
    goto LABEL_36;
  v12 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v8 + 24) = v12;
  if (!v12)
    goto LABEL_36;
  v13 = CFGetAllocator((CFTypeRef)v8);
  v14 = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v8 + 176) = v14;
  if (!v14)
    goto LABEL_36;
  v52 = *(CFSetCallBacks *)byte_1E2002870;
  v15 = CFSetCreateMutable(a1, 0, &v52);
  *(_QWORD *)(v8 + 40) = v15;
  if (!v15)
    goto LABEL_36;
  v16 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v8 + 48) = v16;
  if (!v16)
    goto LABEL_36;
  v17 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v8 + 56) = v17;
  if (!v17)
    goto LABEL_36;
  v18 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v8 + 64) = v18;
  if (!v18)
    goto LABEL_36;
  v19 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v8 + 72) = v19;
  if (!v19)
    goto LABEL_36;
  v20 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v8 + 80) = v20;
  if (!v20)
    goto LABEL_36;
  v21 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v8 + 424) = v21;
  if (!v21)
    goto LABEL_36;
  v22 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  *(_QWORD *)(v8 + 432) = v22;
  if (!v22)
    goto LABEL_36;
  v23 = IOHIDSessionCreate(a1);
  *(_QWORD *)(v8 + 128) = v23;
  if (!v23)
  {
    v49 = _IOHIDLog();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v50 = "IOHIDSessionCreate";
LABEL_60:
      _os_log_impl(&dword_18AAAF000, v49, OS_LOG_TYPE_DEFAULT, v50, buf, 2u);
    }
LABEL_36:
    v32 = 0;
    v26 = 0;
    v25 = 0;
    goto LABEL_37;
  }
  v24 = IOHIDEventServerCreate((uint64_t)a1, v8);
  *(_QWORD *)(v8 + 152) = v24;
  if (!v24)
  {
    v49 = _IOHIDLog();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v50 = "IOHIDEventServerCreate";
      goto LABEL_60;
    }
    goto LABEL_36;
  }
  __IOHIDEventSystem_debug = v8;
  v25 = IOServiceMatching("IOService");
  if (!v25)
  {
    v32 = 0;
    v26 = 0;
    goto LABEL_37;
  }
  keys = CFSTR("HIDServiceSupport");
  v26 = CFDictionaryCreate(a1, (const void **)&keys, MEMORY[0x1E0C9AE50], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v26)
    goto LABEL_65;
  CFDictionarySetValue(v25, CFSTR("IOPropertyMatch"), v26);
  v27 = IONotificationPortCreate(0);
  if (!v27)
  {
LABEL_63:
    *(_QWORD *)(v8 + 96) = 0;
    v51 = _IOHIDLog();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18AAAF000, v51, OS_LOG_TYPE_DEFAULT, "__IOHIDEventSystemCreateNotification", buf, 2u);
    }
LABEL_65:
    v32 = 0;
    goto LABEL_37;
  }
  v28 = v27;
  IONotificationPortSetDispatchQueue(v27, *(dispatch_queue_t *)(v8 + 144));
  CFRetain(v25);
  if (IOServiceAddMatchingNotification(v28, "IOServiceFirstMatch", v25, (IOServiceMatchingCallback)__IOHIDEventSystemServicePublished, (void *)v8, (io_iterator_t *)(v8 + 168)))
  {
    IONotificationPortDestroy(v28);
    goto LABEL_63;
  }
  __IOHIDEventSystemServicePublished((_QWORD *)v8, *(_DWORD *)(v8 + 168));
  *(_QWORD *)(v8 + 96) = v28;
  v29 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v8 + 144));
  *(_QWORD *)(v8 + 440) = v29;
  if (v29)
  {
    dispatch_source_set_event_handler(v29, &__block_literal_global_8);
    v30 = *(NSObject **)(v8 + 440);
    v31 = dispatch_time(0, 300000000000);
    dispatch_source_set_timer(v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(*(dispatch_object_t *)(v8 + 440));
  }
  CFRetain((CFTypeRef)v8);
  v32 = v8;
LABEL_37:
  v35 = _IOHIDLog();
  if (os_signpost_enabled(v35))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v35, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemCreate", (const char *)&unk_18AB567C9, buf, 2u);
  }
  if (v26)
    CFRelease(v26);
  if (v25)
    CFRelease(v25);
  if (v8)
    CFRelease((CFTypeRef)v8);
  _IOHIDDebugTrace(8275, 2, 0, 0, 0, 0);
  __eventSytemAnalyticsEvent = IOHIDAnalyticsEventCreate((uint64_t)CFSTR("com.apple.hid.analytics.event-system"), 0);
  if (__eventSytemAnalyticsEvent)
  {
    IOHIDAnalyticsEventAddField();
    IOHIDAnalyticsEventAddField();
    IOHIDAnalyticsEventActivate();
  }
  v36 = _IOHIDLog();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    v37 = mach_absolute_time();
    v38 = _IOHIDGetTimestampDelta(v37, v2, 0x3E8u);
    *(_DWORD *)buf = 134217984;
    v55 = v38;
    _os_log_impl(&dword_18AAAF000, v36, OS_LOG_TYPE_DEFAULT, "IOHIDEventSystemCreate:%lldus", buf, 0xCu);
  }
  v39 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v39, v2, 0x3E8u);
  if (__eventSytemAnalyticsEvent)
    IOHIDAnalyticsEventSetIntegerValueForField();
  if (!v32)
  {
    v40 = _IOHIDLog();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
      IOHIDEventSystemCreate_cold_1(v40, v41, v42, v43, v44, v45, v46, v47);
  }
  return v32;
}

void __IOHIDEventSystemServicePublished(_QWORD *a1, io_iterator_t iterator)
{
  io_object_t v4;
  io_registry_entry_t v5;
  __CFArray *Mutable;
  const CFArrayCallBacks *v7;
  CFAllocatorRef v8;
  HIDEventService *v9;
  HIDEventService *v10;
  const __CFAllocator *v11;
  NSObject *v12;
  dispatch_time_t v13;
  NSObject *v14;
  NSObject *v15;
  uint8_t v16[16];
  uint8_t buf[16];

  v4 = IOIteratorNext(iterator);
  if (v4)
  {
    v5 = v4;
    Mutable = 0;
    v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    do
    {
      v8 = CFGetAllocator(a1);
      v9 = _IOHIDServiceCreate((uint64_t)v8, v5);
      if (v9)
      {
        v10 = v9;
        if (Mutable || (v11 = CFGetAllocator(a1), (Mutable = CFArrayCreateMutable(v11, 0, v7)) != 0))
        {
          CFArrayAppendValue(Mutable, v10);
          if (a1[55])
          {
            if (!_IOHIDPlugInInstanceCacheIsEmpty())
            {
              v12 = a1[55];
              v13 = dispatch_time(0, 300000000000);
              dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0);
            }
          }
        }
        CFRelease(v10);
      }
      IOObjectRelease(v5);
      v5 = IOIteratorNext(iterator);
    }
    while (v5);
    if (Mutable)
    {
      v14 = _IOHIDLog();
      if (os_signpost_enabled(v14))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_18AAAF000, v14, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddServices", (const char *)&unk_18AB567C9, buf, 2u);
      }
      __IOHIDEventSystemAddServices((uint64_t)a1, Mutable);
      v15 = _IOHIDLog();
      if (os_signpost_enabled(v15))
      {
        *(_WORD *)v16 = 0;
        _os_signpost_emit_with_name_impl(&dword_18AAAF000, v15, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddServices", (const char *)&unk_18AB567C9, v16, 2u);
      }
      CFRelease(Mutable);
    }
  }
}

uint64_t IOHIDEventSystemOpen(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v28;
  int v29;
  unint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = mach_absolute_time();
  _IOHIDDebugTrace(8276, 1, 0, 0, 0, 0);
  v9 = _IOHIDLog();
  if (os_signpost_enabled(v9))
  {
    LOWORD(v29) = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v9, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemOpen", (const char *)&unk_18AB567C9, (uint8_t *)&v29, 2u);
  }
  v10 = a1[19];
  v11 = IOHIDSessionOpen(a1[16], a1, (uint64_t)__IOHIDEventSystemEventCallback, 0);
  if ((_DWORD)v11)
  {
    v12 = a1[17];
    if (v12
      || (v13 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM),
          v12 = hid_dispatch_queue_create("IOHIDEventServer", v13, 0, 0, 0, 0),
          (a1[17] = v12) != 0))
    {
      IOHIDEventServerScheduleWithDispatchQueue(v10, v12);
    }
    else
    {
      v28 = _IOHIDLog();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        IOHIDEventSystemOpen_cold_2(v28);
    }
    os_unfair_recursive_lock_lock_with_options();
    a1[13] = a3;
    a1[14] = a2;
    a1[15] = a4;
    os_unfair_recursive_lock_unlock();
  }
  v14 = _IOHIDLog();
  if (os_signpost_enabled(v14))
  {
    LOWORD(v29) = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v14, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemOpen", (const char *)&unk_18AB567C9, (uint8_t *)&v29, 2u);
  }
  _IOHIDDebugTrace(8276, 2, 0, 0, 0, 0);
  v15 = _IOHIDLog();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = mach_absolute_time();
    v17 = _IOHIDGetTimestampDelta(v16, v8, 0x3E8u);
    v29 = 134217984;
    v30 = v17;
    _os_log_impl(&dword_18AAAF000, v15, OS_LOG_TYPE_DEFAULT, "IOHIDEventSystemOpen:%lldus", (uint8_t *)&v29, 0xCu);
  }
  v18 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v18, v8, 0x3E8u);
  if (__eventSytemAnalyticsEvent)
    IOHIDAnalyticsEventSetIntegerValueForField();
  if (!(_DWORD)v11)
  {
    v19 = _IOHIDLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      IOHIDEventSystemOpen_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
  }
  return v11;
}

uint64_t IOHIDEventSystemSetCallback(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[13] = a3;
  a1[14] = a2;
  a1[15] = a4;
  return os_unfair_recursive_lock_unlock();
}

_QWORD *IOHIDEventSystemRegisterPropertyChangedNotification(_QWORD *result, CFTypeRef cf, void *aBlock)
{
  _QWORD *v4;

  v4 = result;
  if (!result[4])
  {
    result[4] = cf;
    result = CFRetain(cf);
  }
  if (!v4[11])
  {
    if (aBlock)
      result = _Block_copy(aBlock);
    else
      result = 0;
    v4[11] = result;
  }
  return result;
}

void IOHIDEventSystemUnregisterPropertyChangedNotification(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(const void **)(a1 + 88);
  if (v3)
  {
    _Block_release(v3);
    *(_QWORD *)(a1 + 88) = 0;
  }
}

void IOHIDEventSystemClose(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  _QWORD v11[5];
  _QWORD block[5];
  uint8_t buf[16];

  v2 = *(_QWORD *)(a1 + 152);
  v4 = *(_QWORD *)(a1 + 128);
  v3 = *(NSObject **)(a1 + 136);
  v5 = _IOHIDLog();
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v5, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemClose", (const char *)&unk_18AB567C9, buf, 2u);
  }
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 96), 0);
  IOHIDEventServerUnscheduleFromDispatchQueue(v2, (uint64_t)v3);
  IOHIDSessionClose(v4, (const void *)a1);
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  os_unfair_recursive_lock_unlock();
  v6 = _IOHIDLog();
  if (os_signpost_enabled(v6))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v6, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystem - service queue termination", (const char *)&unk_18AB567C9, buf, 2u);
  }
  CFRetain((CFTypeRef)a1);
  v7 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOHIDEventSystemClose_block_invoke;
  block[3] = &__block_descriptor_tmp_15;
  block[4] = a1;
  dispatch_async(v3, block);
  v8 = _IOHIDLog();
  if (os_signpost_enabled(v8))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystem - enumeration queue termination", (const char *)&unk_18AB567C9, buf, 2u);
  }
  CFRetain((CFTypeRef)a1);
  v9 = *(NSObject **)(a1 + 144);
  v11[0] = v7;
  v11[1] = 0x40000000;
  v11[2] = __IOHIDEventSystemClose_block_invoke_16;
  v11[3] = &__block_descriptor_tmp_17_0;
  v11[4] = a1;
  dispatch_async(v9, v11);
  v10 = _IOHIDLog();
  if (os_signpost_enabled(v10))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v10, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemClose", (const char *)&unk_18AB567C9, buf, 2u);
  }
}

uint64_t IOHIDEventSystemSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  return _IOHIDEventSystemSetPropertyForConnection(a1, a2, a3, (const void *)*MEMORY[0x1E0C9B0D0]);
}

__CFArray *IOHIDEventSystemGetProperty(uint64_t a1, const void *a2)
{
  return _IOHIDEventSystemCopyPropertyForConnection(a1, a2, (_QWORD *)*MEMORY[0x1E0C9B0D0]);
}

uint64_t IOHIDEventSystemCopyEvent(uint64_t a1, int a2, uint64_t a3, int a4)
{
  return IOHIDSessionCopyEvent(*(_QWORD *)(a1 + 128), a2, a3, a4);
}

CFArrayRef IOHIDEventSystemCopyConnections(CFSetRef *a1, int a2)
{
  CFSetRef *v4;
  const __CFSet *v5;
  CFIndex Count;
  const void **v7;
  const void **v8;
  const __CFAllocator *v9;
  CFArrayRef v10;

  os_unfair_recursive_lock_lock_with_options();
  if (a2 == 2)
  {
    v4 = a1 + 9;
  }
  else if (a2 == 1)
  {
    v4 = a1 + 8;
  }
  else
  {
    if (a2)
    {
LABEL_10:
      v10 = 0;
      goto LABEL_11;
    }
    v4 = a1 + 7;
  }
  v5 = *v4;
  if (!*v4)
    goto LABEL_10;
  Count = CFSetGetCount(*v4);
  v7 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  if (!v7)
    goto LABEL_10;
  v8 = v7;
  bzero(v7, 8 * Count);
  CFSetGetValues(v5, v8);
  v9 = CFGetAllocator(a1);
  v10 = CFArrayCreate(v9, v8, Count, MEMORY[0x1E0C9B378]);
  free(v8);
LABEL_11:
  os_unfair_recursive_lock_unlock();
  return v10;
}

uint64_t IOHIDEventSystemRegisterConnectionAdditionCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;

  os_unfair_recursive_lock_lock_with_options();
  v10 = (_QWORD *)(a1 + 24 * a2);
  v10[23] = a4;
  v10[24] = a3;
  v10[25] = a5;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemUnregisterConnectionAdditionCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;

  os_unfair_recursive_lock_lock_with_options();
  v10 = (_QWORD *)(a1 + 184 + 24 * a2);
  if (v10[1] == a3 && *v10 == a4 && *(_QWORD *)(a1 + 184 + 24 * a2 + 16) == a5)
  {
    *v10 = 0;
    v10[1] = 0;
    v10[2] = 0;
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemRegisterConnectionRemovalCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;

  os_unfair_recursive_lock_lock_with_options();
  v10 = (_QWORD *)(a1 + 24 * a2);
  v10[38] = a4;
  v10[39] = a3;
  v10[40] = a5;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemUnregisterConnectionRemovalCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  _QWORD *v11;

  os_unfair_recursive_lock_lock_with_options();
  v10 = a1 + 24 * a2;
  if (*(_QWORD *)(v10 + 312) == a3)
  {
    v11 = (_QWORD *)(v10 + 304);
    if (*v11 == a4 && *(_QWORD *)(a1 + 24 * a2 + 320) == a5)
    {
      *v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
    }
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemCopyServices(CFDictionaryRef *a1, const __CFDictionary *a2)
{
  uint64_t v3;

  v3 = 0;
  __IOHIDEventSystemCopyMatchingServices(a1, a2, 0, 0, 0, 0, &v3);
  return v3;
}

void IOHIDEventSystemRegisterServicesCallback(CFDictionaryRef *a1, const __CFDictionary *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  const __CFAllocator *v10;
  CFStringRef v11;
  CFStringRef v12;
  void *value;

  value = 0;
  __IOHIDEventSystemCopyMatchingServices(a1, a2, a3, a4, a5, &value, 0);
  if (value)
  {
    v10 = CFGetAllocator(a1);
    v11 = CFStringCreateWithFormat(v10, 0, CFSTR("%p%p%p%p"), a2, a3, a4, a5);
    if (v11)
    {
      v12 = v11;
      os_unfair_recursive_lock_lock_with_options();
      CFDictionarySetValue(a1[22], v12, value);
      os_unfair_recursive_lock_unlock();
      CFRelease(v12);
    }
    CFRelease(value);
  }
}

void IOHIDEventSystemUnregisterServicesCallback(CFMutableDictionaryRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const __CFAllocator *v10;
  CFStringRef v11;
  CFStringRef v12;

  v10 = CFGetAllocator(a1);
  v11 = CFStringCreateWithFormat(v10, 0, CFSTR("%p%p%p%p"), a2, a3, a4, a5);
  if (v11)
  {
    v12 = v11;
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryRemoveValue(a1[22], v12);
    os_unfair_recursive_lock_unlock();
    CFRelease(v12);
  }
}

void _IOHIDEventSystemRegisterEventFilter(uint64_t a1, void *a2)
{
  const __CFArray *v4;
  const __CFSet *v5;
  const __CFSet *v6;
  CFRange v7;

  _IOHIDEventSystemUnregisterEventFilter(a1, a2);
  os_unfair_recursive_lock_lock_with_options();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), a2);
  v4 = *(const __CFArray **)(a1 + 80);
  v7.length = CFArrayGetCount(v4);
  v7.location = 0;
  CFArraySortValues(v4, v7, (CFComparatorFunction)_IOHIDEventSystemConnectionEventFilterCompare, 0);
  os_unfair_recursive_lock_unlock();
  v5 = _IOHIDEventSystemConnectionCopyServices((CFSetRef *)a2);
  if (v5)
  {
    v6 = v5;
    CFSetApplyFunction(v5, (CFSetApplierFunction)__IOHIDEventSystemFilterEventServiceRegister, a2);
    CFRelease(v6);
  }
}

uint64_t __IOHIDEventSystemFilterEventServiceRegister(uint64_t a1, const void *a2)
{
  return _IOHIDServiceAddConnection(a1, a2, 1);
}

void __CopyRecordForCientFunction(uint64_t a1, _DWORD *a2, __CFArray *a3)
{
  __CFDictionary *v4;
  __CFDictionary *v5;

  v4 = _IOHIDServiceCopyServiceInfoForClient(a2, (const void *)*MEMORY[0x1E0C9B0D0]);
  if (v4)
  {
    v5 = v4;
    CFArrayAppendValue(a3, v4);
    CFRelease(v5);
  }
}

__CFDictionary *_IOHIDEventSystemCopyRecord(CFTypeRef *a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  const __CFAllocator *v7;
  CFMutableArrayRef v8;
  CFMutableArrayRef v9;
  const __CFAllocator *v10;
  const __CFDictionary *Copy;
  int valuePtr;

  v2 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    valuePtr = 0;
    v4 = CFGetAllocator(a1);
    v5 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
    if (v5)
    {
      v6 = v5;
      CFDictionarySetValue(Mutable, CFSTR("Type"), v5);
      CFRelease(v6);
      v7 = CFGetAllocator(a1);
      v8 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
      if (v8)
      {
        v9 = v8;
        CFDictionarySetValue(Mutable, CFSTR("Services"), v8);
        os_unfair_recursive_lock_lock_with_options();
        v10 = CFGetAllocator(a1[2]);
        Copy = CFDictionaryCreateCopy(v10, (CFDictionaryRef)a1[2]);
        os_unfair_recursive_lock_unlock();
        if (Copy)
        {
          CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__CopyRecordForCientFunction, v9);
          CFRelease(Copy);
        }
        CFRelease(v9);
      }
    }
  }
  return Mutable;
}

void _IOHIDEventSystemDispatchEvent(uint64_t a1, const void *a2)
{
  _IOHIDSessionDispatchEvent(*(_QWORD *)(a1 + 128), a2);
}

void _IOHIDEventSystemRemoveService(uint64_t a1, _QWORD *a2)
{
  _IOHIDServiceTerminate(a2);
}

uint64_t _IOHIDEventSystemRegisterRecordClientChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 424), a2);
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemUnregisterRecordClientChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 424), a2);
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemRegisterRecordServiceChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 432), a2);
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemUnregisterRecordServiceChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 432), a2);
  return os_unfair_recursive_lock_unlock();
}

void __GDBIOHIDEventSystemDump()
{
  const __CFString *v0;
  NSObject *v1;
  int v2;
  const char *CStringPtr;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v0 = CFCopyDescription((CFTypeRef)__IOHIDEventSystem_debug);
  v1 = _IOHIDLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    v2 = 136315138;
    CStringPtr = CFStringGetCStringPtr(v0, 0);
    _os_log_impl(&dword_18AAAF000, v1, OS_LOG_TYPE_INFO, "event system =\n%s", (uint8_t *)&v2, 0xCu);
  }
  CFRelease(v0);
}

uint64_t _IOHIDEventSystemGetSession(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128);
}

void __IOHIDEventSystemRelease(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  IONotificationPort *v16;
  io_object_t v17;
  const void *v18;
  const void *v19;
  NSObject *v20;
  NSObject *v21;
  const void *v22;
  const void *v23;
  uint8_t v24[16];
  uint8_t buf[16];

  v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18AAAF000, v2, OS_LOG_TYPE_DEFAULT, "__IOHIDEventSystemRelease", buf, 2u);
  }
  v3 = _IOHIDLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)v24 = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v3, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemRelease", (const char *)&unk_18AB567C9, v24, 2u);
  }
  if (__IOHIDEventSystem_debug == a1)
    __IOHIDEventSystem_debug = 0;
  v4 = *(NSObject **)(a1 + 440);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(a1 + 440));
  }
  v5 = *(const void **)(a1 + 128);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v6 = *(const void **)(a1 + 152);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v7 = *(const void **)(a1 + 424);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 424) = 0;
  }
  v8 = *(const void **)(a1 + 432);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 432) = 0;
  }
  v9 = *(const void **)(a1 + 32);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v10 = *(const void **)(a1 + 88);
  if (v10)
    _Block_release(v10);
  v11 = *(const void **)(a1 + 48);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v12 = *(const void **)(a1 + 56);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v13 = *(const void **)(a1 + 64);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v14 = *(const void **)(a1 + 72);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v15 = *(const void **)(a1 + 24);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v16 = *(IONotificationPort **)(a1 + 96);
  if (v16)
    IONotificationPortDestroy(v16);
  v17 = *(_DWORD *)(a1 + 168);
  if (v17)
    IOObjectRelease(v17);
  v18 = *(const void **)(a1 + 80);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v19 = *(const void **)(a1 + 176);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v20 = *(NSObject **)(a1 + 136);
  if (v20)
    hid_dispatch_queue_release(v20);
  v21 = *(NSObject **)(a1 + 144);
  if (v21)
    hid_dispatch_queue_release(v21);
  v22 = *(const void **)(a1 + 40);
  if (v22)
  {
    CFRelease(v22);
    *(_QWORD *)(a1 + 40) = 0;
  }
  if (__eventSytemAnalyticsEvent)
  {
    IOHIDAnalyticsEventCancel();
    CFRelease((CFTypeRef)__eventSytemAnalyticsEvent);
    __eventSytemAnalyticsEvent = 0;
  }
  v23 = *(const void **)(a1 + 16);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFStringRef __IOHIDEventSystemCopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;
  CFStringRef v4;

  os_unfair_recursive_lock_lock_with_options();
  v2 = CFGetAllocator(a1);
  v3 = CFGetAllocator(a1);
  v4 = CFStringCreateWithFormat(v2, 0, CFSTR("<IOHIDEventSystem %p [%p]>{\n\tserviceDict=%@ \n\tnotificationDict=%@ \n\tmatchNotifySet=%@ \n\tclientSet=%@}"), a1, v3, a1[2], a1[3], a1[5], a1[6]);
  os_unfair_recursive_lock_unlock();
  return v4;
}

uint64_t __IOHIDEventSystemFilterEventFunction(mach_port_t *cf, uint64_t *a2)
{
  _DWORD *v3;
  uint64_t result;

  v3 = (_DWORD *)a2[2];
  result = *v3;
  if (!(_DWORD)result)
  {
    result = _IOHIDEventSystemConnectionFilterEvent(cf, *a2, a2[1]);
    v3 = (_DWORD *)a2[2];
  }
  *v3 = result;
  return result;
}

void OUTLINED_FUNCTION_0_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

CFTypeID IOHIDEventSystemClientGetTypeID(void)
{
  CFTypeID result;

  result = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    return __kIOHIDEventSystemClientTypeID;
  }
  return result;
}

uint64_t __IOHIDEventSystemClientServiceRefreshRemovedServiceCallback(void *key, _QWORD *a2, CFDictionaryRef theDict)
{
  uint64_t result;

  result = CFDictionaryContainsKey(theDict, key);
  if (!(_DWORD)result)
    return _IOHIDServiceClientDispatchServiceRemoval(a2);
  return result;
}

uint64_t __IOHIDEventSystemClientTerminationCallback(uint64_t a1, uint64_t a2, char a3)
{
  NSObject *v5;
  mach_port_name_t v6;
  uint64_t v7;
  __CFRunLoop *v8;
  const __CFString *v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  unsigned int Port;
  const __CFArray *v14;
  CFIndex v15;
  const __CFData *ValueAtIndex;
  const __CFData *v17;
  CFTypeID TypeID;
  const UInt8 *BytePtr;
  const UInt8 *v20;
  NSObject *v21;
  void (*v22)(_QWORD, _QWORD);
  uint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  void (*v27)(_QWORD, _QWORD);
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    __IOHIDEventSystemClientTerminationCallback_cold_1();
  os_unfair_recursive_lock_lock_with_options();
  v6 = *(_DWORD *)(a2 + 32);
  if (v6)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v6);
    *(_DWORD *)(a2 + 32) = 0;
  }
  v7 = *(_QWORD *)(a2 + 40);
  v8 = *(__CFRunLoop **)(a2 + 384);
  v9 = *(const __CFString **)(a2 + 392);
  v10 = *(_QWORD *)(a2 + 400);
  os_unfair_recursive_lock_unlock();
  if (*(_QWORD *)(a2 + 384))
  {
    __IOHIDEventSystemClientUnscheduleWithRunLoop(a2, v8, v9);
  }
  else if (v10 && v7)
  {
    IOMIGMachPortUnscheduleFromDispatchQueue(v7, v10);
  }
  os_unfair_recursive_lock_lock_with_options();
  v11 = *(const void **)(a2 + 288);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a2 + 288) = 0;
  }
  v12 = *(const void **)(a2 + 272);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a2 + 272) = 0;
  }
  if (v7)
  {
    Port = IOMIGMachPortGetPort(v7);
    IOMIGMachPortCacheRemove(Port);
    CFRelease(*(CFTypeRef *)(a2 + 40));
    *(_QWORD *)(a2 + 40) = 0;
  }
  ++*(_DWORD *)(a2 + 144);
  os_unfair_recursive_lock_unlock();
  __IOHIDEventSystemClientRefresh(a2, a3);
  os_unfair_recursive_lock_lock_with_options();
  v14 = *(const __CFArray **)(a2 + 136);
  if (v14 && CFArrayGetCount(v14) >= 1)
  {
    v15 = 0;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 136), v15);
      if (ValueAtIndex)
      {
        v17 = ValueAtIndex;
        TypeID = CFDataGetTypeID();
        if (TypeID == CFGetTypeID(v17))
        {
          BytePtr = CFDataGetBytePtr(v17);
          if (*(_QWORD *)BytePtr)
          {
            v20 = BytePtr;
            v21 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
            {
              v22 = *(void (**)(_QWORD, _QWORD))v20;
              v23 = *((_QWORD *)v20 + 1);
              v24 = *((_QWORD *)v20 + 2);
              *(_DWORD *)buf = 134218496;
              v27 = v22;
              v28 = 2048;
              v29 = v23;
              v30 = 2048;
              v31 = v24;
              _os_log_impl(&dword_18AAAF000, v21, OS_LOG_TYPE_INFO, "posting reset to (%p)(%p, %p)", buf, 0x20u);
            }
            (*(void (**)(_QWORD, _QWORD))v20)(*((_QWORD *)v20 + 1), *((_QWORD *)v20 + 2));
          }
        }
      }
      ++v15;
    }
    while (CFArrayGetCount(*(CFArrayRef *)(a2 + 136)) > v15);
  }
  return os_unfair_recursive_lock_unlock();
}

_QWORD *__VirtualServiceNotifier(uint64_t a1, _QWORD *a2)
{
  return _IOHIDVirtualServiceClientNotification(a2, 5, 0);
}

uint64_t IOHIDEventSystemClient()
{
  NSObject *v0;
  uint64_t result;

  v0 = _IOHIDLog();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    IOHIDEventSystemClient_cold_1();
  result = IOHIDEventSystemClient___hidClient;
  if (!IOHIDEventSystemClient___hidClient)
  {
    result = IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 1, (const __CFDictionary *)0x61746368);
    IOHIDEventSystemClient___hidClient = result;
  }
  return result;
}

uint64_t IOHIDEventSystemClientCreate(const __CFAllocator *a1)
{
  return IOHIDEventSystemClientCreateWithType(a1, 3, (const __CFDictionary *)0x61746368);
}

IOHIDEventSystemClientRef IOHIDEventSystemClientCreateSimpleClient(CFAllocatorRef allocator)
{
  return (IOHIDEventSystemClientRef)IOHIDEventSystemClientCreateWithType(allocator, 4, (const __CFDictionary *)0x61746368);
}

uint64_t IOHIDEventSystemClientUnscheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  __IOHIDEventSystemClientUnscheduleWithRunLoop(a1, a2, a3);
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDEventSystemClientUnscheduleWithRunLoop(uint64_t result, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v5;
  __CFRunLoopSource *v6;
  uint64_t v7;
  mach_port_t v8;
  __CFRunLoopSource *v9;

  if (a2 && a3)
  {
    v5 = result;
    os_unfair_recursive_lock_lock_with_options();
    v6 = *(__CFRunLoopSource **)(v5 + 64);
    if (v6)
      CFRunLoopRemoveSource(a2, v6, a3);
    v7 = *(_QWORD *)(v5 + 40);
    if (v7)
      IOMIGMachPortUnscheduleFromRunLoop(v7, a2, a3);
    v8 = *(_DWORD *)(v5 + 32);
    if (v8)
      io_hideventsystem_queue_stop(v8);
    v9 = *(__CFRunLoopSource **)(v5 + 288);
    if (v9)
      CFRunLoopRemoveSource(a2, v9, a3);
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

uint64_t IOHIDEventSystemClientScheduleWithDispatchQueue(uint64_t a1, NSObject *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_BYTE *)(a1 + 408) = 1;
  os_unfair_recursive_lock_unlock();
  IOHIDEventSystemClientSetDispatchQueue(a1, a2);
  return IOHIDEventSystemClientActivate(a1);
}

uint64_t __IOHIDEventSystemClientAvailabilityCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __IOHIDEventSystemClientTerminationCallback(a1, a4, 0);
}

uint64_t IOHIDEventSystemClientRegisterEventBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  void *v9;

  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (a2)
    v9 = _Block_copy(a2);
  else
    v9 = 0;
  *(_QWORD *)(a1 + 208) = v9;
  *(_QWORD *)(a1 + 216) = a3;
  *(_QWORD *)(a1 + 224) = a4;
  os_unfair_recursive_lock_unlock();
  return __IOHIDEventSystemClientStartQueue(a1);
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback(_QWORD *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[25] = 0;
  a1[27] = 0;
  a1[28] = 0;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterEventBlock(_QWORD *a1)
{
  const void *v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = (const void *)a1[26];
  if (v2)
  {
    _Block_release(v2);
    a1[26] = 0;
  }
  a1[27] = 0;
  a1[28] = 0;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientRegisterEventFilterCallbackWithPriority(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 232) = a3;
  *(_QWORD *)(a1 + 248) = a4;
  *(_QWORD *)(a1 + 256) = a5;
  *(_DWORD *)(a1 + 264) = a2;
  os_unfair_recursive_lock_unlock();
  return __IOHIDEventSystemClientStartFilter(a1);
}

uint64_t IOHIDEventSystemClientRegisterEventFilterCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return IOHIDEventSystemClientRegisterEventFilterCallbackWithPriority(a1, -1, a2, a3, a4);
}

uint64_t IOHIDEventSystemClientRegisterEventFilterBlockWithPriority(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5)
{
  void *v11;

  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (a3)
    v11 = _Block_copy(a3);
  else
    v11 = 0;
  *(_QWORD *)(a1 + 240) = v11;
  *(_QWORD *)(a1 + 248) = a4;
  *(_QWORD *)(a1 + 256) = a5;
  *(_DWORD *)(a1 + 264) = a2;
  os_unfair_recursive_lock_unlock();
  return __IOHIDEventSystemClientStartFilter(a1);
}

uint64_t IOHIDEventSystemClientRegisterEventFilterBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return IOHIDEventSystemClientRegisterEventFilterBlockWithPriority(a1, -1, a2, a3, a4);
}

uint64_t IOHIDEventSystemClientUnregisterEventFilterCallback(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(_QWORD *)(a1 + 232))
  {
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 256) = 0;
    io_hideventsystem_unregister_event_filter(*(_DWORD *)(a1 + 32));
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterEventFilterBlock(uint64_t a1)
{
  const void *v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(const void **)(a1 + 240);
  if (v2)
  {
    _Block_release(v2);
    *(_QWORD *)(a1 + 240) = 0;
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 256) = 0;
    io_hideventsystem_unregister_event_filter(*(_DWORD *)(a1 + 32));
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientDispatchEventFilter(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(_QWORD, _QWORD, uint64_t, uint64_t);
  uint64_t v9;

  os_unfair_recursive_lock_lock_with_options();
  v6 = a1[30];
  if (v6)
  {
    v7 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(v6 + 16))(v6, a1[31], a1[32], a2, a3);
  }
  else
  {
    v8 = (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t))a1[29];
    if (!v8)
    {
      v9 = 0;
      goto LABEL_6;
    }
    v7 = v8(a1[31], a1[32], a2, a3);
  }
  v9 = v7;
LABEL_6:
  os_unfair_recursive_lock_unlock();
  return v9;
}

void IOHIDEventSystemClientDispatchEvent(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v3;
  __CFData *DataInternal;
  __CFData *v5;
  const __CFData *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  int Length;
  uint64_t v10;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DataInternal = IOHIDEventCreateDataInternal((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  if (DataInternal)
  {
    v5 = DataInternal;
    v6 = (const __CFData *)_IOHIDCreateBinaryData(v3, DataInternal);
    if (v6)
    {
      v7 = v6;
      BytePtr = CFDataGetBytePtr(v6);
      Length = CFDataGetLength(v7);
      os_unfair_recursive_lock_lock_with_options();
      v10 = io_hideventsystem_dispatch_event(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, 0);
      if ((_DWORD)v10 == 268435459 && !*(_QWORD *)(a1 + 384) && !*(_QWORD *)(a1 + 400))
      {
        __IOHIDEventSystemClientTerminationCallback(v10, a1, 0);
        io_hideventsystem_dispatch_event(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, 0);
      }
      os_unfair_recursive_lock_unlock();
      CFRelease(v7);
    }
    CFRelease(v5);
  }
}

uint64_t _IOHIDEventSystemClientRegisterServiceRecordsChangedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 352) = a2;
  *(_QWORD *)(a1 + 368) = a3;
  *(_QWORD *)(a1 + 376) = a4;
  io_hideventsystem_register_record_service_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientRegisterServiceRecordsChangedBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  void *v8;

  os_unfair_recursive_lock_lock_with_options();
  if (a2)
    v8 = _Block_copy(a2);
  else
    v8 = 0;
  *(_QWORD *)(a1 + 360) = v8;
  *(_QWORD *)(a1 + 368) = a3;
  *(_QWORD *)(a1 + 376) = a4;
  io_hideventsystem_register_record_service_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterServiceRecordsChangedCallback(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  io_hideventsystem_unregister_record_service_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterServiceRecordsChangedBlock(uint64_t a1)
{
  const void *v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(const void **)(a1 + 360);
  if (v2)
  {
    _Block_release(v2);
    *(_QWORD *)(a1 + 360) = 0;
  }
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  io_hideventsystem_unregister_record_service_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientRegisterClientRecordsChangedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 320) = a2;
  *(_QWORD *)(a1 + 336) = a3;
  *(_QWORD *)(a1 + 344) = a4;
  io_hideventsystem_register_record_client_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientRegisterClientRecordsChangedBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  void *v8;

  os_unfair_recursive_lock_lock_with_options();
  if (a2)
    v8 = _Block_copy(a2);
  else
    v8 = 0;
  *(_QWORD *)(a1 + 328) = v8;
  *(_QWORD *)(a1 + 336) = a3;
  *(_QWORD *)(a1 + 344) = a4;
  io_hideventsystem_register_record_client_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterClientRecordsChangedCallback(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  io_hideventsystem_unregister_record_client_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterClientRecordsChangedBlock(uint64_t a1)
{
  const void *v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(const void **)(a1 + 328);
  if (v2)
  {
    _Block_release(v2);
    *(_QWORD *)(a1 + 328) = 0;
  }
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  io_hideventsystem_unregister_record_client_changed_notification(*(_DWORD *)(a1 + 32));
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingCallback(_QWORD *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[21] = 0;
  a1[23] = 0;
  a1[24] = 0;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  void *v9;

  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (a2)
    v9 = _Block_copy(a2);
  else
    v9 = 0;
  *(_QWORD *)(a1 + 176) = v9;
  *(_QWORD *)(a1 + 184) = a3;
  *(_QWORD *)(a1 + 192) = a4;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingBlock(_QWORD *a1)
{
  const void *v2;

  os_unfair_recursive_lock_lock_with_options();
  v2 = (const void *)a1[22];
  if (v2)
  {
    _Block_release(v2);
    a1[22] = 0;
  }
  a1[23] = 0;
  a1[24] = 0;
  return os_unfair_recursive_lock_unlock();
}

const void *IOHIDEventSystemClientCopyServiceForRegistryID(uint64_t a1, uint64_t a2)
{
  const void *Service;
  const void *v3;

  Service = __IOHIDEventSystemClientGetService(a1, a2);
  v3 = Service;
  if (Service)
    CFRetain(Service);
  return v3;
}

const __CFNumber *_IOHIDEventSystemClientServiceConformsTo(uint64_t a1, IOHIDServiceClientRef service, int a3, int a4)
{
  const __CFNumber *result;
  uint64_t valuePtr;

  result = (const __CFNumber *)IOHIDServiceClientGetRegistryID(service);
  valuePtr = 0;
  if (result)
  {
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)IOHIDEventSystemClientRegistryIDConformsTo(a1, valuePtr, a3, a4);
  }
  return result;
}

BOOL IOHIDEventSystemClientRegistryIDConformsTo(uint64_t a1, uint64_t a2, int a3, int a4)
{
  const __CFAllocator *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  const __CFData *v10;
  const __CFData *v11;
  mach_port_t v12;
  const UInt8 *BytePtr;
  int Length;
  uint64_t v15;
  int v16;
  _BOOL8 v17;
  mach_port_t v18;
  const UInt8 *v19;
  int v20;
  int v22;
  uint64_t valuePtr;

  valuePtr = a2;
  v22 = 0;
  if (!a1)
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = (const __CFData *)_IOHIDCreateBinaryData(v7, v8);
  if (!v10)
  {
    v17 = 0;
    goto LABEL_13;
  }
  v11 = v10;
  os_unfair_recursive_lock_lock_with_options();
  v12 = *(_DWORD *)(a1 + 32);
  BytePtr = CFDataGetBytePtr(v11);
  Length = CFDataGetLength(v11);
  v15 = io_hideventsystem_service_conforms_to(v12, (uint64_t)BytePtr, Length, a3, a4, &v22);
  v16 = v15;
  if ((_DWORD)v15 == 268435459)
  {
    if (*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400))
    {
      os_unfair_recursive_lock_unlock();
      goto LABEL_8;
    }
    __IOHIDEventSystemClientTerminationCallback(v15, a1, 0);
    v18 = *(_DWORD *)(a1 + 32);
    v19 = CFDataGetBytePtr(v11);
    v20 = CFDataGetLength(v11);
    v16 = io_hideventsystem_service_conforms_to(v18, (uint64_t)v19, v20, a3, a4, &v22);
  }
  os_unfair_recursive_lock_unlock();
  if (!v16)
  {
    v17 = v22 != 0;
    goto LABEL_12;
  }
LABEL_8:
  v17 = 0;
LABEL_12:
  CFRelease(v11);
LABEL_13:
  CFRelease(v9);
  return v17;
}

CFPropertyListRef _IOHIDEventSystemClientCopyPropertiesForService(uint64_t a1, IOHIDServiceClientRef service, const void *a3)
{
  CFPropertyListRef v3;
  const __CFAllocator *v6;
  CFTypeRef RegistryID;
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int v11;
  const __CFData *v12;
  const __CFData *v13;
  const UInt8 *v14;
  int v15;
  uint64_t v16;
  int v17;
  CFIndex length;
  UInt8 *bytes;

  v3 = 0;
  length = 0;
  bytes = 0;
  if (!a1 || !service || !a3)
    return v3;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  RegistryID = IOHIDServiceClientGetRegistryID(service);
  v8 = (const __CFData *)_IOHIDCreateBinaryData(v6, RegistryID);
  if (!v8)
    return 0;
  v9 = v8;
  BytePtr = CFDataGetBytePtr(v8);
  v11 = CFDataGetLength(v9);
  v12 = (const __CFData *)_IOHIDCreateBinaryData(v6, a3);
  if (!v12)
  {
    CFRelease(v9);
    return 0;
  }
  v13 = v12;
  v14 = CFDataGetBytePtr(v12);
  v15 = CFDataGetLength(v13);
  os_unfair_recursive_lock_lock_with_options();
  v16 = io_hideventsystem_copy_properties_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, (uint64_t)v14, v15, &bytes, (_DWORD *)&length + 1, &length);
  v17 = v16;
  if ((_DWORD)v16 == 268435459)
  {
    if (*(_QWORD *)(a1 + 384))
    {
      v17 = 268435459;
    }
    else
    {
      v17 = 268435459;
      if (!*(_QWORD *)(a1 + 400))
      {
        __IOHIDEventSystemClientTerminationCallback(v16, a1, 0);
        v17 = io_hideventsystem_copy_properties_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, (uint64_t)v14, v15, &bytes, (_DWORD *)&length + 1, &length);
      }
    }
  }
  os_unfair_recursive_lock_unlock();
  if (v17 | length)
    v3 = 0;
  else
    v3 = _IOHIDUnserializeAndVMDealloc(bytes, HIDWORD(length));
  CFRelease(v9);
  CFRelease(v13);
  return v3;
}

uint64_t _IOHIDEventSystemClientCopyMatchingEventForService(uint64_t a1, IOHIDServiceClientRef service, const UInt8 *BytePtr)
{
  const __CFNumber *RegistryID;
  const __CFNumber *v6;
  CFTypeID v7;
  __CFData *Value;
  __CFData *v9;
  CFTypeID v10;
  uint64_t TypeID;
  const __CFAllocator *v12;
  __CFData *DataInternal;
  const __CFData *v14;
  const __CFData *v15;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  __CFDictionary *v18;
  int Length;
  const UInt8 *v20;
  const __CFData *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  UInt8 *v26;
  mach_vm_size_t v27;
  CFTypeID v28;
  const void *v29;
  const void *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t valuePtr;
  unsigned int v38;
  UInt8 *v39;

  v39 = 0;
  v38 = 0;
  valuePtr = 0;
  if (!a1 || !service)
  {
    v32 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_1();
    return 0;
  }
  RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(service);
  if (!RegistryID || (v6 = RegistryID, v7 = CFGetTypeID(RegistryID), v7 != CFNumberGetTypeID()))
  {
    v31 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_2();
    return 0;
  }
  CFNumberGetValue(v6, kCFNumberSInt64Type, &valuePtr);
  if (!BytePtr)
  {
    v15 = 0;
    Length = 0;
    v18 = 0;
    v9 = 0;
    goto LABEL_20;
  }
  Value = (__CFData *)CFDictionaryGetValue((CFDictionaryRef)BytePtr, CFSTR("MatchingEvent"));
  v9 = Value;
  if (!Value)
  {
    v18 = 0;
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    goto LABEL_15;
  }
  v10 = CFGetTypeID(Value);
  TypeID = IOHIDEventGetTypeID();
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v10 != TypeID)
  {
    v18 = 0;
    v9 = 0;
    goto LABEL_15;
  }
  DataInternal = IOHIDEventCreateDataInternal((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)v9);
  if (!DataInternal)
  {
    v34 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_4();
    return 0;
  }
  v9 = DataInternal;
  v14 = (const __CFData *)_IOHIDCreateBinaryData(v12, DataInternal);
  if (!v14)
  {
    v35 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_5();
    v18 = 0;
    v15 = 0;
    goto LABEL_52;
  }
  v15 = v14;
  Count = CFDictionaryGetCount((CFDictionaryRef)BytePtr);
  MutableCopy = CFDictionaryCreateMutableCopy(v12, Count, (CFDictionaryRef)BytePtr);
  if (!MutableCopy)
  {
    v36 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_6();
    v18 = 0;
LABEL_52:
    v24 = 0;
    goto LABEL_28;
  }
  v18 = MutableCopy;
  CFDictionarySetValue(MutableCopy, CFSTR("MatchingEvent"), v15);
  CFRelease(v15);
LABEL_15:
  if (v18)
    v20 = (const UInt8 *)v18;
  else
    v20 = BytePtr;
  v21 = (const __CFData *)_IOHIDCreateBinaryData(v12, v20);
  if (!v21)
  {
    v33 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_3();
    v24 = 0;
    v15 = 0;
    goto LABEL_27;
  }
  v15 = v21;
  BytePtr = CFDataGetBytePtr(v21);
  Length = CFDataGetLength(v15);
LABEL_20:
  os_unfair_recursive_lock_lock_with_options();
  v22 = io_hideventsystem_copy_matching_event_for_service(*(_DWORD *)(a1 + 32), valuePtr, (uint64_t)BytePtr, Length, &v39, &v38);
  v23 = v22;
  if ((_DWORD)v22 == 268435459)
  {
    if (*(_QWORD *)(a1 + 384) || *(_QWORD *)(a1 + 400))
    {
      os_unfair_recursive_lock_unlock();
LABEL_26:
      v24 = 0;
      goto LABEL_27;
    }
    __IOHIDEventSystemClientTerminationCallback(v22, a1, 0);
    v23 = io_hideventsystem_copy_matching_event_for_service(*(_DWORD *)(a1 + 32), valuePtr, (uint64_t)BytePtr, Length, &v39, &v38);
  }
  os_unfair_recursive_lock_unlock();
  if (v23)
    goto LABEL_26;
  v26 = v39;
  v27 = v38;
  v28 = CFDataGetTypeID();
  v29 = _IOHIDUnserializeAndVMDeallocWithTypeID(v26, v27, v28);
  if (!v29)
    goto LABEL_26;
  v30 = v29;
  v24 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E0C9AE00], v29);
  CFRelease(v30);
LABEL_27:
  if (v9)
LABEL_28:
    CFRelease(v9);
  if (v15)
    CFRelease(v15);
  if (v18)
    CFRelease(v18);
  return v24;
}

uint64_t _IOHIDEventSystemClientSetElementValueForService(uint64_t a1, IOHIDServiceClientRef service, int a3, int a4, int a5)
{
  uint64_t v5;
  const __CFAllocator *v10;
  CFTypeRef RegistryID;
  const __CFData *v12;
  const __CFData *v13;
  const UInt8 *BytePtr;
  int Length;
  uint64_t v16;
  unsigned int v18;

  v5 = 3758097090;
  v18 = -536870206;
  if (a1)
  {
    if (service)
    {
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      RegistryID = IOHIDServiceClientGetRegistryID(service);
      v12 = (const __CFData *)_IOHIDCreateBinaryData(v10, RegistryID);
      if (v12)
      {
        v13 = v12;
        BytePtr = CFDataGetBytePtr(v12);
        Length = CFDataGetLength(v13);
        os_unfair_recursive_lock_lock_with_options();
        v16 = io_hideventsystem_set_element_value_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, a3, a4, a5, (int *)&v18);
        if ((_DWORD)v16 == 268435459 && !*(_QWORD *)(a1 + 384) && !*(_QWORD *)(a1 + 400))
        {
          __IOHIDEventSystemClientTerminationCallback(v16, a1, 0);
          io_hideventsystem_set_element_value_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, a3, a4, a5, (int *)&v18);
        }
        os_unfair_recursive_lock_unlock();
        CFRelease(v13);
        return v18;
      }
    }
  }
  return v5;
}

void IOHIDEventSystemClientRegisterPropertyChangedCallback(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const __CFAllocator *v11;
  _QWORD *v12;
  uint64_t v13;
  CFDictionaryValueCallBacks v14;

  os_unfair_recursive_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312)))
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_QWORD *)(a1 + 120))
  {
    memset(&v14, 0, sizeof(v14));
    v11 = CFGetAllocator((CFTypeRef)a1);
    *(_QWORD *)(a1 + 120) = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E0C9B390], &v14);
  }
  os_unfair_recursive_lock_unlock();
  v12 = malloc_type_malloc(0x20uLL, 0xE00408373F082uLL);
  *v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  os_unfair_recursive_lock_lock_with_options();
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), a2, v12);
  os_unfair_recursive_lock_unlock();
  __IOHIDEventSystemClientRegisterPropertyCallbackRegisterFunction(a2, v13, a1);
}

void __IOHIDEventSystemClientRegisterPropertyCallbackRegisterFunction(const void *a1, uint64_t a2, uint64_t a3)
{
  const __CFData *v4;
  const __CFData *v5;
  int v6;
  const UInt8 *BytePtr;
  int Length;

  v4 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1);
  if (v4)
  {
    v5 = v4;
    os_unfair_recursive_lock_lock_with_options();
    v6 = *(_DWORD *)(a3 + 32);
    BytePtr = CFDataGetBytePtr(v5);
    Length = CFDataGetLength(v5);
    io_hideventsystem_register_property_changed_notification(v6, (uint64_t)BytePtr, Length);
    os_unfair_recursive_lock_unlock();
    CFRelease(v5);
  }
}

void IOHIDEventSystemClientUnregisterPropertyChangedCallback(uint64_t a1, const void *a2)
{
  void *Value;
  const __CFData *v5;
  const __CFData *v6;
  int v7;
  const UInt8 *BytePtr;
  int Length;

  os_unfair_recursive_lock_lock_with_options();
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), a2);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 120), a2);
  os_unfair_recursive_lock_unlock();
  if (Value)
    free(Value);
  v5 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  if (v5)
  {
    v6 = v5;
    os_unfair_recursive_lock_lock_with_options();
    v7 = *(_DWORD *)(a1 + 32);
    BytePtr = CFDataGetBytePtr(v6);
    Length = CFDataGetLength(v6);
    io_hideventsystem_unregister_property_changed_notification(v7, (uint64_t)BytePtr, Length);
    os_unfair_recursive_lock_unlock();
    CFRelease(v6);
  }
}

uint64_t _IOHIDEventSystemClientDispatchPropertiesChanged(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *v4;
  _QWORD v6[2];

  os_unfair_recursive_lock_lock_with_options();
  gettimeofday((timeval *)(a1 + 496), 0);
  ++*(_QWORD *)(a1 + 512);
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  v4 = *(const __CFDictionary **)(a1 + 120);
  if (v4)
  {
    v6[0] = a1;
    v6[1] = a2;
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRegisterPropertyCallbackApplyFunction, v6);
  }
  return os_unfair_recursive_lock_unlock();
}

void __IOHIDEventSystemClientRegisterPropertyCallbackApplyFunction(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const __CFDictionary *v3;
  _QWORD v4[2];

  v3 = (const __CFDictionary *)a3[1];
  v4[0] = *a3;
  v4[1] = a2;
  CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)_IOHIDEventSystemClientDispatchPropertiesChangedFunction, v4);
}

CFIndex IOHIDEventSystemClientUnregisterResetCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFIndex result;

  os_unfair_recursive_lock_lock_with_options();
  result = __IOHIDEventSystemClientFindCallback(a1, a2, a3, a4);
  if (result != -1)
  {
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 136), result);
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

const char *IOHIDEventSystemClientGetTypeString(unsigned int a1)
{
  if (a1 > 4)
    return "Invalid";
  else
    return off_1E2002AA0[a1];
}

uint64_t _iohideventsystem_client_dispatch_properties_changed(unsigned int a1, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v4;
  const void *v5;
  const void *v6;
  const void *v7;
  CFTypeID v8;
  uint64_t v9;

  v4 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  if (v4)
  {
    v5 = v4;
    v6 = IOMIGMachPortCacheCopy(a1);
    if (v6)
    {
      v7 = v6;
      v8 = CFGetTypeID(v6);
      v9 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        v9 = __kIOHIDEventSystemClientTypeID;
      }
      if (v8 == v9)
        _IOHIDEventSystemClientDispatchPropertiesChanged((uint64_t)v7, (uint64_t)v5);
      CFRelease(v7);
    }
    CFRelease(v5);
  }
  return 0;
}

uint64_t _iohideventsystem_client_dispatch_event_filter(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  CFDictionaryRef *v11;
  CFDictionaryRef *v12;
  CFTypeID v13;
  uint64_t v14;
  CFPropertyListRef v15;
  const void *Value;
  CFTypeID TypeID;
  const void *v18;
  const void *v19;
  uint64_t v20;
  const void *v21;

  v11 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  if (v11)
  {
    v12 = v11;
    v13 = CFGetTypeID(v11);
    v14 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      v14 = __kIOHIDEventSystemClientTypeID;
    }
    if (v13 != v14)
      goto LABEL_17;
    v15 = _IOHIDUnserializeAndVMDealloc(a2, a3);
    if (v15)
    {
      os_unfair_recursive_lock_lock_with_options();
      Value = CFDictionaryGetValue(v12[12], v15);
      os_unfair_recursive_lock_unlock();
    }
    else
    {
      Value = 0;
    }
    TypeID = CFDataGetTypeID();
    v18 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
    if (!v18)
    {
LABEL_15:
      if (v15)
        CFRelease(v15);
LABEL_17:
      CFRelease(v12);
      return 0;
    }
    v19 = v18;
    v20 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E0C9AE00], v18);
    v21 = (const void *)v20;
    if (a6 && v20)
    {
      *a6 = _IOHIDEventSystemClientDispatchEventFilter(v12, (uint64_t)Value, v20);
    }
    else if (!v20)
    {
LABEL_14:
      CFRelease(v19);
      goto LABEL_15;
    }
    CFRelease(v21);
    goto LABEL_14;
  }
  return 0;
}

uint64_t _iohideventsystem_client_dispatch_client_records_changed(unsigned int a1)
{
  _QWORD *v1;
  _QWORD *v2;
  CFTypeID v3;
  uint64_t v4;
  void (*v5)(_QWORD, _QWORD *, _QWORD);
  uint64_t v6;

  v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    v4 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      v4 = __kIOHIDEventSystemClientTypeID;
    }
    if (v3 == v4)
    {
      os_unfair_recursive_lock_lock_with_options();
      v5 = (void (*)(_QWORD, _QWORD *, _QWORD))v2[40];
      if (v5)
      {
        v5(v2[42], v2, v2[43]);
      }
      else
      {
        v6 = v2[41];
        if (v6)
          (*(void (**)(uint64_t, _QWORD, _QWORD *, _QWORD))(v6 + 16))(v6, v2[42], v2, v2[43]);
      }
      os_unfair_recursive_lock_unlock();
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t _iohideventsystem_client_dispatch_service_records_changed(unsigned int a1)
{
  _QWORD *v1;
  _QWORD *v2;
  CFTypeID v3;
  uint64_t v4;
  void (*v5)(_QWORD, _QWORD *, _QWORD);
  uint64_t v6;

  v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    v4 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      v4 = __kIOHIDEventSystemClientTypeID;
    }
    if (v3 == v4)
    {
      os_unfair_recursive_lock_lock_with_options();
      v5 = (void (*)(_QWORD, _QWORD *, _QWORD))v2[44];
      if (v5)
      {
        v5(v2[46], v2, v2[47]);
      }
      else
      {
        v6 = v2[45];
        if (v6)
          (*(void (**)(uint64_t, _QWORD, _QWORD *, _QWORD))(v6 + 16))(v6, v2[46], v2, v2[47]);
      }
      os_unfair_recursive_lock_unlock();
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t IOHIDVirtualServiceClientRemove(__IOHIDServiceClient *a1)
{
  uint64_t EventSystemClient;
  const __CFNumber *RegistryID;
  NSObject *v4;
  const void *valuePtr;

  valuePtr = 0;
  EventSystemClient = _IOHIDVirtuaServiceClientGetEventSystemClient((uint64_t)a1);
  RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(a1);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  os_unfair_recursive_lock_lock_with_options();
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(EventSystemClient + 104), valuePtr))
  {
    if (io_hideventsystem_remove_virtual_service(*(_DWORD *)(EventSystemClient + 32), (uint64_t)valuePtr))
    {
      v4 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        IOHIDVirtualServiceClientRemove_cold_1();
    }
  }
  _IOHIDVirtualServiceClientNotification(a1, 3, 0);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(EventSystemClient + 104), valuePtr);
  return os_unfair_recursive_lock_unlock();
}

uint64_t _iohideventsystem_output_event_to_virtual_service(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, _DWORD *a5)
{
  mach_vm_size_t v9;
  CFTypeID TypeID;
  CFDictionaryRef *v11;
  CFDictionaryRef *v12;
  uint64_t v13;
  const void *v14;
  CFDictionaryRef *v15;
  CFDictionaryRef *v16;
  CFTypeID v17;
  uint64_t v18;
  _QWORD *Value;
  _QWORD *v20;
  NSObject *v21;
  CFDictionaryRef *v22;
  NSObject *v24;

  v9 = a4;
  TypeID = CFDataGetTypeID();
  v11 = (CFDictionaryRef *)_IOHIDUnserializeAndVMDeallocWithTypeID(a3, v9, TypeID);
  if (v11)
  {
    v12 = v11;
    v13 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E0C9AE00], v11);
    if (!v13)
    {
      *a5 = -536870211;
      v22 = v12;
      goto LABEL_13;
    }
    v14 = (const void *)v13;
    v15 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    v16 = v15;
    if (!v15)
      goto LABEL_15;
    v17 = CFGetTypeID(v15);
    v18 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      v18 = __kIOHIDEventSystemClientTypeID;
    }
    if (v17 == v18)
    {
      os_unfair_recursive_lock_lock_with_options();
      Value = CFDictionaryGetValue(v16[13], a2);
      if (Value)
      {
        v20 = Value;
        CFRetain(Value);
        os_unfair_recursive_lock_unlock();
        *a5 = _IOHIDVirtualServiceClientSetOputputEvent(v20, (uint64_t)v14);
        CFRelease(v20);
        CFRelease(v12);
        CFRelease(v14);
LABEL_12:
        v22 = v16;
LABEL_13:
        CFRelease(v22);
        return 0;
      }
      os_unfair_recursive_lock_unlock();
      *a5 = -536870208;
      v21 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        _iohideventsystem_output_event_to_virtual_service_cold_2();
    }
    else
    {
LABEL_15:
      *a5 = -536870212;
    }
    CFRelease(v12);
    CFRelease(v14);
    if (v16)
      goto LABEL_12;
  }
  else
  {
    *a5 = -536870206;
    v24 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      _iohideventsystem_output_event_to_virtual_service_cold_1();
  }
  return 0;
}

uint64_t _iohideventsystem_copy_matching_event_from_virtual_service(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, vm_offset_t *a5, _DWORD *a6)
{
  mach_vm_size_t v11;
  CFTypeID TypeID;
  const void *v13;
  CFDictionaryRef *v14;
  CFDictionaryRef *v15;
  CFTypeID v16;
  uint64_t v17;
  _QWORD *Value;
  _QWORD *v19;
  const void *v20;
  const __CFAllocator *v21;
  __CFData *DataInternal;
  NSObject *v23;
  NSObject *v25;

  v11 = a4;
  TypeID = CFDictionaryGetTypeID();
  v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a3, v11, TypeID);
  v14 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  v15 = v14;
  if (!v14)
    goto LABEL_20;
  v16 = CFGetTypeID(v14);
  v17 = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    v17 = __kIOHIDEventSystemClientTypeID;
  }
  if (v16 == v17)
  {
    os_unfair_recursive_lock_lock_with_options();
    Value = CFDictionaryGetValue(v15[13], a2);
    if (Value)
    {
      v19 = Value;
      CFRetain(Value);
      os_unfair_recursive_lock_unlock();
      v20 = (const void *)_IOHIDVirtualServiceClientCopyMatchingEvent(v19, (uint64_t)v13);
      if (v20)
      {
        v21 = CFGetAllocator(v19);
        DataInternal = IOHIDEventCreateDataInternal(v21, (uint64_t)v20);
      }
      else
      {
        DataInternal = 0;
      }
      *a6 = _IOHIDSerialize(DataInternal, a5);
      CFRelease(v19);
      if (v20)
        CFRelease(v20);
      if (DataInternal)
        CFRelease(DataInternal);
    }
    else
    {
      os_unfair_recursive_lock_unlock();
      v23 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        _iohideventsystem_output_event_to_virtual_service_cold_2();
    }
  }
  else
  {
LABEL_20:
    v25 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
  }
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
  return 0;
}

uint64_t _iohideventsystem_client_refresh(unsigned int a1)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;
  uint64_t v4;
  CFDictionaryRef Copy;
  const __CFDictionary *v6;
  int v7;
  NSObject *v8;
  const __CFDictionary *v9;
  UInt8 *v10;
  mach_vm_size_t v11;
  CFTypeID TypeID;
  const __CFArray *v13;
  NSObject *v14;
  _BOOL4 v15;
  CFIndex Count;
  CFIndex v17;
  const __CFAllocator *v18;
  CFDictionaryRef v19;
  unsigned int v21;
  UInt8 *v22;
  _QWORD context[2];
  _BYTE buf[24];
  void *v25;
  const void *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = IOMIGMachPortCacheCopy(a1);
  v22 = 0;
  v21 = 0;
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    v4 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      v4 = __kIOHIDEventSystemClientTypeID;
    }
    if (v3 == v4)
    {
      os_unfair_recursive_lock_lock_with_options();
      Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((CFDictionaryRef *)v2 + 12));
      if (Copy)
      {
        v6 = Copy;
        v7 = io_hideventsystem_do_client_refresh(*((_DWORD *)v2 + 8), &v22, &v21);
        v8 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v7;
          _os_log_impl(&dword_18AAAF000, v8, OS_LOG_TYPE_INFO, "io_hideventsystem_do_client_refresh:0x%x", buf, 8u);
        }
        if (v7)
        {
          os_unfair_recursive_lock_unlock();
          v9 = v6;
LABEL_21:
          CFRelease(v9);
          return 0;
        }
        v10 = v22;
        v11 = v21;
        TypeID = CFArrayGetTypeID();
        v13 = (const __CFArray *)_IOHIDUnserializeAndVMDeallocWithTypeID(v10, v11, TypeID);
        CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)v2 + 12));
        v14 = _IOHIDLogCategory(0xDu);
        v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
        if (v13)
        {
          if (v15)
          {
            Count = CFArrayGetCount(v13);
            v17 = CFDictionaryGetCount(v6);
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = Count;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v17;
            _os_log_impl(&dword_18AAAF000, v14, OS_LOG_TYPE_DEFAULT, "HID Event System Client refreshed with %ld services, cached matching had %ld services", buf, 0x16u);
          }
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ____IOHIDEventSystemClientCacheServices_block_invoke;
          v25 = &__block_descriptor_tmp_93;
          v26 = v2;
          _IOHIDCFArrayApplyBlock(v13, buf);
        }
        else if (v15)
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18AAAF000, v14, OS_LOG_TYPE_DEFAULT, "HID Event System Client refreshed but no services returned", buf, 2u);
        }
        CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)__IOHIDEventSystemClientServiceReplaceCallback, *((void **)v2 + 12));
        v18 = CFGetAllocator(v2);
        v19 = CFDictionaryCreateCopy(v18, *((CFDictionaryRef *)v2 + 12));
        os_unfair_recursive_lock_unlock();
        CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)__IOHIDEventSystemClientServiceRefreshRemovedServiceCallback, v19);
        context[0] = v2;
        context[1] = v6;
        CFDictionaryApplyFunction(v19, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRefreshServiceCallback, context);
        CFRelease(v6);
        if (v13)
          CFRelease(v13);
        if (v19)
        {
          v9 = v19;
          goto LABEL_21;
        }
      }
      else
      {
        os_unfair_recursive_lock_unlock();
      }
    }
  }
  return 0;
}

uint64_t __IOHIDEventSystemClientConnectionPropertyFunction(const __CFString *a1, const void *a2, __IOHIDEventSystemClient *a3)
{
  NSObject *v6;
  int v8;
  const __CFString *v9;
  __int16 v10;
  const void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v6 = _IOHIDLogCategory(0xDu);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v8 = 138412546;
    v9 = a1;
    v10 = 2112;
    v11 = a2;
    _os_log_impl(&dword_18AAAF000, v6, OS_LOG_TYPE_INFO, "restore property %@ to %@", (uint8_t *)&v8, 0x16u);
  }
  return IOHIDEventSystemClientSetProperty(a3, a1, a2);
}

uint64_t _IOHIDEventSystemClientDispatchPropertiesChangedFunction(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = CFEqual(a1, **(CFTypeRef **)(a3 + 8));
  if ((_DWORD)result)
    return (*(uint64_t (**)(_QWORD, _QWORD, const void *, uint64_t))(*(_QWORD *)(a3 + 8) + 8))(*(_QWORD *)(*(_QWORD *)(a3 + 8) + 16), *(_QWORD *)(*(_QWORD *)(a3 + 8) + 24), a1, a2);
  return result;
}

void OUTLINED_FUNCTION_1_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

uint64_t IOHIDNotificationGetTypeID()
{
  uint64_t result;

  result = __kIOHIDNotificationTypeID;
  if (!__kIOHIDNotificationTypeID)
  {
    pthread_once(&__notificationTypeInit, (void (*)(void))__IOHIDNotificationRegister);
    return __kIOHIDNotificationTypeID;
  }
  return result;
}

uint64_t IOHIDNotificationGetClientCallback(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t IOHIDNotificationGetClientTarget(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t IOHIDNotificationGetClientRefcon(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t IOHIDNotificationGetOwnerCallback(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t IOHIDNotificationGetOwnerTarget(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t IOHIDNotificationGetOwnerRefcon(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

CFStringRef __IOHIDNotificationCopyDebugDescription(uint64_t a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<IOHIDNotificationRef %p (ref:%d xref:%d), flags:%x  %p,%p,%p,%p,%p,%p>"), a1, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 72), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
}

HIDEventService *_IOHIDServiceCreateVirtual(uint64_t a1, unint64_t a2, _QWORD *a3, void *a4, void *a5)
{
  HIDEventService *VirtualNoInit;
  HIDEventService *v7;

  VirtualNoInit = __IOHIDServiceCreateVirtualNoInit(a1, a2, a3, a4, a5);
  v7 = VirtualNoInit;
  if (VirtualNoInit && !__IOHIDServiceInit((uint64_t)VirtualNoInit, a2))
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

HIDEventService *_IOHIDServiceCreate(uint64_t a1, io_registry_entry_t entry)
{
  HIDEventService *Private;
  kern_return_t v5;
  int v6;
  NSObject *v7;
  const __CFUUID *v9;
  const __CFUUID *v10;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFIndex v15;
  __CFBundle *ValueAtIndex;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  CFTypeID v21;
  CFTypeID TypeID;
  NSObject *v23;
  const __CFNumber *v24;
  const __CFNumber *v25;
  CFTypeID v26;
  __CFDictionary *v27;
  const __CFDictionary *v28;
  CFIndex v29;
  void *v30;
  __CFBundle *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  __CFString *v34;
  __CFString *v35;
  CFTypeID v36;
  const __CFString *v37;
  const __CFString *v38;
  void *DataPointerForName;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t service;
  id v44;
  void *v45;
  Protocol *Protocol;
  const char *Uid;
  const char *v48;
  const char *v49;
  const char *v50;
  char v51;
  IOCFPlugInInterfaceStruct **plugInInterface;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFAllocator *v54;
  const __CFUUID *v55;
  CFUUIDBytes v56;
  IOCFPlugInInterfaceStruct **v57;
  HRESULT (__cdecl *v58)(void *, REFIID, LPVOID *);
  const __CFUUID *v59;
  CFUUIDBytes v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  NSObject *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  NSObject *v85;
  kern_return_t v86;
  unsigned int v87;
  uint64_t v88;
  const __CFAllocator *allocator;
  io_service_t object;
  uint64_t entryID;
  SInt32 theScore;
  void *value;
  unsigned int valuePtr;
  _BYTE context[24];
  void *v96;
  _BYTE *v97;
  io_service_t v98;
  _BYTE buf[12];
  _BYTE v100[24];
  int v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  theScore = 0;
  entryID = 0;
  IORegistryEntryGetRegistryEntryID(entry, &entryID);
  if (__serviceRunLoopInit != -1)
    dispatch_once(&__serviceRunLoopInit, &__block_literal_global_9);
  _IOHIDDebugTrace(8257, 1, entryID, 0, 0, 0);
  Private = _IOHIDServiceCreatePrivate(a1);
  if (!Private)
    goto LABEL_7;
  v5 = IOObjectRetain(entry);
  if (v5)
  {
    v6 = v5;
    v7 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      _IOHIDServiceCreate_cold_4(v6, v7);
    goto LABEL_7;
  }
  Private->_service.service = entry;
  v9 = CFUUIDGetConstantUUIDWithBytes(0, 5u, 0x16u, 0xB5u, 0x63u, 0xB1u, 0x5Bu, 0x11u, 0xDAu, 0x96u, 0xEBu, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  v10 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  v86 = IOCreatePlugInInterfaceForService(entry, v9, v10, &Private->_service.plugInInterface, &theScore);
  if (v86)
  {
    object = Private->_service.service;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (!Mutable)
      goto LABEL_78;
    v12 = Mutable;
    v13 = (const __CFArray *)_IOHIDLoadServicePluginBundles();
    if (!v13)
      goto LABEL_77;
    v14 = v13;
    if (CFArrayGetCount(v13) >= 1)
    {
      v15 = 0;
      v87 = 0;
      do
      {
        *(_QWORD *)v100 = 0;
        *(_QWORD *)&v100[8] = v100;
        *(_QWORD *)&v100[16] = 0x2000000000;
        v101 = 0;
        valuePtr = 0;
        value = 0;
        ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v14, v15);
        InfoDictionary = CFBundleGetInfoDictionary(ValueAtIndex);
        if (InfoDictionary)
        {
          v18 = InfoDictionary;
          v19 = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, CFSTR("Matching"));
          if (v19 && (v20 = v19, v21 = CFGetTypeID(v19), v21 == CFDictionaryGetTypeID()))
          {
            if (CFDictionaryGetValueIfPresent(v20, CFSTR("IOKitPersonalities"), (const void **)&value)
              && (TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(value)))
            {
              *(_QWORD *)context = MEMORY[0x1E0C809B0];
              *(_QWORD *)&context[8] = 0x40000000;
              *(_QWORD *)&context[16] = ____IOHIDServiceMatchObjcServicePlugin_block_invoke;
              v96 = &unk_1E2002E88;
              v98 = object;
              v97 = v100;
              _IOHIDCFDictionaryApplyBlock((const __CFDictionary *)value, context);
            }
            else if (IOObjectConformsTo(object, "IOHIDDevice") || IOObjectConformsTo(object, "IOHIDEventService"))
            {
              IOServiceMatchPropertyTable(object, v20, (BOOLean_t *)(*(_QWORD *)&v100[8] + 24));
            }
            else
            {
              v27 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (!v27)
              {
                _Block_object_dispose(v100, 8);
LABEL_77:
                CFRelease(v12);
LABEL_78:
                v51 = 0;
                goto LABEL_79;
              }
              v28 = v27;
              CFDictionarySetValue(v27, CFSTR("IOPropertyMatch"), v20);
              IOServiceMatchPropertyTable(object, v28, (BOOLean_t *)(*(_QWORD *)&v100[8] + 24));
              CFRelease(v28);
            }
            if (*(_DWORD *)(*(_QWORD *)&v100[8] + 24))
            {
              v24 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("ProbeScore"));
              if (v24)
              {
                v25 = v24;
                v26 = CFGetTypeID(v20);
                if (v26 != CFNumberGetTypeID())
                  CFNumberGetValue(v25, kCFNumberSInt32Type, &valuePtr);
              }
              if (valuePtr <= v87)
              {
                if (valuePtr == v87)
                  CFArrayAppendValue(v12, ValueAtIndex);
              }
              else
              {
                CFArrayRemoveAllValues(v12);
                CFArrayAppendValue(v12, ValueAtIndex);
                v87 = valuePtr;
              }
            }
          }
          else
          {
            v23 = _IOHIDLogCategory(0);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v18;
              _os_log_error_impl(&dword_18AAAF000, v23, OS_LOG_TYPE_ERROR, "__IOHIDServiceLoadObjcServicePlugin plugin did not provide passive matching dictionary %@", buf, 0xCu);
            }
          }
        }
        _Block_object_dispose(v100, 8);
        ++v15;
      }
      while (v15 < CFArrayGetCount(v14));
    }
    if (CFArrayGetCount(v12) < 1)
      goto LABEL_77;
    v29 = 0;
    v30 = 0;
    v88 = -1;
    do
    {
      *(_QWORD *)buf = 0;
      v31 = (__CFBundle *)CFArrayGetValueAtIndex(v12, v29);
      v32 = CFBundleGetInfoDictionary(v31);
      if (v32)
      {
        v33 = v32;
        v34 = (__CFString *)CFDictionaryGetValue(v32, CFSTR("NSPrincipalClass"));
        if (v34)
        {
          v35 = v34;
          v36 = CFGetTypeID(v34);
          if (v36 == CFStringGetTypeID())
          {
            v37 = CFStringCreateWithFormat(allocator, 0, CFSTR("OBJC_CLASS_$_%@"), v35);
            if (v37)
            {
              v38 = v37;
              DataPointerForName = CFBundleGetDataPointerForName(v31, v37);
              if (DataPointerForName)
              {
                v40 = DataPointerForName;
                CFRelease(v38);
                if (objc_msgSend(v40, sel_getUid("matchService:options:score:"), object, 0, buf))
                {
                  v41 = *(_QWORD *)buf;
                  if (*(uint64_t *)buf > v88)
                  {
                    Private->_service.objc.name = v35;
                    v88 = v41;
                    v30 = v40;
                  }
                }
              }
              else
              {
                v42 = _IOHIDLogCategory(0);
                if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v100 = 138412546;
                  *(_QWORD *)&v100[4] = v38;
                  *(_WORD *)&v100[12] = 2112;
                  *(_QWORD *)&v100[14] = v33;
                  _os_log_error_impl(&dword_18AAAF000, v42, OS_LOG_TYPE_ERROR, "__IOHIDServiceLoadObjcServicePlugin failed to find symbol %@ for bundle %@", v100, 0x16u);
                }
                CFRelease(v38);
              }
            }
          }
        }
      }
      ++v29;
    }
    while (v29 < CFArrayGetCount(v12));
    CFRelease(v12);
    if (v30)
    {
      service = Private->_service.service;
      v44 = objc_msgSend(v30, sel_getUid("alloc"));
      if (v44)
      {
        v45 = v44;
        if (objc_msgSend(v44, sel_getUid("initWithService:"), service))
        {
          Protocol = objc_getProtocol("HIDServicePlugin");
          if (Protocol)
          {
            if (class_conformsToProtocol((Class)v30, Protocol))
            {
              Private->_service.objc.interface = v45;
              Private->_service.objc.getProperty = sel_getUid("propertyForKey:client:");
              Private->_service.objc.setProperty = sel_getUid("setProperty:forKey:client:");
              Private->_service.objc.eventMatching = sel_getUid("eventMatching:forClient:");
              Private->_service.objc.setEventDispatcher = sel_getUid("setEventDispatcher:");
              Private->_service.objc.setCancelHandler = sel_getUid("setCancelHandler:");
              Private->_service.objc.activate = sel_getUid("activate");
              Private->_service.objc.cancel = sel_getUid("cancel");
              Uid = sel_getUid("setDispatchQueue:");
              if (class_respondsToSelector((Class)v30, Uid))
                Private->_service.objc.setDispatchQueue = sel_getUid("setDispatchQueue:");
              v48 = sel_getUid("clientNotification:added:");
              if (class_respondsToSelector((Class)v30, v48))
                Private->_service.objc.clientNotification = sel_getUid("clientNotification:added:");
              v49 = sel_getUid("copyEvent:matching:options:");
              if (class_respondsToSelector((Class)v30, v49))
                Private->_service.objc.copyEvent = sel_getUid("copyEvent:matching:options:");
              v50 = sel_getUid("setOutputEvent:");
              if (class_respondsToSelector((Class)v30, v50))
                Private->_service.objc.setOutputEvent = sel_getUid("setOutputEvent:");
              v51 = 1;
              goto LABEL_80;
            }
            v77 = _IOHIDLogCategory(0);
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
              _IOHIDServiceCreate_cold_3(v77, v78, v79, v80, v81, v82, v83, v84);
          }
          else
          {
            v69 = _IOHIDLogCategory(0);
            if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
              _IOHIDServiceCreate_cold_2(v69, v70, v71, v72, v73, v74, v75, v76);
          }
          CFRelease(v45);
        }
        else
        {
          v61 = _IOHIDLogCategory(0);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
            _IOHIDServiceCreate_cold_1(v61, v62, v63, v64, v65, v66, v67, v68);
        }
      }
    }
    v51 = 0;
    goto LABEL_80;
  }
  plugInInterface = Private->_service.plugInInterface;
  QueryInterface = (*plugInInterface)->QueryInterface;
  v54 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
  v55 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x6Fu, 0xE2u, 0x2Au, 0xBFu, 0x68u, 0xB9u, 0x11u, 0xDBu, 0xA7u, 0x1Fu, 0, 0x16u, 0xCBu, 0xC1u, 0x10u, 0xF7u);
  v56 = CFUUIDGetUUIDBytes(v55);
  if (!((unsigned int (*)(IOCFPlugInInterfaceStruct **, _QWORD, _QWORD, IOHIDServiceInterface2 ***))QueryInterface)(plugInInterface, *(_QWORD *)&v56.byte0, *(_QWORD *)&v56.byte8, &Private->_service.serviceInterface2))goto LABEL_78;
  Private->_service.serviceInterface2 = 0;
  v57 = Private->_service.plugInInterface;
  v58 = (*v57)->QueryInterface;
  v59 = CFUUIDGetConstantUUIDWithBytes(v54, 0xD1u, 0x2Cu, 0x83u, 0x3Fu, 0xB1u, 0x5Bu, 0x11u, 0xDAu, 0x90u, 0x2Du, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  v60 = CFUUIDGetUUIDBytes(v59);
  if (!((unsigned int (*)(IOCFPlugInInterfaceStruct **, _QWORD, _QWORD, IOHIDServiceInterface ***))v58)(v57, *(_QWORD *)&v60.byte0, *(_QWORD *)&v60.byte8, &Private->_service.serviceInterface))goto LABEL_78;
  v51 = 0;
  Private->_service.serviceInterface = 0;
LABEL_79:
  LODWORD(v88) = -1;
LABEL_80:
  if (Private->_service.serviceInterface2)
    goto LABEL_90;
  if (Private->_service.serviceInterface)
    v51 = 1;
  if ((v51 & 1) != 0)
  {
LABEL_90:
    if (__IOHIDServiceInit((uint64_t)Private, entryID))
    {
      _IOHIDDebugTrace(8257, 2, (uint64_t)Private, entryID, 0, 0);
      return Private;
    }
  }
  else
  {
    v85 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)context = 134218752;
      *(_QWORD *)&context[4] = entryID;
      *(_WORD *)&context[12] = 1024;
      *(_DWORD *)&context[14] = v86;
      *(_WORD *)&context[18] = 1024;
      *(_DWORD *)&context[20] = theScore;
      LOWORD(v96) = 1024;
      *(_DWORD *)((char *)&v96 + 2) = v88;
      _os_log_error_impl(&dword_18AAAF000, v85, OS_LOG_TYPE_ERROR, "0x%llx _IOHIDServiceCreate failed to load service plugin ret: 0x%x score: %d objcScore: %d", context, 0x1Eu);
    }
  }
LABEL_7:
  CFRelease(Private);
  _IOHIDDebugTrace(8257, 2, entryID, 0, 0, 0);
  return 0;
}

uint64_t __IOHIDServiceRunLoopCompatibilityThread()
{
  _opaque_pthread_t *v0;
  NSObject *v1;
  CFRunLoopSourceRef v2;
  __CFRunLoopSource *v3;
  __CFRunLoop *Current;
  const __CFString *v5;
  int v7;
  sched_param v8;
  CFRunLoopSourceContext context;
  uint8_t buf[4];
  int sched_priority;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(&context, 0, sizeof(context));
  v8 = 0;
  v7 = 0;
  pthread_setname_np("IOHIDService - RunLoopCompatibilityThread");
  v0 = pthread_self();
  if (!pthread_getschedparam(v0, &v7, &v8))
  {
    v1 = _IOHIDLog();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      sched_priority = v8.sched_priority;
      v12 = 1024;
      v13 = v7;
      _os_log_impl(&dword_18AAAF000, v1, OS_LOG_TYPE_DEFAULT, "IOHIDService compatibility thread running at priority %d and schedule %d.", buf, 0xEu);
    }
  }
  v2 = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &context);
  if (v2)
  {
    v3 = v2;
    Current = CFRunLoopGetCurrent();
    v5 = (const __CFString *)*MEMORY[0x1E0C9B280];
    qword_1EDF7B4F0 = (uint64_t)Current;
    *(_QWORD *)algn_1EDF7B4F8 = v5;
    CFRunLoopAddSource(Current, v3, v5);
    pthread_mutex_lock(&stru_1EDF7B500);
    pthread_cond_signal(&stru_1EDF7B540);
    pthread_mutex_unlock(&stru_1EDF7B500);
    CFRunLoopRun();
    CFRunLoopRemoveSource((CFRunLoopRef)qword_1EDF7B4F0, v3, *(CFRunLoopMode *)algn_1EDF7B4F8);
    CFRelease(v3);
  }
  return 0;
}

CFMutableDictionaryRef _IOHIDServiceCopyPropertiesForClient(uint64_t a1, const __CFArray *a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v7;
  _QWORD v9[7];

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = Mutable;
  if (Mutable)
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = ___IOHIDServiceCopyPropertiesForClient_block_invoke;
    v9[3] = &__block_descriptor_tmp_45_0;
    v9[4] = a1;
    v9[5] = a3;
    v9[6] = Mutable;
    _IOHIDCFArrayApplyBlock(a2, v9);
    if (!CFDictionaryGetCount(v7))
    {
      CFRelease(v7);
      return 0;
    }
  }
  return v7;
}

__CFArray *_IOHIDServiceCopyFilterDebugInfoForClient(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  const void *ValueAtIndex;
  __CFDictionary *v12;
  __CFDictionary *v13;
  uint64_t v14;
  uint64_t v16;
  _OWORD v17[5];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v16, v17);
  ++**(_DWORD **)(a1 + 72);
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 256));
    if (Count >= 1)
    {
      v7 = Count;
      v8 = 0;
      v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), v8);
        v12 = IOHIDServiceFilterCopyPropertyForClient((uint64_t)ValueAtIndex, CFSTR("ServiceFilterDebug"), a2);
        if (v12)
          goto LABEL_8;
        v13 = CFDictionaryCreateMutable(v4, 0, v9, v10);
        if (v13)
          break;
LABEL_9:
        if (v7 == ++v8)
          goto LABEL_10;
      }
      v12 = v13;
      CFDictionaryAddValue(v13, CFSTR("Class"), CFSTR("Unknown"));
LABEL_8:
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      goto LABEL_9;
    }
  }
LABEL_10:
  v14 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v14)
  {
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v16, v17);
  }
  return Mutable;
}

uint64_t IOHIDServiceCopyMatchingEvent(uint64_t a1, CFDictionaryRef theDict, const void *a3)
{
  uint64_t v6;
  const __CFNumber *Value;
  const __CFNumber *v8;
  CFTypeID v9;
  const void *v10;
  const void *v11;
  CFTypeID v12;
  CFAllocatorRef v13;
  int v14;
  uint64_t v15;
  const void *v16;
  void *v17;
  id v18;
  uint64_t v19;
  uint64_t (*v20)(_QWORD, _QWORD, CFDictionaryRef);
  uint64_t v21;
  const __CFNumber *v22;
  uint64_t v23;
  const __CFArray *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD v28[8];
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int valuePtr;
  _OWORD v36[5];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  v31 = 0;
  v32 = &v31;
  v33 = 0x2000000000;
  v34 = 0;
  if (!theDict || (v6 = *(_QWORD *)(a1 + 32)) == 0 || !*(_QWORD *)(*(_QWORD *)v6 + 88))
  {
LABEL_9:
    v14 = 0;
    v8 = 0;
    goto LABEL_10;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("EventType"));
  v8 = Value;
  if (Value)
  {
    v9 = CFGetTypeID(Value);
    if (v9 == CFNumberGetTypeID())
    {
      v10 = CFDictionaryGetValue(theDict, CFSTR("MatchingEvent"));
      if (v10)
      {
        v11 = v10;
        v12 = CFGetTypeID(v10);
        if (v12 == CFDataGetTypeID())
        {
          CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
          v13 = CFGetAllocator(a3);
          v8 = (const __CFNumber *)IOHIDEventCreateWithDataInternal(v13, v11);
          v14 = 1;
          goto LABEL_10;
        }
      }
    }
    goto LABEL_9;
  }
  v14 = 0;
LABEL_10:
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v30, v36);
  ++**(_DWORD **)(a1 + 72);
  if (v14)
  {
    v15 = (*(uint64_t (**)(_QWORD, _QWORD, const __CFNumber *, _QWORD))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32), valuePtr, v8, 0);
LABEL_13:
    v16 = (const void *)v15;
    goto LABEL_21;
  }
  v17 = *(void **)(a1 + 480);
  if (!v17)
  {
    v19 = *(_QWORD *)(a1 + 360);
    if (!v19 || (v20 = *(uint64_t (**)(_QWORD, _QWORD, CFDictionaryRef))(v19 + 80)) == 0)
    {
      v16 = 0;
      goto LABEL_21;
    }
    v15 = v20(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), theDict);
    goto LABEL_13;
  }
  v18 = objc_msgSend(v17, *(SEL *)(a1 + 512), theDict, a3);
  v16 = v18;
  if (v18)
    CFRetain(v18);
LABEL_21:
  v21 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v21)
  {
    --*(_DWORD *)v21;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v30, v36);
  }
  if (v16)
  {
    v32[3] = (uint64_t)v16;
    if (!IOHIDEventGetSenderID((uint64_t)v16))
    {
      v22 = *(const __CFNumber **)(a1 + 48);
      *(_QWORD *)&v36[0] = 0;
      if (v22)
      {
        CFNumberGetValue(v22, kCFNumberSInt64Type, v36);
        v23 = *(_QWORD *)&v36[0];
      }
      else
      {
        v23 = 0;
      }
      IOHIDEventSetSenderID((uint64_t)v16, v23);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v30, v36);
    ++**(_DWORD **)(a1 + 72);
    v24 = *(const __CFArray **)(a1 + 248);
    v28[0] = MEMORY[0x1E0C809B0];
    v28[1] = 0x40000000;
    v28[2] = __IOHIDServiceCopyMatchingEvent_block_invoke;
    v28[3] = &unk_1E2002BE8;
    v29 = v14;
    v28[4] = &v31;
    v28[5] = v16;
    v28[6] = a3;
    v28[7] = theDict;
    _IOHIDCFArrayApplyBlock(v24, v28);
    v25 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)v25)
    {
      --*(_DWORD *)v25;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v25 + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v30, v36);
    }
    if (!v32[3])
      CFRelease(v16);
  }
  if (v8)
    CFRelease(v8);
  v26 = v32[3];
  _Block_object_dispose(&v31, 8);
  return v26;
}

uint64_t IOHIDServiceSetOutputEvent(_QWORD *a1, void *a2)
{
  const __CFArray *v4;
  uint64_t v5;
  uint64_t (*v6)(void);
  id v7;
  uint64_t v8;
  uint64_t (*v9)(_QWORD, _QWORD, void *);
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v15;
  _OWORD v16[5];
  uint64_t v17;
  CFRange v18;

  v17 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v15, v16);
  ++*(_DWORD *)a1[9];
  v4 = (const __CFArray *)a1[32];
  v18.length = CFArrayGetCount(v4);
  v18.location = 0;
  CFArrayApplyFunction(v4, v18, (CFArrayApplierFunction)__FilterFunctionSetOutputEvent, a2);
  v5 = a1[4];
  if (v5)
  {
    v6 = *(uint64_t (**)(void))(*(_QWORD *)v5 + 96);
    if (v6)
    {
      v7 = (id)v6();
LABEL_11:
      v10 = (uint64_t)v7;
      goto LABEL_12;
    }
  }
  v8 = a1[45];
  if (v8)
  {
    v9 = *(uint64_t (**)(_QWORD, _QWORD, void *))(v8 + 72);
    if (v9)
    {
      v7 = (id)v9(a1[43], a1[44], a2);
      goto LABEL_11;
    }
  }
  v10 = 3758097095;
  v11 = (void *)a1[60];
  if (v11)
  {
    v12 = (const char *)a1[72];
    if (v12)
    {
      v7 = objc_msgSend(v11, v12, a2);
      goto LABEL_11;
    }
  }
LABEL_12:
  v13 = a1[9];
  if (*(_DWORD *)v13)
  {
    --*(_DWORD *)v13;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v15, v16);
  }
  return v10;
}

uint64_t IOHIDServiceSetElementValue(uint64_t a1, int a2, char a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  CFAllocatorRef v12;
  uint64_t v13;
  HIDEvent *LEDEvent;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  unint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = 3758097095;
  v9 = mach_absolute_time();
  if (a2 == 8)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v22, buf);
    ++**(_DWORD **)(a1 + 72);
    v10 = 1 << (a3 - 1);
    if (a4)
      v11 = *(_DWORD *)(a1 + 152) | v10;
    else
      v11 = *(_DWORD *)(a1 + 152) & ~v10;
    *(_DWORD *)(a1 + 152) = v11;
    v12 = CFGetAllocator((CFTypeRef)a1);
    v13 = mach_absolute_time();
    LEDEvent = IOHIDEventCreateLEDEvent((uint64_t)v12, v13, *(_DWORD *)(a1 + 152), a3, a4, 0);
    v15 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)v15)
    {
      --*(_DWORD *)v15;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v22, buf);
    }
    if (LEDEvent)
    {
      v8 = IOHIDServiceSetOutputEvent((_QWORD *)a1, LEDEvent);
      CFRelease(LEDEvent);
    }
  }
  v16 = mach_absolute_time();
  v17 = _IOHIDGetTimestampDelta(v16, v9, 1u);
  if (v17 > *(_QWORD *)(a1 + 392))
  {
    v18 = v17;
    *(_QWORD *)(a1 + 392) = v17;
    if (v17 >= 0x2FAF081)
    {
      v19 = _IOHIDLogCategory(6u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        v20 = *(_QWORD *)(a1 + 400);
        *(_DWORD *)buf = 134218240;
        v24 = v20;
        v25 = 2048;
        v26 = v18;
        _os_log_impl(&dword_18AAAF000, v19, OS_LOG_TYPE_INFO, "0x%llx: IOHIDServiceSetElementValue time:%lluns", buf, 0x16u);
      }
    }
  }
  return v8;
}

uint64_t __IOHIDServiceEventCompatibilityCallback(uint64_t a1, uint64_t a2, uint64_t a3, HIDEvent *a4)
{
  if (a1)
  {
    if (a4)
      return __IOHIDServiceEventCallback(a1, a2, a3, a4);
  }
  return a1;
}

_QWORD *IOHIDServiceCreatePropertyChangedNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;
  _OWORD v13[5];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 224) & 1) != 0)
    return 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v12, v13);
  ++**(_DWORD **)(a1 + 72);
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDServiceNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 112), v9);
  v10 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v10)
  {
    --*(_DWORD *)v10;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v12, v13);
  }
  return v9;
}

void __IOHIDServiceCompleteEventsInProgressApplier(const __CFNumber *a1, const void *a2)
{
  __int16 v3;
  __int16 v4;
  CFAllocatorRef v5;
  uint64_t v6;
  HIDEvent *KeyboardEvent;
  uint64_t v8;
  uint64_t v9;
  HIDEvent *v10;
  uint64_t valuePtr;

  valuePtr = 0;
  CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
  v4 = valuePtr;
  v3 = WORD2(valuePtr);
  v5 = CFGetAllocator(a2);
  v6 = mach_absolute_time();
  KeyboardEvent = IOHIDEventCreateKeyboardEvent((uint64_t)v5, v6, v3, v4, 0, 0x800000);
  if (KeyboardEvent)
  {
    v10 = KeyboardEvent;
    __IOHIDServiceEventCallback((uint64_t)a2, v8, v9, KeyboardEvent);
    CFRelease(v10);
  }
}

void __IOHIDServiceHandleCancelTimerTimeout(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  CFStringRef v4;
  NSObject *v5;
  const __CFArray *v6;
  _QWORD v7[5];

  v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    __IOHIDServiceHandleCancelTimerTimeout_cold_2(a1, v2, v3);
  if (*(_BYTE *)(a1 + 440))
  {
    v4 = CFCopyDescription(*(CFTypeRef *)(a1 + 480));
    v5 = _IOHIDLogCategory(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      if (!v4)
        goto LABEL_7;
      goto LABEL_6;
    }
    __IOHIDServiceHandleCancelTimerTimeout_cold_1();
    if (v4)
LABEL_6:
      CFRelease(v4);
  }
LABEL_7:
  if (*(_DWORD *)(a1 + 444))
  {
    v6 = *(const __CFArray **)(a1 + 256);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = ____IOHIDServiceHandleCancelTimerTimeout_block_invoke;
    v7[3] = &__block_descriptor_tmp_63;
    v7[4] = a1;
    _IOHIDCFArrayApplyBlock(v6, v7);
  }
}

uint64_t IOHIDServiceGetService(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

__CFDictionary *_IOHIDServiceCopyServiceRecordForClient(_DWORD *a1, CFTypeRef cf)
{
  CFTypeID v4;
  __CFDictionary *v5;
  __CFArray *v6;
  __CFArray *v7;
  CFMutableArrayRef v8;
  CFMutableArrayRef v9;
  CFMutableDictionaryRef v10;
  CFMutableDictionaryRef v11;
  CFMutableDictionaryRef v12;
  CFMutableDictionaryRef v13;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == IOHIDEventSystemConnectionGetTypeID()
      && !IOHIDServiceCheckEntitlements((uint64_t)a1, (uint64_t)cf))
    {
      return 0;
    }
  }
  v5 = _IOHIDServiceCopyServiceInfoForClient(a1, cf);
  if (v5)
  {
    v6 = _IOHIDServiceCopyFilterDebugInfoForClient((uint64_t)a1, (uint64_t)cf);
    if (v6)
    {
      v7 = v6;
      CFDictionaryAddValue(v5, CFSTR("ServiceFilterDebug"), v6);
      CFRelease(v7);
    }
    v8 = _IOHIDServiceCopyEventLog(a1);
    if (v8)
    {
      v9 = v8;
      CFDictionaryAddValue(v5, CFSTR("EventLog"), v8);
      CFRelease(v9);
    }
    v10 = _IOHIDServiceCopyEventCounts(a1);
    if (v10)
    {
      v11 = v10;
      CFDictionaryAddValue(v5, CFSTR("EventTypeCounts"), v10);
      CFRelease(v11);
    }
    v12 = _IOHIDServiceCopyConnectionIntervals((uint64_t)a1);
    if (v12)
    {
      v13 = v12;
      CFDictionaryAddValue(v5, CFSTR("PropertyCache"), v12);
      CFRelease(v13);
    }
    _IOHIDServiceSetMiscDebugDebugInfo((uint64_t)a1, v5, (uint64_t)cf);
  }
  return v5;
}

__CFDictionary *_IOHIDServiceCopyServiceInfoForClient(_DWORD *cf, const void *a2)
{
  io_registry_entry_t v4;
  const __CFAllocator *v5;
  __CFDictionary *Mutable;
  const __CFAllocator *v7;
  CFStringEncoding SystemEncoding;
  CFStringRef v9;
  CFStringRef v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  uint64_t i;
  __CFString *v17;
  const void *v18;
  const void *v19;
  uint64_t EventDeadlineForClient;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  const __CFAllocator *v24;
  CFNumberRef v25;
  CFNumberRef v26;
  const void *v27;
  uint64_t valuePtr;
  char name[136];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  memset(name, 0, 128);
  valuePtr = 0;
  v4 = cf[4];
  if (v4 && IOObjectRetain(cf[4]))
    v4 = 0;
  v5 = CFGetAllocator(cf);
  Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    if (v4)
    {
      IORegistryEntryGetName(v4, name);
      if (!name[0])
        IOObjectGetClass(v4, name);
      v7 = CFGetAllocator(cf);
      SystemEncoding = CFStringGetSystemEncoding();
      v9 = CFStringCreateWithCString(v7, name, SystemEncoding);
      if (v9)
      {
        v10 = v9;
        CFDictionarySetValue(Mutable, CFSTR("IOClass"), v9);
        CFRelease(v10);
      }
    }
    v11 = (const void *)*((_QWORD *)cf + 6);
    if (v11)
      CFDictionarySetValue(Mutable, CFSTR("IORegistryEntryID"), v11);
    v12 = (const void *)*MEMORY[0x1E0C9AE50];
    v13 = (const void *)*MEMORY[0x1E0C9AE40];
    if (cf[71])
      v14 = (const void *)*MEMORY[0x1E0C9AE50];
    else
      v14 = (const void *)*MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(Mutable, CFSTR("Built-In"), v14);
    if (cf[76])
      v15 = v12;
    else
      v15 = v13;
    CFDictionarySetValue(Mutable, CFSTR("ProtectedAccess"), v15);
    for (i = 0; i != 8; ++i)
    {
      v17 = __debugKeys_0[i];
      v18 = (const void *)_IOHIDServiceCopyPropertyForClient((uint64_t)cf, v17, a2);
      if (v18)
      {
        v19 = v18;
        CFDictionarySetValue(Mutable, v17, v18);
        CFRelease(v19);
      }
    }
    EventDeadlineForClient = _IOHIDServiceGetEventDeadlineForClient((uint64_t)cf, a2, 0);
    valuePtr = EventDeadlineForClient;
    if (EventDeadlineForClient)
    {
      v21 = EventDeadlineForClient;
      v22 = mach_absolute_time();
      v23 = v21 - v22;
      if (v21 < v22)
        v23 = 0;
      if (v21 > v22)
        v23 /= 0x3E8uLL;
      valuePtr = v23;
      v24 = CFGetAllocator(cf);
      v25 = CFNumberCreate(v24, kCFNumberSInt64Type, &valuePtr);
      if (v25)
      {
        v26 = v25;
        CFDictionarySetValue(Mutable, CFSTR("NextEventTimeStampDelta"), v25);
        CFRelease(v26);
      }
    }
    v27 = (const void *)*((_QWORD *)cf + 8);
    if (v27)
      CFDictionarySetValue(Mutable, CFSTR("ServiceEntitlements"), v27);
  }
  if (v4)
    IOObjectRelease(v4);
  return Mutable;
}

CFMutableArrayRef _IOHIDServiceCopyEventLog(_QWORD *a1)
{
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  const __CFData *v4;
  uint64_t v5;
  _QWORD v7[5];
  uint64_t v8;
  _OWORD v9[5];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!a1[51])
    return 0;
  v2 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v2, 50, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
    ++*(_DWORD *)a1[9];
    v4 = (const __CFData *)a1[51];
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = ___IOHIDServiceCopyEventLog_block_invoke;
    v7[3] = &__block_descriptor_tmp_117;
    v7[4] = a1;
    _IOHIDSimpleQueueApplyBlock(v4, (uint64_t)v7, (uint64_t)Mutable);
    v5 = a1[9];
    if (*(_DWORD *)v5)
    {
      --*(_DWORD *)v5;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
    }
  }
  return Mutable;
}

CFMutableDictionaryRef _IOHIDServiceCopyConnectionIntervals(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  uint64_t v3;
  uint64_t v5;
  _OWORD v6[5];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v5, v6);
    ++**(_DWORD **)(a1 + 72);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__CopyConnectionCache, Mutable);
    v3 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)v3)
    {
      --*(_DWORD *)v3;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8)))
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v5, v6);
    }
    if (!CFDictionaryGetCount(Mutable))
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

void _IOHIDServiceSetMiscDebugDebugInfo(uint64_t a1, void *a2, uint64_t a3)
{
  const void *v6;
  const void *v7;
  const __CFAllocator *v8;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v10;
  const __CFSet *v11;
  uint64_t v12;
  const __CFSet *v13;
  const __CFSet *v14;
  const __CFSet *v15;
  const __CFAllocator *v16;
  CFMutableArrayRef v17;
  __CFArray *v18;
  const __CFArray *v19;
  const __CFArray *v20;
  CFIndex v21;
  const void *ValueAtIndex;
  uint64_t UUID;
  const __CFString *v24;
  _QWORD v25[5];
  _QWORD context[5];

  _IOHIDDictionaryAddSInt64(a2, CFSTR("MaxPropertyGetTime"), *(_QWORD *)(a1 + 376));
  _IOHIDDictionaryAddSInt64(a2, CFSTR("MaxPropertyGetTime"), *(_QWORD *)(a1 + 384));
  _IOHIDDictionaryAddSInt32(a2, CFSTR("propertyCacheHit"), *(_DWORD *)(a1 + 320));
  _IOHIDDictionaryAddSInt32(a2, CFSTR("propertyCacheMiss"), *(_DWORD *)(a1 + 324));
  _IOHIDDictionaryAddSInt32(a2, CFSTR("elementSetTime"), *(_DWORD *)(a1 + 392));
  v6 = (const void *)_IOHIDServiceCopyProperyFromPlugin(a1, (uint64_t)CFSTR("ServicePluginDebug"), a3);
  if (v6)
  {
    v7 = v6;
    CFDictionarySetValue((CFMutableDictionaryRef)a2, CFSTR("ServicePluginDebug"), v6);
    CFRelease(v7);
  }
  v8 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v10 = Mutable;
    v11 = (const __CFSet *)_IOHIDServiceCopyConnections(a1, 0);
    v12 = MEMORY[0x1E0C809B0];
    if (v11)
    {
      v13 = v11;
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 0x40000000;
      context[2] = ___IOHIDServiceSetMiscDebugDebugInfo_block_invoke;
      context[3] = &__block_descriptor_tmp_131;
      context[4] = v10;
      _IOHIDCFSetApplyBlock(v11, context);
      CFRelease(v13);
    }
    v14 = (const __CFSet *)_IOHIDServiceCopyConnections(a1, 2);
    if (v14)
    {
      v15 = v14;
      v25[0] = v12;
      v25[1] = 0x40000000;
      v25[2] = ___IOHIDServiceSetMiscDebugDebugInfo_block_invoke_2;
      v25[3] = &__block_descriptor_tmp_132;
      v25[4] = v10;
      _IOHIDCFSetApplyBlock(v14, v25);
      CFRelease(v15);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)a2, CFSTR("Connections"), v10);
    CFRelease(v10);
  }
  v16 = CFGetAllocator((CFTypeRef)a1);
  v17 = CFArrayCreateMutable(v16, 0, MEMORY[0x1E0C9B378]);
  if (v17)
  {
    v18 = v17;
    v19 = (const __CFArray *)_IOHIDServiceCopyConnections(a1, 1);
    if (v19)
    {
      v20 = v19;
      if (CFArrayGetCount(v19) >= 1)
      {
        v21 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v20, v21);
          UUID = IOHIDEventSystemConnectionGetUUID((uint64_t)ValueAtIndex);
          if (UUID)
            v24 = (const __CFString *)UUID;
          else
            v24 = CFSTR("unknown");
          CFArrayAppendValue(v18, v24);
          ++v21;
        }
        while (v21 < CFArrayGetCount(v20));
      }
      CFRelease(v20);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)a2, CFSTR("Filters"), v18);
    CFRelease(v18);
  }
}

void __CopyConnectionCache(const __CFString *cf, uint64_t a2, __CFDictionary *a3)
{
  const __CFString *UUID;
  CFTypeID v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  const __CFString *v9;

  UUID = cf;
  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == IOHIDEventSystemConnectionGetTypeID())
      UUID = (const __CFString *)IOHIDEventSystemConnectionGetUUID((uint64_t)UUID);
    else
      UUID = 0;
  }
  v7 = IOHIDServiceConnectionCacheCopyDebugInfo(a2);
  if (v7)
  {
    v8 = v7;
    if (UUID)
      v9 = UUID;
    else
      v9 = CFSTR("0");
    CFDictionarySetValue(a3, v9, v7);
    CFRelease(v8);
  }
}

uint64_t _IOHIDServiceCopyProperyFromPlugin(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t (*v7)(void);
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(void);
  id v11;
  uint64_t v12;
  uint64_t (*v13)(_QWORD, _QWORD, uint64_t);
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v18;
  _OWORD v19[5];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 72) + 8)))
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v18, v19);
  ++**(_DWORD **)(a1 + 72);
  v6 = *(_QWORD *)(a1 + 32);
  if (v6)
  {
    v7 = *(uint64_t (**)(void))(*(_QWORD *)v6 + 48);
    if (v7)
    {
      v8 = v7();
LABEL_11:
      v14 = v8;
      goto LABEL_17;
    }
  }
  v9 = *(_QWORD *)(a1 + 24);
  if (v9 && (v10 = *(uint64_t (**)(void))(*(_QWORD *)v9 + 48)) != 0)
  {
    v11 = (id)v10();
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 360);
    if (v12)
    {
      v13 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t))(v12 + 24);
      if (v13)
      {
        v8 = v13(*(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), a2);
        goto LABEL_11;
      }
    }
    v15 = *(void **)(a1 + 480);
    if (!v15)
    {
      v14 = 0;
      goto LABEL_17;
    }
    v11 = objc_msgSend(v15, *(SEL *)(a1 + 496), a2, a3);
  }
  v14 = (uint64_t)v11;
  if (v11)
    CFRetain(v11);
LABEL_17:
  v16 = *(_QWORD *)(a1 + 72);
  if (*(_DWORD *)v16)
  {
    --*(_DWORD *)v16;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8)))
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v18, v19);
  }
  return v14;
}

void IOHIDServiceRequestTerminate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  const __CFAllocator *v4;
  const __CFSet *Copy;
  NSObject *v6;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 400);
    *(_DWORD *)buf = 134217984;
    v9 = v3;
    _os_log_impl(&dword_18AAAF000, v2, OS_LOG_TYPE_DEFAULT, "0x%llx: IOHIDServiceRequestTerminate", buf, 0xCu);
  }
  *(_DWORD *)(a1 + 224) |= 1u;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
  v4 = CFGetAllocator(*(CFTypeRef *)(a1 + 120));
  Copy = CFSetCreateCopy(v4, *(CFSetRef *)(a1 + 120));
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
  if (Copy)
  {
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDServiceNotificationSetApplier, (void *)a1);
    CFRelease(Copy);
  }
  CFRetain((CFTypeRef)a1);
  v6 = *(NSObject **)(a1 + 80);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOHIDServiceRequestTerminate_block_invoke;
  block[3] = &__block_descriptor_tmp_137;
  block[4] = a1;
  dispatch_async(v6, block);
  _IOHIDServiceTerminate((_QWORD *)a1);
}

void __IOHIDServiceRequestTerminaitonNotificationRelease(uint64_t a1, uint64_t a2, const void *a3)
{
  os_unfair_lock_s *v5;

  v5 = (os_unfair_lock_s *)(a1 + 456);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 120), a3);
  os_unfair_lock_unlock(v5);
}

_QWORD *IOHIDServiceCreateRequestTerminationNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8;
  _QWORD *v9;

  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDServiceRequestTerminaitonNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 120), v9);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
  }
  return v9;
}

double OUTLINED_FUNCTION_1_5(_QWORD *a1, _OWORD *a2)
{
  double result;

  *a1 = 0;
  result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

void OUTLINED_FUNCTION_11(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

HIDSession *IOHIDSessionCreate(const __CFAllocator *a1)
{
  HIDSession *Private;
  NSObject *v3;
  os_signpost_id_t v4;
  NSObject *v5;
  unint64_t v6;
  NSObject *v7;
  __IOHIDSessionQueueContext *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v13;
  CFMutableArrayRef v14;
  CFMutableArrayRef v15;
  CFMutableDictionaryRef v16;
  CFMutableSetRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFMutableSetRef v20;
  NSObject *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFIndex v24;
  __CFBundle *ValueAtIndex;
  CFPlugInRef PlugIn;
  __CFBundle *v27;
  const __CFUUID *v28;
  const __CFArray *FactoriesForPlugInTypeInPlugIn;
  const __CFArray *v30;
  CFIndex v31;
  const __CFUUID *v32;
  const __CFURL *v33;
  const __CFURL *v34;
  NSObject *v35;
  const __CFArray *v36;
  const __CFArray *v37;
  CFIndex v38;
  __CFBundle *v39;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *v41;
  const void *Value;
  const void *v43;
  CFTypeID v44;
  const __CFString *v45;
  const void *v46;
  objc_class *DataPointerForName;
  objc_class *v48;
  CFURLRef v49;
  NSObject *v50;
  const void *v51;
  BOOL v52;
  char v53;
  NSObject *v54;
  NSObject *v55;
  NSObject *v56;
  NSObject *v57;
  NSObject *v58;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  os_signpost_id_t spid;
  const __CFAllocator *alloc;
  const void *v65;
  _QWORD handler[5];
  uint8_t v67[4];
  CFURLRef v68;
  __int16 v69;
  const __CFDictionary *v70;
  CFSetCallBacks buf;
  pthread_mutexattr_t v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v72.__sig = 0;
  *(_QWORD *)v72.__opaque = 0;
  Private = _IOHIDSessionCreatePrivate((uint64_t)a1);
  v3 = _IOHIDLog();
  v4 = os_signpost_id_make_with_pointer(v3, Private);
  v5 = _IOHIDLog();
  v6 = v4 - 1;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v7 = v5;
    if (os_signpost_enabled(v5))
    {
      LOWORD(buf.version) = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v7, OS_SIGNPOST_INTERVAL_BEGIN, v4, "IOHIDSessionCreate", (const char *)&unk_18AB567C9, (uint8_t *)&buf, 2u);
    }
  }
  if (!Private)
    goto LABEL_68;
  v8 = (__IOHIDSessionQueueContext *)malloc_type_calloc(1uLL, 0x48uLL, 0x10000400131AABDuLL);
  Private->_session.queueContext = v8;
  if (!v8)
    goto LABEL_68;
  if (pthread_mutexattr_init(&v72))
    __IOHIDServiceInit_cold_4(v67, &buf);
  pthread_mutexattr_settype(&v72, 2);
  if (pthread_mutex_init((pthread_mutex_t *)((char *)Private->_session.queueContext + 8), &v72))
    IOHIDSessionCreate_cold_3(v67, &buf);
  if (pthread_cond_init(&Private->_session.stateCondition, 0))
    IOHIDSessionCreate_cold_2(v67, &buf);
  if (pthread_mutexattr_destroy(&v72))
    IOHIDSessionCreate_cold_1(v67, &buf);
  v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v10 = hid_dispatch_queue_create_with_context_destructor("IOHIDSession - SessionEventDispatch", v9, kIOHIDServiceInterruptWorkloop, (uint64_t)__IOHIDSessionQueueWillExecute, (uint64_t)__IOHIDSessionQueueDidExecute, (uint64_t)Private->_session.queueContext, __IOHIDSessionQueueContextDestructor);
  Private->_session.eventDispatchQueueSession = (OS_dispatch_queue *)v10;
  if (!v10)
    goto LABEL_68;
  v11 = dispatch_source_create(MEMORY[0x1E0C80D70], 0, 0, v10);
  Private->_session.eventDispatchSource = (OS_dispatch_source *)v11;
  if (!v11)
    goto LABEL_68;
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __IOHIDSessionCreate_block_invoke;
  handler[3] = &__block_descriptor_tmp_14;
  handler[4] = Private;
  dispatch_source_set_event_handler(v11, handler);
  dispatch_resume((dispatch_object_t)Private->_session.eventDispatchSource);
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  Private->_session.eventDipsatchPending = Mutable;
  if (!Mutable)
    goto LABEL_68;
  v13 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  Private->_session.simpleSessionFilters = v13;
  if (!v13)
    goto LABEL_68;
  v14 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  Private->_session.sessionFilters = v14;
  if (!v14)
    goto LABEL_68;
  v15 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  Private->_session.pendingSessionFilters = v15;
  if (!v15)
    goto LABEL_68;
  v16 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Private->_session.properties = v16;
  if (!v16)
    goto LABEL_68;
  v17 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
  Private->_session.serviceSet = v17;
  if (!v17)
    goto LABEL_68;
  Private->_session.logLevel = 6;
  v18 = CFNumberCreate(a1, kCFNumberIntType, &Private->_session.logLevel);
  if (v18)
  {
    v19 = v18;
    CFDictionarySetValue(Private->_session.properties, CFSTR("LogLevel"), v18);
    CFRelease(v19);
  }
  buf = *(CFSetCallBacks *)byte_1E2002F28;
  v20 = CFSetCreateMutable(a1, 2, &buf);
  Private->_session.activityNotificationSet = v20;
  if (v20)
  {
    spid = v4;
    v21 = _IOHIDLog();
    if (os_signpost_enabled(v21))
    {
      *(_WORD *)v67 = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v21, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionCreate - Load bundles", (const char *)&unk_18AB567C9, v67, 2u);
    }
    v22 = (const __CFArray *)_IOHIDLoadBundles();
    if (v22)
    {
      v23 = v22;
      if (CFArrayGetCount(v22) >= 1)
      {
        v24 = 0;
        alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
        do
        {
          ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v23, v24);
          PlugIn = CFBundleGetPlugIn(ValueAtIndex);
          if (PlugIn)
          {
            v27 = PlugIn;
            v28 = CFUUIDGetConstantUUIDWithBytes(alloc, 0x7Fu, 0x1Au, 0x3Au, 0xE6u, 0x3Eu, 0x3Du, 0x47u, 0xAu, 0xBDu, 0x15u, 0xA2u, 0xDDu, 0x7Eu, 0x1Bu, 0xB7u, 0x19u);
            FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(v28, v27);
            if (FactoriesForPlugInTypeInPlugIn)
            {
              v30 = FactoriesForPlugInTypeInPlugIn;
              if (CFArrayGetCount(FactoriesForPlugInTypeInPlugIn) >= 1)
              {
                v31 = 0;
                do
                {
                  v32 = (const __CFUUID *)CFArrayGetValueAtIndex(v30, v31);
                  v33 = (const __CFURL *)IOHIDSessionFilterCreate(a1, ValueAtIndex, v32);
                  if (v33)
                  {
                    v34 = v33;
                    v35 = _IOHIDLogCategory(0);
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)v67 = 138412290;
                      v68 = v34;
                      _os_log_impl(&dword_18AAAF000, v35, OS_LOG_TYPE_DEFAULT, "Add session filter:%@", v67, 0xCu);
                    }
                    CFArrayAppendValue(Private->_session.simpleSessionFilters, v34);
                    if (!IOHIDSessionFilterGetType((uint64_t)v34))
                      CFArrayAppendValue(Private->_session.pendingSessionFilters, v34);
                    CFRelease(v34);
                  }
                  ++v31;
                }
                while (v31 < CFArrayGetCount(v30));
              }
              CFRelease(v30);
            }
          }
          ++v24;
        }
        while (v24 < CFArrayGetCount(v23));
      }
    }
    v36 = (const __CFArray *)_IOHIDLoadSessionFilterBundles();
    if (v36)
    {
      v37 = v36;
      if (CFArrayGetCount(v36) >= 1)
      {
        v38 = 0;
        v65 = (const void *)*MEMORY[0x1E0C9AE50];
        do
        {
          v39 = (__CFBundle *)CFArrayGetValueAtIndex(v37, v38);
          InfoDictionary = CFBundleGetInfoDictionary(v39);
          if (InfoDictionary)
          {
            v41 = InfoDictionary;
            Value = CFDictionaryGetValue(InfoDictionary, CFSTR("NSPrincipalClass"));
            if (Value)
            {
              v43 = Value;
              v44 = CFGetTypeID(Value);
              if (v44 == CFStringGetTypeID())
              {
                v45 = CFStringCreateWithFormat(a1, 0, CFSTR("OBJC_CLASS_$_%@"), v43);
                if (v45)
                {
                  v46 = v45;
                  DataPointerForName = (objc_class *)CFBundleGetDataPointerForName(v39, v45);
                  if (DataPointerForName)
                  {
                    v48 = DataPointerForName;
                    CFRelease(v46);
                    v49 = CFBundleCopyExecutableURL(v39);
                    v50 = _IOHIDLogCategory(0);
                    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)v67 = 138412290;
                      v68 = v49;
                      _os_log_impl(&dword_18AAAF000, v50, OS_LOG_TYPE_DEFAULT, "Loading session filter:%@", v67, 0xCu);
                    }
                    if (v49)
                      CFRelease(v49);
                    v51 = CFDictionaryGetValue(v41, CFSTR("LogIOHIDFilteredEvents"));
                    if (v51)
                      v52 = v51 == v65;
                    else
                      v52 = 1;
                    v53 = v52;
                    v46 = (const void *)IOHIDSessionFilterCreateWithClass(a1, v48, (uint64_t)Private, v53);
                    v54 = _IOHIDLogCategory(0);
                    v55 = v54;
                    if (!v46)
                    {
                      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)v67 = 138412290;
                        v68 = v41;
                        _os_log_error_impl(&dword_18AAAF000, v55, OS_LOG_TYPE_ERROR, "IOHIDSessionFilterCreateWithClass failed for bundle %@", v67, 0xCu);
                      }
                      goto LABEL_66;
                    }
                    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)v67 = 138412290;
                      v68 = (CFURLRef)v46;
                      _os_log_impl(&dword_18AAAF000, v55, OS_LOG_TYPE_DEFAULT, "Add session filter:%@", v67, 0xCu);
                    }
                    CFArrayAppendValue(Private->_session.simpleSessionFilters, v46);
                    CFArrayAppendValue(Private->_session.sessionFilters, v46);
                  }
                  else
                  {
                    v56 = _IOHIDLogCategory(0);
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)v67 = 138412546;
                      v68 = (CFURLRef)v46;
                      v69 = 2112;
                      v70 = v41;
                      _os_log_error_impl(&dword_18AAAF000, v56, OS_LOG_TYPE_ERROR, "IOHIDSessionCreate failed to find symbol %@ for bundle %@", v67, 0x16u);
                    }
                  }
                  CFRelease(v46);
                }
              }
            }
          }
LABEL_66:
          ++v38;
        }
        while (v38 < CFArrayGetCount(v37));
      }
      v60 = _IOHIDLog();
      if (os_signpost_enabled(v60))
      {
        *(_WORD *)v67 = 0;
        _os_signpost_emit_with_name_impl(&dword_18AAAF000, v60, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionCreate - Load bundles", (const char *)&unk_18AB567C9, v67, 2u);
      }
      v61 = _IOHIDLog();
      if (v6 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v62 = v61;
        if (os_signpost_enabled(v61))
        {
          *(_WORD *)v67 = 0;
          _os_signpost_emit_with_name_impl(&dword_18AAAF000, v62, OS_SIGNPOST_INTERVAL_END, spid, "IOHIDSessionCreate", (const char *)&unk_18AB567C9, v67, 2u);
        }
      }
    }
  }
  else
  {
LABEL_68:
    v57 = _IOHIDLog();
    if (v6 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v58 = v57;
      if (os_signpost_enabled(v57))
      {
        LOWORD(buf.version) = 0;
        _os_signpost_emit_with_name_impl(&dword_18AAAF000, v58, OS_SIGNPOST_INTERVAL_END, v4, "IOHIDSessionCreate", (const char *)&unk_18AB567C9, (uint8_t *)&buf, 2u);
      }
    }
    if (Private)
    {
      CFRelease(Private);
      return 0;
    }
  }
  return Private;
}

uint64_t __IOHIDSessionQueueWillExecute(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  _OWORD v4[5];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if ((_DWORD)result)
    __IOHIDServiceQueueWillExecute_cold_1(&v3, v4);
  ++*(_DWORD *)a1;
  return result;
}

uint64_t __IOHIDSessionQueueDidExecute(uint64_t result)
{
  uint64_t v1;
  _OWORD v2[5];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDServiceQueueDidExecute_cold_1(&v1, v2);
  }
  return result;
}

void __IOHIDSessionQueueContextDestructor(uint64_t a1)
{
  if (a1)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
    free((void *)a1);
  }
}

uint64_t _IOHIDSessionReleasePrivate(uint64_t a1)
{
  NSObject *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  uint8_t v15[16];

  v2 = _IOHIDLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)v15 = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionRelease", (const char *)&unk_18AB567C9, v15, 2u);
  }
  v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    IOHIDSessionClose(a1, v3);
    v4 = *(const void **)(a1 + 8);
    if (v4)
      CFRelease(v4);
  }
  v5 = *(const void **)(a1 + 136);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 120);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 160);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 152);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 144);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 112);
  if (v10)
    CFRelease(v10);
  v11 = *(NSObject **)(a1 + 104);
  if (v11)
    dispatch_release(v11);
  v12 = *(const void **)(a1 + 192);
  if (v12)
    CFRelease(v12);
  v13 = *(NSObject **)(a1 + 96);
  if (v13)
  {
    hid_dispatch_queue_release(v13);
    *(_QWORD *)(a1 + 96) = 0;
  }
  return pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
}

void IOHIDSessionClose(uint64_t a1, const void *a2)
{
  NSObject *v4;
  NSObject *v5;
  const __CFArray *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  const __CFArray *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD v17[5];
  uint64_t v18;
  uint8_t buf[88];
  uint64_t v20;
  CFRange v21;
  CFRange v22;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = _IOHIDLog();
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v4, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionClose", (const char *)&unk_18AB567C9, buf, 2u);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v18, buf);
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  if (*(const void **)(a1 + 8) == a2)
  {
    v5 = _IOHIDLog();
    if (os_signpost_enabled(v5))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v5, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionFiltersClose", (const char *)&unk_18AB567C9, buf, 2u);
    }
    v6 = *(const __CFArray **)(a1 + 152);
    v21.length = CFArrayGetCount(v6);
    v21.location = 0;
    CFArrayApplyFunction(v6, v21, (CFArrayApplierFunction)__FilterFunctionClose_0, (void *)a1);
    v7 = _IOHIDLog();
    if (os_signpost_enabled(v7))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v7, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionFiltersClose", (const char *)&unk_18AB567C9, buf, 2u);
    }
    v8 = _IOHIDLog();
    if (os_signpost_enabled(v8))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnregisterServices", (const char *)&unk_18AB567C9, buf, 2u);
    }
    CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)__UnregisterServiceFunction, (void *)a1);
    v9 = _IOHIDLog();
    if (os_signpost_enabled(v9))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v9, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnregisterServices", (const char *)&unk_18AB567C9, buf, 2u);
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 152));
    v10 = _IOHIDLog();
    if (os_signpost_enabled(v10))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v10, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnschedule", (const char *)&unk_18AB567C9, buf, 2u);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(&v18, buf);
    ++**(_DWORD **)(a1 + 32);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 104));
    v11 = *(const __CFArray **)(a1 + 152);
    v22.length = CFArrayGetCount(v11);
    v22.location = 0;
    CFArrayApplyFunction(v11, v22, (CFArrayApplierFunction)__FilterFunctionUnscheduleAsync_0, (void *)a1);
    v12 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)v12)
    {
      --*(_DWORD *)v12;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v18, buf);
    }
    v13 = _IOHIDLog();
    if (os_signpost_enabled(v13))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18AAAF000, v13, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnschedule", (const char *)&unk_18AB567C9, buf, 2u);
    }
    *(_DWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    CFRelease(a2);
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  v14 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)v14)
  {
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v18, buf);
  }
  CFRetain((CFTypeRef)a1);
  v15 = *(NSObject **)(a1 + 96);
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 0x40000000;
  v17[2] = __IOHIDSessionClose_block_invoke;
  v17[3] = &__block_descriptor_tmp_9;
  v17[4] = a1;
  dispatch_async(v15, v17);
  v16 = _IOHIDLog();
  if (os_signpost_enabled(v16))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v16, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionClose", (const char *)&unk_18AB567C9, buf, 2u);
  }
}

void __RegisterServiceWithSessionFunction(_QWORD *a1, uint64_t a2)
{
  const __CFAllocator *v4;
  __CFSet *MutableCopy;

  __RegisterServiceFunction(a1, a2);
  if (_IOHIDServiceGetOwner((uint64_t)a1) != a2)
  {
    v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 136));
    MutableCopy = CFSetCreateMutableCopy(v4, 0, *(CFSetRef *)(a2 + 136));
    CFRelease(*(CFTypeRef *)(a2 + 136));
    *(_QWORD *)(a2 + 136) = MutableCopy;
    CFSetRemoveValue(MutableCopy, a1);
  }
}

uint64_t IOHIDSessionOpen(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  dispatch_semaphore_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v18;
  __int128 buf;
  intptr_t (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v8 = _IOHIDLog();
  if (os_signpost_enabled(v8))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionOpen", (const char *)&unk_18AB567C9, (uint8_t *)&buf, 2u);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v18, &buf);
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  if (*(_DWORD *)(a1 + 88))
  {
    v9 = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = CFRetain(a2);
    *(_QWORD *)(a1 + 16) = a3;
    *(_QWORD *)(a1 + 24) = a4;
    v10 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)v10)
    {
      --*(_DWORD *)v10;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v18, &buf);
    }
    v11 = dispatch_semaphore_create(0);
    if (v11)
    {
      v12 = v11;
      v13 = *(NSObject **)(a1 + 96);
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 0x40000000;
      v20 = ____IOHIDSessionScheduleAsync_block_invoke;
      v21 = &__block_descriptor_tmp_28;
      v22 = a1;
      v23 = v12;
      dispatch_async(v13, &buf);
      dispatch_semaphore_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v12);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(&v18, &buf);
    ++**(_DWORD **)(a1 + 32);
    v9 = 1;
    *(_DWORD *)(a1 + 88) = 1;
    v14 = _IOHIDLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18AAAF000, v14, OS_LOG_TYPE_INFO, "Successfully opened the IOHIDSession", (uint8_t *)&buf, 2u);
    }
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  v15 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)v15)
  {
    --*(_DWORD *)v15;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v18, &buf);
  }
  v16 = _IOHIDLog();
  if (os_signpost_enabled(v16))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl(&dword_18AAAF000, v16, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionOpen", (const char *)&unk_18AB567C9, (uint8_t *)&buf, 2u);
  }
  return v9;
}

__CFArray *IOHIDSessionGetProperty(uint64_t a1, const void *a2)
{
  return _IOHIDSessionCopyPropertyForClient(a1, a2, (const void *)*MEMORY[0x1E0C9B0D0]);
}

uint64_t IOHIDSessionSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  return _IOHIDSessionSetPropertyForClient(a1, a2, a3, (const void *)*MEMORY[0x1E0C9B0D0]);
}

uint64_t __FunctionApplierForParameters(CFTypeRef cf1, uint64_t a2, _QWORD *a3)
{
  return _IOHIDSessionSetPropertyForClient(*a3, cf1);
}

uint64_t IOHIDSessionCopyEvent(uint64_t a1, int a2, uint64_t a3, int a4)
{
  const __CFSet *v8;
  uint64_t v9;
  uint64_t v11;
  _QWORD context[2];
  uint64_t v13;
  int v14;
  int v15;
  CFArrayRef v16;
  _OWORD v17[5];
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(context, v17);
  ++**(_DWORD **)(a1 + 32);
  context[0] = a1;
  context[1] = a3;
  v13 = 0;
  v14 = a2;
  v15 = a4;
  v16 = *(CFArrayRef *)(a1 + 152);
  v19.length = CFArrayGetCount(v16);
  v19.location = 0;
  CFArrayApplyFunction(v16, v19, (CFArrayApplierFunction)__FilterFunctionCopyEvent, context);
  v8 = 0;
  if (!v13)
    v8 = (const __CFSet *)CFRetain(*(CFTypeRef *)(a1 + 136));
  v9 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)v9)
  {
    --*(_DWORD *)v9;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8)))
      __IOHIDSessionCreate_block_invoke_cold_1(&v11, v17);
  }
  if (v8)
  {
    CFSetApplyFunction(v8, (CFSetApplierFunction)__CopyEventForObjectFunction, context);
    CFRelease(v8);
  }
  return v13;
}

uint64_t __FilterFunctionCopyEvent(uint64_t result, uint64_t a2)
{
  if (!*(_QWORD *)(a2 + 16))
  {
    result = IOHIDSessionFilterCopyEvent(result);
    *(_QWORD *)(a2 + 16) = result;
  }
  return result;
}

uint64_t __CopyEventForObjectFunction(uint64_t result, uint64_t *a2)
{
  uint64_t v3;
  CFTypeID v4;
  uint64_t v5;
  const __CFArray *v6;
  uint64_t v7;
  _QWORD context[3];
  _OWORD v9[5];
  uint64_t v10;
  CFRange v11;

  v10 = *MEMORY[0x1E0C80C00];
  if (!a2[2])
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = IOHIDServiceGetTypeID();
    if (v4 == result)
    {
      result = IOHIDServiceCopyEvent(v3, *((unsigned int *)a2 + 6), a2[1], *((unsigned int *)a2 + 7));
      a2[2] = result;
      if (result)
      {
        v5 = *a2;
        context[0] = v5;
        context[1] = v3;
        context[2] = result;
        if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(v5 + 32) + 8)))
          __IOHIDSessionCreate_block_invoke_cold_4(&v7, v9);
        ++**(_DWORD **)(v5 + 32);
        v6 = (const __CFArray *)a2[4];
        v11.length = CFArrayGetCount(v6);
        v11.location = 0;
        CFArrayApplyFunction(v6, v11, (CFArrayApplierFunction)__FilterFunctionFilterCopyEvent, context);
        result = *(_QWORD *)(v5 + 32);
        if (*(_DWORD *)result)
        {
          --*(_DWORD *)result;
          result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
          if ((_DWORD)result)
            __IOHIDSessionCreate_block_invoke_cold_1(&v7, v9);
        }
      }
    }
  }
  return result;
}

void _IOHIDSessionDispatchEvent(uint64_t a1, const void *a2)
{
  uint64_t TimeStampOfType;
  unsigned int TimeStampType;
  CFIndex Count;
  uint64_t v7;
  uint64_t v8;
  _OWORD v9[5];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  TimeStampOfType = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  TimeStampType = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8272, 0, TimeStampOfType, TimeStampType, 0, 0);
  if (a2)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(&v8, v9);
    ++**(_DWORD **)(a1 + 32);
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 112), a2);
    if (!Count)
      dispatch_source_merge_data(*(dispatch_source_t *)(a1 + 104), 1uLL);
    v7 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)v7)
    {
      --*(_DWORD *)v7;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v8, v9);
    }
  }
}

uint64_t __IOHIDSessionActivityNotificationRelease(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t result;
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
    __IOHIDSessionCreate_block_invoke_cold_4(&v6, v7);
  ++**(_DWORD **)(a1 + 32);
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 192), a3);
  result = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if ((_DWORD)result)
      __IOHIDSessionCreate_block_invoke_cold_1(&v6, v7);
  }
  return result;
}

_QWORD *_IOHIDSessionCreateActivityNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;
  _OWORD v13[5];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDSessionActivityNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 8)))
      __IOHIDSessionCreate_block_invoke_cold_4(&v12, v13);
    ++**(_DWORD **)(a1 + 32);
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 192), v9);
    v10 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)v10)
    {
      --*(_DWORD *)v10;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8)))
        __IOHIDSessionCreate_block_invoke_cold_1(&v12, v13);
    }
  }
  return v9;
}

uint64_t __FilterFunctionFilterCopyEvent(uint64_t a1, uint64_t a2)
{
  return IOHIDSessionFilterFilterCopyEvent(a1, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16));
}

uint64_t IOHIDEventQueueSuspend(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 152) = 1;
  while (!_IODataQueueDequeue(*(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 56), 0))
    ++*(_QWORD *)(a1 + 168);
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueResume(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 152) = 0;
  return os_unfair_recursive_lock_unlock();
}

void IOHIDEventQueueNotify(uint64_t a1)
{
  int v2;
  NSObject *v3;

  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 152))
  {
    v2 = _IODataQueueSendDataAvailableNotification(*(unsigned int **)(a1 + 16), (mach_msg_header_t *)(a1 + 60));
    os_unfair_recursive_lock_unlock();
    if (v2)
    {
      v3 = _IOHIDLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        IOHIDEventQueueNotify_cold_1();
    }
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

IOReturn IOPMCopyCPUPowerStatus(CFDictionaryRef *cpuPowerStatus)
{
  IOReturn v1;
  uint64_t (*v3)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, uint64_t);
  CFStringRef SCKeyForIOKitString;
  CFStringRef v6;
  uint64_t (*v7)(uint64_t, uint64_t);
  CFTypeID TypeID;

  v1 = -536870160;
  if (!cpuPowerStatus)
    return -536870206;
  v3 = _io_SCDynamicStoreCreate(*MEMORY[0x1E0C9AE00], (uint64_t)CFSTR("IOKit Power"), 0, 0);
  if (!v3)
    return -536870212;
  v4 = v3;
  SCKeyForIOKitString = createSCKeyForIOKitString(CFSTR("CPU_Power_Limits"));
  if (SCKeyForIOKitString)
  {
    v6 = SCKeyForIOKitString;
    v7 = _io_SCDynamicStoreCopyValue((uint64_t)v4, (uint64_t)SCKeyForIOKitString);
    *cpuPowerStatus = (CFDictionaryRef)v7;
    TypeID = CFDictionaryGetTypeID();
    if (v7 && CFGetTypeID(v7) == TypeID)
    {
      v1 = 0;
    }
    else if (*cpuPowerStatus)
    {
      CFRelease(*cpuPowerStatus);
      *cpuPowerStatus = 0;
    }
    CFRelease(v6);
  }
  else
  {
    v1 = -536870199;
  }
  CFRelease(v4);
  return v1;
}

CFStringRef createSCKeyForIOKitString(const void *a1)
{
  const __CFString *v2;

  if (CFEqual(a1, CFSTR("Thermal_Level_Warning")))
  {
    v2 = CFSTR("ThermalWarning");
    return _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("%@%@/%@"), CFSTR("State:"), CFSTR("/IOKit/Power"), v2);
  }
  if (CFEqual(a1, CFSTR("CPU_Power_Limits")))
  {
    v2 = CFSTR("CPUPower");
    return _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("%@%@/%@"), CFSTR("State:"), CFSTR("/IOKit/Power"), v2);
  }
  if (CFEqual(a1, CFSTR("Performance_Warning")))
  {
    v2 = CFSTR("PerformanceWarning");
    return _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("%@%@/%@"), CFSTR("State:"), CFSTR("/IOKit/Power"), v2);
  }
  return 0;
}

IOReturn IOPMGetThermalWarningLevel(uint32_t *thermalLevel)
{
  IOReturn v1;
  uint64_t (*v3)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, uint64_t);
  CFStringRef SCKeyForIOKitString;
  CFStringRef v6;
  uint64_t (*v7)(uint64_t, uint64_t);
  const __CFNumber *v8;
  CFTypeID TypeID;

  v1 = -536870160;
  if (!thermalLevel)
    return -536870206;
  v3 = _io_SCDynamicStoreCreate(*MEMORY[0x1E0C9AE00], (uint64_t)CFSTR("IOKit Power"), 0, 0);
  if (!v3)
    return -536870212;
  v4 = v3;
  SCKeyForIOKitString = createSCKeyForIOKitString(CFSTR("Thermal_Level_Warning"));
  if (SCKeyForIOKitString)
  {
    v6 = SCKeyForIOKitString;
    v7 = _io_SCDynamicStoreCopyValue((uint64_t)v4, (uint64_t)SCKeyForIOKitString);
    if (v7)
    {
      v8 = (const __CFNumber *)v7;
      TypeID = CFNumberGetTypeID();
      if (CFGetTypeID(v8) == TypeID)
      {
        CFNumberGetValue(v8, kCFNumberIntType, thermalLevel);
        v1 = 0;
      }
      CFRelease(v8);
    }
    CFRelease(v6);
  }
  else
  {
    v1 = -536870199;
  }
  CFRelease(v4);
  return v1;
}

uint64_t IOPMGetPerformanceWarningLevel(void *a1)
{
  uint64_t v1;
  uint64_t (*v3)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, uint64_t);
  CFStringRef SCKeyForIOKitString;
  CFStringRef v6;
  uint64_t (*v7)(uint64_t, uint64_t);
  const __CFNumber *v8;
  CFTypeID TypeID;

  v1 = 3758097136;
  if (!a1)
    return 3758097090;
  v3 = _io_SCDynamicStoreCreate(*MEMORY[0x1E0C9AE00], (uint64_t)CFSTR("IOKit Power"), 0, 0);
  if (!v3)
    return 3758097084;
  v4 = v3;
  SCKeyForIOKitString = createSCKeyForIOKitString(CFSTR("Performance_Warning"));
  if (SCKeyForIOKitString)
  {
    v6 = SCKeyForIOKitString;
    v7 = _io_SCDynamicStoreCopyValue((uint64_t)v4, (uint64_t)SCKeyForIOKitString);
    if (v7)
    {
      v8 = (const __CFNumber *)v7;
      TypeID = CFNumberGetTypeID();
      if (CFGetTypeID(v8) == TypeID)
      {
        CFNumberGetValue(v8, kCFNumberIntType, a1);
        v1 = 0;
      }
      CFRelease(v8);
    }
    CFRelease(v6);
  }
  else
  {
    v1 = 3758097097;
  }
  CFRelease(v4);
  return v1;
}

uint64_t IOUSBDeviceDataGetTypeID()
{
  uint64_t result;

  result = __kIOUSBDeviceDataTypeID;
  if (!__kIOUSBDeviceDataTypeID)
  {
    pthread_once(&__dataTypeInit, (void (*)(void))__IOUSBDeviceDataRegister);
    return __kIOUSBDeviceDataTypeID;
  }
  return result;
}

uint64_t __IOUSBDeviceDataRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOUSBDeviceDataTypeID = result;
  return result;
}

double IOUSBDeviceDataCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Instance;
  double result;

  if (!__kIOUSBDeviceDataTypeID)
    pthread_once(&__dataTypeInit, (void (*)(void))__IOUSBDeviceDataRegister);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    result = 0.0;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_QWORD *)(Instance + 16) = a3;
    *(_QWORD *)(Instance + 24) = a4;
    *(_QWORD *)(Instance + 32) = a2;
    *(_QWORD *)(Instance + 40) = a5;
    *(_QWORD *)(Instance + 48) = a6;
  }
  return result;
}

uint64_t IOUSBDeviceDataGetCapacity(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t IOUSBDeviceDataGetBytePtr(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t IOUSBDeviceDataGetMapToken(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t __IOUSBDeviceDataRelease(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 40))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 48));
}

void IOUSBDeviceControllerRemoveArrivalCallback()
{
  __CFRunLoop *v0;
  __CFRunLoopSource *RunLoopSource;

  if (_notifyPort)
  {
    IOObjectRelease(_notifyIterator);
    v0 = (__CFRunLoop *)_runLoop;
    RunLoopSource = IONotificationPortGetRunLoopSource((IONotificationPortRef)_notifyPort);
    CFRunLoopRemoveSource(v0, RunLoopSource, (CFRunLoopMode)_runLoopMode);
    IONotificationPortDestroy((IONotificationPortRef)_notifyPort);
    _notifyIterator = 0;
    _runLoop = 0;
    _runLoopMode = 0;
    _notifyPort = 0;
  }
}

uint64_t IOUSBDeviceControllerRegisterArrivalCallback(uint64_t (*a1)(_QWORD), uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFRunLoop *v6;
  IONotificationPort *v7;
  __CFRunLoopSource *RunLoopSource;
  const __CFDictionary *v9;
  uint64_t result;

  _runLoop = a3;
  _runLoopMode = a4;
  if (a3)
  {
    v6 = (__CFRunLoop *)a3;
    v7 = (IONotificationPort *)_notifyPort;
    if (!_notifyPort)
    {
      v7 = IONotificationPortCreate(0);
      _notifyPort = (uint64_t)v7;
      v6 = (__CFRunLoop *)_runLoop;
    }
    RunLoopSource = IONotificationPortGetRunLoopSource(v7);
    CFRunLoopAddSource(v6, RunLoopSource, (CFRunLoopMode)_runLoopMode);
  }
  if (!_notifyPort)
    return 3758097084;
  _arrivalCallback = a1;
  _arrivalContext = a2;
  v9 = IOServiceMatching("IOUSBDeviceController");
  result = IOServiceAddMatchingNotification((IONotificationPortRef)_notifyPort, "IOServicePublish", v9, (IOServiceMatchingCallback)__IOUSBDeviceControllerPublished, 0, (io_iterator_t *)&_notifyIterator);
  if (!(_DWORD)result)
  {
    __IOUSBDeviceControllerPublished(0, _notifyIterator);
    return 0;
  }
  return result;
}

uint64_t __IOUSBDeviceControllerPublished(int a1, io_iterator_t iterator)
{
  uint64_t result;
  io_object_t v4;
  uint64_t v5;
  CFTypeRef cf;

  result = IOIteratorNext(iterator);
  if ((_DWORD)result)
  {
    v4 = result;
    v5 = *MEMORY[0x1E0C9AE00];
    do
    {
      cf = 0;
      if (!IOUSBDeviceControllerCreateWithService(v5, v4, (uint64_t *)&cf))
      {
        if (cf)
        {
          _arrivalCallback(_arrivalContext);
          CFRelease(cf);
        }
      }
      result = IOIteratorNext(iterator);
      v4 = result;
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t IOHIDUserDeviceCopyService(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v1)
    IOObjectRetain(*(_DWORD *)(a1 + 32));
  return v1;
}

CFTypeID IOHIDUserDeviceGetTypeID(void)
{
  CFTypeID result;

  result = __kIOHIDUserDeviceTypeID;
  if (!__kIOHIDUserDeviceTypeID)
  {
    pthread_once(&__deviceTypeInit, (void (*)(void))__IOHIDUserDeviceRegister);
    return __kIOHIDUserDeviceTypeID;
  }
  return result;
}

uint64_t __IOHIDUserDeviceRegister()
{
  uint64_t result;

  IOMasterPort(*MEMORY[0x1E0C81720], (mach_port_t *)&__masterPort);
  result = _CFRuntimeRegisterClass();
  __kIOHIDUserDeviceTypeID = result;
  return result;
}

__CFDictionary *__IOHIDUserDeviceSerializeState(uint64_t a1)
{
  __CFDictionary *Mutable;
  io_registry_entry_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t entryID;

  entryID = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v3 = *(_DWORD *)(a1 + 32);
    if (v3)
    {
      IOObjectRetain(*(_DWORD *)(a1 + 32));
      IORegistryEntryGetRegistryEntryID(v3, &entryID);
    }
    v4 = (const void *)*MEMORY[0x1E0C9AE50];
    v5 = (const void *)*MEMORY[0x1E0C9AE40];
    if (*(_QWORD *)(a1 + 120))
      v6 = (const void *)*MEMORY[0x1E0C9AE50];
    else
      v6 = (const void *)*MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(Mutable, CFSTR("DispatchQueue"), v6);
    if (*(_QWORD *)(a1 + 96))
      v7 = v4;
    else
      v7 = v5;
    CFDictionarySetValue(Mutable, CFSTR("RunLoop"), v7);
    if (*(_QWORD *)(a1 + 160))
      v8 = v4;
    else
      v8 = v5;
    CFDictionarySetValue(Mutable, CFSTR("Queue"), v8);
    if (*(_QWORD *)(a1 + 216))
      v9 = v4;
    else
      v9 = v5;
    CFDictionarySetValue(Mutable, CFSTR("SetReportCallback"), v9);
    if (!*(_QWORD *)(a1 + 232) && !*(_QWORD *)(a1 + 248))
      v4 = v5;
    CFDictionarySetValue(Mutable, CFSTR("GetReportCallback"), v4);
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("RegistryID"), entryID);
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("QueueCallbackTimestamp"), *(_QWORD *)(a1 + 72));
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("DequeueTimestamp"), *(_QWORD *)(a1 + 80));
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("SetReportCnt"), *(unsigned int *)(a1 + 280));
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("GetReportCnt"), *(unsigned int *)(a1 + 284));
    _IOHIDDictionaryAddSInt64(Mutable, CFSTR("HandleReportCnt"), *(unsigned int *)(a1 + 288));
    if (v3)
      IOObjectRelease(v3);
  }
  return Mutable;
}

void *__IOHIDUserDeviceStateHandler(uint64_t a1, uint64_t a2)
{
  __CFDictionary *v2;
  __CFDictionary *v3;
  const __CFData *Data;
  const __CFData *v5;
  unsigned int Length;
  void *v7;
  CFRange v9;

  if ((*(_DWORD *)(a2 + 16) & 0xFFFFFFFE) != 2)
    return 0;
  v2 = __IOHIDUserDeviceSerializeState(a1);
  if (!v2)
    return 0;
  v3 = v2;
  Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    v5 = Data;
    Length = CFDataGetLength(Data);
    v7 = malloc_type_calloc(1uLL, Length + 200, 0xBEDA62D4uLL);
    if (v7)
    {
      __strlcpy_chk();
      *(_DWORD *)v7 = 1;
      *((_DWORD *)v7 + 1) = Length;
      v9.location = 0;
      v9.length = Length;
      CFDataGetBytes(v5, v9, (UInt8 *)v7 + 200);
    }
    CFRelease(v3);
  }
  else
  {
    v7 = 0;
    v5 = v3;
  }
  CFRelease(v5);
  return v7;
}

const __CFDictionary *IOHIDUserDeviceCreate(const __CFAllocator *a1, const __CFDictionary *a2)
{
  return IOHIDUserDeviceCreateWithOptions(a1, a2, 0);
}

const __CFDictionary *IOHIDUserDeviceCreateWithOptions(const __CFAllocator *a1, const __CFDictionary *a2, int a3)
{
  const __CFDictionary *v3;
  uint64_t v6;
  uint64_t Instance;
  uint64_t v8;
  CFDictionaryRef Copy;
  mach_port_t v10;
  const __CFDictionary *v11;
  io_service_t MatchingService;
  uint64_t v13;
  const __CFData *v14;
  const __CFData *v15;
  mach_port_t v16;
  const UInt8 *BytePtr;
  size_t Length;
  kern_return_t Service;
  NSObject *v20;
  uint64_t v21;
  dispatch_queue_t v22;
  const __CFAllocator *v23;
  CFDictionaryRef v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  char v30;
  const void *v31;
  int v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t input[2];
  _QWORD buf[4];
  uint8_t v49[4];
  uint64_t v50;
  uint64_t v51;

  v3 = a2;
  v51 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v6 = __kIOHIDUserDeviceTypeID;
    if (!__kIOHIDUserDeviceTypeID)
    {
      pthread_once(&__deviceTypeInit, (void (*)(void))__IOHIDUserDeviceRegister);
      v6 = __kIOHIDUserDeviceTypeID;
    }
    Instance = _IOHIDObjectCreateInstance((uint64_t)a1, v6, 0x118uLL);
    if (!Instance)
      return 0;
    v8 = Instance;
    *(_DWORD *)(Instance + 48) = a3;
    _IOHIDDebugTrace(8193, 0, Instance, 0, 0, 0);
    Copy = CFDictionaryCreateCopy(a1, v3);
    *(_QWORD *)(v8 + 40) = Copy;
    if (!Copy)
      goto LABEL_40;
    v10 = __masterPort;
    v11 = IOServiceMatching("IOHIDResource");
    MatchingService = IOServiceGetMatchingService(v10, v11);
    *(_DWORD *)(v8 + 24) = MatchingService;
    if (!MatchingService)
    {
      v34 = _IOHIDLogCategory(5u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        IOHIDUserDeviceCreateWithOptions_cold_1();
      goto LABEL_40;
    }
    if (IOServiceOpen(MatchingService, *MEMORY[0x1E0C83DA0], 0, (io_connect_t *)(v8 + 28)))
    {
      v35 = _IOHIDLogCategory(5u);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        IOHIDUserDeviceCreateWithOptions_cold_4();
      goto LABEL_40;
    }
    v13 = *(unsigned int *)(v8 + 48);
    input[0] = v13;
    v14 = IOCFSerialize(*(CFTypeRef *)(v8 + 40), 0);
    if (v14)
    {
      v15 = v14;
      v16 = *(_DWORD *)(v8 + 28);
      BytePtr = CFDataGetBytePtr(v14);
      Length = CFDataGetLength(v15);
      Service = IOConnectCallMethod(v16, 0, input, 1u, BytePtr, Length, 0, 0, 0, 0);
      if (!Service)
      {
        Service = IOConnectGetService(*(_DWORD *)(v8 + 28), (io_service_t *)(v8 + 32));
        if (!Service)
        {
          IORegistryEntryGetRegistryEntryID(*(_DWORD *)(v8 + 32), (uint64_t *)(v8 + 88));
          v20 = _IOHIDLogCategory(5u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            v21 = *(_QWORD *)(v8 + 88);
            LODWORD(buf[0]) = 134218242;
            *(_QWORD *)((char *)buf + 4) = v21;
            WORD2(buf[1]) = 2112;
            *(_QWORD *)((char *)&buf[1] + 6) = v8;
            _os_log_impl(&dword_18AAAF000, v20, OS_LOG_TYPE_DEFAULT, "0x%llx: Start: %@", (uint8_t *)buf, 0x16u);
          }
          _IOHIDDebugTrace(8195, 0, v8, v13, *(_QWORD *)(v8 + 88), 0);
          CFRelease(v15);
          v22 = dispatch_queue_create("IOHIDUserDeviceStateQueue", 0);
          *(_QWORD *)(v8 + 64) = v22;
          if (v22)
          {
            *(_QWORD *)(v8 + 56) = os_state_add_handler();
            *(_OWORD *)input = xmmword_18AB470C0;
            v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            buf[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, (const void *)(v8 + 168));
            buf[1] = CFSTR("userDeviceQueue");
            v24 = CFDictionaryCreate(v23, (const void **)&__IOHIDUserDeviceSetupAnalytics_keys, (const void **)buf, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (v24)
            {
              v25 = IOHIDAnalyticsHistogramEventCreate((uint64_t)CFSTR("com.apple.hid.queueUsage"), (uint64_t)v24, (uint64_t)CFSTR("UsagePercent"), (uint64_t)input, 1);
              *(_QWORD *)(v8 + 184) = v25;
              if (!v25)
              {
                v26 = _IOHIDLogCategory(5u);
                if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                {
                  v27 = *(_QWORD *)(v8 + 88);
                  *(_DWORD *)v49 = 134217984;
                  v50 = v27;
                  _os_log_impl(&dword_18AAAF000, v26, OS_LOG_TYPE_DEFAULT, "0x%llx: Unable to create queue analytics", v49, 0xCu);
                }
                if (!*(_QWORD *)(v8 + 184))
                  IOHIDAnalyticsEventActivate();
              }
              CFRelease(v24);
            }
            else
            {
              v38 = _IOHIDLogCategory(5u);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                IOHIDUserDeviceCreateWithOptions_cold_3(v8 + 88, v38, v39, v40, v41, v42, v43, v44);
            }
            v28 = 0;
            v29 = 1;
            do
            {
              v30 = v29;
              v31 = (const void *)buf[v28];
              if (v31)
                CFRelease(v31);
              v29 = 0;
              v28 = 1;
            }
            while ((v30 & 1) != 0);
            if (v24)
            {
              CFRetain((CFTypeRef)v8);
              v3 = (const __CFDictionary *)v8;
LABEL_27:
              CFRelease((CFTypeRef)v8);
              return v3;
            }
          }
LABEL_40:
          v3 = 0;
          goto LABEL_27;
        }
      }
      v33 = Service;
      CFRelease(v15);
    }
    else
    {
      v33 = -536870211;
    }
    v36 = _IOHIDLogCategory(5u);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v45 = *(_QWORD *)(v8 + 88);
      v46 = *(_QWORD *)(v8 + 40);
      LODWORD(buf[0]) = 134218498;
      *(_QWORD *)((char *)buf + 4) = v45;
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = v33;
      WORD1(buf[2]) = 2112;
      *(_QWORD *)((char *)&buf[2] + 4) = v46;
      _os_log_error_impl(&dword_18AAAF000, v36, OS_LOG_TYPE_ERROR, "0x%llx: IOHIDUserDevice start failed:0x%x properties:%@", (uint8_t *)buf, 0x1Cu);
    }
    v37 = _IOHIDLogCategory(5u);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      IOHIDUserDeviceCreateWithOptions_cold_2();
    goto LABEL_40;
  }
  return v3;
}

void IOHIDUserDeviceScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  const __CFAllocator *v6;
  CFRunLoopSourceRef v7;
  __CFRunLoopSource *RunLoopSource;
  io_connect_t v9;
  mach_port_t Port;
  uint64_t v11;
  _OWORD v12[5];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!__IOHIDUserDeviceSetupAsyncSupport(a1))
    IOHIDUserDeviceScheduleWithRunLoop_cold_1(&v11, v12);
  *(_QWORD *)(a1 + 96) = a2;
  *(_QWORD *)(a1 + 104) = a3;
  if (*(_QWORD *)(a1 + 152)
    || (v6 = CFGetAllocator((CFTypeRef)a1),
        v7 = CFMachPortCreateRunLoopSource(v6, *(CFMachPortRef *)(a1 + 144), 0),
        (*(_QWORD *)(a1 + 152) = v7) != 0))
  {
    RunLoopSource = *(__CFRunLoopSource **)(a1 + 200);
    if (RunLoopSource
      || (RunLoopSource = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(a1 + 192)),
          (*(_QWORD *)(a1 + 200) = RunLoopSource) != 0))
    {
      CFRunLoopAddSource(a2, RunLoopSource, a3);
      CFRunLoopAddSource(a2, *(CFRunLoopSourceRef *)(a1 + 152), a3);
      if (*(_QWORD *)(a1 + 216) || *(_QWORD *)(a1 + 232) || *(_QWORD *)(a1 + 248))
      {
        v9 = *(_DWORD *)(a1 + 28);
        Port = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 144));
        IOConnectSetNotificationPort(v9, 0, Port, 0);
      }
      if ((*(_BYTE *)(a1 + 48) & 1) != 0)
        IOConnectCallMethod(*(_DWORD *)(a1 + 28), 4u, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
}

BOOL __IOHIDUserDeviceSetupAsyncSupport(uint64_t a1)
{
  mach_vm_size_t v2;
  mach_port_t NotificationPort;
  mach_port_t v4;
  const __CFAllocator *v5;
  CFMachPortRef v6;
  IONotificationPortRef v7;
  _BOOL8 v8;
  NSObject *v10;
  CFMachPortContext v11;
  mach_vm_size_t ofSize;

  if (*(_QWORD *)(a1 + 96) || *(_QWORD *)(a1 + 120))
    __IOHIDDeviceSetupAsyncSupport_cold_3();
  if (!*(_QWORD *)(a1 + 160))
  {
    v11.version = 0;
    ofSize = 0;
    if (IOConnectMapMemory(*(_DWORD *)(a1 + 28), 0, *MEMORY[0x1E0C83DA0], (mach_vm_address_t *)&v11, &ofSize, 1u))
    {
      v10 = _IOHIDLogCategory(5u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        __IOHIDUserDeviceSetupAsyncSupport_cold_1();
      goto LABEL_18;
    }
    v2 = ofSize;
    *(_QWORD *)(a1 + 160) = v11.version;
    *(_QWORD *)(a1 + 168) = v2;
  }
  if (!*(_QWORD *)(a1 + 144))
  {
    NotificationPort = IODataQueueAllocateNotificationPort();
    if (NotificationPort)
    {
      v4 = NotificationPort;
      v11.version = 0;
      memset(&v11.retain, 0, 24);
      v11.info = (void *)a1;
      v5 = CFGetAllocator((CFTypeRef)a1);
      v6 = CFMachPortCreateWithPort(v5, v4, (CFMachPortCallBack)__IOHIDUserDeviceQueueCallback, &v11, 0);
      *(_QWORD *)(a1 + 144) = v6;
      if (!v6)
        goto LABEL_18;
    }
    else if (!*(_QWORD *)(a1 + 144))
    {
LABEL_18:
      v8 = 0;
      goto LABEL_14;
    }
  }
  v7 = *(IONotificationPortRef *)(a1 + 192);
  if (!v7)
  {
    v7 = IONotificationPortCreate(0);
    *(_QWORD *)(a1 + 192) = v7;
  }
  v8 = v7 != 0;
LABEL_14:
  _IOHIDDebugTrace(8196, 0, a1, v8, 0, 0);
  return v8;
}

void IOHIDUserDeviceUnscheduleFromRunLoop(uint64_t a1)
{
  uint64_t v1;
  BOOL v2;

  v1 = a1;
  _IOHIDDebugTrace(8197, 0, a1, 0, 0, 0);
  if (*(_QWORD *)(v1 + 96))
    v2 = *(_QWORD *)(v1 + 120) == 0;
  else
    v2 = 0;
  if (!v2)
  {
    v1 = MEMORY[0x1E0C81028];
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  IOConnectSetNotificationPort(*(_DWORD *)(v1 + 28), 0, 0, 0);
  CFRunLoopRemoveSource(*(CFRunLoopRef *)(v1 + 96), *(CFRunLoopSourceRef *)(v1 + 152), *(CFRunLoopMode *)(v1 + 104));
  CFRunLoopRemoveSource(*(CFRunLoopRef *)(v1 + 96), *(CFRunLoopSourceRef *)(v1 + 200), *(CFRunLoopMode *)(v1 + 104));
}

void IOHIDUserDeviceScheduleWithDispatchQueue(__IOHIDUserDevice *a1, NSObject *a2)
{
  IOHIDUserDeviceSetDispatchQueue(a1, a2);
  IOHIDUserDeviceActivate(a1);
}

void IOHIDUserDeviceSetDispatchQueue(IOHIDUserDeviceRef device, dispatch_queue_t queue)
{
  const char *label;
  const char *v5;
  dispatch_queue_t v6;
  uint64_t v7;
  uint64_t v8;
  char __str[16];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  _IOHIDDebugTrace(8198, 0, (uint64_t)device, 0, 0, 0);
  if (!__IOHIDUserDeviceSetupAsyncSupport((uint64_t)device))
    IOHIDUserDeviceScheduleWithRunLoop_cold_1(&v8, __str);
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  *(_OWORD *)__str = 0u;
  v10 = 0u;
  label = dispatch_queue_get_label(queue);
  v5 = "";
  if (label)
    v5 = label;
  snprintf(__str, 0x100uLL, "%s.IOHIDUserDeviceRef", v5);
  v6 = dispatch_queue_create_with_target_V2(__str, 0, queue);
  *((_QWORD *)device + 15) = v6;
  if (v6)
  {
    _IOHIDObjectInternalRetain(device);
    v7 = dispatch_mach_create();
    *((_QWORD *)device + 16) = v7;
    if (!v7)
      _IOHIDObjectInternalRelease(device);
  }
}

void IOHIDUserDeviceActivate(IOHIDUserDeviceRef device)
{
  BOOL v1;
  IOHIDUserDeviceRef v2;
  unsigned int *v3;
  unsigned int v4;
  io_connect_t v5;
  mach_port_t Port;

  if (*((_QWORD *)device + 15))
    v1 = *((_QWORD *)device + 12) == 0;
  else
    v1 = 0;
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    device = (IOHIDUserDeviceRef)_os_crash_msg();
    __break(1u);
  }
  v2 = device;
  v3 = (unsigned int *)((char *)device + 112);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if ((v4 & 1) == 0)
  {
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)device + 24), *((dispatch_queue_t *)device + 15));
    if (*((_QWORD *)v2 + 27)
      || *((_QWORD *)v2 + 29)
      || *((_QWORD *)v2 + 31)
      || *((_QWORD *)v2 + 33)
      || *((_QWORD *)v2 + 34))
    {
      v5 = *((_DWORD *)v2 + 7);
      Port = CFMachPortGetPort(*((CFMachPortRef *)v2 + 18));
      IOConnectSetNotificationPort(v5, 0, Port, 0);
    }
    CFMachPortGetPort(*((CFMachPortRef *)v2 + 18));
    dispatch_mach_connect();
    if ((*((_BYTE *)v2 + 48) & 1) != 0)
      IOConnectCallMethod(*((_DWORD *)v2 + 7), 4u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}

void IOHIDUserDeviceCancel(IOHIDUserDeviceRef device)
{
  unsigned int *v2;
  unsigned int v3;
  BOOL v4;

  _IOHIDDebugTrace(8199, 0, (uint64_t)device, 0, 0, 0);
  v2 = (unsigned int *)((char *)device + 112);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 | 2, v2));
  if ((v3 & 2) == 0)
  {
    if (*((_QWORD *)device + 15))
      v4 = *((_QWORD *)device + 12) == 0;
    else
      v4 = 0;
    if (v4)
    {
      IOConnectSetNotificationPort(*((_DWORD *)device + 7), 0, 0, 0);
      dispatch_mach_cancel();
    }
    else
    {
      os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
}

uint64_t __IOHIDUserDeviceQueueCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  IODataQueueMemory *v6;
  UInt32 tail;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  void *v12;
  uint64_t v13;
  unsigned int *v14;
  int (*v15)(_QWORD, _QWORD, _QWORD, void *);
  int (*v16)(uint64_t, uint64_t, _QWORD, void *, size_t *);
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  kern_return_t v23;
  kern_return_t v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  int v31;
  size_t inputStructCnt;
  uint32_t dataSize;
  _BYTE buf[12];
  __int16 v35;
  kern_return_t v36;
  __int16 v37;
  int v38;
  uint64_t input[3];

  input[2] = *MEMORY[0x1E0C80C00];
  _IOHIDDebugTrace(8200, 0, a4, 0, 0, 0);
  result = mach_continuous_time();
  *(_QWORD *)(a4 + 72) = result;
  v6 = *(IODataQueueMemory **)(a4 + 160);
  if (v6)
  {
    if (*(_QWORD *)(a4 + 184))
    {
      tail = v6->tail;
      if (tail != *(_DWORD *)(a4 + 176))
      {
        IOHIDAnalyticsHistogramEventSetIntegerValue();
        *(_DWORD *)(a4 + 176) = tail;
        v6 = *(IODataQueueMemory **)(a4 + 160);
      }
    }
    dataSize = 0;
    result = (uint64_t)IODataQueuePeek(v6);
    if (result)
    {
      v8 = (unsigned int *)result;
      while (1)
      {
        v9 = *(_QWORD *)(v8 + 5);
        input[0] = -536870201;
        input[1] = v9;
        inputStructCnt = 0;
        v10 = v8[3];
        v11 = v8[1];
        if (!v11)
          break;
        v12 = 0;
        if (v11 == 1)
        {
          if ((v10 & 1) != 0)
          {
            if (*v8 > 0x23)
            {
              v14 = *(unsigned int **)(v8 + 7);
              v13 = v8[9];
              goto LABEL_20;
            }
            v29 = _IOHIDLogCategory(5u);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              v30 = *(_QWORD *)(a4 + 88);
              v31 = *v8;
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = v30;
              v35 = 1024;
              v36 = v10;
              v37 = 1024;
              v38 = v31;
              _os_log_error_impl(&dword_18AAAF000, v29, OS_LOG_TYPE_ERROR, "0x%llx: Packet size is to small for large report, but large report flag is set. reportFlags:%#x entrySize:%u", buf, 0x18u);
            }
          }
          else
          {
            if ((unint64_t)*v8 - 24 >= v8[4])
              v13 = v8[4];
            else
              v13 = *v8 - 24;
            v14 = v8 + 7;
LABEL_20:
            ++*(_DWORD *)(a4 + 280);
            if (*(_QWORD *)(a4 + 216))
            {
              _IOHIDDebugTrace(8203, 0, a4, 0, 0, 0);
              v19 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, unsigned int *, uint64_t))(a4 + 216))(*(_QWORD *)(a4 + 224), v8[2], v10 >> 8, v14, v13);
              goto LABEL_31;
            }
            v22 = *(_QWORD *)(a4 + 264);
            if (v22)
            {
              v19 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, unsigned int *, uint64_t))(v22 + 16))(v22, v8[2], v10 >> 8, v14, v13);
LABEL_31:
              input[0] = v19;
            }
            else
            {
              v26 = _IOHIDLogCategory(5u);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
              {
                v27 = *(_QWORD *)(a4 + 88);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v27;
                _os_log_impl(&dword_18AAAF000, v26, OS_LOG_TYPE_INFO, "0x%llx: set report not handled", buf, 0xCu);
              }
            }
            if ((v10 & 1) != 0)
            {
              *(_QWORD *)buf = *(_QWORD *)(v8 + 7);
              IOConnectCallMethod(*(_DWORD *)(a4 + 28), 5u, (const uint64_t *)buf, 1u, 0, 0, 0, 0, 0, 0);
            }
          }
          v12 = 0;
        }
LABEL_35:
        v23 = IOConnectCallMethod(*(_DWORD *)(a4 + 28), 3u, input, 2u, v12, inputStructCnt, 0, 0, 0, 0);
        if (v23)
        {
          v24 = v23;
          v25 = _IOHIDLogCategory(5u);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            v28 = *(_QWORD *)(a4 + 88);
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v28;
            v35 = 1024;
            v36 = v24;
            _os_log_error_impl(&dword_18AAAF000, v25, OS_LOG_TYPE_ERROR, "0x%llx: kIOHIDResourceDeviceUserClientMethodPostReportResponse:%x", buf, 0x12u);
            if (!v12)
              goto LABEL_39;
LABEL_38:
            free(v12);
            goto LABEL_39;
          }
        }
        if (v12)
          goto LABEL_38;
LABEL_39:
        dataSize = 0;
        *(_QWORD *)(a4 + 80) = mach_continuous_time();
        IODataQueueDequeue(*(IODataQueueMemory **)(a4 + 160), 0, &dataSize);
        result = (uint64_t)IODataQueuePeek(*(IODataQueueMemory **)(a4 + 160));
        v8 = (unsigned int *)result;
        if (!result)
          return result;
      }
      v12 = malloc_type_malloc(v8[4], 0x4076ABD7uLL);
      inputStructCnt = v8[4];
      ++*(_DWORD *)(a4 + 284);
      v15 = *(int (**)(_QWORD, _QWORD, _QWORD, void *))(a4 + 232);
      if (v15)
        input[0] = v15(*(_QWORD *)(a4 + 240), v8[2], v10 >> 8, v12);
      v16 = *(int (**)(uint64_t, uint64_t, _QWORD, void *, size_t *))(a4 + 248);
      if (v16)
      {
        v17 = *(_QWORD *)(a4 + 256);
        v18 = v8[2];
      }
      else
      {
        v17 = *(_QWORD *)(a4 + 272);
        if (!v17)
        {
LABEL_25:
          if (!*(_QWORD *)(a4 + 232) && !*(_QWORD *)(a4 + 272))
          {
            v20 = _IOHIDLogCategory(5u);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
            {
              v21 = *(_QWORD *)(a4 + 88);
              *(_DWORD *)buf = 134217984;
              *(_QWORD *)&buf[4] = v21;
              _os_log_impl(&dword_18AAAF000, v20, OS_LOG_TYPE_INFO, "0x%llx: get report not handled", buf, 0xCu);
            }
          }
          goto LABEL_35;
        }
        v18 = v8[2];
        v16 = *(int (**)(uint64_t, uint64_t, _QWORD, void *, size_t *))(v17 + 16);
      }
      input[0] = v16(v17, v18, v10 >> 8, v12, &inputStructCnt);
      if (*(_QWORD *)(a4 + 248))
        goto LABEL_35;
      goto LABEL_25;
    }
  }
  return result;
}

uint64_t __IOHIDUserDeviceDestroyDevice(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  IONotificationPort *v4;
  mach_vm_address_t v5;
  io_connect_t v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = _IOHIDLogCategory(5u);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 88);
    v8 = 134218242;
    v9 = v3;
    v10 = 2112;
    v11 = a1;
    _os_log_impl(&dword_18AAAF000, v2, OS_LOG_TYPE_DEFAULT, "0x%llx: Destroy: %@", (uint8_t *)&v8, 0x16u);
  }
  v4 = *(IONotificationPort **)(a1 + 192);
  if (v4)
  {
    IONotificationPortDestroy(v4);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v5 = *(_QWORD *)(a1 + 160);
  if (v5)
  {
    IOConnectUnmapMemory(*(_DWORD *)(a1 + 28), 0, *MEMORY[0x1E0C83DA0], v5);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v6 = *(_DWORD *)(a1 + 28);
  if (v6)
  {
    IOServiceClose(v6);
    *(_DWORD *)(a1 + 28) = 0;
  }
  result = *(unsigned int *)(a1 + 24);
  if ((_DWORD)result)
  {
    result = IOObjectRelease(result);
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}

void IOHIDUserDeviceSetCancelHandler(IOHIDUserDeviceRef device, dispatch_block_t handler)
{
  uint64_t v2;
  _OWORD v3[5];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (!handler || *((_QWORD *)device + 17))
    IOHIDUserDeviceSetCancelHandler_cold_1(&v2, v3);
  *((_QWORD *)device + 17) = _Block_copy(handler);
}

CFTypeRef IOHIDUserDeviceCopyProperty(IOHIDUserDeviceRef device, CFStringRef key)
{
  return IORegistryEntryCreateCFProperty(*((_DWORD *)device + 8), key, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
}

Boolean IOHIDUserDeviceSetProperty(IOHIDUserDeviceRef device, CFStringRef key, CFTypeRef property)
{
  return IOConnectSetCFProperty(*((_DWORD *)device + 7), key, property) == 0;
}

uint64_t IOHIDUserDeviceRegisterGetReportCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  io_connect_t v3;
  mach_port_t Port;

  *(_QWORD *)(result + 232) = a2;
  *(_QWORD *)(result + 240) = a3;
  if (a2)
  {
    if (*(_QWORD *)(result + 144))
    {
      v3 = *(_DWORD *)(result + 28);
      Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 144));
      return IOConnectSetNotificationPort(v3, 0, Port, 0);
    }
  }
  return result;
}

uint64_t IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  io_connect_t v3;
  mach_port_t Port;

  *(_QWORD *)(result + 248) = a2;
  *(_QWORD *)(result + 256) = a3;
  if (a2)
  {
    if (*(_QWORD *)(result + 144))
    {
      v3 = *(_DWORD *)(result + 28);
      Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 144));
      return IOConnectSetNotificationPort(v3, 0, Port, 0);
    }
  }
  return result;
}

uint64_t IOHIDUserDeviceRegisterSetReportCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  io_connect_t v3;
  mach_port_t Port;

  *(_QWORD *)(result + 216) = a2;
  *(_QWORD *)(result + 224) = a3;
  if (a2)
  {
    if (*(_QWORD *)(result + 144))
    {
      v3 = *(_DWORD *)(result + 28);
      Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 144));
      return IOConnectSetNotificationPort(v3, 0, Port, 0);
    }
  }
  return result;
}

void IOHIDUserDeviceRegisterGetReportBlock(IOHIDUserDeviceRef device, IOHIDUserDeviceGetReportBlock block)
{
  if (*((_QWORD *)device + 34))
    IOHIDUserDeviceRegisterGetReportBlock_cold_1();
  *((_QWORD *)device + 34) = _Block_copy(block);
}

void IOHIDUserDeviceRegisterSetReportBlock(IOHIDUserDeviceRef device, IOHIDUserDeviceSetReportBlock block)
{
  if (*((_QWORD *)device + 33))
    IOHIDUserDeviceRegisterSetReportBlock_cold_1();
  *((_QWORD *)device + 33) = _Block_copy(block);
}

uint64_t IOHIDUserDeviceHandleReportAsyncWithTimeStamp(uint64_t a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v12;
  uint64_t v13;
  mach_port_t MachPort;
  uint64_t input;
  uint64_t reference[9];

  reference[8] = *MEMORY[0x1E0C80C00];
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  if (!v12)
    return 3758097085;
  v13 = (uint64_t)v12;
  *v12 = a5;
  v12[1] = a6;
  MachPort = IONotificationPortGetMachPort(*(IONotificationPortRef *)(a1 + 192));
  reference[1] = (uint64_t)__IOHIDUserDeviceHandleReportAsyncCallback;
  reference[2] = v13;
  if (dynLinkrosetta_is_current_process_translated_1 && dynLinkrosetta_is_current_process_translated_1())
  {
    if (dynLinkrosetta_convert_to_system_absolute_time_1)
      a2 = dynLinkrosetta_convert_to_system_absolute_time_1(a2);
  }
  input = a2;
  return IOConnectCallAsyncMethod(*(_DWORD *)(a1 + 28), 2u, MachPort, reference, 8u, &input, 1u, a3, a4, 0, 0, 0, 0);
}

void __IOHIDUserDeviceHandleReportAsyncCallback(_QWORD *a1, uint64_t a2)
{
  _IOHIDDebugTrace(8202, 0, (uint64_t)a1, 0, 0, 0);
  if (*a1)
    ((void (*)(_QWORD, uint64_t))*a1)(a1[1], a2);
  free(a1);
}

IOReturn IOHIDUserDeviceHandleReportWithTimeStamp(IOHIDUserDeviceRef device, uint64_t timestamp, const uint8_t *report, CFIndex reportLength)
{
  kern_return_t v8;
  NSObject *v9;
  uint64_t input;

  if (dynLinkrosetta_is_current_process_translated_1
    && dynLinkrosetta_is_current_process_translated_1()
    && dynLinkrosetta_convert_to_system_absolute_time_1)
  {
    timestamp = dynLinkrosetta_convert_to_system_absolute_time_1(timestamp);
  }
  input = timestamp;
  _IOHIDDebugTrace(8201, 0, timestamp, (uint64_t)device, reportLength, 0);
  ++*((_DWORD *)device + 72);
  v8 = IOConnectCallMethod(*((_DWORD *)device + 7), 2u, &input, 1u, report, reportLength, 0, 0, 0, 0);
  if (v8)
  {
    v9 = _IOHIDLogCategory(5u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      IOHIDUserDeviceHandleReportWithTimeStamp_cold_1();
  }
  return v8;
}

uint64_t IOHIDUserDeviceHandleReport(__IOHIDUserDevice *a1, const uint8_t *a2, CFIndex a3)
{
  uint64_t v6;

  v6 = mach_absolute_time();
  return IOHIDUserDeviceHandleReportWithTimeStamp(a1, v6, a2, a3);
}

uint64_t IOHIDUserDeviceHandleReportAsync(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;

  v10 = mach_absolute_time();
  return IOHIDUserDeviceHandleReportAsyncWithTimeStamp(a1, v10, a2, a3, a4, a5);
}

void __IOHIDUserDeviceExtRelease(uint64_t a1)
{
  unsigned int v2;
  NSObject *v3;
  __CFMachPort *v4;
  uint64_t v5;
  _OWORD v6[5];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  _IOHIDDebugTrace(8194, 0, a1, 0, 0, 0);
  if (*(_QWORD *)(a1 + 120))
  {
    v2 = atomic_load((unsigned int *)(a1 + 112));
    if (v2 != 3)
      __IOHIDQueueExtRelease_cold_1(&v5, v6, (unsigned int *)(a1 + 112));
  }
  if (*(_QWORD *)(a1 + 56))
    os_state_remove_handler();
  v3 = *(NSObject **)(a1 + 64);
  if (v3)
  {
    dispatch_set_context(v3, (void *)a1);
    dispatch_set_finalizer_f(*(dispatch_object_t *)(a1 + 64), (dispatch_function_t)__IOHIDUserDeviceFinalizeStateHandler);
    _IOHIDObjectInternalRetain((const void *)a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
  }
  v4 = *(__CFMachPort **)(a1 + 144);
  if (v4)
    CFMachPortInvalidate(v4);
}

CFStringRef __IOHIDUserDeviceCopyDebugDescription(uint64_t a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<IOHIDUserDeviceRef ref:%d/%d id:0x%llx stats:%d,%d,%d>"), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(_QWORD *)(a1 + 88), *(unsigned int *)(a1 + 280), *(unsigned int *)(a1 + 284), *(unsigned int *)(a1 + 288));
}

void __IOHIDUserDeviceIntRelease(uint64_t a1)
{
  const void *v2;
  __CFMachPort *v3;
  ipc_space_t v4;
  mach_port_name_t Port;
  const void *v6;
  io_object_t v7;
  const void *v8;
  const void *v9;

  _IOHIDDebugTrace(8194, 0, a1, 0, 0, 0);
  __IOHIDUserDeviceDestroyDevice(a1);
  v2 = *(const void **)(a1 + 152);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v3 = *(__CFMachPort **)(a1 + 144);
  if (v3)
  {
    v4 = *MEMORY[0x1E0C83DA0];
    Port = CFMachPortGetPort(v3);
    mach_port_mod_refs(v4, Port, 1u, -1);
    CFRelease(*(CFTypeRef *)(a1 + 144));
    *(_QWORD *)(a1 + 144) = 0;
  }
  v6 = *(const void **)(a1 + 40);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v7 = *(_DWORD *)(a1 + 32);
  if (v7)
  {
    IOObjectRelease(v7);
    *(_DWORD *)(a1 + 32) = 0;
  }
  if (*(_QWORD *)(a1 + 184))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 184));
    *(_QWORD *)(a1 + 184) = 0;
  }
  v8 = *(const void **)(a1 + 264);
  if (v8)
    _Block_release(v8);
  v9 = *(const void **)(a1 + 272);
  if (v9)
    _Block_release(v9);
}

uint64_t initrosetta_convert_to_system_absolute_time_1(uint64_t a1)
{
  void *v2;
  uint64_t (*v3)();

  v2 = (void *)RosettaLibrary_libLibrary_1;
  if (!RosettaLibrary_libLibrary_1)
  {
    v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_1 = (uint64_t)v2;
  }
  v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_system_absolute_time");
  dynLinkrosetta_convert_to_system_absolute_time_1 = v3;
  if (v3)
    return ((uint64_t (*)(uint64_t))v3)(a1);
  else
    return a1;
}

void OUTLINED_FUNCTION_7(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t IOEthernetControllerGetTypeID()
{
  uint64_t result;

  result = __kIOEthernetControllerTypeID;
  if (!__kIOEthernetControllerTypeID)
  {
    pthread_once(&__controllerTypeInit, (void (*)(void))__IOEthernetControllerRegister);
    return __kIOEthernetControllerTypeID;
  }
  return result;
}

uint64_t __IOEthernetControllerRegister()
{
  uint64_t result;

  IOMasterPort(*MEMORY[0x1E0C81720], (mach_port_t *)&__masterPort_0);
  result = _CFRuntimeRegisterClass();
  __kIOEthernetControllerTypeID = result;
  return result;
}

uint64_t IOEthernetControllerCreate(uint64_t a1, const void *a2)
{
  uint64_t Instance;
  uint64_t v4;
  mach_port_t v5;
  const __CFDictionary *v6;
  io_service_t MatchingService;
  const __CFData *v9;
  const __CFData *v10;
  mach_port_t v11;
  const UInt8 *BytePtr;
  size_t Length;
  kern_return_t v14;
  unsigned int InterfaceWithID;
  int v16;
  uint32_t outputCnt;

  if (!a2)
    return 0;
  if (!__kIOEthernetControllerTypeID)
    pthread_once(&__controllerTypeInit, (void (*)(void))__IOEthernetControllerRegister);
  Instance = _CFRuntimeCreateInstance();
  v4 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_DWORD *)(Instance + 88) = -1;
    v5 = __masterPort_0;
    v6 = IOServiceMatching("IOUserEthernetResource");
    MatchingService = IOServiceGetMatchingService(v5, v6);
    *(_DWORD *)(v4 + 16) = MatchingService;
    if (!MatchingService)
      return 0;
    if (IOServiceOpen(MatchingService, *MEMORY[0x1E0C83DA0], 0, (io_connect_t *)(v4 + 20)))
      goto LABEL_9;
    if (IOCreateReceivePort(0x35u, (mach_port_t *)(v4 + 56)))
      goto LABEL_9;
    if (IOConnectSetNotificationPort(*(_DWORD *)(v4 + 20), 0, *(_DWORD *)(v4 + 56), 0))
      goto LABEL_9;
    v9 = IOCFSerialize(a2, 0);
    if (!v9)
      goto LABEL_9;
    v10 = v9;
    outputCnt = 1;
    v11 = *(_DWORD *)(v4 + 20);
    BytePtr = CFDataGetBytePtr(v9);
    Length = CFDataGetLength(v10);
    v14 = IOConnectCallMethod(v11, 0, 0, 0, BytePtr, Length, (uint64_t *)(v4 + 128), &outputCnt, 0, 0);
    CFRelease(v10);
    if (v14
      || (InterfaceWithID = __IOEthernetControllerGetInterfaceWithID(*(_QWORD *)(v4 + 128)),
          (*(_DWORD *)(v4 + 32) = InterfaceWithID) == 0)
      || (v16 = __connect_to_kernel((const void *)(v4 + 128)), *(_DWORD *)(v4 + 88) = v16, v16 == -1))
    {
LABEL_9:
      CFRelease((CFTypeRef)v4);
      return 0;
    }
  }
  return v4;
}

CFMutableDictionaryRef __IOEthernetControllerGetInterfaceWithID(uint64_t a1)
{
  CFMutableDictionaryRef result;
  __CFDictionary *v2;
  CFNumberRef v3;
  CFNumberRef v4;
  uint64_t valuePtr;

  valuePtr = a1;
  result = IOServiceMatching("IONetworkInterface");
  if (result)
  {
    v2 = result;
    v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
    if (v3)
    {
      v4 = v3;
      CFDictionarySetValue(v2, CFSTR("IORegistryEntryID"), v3);
      CFRelease(v4);
      return (CFMutableDictionaryRef)IOServiceGetMatchingService(0, v2);
    }
    else
    {
      CFRelease(v2);
      return 0;
    }
  }
  return result;
}

uint64_t __connect_to_kernel(const void *a1)
{
  uint64_t v2;
  int v4;
  _BYTE v5[20];
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  _OWORD v10[6];
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v8 = 0x4000;
  v9 = 0x10000;
  v2 = socket(32, 2, 2);
  if ((_DWORD)v2 != -1)
  {
    v11 = 0;
    memset(v10, 0, sizeof(v10));
    __strlcpy_chk();
    if (ioctl(v2, 0xC0644E03uLL, v10) == -1
      || (v6 = 0,
          *(_QWORD *)&v5[12] = 0,
          v7 = 0,
          *(_DWORD *)v5 = 139296,
          *(_DWORD *)&v5[4] = v10[0],
          *(_DWORD *)&v5[8] = 0,
          connect(v2, (const sockaddr *)v5, 0x20u) == -1)
      || setsockopt(v2, 2, 12, a1, 8u) == -1
      || setsockopt(v2, 0xFFFF, 4098, &v9, 4u)
      || setsockopt(v2, 0xFFFF, 4097, &v8, 4u)
      || (v4 = fcntl(v2, 3), fcntl(v2, 4, v4 | 4u) == -1))
    {
      close(v2);
      return 0xFFFFFFFFLL;
    }
  }
  return v2;
}

uint64_t IOEthernetControllerGetIONetworkInterfaceObject(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t IOEthernetControllerSetLinkStatus(uint64_t a1, unsigned int a2)
{
  uint64_t input;

  input = a2;
  return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 20), 1u, &input, 1u, 0, 0);
}

uint64_t IOEthernetControllerSetPowerSavings(uint64_t a1, unsigned int a2)
{
  uint64_t input;

  input = a2;
  return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 20), 4u, &input, 1u, 0, 0);
}

ssize_t IOEthernetControllerReadPacket(uint64_t a1, void *a2, size_t a3)
{
  return recv(*(_DWORD *)(a1 + 88), a2, a3, 0);
}

uint64_t IOEthernetControllerWritePacket(uint64_t a1, const void *a2, int64_t a3)
{
  uint64_t v3;

  v3 = 3758097084;
  if (a3 >= 14)
  {
    if (send(*(_DWORD *)(a1 + 88), a2, a3, 0) <= 0)
      return 3758097084;
    else
      return 0;
  }
  return v3;
}

void IOEthernetControllerScheduleWithRunLoop(uint64_t a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  mach_port_t v5;
  __CFMachPort *v7;
  CFRunLoopSourceRef v8;
  __CFSocket *v9;
  CFRunLoopSourceRef RunLoopSource;
  CFMachPortContext v11;

  if (a1)
  {
    if (rl)
    {
      v5 = *(_DWORD *)(a1 + 56);
      if (v5 + 1 >= 2 && *(_DWORD *)(a1 + 88) != -1 && !*(_QWORD *)(a1 + 40) && !*(_QWORD *)(a1 + 48))
      {
        v7 = *(__CFMachPort **)(a1 + 64);
        if (v7
          || (v11.version = 0,
              memset(&v11.retain, 0, 24),
              v11.info = (void *)a1,
              v7 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, (CFMachPortCallBack)__IOEthernetControllerCFMachPortCallBack, &v11, 0), (*(_QWORD *)(a1 + 64) = v7) != 0))
        {
          if (*(_QWORD *)(a1 + 72)
            || (v8 = CFMachPortCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, 0),
                (*(_QWORD *)(a1 + 72) = v8) != 0))
          {
            v9 = *(__CFSocket **)(a1 + 96);
            if (v9
              || (v11.version = 0,
                  memset(&v11.retain, 0, 24),
                  v11.info = (void *)a1,
                  v9 = CFSocketCreateWithNative((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(_DWORD *)(a1 + 88), 1uLL, (CFSocketCallBack)__IOEthernetControllerCFSocketCallback, (const CFSocketContext *)&v11), (*(_QWORD *)(a1 + 96) = v9) != 0))
            {
              if (*(_QWORD *)(a1 + 104)
                || (RunLoopSource = CFSocketCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, 0),
                    (*(_QWORD *)(a1 + 104) = RunLoopSource) != 0))
              {
                CFRunLoopAddSource(rl, *(CFRunLoopSourceRef *)(a1 + 72), mode);
                CFRunLoopAddSource(rl, *(CFRunLoopSourceRef *)(a1 + 104), mode);
                *(_QWORD *)(a1 + 40) = rl;
                *(_QWORD *)(a1 + 48) = mode;
              }
            }
          }
        }
      }
    }
  }
}

uint64_t __IOEthernetControllerCFMachPortCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, _QWORD);
  _QWORD *v8;
  CFTypeRef CFProperty;
  void (*v10)(uint64_t, _QWORD);
  uint32_t outputCnt;
  uint64_t output;

  if (!*(_BYTE *)(a4 + 121))
  {
    CFProperty = IORegistryEntryCreateCFProperty(*(_DWORD *)(a4 + 32), CFSTR("BSD Name"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (CFProperty)
    {
      *(_BYTE *)(a4 + 121) = 1;
      CFRelease(CFProperty);
      v10 = *(void (**)(uint64_t, _QWORD))(a4 + 184);
      if (v10)
        v10(a4, *(_QWORD *)(a4 + 192));
    }
  }
  output = 0;
  outputCnt = 1;
  result = IOConnectCallScalarMethod(*(_DWORD *)(a4 + 20), 2u, 0, 0, &output, &outputCnt);
  v6 = output;
  if (output != *(unsigned __int8 *)(a4 + 120))
  {
    *(_BYTE *)(a4 + 120) = output;
    if (v6)
    {
      v7 = *(uint64_t (**)(uint64_t, _QWORD))(a4 + 136);
      if (!v7)
        return result;
      v8 = (_QWORD *)(a4 + 144);
    }
    else
    {
      v7 = *(uint64_t (**)(uint64_t, _QWORD))(a4 + 152);
      if (!v7)
        return result;
      v8 = (_QWORD *)(a4 + 160);
    }
    return v7(a4, *v8);
  }
  return result;
}

uint64_t __IOEthernetControllerCFSocketCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t (*v5)(_QWORD *, _QWORD);

  if (a5 && a2 == 1 && a5[12] == result)
  {
    v5 = (uint64_t (*)(_QWORD *, _QWORD))a5[21];
    if (v5)
      return v5(a5, a5[22]);
  }
  return result;
}

void IOEthernetControllerUnscheduleFromRunLoop(_QWORD *a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  __CFRunLoopSource *v6;
  __CFRunLoopSource *v7;

  if (a1 && rl)
  {
    v6 = (__CFRunLoopSource *)a1[13];
    if (v6)
      CFRunLoopRemoveSource(rl, v6, mode);
    v7 = (__CFRunLoopSource *)a1[9];
    if (v7)
      CFRunLoopRemoveSource(rl, v7, mode);
    a1[5] = 0;
    a1[6] = 0;
  }
}

void IOEthernetControllerSetDispatchQueue(uint64_t a1, dispatch_queue_t queue)
{
  uintptr_t v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD v9[5];
  _QWORD handler[5];

  if (a1)
  {
    v4 = *(unsigned int *)(a1 + 56);
    if ((v4 + 1) >= 2 && *(_DWORD *)(a1 + 88) != -1)
    {
      v5 = *(NSObject **)(a1 + 80);
      if (queue)
      {
        if (!v5)
        {
          v6 = dispatch_source_create(MEMORY[0x1E0C80D98], v4, 0, queue);
          *(_QWORD *)(a1 + 80) = v6;
          if (v6)
          {
            handler[0] = MEMORY[0x1E0C809B0];
            handler[1] = 0x40000000;
            handler[2] = __IOEthernetControllerSetDispatchQueue_block_invoke;
            handler[3] = &__block_descriptor_tmp_17;
            handler[4] = a1;
            dispatch_source_set_event_handler(v6, handler);
            dispatch_resume(*(dispatch_object_t *)(a1 + 80));
          }
        }
        if (!*(_QWORD *)(a1 + 112) && *(_QWORD *)(a1 + 168))
        {
          v7 = dispatch_source_create(MEMORY[0x1E0C80DB8], *(int *)(a1 + 88), 0, queue);
          *(_QWORD *)(a1 + 112) = v7;
          if (v7)
          {
            v9[0] = MEMORY[0x1E0C809B0];
            v9[1] = 0x40000000;
            v9[2] = __IOEthernetControllerSetDispatchQueue_block_invoke_2;
            v9[3] = &__block_descriptor_tmp_7_1;
            v9[4] = a1;
            dispatch_source_set_event_handler(v7, v9);
            dispatch_resume(*(dispatch_object_t *)(a1 + 112));
          }
        }
      }
      else
      {
        if (v5)
        {
          dispatch_release(v5);
          *(_QWORD *)(a1 + 80) = 0;
        }
        v8 = *(NSObject **)(a1 + 112);
        if (v8)
        {
          dispatch_release(v8);
          *(_QWORD *)(a1 + 112) = 0;
        }
      }
    }
  }
}

uint64_t IOEthernetControllerRegisterEnableCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 136) = a2;
  *(_QWORD *)(result + 144) = a3;
  return result;
}

uint64_t IOEthernetControllerRegisterDisableCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 152) = a2;
  *(_QWORD *)(result + 160) = a3;
  return result;
}

uint64_t IOEthernetControllerRegisterPacketAvailableCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 168) = a2;
  *(_QWORD *)(result + 176) = a3;
  return result;
}

uint64_t IOEthernetControllerRegisterBSDAttachCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 184) = a2;
  *(_QWORD *)(result + 192) = a3;
  return result;
}

uint64_t IOEthernetControllerGetBSDSocket(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 88);
  else
    return 0xFFFFFFFFLL;
}

void __IOEthernetControllerRelease(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  NSObject *v4;
  __CFSocket *v5;
  const void *v6;
  int v7;
  io_connect_t v8;
  io_object_t v9;
  io_object_t v10;
  __CFMachPort *v11;
  const void *v12;
  mach_port_name_t v13;

  v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(NSObject **)(a1 + 80);
  if (v3)
  {
    dispatch_release(v3);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v4 = *(NSObject **)(a1 + 112);
  if (v4)
  {
    dispatch_release(v4);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v5 = *(__CFSocket **)(a1 + 96);
  if (v5)
  {
    CFSocketInvalidate(v5);
    *(_DWORD *)(a1 + 88) = -1;
    CFRelease(*(CFTypeRef *)(a1 + 96));
    *(_QWORD *)(a1 + 96) = 0;
  }
  v6 = *(const void **)(a1 + 104);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v7 = *(_DWORD *)(a1 + 88);
  if (v7 != -1)
  {
    close(v7);
    *(_DWORD *)(a1 + 88) = -1;
  }
  v8 = *(_DWORD *)(a1 + 20);
  if (v8)
  {
    IOServiceClose(v8);
    *(_DWORD *)(a1 + 20) = 0;
  }
  v9 = *(_DWORD *)(a1 + 16);
  if (v9)
  {
    IOObjectRelease(v9);
    *(_DWORD *)(a1 + 16) = 0;
  }
  v10 = *(_DWORD *)(a1 + 32);
  if (v10)
  {
    IOObjectRelease(v10);
    *(_DWORD *)(a1 + 32) = 0;
  }
  v11 = *(__CFMachPort **)(a1 + 64);
  if (v11)
  {
    CFMachPortInvalidate(v11);
    CFRelease(*(CFTypeRef *)(a1 + 64));
    *(_QWORD *)(a1 + 64) = 0;
  }
  v12 = *(const void **)(a1 + 72);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v13 = *(_DWORD *)(a1 + 56);
  if (v13)
  {
    mach_port_mod_refs(*MEMORY[0x1E0C83DA0], v13, 1u, -1);
    *(_DWORD *)(a1 + 56) = 0;
  }
}

uint64_t IOMIGMachPortGetTypeID()
{
  uint64_t result;

  result = __IOMIGMachPortTypeID;
  if (!__IOMIGMachPortTypeID)
  {
    pthread_once(&__IOMIGMachPortTypeInit, (void (*)(void))__IOMIGMachPortRegister);
    return __IOMIGMachPortTypeID;
  }
  return result;
}

void IOMIGMachPortUnscheduleFromRunLoop(uint64_t a1, __CFRunLoop *cf1, const __CFString *a3)
{
  const void *v6;
  _QWORD *v7;
  __CFRunLoopSource *v8;

  if (cf1)
  {
    if (a3)
    {
      v7 = (_QWORD *)(a1 + 16);
      v6 = *(const void **)(a1 + 16);
      if (v6)
      {
        if (*(_QWORD *)(a1 + 24) && CFEqual(cf1, v6) && CFEqual(a3, *(CFTypeRef *)(a1 + 24)))
        {
          *v7 = 0;
          v7[1] = 0;
          v8 = *(__CFRunLoopSource **)(a1 + 56);
          if (v8)
            CFRunLoopRemoveSource(cf1, v8, a3);
        }
      }
    }
  }
}

uint64_t __sOSKextDefaultLogFunction(uint64_t a1, uint64_t a2, char *a3, ...)
{
  FILE *v3;
  va_list va;

  va_start(va, a3);
  v3 = (FILE *)*MEMORY[0x1E0C80C10];
  vfprintf((FILE *)*MEMORY[0x1E0C80C10], a3, va);
  return fputc(10, v3);
}

uint64_t OSKextGetTypeID()
{
  return __kOSKextTypeID;
}

void __OSKextReinit(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 88) & 4) == 0)
    {
      v2 = *(const void **)(a1 + 24);
      if (v2)
        CFRelease(v2);
      *(_QWORD *)(a1 + 24) = 0;
      OSKextFlushDiagnostics(a1, -1);
      *(_DWORD *)(a1 + 92) = 0;
      __OSKextProcessInfoDictionary(a1, 0, v3, v4, v5, v6, v7, v8);
    }
  }
  else if (__sOSKextsByURL)
  {
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextReinitApplierFunction, 0);
  }
}

void OSKextFlushLoadInfo(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef *v9;
  int v10;
  const char *v11;
  char context;
  UInt8 buffer[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  context = a2;
  pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
      __OSKextGetFileSystemPath(a1, 0, 0, buffer, v5, v6, v7, v8);
    v9 = *(CFTypeRef **)(a1 + 72);
    if (v9)
    {
      if ((OSKextFlushLoadInfo_flushingAll & 1) == 0)
      {
        OSKextLog(a1, 262149, "Flushing load info for %s (%s dependencies)", v4, v5, v6, v7, v8, (char)buffer);
        v9 = *(CFTypeRef **)(a1 + 72);
      }
      if (v9[1])
      {
        CFRelease(v9[1]);
        v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[1] = 0;
      if (v9[16])
      {
        CFRelease(v9[16]);
        v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[16] = 0;
      if (v9[17])
      {
        CFRelease(v9[17]);
        v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[17] = 0;
      if (v9[18])
      {
        CFRelease(v9[18]);
        v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[18] = 0;
      if (!a2 || (OSKextFlushDependencies((_QWORD *)a1), (v9 = *(CFTypeRef **)(a1 + 72)) != 0))
        free(v9);
      *(_QWORD *)(a1 + 72) = 0;
      v10 = *(_DWORD *)(a1 + 92);
      if ((~v10 & 0x4900) != 0)
        *(_DWORD *)(a1 + 92) = v10 & 0xFFFD81FF;
    }
  }
  else if (__sOSKextsByURL)
  {
    OSKextFlushLoadInfo_flushingAll = 1;
    v11 = "with";
    if (!a2)
      v11 = "keeping";
    OSKextLog(0, 262149, "Flushing load info for all kexts (%s dependencies)", v4, v5, v6, v7, v8, (char)v11);
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushLoadInfoApplierFunction, &context);
    OSKextFlushLoadInfo_flushingAll = 0;
  }
}

char **OSKextGetArchitecture()
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  return __sOSKextArchInfo;
}

uint64_t OSKextGetExecutableURL(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  _BOOL4 v16;
  const __CFDictionary *ValueForInfoDictionaryKey;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFDictionary *v22;
  const __CFString *Value;
  int v24;
  const __CFString *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFString *v29;
  const __CFString *v30;
  uint64_t v31;
  __CFString *v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFAllocator *v39;
  CFStringRef v40;
  const __CFString *v41;
  const __CFAllocator *v42;
  CFURLRef v43;
  char v44;
  stat v45;
  char buffer[16];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  UInt8 __s[1024];
  UInt8 v55[1024];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  result = a1[4];
  if (!result)
  {
    memset(&v45, 0, sizeof(v45));
    __OSKextGetFileSystemPath((uint64_t)a1, 0, 1u, v55, a5, a6, a7, a8);
    OSKextLog((uint64_t)a1, 131079, "Checking CFBundle of %s for executable URL.", v10, v11, v12, v13, v14, (char)v55);
    v15 = (const __CFString *)_CFBundleCopyExecutableURLInDirectory();
    if (v15)
    {
LABEL_3:
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v16 = v15 != 0;
      *(_OWORD *)buffer = 0u;
      v47 = 0u;
      if (v15 && __sOSKextTargetString)
      {
        ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, CFSTR("OSKextVariantOverride"));
        if (ValueForInfoDictionaryKey
          && (v22 = ValueForInfoDictionaryKey,
              CFDictionaryContainsKey(ValueForInfoDictionaryKey, (const void *)__sOSKextTargetString))
          && (Value = (const __CFString *)CFDictionaryGetValue(v22, (const void *)__sOSKextTargetString)) != 0
          && !CFStringGetCString(Value, buffer, 128, 0x8000100u))
        {
          *(_QWORD *)buffer = 0;
          v16 = 1;
        }
        else
        {
          v24 = buffer[0];
          v16 = 1;
          if (buffer[0])
            goto LABEL_21;
        }
      }
LABEL_20:
      __strlcpy_chk();
      v24 = buffer[0];
      if (!v16)
      {
LABEL_27:
        if (v15)
          goto LABEL_28;
        return a1[4];
      }
LABEL_21:
      if (v24)
      {
        if (!__OSKextGetFileSystemPath(0, (CFURLRef)v15, 1u, __s, v18, v19, v20, v21))
        {
LABEL_29:
          CFRelease(v15);
          return a1[4];
        }
        v33 = strlen((const char *)__s);
        strlcpy((char *)&__s[v33], buffer, 1024 - v33);
        OSKextLog((uint64_t)a1, 131079, "Statting %s for suffix.", v34, v35, v36, v37, v38, (char)__s);
        if (!stat((const char *)__s, &v45))
        {
          v39 = CFGetAllocator(a1);
          v40 = CFStringCreateWithCString(v39, (const char *)__s, 0x8000100u);
          if (v40)
          {
            v41 = v40;
            v42 = CFGetAllocator(a1);
            v43 = CFURLCreateWithFileSystemPath(v42, v41, kCFURLPOSIXPathStyle, 0);
            CFRelease(v41);
            if (v43)
            {
              CFRelease(v15);
              v15 = (const __CFString *)v43;
            }
          }
        }
LABEL_28:
        a1[4] = CFRetain(v15);
        goto LABEL_29;
      }
      goto LABEL_27;
    }
    v25 = (const __CFString *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, (const __CFString *)*MEMORY[0x1E0C9AE70]);
    if (v25)
    {
      v29 = v25;
      v30 = CFSTR("Kext has a CFBundleExecutable property but the executable can't be found");
      v31 = (uint64_t)a1;
    }
    else
    {
      v32 = (__CFString *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, CFSTR("OSBundleSharedExecutableIdentifier"));
      v15 = v32;
      if (!v32)
      {
        v16 = 0;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        *(_OWORD *)buffer = 0u;
        v47 = 0u;
        goto LABEL_20;
      }
      if (OSKextGetKextWithIdentifier(v32))
      {
        v15 = (const __CFString *)_CFBundleCopyExecutableURLInDirectory();
        goto LABEL_3;
      }
      v30 = CFSTR("Kext claims a shared executable with named kext, but that kext can't be found");
      v31 = (uint64_t)a1;
      v29 = v15;
    }
    __OSKextAddDiagnostic(v31, 1, v30, v29, 0, v26, v27, v28, v44);
    return a1[4];
  }
  return result;
}

uint64_t __OSKextGetFileSystemPath(uint64_t a1, CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char v11;

  if (a1)
    url = *(CFURLRef *)(a1 + 16);
  if (!url || (result = CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, 1024), !(_DWORD)result))
  {
    OSKextLog(a1, 17, "String/URL conversion failure.", (uint64_t)buffer, a5, a6, a7, a8, v11);
    result = 0;
    strcpy((char *)buffer, "(unknown)");
  }
  return result;
}

uint64_t OSKextGetURL(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

const void *OSKextGetValueForInfoDictionaryKey(uint64_t a1, const __CFString *a2)
{
  const __CFDictionary *v4;
  CFStringRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFStringRef v11;
  const void *Value;
  const void *v13;

  if (!__OSKextReadInfoDictionary(a1, 0))
    return 0;
  if (CFStringHasPrefix(a2, CFSTR("OS")) || CFStringHasPrefix(a2, CFSTR("IO")))
  {
    pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
    if (NXGetArchInfoFromCpuType(*((_DWORD *)__sOSKextArchInfo + 2), -1))
    {
      v4 = *(const __CFDictionary **)(a1 + 56);
      v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@%s%s"));
      if (v5)
      {
        v11 = v5;
        Value = CFDictionaryGetValue(v4, v5);
        if (Value)
        {
          v13 = Value;
          CFRelease(v11);
          return v13;
        }
        v13 = CFDictionaryGetValue(v4, a2);
        CFRelease(v11);
        if (v13)
          return v13;
      }
      else
      {
        OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, (char)a2);
      }
    }
  }
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
}

void __OSKextAddDiagnostic(uint64_t a1, int a2, const void *a3, const __CFString *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFStringRef v10;
  CFMutableDictionaryRef Diagnostics;
  const __CFDictionary *v14;
  CFTypeID v15;
  CFStringRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFStringRef v22;
  CFStringRef v23;
  CFTypeID v24;
  const __CFString *Mutable;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __CFString *Value;
  __CFString *v32;
  CFTypeID TypeID;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFString *v39;
  char v40;
  CFRange v41;

  if (!a4)
    return;
  if ((__sOSKextRecordsDiagnositcs & a2) == 0)
    return;
  v10 = a4;
  Diagnostics = __OSKextGetDiagnostics(a1, a2);
  if (!Diagnostics)
    return;
  v14 = Diagnostics;
  v15 = CFGetTypeID(v10);
  if (v15 == CFURLGetTypeID())
  {
    v16 = CFURLCopyFileSystemPath((CFURLRef)v10, kCFURLPOSIXPathStyle);
    if (v16)
    {
      v22 = v16;
      v23 = 0;
      goto LABEL_10;
    }
    goto LABEL_12;
  }
  v24 = CFGetTypeID(v10);
  if (v24 == CFArrayGetTypeID())
  {
    v16 = CFStringCreateByCombiningStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFArrayRef)v10, CFSTR("."));
    if (v16)
    {
      v23 = v16;
      v22 = 0;
LABEL_10:
      v10 = v16;
      if (!a5)
        goto LABEL_15;
      goto LABEL_14;
    }
LABEL_12:
    OSKextLog((uint64_t)v16, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, a9);
    return;
  }
  v23 = 0;
  v22 = 0;
  if (!a5)
    goto LABEL_15;
LABEL_14:
  Mutable = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@ - %@"), v10, a5);
  a5 = Mutable;
  v10 = Mutable;
  if (!Mutable)
    goto LABEL_25;
LABEL_15:
  Value = (__CFString *)CFDictionaryGetValue(v14, a3);
  if (Value)
  {
    v32 = Value;
    TypeID = CFArrayGetTypeID();
    if (TypeID != CFGetTypeID(v32))
    {
      OSKextLog(a1, 262145, "Internal error in diagnositcs recording", v34, v35, v36, v37, v38, v40);
      if (!v23)
        goto LABEL_28;
      goto LABEL_27;
    }
    v39 = 0;
    goto LABEL_20;
  }
  Mutable = (const __CFString *)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
LABEL_25:
    OSKextLog((uint64_t)Mutable, 17, "Memory allocation failure.", v26, v27, v28, v29, v30, v40);
    goto LABEL_26;
  }
  v39 = Mutable;
  CFDictionarySetValue(v14, a3, Mutable);
  v32 = (__CFString *)v39;
LABEL_20:
  v41.length = CFArrayGetCount((CFArrayRef)v32);
  v41.location = 0;
  if (!CFArrayGetCountOfValue((CFArrayRef)v32, v41, v10))
    CFArrayAppendValue((CFMutableArrayRef)v32, v10);
  if (v39)
  {
    CFRelease(v39);
    if (!v23)
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_26:
  if (v23)
LABEL_27:
    CFRelease(v23);
LABEL_28:
  if (a5)
    CFRelease(a5);
  if (v22)
    CFRelease(v22);
}

const __CFArray *OSKextGetKextWithIdentifier(void *a1)
{
  const __CFArray *Value;
  const __CFArray *v3;
  uint64_t v4;
  CFTypeID TypeID;

  if (__sOSKextsByIdentifier)
  {
    __OSKextRealizeKextsWithIdentifier(a1);
    Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
    v3 = Value;
    if (!Value)
      return v3;
    v4 = __kOSKextTypeID;
    if (v4 == CFGetTypeID(Value))
      return v3;
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v3) && CFArrayGetCount(v3))
      return (const __CFArray *)CFArrayGetValueAtIndex(v3, 0);
  }
  return 0;
}

uint64_t OSKextGetKernelExecutableURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a1 + 92) & 8) != 0)
    return 0;
  else
    return OSKextGetExecutableURL((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t OSKextDeclaresUserExecutable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 3) & 1;
}

uint64_t OSKextGetUserExecutableURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a1 + 92) & 8) != 0)
    return OSKextGetExecutableURL((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  else
    return 0;
}

void OSKextSetExecutableSuffix(uint64_t a1, char *__s1)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  const char *v6;
  char *v7;
  size_t v8;
  size_t v9;

  if (a1)
  {
    __strlcpy_chk();
    return;
  }
  if (!__s1)
    goto LABEL_10;
  v2 = strndup(__s1, 0x400uLL);
  if (!v2)
    goto LABEL_10;
  v3 = v2;
  v4 = basename(v2);
  if (!v4 || (v5 = strchr(v4, 46)) == 0)
  {
    free(v3);
LABEL_10:
    OSKextExecutableVariant = 0;
    return;
  }
  v6 = v5 + 1;
  v7 = strchr(v5 + 1, 46);
  if (v7)
    v8 = v7 - v6;
  else
    v8 = strlen(v6);
  if (v8 + 2 >= 0x80)
    v9 = 128;
  else
    v9 = v8 + 2;
  __snprintf_chk(&OSKextExecutableVariant, v9, 0, 0x80uLL, "_%s", v6);
  free(v3);
}

uint64_t OSKextSetTargetString(char *cStr)
{
  CFStringRef v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (__sOSKextTargetString)
  {
    CFRelease((CFTypeRef)__sOSKextTargetString);
    __sOSKextTargetString = 0;
  }
  v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  if (v2)
  {
    __sOSKextTargetString = (uint64_t)v2;
    return 1;
  }
  else
  {
    OSKextLog(0, 17, "%s %d - cannot allocate memory for target string", v3, v4, v5, v6, v7, (char)"OSKextSetTargetString");
    return 0;
  }
}

uint64_t OSKextGetTargetString()
{
  return __sOSKextTargetString;
}

void OSKextSetLogFilter(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  int v9;
  const char *v10;

  if (a2)
    v8 = &__sKernelLogFilter;
  else
    v8 = &__sUserLogFilter;
  v9 = *v8;
  *v8 = a1;
  if (v9 != a1)
  {
    v10 = "kernel";
    if (!a2)
      v10 = "user";
    OSKextLog(0, 23, "Kext %s-space log filter changed from 0x%x to 0x%x.", a4, a5, a6, a7, a8, (char)v10);
  }
}

uint64_t OSKextGetLogFilter(int a1)
{
  int *v1;

  v1 = &__sKernelLogFilter;
  if (!a1)
    v1 = &__sUserLogFilter;
  return *v1;
}

uint64_t (*OSKextSetLogOutputFunction(uint64_t (*result)(int, int, char *)))(int, int, char *)
{
  __sOSKextLogOutputFunction = result;
  return result;
}

void OSKextSetSimulatedSafeBoot(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  const char *v10;

  v9 = __sOSKextSimulatedSafeBoot;
  v10 = "true";
  if (!a1)
    v10 = "false";
  OSKextLog(0, 262150, "Kext library setting simulated safe boot mode to %s.", a4, a5, a6, a7, a8, (char)v10);
  __sOSKextSimulatedSafeBoot = a1;
  if (v9 != a1)
  {
    if (__sOSKextsByURL)
      CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextReinitApplierFunction, 0);
  }
}

uint64_t OSKextGetSimulatedSafeBoot()
{
  return __sOSKextSimulatedSafeBoot;
}

uint64_t OSKextGetActualSafeBoot()
{
  int *v0;
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  size_t v8;
  int v9;
  int v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  *(_QWORD *)v10 = 0x4200000001;
  if ((OSKextGetActualSafeBoot_gotIt & 1) == 0)
  {
    v8 = 4;
    if (sysctl(v10, 2u, &v9, &v8, 0, 0))
    {
      v0 = __error();
      v1 = strerror(*v0);
      OSKextLog(0, 81, "Can't determine actual safe boot mode - sysctl() failed for KERN_SAFEBOOT - %s.", v2, v3, v4, v5, v6, v1);
    }
    else
    {
      OSKextGetActualSafeBoot_result = v9 != 0;
      OSKextGetActualSafeBoot_gotIt = 1;
    }
  }
  return OSKextGetActualSafeBoot_result;
}

void OSKextSetRecordsDiagnostics(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;

  v9 = " for:";
  if (!a1)
    v9 = " off";
  OSKextLog(0, 3436582, "Kext library recording diagnostics%s%s%s%s%s.", a4, a5, a6, a7, a8, (char)v9);
  __sOSKextRecordsDiagnositcs = a1;
}

uint64_t OSKextGetRecordsDiagnostics()
{
  return __sOSKextRecordsDiagnositcs;
}

void OSKextSetUsesCaches(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  const char *v9;

  v8 = a1;
  v9 = "now";
  if (!a1)
    v9 = "not";
  OSKextLog(0, 262150, "Kext library %s using caches.", a4, a5, a6, a7, a8, (char)v9);
  __sOSKextUsesCaches = v8;
}

uint64_t OSKextGetUsesCaches()
{
  return __sOSKextUsesCaches;
}

uint64_t _OSKextSetStrictRecordingByLastOpened(uint64_t result)
{
  __sOSKextStrictRecordingByLastOpened = result;
  return result;
}

uint64_t _OSKextSetStrictAuthentication(uint64_t result)
{
  __sOSKextStrictAuthentication = result;
  return result;
}

uint64_t (*_OSKextSetAuthenticationFunction(uint64_t (*result)(), uint64_t a2))()
{
  __sOSKextAuthenticationFunction[0] = result;
  __sOSKextAuthenticationContext = a2;
  return result;
}

void *_OSKextSetLoadAuditFunction(void *result)
{
  __sOSKextLoadAuditFunction = result;
  return result;
}

void *_OSKextSetPersonalityPatcherFunction(void *result)
{
  __sOSKextPersonalityPatcherFunction = result;
  return result;
}

_QWORD *OSKextCreate(uint64_t a1, const __CFURL *a2)
{
  CFStringRef v3;
  CFStringRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  const __CFURL *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFURL *v21;
  _BYTE *KextWithURL;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFAllocator *v39;
  CFBundleRef v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  CFBundleRef v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char v67;
  char v68;
  char __s[1024];
  UInt8 buffer[1024];
  UInt8 v71[1024];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v3 = CFURLCopyPathExtension(a2);
  if (v3)
  {
    v4 = v3;
    if ((CFEqual(v3, CFSTR("kext")) || CFEqual(v4, CFSTR("dext")))
      && __OSKextGetFileSystemPath(0, a2, 1u, buffer, v5, v6, v7, v8))
    {
      if (realpath_DARWIN_EXTSN((const char *)buffer, __s))
      {
        v14 = strlen(__s);
        v15 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)__s, v14, 1u);
        if (v15)
        {
          v21 = v15;
          KextWithURL = OSKextGetKextWithURL(v15);
          if (KextWithURL)
          {
            v28 = KextWithURL;
            OSKextLog(0, 393223, "%s is already open; returning existing object.",
              v23,
              v24,
              v25,
              v26,
              v27,
              (char)buffer);
            CFRetain(v28);
LABEL_22:
            CFRelease(v21);
            goto LABEL_23;
          }
          OSKextLog(0, 393223, "Creating %s.", v23, v24, v25, v26, v27, (char)__s);
          v28 = __OSKextAlloc();
          if (!v28)
          {
            OSKextLog(0, 17, "Memory allocation failure.", v29, v30, v31, v32, v33, v68);
            goto LABEL_22;
          }
          __OSKextGetFileSystemPath(0, v21, 1u, v71, v30, v31, v32, v33);
          OSKextLog((uint64_t)v28, 131079, "Opening CFBundle for %s.", v34, v35, v36, v37, v38, (char)v71);
          v39 = CFGetAllocator(v28);
          v40 = CFBundleCreate(v39, v21);
          if (v40)
          {
            v46 = v40;
            v28[2] = CFRetain(v21);
            if (__OSKextReadInfoDictionary((uint64_t)v28, (uint64_t)v46))
            {
              __OSKextProcessInfoDictionary((uint64_t)v28, (uint64_t)v46, v47, v48, v49, v50, v51, v52);
              v60 = __OSKextRecordKext((uint64_t)v28, v53, v54, v55, v56, v57, v58, v59);
              OSKextLog((uint64_t)v28, 131079, "Releasing CFBundle for %s", v61, v62, v63, v64, v65, (char)v71);
              CFRelease(v46);
              if (v60)
                goto LABEL_22;
            }
            else
            {
              OSKextLog((uint64_t)v28, 131079, "Releasing CFBundle for %s", v48, v49, v50, v51, v52, (char)v71);
              CFRelease(v46);
            }
          }
          else
          {
            OSKextLog(0, 131073, "Can't open CFBundle for %s.", v41, v42, v43, v44, v45, (char)v71);
          }
          CFRelease(v28);
          v28 = 0;
          goto LABEL_22;
        }
        OSKextLog(0, 17, "Memory allocation failure.", v16, v17, v18, v19, v20, v67);
      }
      else
      {
        OSKextLog(0, 131073, "Unable to determine realpath for %s - failing.", v9, v10, v11, v12, v13, (char)buffer);
      }
    }
    v28 = 0;
LABEL_23:
    CFRelease(v4);
    return v28;
  }
  return 0;
}

_BYTE *OSKextGetKextWithURL(const __CFURL *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFAllocator *v15;
  size_t v16;
  CFURLRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFURLRef v23;
  _BYTE *Value;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  char v34;
  char __s[1024];
  UInt8 v36[1024];
  UInt8 buffer[1024];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (!__OSKextGetFileSystemPath(0, a1, 0, buffer, v2, v3, v4, v5)
    || !__OSKextGetFileSystemPath(0, a1, 1u, v36, v6, v7, v8, v9))
  {
    return 0;
  }
  if (!realpath_DARWIN_EXTSN((const char *)v36, __s))
  {
    OSKextLog(0, 131073, "Unable to determine realpath for %s - failing.", v10, v11, v12, v13, v14, (char)v36);
    return 0;
  }
  v15 = CFGetAllocator(a1);
  v16 = strlen(__s);
  v17 = CFURLCreateFromFileSystemRepresentation(v15, (const UInt8 *)__s, v16, 1u);
  if (!v17)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, v34);
    return 0;
  }
  v23 = v17;
  if (__sOSKextsByURL)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByURL, v17);
    v32 = Value;
    if (Value && (Value[88] & 4) != 0)
      __OSKextRealize((uint64_t)Value, v25, v26, v27, v28, v29, v30, v31);
  }
  else
  {
    v32 = 0;
  }
  CFRelease(v23);
  return v32;
}

_OWORD *__OSKextAlloc()
{
  _OWORD *Instance;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  char v8;

  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v6 = Instance;
  if (Instance)
  {
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    Instance[1] = 0u;
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v1, v2, v3, v4, v5, v8);
  }
  return v6;
}

const __CFArray *OSKextCreateKextsFromURL(const __CFAllocator *a1, const __CFURL *a2)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  return __OSKextCreateKextsFromURL(a1, a2, 0, 1);
}

const __CFArray *__OSKextCreateKextsFromURL(const __CFAllocator *a1, const __CFURL *a2, uint64_t a3, int a4)
{
  CFStringRef v8;
  CFStringRef v9;
  CFMutableArrayRef Mutable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFArray *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFBundle *v26;
  const __CFArray *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFBoolean *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFBoolean *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  CFMutableArrayRef v45;
  const __CFArray *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const __CFArray *v52;
  CFIndex Count;
  CFIndex v54;
  CFIndex v55;
  const __CFArray *v56;
  const __CFURL *ValueAtIndex;
  CFStringRef v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFArray *KextsFromURL;
  __CFArray *v69;
  const __CFArray *v70;
  const char *v71;
  int v72;
  const void *v73;
  UInt8 *v75;
  SInt32 errorCode;
  const __CFArray *v77;
  UInt8 v78[1024];
  UInt8 buffer[1024];
  uint64_t v80;
  CFRange v81;
  CFRange v82;

  v80 = *MEMORY[0x1E0C80C00];
  v77 = 0;
  v8 = CFURLCopyPathExtension(a2);
  v9 = v8;
  if (v8 && (CFEqual(v8, CFSTR("kext")) || CFEqual(v9, CFSTR("dext"))))
  {
    Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
    v77 = Mutable;
    if (Mutable)
    {
      v16 = Mutable;
      v17 = OSKextCreate((uint64_t)a1, a2);
      if (v17)
      {
        v18 = (uint64_t)v17;
        CFArrayAppendValue(v16, v17);
        if (a4)
        {
          v26 = OSKextCopyPlugins(v18, v19, v20, v21, v22, v23, v24, v25);
          v27 = v26;
          if (v26 && CFArrayGetCount(v26))
          {
            v81.length = CFArrayGetCount(v27);
            v81.location = 0;
            CFArrayAppendArray(v16, v27, v81);
          }
        }
        else
        {
          v27 = 0;
        }
        CFRelease(v9);
        v73 = (const void *)v18;
        goto LABEL_53;
      }
    }
    else
    {
      OSKextLog(0, 17, "Memory allocation failure.", v11, v12, v13, v14, v15, (char)v75);
    }
    v70 = (const __CFArray *)v9;
LABEL_56:
    CFRelease(v70);
    return v77;
  }
  errorCode = 0;
  v27 = CFURLCopyAbsoluteURL(a2);
  if (!v27)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v28, v29, v30, v31, v32, (char)v75);
    v39 = 0;
    goto LABEL_43;
  }
  __OSKextGetFileSystemPath(0, v27, 1u, buffer, v29, v30, v31, v32);
  v33 = (const __CFBoolean *)CFURLCreatePropertyFromResource(a1, a2, (CFStringRef)*MEMORY[0x1E0C9B438], &errorCode);
  v39 = v33;
  if (!v33)
  {
    v75 = buffer;
    v71 = "Failed to check path %s (CF error %ld).";
    v45 = (CFMutableArrayRef)a3;
    v72 = 131073;
LABEL_38:
    OSKextLog((uint64_t)v45, v72, v71, v34, v35, v36, v37, v38, (char)v75);
    goto LABEL_43;
  }
  if (!CFBooleanGetValue(v33))
  {
    if (!a3)
      OSKextLog(0, 131076, "%s: %s - no such file or directory.", v40, v41, v42, v43, v44, (char)"__OSKextCreateKextsFromURL");
    goto LABEL_43;
  }
  if (_OSKextReadFromIdentifierCacheForFolder(v27, (CFTypeRef *)&v77))
  {
LABEL_43:
    v52 = 0;
    goto LABEL_44;
  }
  v45 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  v77 = v45;
  if (!v45)
  {
    v71 = "Memory allocation failure.";
    v72 = 17;
    goto LABEL_38;
  }
  OSKextLog(a3, 65540, "Scanning %s for kexts.", v34, v35, v36, v37, v38, (char)buffer);
  v46 = (const __CFArray *)CFURLCreatePropertyFromResource(a1, a2, (CFStringRef)*MEMORY[0x1E0C9B430], &errorCode);
  v52 = v46;
  if (!v46 || errorCode)
  {
    v56 = 0;
    if (errorCode == -12 || !errorCode)
      goto LABEL_45;
    OSKextLog(a3, 131073, "Failed to read contents of %s, CFURL error %d.", v47, v48, v49, v50, v51, (char)buffer);
LABEL_44:
    v56 = 0;
    goto LABEL_45;
  }
  Count = CFArrayGetCount(v46);
  if (Count < 1)
  {
    v56 = 0;
  }
  else
  {
    v54 = Count;
    v55 = 0;
    v56 = 0;
    do
    {
      ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v52, v55);
      if (v9)
        CFRelease(v9);
      if (v56)
        CFRelease(v56);
      v58 = CFURLCopyPathExtension(ValueAtIndex);
      v9 = v58;
      if (v58 && (CFEqual(v58, CFSTR("kext")) || CFEqual(v9, CFSTR("dext"))))
      {
        __OSKextGetFileSystemPath(0, ValueAtIndex, 0, v78, v59, v60, v61, v62);
        if (a3)
          OSKextLog(a3, 65542, "Found plugin %s.", v63, v64, v65, v66, v67, (char)v78);
        else
          OSKextLog(0, 65542, "Found %s.", v63, v64, v65, v66, v67, (char)v78);
        pthread_once(&__sOSKextInitialized, __OSKextInitialize);
        KextsFromURL = (const __CFArray *)__OSKextCreateKextsFromURL(a1, ValueAtIndex, 0, 1);
        v56 = KextsFromURL;
        if (KextsFromURL)
        {
          v69 = v77;
          v82.length = CFArrayGetCount(KextsFromURL);
          v82.location = 0;
          CFArrayAppendArray(v69, v56, v82);
        }
      }
      else
      {
        v56 = 0;
      }
      ++v55;
    }
    while (v54 != v55);
  }
  _OSKextWriteIdentifierCacheForKextsInDirectory(v77, v27, 0);
LABEL_45:
  if (v9)
    CFRelease(v9);
  if (v39)
    CFRelease(v39);
  if (v52)
    CFRelease(v52);
  if (v56)
  {
    v73 = v56;
LABEL_53:
    CFRelease(v73);
  }
  if (v27)
  {
    v70 = v27;
    goto LABEL_56;
  }
  return v77;
}

__CFArray *OSKextCreateKextsFromURLs(const __CFAllocator *a1, const __CFArray *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v11;
  const __CFArray *v12;
  CFIndex i;
  const __CFURL *ValueAtIndex;
  const __CFArray *KextsFromURL;
  CFIndex v16;
  const void *v17;
  CFIndex v18;
  char v20;
  CFRange v21;

  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      v11 = Count;
      v12 = 0;
      for (i = 0; i != v11; ++i)
      {
        while (1)
        {
          ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(a2, i);
          if (v12)
            CFRelease(v12);
          KextsFromURL = __OSKextCreateKextsFromURL(a1, ValueAtIndex, 0, 1);
          v12 = KextsFromURL;
          if (KextsFromURL)
            break;
          if (++i == v11)
            goto LABEL_12;
        }
        v21.length = CFArrayGetCount(KextsFromURL);
        v21.location = 0;
        CFArrayAppendArray(Mutable, v12, v21);
      }
      CFRelease(v12);
    }
LABEL_12:
    if (CFArrayGetCount(Mutable) && CFArrayGetCount(Mutable) >= 1)
    {
      v16 = 0;
      do
      {
        v17 = CFArrayGetValueAtIndex(Mutable, v16++);
        if (v16 < CFArrayGetCount(Mutable))
        {
          v18 = v16;
          do
          {
            if (v17 == CFArrayGetValueAtIndex(Mutable, v18))
              CFArrayRemoveValueAtIndex(Mutable, v18);
            else
              ++v18;
          }
          while (v18 < CFArrayGetCount(Mutable));
        }
      }
      while (v16 < CFArrayGetCount(Mutable));
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v20);
  }
  return Mutable;
}

uint64_t _OSKextReadFromIdentifierCacheForFolder(const __CFURL *a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef *p_cf;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeID TypeID;
  const void *Value;
  const void *v21;
  CFTypeID v22;
  const void *v23;
  const void *v24;
  CFTypeID v25;
  const __CFArray *v26;
  const __CFArray *v27;
  CFTypeID v28;
  CFMutableArrayRef Mutable;
  const __CFArray *v30;
  CFIndex Count;
  CFIndex v32;
  CFIndex v33;
  CFTypeRef *v34;
  const void *v35;
  CFTypeID v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFAllocator *v42;
  uint64_t v43;
  const char *v44;
  int v45;
  CFIndex v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  const void *ValueAtIndex;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  UInt8 *v62;
  int valuePtr;
  CFTypeRef cf;
  UInt8 buffer[1024];
  uint64_t v66;
  CFRange v67;

  v66 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  cf = 0;
  valuePtr = 0;
  if (!__sOSKextUsesCaches)
    return 0;
  if (!__OSKextGetFileSystemPath(0, a1, 1u, buffer, v4, v5, v6, v7))
  {
    v44 = "String/URL conversion failure.";
LABEL_30:
    v45 = 17;
LABEL_35:
    OSKextLog(0, v45, v44, v8, v9, v10, v11, v12, (char)v62);
LABEL_36:
    v43 = 0;
    v34 = 0;
    goto LABEL_37;
  }
  if (a2)
    p_cf = &cf;
  else
    p_cf = 0;
  if (!_OSKextReadCache(a1, (uint64_t)CFSTR("KextIdentifiers"), 0, 2, 1, p_cf))
    goto LABEL_36;
  if (a2)
  {
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(cf))
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("OSKextIdentifierCacheVersion"));
      if (Value
        && (v21 = Value, v22 = CFNumberGetTypeID(), v22 == CFGetTypeID(v21))
        && CFNumberGetValue((CFNumberRef)v21, kCFNumberSInt32Type, &valuePtr))
      {
        if (valuePtr == 2)
        {
          v23 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("OSKextIdentifierCacheBasePath"));
          if (v23 && (v24 = v23, v25 = CFStringGetTypeID(), v25 == CFGetTypeID(v24)))
          {
            v26 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("OSKextIdentifierCacheKextInfo"));
            if (v26)
            {
              v27 = v26;
              v28 = CFArrayGetTypeID();
              if (v28 == CFGetTypeID(v27))
              {
                OSKextLog(0, 262148, "Creating kexts from identifier->path cache for %s.", v8, v9, v10, v11, v12, (char)buffer);
                Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
                if (Mutable)
                {
                  v30 = Mutable;
                  Count = CFArrayGetCount(v27);
                  if (Count < 1)
                  {
                    v34 = 0;
LABEL_47:
                    v47 = CFArrayGetCount(v30);
                    if (v47 >= 1)
                    {
                      v53 = v47 + 1;
                      do
                      {
                        ValueAtIndex = CFArrayGetValueAtIndex(v30, v53 - 2);
                        if (!__OSKextRecordKext((uint64_t)ValueAtIndex, v55, v56, v57, v58, v59, v60, v61))
                          CFArrayRemoveValueAtIndex(v30, v53 - 2);
                        --v53;
                      }
                      while (v53 > 1);
                    }
                    OSKextLog(0, 393220, "Finished reading identifier->path cache for %s.", v48, v49, v50, v51, v52, (char)buffer);
                    *a2 = CFRetain(v30);
                    v43 = 1;
                  }
                  else
                  {
                    v32 = Count;
                    v33 = 0;
                    v34 = 0;
                    while (1)
                    {
                      v35 = CFArrayGetValueAtIndex(v27, v33);
                      v36 = CFDictionaryGetTypeID();
                      if (v36 != CFGetTypeID(v35))
                        break;
                      if (v34)
                        CFRelease(v34);
                      v42 = CFGetAllocator(0);
                      v34 = __OSKextCreateFromIdentifierCacheDict(v42, (CFDictionaryRef)v35, (uint64_t)v24, v33);
                      if (!v34)
                        goto LABEL_54;
                      v67.length = CFArrayGetCount(v30);
                      v67.location = 0;
                      if (CFArrayGetFirstIndexOfValue(v30, v67, v34) == -1)
                        CFArrayAppendValue(v30, v34);
                      if (v32 == ++v33)
                        goto LABEL_47;
                    }
                    OSKextLog(0, 1, "Kext identifier->path cache for %s - kext entry not a dictionary.", v37, v38, v39, v40, v41, (char)buffer);
LABEL_54:
                    v43 = 0;
                  }
                  CFRelease(v30);
                  goto LABEL_37;
                }
                v44 = "Memory allocation failure.";
                goto LABEL_30;
              }
            }
            v44 = "Kext identifier->path cache - kext info is not an array.";
          }
          else
          {
            v62 = buffer;
            v44 = "Kext identifier->path cache for %s - base path missing or invalid.";
          }
        }
        else
        {
          v62 = buffer;
          v44 = "Kext identifier->path cache for %s - version %d unsupported.";
        }
      }
      else
      {
        v62 = buffer;
        v44 = "Kext identifier->cache for %s - cache version missing/invalid.";
      }
    }
    else
    {
      v62 = buffer;
      v44 = "Kext identifier->path cache for %s - not a dictionary.";
    }
    v45 = 262145;
    goto LABEL_35;
  }
  OSKextLog(0, 262151, "Kext identifier->path cache for %s is up to date.", v14, v15, v16, v17, v18, (char)buffer);
  v34 = 0;
  v43 = 1;
LABEL_37:
  if (cf)
    CFRelease(cf);
  if (v34)
    CFRelease(v34);
  return v43;
}

uint64_t _OSKextReadCache(const void *a1, uint64_t a2, const char **a3, int a4, int a5, CFTypeRef *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFURL *CacheFileURL;
  char v18;
  uint64_t v19;
  void *UTF8CStringForCFString;
  CFDataRef v21;
  void *v22;
  const __CFAllocator *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  Bytef *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v50;
  const __CFAllocator *v51;
  CFDataRef v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  CFPropertyListRef v58;
  const char *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  z_stream strm;
  CFTypeRef v68;
  SInt32 errorCode;
  CFTypeRef cf;
  UInt8 buffer[1024];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  cf = 0;
  errorCode = 0;
  v68 = 0;
  memset(&strm, 0, sizeof(strm));
  CacheFileURL = __OSKextCreateCacheFileURL(a1, a2, a3, a4);
  if (!CacheFileURL)
  {
    v19 = 0;
    UTF8CStringForCFString = 0;
    v21 = 0;
    v22 = 0;
    v18 = 1;
    goto LABEL_7;
  }
  v18 = 1;
  if (!__OSKextGetFileSystemPath(0, CacheFileURL, 1u, buffer, v13, v14, v15, v16)
    || __OSKextCacheNeedsUpdate(CacheFileURL, a1))
  {
    goto LABEL_4;
  }
  if (!a6)
  {
    UTF8CStringForCFString = 0;
    v21 = 0;
    v22 = 0;
LABEL_32:
    v19 = 1;
    goto LABEL_7;
  }
  OSKextLog(0, 393220, "Reading cache file %s.", v12, v13, v14, v15, v16, (char)buffer);
  v24 = CFGetAllocator(CacheFileURL);
  if (!CFURLCreateDataAndPropertiesFromResource(v24, CacheFileURL, (CFDataRef *)&cf, 0, 0, &errorCode))
  {
    OSKextLog(0, 131073, "Can't open cache file %s, CF error %d.", v25, v26, v27, v28, v29, (char)buffer);
LABEL_4:
    v19 = 0;
    UTF8CStringForCFString = 0;
    v21 = 0;
LABEL_5:
    v22 = 0;
    goto LABEL_7;
  }
  strm.next_in = (Bytef *)CFDataGetBytePtr((CFDataRef)cf);
  strm.avail_in = CFDataGetLength((CFDataRef)cf);
  v30 = 5 * strm.avail_in;
  memset(&strm.zalloc, 0, 24);
  v31 = (Bytef *)malloc_type_malloc(v30, 0x30CAEF9CuLL);
  v22 = v31;
  if (!v31)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v32, v33, v34, v35, v36, v66);
    v19 = 0;
    UTF8CStringForCFString = 0;
    v21 = 0;
    goto LABEL_7;
  }
  strm.next_out = v31;
  strm.avail_out = v30;
  if (inflateInit2_(&strm, 47, "1.2.12", 112))
  {
    OSKextLog(0, 131073, "Error initializing zlib uncompression for %s.", v37, v38, v39, v40, v41, (char)buffer);
    goto LABEL_4;
  }
  v42 = 16;
  while (1)
  {
    v43 = inflate(&strm, 0);
    if (v43 != -5 && v43 != 0)
      break;
    v30 *= 2;
    v50 = (char *)malloc_type_realloc(v22, v30, 0x74211840uLL);
    v22 = v50;
    if (!v50)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v44, v45, v46, v47, v48, v66);
      v19 = 0;
      UTF8CStringForCFString = 0;
      v21 = 0;
      goto LABEL_52;
    }
    strm.next_out = (Bytef *)&v50[strm.total_out];
    strm.avail_out = v30 - LODWORD(strm.total_out);
    if (!--v42)
      goto LABEL_49;
  }
  if (v43 != 1)
  {
LABEL_49:
    OSKextLog(0, 131073, "Error uncompressing kext cache file %s - zlib returned %d - %s.", v44, v45, v46, v47, v48, (char)buffer);
    v19 = 0;
    UTF8CStringForCFString = 0;
    v21 = 0;
LABEL_50:
    v18 = 0;
    goto LABEL_5;
  }
  v51 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v52 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v22, strm.total_out, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  v21 = v52;
  if (!v52)
  {
    v59 = "Memory allocation failure.";
    v60 = 17;
LABEL_61:
    OSKextLog(0, v60, v59, v53, v54, v55, v56, v57, v66);
    v19 = 0;
    UTF8CStringForCFString = 0;
    goto LABEL_50;
  }
  if (!a5)
  {
    v22 = (void *)CFRetain(v52);
LABEL_58:
    UTF8CStringForCFString = 0;
    v18 = 0;
    goto LABEL_32;
  }
  if ((a4 - 1) <= 1)
  {
    v58 = CFPropertyListCreateFromXMLData(v51, v52, 0, (CFStringRef *)&v68);
    goto LABEL_57;
  }
  if (a4 != 3)
  {
    v60 = 393217;
    v66 = a4;
    v59 = "Invalid cache format %d specified.";
    goto LABEL_61;
  }
  v58 = IOCFUnserialize((const char *)v22, v51, 0, (CFStringRef *)&v68);
LABEL_57:
  v22 = (void *)v58;
  if (v58)
    goto LABEL_58;
  UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)v68);
  OSKextLog(0, 393217, "Can't read plist from cache file %s - %s.", v61, v62, v63, v64, v65, (char)buffer);
  v19 = 0;
LABEL_52:
  v18 = 0;
LABEL_7:
  OSKextLog(0, 393220, "Finished reading cache file %s.", v12, v13, v14, v15, v16, (char)buffer);
  if (a6 && (_DWORD)v19 && v22)
    *a6 = CFRetain(v22);
  if (CacheFileURL)
    CFRelease(CacheFileURL);
  if (v22)
    CFRelease(v22);
  if (cf)
    CFRelease(cf);
  if (v68)
    CFRelease(v68);
  if (v21)
    CFRelease(v21);
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  if ((v18 & 1) == 0)
    inflateEnd(&strm);
  return v19;
}

CFTypeRef *__OSKextCreateFromIdentifierCacheDict(const __CFAllocator *a1, CFDictionaryRef theDict, uint64_t a3, char a4)
{
  const __CFString *Value;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  CFTypeID v15;
  const __CFBoolean *v16;
  const __CFBoolean *v17;
  CFTypeID v18;
  const __CFString *v19;
  const char *v20;
  int v21;
  CFTypeRef *v22;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  CFTypeRef *v31;
  CFTypeRef *v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  CFTypeID v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const __CFString *v47;
  const __CFString *v48;
  CFTypeID v49;
  uint64_t v50;
  const void *v51;
  const void *v52;
  CFTypeID v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const __CFBoolean *v60;
  const __CFBoolean *v61;
  CFTypeID v62;
  char v63;
  UInt8 buffer[1024];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("OSBundlePath"));
  if (!Value || (v14 = Value, v15 = CFGetTypeID(Value), v15 != CFStringGetTypeID()))
  {
    v63 = a4;
    v20 = "Can't create kext: missing or non-string path in identifier cache entry %d.";
LABEL_10:
    v21 = 262145;
LABEL_11:
    OSKextLog(0, v21, v20, v9, v10, v11, v12, v13, v63);
    return 0;
  }
  if (!CFStringHasSuffix(v14, CFSTR("kext")) && !CFStringHasSuffix(v14, CFSTR("dext")))
  {
    v63 = a4;
    v20 = "Can't create kext: path in identifier cache entry %d doesn't name a kext.";
    goto LABEL_10;
  }
  v16 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("OSBundleUsesAbsolutePath"));
  if (v16)
  {
    v17 = v16;
    v18 = CFGetTypeID(v16);
    if (v18 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v17))
      {
        v19 = 0;
        goto LABEL_14;
      }
    }
  }
  v14 = CFStringCreateWithFormat(a1, 0, CFSTR("%@/%@"), a3, v14);
  v19 = v14;
  if (!v14)
  {
    v20 = "Memory allocation failure.";
    v21 = 17;
    goto LABEL_11;
  }
LABEL_14:
  v24 = CFURLCreateWithFileSystemPath(a1, v14, kCFURLPOSIXPathStyle, 1u);
  v30 = v24;
  if (v24)
  {
    __OSKextGetFileSystemPath(0, (CFURLRef)v24, 1u, buffer, v26, v27, v28, v29);
    v22 = (CFTypeRef *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByURL, v30);
    v31 = 0;
    v32 = v22;
    if (v22)
    {
LABEL_18:
      v33 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0C9AE78]);
      if (v33 && (v39 = v33, v40 = CFGetTypeID(v33), v40 == CFStringGetTypeID()))
      {
        if (v22)
        {
          if (!CFEqual(v39, v22[3]))
          {
            OSKextLog((uint64_t)v22, 262145, "Can't create kext from cache: %s is already open and has a different CFBundleIdentifier from identifier->path cache entry %d.", v41, v42, v43, v44, v45, (char)buffer);
LABEL_27:
            CFRetain(v22);
LABEL_28:
            if (v31)
              CFRelease(v31);
            goto LABEL_30;
          }
        }
        else
        {
          v31[3] = CFRetain(v39);
        }
        v47 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0C9AE90]);
        if (v47 && (v48 = v47, v49 = CFGetTypeID(v47), v49 == CFStringGetTypeID()))
        {
          v50 = OSKextParseVersionCFString(v48);
          if (v50 < 0)
          {
            v46 = "Can't create kext: invalid CFBundleVersion in identifier cache entry entry %d.";
          }
          else
          {
            if (v22)
            {
              if ((CFTypeRef)v50 != v22[5])
              {
                OSKextLog((uint64_t)v22, 262145, "Can't create kext from cache: %s is already open and has a different CFBundleVersion from identifier->path cache entry %d.", v34, v35, v36, v37, v38, (char)buffer);
                goto LABEL_27;
              }
            }
            else
            {
              v31[5] = (CFTypeRef)v50;
            }
            v51 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0C9AAE0]);
            if (v51 && (v52 = v51, v53 = CFGetTypeID(v51), v53 == CFStringGetTypeID()))
            {
              v54 = CFEqual(v52, CFSTR("DEXT"));
              if (v22)
              {
                if (((*((_DWORD *)v22 + 23) >> 3) & 1) != v54)
                  OSKextLog((uint64_t)v22, 262145, "Can't create kext from cache: %s is already open and has a different CFBundlePackageType from identifier->path cache entry %d.", v55, v56, v57, v58, v59, (char)buffer);
                if (!v31)
                  goto LABEL_57;
              }
              else
              {
                *((_DWORD *)v31 + 23) = *((_DWORD *)v31 + 23) & 0xFFFFFFF7 | (8 * (v54 != 0));
              }
              v60 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("OSBundleEnableKextLogging"));
              if (!v60)
              {
LABEL_57:
                v22 = v32;
                goto LABEL_27;
              }
              v61 = v60;
              v62 = CFGetTypeID(v60);
              if (v62 == CFBooleanGetTypeID())
              {
                *((_DWORD *)v31 + 23) = *((_DWORD *)v31 + 23) & 0xFFFFFFDF | (32 * (CFBooleanGetValue(v61) != 0));
                *((_DWORD *)v31 + 23) = *((_DWORD *)v31 + 23) & 0xFFFFFFEF | (16 * (CFBooleanGetValue(v61) != 0));
                goto LABEL_57;
              }
              v46 = "Can't create kext from cache: non-BOOLean OSKextEnableKextLogging in identifier cache entry %d.";
            }
            else
            {
              v46 = "Can't create kext: missing or non-string bundle package type in identifier cache entry %d.";
            }
          }
        }
        else
        {
          v46 = "Can't create kext: missing or non-string version in identifier cache entry %d.";
        }
      }
      else
      {
        v46 = "Can't create kext: missing or non-string CFBundleIdentifier in identifier cache entry %d.";
      }
      OSKextLog((uint64_t)v22, 262145, v46, v34, v35, v36, v37, v38, a4);
      if (!v22)
        goto LABEL_28;
      goto LABEL_27;
    }
    v24 = __OSKextAlloc();
    if (v24)
    {
      v32 = (CFTypeRef *)v24;
      *((_BYTE *)v24 + 88) |= 4u;
      *((_QWORD *)v24 + 2) = CFRetain(v30);
      v31 = v32;
      goto LABEL_18;
    }
  }
  OSKextLog((uint64_t)v24, 17, "Memory allocation failure.", v25, v26, v27, v28, v29, v63);
  v22 = 0;
LABEL_30:
  if (v19)
    CFRelease(v19);
  if (v30)
    CFRelease(v30);
  return v22;
}

uint64_t __OSKextRecordKext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  void *UTF8CStringForCFString;
  const __CFURL *v11;
  uint64_t v12;
  const __CFURL *v13;
  uint64_t v14;
  const __CFArray *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v28;
  UInt8 buffer[1024];
  _BYTE v30[20];
  uint64_t v31;
  CFRange v32;

  v31 = *MEMORY[0x1E0C80C00];
  v9 = *(const __CFString **)(a1 + 24);
  if (v9)
    UTF8CStringForCFString = createUTF8CStringForCFString(v9);
  else
    UTF8CStringForCFString = 0;
  v11 = *(const __CFURL **)(a1 + 16);
  if (v11)
  {
    v13 = CFURLCopyAbsoluteURL(v11);
    if (!v13)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v12, a5, a6, a7, a8, v28);
      v14 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    v13 = 0;
  }
  __OSKextGetFileSystemPath(0, v13, 1u, buffer, a5, a6, a7, a8);
  v15 = (const __CFArray *)__sOSAllKexts;
  v32.length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  v32.location = 0;
  if (CFArrayGetFirstIndexOfValue(v15, v32, (const void *)a1) == -1)
    CFArrayAppendValue((CFMutableArrayRef)__sOSAllKexts, (const void *)a1);
  if (v13 && (*(_BYTE *)(a1 + 88) & 8) == 0)
    CFDictionarySetValue((CFMutableDictionaryRef)__sOSKextsByURL, v13, (const void *)a1);
  v14 = __OSKextRecordKextInIdentifierDict((CFMutableArrayRef)a1, (CFDictionaryRef)__sOSKextsByIdentifier, v16, v17, v18, v19, v20, v21);
  if ((_DWORD)v14)
  {
    OSKextVersionGetString(*(_QWORD *)(a1 + 40), v30, 0x14u);
    OSKextLog(a1, 262149, "Recorded %s%s, id %s, version %s.", v22, v23, v24, v25, v26, (char)buffer);
  }
  if (v13)
    CFRelease(v13);
LABEL_17:
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  return v14;
}

uint64_t OSKextGetIdentifier(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t OSKextGetVersion(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

void __OSKextRealize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  __CFString *v22;
  char v23;
  UInt8 buffer[1024];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 88) & 4) == 0)
  {
    *(_BYTE *)(a1 + 88) &= ~4u;
    return;
  }
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 262150, "Realizing %s from identifier cache object.", v9, v10, v11, v12, v13, (char)buffer);
  __OSKextRemoveKextFromIdentifierDict(a1, (const __CFDictionary *)__sOSKextsByIdentifier, v14, v15, v16, v17, v18, v19, v23);
  v20 = *(const void **)(a1 + 24);
  v21 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = -1;
  *(_QWORD *)(a1 + 24) = CFSTR("__unknown__");
  __OSKextProcessInfoDictionary(a1, 0);
  if (v21 == *(_QWORD *)(a1 + 40) && (v22 = *(__CFString **)(a1 + 24), CFEqual(v20, v22)))
  {
    *(_BYTE *)(a1 + 88) &= ~4u;
    if (v22 != CFSTR("__unknown__"))
    {
      if (!v20)
        return;
      goto LABEL_7;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 88) &= ~4u;
  }
  __OSKextRemoveIdentifierCacheForKext(a1);
  if (!v20)
    return;
LABEL_7:
  CFRelease(v20);
}

void __OSKextRemoveKextFromIdentifierDict(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const void *v9;
  void *UTF8CStringForCFString;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  const __CFArray *Value;
  const __CFArray *v20;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE v36[20];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v9 = *(const void **)(a1 + 24);
  if (v9)
  {
    UTF8CStringForCFString = createUTF8CStringForCFString(*(const __CFString **)(a1 + 24));
    if (!UTF8CStringForCFString)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v13, v14, v15, v16, v17, a9);
      return;
    }
    v18 = UTF8CStringForCFString;
    Value = (const __CFArray *)CFDictionaryGetValue(a2, v9);
    if (Value)
    {
      v20 = Value;
      if (Value == (const __CFArray *)a1)
      {
        CFDictionaryRemoveValue(a2, v9);
LABEL_17:
        OSKextVersionGetString(*(_QWORD *)(a1 + 40), v36, 0x14u);
        OSKextLog(a1, 262149, "%s, version %s removed from identifier lookup dictionary.", v26, v27, v28, v29, v30, (char)v18);
LABEL_19:
        free(v18);
        return;
      }
      TypeID = CFArrayGetTypeID();
      if (TypeID == CFGetTypeID(v20))
      {
        Count = CFArrayGetCount(v20);
        if (Count < 1)
        {
LABEL_10:
          v25 = 0;
        }
        else
        {
          v23 = Count;
          v24 = 0;
          while (CFArrayGetValueAtIndex(v20, v24) != (const void *)a1)
          {
            if (v23 == ++v24)
              goto LABEL_10;
          }
          CFArrayRemoveValueAtIndex(v20, v24);
          v25 = a1;
        }
        if (!CFArrayGetCount(v20))
        {
          CFDictionaryRemoveValue(a2, v9);
          CFRelease(v20);
        }
        if (v25)
          goto LABEL_17;
      }
    }
    strncmp((const char *)v18, "__unknown__", 0xBuLL);
    OSKextLog(a1, 262151, "%s not found in identifier lookup dictionary%s.", v31, v32, v33, v34, v35, (char)v18);
    goto LABEL_19;
  }
}

uint64_t __OSKextProcessInfoDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  const __CFDictionary *v17;
  const __CFString *TypeID;
  int v19;
  BOOL v20;
  int v21;
  const __CFString *v22;
  const __CFDictionary *v23;
  const __CFString *v24;
  int v25;
  int v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFDictionary *v29;
  const __CFString *v30;
  int v31;
  BOOL v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const __CFDictionary *v38;
  const __CFString *v39;
  int v40;
  BOOL v41;
  int v42;
  uint64_t v43;
  const __CFDictionary *v44;
  const __CFString *v45;
  int v46;
  BOOL v47;
  char v48;
  _BOOL4 v49;
  const __CFDictionary *v50;
  const __CFString *v51;
  char v52;
  int v53;
  const __CFString *v54;
  const __CFDictionary *v55;
  const __CFString *v56;
  char v57;
  int v58;
  const __CFDictionary *v59;
  const __CFString *v60;
  int v61;
  const __CFDictionary *v62;
  const __CFString *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const __CFDictionary *v67;
  const __CFString *v68;
  char v69;
  const __CFString *v70;
  CFIndex Count;
  CFIndex v72;
  CFIndex v73;
  const __CFAllocator *v74;
  const __CFString *ValueAtIndex;
  CFStringRef v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  CFStringRef v82;
  const __CFDictionary *v83;
  const __CFString *v84;
  int v85;
  BOOL v86;
  const __CFAllocator *v87;
  __CFArray *Mutable;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  const __CFArray *v94;
  CFIndex v95;
  uint64_t v96;
  char v98;
  char v99;
  char v100;
  char v101;
  _QWORD context[3];
  uint64_t v103;
  CFTypeRef cf1;
  CFDictionaryRef theDict;
  CFTypeRef cf;
  CFBooleanRef BOOLean;
  char v108;

  v108 = 0;
  cf = 0;
  BOOLean = 0;
  cf1 = 0;
  theDict = 0;
  __OSKextRemoveKextFromIdentifierDict(a1, (const __CFDictionary *)__sOSKextsByIdentifier, a3, a4, a5, a6, a7, a8, v98);
  if (!__OSKextReadInfoDictionary(a1, a2))
  {
LABEL_126:
    v94 = 0;
    goto LABEL_127;
  }
  v16 = (const __CFString *)*MEMORY[0x1E0C9AAE0];
  v17 = *(const __CFDictionary **)(a1 + 56);
  TypeID = (const __CFString *)CFStringGetTypeID();
  v19 = __OSKextCheckProperty(a1, v17, v16, v16, TypeID, (const __CFArray *)__sOSKextPackageTypeValues, 1, 1, 1, (const __CFString **)&cf1, &v108);
  if (v19)
    v20 = v108 == 0;
  else
    v20 = 1;
  if (v20)
  {
    v21 = v19;
    goto LABEL_122;
  }
  v22 = (const __CFString *)*MEMORY[0x1E0C9AE78];
  v23 = *(const __CFDictionary **)(a1 + 56);
  v24 = (const __CFString *)CFStringGetTypeID();
  v25 = __OSKextCheckProperty(a1, v23, v22, v22, v24, 0, 1, 1, 1, (const __CFString **)&cf, 0);
  v26 = v25;
  if (v25)
  {
    v27 = (const __CFString *)cf;
    if (cf)
    {
      if (*(_QWORD *)(a1 + 24))
      {
        CFRelease(*(CFTypeRef *)(a1 + 24));
        v27 = (const __CFString *)cf;
        *(_QWORD *)(a1 + 24) = 0;
        if (!v27)
        {
LABEL_16:
          if (CFStringGetLength(v27) < 64)
          {
            v26 = 1;
          }
          else
          {
            __OSKextSetDiagnostic(a1, 1, CFSTR("CFBundleIdentifier and CFBundleVersion must be < 64 characters."));
            v26 = 0;
          }
          goto LABEL_19;
        }
      }
      else
      {
        *(_QWORD *)(a1 + 24) = 0;
      }
      *(_QWORD *)(a1 + 24) = CFRetain(v27);
      v27 = (const __CFString *)cf;
      goto LABEL_16;
    }
  }
  *(_QWORD *)(a1 + 24) = CFSTR("__unknown__");
LABEL_19:
  v28 = (const __CFString *)*MEMORY[0x1E0C9AE90];
  v29 = *(const __CFDictionary **)(a1 + 56);
  v30 = (const __CFString *)CFStringGetTypeID();
  v31 = __OSKextCheckProperty(a1, v29, v28, v28, v30, 0, 1, 1, 0, (const __CFString **)&cf, 0);
  if (v26)
    v32 = v31 == 0;
  else
    v32 = 1;
  v33 = !v32;
  v34 = -1;
  if (v31 && cf)
  {
    if (CFStringGetLength((CFStringRef)cf) < 64)
    {
      v34 = OSKextParseVersionCFString((const __CFString *)cf);
      if (v34 == -1)
      {
        __OSKextAddDiagnostic(a1, 1, CFSTR("Info dictionary property value is illegal"), v28, 0, v35, v36, v37, v99);
        v33 = 0;
      }
      *(_QWORD *)(a1 + 40) = v34;
    }
    else
    {
      __OSKextSetDiagnostic(a1, 1, CFSTR("CFBundleIdentifier and CFBundleVersion must be < 64 characters."));
      v33 = 0;
    }
  }
  v38 = *(const __CFDictionary **)(a1 + 56);
  v39 = (const __CFString *)CFStringGetTypeID();
  v40 = __OSKextCheckProperty(a1, v38, CFSTR("OSBundleCompatibleVersion"), CFSTR("OSBundleCompatibleVersion"), v39, 0, 0, 1, 0, (const __CFString **)&cf, 0);
  if (v33)
    v41 = v40 == 0;
  else
    v41 = 1;
  v42 = !v41;
  if (v40 && cf)
  {
    v43 = OSKextParseVersionCFString((const __CFString *)cf);
    if (v43 == -1)
      v42 = 0;
    *(_QWORD *)(a1 + 48) = v43;
    if (v43 > v34)
    {
      __OSKextSetDiagnostic(a1, 1, CFSTR("Compatible version must be lower than current version."));
      v42 = 0;
    }
  }
  v44 = *(const __CFDictionary **)(a1 + 56);
  v45 = (const __CFString *)CFBooleanGetTypeID();
  v46 = __OSKextCheckProperty(a1, v44, CFSTR("OSBundleIsInterface"), CFSTR("OSBundleIsInterface"), v45, 0, 0, 1, 0, (const __CFString **)&BOOLean, &v108);
  if (v42)
    v47 = v46 == 0;
  else
    v47 = 1;
  v48 = !v47;
  if (v108)
    *(_DWORD *)(a1 + 92) |= 2u;
  if (BOOLean)
    v49 = CFBooleanGetValue(BOOLean) == 0;
  else
    v49 = 0;
  v50 = *(const __CFDictionary **)(a1 + 56);
  v51 = (const __CFString *)CFBooleanGetTypeID();
  if (__OSKextCheckProperty(a1, v50, CFSTR("OSKernelResource"), CFSTR("OSKernelResource"), v51, 0, 0, 1, 0, 0, &v108))v52 = v48;
  else
    v52 = 0;
  v53 = *(_DWORD *)(a1 + 92);
  if (v108)
  {
    v53 |= 1u;
    *(_DWORD *)(a1 + 92) = v53;
  }
  if ((v53 & 1) != 0)
  {
    if (v49)
    {
      __OSKextSetDiagnostic(a1, 8, CFSTR("Kext is a kernel component but OSBundleIsInterface is set to false; overriding"));
      v53 = *(_DWORD *)(a1 + 92);
    }
    *(_DWORD *)(a1 + 92) = v53 | 2;
  }
  v54 = (const __CFString *)*MEMORY[0x1E0C9AE70];
  v55 = *(const __CFDictionary **)(a1 + 56);
  v56 = (const __CFString *)CFStringGetTypeID();
  if (__OSKextCheckProperty(a1, v55, v54, v54, v56, 0, 0, 1, 1, 0, &v108))
    v57 = v52;
  else
    v57 = 0;
  if (v108)
  {
    if (CFEqual(cf1, CFSTR("KEXT")))
    {
      v58 = 4;
LABEL_72:
      *(_DWORD *)(a1 + 92) |= v58;
      goto LABEL_73;
    }
    if (CFEqual(cf1, CFSTR("DEXT")))
    {
      v58 = 8;
      goto LABEL_72;
    }
    v57 = 0;
  }
LABEL_73:
  v59 = *(const __CFDictionary **)(a1 + 56);
  v60 = (const __CFString *)CFStringGetTypeID();
  if (!__OSKextCheckProperty(a1, v59, CFSTR("OSBundleSharedExecutableIdentifier"), CFSTR("OSBundleSharedExecutableIdentifier"), v60, 0, 0, 1, 0, 0, &v108))v57 = 0;
  if (v108)
  {
    v61 = *(_DWORD *)(a1 + 92);
    if ((v61 & 4) != 0)
    {
      __OSKextSetDiagnostic(a1, 1, CFSTR("Kext declares both CFBundleExecutable and CFBundleSharedExecutableIdentifier; use only one."));
    }
    else if ((v61 & 8) != 0)
    {
      __OSKextSetDiagnostic(a1, 1, CFSTR("CFBundlePackageType is DEXT and bundle declares CFBundleExecutable; use only one."));
      v57 = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = v61 | 4;
    }
  }
  v62 = *(const __CFDictionary **)(a1 + 56);
  v63 = (const __CFString *)CFBooleanGetTypeID();
  if (!__OSKextCheckProperty(a1, v62, CFSTR("OSBundleEnableKextLogging"), CFSTR("OSBundleEnableKextLogging"), v63, 0, 0, 1, 0, (const __CFString **)&BOOLean, &v108))v57 = 0;
  if (v108)
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFEF | (16 * (CFBooleanGetValue(BOOLean) != 0));
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFDF | (32 * (CFBooleanGetValue(BOOLean) != 0));
  }
  if (OSKextGetValueForInfoDictionaryKey(a1, CFSTR("OSBundleDebugLevel")))
    __OSKextAddDiagnostic(a1, 8, CFSTR("Deprecated property (ignored)"), CFSTR("OSBundleDebugLevel"), 0, v64, v65, v66, v100);
  v67 = *(const __CFDictionary **)(a1 + 56);
  v68 = (const __CFString *)CFStringGetTypeID();
  if (__OSKextCheckProperty(a1, v67, CFSTR("OSBundleRequired"), CFSTR("OSBundleRequired"), v68, (const __CFArray *)__sOSKextOSBundleRequiredValues, 0, 1, 0, (const __CFString **)&cf, &v108))v69 = v57;
  else
    v69 = 0;
  if (v108)
  {
    if ((*(_BYTE *)(a1 + 92) & 8) != 0)
    {
      if (CFStringHasPrefix(*(CFStringRef *)(a1 + 24), CFSTR("com.apple.")))
      {
        if (CFEqual(cf, CFSTR("DriverKit")) || CFEqual(cf, CFSTR("Safe Boot")))
          goto LABEL_102;
        v70 = CFSTR("Driver Extension lacks appropriate value for OSBundleRequired, and will not be launched without kextd present. Use one of 'DriverKit' or 'Safe Boot.'");
      }
      else
      {
        v70 = CFSTR("Third-party Driver Extensions are ineligible to run in Safe Boot, or match on devices during early boot. Please remove the OSBundleRequired key from your Info.plist.");
      }
    }
    else
    {
      if (!CFEqual(cf, CFSTR("DriverKit")))
      {
LABEL_102:
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFF7F | ((v69 & 1) << 7);
        goto LABEL_103;
      }
      v70 = CFSTR("Kexts may not use the DriverKit value for OSBundleRequired.");
    }
    __OSKextSetDiagnostic(a1, 16, v70);
    v69 = 0;
    goto LABEL_102;
  }
  if (OSKextGetActualSafeBoot() | __sOSKextSimulatedSafeBoot)
    __OSKextSetDiagnostic(a1, 16, CFSTR("Kext isn't loadable during safe boot."));
LABEL_103:
  if ((*(_BYTE *)(a1 + 92) & 8) != 0)
  {
    Count = CFArrayGetCount((CFArrayRef)__sOSKextInfoKextOnlyKeys);
    if (Count >= 1)
    {
      v72 = Count;
      v73 = 0;
      v74 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)__sOSKextInfoKextOnlyKeys, v73);
        if (OSKextGetValueForInfoDictionaryKey(a1, ValueAtIndex))
        {
          v76 = CFStringCreateWithFormat(v74, 0, CFSTR("Driver Extensions may not use the %@ key; please remove."));
          if (!v76)
          {
            OSKextLog(a1, 17, "String/URL conversion failure.", v77, v78, v79, v80, v81, (char)ValueAtIndex);
            goto LABEL_126;
          }
          v82 = v76;
          __OSKextSetDiagnostic(a1, 1, v76);
          CFRelease(v82);
          v69 = 0;
        }
        ++v73;
      }
      while (v72 != v73);
    }
  }
  v83 = *(const __CFDictionary **)(a1 + 56);
  v84 = (const __CFString *)CFDictionaryGetTypeID();
  v85 = __OSKextCheckProperty(a1, v83, CFSTR("IOKitPersonalities"), CFSTR("IOKitPersonalities"), v84, 0, 0, 1, 0, (const __CFString **)&theDict, &v108);
  if (v69)
    v86 = v85 == 0;
  else
    v86 = 1;
  v21 = !v86;
  if (!theDict)
  {
LABEL_122:
    v94 = 0;
    if (v21)
      goto LABEL_123;
    goto LABEL_127;
  }
  v103 = 0;
  v87 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFArrayCreateMutable(v87, 0, MEMORY[0x1E0C9B378]);
  v94 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, CFSTR("IOKitPersonalities"));
    context[0] = a1;
    context[1] = theDict;
    context[2] = v94;
    LOWORD(v103) = 257;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateIOKitPersonalityApplierFunction, context);
    if (!(_BYTE)v103)
      v21 = 0;
    v95 = CFArrayGetCount(v94);
    CFArrayRemoveValueAtIndex(v94, v95 - 1);
    if (!v21)
      goto LABEL_127;
LABEL_123:
    v96 = 1;
    goto LABEL_128;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v89, v90, v91, v92, v93, v101);
LABEL_127:
  v96 = 0;
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
LABEL_128:
  __OSKextRecordKextInIdentifierDict((CFMutableArrayRef)a1, (CFDictionaryRef)__sOSKextsByIdentifier, v10, v11, v12, v13, v14, v15);
  if (v94)
    CFRelease(v94);
  return v96;
}

void __OSKextRemoveIdentifierCacheForKext(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFURL *ValueAtIndex;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  UInt8 buffer[1024];
  char __s1[1024];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!geteuid())
  {
    if (__OSKextGetFileSystemPath(a1, 0, 1u, (UInt8 *)__s1, v2, v3, v4, v5))
    {
      Count = CFArrayGetCount((CFArrayRef)__sOSKextSystemExtensionsFolderURLs);
      if (Count >= 1)
      {
        v7 = Count;
        v8 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex((CFArrayRef)__sOSKextSystemExtensionsFolderURLs, v8);
          CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, buffer, 1024);
          if (!strncmp(__s1, (const char *)buffer, 0x400uLL))
            break;
          if (v7 == ++v8)
            return;
        }
        OSKextLog(0, 393220, "Removing identifier->path cache %s.", v10, v11, v12, v13, v14, (char)__s1);
        __s1[0] = 0;
        __strlcpy_chk();
        __strlcat_chk();
        __strlcat_chk();
        if (unlink(__s1) && *__error() != 2 && *__error() != 20)
        {
          v15 = __error();
          strerror(*v15);
          OSKextLog(0, 131073, "Failed to remove identifier->path cache %s - %s.", v16, v17, v18, v19, v20, (char)__s1);
        }
      }
    }
  }
}

void __OSKextRealizeKextsWithIdentifier(void *key)
{
  const __CFArray *Value;
  const __CFArray *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeID TypeID;
  CFRange v12;

  if (__sOSKextsByIdentifier)
  {
    Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, key);
    if (Value)
    {
      v2 = Value;
      CFRetain(Value);
      v3 = __kOSKextTypeID;
      if (v3 == CFGetTypeID(v2))
      {
        __OSKextRealize((uint64_t)v2, v4, v5, v6, v7, v8, v9, v10);
      }
      else
      {
        TypeID = CFArrayGetTypeID();
        if (TypeID == CFGetTypeID(v2))
        {
          if (CFArrayGetCount(v2))
          {
            v12.length = CFArrayGetCount(v2);
            v12.location = 0;
            CFArrayApplyFunction(v2, v12, (CFArrayApplierFunction)__OSKextRealize, 0);
          }
        }
      }
      CFRelease(v2);
    }
  }
}

CFURLRef __OSKextCreateCacheFileURL(const void *a1, uint64_t a2, const char **a3, int a4)
{
  CFTypeID v8;
  CFTypeID v9;
  const __CFURL *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *v22;
  CFURLRef v23;
  const char *v24;
  const char *v25;
  const __CFAllocator *v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFString *v34;
  char v36;
  char v37;

  v8 = CFGetTypeID(a1);
  v9 = CFURLGetTypeID();
  if (v8 == v9)
  {
    v10 = _CFURLCopyAbsolutePath((const __CFURL *)a1);
    if (!v10)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v11, v12, v13, v14, v15, v36);
      return 0;
    }
    v16 = (const __CFString *)v10;
    if (!__OSKextURLIsSystemFolder((const __CFURL *)a1))
    {
      OSKextLogCFString(0, 262148, CFSTR("%@ is not a system extensions folder; not looking for a cache."),
        v17,
        v18,
        v19,
        v20,
        v21,
        (char)v16);
      v34 = 0;
      v23 = 0;
      goto LABEL_24;
    }
    v22 = v16;
  }
  else
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v16 = 0;
    if ((const void *)__sOSKextSystemExtensionsFolderURLs != a1)
      return 0;
    v22 = &stru_1E2005170;
  }
  v24 = "";
  v25 = "";
  if ((a4 - 1) <= 2)
    v25 = off_1E2003310[a4 - 1];
  v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v27 = "Startup";
  if (v8 == v9)
    v27 = "Directories";
  v28 = "_";
  if (a3)
    v24 = *a3;
  else
    v28 = "";
  v34 = CFStringCreateWithFormat(v26, 0, CFSTR("%s/%s%@/%@%s%s%s"), "/System/Library/Caches/com.apple.kext.caches", v27, v22, a2, v28, v24, v25);
  if (!v34 || (v23 = CFURLCreateWithFileSystemPath(v26, v34, kCFURLPOSIXPathStyle, 0)) == 0)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v29, v30, v31, v32, v33, v37);
    v23 = 0;
  }
  if (v16)
  {
LABEL_24:
    CFRelease(v16);
    if (!v34)
      return v23;
    goto LABEL_21;
  }
  if (v34)
LABEL_21:
    CFRelease(v34);
  return v23;
}

const __CFURL *_CFURLCopyAbsolutePath(const __CFURL *a1)
{
  const __CFURL *result;
  const __CFURL *v2;
  CFStringRef v3;

  result = CFURLCopyAbsoluteURL(a1);
  if (result)
  {
    v2 = result;
    v3 = CFURLCopyFileSystemPath(result, kCFURLPOSIXPathStyle);
    CFRelease(v2);
    return (const __CFURL *)v3;
  }
  return result;
}

BOOL __OSKextURLIsSystemFolder(const __CFURL *a1)
{
  CFURLRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFURLRef v7;
  const __CFArray *v8;
  _BOOL8 v9;
  char v11;
  CFRange v12;

  v1 = CFURLCopyAbsoluteURL(a1);
  if (v1)
  {
    v7 = v1;
    v8 = (const __CFArray *)__sOSKextSystemExtensionsFolderURLs;
    v12.length = CFArrayGetCount((CFArrayRef)__sOSKextSystemExtensionsFolderURLs);
    v12.location = 0;
    v9 = CFArrayGetFirstIndexOfValue(v8, v12, v7) != -1;
    CFRelease(v7);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v2, v3, v4, v5, v6, v11);
    return 0;
  }
  return v9;
}

void OSKextLogCFString(uint64_t a1, int a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  OSKextVLogCFString(a1, a2, a3, &a9);
}

uint64_t __OSKextCheckURL(const __CFURL *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  UInt8 *i;
  const char *p_buffer;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  stat v41;
  statfs v42;
  UInt8 buffer;
  _BYTE v44[1031];

  *(_QWORD *)&v44[1023] = *MEMORY[0x1E0C80C00];
  bzero(&buffer, 0x400uLL);
  memset(&v41, 0, sizeof(v41));
  result = __OSKextGetFileSystemPath(0, a1, 1u, &buffer, v4, v5, v6, v7);
  if (!(_DWORD)result)
    return result;
  if (buffer != 47)
  {
    OSKextLog(0, 17, "Internal error, invalid argument to __OSKextCheckURL.", v9, v10, v11, v12, v13, v40);
    return 0;
  }
  if (a2)
  {
    memset(&v42, 0, 512);
    if (!statfs((const char *)&buffer, &v42) && (v42.f_flags & 1) != 0)
    {
      OSKextLogCFString(0, 131076, CFSTR("Not saving %s - read-only filesystem."), v14, v15, v16, v17, v18, (char)&buffer);
      return 0;
    }
  }
  for (i = &buffer; ; i = (UInt8 *)index(v27, 47))
  {
    if (i == &buffer)
    {
      p_buffer = "/";
    }
    else
    {
      if (i)
        *i = 0;
      p_buffer = (const char *)&buffer;
    }
    if (stat(p_buffer, &v41))
    {
      if (*__error() != 2)
      {
        v28 = __error();
        strerror(*v28);
        OSKextLog(0, 131073, "Can't stat path %s - %s.", v29, v30, v31, v32, v33, (char)p_buffer);
        goto LABEL_34;
      }
      if (!a2)
        goto LABEL_34;
      if (mkdir((const char *)&buffer, 0x1EDu) && *__error() != 17)
        break;
    }
    if (v41.st_uid)
    {
      OSKextLog(0, 131073, "Can't create kext cache under %s - owner not root.", v21, v22, v23, v24, v25, (char)p_buffer);
      goto LABEL_34;
    }
    if ((v41.st_mode & 0xF000) != 0x4000 && v41.st_gid != 0)
    {
      OSKextLog(0, 131073, "Can't create kext cache under %s - group not wheel.", v21, v22, v23, v24, v25, (char)p_buffer);
      goto LABEL_34;
    }
    if (!i)
      return 1;
    v27 = v44;
    if (i != &buffer)
    {
      *i = 47;
      v27 = (const char *)(i + 1);
    }
  }
  v34 = __error();
  strerror(*v34);
  OSKextLog(0, 131073, "Failed to create directory %s - %s.", v35, v36, v37, v38, v39, (char)p_buffer);
LABEL_34:
  result = 0;
  if (i)
  {
    if (i != &buffer)
    {
      result = 0;
      *i = 47;
    }
  }
  return result;
}

uint64_t _OSKextCreateFolderForCacheURL(CFURLRef url)
{
  const __CFURL *PathComponent;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFURL *v7;
  uint64_t v8;
  char v10;

  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], url);
  if (PathComponent)
  {
    v7 = PathComponent;
    v8 = __OSKextCheckURL(PathComponent, 1);
    CFRelease(v7);
    return v8;
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v2, v3, v4, v5, v6, v10);
    return 0;
  }
}

uint64_t __OSKextStatURL(CFURLRef url, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int *v11;
  __int128 v12;
  timespec st_mtimespec;
  timespec st_birthtimespec;
  __int128 v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  stat v22;
  UInt8 buffer[1024];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a2)
    *a2 = 0;
  memset(&v22, 0, sizeof(v22));
  result = __OSKextGetFileSystemPath(0, url, 1u, buffer, a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
LABEL_13:
    if (!a3)
      return result;
    goto LABEL_14;
  }
  if (!stat((const char *)buffer, &v22))
  {
    result = 1;
    if (!a3)
      return result;
    goto LABEL_14;
  }
  if (*__error() == 2)
  {
    if (!a2)
      goto LABEL_16;
    goto LABEL_12;
  }
  v11 = __error();
  if (a2 && *v11 == 20)
  {
LABEL_12:
    result = 0;
    *a2 = 1;
    goto LABEL_13;
  }
LABEL_16:
  v16 = __error();
  strerror(*v16);
  OSKextLogCFString(0, 131073, CFSTR("Can't stat %s - %s."), v17, v18, v19, v20, v21, (char)buffer);
  result = 0;
  if (!a3)
    return result;
LABEL_14:
  v12 = *(_OWORD *)&v22.st_blksize;
  *(_OWORD *)(a3 + 96) = *(_OWORD *)&v22.st_size;
  *(_OWORD *)(a3 + 112) = v12;
  *(_OWORD *)(a3 + 128) = *(_OWORD *)v22.st_qspare;
  st_mtimespec = v22.st_mtimespec;
  *(timespec *)(a3 + 32) = v22.st_atimespec;
  *(timespec *)(a3 + 48) = st_mtimespec;
  st_birthtimespec = v22.st_birthtimespec;
  *(timespec *)(a3 + 64) = v22.st_ctimespec;
  *(timespec *)(a3 + 80) = st_birthtimespec;
  v15 = *(_OWORD *)&v22.st_uid;
  *(_OWORD *)a3 = *(_OWORD *)&v22.st_dev;
  *(_OWORD *)(a3 + 16) = v15;
  return result;
}

__n128 __OSKextStatURLsOrURL(const void *a1, _BYTE *a2, uint64_t a3)
{
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 result;
  CFTypeID v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  char *v17;
  const __CFURL *ValueAtIndex;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __n128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __n128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  char v45;

  v45 = 0;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v6 = CFGetTypeID(a1);
  if (v6 == CFURLGetTypeID())
  {
    __OSKextStatURL((CFURLRef)a1, a2, (uint64_t)&v27, v7, v8, v9, v10, v11);
    goto LABEL_19;
  }
  v13 = CFGetTypeID(a1);
  if (v13 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1)
    {
      v15 = 0;
      if (!a2)
        goto LABEL_19;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      if (a2)
        v17 = &v45;
      else
        v17 = 0;
      do
      {
        ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex((CFArrayRef)a1, v16);
        if (__OSKextStatURL(ValueAtIndex, v17, (uint64_t)&v36, v19, v20, v21, v22, v23))
        {
          ++v15;
          if (!v16 || (uint64_t)v39 > (uint64_t)v30)
          {
            v33 = v42;
            v34 = v43;
            v35 = v44;
            v29 = v38;
            v30 = v39;
            v31 = v40;
            v32 = v41;
            result.n128_u64[0] = v37.n128_u64[0];
            v27 = v36;
            v28 = v37;
          }
        }
        ++v16;
      }
      while (Count != v16);
      if (!a2)
        goto LABEL_19;
    }
    if (v15 < Count)
      *a2 = 1;
  }
LABEL_19:
  if (a3)
  {
    v24 = v34;
    *(_OWORD *)(a3 + 96) = v33;
    *(_OWORD *)(a3 + 112) = v24;
    *(_OWORD *)(a3 + 128) = v35;
    v25 = v30;
    *(_OWORD *)(a3 + 32) = v29;
    *(_OWORD *)(a3 + 48) = v25;
    v26 = v32;
    *(_OWORD *)(a3 + 64) = v31;
    *(_OWORD *)(a3 + 80) = v26;
    result = v28;
    *(_OWORD *)a3 = v27;
    *(__n128 *)(a3 + 16) = result;
  }
  return result;
}

uint64_t _OSKextWriteCache(const void *a1, uint64_t a2, const char **a3, int a4, const void *a5)
{
  CFTypeID v10;
  CFURLRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFURLRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFURL *v23;
  uint64_t v24;
  const __CFURL *CacheFileURL;
  __CFWriteStream *v26;
  const __CFData *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  int v39;
  int v40;
  mode_t v41;
  __CFWriteStream *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CFPropertyListFormat v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  gzFile v74;
  gzFile_s *v75;
  uint64_t v76;
  unsigned int v77;
  std::error_code *v78;
  int *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  std::__fs::filesystem::path *p_to;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  std::__fs::filesystem::path *p_from;
  _OWORD v130[3];
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  timeval v137;
  uint64_t v138;
  int v139;
  std::__fs::filesystem::path __to;
  std::__fs::filesystem::path __from;
  uint64_t v142;

  v142 = *MEMORY[0x1E0C80C00];
  bzero(&__from, 0x400uLL);
  bzero(&__to, 0x400uLL);
  v135 = 0u;
  v136 = 0u;
  v133 = 0u;
  v134 = 0u;
  v131 = 0u;
  v132 = 0u;
  memset(v130, 0, sizeof(v130));
  v10 = CFGetTypeID(a1);
  if (v10 == CFURLGetTypeID())
  {
    v11 = CFURLCopyAbsoluteURL((CFURLRef)a1);
    if (!v11)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, (char)p_from);
      return 0;
    }
    v17 = v11;
    v23 = _CFURLCopyAbsolutePath((const __CFURL *)a1);
    if (!v23)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, (char)p_from);
      v24 = 0;
      CacheFileURL = 0;
      v26 = 0;
      v27 = 0;
LABEL_16:
      CFRelease(v17);
      goto LABEL_17;
    }
  }
  else
  {
    v17 = 0;
    v23 = 0;
  }
  CacheFileURL = __OSKextCreateCacheFileURL(a1, a2, a3, a4);
  if (!CacheFileURL)
    goto LABEL_14;
  if (!__OSKextGetFileSystemPath(0, CacheFileURL, 1u, (UInt8 *)&__to, v28, v29, v30, v31))
  {
    v37 = "String/URL conversion failure.";
    goto LABEL_13;
  }
  OSKextLog(0, 393220, "Saving cache file %s.", v32, v33, v34, v35, v36, (char)&__to);
  if (!_OSKextCreateFolderForCacheURL(CacheFileURL))
  {
LABEL_14:
    v27 = 0;
    v26 = 0;
    goto LABEL_15;
  }
  __strlcpy_chk();
  if ((unint64_t)__strlcat_chk() >= 0x401)
  {
    p_from = &__from;
    v37 = "Temp cache file name too long: %s.";
LABEL_13:
    OSKextLog(0, 17, v37, v32, v33, v34, v35, v36, (char)p_from);
    goto LABEL_14;
  }
  v39 = mkstemp((char *)&__from);
  if (v39 == -1)
  {
    v54 = __error();
    strerror(*v54);
    OSKextLog(0, 131073, "Can't create %s - %s.", v55, v56, v57, v58, v59, (char)&__from);
    goto LABEL_14;
  }
  v40 = v39;
  v41 = umask(0);
  umask(v41);
  if (fchmod(v40, ~v41 & 0x1A4) == -1)
  {
    v60 = __error();
    strerror(*v60);
    OSKextLog(0, 131073, "Failed to set permissions for %s - %s.", v61, v62, v63, v64, v65, (char)&__from);
    v26 = 0;
LABEL_54:
    v27 = 0;
    goto LABEL_56;
  }
  if ((a4 - 1) > 1)
  {
    v27 = IOCFSerialize(a5, 0);
    v26 = 0;
    goto LABEL_37;
  }
  v42 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v26 = v42;
  if (!v42)
  {
    OSKextLog(0, 262145, "Can't create CFWriteStream to save cache %s.", v43, v44, v45, v46, v47, (char)&__to);
    goto LABEL_54;
  }
  if (a4 == 1)
    v48 = kCFPropertyListBinaryFormat_v1_0;
  else
    v48 = kCFPropertyListXMLFormat_v1_0;
  CFWriteStreamOpen(v42);
  CFPropertyListWriteToStream(a5, v26, v48, 0);
  CFWriteStreamClose(v26);
  v27 = (const __CFData *)CFWriteStreamCopyProperty(v26, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
LABEL_37:
  if (!v27)
  {
    OSKextLog(0, 262145, "Failed to serialize data for cache %s.", v49, v50, v51, v52, v53, (char)&__to);
LABEL_56:
    close(v40);
LABEL_57:
    p_to = &__from;
    goto LABEL_58;
  }
  BytePtr = CFDataGetBytePtr(v27);
  Length = CFDataGetLength(v27);
  if (!BytePtr)
  {
    OSKextLog(0, 17, "Unable to get data to create cache file %s.", v68, v69, v70, v71, v72, (char)&__to);
    goto LABEL_56;
  }
  v73 = Length;
  *__error() = 0;
  v74 = gzdopen(v40, "w");
  if (!v74)
  {
    v93 = __error();
    strerror(*v93);
    OSKextLog(0, 131073, "Failed to open compression stream for %s - %s.", v94, v95, v96, v97, v98, (char)&__to);
    goto LABEL_56;
  }
  v75 = v74;
  if (v73 >= 1)
  {
    v76 = 0;
    while (1)
    {
      *__error() = 0;
      v77 = gzwrite(v75, &BytePtr[v76], v73 - v76);
      if ((v77 & 0x80000000) != 0)
        break;
      v76 += v77;
      if (v76 >= v73)
        goto LABEL_44;
    }
    v105 = __error();
    strerror(*v105);
    OSKextLog(0, 131073, "Compressed write error for cache file %s - %s.", v106, v107, v108, v109, v110, (char)&__to);
    p_to = &__from;
    if (gzclose(v75))
    {
      v111 = __error();
      strerror(*v111);
      OSKextLog(0, 131073, "Failed to close compression stream for %s - %s.", v112, v113, v114, v115, v116, (char)&__from);
    }
    goto LABEL_58;
  }
LABEL_44:
  *__error() = 0;
  if (gzclose(v75))
  {
    v79 = __error();
    strerror(*v79);
    OSKextLog(0, 131073, "Failed to close compression stream for %s - %s.", v80, v81, v82, v83, v84, (char)&__from);
  }
  rename(&__from, &__to, v78);
  if (v85 == -1)
  {
    v117 = __error();
    strerror(*v117);
    OSKextLog(0, 131073, "Can't rename temp cache file to %s - %s.", v118, v119, v120, v121, v122, (char)&__to);
    goto LABEL_57;
  }
  __OSKextStatURLsOrURL(a1, 0, (uint64_t)v130);
  if (!v86)
  {
    p_to = &__to;
LABEL_58:
    if (unlink((const char *)p_to) == -1)
    {
      v99 = __error();
      strerror(*v99);
      OSKextLog(0, 131073, "Failed to remove temp cache file %s - %s.", v100, v101, v102, v103, v104, (char)p_to);
    }
    goto LABEL_15;
  }
  v137.tv_sec = v131 + 1;
  v137.tv_usec = 0;
  v138 = v131 + 1;
  v139 = 0;
  p_to = &__to;
  if (utimes((const char *)&__to, &v137) != -1)
  {
    OSKextLog(0, 393220, "Saved cache file %s.", v88, v89, v90, v91, v92, (char)&__to);
    v24 = 1;
    if (!v17)
      goto LABEL_17;
    goto LABEL_16;
  }
  v123 = __error();
  strerror(*v123);
  OSKextLog(0, 131073, "Can't update mod time of cache file %s - %s.", v124, v125, v126, v127, v128, (char)&__to);
  if (*__error() != 2)
    goto LABEL_58;
LABEL_15:
  v24 = 0;
  if (v17)
    goto LABEL_16;
LABEL_17:
  if (v23)
    CFRelease(v23);
  if (CacheFileURL)
    CFRelease(CacheFileURL);
  if (v27)
    CFRelease(v27);
  if (v26)
    CFRelease(v26);
  return v24;
}

uint64_t __OSKextCacheNeedsUpdate(const __CFURL *a1, const void *a2)
{
  const __CFURL *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFURL *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  const __CFString *v18;
  int v20;
  char v21;
  _OWORD v22[3];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  char v38;

  v38 = 0;
  v4 = _CFURLCopyAbsolutePath(a1);
  if (v4)
  {
    v10 = v4;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    memset(v22, 0, sizeof(v22));
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    if (__OSKextStatURL(a1, &v38, (uint64_t)&v29, v5, v6, v7, v8, v9))
    {
      if ((SWORD2(v29) & 0x80000000) == 0)
      {
        OSKextLogCFString(0, 393220, CFSTR("Cache file %@ is not a regular file; ignoring."),
          v11,
          v12,
          v13,
          v14,
          v15,
          (char)v10);
LABEL_9:
        v16 = 1;
LABEL_10:
        CFRelease(v10);
        return v16;
      }
      if (!__OSKextCheckURL(a1, 0))
        goto LABEL_9;
      if ((_DWORD)v30)
      {
        v21 = (char)v10;
        v18 = CFSTR("Cache file %@ - owner not root; not using.");
      }
      else if (DWORD1(v30))
      {
        v21 = (char)v10;
        v18 = CFSTR("Cache file %@ - group not wheel; not using.");
      }
      else if ((WORD2(v29) & 0x1FF) == 0x1A4)
      {
        __OSKextStatURLsOrURL(a2, &v38, (uint64_t)v22);
        if (v20)
        {
          if ((_QWORD)v32 == (_QWORD)v23 + 1)
          {
            v16 = 0;
            goto LABEL_10;
          }
          v21 = (char)v10;
          v18 = CFSTR("Cache file %@ is out of date; not using.");
        }
        else
        {
          v21 = (char)v10;
          v18 = CFSTR("Can't stat source folders for cache file %@.");
        }
      }
      else
      {
        v21 = (char)v10;
        v18 = CFSTR("Cache file %@ - wrong permissions (%#o, should be %#o); not using.");
      }
      v17 = 393218;
    }
    else
    {
      if (!v38)
        goto LABEL_9;
      v17 = 393223;
      v21 = (char)v10;
      v18 = CFSTR("Cache file %@ does not exist.");
    }
    OSKextLogCFString(0, v17, v18, v11, v12, v13, v14, v15, v21);
    goto LABEL_9;
  }
  return 1;
}

uint64_t _OSKextWriteIdentifierCacheForKextsInDirectory(const __CFArray *a1, const void *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFURLRef CacheFileURL;
  CFURLRef v14;
  const __CFAllocator *v15;
  CFMutableDictionaryRef Mutable;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFDictionary *v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFStringRef v29;
  CFMutableArrayRef v30;
  __CFArray *v31;
  CFNumberRef v32;
  CFIndex Count;
  CFIndex v34;
  CFIndex v35;
  const __CFURL *IdentifierCacheDict;
  const void *ValueAtIndex;
  char v38;
  int valuePtr;
  char __s[1024];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  bzero(__s, 0x400uLL);
  if (!(__sOSKextUsesCaches | a3))
    return 0;
  if (geteuid())
  {
    OSKextLog(0, 262148, "Not running as root; skipping save of identifier->path cache.", v6, v7, v8, v9, v10, v38);
    return 0;
  }
  CacheFileURL = __OSKextCreateCacheFileURL(a2, (uint64_t)CFSTR("KextIdentifiers"), 0, 2);
  if (!CacheFileURL)
    return 0;
  v14 = CacheFileURL;
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, v38);
    CFRelease(v14);
    return 0;
  }
  v22 = Mutable;
  if (__OSKextGetFileSystemPath(0, (CFURLRef)a2, 1u, (UInt8 *)__s, v18, v19, v20, v21))
  {
    v23 = strlen(__s);
    v29 = CFStringCreateWithBytes(v15, (const UInt8 *)__s, v23, 0x8000100u, 0);
    if (v29)
    {
      CFDictionarySetValue(v22, CFSTR("OSKextIdentifierCacheBasePath"), v29);
      v30 = CFArrayCreateMutable(v15, 0, MEMORY[0x1E0C9B378]);
      if (v30)
      {
        v31 = v30;
        CFDictionarySetValue(v22, CFSTR("OSKextIdentifierCacheKextInfo"), v30);
        valuePtr = 2;
        v32 = CFNumberCreate(v15, kCFNumberSInt32Type, &valuePtr);
        CFDictionarySetValue(v22, CFSTR("OSKextIdentifierCacheVersion"), v32);
        Count = CFArrayGetCount(a1);
        if (Count < 1)
        {
          IdentifierCacheDict = 0;
        }
        else
        {
          v34 = Count;
          v35 = 0;
          IdentifierCacheDict = 0;
          do
          {
            if (IdentifierCacheDict)
              CFRelease(IdentifierCacheDict);
            ValueAtIndex = CFArrayGetValueAtIndex(a1, v35);
            IdentifierCacheDict = __OSKextCreateIdentifierCacheDict((uint64_t)ValueAtIndex, v29);
            if (IdentifierCacheDict)
              CFArrayAppendValue(v31, IdentifierCacheDict);
            ++v35;
          }
          while (v34 != v35);
        }
        v11 = _OSKextWriteCache(a2, (uint64_t)CFSTR("KextIdentifiers"), 0, 2, v22);
        goto LABEL_25;
      }
    }
    OSKextLog(0, 17, "Memory allocation failure.", v24, v25, v26, v27, v28, v38);
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v29 = 0;
  }
  v32 = 0;
  v31 = 0;
  IdentifierCacheDict = 0;
LABEL_25:
  CFRelease(v14);
  CFRelease(v22);
  if (v31)
    CFRelease(v31);
  if (IdentifierCacheDict)
    CFRelease(IdentifierCacheDict);
  if (v32)
    CFRelease(v32);
  if (v29)
    CFRelease(v29);
  return v11;
}

const __CFURL *__OSKextCreateIdentifierCacheDict(uint64_t a1, const __CFString *a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFDictionary *v11;
  const __CFURL *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFURL *v18;
  const __CFString *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  CFIndex Length;
  CFIndex v27;
  const __CFAllocator *v28;
  CFStringRef v29;
  CFStringRef v30;
  const void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  const void *v38;
  const void *ValueForInfoDictionaryKey;
  const void *v40;
  const void *v41;
  char v43;
  char v44[1024];
  char buffer[1024];
  uint64_t v46;
  CFRange v47;

  v46 = *MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v43);
    return 0;
  }
  v11 = Mutable;
  v12 = CFURLCopyAbsoluteURL(*(CFURLRef *)(a1 + 16));
  v18 = v12;
  if (!v12)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v13, v14, v15, v16, v17, v43);
    v31 = v11;
LABEL_20:
    CFRelease(v31);
    return v18;
  }
  v19 = CFURLCopyFileSystemPath(v12, kCFURLPOSIXPathStyle);
  v25 = v19;
  if (!v19)
    goto LABEL_6;
  if (CFStringHasPrefix(v19, a2))
  {
    Length = CFStringGetLength(v25);
    v27 = CFStringGetLength(a2) + 1;
    v28 = CFGetAllocator((CFTypeRef)a1);
    v47.length = Length - v27;
    v47.location = v27;
    v29 = CFStringCreateWithSubstring(v28, v25, v47);
    v30 = v29;
    if (!v29)
    {
LABEL_6:
      OSKextLog(0, 17, "Memory allocation failure.", v20, v21, v22, v23, v24, v43);
      v29 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    CFStringGetCString(v25, buffer, 1024, 0x8000100u);
    CFStringGetCString(a2, v44, 1024, 0x8000100u);
    OSKextLog(a1, 262150, "%s not in base path %s for identifier->path cache - marking.", v32, v33, v34, v35, v36, (char)buffer);
    CFDictionarySetValue(v11, CFSTR("OSBundleUsesAbsolutePath"), (const void *)*MEMORY[0x1E0C9AE50]);
    v29 = 0;
    v30 = v25;
  }
  CFDictionarySetValue(v11, CFSTR("OSBundlePath"), v30);
  v37 = *(const void **)(a1 + 24);
  if (!v37
    || (CFDictionarySetValue(v11, (const void *)*MEMORY[0x1E0C9AE78], v37),
        v38 = (const void *)*MEMORY[0x1E0C9AE90],
        (ValueForInfoDictionaryKey = OSKextGetValueForInfoDictionaryKey(a1, (const __CFString *)*MEMORY[0x1E0C9AE90])) == 0)
    || (CFDictionarySetValue(v11, v38, ValueForInfoDictionaryKey),
        v40 = (const void *)*MEMORY[0x1E0C9AAE0],
        (v41 = OSKextGetValueForInfoDictionaryKey(a1, (const __CFString *)*MEMORY[0x1E0C9AAE0])) == 0))
  {
LABEL_16:
    CFRelease(v11);
    CFRelease(v18);
    v11 = 0;
    v18 = 0;
    if (!v25)
      goto LABEL_18;
    goto LABEL_17;
  }
  CFDictionarySetValue(v11, v40, v41);
  if ((*(_BYTE *)(a1 + 92) & 0x10) != 0)
    CFDictionarySetValue(v11, CFSTR("OSBundleEnableKextLogging"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFRelease(v18);
LABEL_17:
  CFRelease(v25);
  v18 = v11;
LABEL_18:
  if (v29)
  {
    v31 = v29;
    goto LABEL_20;
  }
  return v18;
}

CFTypeRef OSKextCreateWithIdentifier(const __CFAllocator *a1, void *a2)
{
  const __CFAllocator *v3;
  CFArrayRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFArrayRef v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  CFTypeID v14;
  const __CFDictionary *Value;
  const __CFDictionary *v16;
  CFTypeID v17;
  const __CFString *v18;
  const __CFString *v19;
  CFTypeID v20;
  const __CFString *v21;
  const __CFString *v22;
  CFTypeID v23;
  uint64_t v24;
  void *UTF8CStringForCFString;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFURL *v36;
  __CFArray *KextsFromURLs;
  const void *KextWithIdentifierAndVersion;
  CFTypeRef v39;
  CFTypeRef v40;
  char v42;
  char v43;
  void *values;

  values = a2;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (!v4)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v42);
    return 0;
  }
  v11 = v4;
  v12 = (const __CFDictionary *)OSKextCopyLoadedKextInfo((unint64_t)v4, (const void *)__sOSKextInfoEssentialKeys, v5, v6, v7, v8, v9, v10);
  v13 = v12;
  if (!v12 || (v14 = CFGetTypeID(v12), v14 != CFDictionaryGetTypeID()))
  {
    v16 = 0;
LABEL_16:
    v36 = 0;
    v19 = 0;
    UTF8CStringForCFString = 0;
    v24 = -1;
    goto LABEL_17;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v13, values);
  v16 = Value;
  if (!Value)
    goto LABEL_16;
  v17 = CFGetTypeID(Value);
  if (v17 != CFDictionaryGetTypeID())
    goto LABEL_16;
  v18 = (const __CFString *)CFDictionaryGetValue(v16, CFSTR("OSBundlePath"));
  if (!v18 || (v19 = v18, v20 = CFGetTypeID(v18), v20 != CFStringGetTypeID()))
    v19 = 0;
  v21 = (const __CFString *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x1E0C9AE90]);
  if (!v21 || (v22 = v21, v23 = CFGetTypeID(v21), v23 != CFStringGetTypeID()))
    v22 = 0;
  v24 = OSKextParseVersionCFString(v22);
  if (v19)
  {
    UTF8CStringForCFString = createUTF8CStringForCFString(v19);
    OSKextLog(0, 262151, "Creating kext with path %s.", v26, v27, v28, v29, v30, (char)UTF8CStringForCFString);
    v36 = CFURLCreateWithFileSystemPath(v3, v19, kCFURLPOSIXPathStyle, 1u);
    if (!v36)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v31, v32, v33, v34, v35, v43);
      v40 = 0;
      v19 = 0;
      KextsFromURLs = 0;
      if (!UTF8CStringForCFString)
        goto LABEL_28;
      goto LABEL_27;
    }
    v19 = (const __CFString *)OSKextCreate((uint64_t)a1, v36);
  }
  else
  {
    v36 = 0;
    UTF8CStringForCFString = 0;
  }
LABEL_17:
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  KextsFromURLs = OSKextCreateKextsFromURLs(a1, (const __CFArray *)__sOSKextSystemExtensionsFolderURLs);
  if (v24 != -1 && (KextWithIdentifierAndVersion = OSKextGetKextWithIdentifierAndVersion(values, v24)) != 0
    || (KextWithIdentifierAndVersion = OSKextGetKextWithIdentifier(values)) != 0)
  {
    v39 = CFRetain(KextWithIdentifierAndVersion);
    v40 = v39;
    if (v16 && v39)
    {
      __OSKextProcessLoadInfo((int)v39, v16);
      if (!UTF8CStringForCFString)
        goto LABEL_28;
      goto LABEL_27;
    }
  }
  else
  {
    v40 = 0;
  }
  if (UTF8CStringForCFString)
LABEL_27:
    free(UTF8CStringForCFString);
LABEL_28:
  CFRelease(v11);
  if (v13)
    CFRelease(v13);
  if (v36)
    CFRelease(v36);
  if (v19)
    CFRelease(v19);
  if (KextsFromURLs)
    CFRelease(KextsFromURLs);
  return v40;
}

CFTypeRef OSKextCopyLoadedKextInfo(unint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *v10;
  mach_error_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __CFString *CFStringForPlist_new;
  void *UTF8CStringForCFString;
  CFTypeID TypeID;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  char v34;
  char v35;
  CFMutableDictionaryRef theDict;
  CFTypeRef cf;

  theDict = 0;
  cf = 0;
  OSKextLog(0, 69, "Reading loaded kext info from kernel.", a4, a5, a6, a7, a8, v34);
  v10 = __OSKextCreateKextRequest(CFSTR("Get Loaded Kext Info"), a1, &theDict);
  if (a2 && CFArrayGetCount((CFArrayRef)a2))
    CFDictionarySetValue(theDict, CFSTR("Kext Request Info Keys"), a2);
  v11 = __OSKextSendKextRequest(0, v10, &cf, 0, 0);
  if (v11)
  {
    v17 = mach_error_string(v11);
    v23 = "(unknown)";
    if (v17)
      LOBYTE(v23) = (_BYTE)v17;
    OSKextLog(0, 65, "Failed to read loaded kext info from kernel - %s.", v18, v19, v20, v21, v22, (char)v23);
    if (cf)
      CFRelease(cf);
    CFStringForPlist_new = 0;
    UTF8CStringForCFString = 0;
    cf = 0;
    goto LABEL_20;
  }
  if (!cf)
  {
    v32 = "Kernel request call returned no data.";
LABEL_19:
    OSKextLog(0, 65, v32, v12, v13, v14, v15, v16, v35);
    CFStringForPlist_new = 0;
    UTF8CStringForCFString = 0;
    goto LABEL_20;
  }
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(cf))
  {
    if (cf)
      CFRelease(cf);
    cf = 0;
    v32 = "Loaded kext info from kernel is wrong type.";
    goto LABEL_19;
  }
  CFStringForPlist_new = 0;
  UTF8CStringForCFString = 0;
  if ((~__sUserLogFilter & 7) == 0 && (__sUserLogFilter & 0x60) != 0)
  {
    CFStringForPlist_new = createCFStringForPlist_new(cf, 1);
    UTF8CStringForCFString = createUTF8CStringForCFString(CFStringForPlist_new);
    OSKextLog(0, 103, "Loaded kext info:\n%s", v27, v28, v29, v30, v31, (char)UTF8CStringForCFString);
  }
LABEL_20:
  if (v10)
    CFRelease(v10);
  if (CFStringForPlist_new)
    CFRelease(CFStringForPlist_new);
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  return cf;
}

_QWORD *OSKextGetKextWithIdentifierAndVersion(void *a1, uint64_t a2)
{
  _QWORD *result;
  _QWORD *v5;
  uint64_t v6;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;

  if (!__sOSKextsByIdentifier)
    return 0;
  __OSKextRealizeKextsWithIdentifier(a1);
  result = CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!result)
    return result;
  v5 = result;
  v6 = __kOSKextTypeID;
  if (v6 == CFGetTypeID(result))
  {
    if (v5[5] == a2)
      return v5;
    else
      return 0;
  }
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v5))
    return 0;
  Count = CFArrayGetCount((CFArrayRef)v5);
  if (Count < 1)
    return 0;
  v9 = Count;
  for (i = 0; i != v9; ++i)
  {
    result = CFArrayGetValueAtIndex((CFArrayRef)v5, i);
    if (result[5] == a2)
      break;
    result = 0;
  }
  return result;
}

void __OSKextProcessLoadInfo(int a1, CFDictionaryRef theDict)
{
  __CFString *Value;
  const __CFString *v4;
  const __CFArray *v5;
  void *UTF8CStringForCFString;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  int v17;
  _QWORD *ValueAtIndex;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  __int128 v32;
  int v33;
  _BYTE v34[20];
  UInt8 buffer[1024];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v32 = *(_OWORD *)"(unknown)";
  v33 = 0;
  Value = (__CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0C9AE78]);
  v4 = Value;
  if (!Value)
  {
    ValueAtIndex = 0;
    v5 = 0;
LABEL_17:
    UTF8CStringForCFString = 0;
    goto LABEL_20;
  }
  v5 = OSKextCopyKextsWithIdentifier(Value);
  if (!v5)
  {
    ValueAtIndex = 0;
    goto LABEL_17;
  }
  UTF8CStringForCFString = createUTF8CStringForCFString(v4);
  v7 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0C9AE90]);
  if (!v7)
  {
    OSKextLog(0, 97, "Kernel load info for %s lacks a CFBundleVersion.", v8, v9, v10, v11, v12, (char)UTF8CStringForCFString);
    goto LABEL_19;
  }
  v13 = OSKextParseVersionCFString(v7);
  OSKextVersionGetString(v13, &v32, 0x14u);
  Count = CFArrayGetCount(v5);
  if (Count < 1)
  {
LABEL_19:
    ValueAtIndex = 0;
    goto LABEL_20;
  }
  v15 = Count;
  v16 = 0;
  v17 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v5, v16);
    if (!__OSKextCreateLoadInfo((uint64_t)ValueAtIndex))
      break;
    __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 0, buffer, v20, v21, v22, v23);
    OSKextVersionGetString(ValueAtIndex[5], v34, 0x14u);
    v24 = ValueAtIndex[9];
    if (v13 == ValueAtIndex[5])
    {
      v25 = *(const void **)(v24 + 8);
      if (v25)
      {
        CFRelease(v25);
        v24 = ValueAtIndex[9];
      }
      *(_QWORD *)(v24 + 8) = 0;
      *(_QWORD *)(ValueAtIndex[9] + 8) = CFRetain(theDict);
      v17 = 1;
    }
    else
    {
      *(_WORD *)(v24 + 168) |= 0x200u;
    }
    if (v15 == ++v16)
    {
      if (v17)
        goto LABEL_22;
      goto LABEL_20;
    }
  }
  OSKextLog(0, 17, "Memory allocation failure.", v19, v20, v21, v22, v23, v31);
  if (v17)
    goto LABEL_22;
LABEL_20:
  if (!CFEqual(v4, CFSTR("__kernel__")))
    OSKextLog((uint64_t)ValueAtIndex, 102, "For loaded kext %s, v%s: no opened kext matches.", v26, v27, v28, v29, v30, (char)UTF8CStringForCFString);
LABEL_22:
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  if (v5)
    CFRelease(v5);
}

uint64_t OSKextGetAllKexts()
{
  const __CFArray *v0;
  CFRange v2;

  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v0 = (const __CFArray *)__sOSAllKexts;
  if (!__sOSAllKexts)
    return 0;
  v2.length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  v2.location = 0;
  CFArrayApplyFunction(v0, v2, (CFArrayApplierFunction)__OSKextRealize, 0);
  return __sOSAllKexts;
}

unint64_t *OSKextGetLoadedKextWithIdentifier(void *a1)
{
  unint64_t *Value;
  unint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *ValueAtIndex;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  __OSKextRealizeKextsWithIdentifier(a1);
  Value = (unint64_t *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = __kOSKextTypeID;
  if (v4 == CFGetTypeID(Value))
  {
    if (OSKextIsLoaded(v3, v5, v6, v7, v8, v9, v10, v11))
      return v3;
    else
      return 0;
  }
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v3))
    return 0;
  Count = CFArrayGetCount((CFArrayRef)v3);
  if (Count < 1)
    return 0;
  v15 = Count;
  v16 = 0;
  while (1)
  {
    ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex((CFArrayRef)v3, v16);
    if (OSKextIsLoaded(ValueAtIndex, v17, v18, v19, v20, v21, v22, v23))
      break;
    if (v15 == ++v16)
      return 0;
  }
  return ValueAtIndex;
}

uint64_t OSKextIsLoaded(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;

  v8 = a1[9];
  if (!v8)
    return 0;
  if (*(_QWORD *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    v8 = a1[9];
  }
  return (*(unsigned __int16 *)(v8 + 168) >> 7) & 1;
}

const __CFArray *OSKextGetCompatibleKextWithIdentifier(void *a1, uint64_t a2)
{
  const __CFArray *Value;
  const __CFArray *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v19;
  CFIndex v20;
  _QWORD *ValueAtIndex;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!__sOSKextsByIdentifier)
    return 0;
  __OSKextRealizeKextsWithIdentifier(a1);
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = __kOSKextTypeID;
  if (v6 != CFGetTypeID(Value))
  {
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        v19 = Count;
        v20 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v5, v20);
          v22 = ValueAtIndex[6];
          if (v22 >= 1 && v22 <= a2)
          {
            v16 = (uint64_t)ValueAtIndex;
            if (ValueAtIndex[5] >= a2)
            {
              if (!__sOSKextStrictAuthentication
                || OSKextIsValid((uint64_t)ValueAtIndex)
                && OSKextIsAuthentic(v16, v24, v25, v26, v27, v28, v29, v30))
              {
                return (const __CFArray *)v16;
              }
              OSKextLogCFString(0, 4097, CFSTR("Rejecting invalid/inauthentic kext for bundle id %@ at location %@."), v26, v27, v28, v29, v30, (char)a1);
            }
          }
          if (v19 == ++v20)
            return 0;
        }
      }
    }
    return 0;
  }
  v7 = *((_QWORD *)v5 + 6);
  v8 = v7 >= 1 && v7 <= a2;
  if (!v8 || *((_QWORD *)v5 + 5) < a2)
    return 0;
  if (__sOSKextStrictAuthentication
    && (!OSKextIsValid((uint64_t)v5)
     || !OSKextIsAuthentic((uint64_t)v5, v9, v10, v11, v12, v13, v14, v15)))
  {
    OSKextLogCFString(0, 4097, CFSTR("Rejecting invalid/inauthentic kext for bundle id %@ at location %@."), v11, v12, v13, v14, v15, (char)a1);
    return 0;
  }
  return v5;
}

BOOL OSKextIsCompatibleWithVersion(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 48);
  return v2 >= 1 && v2 <= a2 && *(_QWORD *)(a1 + 40) >= a2;
}

uint64_t OSKextIsValid(uint64_t a1)
{
  unsigned int v1;

  v1 = *(_DWORD *)(a1 + 92);
  if ((v1 & 0x400) != 0)
    return 0;
  if ((v1 & 0x200) == 0)
  {
    OSKextValidate(a1);
    v1 = *(_DWORD *)(a1 + 92);
  }
  return (v1 >> 11) & 1;
}

uint64_t OSKextIsAuthentic(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;

  v8 = *(_DWORD *)(a1 + 92);
  if ((v8 & 0x2000) != 0)
    return 0;
  if ((v8 & 0x1000) == 0)
  {
    OSKextAuthenticate(a1, a2, a3, a4, a5, a6, a7, a8);
    v8 = *(_DWORD *)(a1 + 92);
  }
  return (v8 >> 14) & 1;
}

CFArrayRef OSKextCopyKextsWithIdentifier(void *a1)
{
  void *Value;
  void *v3;
  uint64_t v4;
  CFArrayRef result;
  CFTypeID TypeID;
  void *values;

  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  __OSKextRealizeKextsWithIdentifier(a1);
  if (!__sOSKextsByIdentifier)
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  Value = (void *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!Value)
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  v3 = Value;
  v4 = __kOSKextTypeID;
  if (v4 == CFGetTypeID(Value))
  {
    values = v3;
    result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    if (result)
      return result;
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  }
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v3))
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFArrayRef)v3);
  if (!result)
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  return result;
}

CFComparisonResult __OSKextBundleIDCompare(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 0);
}

__CFArray *OSKextCopyAllRequestedIdentifiers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *KextRequest;
  mach_error_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __CFArray *Mutable;
  const void **v18;
  CFTypeID TypeID;
  CFIndex Count;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFAllocator *v27;
  CFIndex v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CFIndex v34;
  char v35;
  char v36;
  CFTypeRef cf;
  CFRange v38;

  cf = 0;
  OSKextLog(0, 71, "Reading list of all kexts requested by kernel since startup.", a4, a5, a6, a7, a8, v35);
  KextRequest = __OSKextCreateKextRequest(CFSTR("Get All Load Requests"), 0, 0);
  v9 = __OSKextSendKextRequest(0, KextRequest, &cf, 0, 0);
  if (v9)
  {
    v10 = mach_error_string(v9);
    v16 = "(unknown)";
    if (v10)
      LOBYTE(v16) = (_BYTE)v10;
    OSKextLog(0, 65, "Failed to read kexts requested by kernel since startup - %s.", v11, v12, v13, v14, v15, (char)v16);
    goto LABEL_5;
  }
  if (!cf || (TypeID = CFSetGetTypeID(), TypeID != CFGetTypeID(cf)))
  {
LABEL_5:
    Mutable = 0;
    v18 = 0;
    goto LABEL_6;
  }
  Count = CFSetGetCount((CFSetRef)cf);
  v18 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  if (v18)
  {
    CFSetGetValues((CFSetRef)cf, v18);
    v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v28 = CFSetGetCount((CFSetRef)cf);
    Mutable = CFArrayCreateMutable(v27, v28, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      if (CFSetGetCount((CFSetRef)cf) >= 1)
      {
        v34 = 0;
        do
          CFArrayAppendValue(Mutable, v18[v34++]);
        while (CFSetGetCount((CFSetRef)cf) > v34);
      }
      v38.length = CFArrayGetCount(Mutable);
      v38.location = 0;
      CFArraySortValues(Mutable, v38, (CFComparatorFunction)__OSKextBundleIDCompare, 0);
    }
    else
    {
      OSKextLog(0, 17, "Memory allocation failure.", v29, v30, v31, v32, v33, v36);
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v22, v23, v24, v25, v26, v36);
    Mutable = 0;
  }
LABEL_6:
  if (KextRequest)
    CFRelease(KextRequest);
  if (cf)
    CFRelease(cf);
  if (v18)
    free(v18);
  return Mutable;
}

__CFArray *OSKextCopyKextsWithIdentifiers(const __CFArray *a1)
{
  int Count;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFArray *Mutable;
  CFIndex v9;
  void *UTF8CStringForCFString;
  const __CFArray *v11;
  __CFString *ValueAtIndex;
  const __CFArray *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;
  CFRange v21;

  Count = CFArrayGetCount(a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    if (Count >= 1)
    {
      v9 = 0;
      UTF8CStringForCFString = 0;
      v11 = 0;
      do
      {
        if (v11)
          CFRelease(v11);
        if (UTF8CStringForCFString)
          free(UTF8CStringForCFString);
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a1, v9);
        v13 = OSKextCopyKextsWithIdentifier(ValueAtIndex);
        v11 = v13;
        if (v13)
        {
          v21.length = CFArrayGetCount(v13);
          v21.location = 0;
          CFArrayAppendArray(Mutable, v11, v21);
          UTF8CStringForCFString = 0;
        }
        else
        {
          UTF8CStringForCFString = createUTF8CStringForCFString(ValueAtIndex);
          OSKextLog(0, 262151, "Note: OSKextCopyKextsWithIdentifiers() - identifier %s not found.", v14, v15, v16, v17, v18, (char)UTF8CStringForCFString);
        }
        ++v9;
      }
      while (Count != v9);
      if (v11)
        CFRelease(v11);
      if (UTF8CStringForCFString)
        free(UTF8CStringForCFString);
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v20);
  }
  return Mutable;
}

__CFArray *OSKextCopyLoadListForKexts(const __CFArray *a1, int a2)
{
  const __CFAllocator *v4;
  CFMutableSetRef Mutable;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFSet *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFArray *v17;
  CFIndex Count;
  CFIndex v19;
  CFIndex v20;
  const __CFArray *v21;
  int v22;
  const void *ValueAtIndex;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFArray *v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex i;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __CFSet *v45;
  char v47;
  int v48;
  UInt8 buffer[1024];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v47);
    return 0;
  }
  v11 = Mutable;
  v17 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
  if (!v17)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v47);
    goto LABEL_27;
  }
  Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
LABEL_27:
    v45 = v11;
LABEL_30:
    CFRelease(v45);
    return v17;
  }
  v19 = Count;
  v20 = 0;
  v21 = 0;
  if (a2)
    v22 = 145;
  else
    v22 = 146;
  v48 = v22;
  do
  {
    if (v21)
      CFRelease(v21);
    ValueAtIndex = CFArrayGetValueAtIndex(a1, v20);
    if (CFSetGetValue(v11, ValueAtIndex))
    {
      v21 = 0;
    }
    else if (__OSKextIsValid((uint64_t)ValueAtIndex, v24, v25, v26, v27, v28, v29, v30))
    {
      v35 = __OSKextCopyDependenciesList(ValueAtIndex, a2, 0);
      if (!v35)
        goto LABEL_23;
      v21 = v35;
      v36 = CFArrayGetCount(v35);
      if (v36 >= 1)
      {
        v37 = v36;
        for (i = 0; i != v37; ++i)
        {
          v39 = CFArrayGetValueAtIndex(v21, i);
          if (!CFSetGetValue(v11, v39))
          {
            CFArrayAppendValue(v17, v39);
            CFSetSetValue(v11, v39);
          }
        }
      }
    }
    else
    {
      __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 0, buffer, v31, v32, v33, v34);
      OSKextLog((uint64_t)ValueAtIndex, v48, "%s is not valid.", v40, v41, v42, v43, v44, (char)buffer);
      v21 = 0;
      if (a2)
      {
LABEL_23:
        CFRelease(v11);
        CFRelease(v17);
        return 0;
      }
    }
    ++v20;
  }
  while (v20 != v19);
  CFRelease(v11);
  if (v21)
  {
    v45 = v21;
    goto LABEL_30;
  }
  return v17;
}

uint64_t __OSKextIsValid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;

  v8 = *(_DWORD *)(a1 + 92);
  if ((v8 & 0x400) != 0)
    return 0;
  if ((v8 & 0x200) == 0)
  {
    __OSKextValidate(a1, 0, a3, a4, a5, a6, a7, a8);
    v8 = *(_DWORD *)(a1 + 92);
  }
  return (v8 >> 11) & 1;
}

CFMutableArrayRef OSKextCopyLoadList(const void *a1, int a2)
{
  return __OSKextCopyDependenciesList(a1, a2, 0);
}

BOOL _OSKextIdentifierHasApplePrefix(uint64_t a1)
{
  return CFStringHasPrefix(*(CFStringRef *)(a1 + 24), CFSTR("com.apple.")) != 0;
}

CFStringRef __OSKextCreateCompositeKey(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@%s%s"), a1, "_", a2);
}

uint64_t __OSKextReadInfoDictionary(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *UTF8CStringForCFString;
  int v14;
  uint64_t v15;
  CFBundleRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFString *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const __CFString *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  off_t st_size;
  off_t v54;
  ssize_t v55;
  CFTypeRef v56;
  CFTypeID TypeID;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  CFTypeRef cf;
  stat v65;
  UInt8 v66[1024];
  UInt8 __dst[1024];
  UInt8 buffer[1024];
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  memset(&v65, 0, sizeof(v65));
  cf = 0;
  memcpy(__dst, "(unknown)", sizeof(__dst));
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, v4, v5, v6, v7);
  if (*(_QWORD *)(a1 + 56))
  {
    UTF8CStringForCFString = 0;
    v14 = 0;
    v15 = 1;
LABEL_7:
    v22 = -1;
    goto LABEL_8;
  }
  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
  {
    __OSKextGetFileSystemPath(0, **(CFURLRef **)(a1 + 80), 0, __dst, v9, v10, v11, v12);
    OSKextLog(a1, 129, "%s created from m%s is missing its info dictionary.", v17, v18, v19, v20, v21, (char)buffer);
    UTF8CStringForCFString = 0;
    v15 = 0;
    v14 = 1;
    goto LABEL_7;
  }
  if (a2)
  {
    v16 = 0;
  }
  else
  {
    OSKextLog(a1, 131079, "Opening CFBundle for %s.", v8, v9, v10, v11, v12, (char)buffer);
    v16 = CFBundleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFURLRef *)(a1 + 16));
    if (!v16)
    {
      OSKextLog(0, 131073, "Can't open CFBundle for %s.", v24, v25, v26, v27, v28, (char)buffer);
      v14 = 1;
      __OSKextSetDiagnostic(a1, 1, CFSTR("Failed to open CFBundle (unknown error)."));
      UTF8CStringForCFString = 0;
      v15 = 0;
      goto LABEL_7;
    }
  }
  v34 = (const __CFString *)_CFBundleCopyInfoPlistURL();
  if (v34)
  {
    if (__OSKextGetFileSystemPath(0, (CFURLRef)v34, 1u, v66, v30, v31, v32, v33))
    {
      if (!stat((const char *)v66, &v65))
      {
        v22 = open((const char *)v66, 0);
        if (v22 < 0)
        {
          v14 = 1;
          __OSKextAddDiagnostic(a1, 1, CFSTR("File access failure; can't open, or I/O error"),
            v34,
            0,
            v44,
            v45,
            v46,
            v63);
          v15 = 0;
          v52 = 0;
        }
        else
        {
          v52 = (char *)malloc_type_malloc(v65.st_size + 1, 0xEAE9E46CuLL);
          if (!v52)
          {
            OSKextLog(0, 17, "Memory allocation failure.", v47, v48, v49, v50, v51, v63);
            v15 = 0;
            UTF8CStringForCFString = 0;
            v14 = 1;
            goto LABEL_36;
          }
          st_size = v65.st_size;
          if (v65.st_size < 1)
          {
            v54 = 0;
LABEL_45:
            v52[v54] = 0;
            v56 = IOCFUnserialize(v52, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFStringRef *)&cf);
            *(_QWORD *)(a1 + 56) = v56;
            if (v56 && (TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(*(CFTypeRef *)(a1 + 56))))
            {
              v14 = 0;
              UTF8CStringForCFString = 0;
              v15 = 1;
            }
            else
            {
              __OSKextAddDiagnostic(a1, 1, CFSTR("Can't parse info dictionary XML"), (const __CFString *)cf, 0, v41, v42, v43, v63);
              if (cf)
                UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)cf);
              else
                UTF8CStringForCFString = 0;
              v14 = 1;
              OSKextLog(a1, 1, "Can't read info dictionary for %s: %s.", v58, v59, v60, v61, v62, (char)buffer);
              v15 = 0;
            }
            goto LABEL_36;
          }
          v54 = 0;
          while (1)
          {
            v55 = read(v22, &v52[v54], st_size - v54);
            if (v55 < 0)
              break;
            v54 += v55;
            st_size = v65.st_size;
            if (v54 >= v65.st_size)
              goto LABEL_45;
          }
          v14 = 1;
          __OSKextSetDiagnostic(a1, 1, CFSTR("File access failure; can't open, or I/O error"));
          v15 = 0;
        }
        UTF8CStringForCFString = 0;
        goto LABEL_36;
      }
      if (*__error() == 2)
        v38 = CFSTR("File not found");
      else
        v38 = CFSTR("Failed to get file info (stat failed)");
    }
    else
    {
      v38 = CFSTR("Internal error converting URL");
    }
    v14 = 1;
    __OSKextAddDiagnostic(a1, 1, v38, v34, 0, v35, v36, v37, v63);
  }
  else
  {
    OSKextLog(0, 131073, "%s has no Info.plist file.", v29, v30, v31, v32, v33, (char)buffer);
    v14 = 1;
    __OSKextSetDiagnostic(a1, 1, CFSTR("Failed to open CFBundle (unknown error)."));
  }
  v15 = 0;
  v52 = 0;
  UTF8CStringForCFString = 0;
  v22 = -1;
LABEL_36:
  if (v16)
  {
    OSKextLog(a1, 131079, "Releasing CFBundle for %s.", v39, v40, v41, v42, v43, (char)buffer);
    CFRelease(v16);
  }
  if (v34)
    CFRelease(v34);
  if (v52)
    free(v52);
LABEL_8:
  if (cf)
    CFRelease(cf);
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  if ((v22 & 0x80000000) == 0)
    close(v22);
  if (v14)
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
  return v15;
}

CFMutableDictionaryRef OSKextCopyInfoDictionary(uint64_t cf)
{
  const __CFAllocator *v2;

  if (!*(_QWORD *)(cf + 56) && !__OSKextReadInfoDictionary(cf, 0))
    return 0;
  v2 = CFGetAllocator((CFTypeRef)cf);
  return CFDictionaryCreateMutableCopy(v2, 0, *(CFDictionaryRef *)(cf + 56));
}

void OSKextFlushInfoDictionary(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int v8;
  char v9;
  UInt8 buffer[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (a1)
  {
    if ((OSKextFlushInfoDictionary_flushingAll & 1) == 0)
    {
      if (*(_QWORD *)(a1 + 16))
        __OSKextGetFileSystemPath(a1, 0, 0, buffer, v3, v4, v5, v6);
      OSKextLog(0, 262150, "Flushing info dictionary for %s.", v2, v3, v4, v5, v6, (char)buffer);
    }
    if ((*(_BYTE *)(a1 + 88) & 8) == 0)
    {
      v7 = *(const void **)(a1 + 56);
      if (v7)
        CFRelease(v7);
      *(_QWORD *)(a1 + 56) = 0;
      v8 = *(_DWORD *)(a1 + 92);
      if ((~v8 & 0x4900) != 0)
        *(_DWORD *)(a1 + 92) = v8 & 0xFFFD81FF;
    }
  }
  else if (__sOSKextsByURL)
  {
    OSKextFlushInfoDictionary_flushingAll = 1;
    OSKextLog(0, 262150, "Flushing info dictionaries for all kexts.", v2, v3, v4, v5, v6, v9);
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushInfoDictionaryApplierFunction, 0);
    OSKextFlushInfoDictionary_flushingAll = 0;
  }
}

uint64_t OSKextIsFromMkext(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 88) >> 3) & 1;
}

uint64_t __OSKextFlushInfoDictionaryApplierFunction(uint64_t a1, uint64_t a2)
{
  return OSKextFlushInfoDictionary(a2);
}

uint64_t OSKextGetCompatibleVersion(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t __OSKextUUIDCallback(_DWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (*a1 != 27)
    return 2;
  if ((unint64_t)a1 + a1[1] > a2)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_DWORD *)a4 = 16;
  *(_QWORD *)(a4 + 8) = a1 + 2;
  return result;
}

CFDataRef OSKextCopyUUIDForArchitecture(const void *a1, char **a2)
{
  const __CFData *v3;
  const __CFData *v4;
  int *BytePtr;
  CFIndex Length;
  int v7;
  int commands;
  CFDataRef v9;
  const __CFAllocator *v10;
  unsigned int v11;
  CFIndex v12;
  uint64_t v14;
  UInt8 *bytes;

  if (!a2)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    a2 = __sOSKextArchInfo;
  }
  v3 = OSKextCopyExecutableForArchitecture((uint64_t)a1, (uint64_t)a2);
  if (!v3)
    return 0;
  v4 = v3;
  v14 = 0;
  bytes = 0;
  BytePtr = (int *)CFDataGetBytePtr(v3);
  Length = CFDataGetLength(v4);
  v7 = *BytePtr;
  commands = macho_scan_load_commands(BytePtr, (unint64_t)BytePtr + Length, __OSKextUUIDCallback, (uint64_t)&v14);
  if (commands)
  {
    v9 = 0;
    if (commands == -1)
    {
      __OSKextSetDiagnostic((uint64_t)a1, 1, CFSTR("Executable file doesn't contain kernel extension code (no kmod_info symbol or bad Mach-O layout)."));
      v9 = 0;
    }
  }
  else
  {
    v10 = CFGetAllocator(a1);
    v11 = bswap32(v14);
    if (((v7 + 822415874) & 0xFEFFFFFF) != 0)
      v12 = v14;
    else
      v12 = v11;
    v9 = CFDataCreate(v10, bytes, v12);
  }
  CFRelease(v4);
  return v9;
}

CFDataRef OSKextCopyExecutableForArchitecture(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  uint64_t v6;
  const __CFData *v7;
  const __CFData *v8;
  int *BytePtr;
  CFIndex Length;
  int **v11;
  int **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFDataRef v17;
  CFDataRef v18;
  char *arch;
  const UInt8 *v20;
  const __CFAllocator *v21;
  CFDataRef v22;
  const __CFAllocator *v24;
  const UInt8 *v25;
  CFIndex v26;
  const __CFAllocator *v27;
  const __CFString *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  uint64_t v33;
  UInt8 buffer[8];
  uint64_t v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!__OSKextReadExecutable(a1))
    return 0;
  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
  {
    v6 = *(_QWORD *)(a1 + 80);
    if (!v6)
      return 0;
    v5 = *(const void **)(v6 + 16);
    if (!v5)
      return 0;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 72);
    if (!v4)
      return 0;
    v5 = *(const void **)(v4 + 128);
    if (!v5)
      return 0;
  }
  v7 = (const __CFData *)CFRetain(v5);
  if (!v7)
    return 0;
  v8 = v7;
  if (a2)
  {
    BytePtr = (int *)CFDataGetBytePtr(v7);
    v33 = 0;
    Length = CFDataGetLength(v8);
    v11 = (int **)fat_iterator_for_data(BytePtr, (unint64_t)BytePtr + Length, 1);
    if (v11)
    {
      v12 = v11;
      if ((*(_BYTE *)(a1 + 88) & 8) != 0)
        goto LABEL_17;
      *(_QWORD *)buffer = 0;
      v35 = 0;
      v36 = 0;
      if (!fat_iterator_find_fat_arch(v11, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), (uint64_t)buffer))
        goto LABEL_26;
      if (*MEMORY[0x1E0C85AD8] != 1 << v36)
      {
LABEL_17:
        arch = fat_iterator_find_arch(v12, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), &v33);
        if (!arch)
          goto LABEL_26;
        v20 = (const UInt8 *)arch;
        v21 = CFGetAllocator((CFTypeRef)a1);
        v17 = CFDataCreate(v21, v20, v33 - (_QWORD)v20);
      }
      else
      {
        v17 = __OSKextMapExecutable(a1, v35, HIDWORD(v35));
      }
      v22 = v17;
      if (v17)
      {
LABEL_29:
        CFRelease(v8);
        fat_iterator_close((void **)v12);
        return v22;
      }
LABEL_26:
      __OSKextGetFileSystemPath(a1, 0, 0, buffer, v13, v14, v15, v16);
      v27 = CFGetAllocator((CFTypeRef)a1);
      v28 = CFStringCreateWithCString(v27, *(const char **)a2, 0x8000100u);
      if (v28)
      {
        v32 = v28;
        __OSKextAddDiagnostic(a1, 8, CFSTR("Executable does not contain code for architecture"), v28, 0, v29, v30, v31, v33);
        CFRelease(v32);
      }
      v22 = 0;
      goto LABEL_29;
    }
    __OSKextSetDiagnostic(a1, 1, CFSTR("Executable file doesn't contain kernel extension code (no kmod_info symbol or bad Mach-O layout)."));
    CFRelease(v8);
    return 0;
  }
  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
  {
    v24 = CFGetAllocator(v7);
    v25 = CFDataGetBytePtr(v8);
    v26 = CFDataGetLength(v8);
    v18 = CFDataCreate(v24, v25, v26);
  }
  else
  {
    v18 = __OSKextMapExecutable(a1, 0, 0);
  }
  v22 = v18;
  CFRelease(v8);
  return v22;
}

void __OSKextSetDiagnostic(uint64_t a1, int a2, const void *a3)
{
  __CFDictionary *Diagnostics;

  if ((__sOSKextRecordsDiagnositcs & a2) != 0)
  {
    Diagnostics = __OSKextGetDiagnostics(a1, a2);
    if (Diagnostics)
      CFDictionarySetValue(Diagnostics, a3, (const void *)*MEMORY[0x1E0C9AE50]);
  }
}

uint64_t OSKextIsKernelComponent(uint64_t a1)
{
  return *(_DWORD *)(a1 + 92) & 1;
}

uint64_t OSKextIsInterface(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 1) & 1;
}

BOOL OSKextIsLibrary(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48) > 0;
}

uint64_t OSKextDeclaresExecutable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 2) & 1;
}

BOOL OSKextHasLogOrDebugFlags(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 92) & 0x60) != 0;
}

uint64_t OSKextIsLoggingEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 4) & 1;
}

void OSKextSetLoggingEnabled(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  UInt8 buffer[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v8 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 92) = v8 & 0xFFFFFFEF | (16 * (a2 != 0));
  if (((v8 >> 4) & 1) != (a2 != 0))
  {
    __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
    if ((*(_DWORD *)(a1 + 92) & 0x10) != 0)
      v15 = "en";
    else
      v15 = "dis";
    OSKextLog(a1, 262151, "Kext logging %sabled for %s.", v10, v11, v12, v13, v14, (char)v15);
  }
}

uint64_t OSKextIsLoadableInSafeBoot(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 92) >> 7;
}

uint64_t OSKextDependenciesAreLoadableInSafeBoot(const void *a1)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  unsigned __int8 v7;
  const __CFString **ValueAtIndex;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v13;

  v2 = __OSKextCopyDependenciesList(a1, 1, 1);
  if (v2)
  {
    v3 = v2;
    Count = CFArrayGetCount(v2);
    if (Count < 1)
    {
      v7 = 1;
    }
    else
    {
      v5 = Count;
      v6 = 0;
      v7 = 1;
      do
      {
        ValueAtIndex = (const __CFString **)CFArrayGetValueAtIndex(v3, v6);
        if (OSKextGetActualSafeBoot() | __sOSKextSimulatedSafeBoot
          && (*((_BYTE *)ValueAtIndex + 92) & 0x80) == 0)
        {
          __OSKextAddDiagnostic((uint64_t)a1, 16, CFSTR("Dependencies aren't loadable during safe boot"), ValueAtIndex[3], 0, v9, v10, v11, v13);
          v7 = 0;
        }
        ++v6;
      }
      while (v5 != v6);
    }
    CFRelease(v3);
  }
  else
  {
    return 0;
  }
  return v7;
}

CFMutableArrayRef OSKextCopyAllDependencies(const void *a1, int a2)
{
  return __OSKextCopyDependenciesList(a1, a2, 1);
}

_QWORD *OSKextCopyArchitectures(uint64_t a1)
{
  int *BytePtr;
  CFIndex Length;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  size_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _DWORD *arch;
  int v17;
  cpu_type_t v18;
  cpu_subtype_t v19;
  const __CFURL *ExecutableURL;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  UInt8 buffer[1024];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 92) & 4) == 0 || !__OSKextReadExecutable(a1))
    return 0;
  BytePtr = (int *)CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(a1 + 72) + 128));
  Length = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(a1 + 72) + 128));
  v4 = (uint64_t *)fat_iterator_for_data(BytePtr, (unint64_t)BytePtr + Length, 1);
  if (!v4)
  {
    if ((*(_BYTE *)(a1 + 92) & 8) != 0)
      ExecutableURL = 0;
    else
      ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((_QWORD *)a1, v5, v6, v7, v8, v9, v10, v11);
    __OSKextGetFileSystemPath(a1, ExecutableURL, 0, buffer, v8, v9, v10, v11);
    OSKextLog(a1, 131073, "Can't read mach-o file %s.", v21, v22, v23, v24, v25, (char)buffer);
    return 0;
  }
  v12 = v4;
  v13 = (int)(8 * fat_iterator_num_arches((uint64_t)v4) + 8);
  v14 = malloc_type_malloc(v13, 0x2818BDBDuLL);
  v15 = v14;
  if (v14)
  {
    bzero(v14, v13);
    arch = (_DWORD *)fat_iterator_next_arch(v12, 0);
    if (arch)
    {
      v17 = 0;
      do
      {
        if ((*arch | 0x1000000) == 0xCFFAEDFE)
          v18 = bswap32(arch[1]);
        else
          v18 = arch[1];
        if ((*arch | 0x1000000) == 0xCFFAEDFE)
          v19 = bswap32(arch[2]);
        else
          v19 = arch[2];
        v15[v17++] = NXGetArchInfoFromCpuType(v18, v19);
        arch = (_DWORD *)fat_iterator_next_arch(v12, 0);
      }
      while (arch);
    }
  }
  fat_iterator_close((void **)v12);
  return v15;
}

uint64_t __OSKextReadExecutable(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  CFDataRef v4;
  uint64_t v5;
  const __CFNumber *Value;
  const __CFNumber *v7;
  const UInt8 *BytePtr;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFURL *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const UInt8 *v18;
  CFIndex v19;
  uInt v20;
  const __CFAllocator *v21;
  CFDataRef UncompressMkext2FileData;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const __CFAllocator *v28;
  CFDataRef v29;
  char v30;
  int valuePtr;
  UInt8 buffer[1024];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 92) & 4) == 0)
    return 0;
  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
  {
    v5 = *(_QWORD *)(a1 + 80);
    if (v5 && *(_QWORD *)(v5 + 16))
      return 1;
    result = __OSKextCreateMkextInfo(a1);
    if (!(_DWORD)result)
      return result;
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), CFSTR("_MKEXTExecutable"));
    if (!Value)
      return 1;
    v7 = Value;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(a1 + 80) + 8));
    valuePtr = 0;
    bzero(buffer, 0x400uLL);
    v14 = **(const __CFURL ***)(a1 + 80);
    if (v14)
      __OSKextGetFileSystemPath(0, v14, 0, buffer, v10, v11, v12, v13);
    OSKextLog(a1, 134, "Extracting %s%s from %s.", v9, v10, v11, v12, v13, (char)"executable");
    if (CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr))
    {
      v18 = &BytePtr[valuePtr];
      v19 = bswap32(*((_DWORD *)v18 + 1));
      if (!*(_DWORD *)v18)
      {
        v28 = CFGetAllocator((CFTypeRef)a1);
        v29 = CFDataCreate(v28, v18 + 8, v19);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) = v29;
        if (v29)
          return 1;
LABEL_23:
        __OSKextAddDiagnostic(a1, 1, CFSTR("Kext has a CFBundleExecutable property but the executable can't be found"), CFSTR("(executable from mkext)"), 0, v15, v16, v17, v30);
        result = 0;
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
        return result;
      }
      v20 = bswap32(*(_DWORD *)v18);
      v21 = CFGetAllocator((CFTypeRef)a1);
      UncompressMkext2FileData = __OSKextCreateUncompressMkext2FileData(v21, (Bytef *)v18 + 8, v20, v19);
      if (UncompressMkext2FileData)
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) = UncompressMkext2FileData;
        return 1;
      }
      OSKextLog(a1, 129, "Failed to uncompress %s%s from %s.", v23, v24, v25, v26, v27, (char)"executable");
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) = 0;
    goto LABEL_23;
  }
  v3 = *(_QWORD *)(a1 + 72);
  if (v3 && *(_QWORD *)(v3 + 128))
    return 1;
  result = __OSKextCreateLoadInfo(a1);
  if ((_DWORD)result)
  {
    v4 = __OSKextMapExecutable(a1, 0, 0);
    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 128) = v4;
    return v4 != 0;
  }
  return result;
}

uint64_t OSKextSupportsArchitecture(uint64_t a1, char **a2)
{
  uint64_t v2;
  char **v3;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  const __CFData *v8;
  const __CFData *v9;
  int *BytePtr;
  CFIndex Length;
  int **v12;
  void **v13;
  char *arch;
  BOOL v15;
  char *v17;

  if ((*(_BYTE *)(a1 + 92) & 4) == 0)
    return 1;
  v3 = a2;
  if (!a2)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v3 = __sOSKextArchInfo;
  }
  if (!__OSKextReadExecutable(a1))
    return 0;
  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
  {
    v7 = *(_QWORD *)(a1 + 80);
    if (!v7)
      return 0;
    v6 = *(const void **)(v7 + 16);
    if (!v6)
      return 0;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 72);
    if (!v5)
      return 0;
    v6 = *(const void **)(v5 + 128);
    if (!v6)
      return 0;
  }
  v8 = (const __CFData *)CFRetain(v6);
  if (!v8)
    return 0;
  v9 = v8;
  BytePtr = (int *)CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v9);
  v12 = (int **)fat_iterator_for_data(BytePtr, (unint64_t)BytePtr + Length, 1);
  if (!v12)
  {
    CFRelease(v9);
    return 0;
  }
  v13 = (void **)v12;
  v17 = 0;
  arch = fat_iterator_find_arch(v12, *((_DWORD *)v3 + 2), *((_DWORD *)v3 + 3), &v17);
  if (arch)
    v15 = arch == v17;
  else
    v15 = 1;
  v2 = !v15;
  CFRelease(v9);
  fat_iterator_close(v13);
  return v2;
}

__CFBundle *OSKextCopyPlugins(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFAllocator *v9;
  __CFBundle *result;
  __CFBundle *v11;
  CFURLRef v12;
  CFURLRef v13;
  CFMutableArrayRef KextsFromURL;
  CFURLRef v15;
  const __CFAllocator *v16;

  if (OSKextIsPlugin(a1, a2, a3, a4, a5, a6, a7, a8) || (*(_BYTE *)(a1 + 92) & 8) != 0)
  {
    v16 = CFGetAllocator((CFTypeRef)a1);
    return CFArrayCreate(v16, 0, 0, MEMORY[0x1E0C9B378]);
  }
  else
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    result = CFBundleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFURLRef *)(a1 + 16));
    if (result)
    {
      v11 = result;
      v12 = CFBundleCopyBuiltInPlugInsURL(result);
      if (v12)
      {
        v13 = v12;
        KextsFromURL = (CFMutableArrayRef)__OSKextCreateKextsFromURL(v9, v12, a1, 0);
        CFRelease(v11);
        v15 = v13;
      }
      else
      {
        KextsFromURL = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
        v15 = v11;
      }
      CFRelease(v15);
      return KextsFromURL;
    }
  }
  return result;
}

BOOL OSKextIsPlugin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFURL *v12;
  const __CFURL *PathComponent;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFURL *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  CFIndex location;
  _BOOL8 v27;
  const char *v28;
  int v29;
  char v31;

  v8 = *(unsigned __int8 *)(a1 + 88);
  if ((v8 & 1) != 0)
    return (v8 >> 1) & 1;
  v10 = *(const __CFURL **)(a1 + 16);
  if (!v10)
  {
    v28 = "Bundle URL unexpectedly NULL!";
    v11 = (const __CFURL *)a1;
    v29 = 262161;
LABEL_12:
    OSKextLog((uint64_t)v11, v29, v28, a4, a5, a6, a7, a8, v31);
    return 0;
  }
  v11 = CFURLCopyAbsoluteURL(v10);
  if (!v11)
  {
    v28 = "Memory allocation failure.";
    v29 = 17;
    goto LABEL_12;
  }
  v12 = v11;
  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11);
  if (!PathComponent)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v14, v15, v16, v17, v18, v31);
    CFRelease(v12);
    return 0;
  }
  v19 = PathComponent;
  v25 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
  if (!v25)
    OSKextLog(0, 17, "Memory allocation failure.", v20, v21, v22, v23, v24, v31);
  location = CFStringFind(v25, CFSTR(".kext/"), 0).location;
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a1 + 88) & 0xFC | (2 * (location != -1)) | 1;
  v27 = location != -1;
  CFRelease(v12);
  CFRelease(v19);
  if (v25)
    CFRelease(v25);
  return v27;
}

CFTypeRef OSKextCopyContainerForPluginKext(uint64_t a1)
{
  const __CFURL *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFURL *v8;
  const __CFAllocator *v9;
  const __CFURL *PathComponent;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFURL *v16;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  CFRange v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  const __CFURL *v31;
  CFURLRef *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFURLRef *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __CFBundle *v48;
  const __CFString *v49;
  const __CFURL *v50;
  const __CFURL *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const __CFURL *v57;
  size_t v58;
  CFTypeRef v59;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  char v67;
  char v68;
  const __CFURL *v69;
  const __CFString *cf;
  char buffer[1024];
  char __s[1024];
  UInt8 v73[1024];
  uint64_t v74;
  CFRange v75;

  v74 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 88) & 3) == 1)
    return 0;
  v2 = CFURLCopyAbsoluteURL(*(CFURLRef *)(a1 + 16));
  if (!v2)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v67);
    return 0;
  }
  v8 = v2;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2);
  if (!PathComponent)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v11, v12, v13, v14, v15, v67);
    CFRelease(v8);
    return 0;
  }
  v16 = PathComponent;
  v17 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
  v23 = v17;
  if (!v17)
    goto LABEL_20;
  v24 = CFStringFind(v17, CFSTR(".kext/"), 4uLL);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a1 + 88) & 0xFC | (2 * (v24.location != -1)) | 1;
  if (v24.location == -1)
  {
LABEL_21:
    cf = 0;
LABEL_22:
    v69 = 0;
    v37 = 0;
    goto LABEL_23;
  }
  v75.length = v24.location + v24.length;
  v75.location = 0;
  v17 = CFStringCreateWithSubstring(v9, v23, v75);
  if (!v17)
  {
LABEL_20:
    OSKextLog((uint64_t)v17, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, v67);
    goto LABEL_21;
  }
  cf = v17;
  if (!CFStringGetCString(v17, buffer, 1024, 0x8000100u))
  {
    v66 = "String/URL conversion failure.";
    v31 = (const __CFURL *)a1;
LABEL_44:
    OSKextLog((uint64_t)v31, 17, v66, v25, v26, v27, v28, v29, v67);
    goto LABEL_22;
  }
  v30 = strlen(buffer);
  v31 = CFURLCreateFromFileSystemRepresentation(v9, (const UInt8 *)buffer, v30, 1u);
  if (!v31)
  {
    v66 = "Memory allocation failure.";
    goto LABEL_44;
  }
  v69 = v31;
  v32 = (CFURLRef *)OSKextCreate((uint64_t)v9, v31);
  v37 = v32;
  if (!v32)
  {
LABEL_23:
    v48 = 0;
LABEL_24:
    v50 = 0;
    v57 = 0;
    v49 = 0;
    goto LABEL_25;
  }
  __OSKextGetFileSystemPath((uint64_t)v32, 0, 0, v73, v33, v34, v35, v36);
  OSKextLog(a1, 131079, "Opening CFBundle for %s.", v38, v39, v40, v41, v42, (char)v73);
  v48 = CFBundleCreate(v9, v37[2]);
  if (!v48)
  {
    OSKextLog(a1, 131073, "Failed to open CFBundle for %s.", v43, v44, v45, v46, v47, (char)v73);
    goto LABEL_24;
  }
  v49 = CFURLCopyLastPathComponent(*(CFURLRef *)(a1 + 16));
  v50 = CFBundleCopyBuiltInPlugInsURL(v48);
  v51 = CFURLCreateCopyAppendingPathComponent(v9, v50, v49, 1u);
  v57 = v51;
  if (!v51)
    goto LABEL_46;
  if (!__OSKextGetFileSystemPath(0, v51, 1u, (UInt8 *)__s, v53, v54, v55, v56))
  {
LABEL_25:
    v59 = 0;
    goto LABEL_26;
  }
  CFRelease(v57);
  v58 = strlen(__s);
  v51 = CFURLCreateFromFileSystemRepresentation(v9, (const UInt8 *)__s, v58, 1u);
  v57 = v51;
  if (!v51)
  {
LABEL_46:
    OSKextLog((uint64_t)v51, 17, "Memory allocation failure.", v52, v53, v54, v55, v56, v68);
    goto LABEL_25;
  }
  if (!CFEqual(v8, v51))
    goto LABEL_25;
  v59 = CFRetain(v37);
LABEL_26:
  CFRelease(v8);
  CFRelease(v16);
  if (v23)
    CFRelease(v23);
  if (cf)
    CFRelease(cf);
  if (v69)
    CFRelease(v69);
  if (v37)
    CFRelease(v37);
  if (v48)
  {
    OSKextLog(a1, 131079, "Releasing CFBundle for %s.", v61, v62, v63, v64, v65, (char)v73);
    CFRelease(v48);
  }
  if (v50)
    CFRelease(v50);
  if (v57)
    CFRelease(v57);
  if (v49)
    CFRelease(v49);
  return v59;
}

CFMutableArrayRef OSKextCopyPersonalitiesArray(CFURLRef *a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFMutableArrayRef Mutable;
  const __CFDictionary *ValueForInfoDictionaryKey;
  const __CFDictionary *v10;
  CFTypeID v11;
  const char *v12;
  int v13;
  const __CFString *v14;
  char CStringPtr;
  _QWORD context[5];

  v2 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v12 = "Memory allocation failure.";
    v13 = 17;
LABEL_8:
    OSKextLog(0, v13, v12, v3, v4, v5, v6, v7, CStringPtr);
    return Mutable;
  }
  ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, CFSTR("IOKitPersonalities"));
  if (!ValueForInfoDictionaryKey)
    return Mutable;
  v10 = ValueForInfoDictionaryKey;
  v11 = CFGetTypeID(ValueForInfoDictionaryKey);
  if (v11 != CFDictionaryGetTypeID())
  {
    v14 = CFURLGetString(a1[2]);
    CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
    v12 = "Kext personality for kext %s is not a dictionary";
    v13 = 262145;
    goto LABEL_8;
  }
  if (CFDictionaryGetCount(v10))
  {
    context[0] = a1;
    context[1] = Mutable;
    context[3] = 0;
    context[2] = 0;
    context[4] = 1;
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)__OSKextPersonalityPatcherApplierFunction, context);
  }
  return Mutable;
}

void __OSKextPersonalityPatcherApplierFunction(const __CFString *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFArray *v11;
  _QWORD *v12;
  __CFDictionary *v13;
  const void *v14;
  int v15;
  CFTypeID v16;
  CFTypeID v17;
  const __CFString *v18;
  const __CFAllocator *v19;
  CFMutableDictionaryRef MutableCopy;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFDictionary *v26;
  const __CFString *v27;
  const void *Value;
  const __CFString *v29;
  __CFDictionary *v30;
  char CStringPtr;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *UTF8CStringForCFString;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  const char *v48;
  UInt8 buffer[1024];
  uint64_t v50;
  CFRange v51;

  v50 = *MEMORY[0x1E0C80C00];
  v12 = *(_QWORD **)a3;
  v11 = *(__CFArray **)(a3 + 8);
  v13 = *(__CFDictionary **)(a3 + 16);
  v14 = *(const void **)(a3 + 24);
  v15 = *(unsigned __int8 *)(a3 + 32);
  v16 = CFGetTypeID(cf);
  if (v16 != CFDictionaryGetTypeID())
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    OSKextLog(0, 262145, "Kext personality %s subentry is not a dictionary", v32, v33, v34, v35, v36, CStringPtr);
    return;
  }
  if (!v14
    || (v17 = CFGetTypeID(v14), v17 != CFArrayGetTypeID())
    || (v51.length = CFArrayGetCount((CFArrayRef)v14), v51.location = 0,
                                                       CFArrayContainsValue((CFArrayRef)v14, v51, a1)))
  {
    v18 = (const __CFString *)v12[3];
    if (v18)
    {
      v19 = CFGetAllocator(v12);
      MutableCopy = CFDictionaryCreateMutableCopy(v19, 0, (CFDictionaryRef)cf);
      if (!MutableCopy)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v21, v22, v23, v24, v25, a9);
        return;
      }
      v26 = MutableCopy;
      if (!v15)
        goto LABEL_19;
      v27 = (const __CFString *)*MEMORY[0x1E0C9AE78];
      Value = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)*MEMORY[0x1E0C9AE78]);
      if (Value)
      {
        if (CFEqual(v18, Value))
          goto LABEL_15;
        v29 = CFSTR("IOPersonalityPublisher");
        v30 = v26;
      }
      else
      {
        v30 = v26;
        v29 = v27;
      }
      CFDictionarySetValue(v30, v29, v18);
LABEL_15:
      if (__OSKextShouldLog((uint64_t)v12, 38))
      {
        __OSKextGetFileSystemPath((uint64_t)v12, 0, 0, buffer, v37, v38, v39, v40);
        UTF8CStringForCFString = createUTF8CStringForCFString(v18);
        v47 = createUTF8CStringForCFString(a1);
        if (Value)
        {
          if (CFEqual(v18, Value))
            goto LABEL_22;
          v48 = "Adding IOBundlePublisher %s to %s personality %s.";
        }
        else
        {
          v48 = "Adding CFBundleIdentifier %s to %s personality %s.";
        }
        OSKextLog((uint64_t)v12, 38, v48, v42, v43, v44, v45, v46, (char)UTF8CStringForCFString);
LABEL_22:
        if (!__sOSKextPersonalityPatcherFunction || __sOSKextPersonalityPatcherFunction(v12, v26))
        {
          if (v11)
            CFArrayAppendValue(v11, v26);
          if (v13)
            CFDictionarySetValue(v13, a1, v26);
        }
        if (UTF8CStringForCFString)
          free(UTF8CStringForCFString);
        if (v47)
          free(v47);
        CFRelease(v26);
        return;
      }
LABEL_19:
      UTF8CStringForCFString = 0;
      v47 = 0;
      goto LABEL_22;
    }
  }
}

CFMutableArrayRef OSKextCopyPersonalitiesOfKexts(CFTypeRef cf)
{
  CFTypeRef AllKexts;
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFMutableArrayRef v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  CFURLRef *ValueAtIndex;
  const __CFDictionary *ValueForInfoDictionaryKey;
  const __CFDictionary *v15;
  CFTypeID v16;
  const __CFString *v17;
  char CStringPtr;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v25;
  CFURLRef *context;
  CFMutableArrayRef context_8;
  __int128 v28;
  uint64_t v29;

  AllKexts = cf;
  if (!cf)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    AllKexts = (CFTypeRef)OSKextGetAllKexts();
  }
  v2 = CFGetAllocator(AllKexts);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  v9 = Mutable;
  if (Mutable)
  {
    context = 0;
    v28 = 0u;
    v29 = 0;
    context_8 = Mutable;
    Count = CFArrayGetCount((CFArrayRef)AllKexts);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; i != v11; ++i)
      {
        ValueAtIndex = (CFURLRef *)CFArrayGetValueAtIndex((CFArrayRef)AllKexts, i);
        ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)ValueAtIndex, CFSTR("IOKitPersonalities"));
        if (ValueForInfoDictionaryKey)
        {
          v15 = ValueForInfoDictionaryKey;
          v16 = CFGetTypeID(ValueForInfoDictionaryKey);
          if (v16 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryGetCount(v15))
            {
              context = ValueAtIndex;
              context_8 = v9;
              v28 = 0uLL;
              LOBYTE(v29) = 1;
              CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)__OSKextPersonalityPatcherApplierFunction, &context);
            }
          }
          else
          {
            v17 = CFURLGetString(ValueAtIndex[2]);
            CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
            OSKextLog(0, 262145, "Kext personality for kext %s is not a dictionary", v19, v20, v21, v22, v23, CStringPtr);
          }
        }
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v25);
  }
  return v9;
}

void __OSKextDeallocateMmapBuffer(void *a1, size_t *a2)
{
  munmap(a1, *a2);
  free(a2);
}

CFDataRef __OSKextMapExecutable(uint64_t a1, off_t a2, off_t st_size)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFURL *ExecutableURL;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  const __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  const __CFAllocator *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  CFAllocatorRef v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const __CFAllocator *v60;
  const __CFAllocator *v61;
  CFDataRef v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  const __CFString *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char v88;
  char v89;
  char v90;
  CFAllocatorContext context;
  stat v92;
  UInt8 buffer[1024];
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (!__OSKextCreateLoadInfo(a1))
    return 0;
  if ((*(_BYTE *)(a1 + 92) & 8) != 0)
    return 0;
  ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((_QWORD *)a1, v6, v7, v8, v9, v10, v11, v12);
  if (!ExecutableURL)
    return 0;
  memset(&v92, 0, sizeof(v92));
  memset(&context, 0, sizeof(context));
  if (!__OSKextGetFileSystemPath(0, ExecutableURL, 1u, buffer, v14, v15, v16, v17))
    return 0;
  OSKextLog(a1, 131079, "Statting %s for map.", v18, v19, v20, v21, v22, (char)buffer);
  if (stat((const char *)buffer, &v92) == -1)
  {
    v31 = *__error();
    if (v31 == 2)
      v32 = CFSTR("File not found");
    else
      v32 = CFSTR("Failed to get file info (stat failed)");
    __OSKextAddDiagnostic(a1, 1, v32, *(const __CFString **)(a1 + 32), 0, v28, v29, v30, v88);
    strerror(v31);
    OSKextLog(a1, 131073, "Stat failed for %s - %s.", v33, v34, v35, v36, v37, (char)buffer);
    return 0;
  }
  if (st_size)
  {
    if (st_size + a2 > v92.st_size)
    {
      OSKextLog(a1, 131073, "Internal error; overrun mapping executable file %s.",
        v23,
        v24,
        v25,
        v26,
        v27,
        (char)buffer);
      return 0;
    }
  }
  else
  {
    st_size = v92.st_size;
  }
  OSKextLog(a1, 131079, "Opening %s for map.", v23, v24, v25, v26, v27, (char)buffer);
  v38 = open((const char *)buffer, 0);
  if (v38 == -1)
  {
    v66 = *__error();
    if (v66 == 2)
      v67 = CFSTR("File not found");
    else
      v67 = CFSTR("File access failure; can't open, or I/O error");
    __OSKextAddDiagnostic(a1, 1, v67, *(const __CFString **)(a1 + 32), 0, v63, v64, v65, v89);
    strerror(v66);
    OSKextLog(a1, 131073, "Open failed for %s - %s.", v68, v69, v70, v71, v72, (char)buffer);
    return 0;
  }
  v39 = v38;
  v45 = mmap(0, st_size, 3, 2, v38, a2);
  if (v45 == (void *)-1)
  {
    v77 = *__error();
    if (!st_size)
    {
      __OSKextAddDiagnostic(a1, 1, CFSTR("File access failure; can't open, or I/O error"),
        *(const __CFString **)(a1 + 32),
        0,
        v74,
        v75,
        v76,
        v89);
      *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
    }
    strerror(v77);
    OSKextLog(a1, 131073, "Failed to map executable file %s (offset %lu, %lu bytes) - %s.", v78, v79, v80, v81, v82, (char)buffer);
    goto LABEL_30;
  }
  OSKextLog(a1, 131078, "Mapped executable file %s (offset %lu, %lu bytes).", v40, v41, v42, v43, v44, (char)buffer);
  v46 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CFAllocatorGetContext((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
  v47 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (!v47)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v48, v49, v50, v51, v52, v90);
LABEL_30:
    close(v39);
    goto LABEL_33;
  }
  v53 = v47;
  *v47 = st_size;
  context.info = v47;
  context.deallocate = (CFAllocatorDeallocateCallBack)__OSKextDeallocateMmapBuffer;
  v54 = CFAllocatorCreate(v46, &context);
  if (!v54)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v55, v56, v57, v58, v59, v90);
    close(v39);
LABEL_32:
    free(v53);
LABEL_33:
    if (v45)
    {
      OSKextLog(a1, 131073, "Error encountered, unmapping executable file %s (offset %lu, %lu bytes).", v83, v84, v85, v86, v87, (char)buffer);
      munmap(v45, st_size);
    }
    return 0;
  }
  v60 = v54;
  v61 = CFGetAllocator((CFTypeRef)a1);
  v62 = CFDataCreateWithBytesNoCopy(v61, (const UInt8 *)v45, st_size, v60);
  CFRelease(v60);
  close(v39);
  if (!v62)
    goto LABEL_32;
  return v62;
}

uint64_t __OSKextCreateLoadInfo(uint64_t a1)
{
  uint64_t v1;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  if (*(_QWORD *)(a1 + 72))
    return 1;
  v3 = malloc_type_malloc(0xB0uLL, 0x107004062F0A6EBuLL);
  *(_QWORD *)(a1 + 72) = v3;
  if (v3)
  {
    v3[9] = 0u;
    v3[10] = 0u;
    v3[7] = 0u;
    v3[8] = 0u;
    v3[5] = 0u;
    v3[6] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v1 = 1;
    *v3 = 0u;
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v10);
    return 0;
  }
  return v1;
}

CFDataRef OSKextCopyResource(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDataRef v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFAllocator *v17;
  __CFBundle *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __CFBundle *v24;
  const __CFURL *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFURL *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFAllocator *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *UTF8CStringForCFString;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  SInt32 errorCode;
  CFDataRef resourceData;
  UInt8 v57[1024];
  UInt8 buffer[1024];
  uint64_t v59;

  v8 = 0;
  v59 = *MEMORY[0x1E0C80C00];
  resourceData = 0;
  if ((*(_BYTE *)(a1 + 88) & 8) == 0)
  {
    errorCode = 0;
    __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
    OSKextLog(a1, 131078, "Opening CFBundle for %s.", v12, v13, v14, v15, v16, (char)buffer);
    v17 = CFGetAllocator((CFTypeRef)a1);
    v18 = CFBundleCreate(v17, *(CFURLRef *)(a1 + 16));
    if (v18)
    {
      v24 = v18;
      v25 = CFBundleCopyResourceURL(v18, a2, a3, 0);
      if (v25)
      {
        v30 = v25;
        __OSKextGetFileSystemPath(0, v25, 0, v57, v26, v27, v28, v29);
        OSKextLog(a1, 131078, "Reading resource %s.", v31, v32, v33, v34, v35, (char)v57);
        v36 = CFGetAllocator((CFTypeRef)a1);
        if (CFURLCreateDataAndPropertiesFromResource(v36, v30, &resourceData, 0, 0, &errorCode))
        {
          v8 = resourceData;
        }
        else
        {
          OSKextLog(a1, 131076, "Couldn't read resource file %s.", v37, v38, v39, v40, v41, (char)v57);
          v8 = 0;
        }
        if (v8)
          v53 = 131079;
        else
          v53 = 131076;
        OSKextLog(a1, v53, "Reading resource file %s%s.", v37, v38, v39, v40, v41, (char)v57);
        CFRelease(v30);
      }
      else
      {
        UTF8CStringForCFString = createUTF8CStringForCFString(a2);
        OSKextLog(a1, 131076, "Couldn't read resource URL in %s for resource %s.", v43, v44, v45, v46, v47, (char)buffer);
        if (UTF8CStringForCFString)
          free(UTF8CStringForCFString);
        v8 = 0;
      }
      OSKextLog(a1, 131079, "Releasing CFBundle for %s.", v48, v49, v50, v51, v52, (char)buffer);
      CFRelease(v24);
    }
    else
    {
      OSKextLog(a1, 131076, "Couldn't open CFBundle for %s.", v19, v20, v21, v22, v23, (char)buffer);
      return 0;
    }
  }
  return v8;
}

uint64_t OSKextResolveDependencies(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFSet *Mutable;
  const __CFAllocator *v4;
  const __CFArray *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFArray *v11;
  BOOL v12;
  const __CFArray *v13;
  unsigned __int8 v14;
  uint64_t v16;
  int v17;
  const void *ValueForInfoDictionaryKey;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFIndex Count;
  CFIndex v26;
  CFIndex v27;
  const void *ValueAtIndex;
  const __CFString *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFString *v33;
  const __CFString *v34;
  int v35;
  const __CFString *v36;
  int v37;
  const __CFString *v38;
  int v39;
  CFIndex v40;
  CFTypeRef *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  BOOL v46;
  char v47;
  char v48;
  UInt8 context[1024];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFSetCreateMutable(v2, 0, MEMORY[0x1E0C9B3B0]);
  v4 = CFGetAllocator((CFTypeRef)a1);
  v5 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
  v11 = v5;
  if (Mutable)
    v12 = v5 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    if (a1)
    {
      if ((*(_BYTE *)(a1 + 92) & 1) != 0 || (v16 = *(_QWORD *)(a1 + 72)) != 0 && (*(_WORD *)(v16 + 168) & 0x10) != 0)
      {
        __OSKextGetFileSystemPath(a1, 0, 0, context, v7, v8, v9, v10);
        OSKextLog(a1, 16391, "%s - dependencies already resolved.", v20, v21, v22, v23, v24, (char)context);
        v13 = 0;
        v14 = 1;
        goto LABEL_29;
      }
      v17 = __OSKextResolveDependencies(a1, a1, Mutable, v5, v7, v8, v9, v10);
      v14 = v17;
      if (v17)
      {
        v13 = (const __CFArray *)__OSKextCopyDependenciesList(a1, 1, 0);
        if (!v13)
        {
          v14 = 0;
          goto LABEL_29;
        }
        ValueForInfoDictionaryKey = OSKextGetValueForInfoDictionaryKey(a1, CFSTR("OSBundleRequired"));
        if (ValueForInfoDictionaryKey)
        {
          v19 = ValueForInfoDictionaryKey;
          if (!CFEqual(ValueForInfoDictionaryKey, CFSTR("Root"))
            && !CFEqual(v19, CFSTR("Console"))
            && !CFEqual(v19, CFSTR("DriverKit")))
          {
            if (CFEqual(v19, CFSTR("Local-Root")))
            {
              v47 = 0;
              v48 = 1;
              v46 = 1;
            }
            else
            {
              v48 = 1;
              v46 = CFEqual(v19, CFSTR("Network-Root")) == 0;
              v47 = 1;
            }
LABEL_34:
            Count = CFArrayGetCount(v13);
            if (Count >= 1)
            {
              v26 = Count;
              v27 = 0;
              while (1)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v13, v27);
                v29 = (const __CFString *)OSKextGetValueForInfoDictionaryKey((uint64_t)ValueAtIndex, CFSTR("OSBundleRequired"));
                v33 = v29;
                v34 = (const __CFString *)*((_QWORD *)ValueAtIndex + 3);
                if ((v48 & 1) != 0)
                  goto LABEL_42;
                if (!v29)
                  break;
                v35 = CFEqual(CFSTR("Safe Boot"), v29);
                v36 = v33;
                if (v35)
                  goto LABEL_41;
LABEL_42:
                if ((v47 & 1) != 0)
                  goto LABEL_51;
                if (!v33)
                {
                  v38 = CFSTR("OSBundleRequired not set");
LABEL_50:
                  __OSKextAddDiagnostic(a1, 8, CFSTR("Dependency lacks appropriate value for OSBundleRequired and may not be available during early boot"), v34, v38, v30, v31, v32, v45);
                  goto LABEL_51;
                }
                if (!CFEqual(CFSTR("Root"), v33) && !CFEqual(CFSTR("Local-Root"), v33))
                {
                  v37 = CFEqual(CFSTR("Console"), v33);
                  v38 = v33;
                  if (!v37)
                    goto LABEL_50;
                }
                v39 = CFEqual(CFSTR("DriverKit"), v33);
                v38 = v33;
                if (v39)
                  goto LABEL_50;
LABEL_51:
                if (!v46)
                {
                  if (v33)
                  {
                    if ((CFEqual(CFSTR("Root"), v33)
                       || CFEqual(CFSTR("Network-Root"), v33)
                       || CFEqual(CFSTR("Console"), v33))
                      && !CFEqual(CFSTR("DriverKit"), v33))
                    {
                      goto LABEL_60;
                    }
                  }
                  else
                  {
                    v33 = CFSTR("OSBundleRequired not set");
                  }
                  __OSKextAddDiagnostic(a1, 8, CFSTR("Dependency lacks appropriate value for OSBundleRequired and may not be available during early boot"), v34, v33, v30, v31, v32, v45);
                }
LABEL_60:
                if (++v27 < v26)
                {
                  v40 = v27;
                  do
                  {
                    v41 = (CFTypeRef *)CFArrayGetValueAtIndex(v13, v40);
                    if (CFEqual(v34, v41[3]))
                    {
                      __OSKextAddDiagnostic(a1, 4, CFSTR("Multiple kexts for these libraries occur in the dependency graph"), v34, 0, v42, v43, v44, v45);
                      v14 = 0;
                    }
                    ++v40;
                  }
                  while (v26 != v40);
                }
                if (v27 == v26)
                  goto LABEL_7;
              }
              v36 = CFSTR("OSBundleRequired not set");
LABEL_41:
              __OSKextAddDiagnostic(a1, 8, CFSTR("Dependency lacks appropriate value for OSBundleRequired and may not be available during early boot"), v34, v36, v30, v31, v32, v45);
              goto LABEL_42;
            }
            goto LABEL_29;
          }
          v48 = 0;
        }
        else
        {
          v48 = 1;
        }
        v46 = 1;
        v47 = 1;
        goto LABEL_34;
      }
    }
    else
    {
      if (__sOSKextsByURL)
      {
        context[0] = 1;
        CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextResolveDependenciesApplierFunction, context);
      }
      v14 = 0;
    }
    v13 = 0;
    goto LABEL_29;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v45);
  v13 = 0;
  v14 = 0;
LABEL_7:
  if (!Mutable)
  {
    if (!v11)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_29:
  CFRelease(Mutable);
  if (v11)
LABEL_9:
    CFRelease(v11);
LABEL_10:
  if (v13)
    CFRelease(v13);
  return v14;
}

uint64_t __OSKextResolveDependencies(uint64_t a1, uint64_t a2, __CFSet *a3, const __CFArray *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _BOOL8 v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFAllocator *v39;
  CFMutableArrayRef Mutable;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const __CFDictionary *ValueForInfoDictionaryKey;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const __CFDictionary *v52;
  CFIndex v53;
  uint64_t v54;
  size_t v55;
  const void **v56;
  const void **v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const void **v63;
  uint64_t v64;
  void **v65;
  __CFString *v66;
  uint64_t v67;
  const __CFDictionary *UTF8CStringForCFString;
  unint64_t *LoadedKextWithIdentifier;
  unint64_t *v70;
  uint64_t v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const __CFString *v81;
  const __CFArray *CompatibleKextWithIdentifier;
  uint64_t v83;
  __int16 v84;
  const void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  const __CFString *v100;
  uint64_t v101;
  const __CFArray *KextWithIdentifier;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  CFIndex Count;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  CFIndex v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  CFIndex v130;
  CFIndex i;
  const __CFString *v132;
  CFIndex v133;
  CFIndex v134;
  CFIndex j;
  const void *ValueAtIndex;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  const __CFArray *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  const __CFArray *v147;
  const __CFArray *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  const __CFArray *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  const __CFArray *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  const __CFString *v168;
  __int16 v169;
  BOOL v170;
  int v171;
  char v172;
  char v173;
  char v174;
  char v175;
  CFTypeRef cf2;
  int v177;
  uint64_t v178;
  const __CFDictionary *v179;
  void **keys;
  const void **v181;
  const void **v182;
  char v183[20];
  char v184[20];
  UInt8 v185[1024];
  UInt8 buffer[1024];
  uint64_t v187;
  CFRange v188;

  v187 = *MEMORY[0x1E0C80C00];
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  if (!__OSKextReadInfoDictionary(a1, 0) || !*(_QWORD *)(a1 + 56))
  {
    OSKextLog(a1, 16385, "%s has no info dictionary; can't resolve dependencies.",
      v14,
      v15,
      v16,
      v17,
      v18,
      (char)buffer);
LABEL_10:
    CFSetAddValue(a3, (const void *)a1);
    return 0;
  }
  if (!__OSKextIsValid(a1, v12, v13, v14, v15, v16, v17, v18))
  {
    OSKextLog(a1, 16385, "%s is invalid; can't resolve dependencies.", v19, v20, v21, v22, v23, (char)buffer);
    goto LABEL_10;
  }
  v29 = CFSetContainsValue(a3, (const void *)a1);
  if (v29)
  {
    OSKextLog(a1, 16391, "%s already has dependencies resolved.", v24, v25, v26, v27, v28, (char)buffer);
    v30 = *(_QWORD *)(a1 + 72);
    if (!v30)
    {
      CFSetAddValue(a3, (const void *)a1);
      return 1;
    }
    v31 = 1;
    goto LABEL_7;
  }
  if ((*(_BYTE *)(a1 + 92) & 1) == 0)
    OSKextLog(a1, 16389, "Resolving dependencies for %s.", v24, v25, v26, v27, v28, (char)buffer);
  v188.length = CFArrayGetCount(a4);
  v188.location = 0;
  if (CFArrayGetCountOfValue(a4, v188, (const void *)a1))
  {
    __OSKextAddDiagnostic(a2, 4, CFSTR("Some dependencies are causing circular references"), *(const __CFString **)(a1 + 24), 0, v33, v34, v35, v172);
    __OSKextAddDiagnostic(a1, 4, CFSTR("Some dependencies are causing circular references"), *(const __CFString **)(a1 + 24), 0, v36, v37, v38, v173);
    goto LABEL_10;
  }
  CFArrayAppendValue(a4, (const void *)a1);
  OSKextFlushDependencies((_QWORD *)a1);
  if (!__OSKextCreateLoadInfo(a1))
    goto LABEL_68;
  v39 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFArrayCreateMutable(v39, 0, MEMORY[0x1E0C9B378]);
  **(_QWORD **)(a1 + 72) = Mutable;
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v41, v42, v43, v44, v45, v172);
LABEL_68:
    v31 = 0;
LABEL_69:
    CFSetAddValue(a3, (const void *)a1);
LABEL_70:
    Count = CFArrayGetCount(a4);
    CFArrayRemoveValueAtIndex(a4, Count - 1);
    return v31;
  }
  ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey(a1, CFSTR("OSBundleLibraries"));
  if ((*(_BYTE *)(a1 + 92) & 1) != 0)
  {
    if (a1 == a2)
      OSKextLog(a1, 0x4000, "%s is a kernel component with no dependencies.", v47, v48, v49, v50, v51, (char)buffer);
    v31 = 1;
    goto LABEL_119;
  }
  v52 = ValueForInfoDictionaryKey;
  if (ValueForInfoDictionaryKey)
  {
    v53 = CFDictionaryGetCount(ValueForInfoDictionaryKey);
    if (v53)
    {
      v54 = v53;
      v55 = 8 * v53;
      v56 = (const void **)malloc_type_malloc(8 * v53, 0x6004044C4A2DFuLL);
      v57 = (const void **)malloc_type_malloc(v55, 0x6004044C4A2DFuLL);
      v63 = v57;
      keys = (void **)v56;
      if (!v56 || !v57)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v58, v59, v60, v61, v62, v172);
        v31 = 0;
        v170 = 1;
        goto LABEL_114;
      }
      CFDictionaryGetKeysAndValues(v52, v56, v57);
      if (v54 >= 1)
      {
        v181 = v63;
        v177 = 0;
        v64 = 0;
        v52 = 0;
        cf2 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
        v65 = keys;
        v178 = v54;
        while (1)
        {
          v66 = (__CFString *)v65[v64];
          v67 = OSKextParseVersionCFString((const __CFString *)v181[v64]);
          if (v52)
            free(v52);
          UTF8CStringForCFString = (const __CFDictionary *)createUTF8CStringForCFString(v66);
          LoadedKextWithIdentifier = OSKextGetLoadedKextWithIdentifier(v66);
          v70 = LoadedKextWithIdentifier;
          if (LoadedKextWithIdentifier)
          {
            v71 = LoadedKextWithIdentifier[6];
            v72 = v71 >= 1 && v71 <= v67;
            if (!v72 || (uint64_t)LoadedKextWithIdentifier[5] < v67)
            {
              OSKextVersionGetString(v67, v184, 0x14u);
              OSKextVersionGetString(v70[5], v183, 0x14u);
              if ((uint64_t)v70[6] < 1)
              {
                v52 = UTF8CStringForCFString;
                OSKextLog(a1, 16385, "%s - loaded dependency %s lacks valid OSBundleCompatibleVersion.", v73, v74, v75, v76, v77, (char)buffer);
                v81 = CFSTR("Kexts already loaded for these libraries have no OSBundleCompatibleVersion");
              }
              else
              {
                v52 = UTF8CStringForCFString;
                OSKextLog(a1, 16385, "%s - loaded dependency %s, v%s is not compatible with requested version %s.", v73, v74, v75, v76, v77, (char)buffer);
                v81 = CFSTR("Kexts already loaded for these libraries are not compatible with the requested version");
              }
              v83 = a1;
              goto LABEL_41;
            }
            CompatibleKextWithIdentifier = (const __CFArray *)LoadedKextWithIdentifier;
          }
          else
          {
            CompatibleKextWithIdentifier = OSKextGetCompatibleKextWithIdentifier(v66, v67);
          }
          if (CFEqual(v66, CFSTR("com.apple.kernel")))
          {
            v84 = 1;
          }
          else if (CFStringHasPrefix(v66, CFSTR("com.apple.kernel.")))
          {
            v84 = 2;
          }
          else
          {
            if (!CFStringHasPrefix(v66, CFSTR("com.apple.kpi.")))
              goto LABEL_48;
            *(_WORD *)(*(_QWORD *)(a1 + 72) + 168) |= 4u;
            if (!CFEqual(v66, CFSTR("com.apple.kpi.private")))
              goto LABEL_48;
            v84 = 8;
          }
          *(_WORD *)(*(_QWORD *)(a1 + 72) + 168) |= v84;
LABEL_48:
          if (CompatibleKextWithIdentifier)
          {
            v85 = OSKextGetValueForInfoDictionaryKey((uint64_t)CompatibleKextWithIdentifier, CFSTR("OSBundleRequiredPromotion"));
            if (v85)
            {
              v90 = CFEqual(v85, cf2);
              __OSKextGetFileSystemPath((uint64_t)CompatibleKextWithIdentifier, 0, 0, v185, v91, v92, v93, v94);
              v52 = UTF8CStringForCFString;
              OSKextLog(a1, 16390, "%s found %s%s%sdependency %s for %s%s.", v95, v96, v97, v98, v99, (char)buffer);
              CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), CompatibleKextWithIdentifier);
              if (v90)
              {
                v100 = (const __CFString *)OSKextGetValueForInfoDictionaryKey(a1, CFSTR("OSBundleRequired"));
                v101 = v178;
                v65 = keys;
                if (!v100 || CFStringCompare(v100, CFSTR("Safe Boot"), 0) == kCFCompareEqualTo)
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), CFSTR("OSBundleRequired"), CFSTR("Console"));
                goto LABEL_64;
              }
            }
            else
            {
              __OSKextGetFileSystemPath((uint64_t)CompatibleKextWithIdentifier, 0, 0, v185, v86, v87, v88, v89);
              v52 = UTF8CStringForCFString;
              OSKextLog(a1, 16390, "%s found %s%s%sdependency %s for %s%s.", v108, v109, v110, v111, v112, (char)buffer);
              CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), CompatibleKextWithIdentifier);
            }
            goto LABEL_62;
          }
          KextWithIdentifier = OSKextGetKextWithIdentifier(v66);
          if (!KextWithIdentifier)
          {
            v52 = UTF8CStringForCFString;
            OSKextLog(a1, 16385, "%s - dependency '%s' not found.", v103, v104, v105, v106, v107, (char)buffer);
            __OSKextAddDiagnostic(a1, 4, CFSTR("No kexts found for these libraries"), v66, 0, v113, v114, v115, v175);
            v177 = 1;
LABEL_62:
            v65 = keys;
            goto LABEL_63;
          }
          v65 = keys;
          v52 = UTF8CStringForCFString;
          if (*((uint64_t *)KextWithIdentifier + 6) < 1)
          {
            OSKextLog(a1, 16385, "%s - dependency for %s lacks valid OSBundleCompatibleVersion.", v103, v104, v105, v106, v107, (char)buffer);
            v83 = a1;
            v81 = CFSTR("Kexts found for these libraries lack valid OSBundleCompatibleVersion");
          }
          else
          {
            OSKextLog(a1, 16385, "%s - no compatible dependency found for %s.", v103, v104, v105, v106, v107, (char)buffer);
            v83 = a1;
            v81 = CFSTR("Only incompatible kexts found for these libraries");
          }
LABEL_41:
          __OSKextAddDiagnostic(v83, 4, v81, v66, 0, v78, v79, v80, v174);
          v177 = 1;
LABEL_63:
          v101 = v178;
LABEL_64:
          if (v101 == ++v64)
          {
            v63 = v181;
            v171 = v177;
            goto LABEL_78;
          }
        }
      }
    }
    else
    {
      v63 = 0;
      keys = 0;
    }
    v52 = 0;
  }
  else
  {
    v63 = 0;
    keys = 0;
  }
  v171 = 0;
LABEL_78:
  if ((*(_WORD *)(*(_QWORD *)(a1 + 72) + 168) & 1) != 0)
  {
    __OSKextSetDiagnostic(a1, 4, CFSTR("Kexts may not link against com.apple.kernel; use either com.apple.kpi.* libraries (recommended), or com.apple.kernel.* (for compatiblity with older releases)."));
    v171 = 1;
  }
  v179 = v52;
  if ((*(_BYTE *)(a1 + 92) & 2) != 0 && CFArrayGetCount(**(CFArrayRef **)(a1 + 72)) != 1)
  {
    OSKextLog(a1, 16385, "%s - Interface kext must have exactly one dependency.", v117, v118, v119, v120, v121, (char)buffer);
    __OSKextSetDiagnostic(a1, 4, CFSTR("Interface kext must have exactly one dependency."));
    v171 = 1;
  }
  v182 = v63;
  v122 = CFArrayGetCount(**(CFArrayRef **)(a1 + 72));
  if (v122 >= 1)
  {
    v130 = v122;
    for (i = 0; i != v130; ++i)
    {
      v132 = (const __CFString *)*((_QWORD *)CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 72), i) + 3);
      if (!__OSKextResolveDependencies())
      {
        v133 = CFArrayGetCount(a4);
        if (v133 >= 1)
        {
          v134 = v133;
          for (j = 0; j != v134; ++j)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(a4, j);
            __OSKextAddDiagnostic((uint64_t)ValueAtIndex, 4, CFSTR("Indirect dependencies can't be resolved"), v132, 0, v137, v138, v139, v172);
          }
        }
        v171 = 1;
      }
    }
  }
  v140 = v171;
  v29 = 0;
  v63 = v182;
  if ((*(_BYTE *)(a1 + 92) & 4) != 0 && __OSKextHasSuffix(a1, v123, v124, v125, v126, v127, v128, v129))
  {
    v141 = OSKextGetKextWithIdentifier(CFSTR("com.apple.kpi.kasan"));
    if (v141)
    {
      v147 = v141;
      OSKextLog(a1, 16390, "%s adding implicit KASan dependency", v142, v143, v144, v145, v146, (char)buffer);
      CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), v147);
    }
    v148 = OSKextGetKextWithIdentifier(CFSTR("com.apple.kpi.kcov"));
    if (v148)
    {
      v154 = v148;
      OSKextLog(a1, 16390, "%s adding implicit Kcov dependency", v149, v150, v151, v152, v153, (char)buffer);
      CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), v154);
    }
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v160 = *(_DWORD *)(a1 + 92);
  if ((*((_BYTE *)__sOSKextArchInfo + 11) & 1) != 0)
  {
    if ((v160 & 4) == 0)
      goto LABEL_110;
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    if (!OSKextSupportsArchitecture(a1, __sOSKextArchInfo))
      goto LABEL_110;
    v169 = *(_WORD *)(*(_QWORD *)(a1 + 72) + 168);
    if ((v169 & 2) == 0)
    {
      if ((v169 & 4) != 0)
        goto LABEL_110;
      v168 = CFSTR("Kext declares no com.apple.kpi.* libraries; if it references any kernel symbols, it may fail to link.");
      goto LABEL_104;
    }
    __OSKextSetDiagnostic(a1, 4, CFSTR("64-bit kexts must use com.apple.kpi.* libraries, not com.apple.kernel* libraries."));
    v31 = 0;
    v170 = 1;
  }
  else
  {
    v161 = *(_QWORD *)(a1 + 72);
    if ((v160 & 4) == 0 || (*(_WORD *)(v161 + 168) & 6) != 0)
      goto LABEL_102;
    OSKextLog(a1, 16386, "%s does not declare a kernel dependency; using %s.",
      v155,
      v156,
      v157,
      v158,
      v159,
      (char)buffer);
    v162 = OSKextGetKextWithIdentifier(CFSTR("com.apple.kernel.6.0"));
    if (v162)
    {
      CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), v162);
      __OSKextSetDiagnostic(a1, 8, CFSTR("Kext declares no kernel/KPI libraries; if it references any kernel symbols, it may fail to link."));
      v161 = *(_QWORD *)(a1 + 72);
LABEL_102:
      if ((~*(unsigned __int16 *)(v161 + 168) & 6) != 0)
      {
LABEL_110:
        v170 = v140 != 0;
        v31 = v140 == 0;
        goto LABEL_111;
      }
      v168 = CFSTR("Kexts should declare dependencies on either com.apple.kernel* or com.apple.kpi.* libraries, not both.");
LABEL_104:
      __OSKextSetDiagnostic(a1, 8, v168);
      goto LABEL_110;
    }
    OSKextLog(a1, 16385, "%s - dependency '%s' not found.", v163, v164, v165, v166, v167, (char)buffer);
    v31 = 0;
    v170 = 1;
  }
LABEL_111:
  if (v179)
    free(v179);
LABEL_114:
  if (keys)
    free(keys);
  if (v63)
    free(v63);
  if (v170)
    goto LABEL_69;
LABEL_119:
  v30 = *(_QWORD *)(a1 + 72);
  if (!v30)
    goto LABEL_69;
LABEL_7:
  *(_WORD *)(v30 + 168) |= 0x10u;
  CFSetAddValue(a3, (const void *)a1);
  if (!v29)
    goto LABEL_70;
  return v31;
}

uint64_t __OSKextResolveDependenciesApplierFunction(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;

  result = OSKextResolveDependencies(a2);
  if (!(_DWORD)result)
    *a3 = 0;
  return result;
}

uint64_t __OSKextClearHasAllDependenciesOnKext(const void *a1)
{
  uint64_t result;
  uint64_t v3;
  CFIndex i;
  uint64_t v5;
  const __CFArray *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  UInt8 buffer[1024];
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  result = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  if (result >= 1)
  {
    v3 = result;
    for (i = 0; i != v3; ++i)
    {
      result = (uint64_t)CFArrayGetValueAtIndex((CFArrayRef)__sOSAllKexts, i);
      v5 = *(_QWORD *)(result + 72);
      if (v5)
      {
        v6 = *(const __CFArray **)v5;
        if (*(_QWORD *)v5)
        {
          v7 = result;
          if ((*(_BYTE *)(result + 92) & 1) != 0 || (*(_WORD *)(v5 + 168) & 0x10) != 0)
          {
            v19.length = CFArrayGetCount(v6);
            v19.location = 0;
            result = CFArrayContainsValue(v6, v19, a1);
            if ((_DWORD)result)
            {
              __OSKextGetFileSystemPath(v7, 0, 0, buffer, v8, v9, v10, v11);
              OSKextLog((uint64_t)a1, 262151, "Clearing \"has all dependencies\" for %s.", v12, v13, v14, v15, v16, (char)buffer);
              *(_WORD *)(*(_QWORD *)(v7 + 72) + 168) &= ~0x10u;
              result = __OSKextClearHasAllDependenciesOnKext(v7);
            }
          }
        }
      }
    }
  }
  return result;
}

void OSKextFlushDependencies(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  char v10;
  UInt8 buffer[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (a1)
  {
    if ((OSKextFlushDependencies_flushingAll & 1) == 0)
    {
      if (a1[2])
        __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, v3, v4, v5, v6);
      OSKextLog((uint64_t)a1, 262150, "Flushing dependencies for %s.", v2, v3, v4, v5, v6, (char)buffer);
    }
    v7 = a1[9];
    if (v7)
    {
      *(_WORD *)(v7 + 168) &= ~1u;
      *(_WORD *)(a1[9] + 168) &= ~2u;
      *(_WORD *)(a1[9] + 168) &= ~4u;
      v8 = *(const void **)a1[9];
      if (v8)
      {
        CFRelease(v8);
        v9 = a1[9];
        *(_QWORD *)v9 = 0;
        *(_WORD *)(v9 + 168) &= ~0x10u;
        *(_WORD *)(a1[9] + 168) &= ~0x20u;
        *(_WORD *)(a1[9] + 168) &= ~0x40u;
        __OSKextClearHasAllDependenciesOnKext(a1);
      }
      OSKextFlushDiagnostics((uint64_t)a1, 4);
    }
  }
  else if (__sOSKextsByURL)
  {
    OSKextFlushDependencies_flushingAll = 1;
    OSKextLog(0, 262150, "Flushing dependencies for all kexts.", v2, v3, v4, v5, v6, v10);
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushDependenciesApplierFunction, 0);
    OSKextFlushDependencies_flushingAll = 0;
  }
}

void OSKextFlushDiagnostics(uint64_t a1, int a2)
{
  CFTypeRef *v4;
  int context;

  pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (a1)
  {
    v4 = *(CFTypeRef **)(a1 + 64);
    if (!v4)
      return;
    if ((a2 & 1) != 0)
    {
      if (*v4)
      {
        CFRelease(*v4);
        v4 = *(CFTypeRef **)(a1 + 64);
      }
      *v4 = 0;
      if ((a2 & 2) == 0)
      {
LABEL_5:
        if ((a2 & 4) == 0)
          goto LABEL_6;
        goto LABEL_17;
      }
    }
    else if ((a2 & 2) == 0)
    {
      goto LABEL_5;
    }
    if (v4[1])
    {
      CFRelease(v4[1]);
      v4 = *(CFTypeRef **)(a1 + 64);
    }
    v4[1] = 0;
    if ((a2 & 4) == 0)
    {
LABEL_6:
      if ((a2 & 8) == 0)
        goto LABEL_7;
      goto LABEL_20;
    }
LABEL_17:
    if (v4[2])
    {
      CFRelease(v4[2]);
      v4 = *(CFTypeRef **)(a1 + 64);
    }
    v4[2] = 0;
    if ((a2 & 8) == 0)
    {
LABEL_7:
      if ((a2 & 0x10) == 0)
      {
LABEL_26:
        if ((~a2 & 0x1F) == 0)
        {
          free(v4);
          *(_QWORD *)(a1 + 64) = 0;
        }
        return;
      }
LABEL_23:
      if (v4[4])
      {
        CFRelease(v4[4]);
        v4 = *(CFTypeRef **)(a1 + 64);
      }
      v4[4] = 0;
      goto LABEL_26;
    }
LABEL_20:
    if (v4[3])
    {
      CFRelease(v4[3]);
      v4 = *(CFTypeRef **)(a1 + 64);
    }
    v4[3] = 0;
    if ((a2 & 0x10) == 0)
      goto LABEL_26;
    goto LABEL_23;
  }
  if (__sOSKextsByURL)
  {
    context = a2;
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushDiagnosticsApplierFunction, &context);
  }
}

uint64_t __OSKextFlushDependenciesApplierFunction(uint64_t a1, uint64_t a2)
{
  return OSKextFlushDependencies(a2);
}

uint64_t OSKextValidateDependencies(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  int v8;
  const __CFString **ValueAtIndex;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v22;

  v2 = *(_QWORD *)(a1 + 72);
  if (v2 && (*(_WORD *)(v2 + 168) & 0x20) != 0)
    return 1;
  v3 = (const __CFArray *)__OSKextCopyDependenciesList(a1, 1, 1);
  if (!v3)
    return 0;
  v4 = v3;
  Count = CFArrayGetCount(v3);
  if (Count >= 1)
  {
    v6 = Count;
    v7 = 0;
    v8 = 1;
    do
    {
      ValueAtIndex = (const __CFString **)CFArrayGetValueAtIndex(v4, v7);
      if (!__OSKextIsValid((uint64_t)ValueAtIndex, v10, v11, v12, v13, v14, v15, v16))
      {
        __OSKextAddDiagnostic(a1, 4, CFSTR("Dependencies have validation problems"), ValueAtIndex[3], 0, v17, v18, v19, v22);
        v8 = 0;
      }
      ++v7;
    }
    while (v6 != v7);
    if (!v8)
      goto LABEL_14;
  }
  if (__OSKextCreateLoadInfo(a1))
  {
    *(_WORD *)(*(_QWORD *)(a1 + 72) + 168) |= 0x20u;
    v20 = 1;
  }
  else
  {
LABEL_14:
    v20 = 0;
  }
  CFRelease(v4);
  return v20;
}

uint64_t OSKextAuthenticateDependencies(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  int v8;
  const __CFString **ValueAtIndex;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v27;

  v2 = *(_QWORD *)(a1 + 72);
  if (v2 && (*(_WORD *)(v2 + 168) & 0x40) != 0)
    return 1;
  v3 = (const __CFArray *)__OSKextCopyDependenciesList(a1, 1, 1);
  if (!v3)
    return 0;
  v4 = v3;
  Count = CFArrayGetCount(v3);
  if (Count < 1)
    goto LABEL_21;
  v6 = Count;
  v7 = 0;
  v8 = 1;
  do
  {
    ValueAtIndex = (const __CFString **)CFArrayGetValueAtIndex(v4, v7);
    if (!OSKextIsAuthentic((uint64_t)ValueAtIndex, v10, v11, v12, v13, v14, v15, v16))
    {
      __OSKextAddDiagnostic(a1, 4, CFSTR("Dependencies have incorrect owner/permissions"), ValueAtIndex[3], 0, v17, v18, v19, v27);
      v8 = 0;
    }
    ++v7;
  }
  while (v6 != v7);
  if (v8)
  {
LABEL_21:
    if (__OSKextCreateLoadInfo(a1))
      *(_WORD *)(*(_QWORD *)(a1 + 72) + 168) |= 0x40u;
    else
      OSKextLog(0, 17, "Memory allocation failure.", v20, v21, v22, v23, v24, v27);
    v25 = 1;
  }
  else
  {
    v25 = 0;
  }
  CFRelease(v4);
  return v25;
}

CFArrayRef OSKextCopyDeclaredDependencies(CFArrayRef **a1, int a2)
{
  int v4;
  CFArrayRef *v6;
  const __CFAllocator *v7;
  const __CFAllocator *v8;

  v4 = OSKextResolveDependencies((uint64_t)a1);
  if (a2 && !v4)
    return 0;
  v6 = a1[9];
  if (v6 && *v6)
  {
    v7 = CFGetAllocator(a1);
    return CFArrayCreateCopy(v7, *a1[9]);
  }
  else
  {
    v8 = CFGetAllocator(a1);
    return CFArrayCreate(v8, 0, 0, MEMORY[0x1E0C9B378]);
  }
}

BOOL __OSKextGetBleedthroughFlag(uint64_t a1)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  return (*((_BYTE *)__sOSKextArchInfo + 11) & 1) == 0 && (*(_WORD *)(*(_QWORD *)(a1 + 72) + 168) & 4) == 0;
}

CFMutableArrayRef OSKextCopyLinkDependencies(const void *a1, uint64_t a2)
{
  int v4;
  const __CFAllocator *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFMutableArrayRef Mutable;
  char v13;

  v4 = OSKextResolveDependencies((uint64_t)a1);
  if ((_DWORD)a2 && !v4)
    return 0;
  v5 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v13);
    return Mutable;
  }
  if (!__OSKextAddLinkDependencies((uint64_t)a1, Mutable, a2, 0))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t __OSKextAddLinkDependencies(uint64_t a1, const __CFArray *a2, uint64_t a3, int a4)
{
  const __CFArray **v6;
  const __CFArray *v7;
  _BOOL8 BleedthroughFlag;
  uint64_t result;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  _BYTE *ValueAtIndex;
  _BYTE *v15;
  CFRange v16;

  if ((*(_BYTE *)(a1 + 92) & 1) == 0)
  {
    v6 = *(const __CFArray ***)(a1 + 72);
    if (!v6)
      return (_DWORD)a3 == 0;
    v7 = *v6;
    if (!*v6)
      return (_DWORD)a3 == 0;
    if (a4)
    {
      BleedthroughFlag = 1;
    }
    else
    {
      BleedthroughFlag = __OSKextGetBleedthroughFlag(a1);
      v7 = **(const __CFArray ***)(a1 + 72);
    }
    Count = CFArrayGetCount(v7);
    if (Count >= 1)
    {
      v12 = Count;
      for (i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 72), i);
        v15 = ValueAtIndex;
        if (!BleedthroughFlag && (ValueAtIndex[92] & 4) != 0)
          goto LABEL_14;
        result = __OSKextAddLinkDependencies(ValueAtIndex, a2, a3, BleedthroughFlag);
        if (!(_DWORD)result)
          return result;
        if ((v15[92] & 4) != 0)
        {
LABEL_14:
          v16.length = CFArrayGetCount(a2);
          v16.location = 0;
          if (CFArrayGetFirstIndexOfValue(a2, v16, v15) == -1)
            CFArrayAppendValue(a2, v15);
        }
      }
    }
  }
  return 1;
}

__CFArray *OSKextCopySymbolReferences(const void *a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFDictionary *v10;
  const __CFAllocator *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFArray *v17;
  CFIndex Count;
  CFIndex v19;
  size_t v20;
  const void **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void **v27;
  char v29;
  CFRange v30;

  v2 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v10 = Mutable;
    if (__OSKextReadSymbolReferences((uint64_t)a1, Mutable, v4, v5, v6, v7, v8, v9))
    {
      v11 = CFGetAllocator(v10);
      v17 = CFArrayCreateMutable(v11, 0, MEMORY[0x1E0C9B378]);
      if (!v17)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v29);
        goto LABEL_11;
      }
      Count = CFDictionaryGetCount(v10);
      if (!Count)
      {
LABEL_11:
        CFRelease(v10);
        return v17;
      }
      v19 = Count;
      v20 = 8 * Count;
      v21 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (v21)
      {
        v27 = v21;
        bzero(v21, v20);
        CFDictionaryGetKeysAndValues(v10, v27, 0);
        v30.location = 0;
        v30.length = 0;
        CFArrayReplaceValues(v17, v30, v27, v19);
        free(v27);
        goto LABEL_11;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v22, v23, v24, v25, v26, v29);
      CFRelease(v17);
    }
    v17 = 0;
    goto LABEL_11;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v29);
  return 0;
}

uint64_t __OSKextReadSymbolReferences(uint64_t a1, __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFData *v10;
  const __CFData *v11;
  int *BytePtr;
  unint64_t v13;
  int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int *v34;
  CFStringRef v35;
  int v36;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  char *v44;
  unsigned int v45;
  const char *v46;
  size_t v47;
  CFStringRef v48;
  UInt8 *v49;
  void *value;
  unsigned int *v51;
  char v52;
  __CFDictionary *theDict;
  const __CFAllocator *alloc;
  char *v55;
  unint64_t v56;
  _DWORD *v57;
  UInt8 buffer[1024];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  if ((*(_DWORD *)(a1 + 92) & 5) != 4)
    return 1;
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v10 = OSKextCopyExecutableForArchitecture(a1, (uint64_t)__sOSKextArchInfo);
  if (!v10)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    OSKextLog(a1, 1048577, "%s has no executable for architecture %s.", v17, v18, v19, v20, v21, (char)buffer);
    return 0;
  }
  v11 = v10;
  BytePtr = (int *)CFDataGetBytePtr(v10);
  v13 = (unint64_t)BytePtr + CFDataGetLength(v11);
  v14 = *BytePtr;
  if (*BytePtr == -17958193 || v14 == -805638658)
  {
    v23 = 0;
    v22 = 16;
  }
  else
  {
    v22 = 12;
    v23 = 1;
  }
  if (macho_find_symtab(BytePtr, v13, &v57))
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v49 = buffer;
    v29 = "%s has no symtab in its executable (%s)";
LABEL_18:
    v35 = (CFStringRef)a1;
    v36 = 1048577;
    goto LABEL_19;
  }
  v30 = v57[2];
  v31 = (v14 + 822415874) & 0xFEFFFFFF;
  if (v31)
  {
    v32 = v57[3];
    v33 = v57[4];
  }
  else
  {
    v30 = bswap32(v30);
    v33 = bswap32(v57[4]);
    v32 = bswap32(v57[3]);
  }
  v34 = (unsigned int *)((char *)BytePtr + v30);
  if ((unint64_t)v34 + v32 * v22 > v13)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v49 = buffer;
    v29 = "%s: internal overrun in executable file (%s).";
    goto LABEL_18;
  }
  if (!v32)
  {
LABEL_42:
    v16 = 1;
    goto LABEL_20;
  }
  theDict = a2;
  v38 = 0;
  v55 = (char *)BytePtr + v33;
  v56 = v13;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  value = (void *)*MEMORY[0x1E0C9AE50];
  v51 = (unsigned int *)((char *)BytePtr + v30);
  v39 = v32;
  v40 = v51 + 1;
  v41 = v51;
  v52 = v23;
  while (1)
  {
    if ((v23 & 1) != 0)
    {
      v42 = bswap32(*((_DWORD *)v40 - 1));
      if (v31)
        v43 = *((_DWORD *)v40 - 1);
      else
        v43 = v42;
      v44 = v40;
      if (!v43)
        goto LABEL_41;
    }
    else
    {
      v45 = bswap32(*v41);
      if (v31)
        v43 = *v41;
      else
        v43 = v45;
      v44 = (char *)&v34[4 * v38 + 1];
      if (!v43)
        goto LABEL_41;
    }
    if ((*v44 & 0xEE) == 0)
      break;
LABEL_41:
    ++v38;
    v40 += 12;
    v41 += 4;
    if (!--v39)
      goto LABEL_42;
  }
  v46 = &v55[v43];
  if ((unint64_t)v46 >= v56)
    v47 = 0;
  else
    v47 = strnlen(&v55[v43], v56 - (_QWORD)v46);
  if ((unint64_t)&v46[v47] >= v56)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v49 = buffer;
    v29 = "%s: internal overrun (%p, string_index: %d, file_end: %p) in executable file (%s).";
    goto LABEL_18;
  }
  v35 = CFStringCreateWithCString(alloc, v46, 0x600u);
  if (v35)
  {
    v48 = v35;
    CFDictionarySetValue(theDict, v35, value);
    CFRelease(v48);
    v23 = v52;
    v34 = v51;
    goto LABEL_41;
  }
  v29 = "Memory allocation failure.";
  v36 = 17;
LABEL_19:
  OSKextLog((uint64_t)v35, v36, v29, v24, v25, v26, v27, v28, (char)v49);
  v16 = 0;
LABEL_20:
  CFRelease(v11);
  return v16;
}

CFTypeRef OSKextFindLinkDependencies(const void *a1, int a2, int a3, CFTypeRef *a4, CFTypeRef *a5, CFTypeRef *a6, CFTypeRef *a7)
{
  uint64_t AllKexts;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFArray *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFAllocator *v23;
  const CFArrayCallBacks *v24;
  const __CFArray *Mutable;
  const __CFAllocator *v26;
  const CFDictionaryKeyCallBacks *v27;
  const CFDictionaryValueCallBacks *v28;
  __CFDictionary *v29;
  const __CFAllocator *v30;
  CFMutableDictionaryRef v31;
  const __CFAllocator *v32;
  CFMutableDictionaryRef v33;
  const __CFAllocator *v34;
  CFMutableArrayRef v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFArray *v42;
  CFIndex Count;
  CFIndex v44;
  CFIndex v45;
  const void *ValueAtIndex;
  _DWORD *v47;
  const __CFString *v48;
  const __CFString *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const __CFData *v54;
  const __CFData *v55;
  int *BytePtr;
  CFIndex Length;
  int v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CFStringRef v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  char v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int *v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  CFStringRef v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  __CFArray *v93;
  void *v94;
  __CFArray *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  CFTypeRef v111;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  char v123;
  void *value;
  CFTypeRef *v125;
  CFTypeRef *v126;
  int v127;
  unsigned int *v128;
  unsigned int v129;
  char *v130;
  int theArray;
  __CFArray *theArraya;
  int key;
  CFStringRef keya;
  char v135;
  const __CFAllocator *alloc;
  const __CFData *cf;
  const __CFArray *v138;
  __CFDictionary *v139;
  const __CFDictionary *theDict;
  const __CFArray *v141;
  CFTypeRef *v142;
  CFTypeRef *v143;
  const __CFDictionary *v144;
  _DWORD *v147;
  UInt8 v148[1024];
  UInt8 buffer[1024];
  UInt8 v150[1024];
  uint64_t v151;
  CFRange v152;
  CFRange v153;
  CFRange v154;
  CFRange v155;

  v151 = *MEMORY[0x1E0C80C00];
  AllKexts = OSKextGetAllKexts();
  if (!AllKexts)
    return 0;
  v17 = (const __CFArray *)AllKexts;
  v142 = a4;
  v143 = a5;
  __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, v13, v14, v15, v16);
  OSKextLog((uint64_t)a1, 1064965, "Searching for link dependencies of %s.", v18, v19, v20, v21, v22, (char)buffer);
  v23 = CFGetAllocator(a1);
  v24 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Mutable = CFArrayCreateMutable(v23, 0, MEMORY[0x1E0C9B378]);
  v26 = CFGetAllocator(a1);
  v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v29 = CFDictionaryCreateMutable(v26, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v30 = CFGetAllocator(a1);
  v31 = CFDictionaryCreateMutable(v30, 0, v27, v28);
  v32 = CFGetAllocator(a1);
  v33 = CFDictionaryCreateMutable(v32, 0, v27, v28);
  v34 = CFGetAllocator(a1);
  v35 = CFArrayCreateMutable(v34, 0, v24);
  v42 = v35;
  if (!Mutable || !v29 || !v31 || !v33 || !v35)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v37, v38, v39, v40, v41, v123);
    v111 = 0;
    goto LABEL_85;
  }
  if (!__OSKextReadSymbolReferences((uint64_t)a1, v29, v36, v37, v38, v39, v40, v41))
  {
    v111 = 0;
    goto LABEL_109;
  }
  theDict = v33;
  v141 = v42;
  v139 = v29;
  Count = CFArrayGetCount(v17);
  v144 = v31;
  if (Count < 1)
    goto LABEL_95;
  v44 = Count;
  v45 = 0;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v17, v45);
    if (ValueAtIndex == a1)
      goto LABEL_74;
    v47 = ValueAtIndex;
    if (*((uint64_t *)ValueAtIndex + 6) < 1)
      goto LABEL_74;
    if ((*((_BYTE *)ValueAtIndex + 92) & 4) == 0)
      goto LABEL_74;
    v48 = (const __CFString *)*((_QWORD *)ValueAtIndex + 3);
    if (!a3
      && (CFEqual(v48, CFSTR("com.apple.kernel.unsupported"))
       || CFEqual(v48, CFSTR("com.apple.kpi.unsupported"))
       || CFEqual(v48, CFSTR("com.apple.kpi.private"))
       || CFEqual(v48, CFSTR("com.apple.kpi.dsep"))))
    {
      goto LABEL_74;
    }
    v49 = a2 ? CFSTR("com.apple.kpi.") : CFSTR("com.apple.kernel.");
    if (CFStringHasPrefix(v48, v49))
      goto LABEL_74;
    v147 = 0;
    __OSKextGetFileSystemPath((uint64_t)v47, 0, 0, v150, v50, v51, v52, v53);
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v54 = OSKextCopyExecutableForArchitecture((uint64_t)v47, (uint64_t)__sOSKextArchInfo);
    if (!v54)
      goto LABEL_74;
    v55 = v54;
    BytePtr = (int *)CFDataGetBytePtr(v54);
    cf = v55;
    Length = CFDataGetLength(v55);
    v58 = *BytePtr;
    v138 = Mutable;
    if (*BytePtr == -17958193 || v58 == -805638658)
    {
      v135 = 0;
      key = 16;
    }
    else
    {
      key = 12;
      v135 = 1;
    }
    v59 = (char *)BytePtr + Length;
    if (macho_find_symtab(BytePtr, (unint64_t)BytePtr + Length, &v147))
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      OSKextLog((uint64_t)v47, 1048577, "%s has no symtab in its executable (%s)", v60, v61, v62, v63, v64, (char)v150);
LABEL_30:
      Mutable = v138;
      v31 = v144;
      goto LABEL_73;
    }
    v65 = v147[2];
    v66 = (v58 + 822415874) & 0xFEFFFFFF;
    if (v66)
    {
      v68 = v147[3];
      v67 = v147[4];
    }
    else
    {
      v65 = bswap32(v65);
      v67 = bswap32(v147[4]);
      v68 = bswap32(v147[3]);
    }
    v69 = (unsigned int *)((char *)BytePtr + v65);
    v31 = v144;
    if ((char *)v69 + v68 * key > v59)
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      OSKextLog((uint64_t)v47, 1048577, "%s - internal overrun in executable file (%s).", v70, v71, v72, v73, v74, (char)v150);
      Mutable = v138;
LABEL_73:
      CFRelease(cf);
      goto LABEL_74;
    }
    Mutable = v138;
    if (!v68)
      goto LABEL_73;
    v125 = a6;
    v126 = a7;
    v75 = 0;
    theArray = 0;
    v76 = 0;
    v127 = 0;
    v130 = (char *)BytePtr + v67;
    v77 = v68;
    v78 = (uint64_t)BytePtr + v65 + 4;
    v79 = v69;
    v80 = v135;
    v129 = v66;
    v128 = v69;
    do
    {
      if ((v80 & 1) != 0)
      {
        v81 = bswap32(*(_DWORD *)(v78 - 4));
        if (v66)
          v82 = *(_DWORD *)(v78 - 4);
        else
          v82 = v81;
        v83 = (unsigned int *)v78;
        if (!v82)
          goto LABEL_61;
      }
      else
      {
        v84 = bswap32(*v79);
        if (v66)
          v82 = *v79;
        else
          v82 = v84;
        v83 = &v69[4 * v75 + 1];
        if (!v82)
        {
LABEL_61:
          v31 = v144;
          goto LABEL_62;
        }
      }
      v85 = *(unsigned __int8 *)v83;
      if (v85 > 0x1F)
        goto LABEL_61;
      v86 = v85 & 0xE;
      if (!v86)
        goto LABEL_52;
      if (v86 != 14)
      {
        if (v86 != 10)
          goto LABEL_61;
LABEL_52:
        if ((v47[23] & 1) == 0)
          goto LABEL_61;
        goto LABEL_53;
      }
      if ((v47[23] & 1) != 0)
        goto LABEL_61;
LABEL_53:
      if (v76)
        CFRelease(v76);
      v87 = CFStringCreateWithCString(alloc, &v130[v82], 0x600u);
      if (!v87)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v88, v89, v90, v91, v92, v123);
        a6 = v125;
        a7 = v126;
        goto LABEL_30;
      }
      keya = v87;
      v93 = (__CFArray *)CFDictionaryGetValue(theDict, v87);
      if (v93)
      {
        CFArrayAppendValue(v93, v47);
        theArray = 1;
      }
      else
      {
        v31 = v144;
        v94 = (void *)CFDictionaryGetValue(v144, keya);
        if (v94)
        {
          value = v94;
          v95 = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
          if (!v95)
          {
            OSKextLog(0, 17, "Memory allocation failure.", v96, v97, v98, v99, v100, v123);
            v101 = 1;
            v76 = keya;
            goto LABEL_77;
          }
          theArraya = v95;
          CFArrayAppendValue(v95, value);
          CFArrayAppendValue(theArraya, v47);
          CFDictionarySetValue(theDict, keya, theArraya);
          CFRelease(theArraya);
          if (!v127)
          {
            v152.length = CFArrayGetCount(v141);
            v152.location = 0;
            if (CFArrayGetFirstIndexOfValue(v141, v152, v47) == -1)
              CFArrayAppendValue(v141, v47);
          }
          CFDictionaryRemoveValue(v144, keya);
          v76 = keya;
          v127 = 1;
          theArray = 1;
          v80 = v135;
          v66 = v129;
          goto LABEL_70;
        }
        if (CFDictionaryGetValue(v139, keya))
        {
          CFDictionarySetValue(v144, keya, v47);
          v31 = v144;
          CFDictionaryRemoveValue(v139, keya);
          theArray = 1;
          goto LABEL_59;
        }
      }
      v31 = v144;
LABEL_59:
      v80 = v135;
      v66 = v129;
      v76 = keya;
LABEL_70:
      v69 = v128;
LABEL_62:
      ++v75;
      v78 += 12;
      v79 += 4;
      --v77;
    }
    while (v77);
    v101 = theArray;
    if (!v76)
      goto LABEL_78;
LABEL_77:
    CFRelease(v76);
LABEL_78:
    CFRelease(cf);
    a6 = v125;
    a7 = v126;
    Mutable = v138;
    if (v101)
    {
      __OSKextGetFileSystemPath((uint64_t)v47, 0, 0, v148, v102, v103, v104, v105);
      OSKextLog((uint64_t)a1, 1064966, "%s found link dependency %s.", v106, v107, v108, v109, v110, (char)buffer);
      v153.length = CFArrayGetCount(v138);
      v153.location = 0;
      if (CFArrayGetFirstIndexOfValue(v138, v153, v47) == -1)
        CFArrayAppendValue(v138, v47);
    }
LABEL_74:
    ++v45;
  }
  while (v45 != v44);
LABEL_95:
  v154.length = CFArrayGetCount(Mutable);
  v154.location = 0;
  CFArraySortValues(Mutable, v154, (CFComparatorFunction)__OSKextCompareIdentifiers, 0);
  v42 = v141;
  v155.length = CFArrayGetCount(v141);
  v155.location = 0;
  CFArraySortValues(v141, v155, (CFComparatorFunction)__OSKextCompareIdentifiers, 0);
  v111 = CFRetain(Mutable);
  if (v111)
  {
    v29 = v139;
    v33 = theDict;
    if (CFDictionaryGetCount(v139))
      OSKextLog((uint64_t)a1, 1064966, "%s has %d remaining undefined symbol%s", v113, v114, v115, v116, v117, (char)buffer);
    if (CFDictionaryGetCount(theDict))
      OSKextLog((uint64_t)a1, 1064966, "%s has multiply defined %ld symbol%s", v118, v119, v120, v121, v122, (char)buffer);
    if (v142)
      *v142 = CFRetain(v139);
    v31 = v144;
    if (v143)
      *v143 = CFRetain(v144);
    if (a6)
      *a6 = CFRetain(theDict);
    v42 = v141;
    if (a7)
      *a7 = CFRetain(v141);
  }
  else
  {
    v29 = v139;
    v33 = theDict;
  }
LABEL_85:
  if (!Mutable)
  {
    if (v29)
      goto LABEL_87;
    goto LABEL_88;
  }
LABEL_109:
  CFRelease(Mutable);
  if (v29)
LABEL_87:
    CFRelease(v29);
LABEL_88:
  if (v31)
    CFRelease(v31);
  if (v33)
    CFRelease(v33);
  if (v42)
    CFRelease(v42);
  return v111;
}

CFComparisonResult __OSKextCompareIdentifiers(uint64_t a1, uint64_t a2)
{
  return CFStringCompare(*(CFStringRef *)(a1 + 24), *(CFStringRef *)(a2 + 24), 0x201uLL);
}

CFMutableArrayRef __OSKextCopyDependenciesList(const void *a1, int a2, int a3)
{
  int v6;
  const __CFAllocator *v7;
  CFMutableArrayRef Mutable;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFMutableArrayRef v15;
  char v17;
  CFMutableArrayRef v18;
  int v19;
  int v20;
  uint64_t v21;

  v6 = OSKextResolveDependencies((uint64_t)a1);
  if (a2 && !v6)
    return 0;
  v7 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
  v15 = Mutable;
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v10, v11, v12, v13, v14, v17);
    return v15;
  }
  v18 = Mutable;
  v19 = a3;
  v20 = 0;
  v21 = 0;
  __OSKextAddDependenciesApplierFunction((uint64_t)a1, &v18, v9, v10, v11, v12, v13, v14);
  if ((_BYTE)v21)
  {
    CFRelease(v15);
    return 0;
  }
  return v15;
}

CFMutableArrayRef OSKextCopyIndirectDependencies(const void *a1, int a2)
{
  return __OSKextCopyDependenciesList(a1, a2, 2);
}

const __CFArray *OSKextDependsOnKext(uint64_t a1, const void *a2, int a3)
{
  const __CFArray **v6;
  const __CFArray *result;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;

  OSKextResolveDependencies(a1);
  v6 = *(const __CFArray ***)(a1 + 72);
  if (!v6)
    return 0;
  result = *v6;
  if (!*v6)
    return result;
  Count = CFArrayGetCount(result);
  if (Count < 1)
    return 0;
  v9 = Count;
  v10 = 0;
  while (CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 72), v10) != a2 && (a3 || !OSKextDependsOnKext()))
  {
    if (v9 == ++v10)
      return 0;
  }
  return (const __CFArray *)1;
}

__CFArray *OSKextCopyDependents(const void *a1, int a2)
{
  uint64_t AllKexts;
  const __CFArray *v5;
  const __CFAllocator *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v14;
  CFIndex i;
  const void *ValueAtIndex;
  char v18;

  AllKexts = OSKextGetAllKexts();
  if (!AllKexts)
    return 0;
  v5 = (const __CFArray *)AllKexts;
  OSKextResolveDependencies(0);
  v6 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      v14 = Count;
      for (i = 0; i != v14; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v5, i);
        if (OSKextDependsOnKext((uint64_t)ValueAtIndex, a1, a2))
          CFArrayAppendValue(Mutable, ValueAtIndex);
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v7, v8, v9, v10, v11, v18);
  }
  return Mutable;
}

void __OSKextLogDependencyGraphApplierFunction(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  CFStringRef PathComponent;
  void *UTF8CStringForCFString;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  CFMutableArrayRef v26;
  const __CFArray *v27;
  const __CFArray **v28;
  uint64_t context;
  char v30[20];
  uint64_t v31;
  CFRange v32;

  v31 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  context = *a2;
  if (!OSKextResolveDependencies(a1))
    return;
  if ((_DWORD)v10)
  {
    v11 = malloc_type_malloc((v10 + 1), 0x100004077774924uLL);
    if (!v11)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, a9);
      return;
    }
    v17 = v11;
    memset(v11, 32, v10);
    v17[v10] = 0;
  }
  else
  {
    v17 = 0;
  }
  if ((v10 & 0xFF00000000) != 0)
  {
    PathComponent = *(CFStringRef *)(a1 + 24);
    CFRetain(PathComponent);
  }
  else
  {
    PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a1 + 16));
  }
  UTF8CStringForCFString = createUTF8CStringForCFString(PathComponent);
  if (!UTF8CStringForCFString)
    goto LABEL_29;
  OSKextVersionGetString(*(_QWORD *)(a1 + 40), v30, 0x14u);
  v25 = "";
  if (v17)
    LOBYTE(v25) = (_BYTE)v17;
  OSKextLog(0, 0x4000, "%s%s (%s)%s", v20, v21, v22, v23, v24, (char)v25);
  LODWORD(context) = v10 + 4;
  if ((v10 & 0xFF0000000000) == 0)
  {
    v28 = *(const __CFArray ***)(a1 + 72);
    if (v28)
    {
      v26 = 0;
      v27 = *v28;
      if (!*v28)
        goto LABEL_20;
      goto LABEL_19;
    }
LABEL_29:
    v26 = 0;
    if (!v17)
      goto LABEL_22;
    goto LABEL_21;
  }
  v26 = OSKextCopyLinkDependencies((const void *)a1, 0);
  v27 = v26;
  if (v26)
  {
LABEL_19:
    v32.length = CFArrayGetCount(v27);
    v32.location = 0;
    CFArrayApplyFunction(v27, v32, (CFArrayApplierFunction)__OSKextLogDependencyGraphApplierFunction, &context);
  }
LABEL_20:
  if (v17)
LABEL_21:
    free(v17);
LABEL_22:
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  if (PathComponent)
    CFRelease(PathComponent);
  if (v26)
    CFRelease(v26);
}

void OSKextLogDependencyGraph(uint64_t a1, char a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;

  v11 = 0;
  BYTE4(v11) = a2;
  BYTE5(v11) = a3;
  OSKextResolveDependencies(a1);
  __OSKextLogDependencyGraphApplierFunction(a1, &v11, v4, v5, v6, v7, v8, v9, v10);
}

uint64_t OSKextLoad(uint64_t a1)
{
  return OSKextLoadWithOptions(a1, 0, 2, 0, 0);
}

uint64_t OSKextLoadWithOptions(uint64_t a1, char a2, char a3, const void *a4, int a5)
{
  __CFDictionary *Mutable;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;
  const __CFAllocator *v15;
  CFNumberRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFNumberRef v22;
  const __CFAllocator *v23;
  CFNumberRef v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFNumberRef v30;
  uint64_t LoadedKextInfo;
  host_priv_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  host_priv_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  __CFDictionary *v63;
  const char *v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  CFMutableArrayRef v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  const __CFArray *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t Count;
  const __CFAllocator *v84;
  CFMutableArrayRef v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  __CFArray *v91;
  CFIndex i;
  const void **ValueAtIndex;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const __CFData *v101;
  const __CFDictionary *Diagnostics;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const __CFArray *Value;
  const __CFArray *v109;
  __CFString *CFStringForPlist_new;
  __CFString *v111;
  vm_map_t *v112;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  CFMutableArrayRef v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  const __CFArray *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  const __CFAllocator *v132;
  const __CFData *Mkext;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  const __CFData *v139;
  const UInt8 *BytePtr;
  mach_msg_type_number_t Length;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint32_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _BOOL4 IsLoaded;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  UInt8 *op_result;
  char v162;
  char valuePtr;
  BOOL v164;
  mach_msg_type_number_t address[4];
  mach_msg_type_number_t size[4];
  kern_return_t v167;
  UInt8 buffer[1024];
  uint64_t v169;

  v169 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v162 = a3;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    LoadedKextInfo = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v9, v10, v11, v12, v13, (char)op_result);
    return LoadedKextInfo;
  }
  v14 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("CFBundleIdentifier"), *(const void **)(a1 + 24));
  v15 = CFGetAllocator((CFTypeRef)a1);
  v16 = CFNumberCreate(v15, kCFNumberSInt8Type, &valuePtr);
  if (!v16)
  {
    LoadedKextInfo = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, (char)op_result);
    v63 = v14;
LABEL_55:
    CFRelease(v63);
    return LoadedKextInfo;
  }
  v22 = v16;
  CFDictionarySetValue(v14, CFSTR("Start Exclude Level"), v16);
  v23 = CFGetAllocator((CFTypeRef)a1);
  v24 = CFNumberCreate(v23, kCFNumberSInt8Type, &v162);
  v30 = v24;
  if (!v24)
  {
    LoadedKextInfo = 3690987521;
    v64 = "Memory allocation failure.";
    v65 = 17;
    goto LABEL_52;
  }
  CFDictionarySetValue(v14, CFSTR("Start Matching Exclude Level"), v24);
  if (a4)
    CFDictionarySetValue(v14, CFSTR("Personality Names"), a4);
  if (a5)
    CFDictionarySetValue(v14, CFSTR("Delay Autounload"), (const void *)*MEMORY[0x1E0C9AE50]);
  LoadedKextInfo = 3690987521;
  v167 = -603979775;
  *(_QWORD *)&size[1] = 0;
  size[0] = 0;
  *(_QWORD *)&address[1] = 0;
  address[0] = 0;
  v32 = MEMORY[0x18D772924]();
  if (!v32)
  {
    OSKextLog(a1, 33, "Process must be running as root to load kexts.", v33, v34, v35, v36, v37, (char)op_result);
    LoadedKextInfo = 3691020292;
    goto LABEL_45;
  }
  v38 = v32;
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, v34, v35, v36, v37);
  if (!__OSKextIsValid(a1, v39, v40, v41, v42, v43, v44, v45))
  {
    OSKextLog(a1, 33, "Can't load %s - validation problems.", v46, v47, v48, v49, v50, (char)buffer);
    LoadedKextInfo = 3691020300;
    goto LABEL_45;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (!OSKextSupportsArchitecture(a1, __sOSKextArchInfo))
  {
    OSKextLog(a1, 33, "Can't load %s - no code for running kernel's architecture.", v51, v52, v53, v54, v55, (char)buffer);
    LoadedKextInfo = 3691020303;
    goto LABEL_45;
  }
  if (!(OSKextGetActualSafeBoot() | __sOSKextSimulatedSafeBoot)
    || (*(_BYTE *)(a1 + 92) & 0x80) != 0)
  {
    if (!OSKextIsAuthentic(a1, v56, v57, v58, v59, v60, v61, v62))
    {
      LoadedKextInfo = 3691020301;
      OSKextLog(a1, 33, "Can't load %s - authentication problems.", v66, v67, v68, v69, v70, (char)buffer);
      goto LABEL_45;
    }
    if (!__sOSKextLoadAuditFunction)
    {
      OSKextLog(a1, 33, "No load audit function set, cannot load %s", v66, v67, v68, v69, v70, (char)buffer);
      goto LABEL_45;
    }
    OSKextFlushLoadInfo(0, 1);
    v71 = __OSKextCopyDependenciesList((const void *)a1, 1, 0);
    if (!v71)
    {
      OSKextLog(a1, 33, "Can't load %s - failed to resolve dependencies.", v72, v73, v74, v75, v76, (char)buffer);
      LoadedKextInfo = 3691020302;
      goto LABEL_45;
    }
    v77 = v71;
    if (OSKextAuthenticateDependencies(a1))
    {
      if (OSKextDependenciesAreLoadableInSafeBoot((const void *)a1))
      {
        Count = CFArrayGetCount(v77);
        v84 = CFGetAllocator((CFTypeRef)a1);
        v85 = CFArrayCreateMutable(v84, Count, MEMORY[0x1E0C9B378]);
        if (v85)
        {
          v91 = v85;
          if (Count >= 1)
          {
            for (i = 0; i != Count; ++i)
            {
              ValueAtIndex = (const void **)CFArrayGetValueAtIndex(v77, i);
              CFArrayAppendValue(v91, ValueAtIndex[3]);
            }
          }
          CFRelease(v77);
          LoadedKextInfo = OSKextReadLoadedKextInfo(v91, 1);
          if (!(_DWORD)LoadedKextInfo)
          {
            if (!OSKextIsLoaded((unint64_t *)a1, v94, v95, v96, v97, v98, v99, v100)
              && ((v164 = 0,
                   IsLoaded = OSKextOtherVersionIsLoaded((unint64_t *)a1, &v164, v114, v115, v116, v117, v118, v119), v164)|| IsLoaded))
            {
              OSKextLog(a1, 33, "Can't load %s - a different %s is already loaded.", v156, v157, v158, v159, v160, (char)buffer);
              LoadedKextInfo = 3691020308;
            }
            else
            {
              v120 = __OSKextCopyDependenciesList((const void *)a1, 1, 0);
              if (v120)
              {
                v126 = v120;
                if (OSKextAuthenticateDependencies(a1))
                {
                  v132 = CFGetAllocator((CFTypeRef)a1);
                  Mkext = __OSKextCreateMkext(v132, v126, 0, 0, 0, 1, v14);
                  v139 = Mkext;
                  if (Mkext)
                  {
                    BytePtr = CFDataGetBytePtr(Mkext);
                    Length = CFDataGetLength(v139);
                    OSKextLog(a1, 36, "Loading %s.", v142, v143, v144, v145, v146, (char)buffer);
                    if (__sOSKextLogOutputFunction)
                      v147 = __sKernelLogFilter;
                    else
                      v147 = 0;
                    v148 = kext_request(v38, v147, (vm_offset_t)BytePtr, Length, (vm_offset_t *)&size[1], size, (vm_offset_t *)&address[1], address, &v167);
                    v149 = __OSKextProcessKextRequestResults(a1, v148, v167, *(char **)&address[1], address[0]);
                    LoadedKextInfo = v149;
                    if ((_DWORD)v149)
                    {
                      mach_error_string(v149);
                      OSKextLog(a1, 33, "Failed to load %s - %s.", v150, v151, v152, v153, v154, (char)buffer);
                    }
                  }
                  else
                  {
                    OSKextLog(a1, 33, "Can't create kernel load request for %s.", v134, v135, v136, v137, v138, (char)buffer);
                    LoadedKextInfo = 0;
                  }
                }
                else
                {
                  LoadedKextInfo = 3691020301;
                  OSKextLog(a1, 33, "Can't load %s - dependency authentication problems.", v127, v128, v129, v130, v131, (char)buffer);
                  v139 = 0;
                }
                CFRelease(v91);
                CFRelease(v126);
                if (!v139)
                  goto LABEL_45;
                v101 = v139;
                goto LABEL_44;
              }
              OSKextLog(a1, 33, "Can't load %s - failed to resolve dependencies based on loaded kexts.", v121, v122, v123, v124, v125, (char)buffer);
              LoadedKextInfo = 3691020302;
            }
          }
          v101 = v91;
LABEL_44:
          CFRelease(v101);
          goto LABEL_45;
        }
        OSKextLog(0, 17, "Memory allocation failure.", v86, v87, v88, v89, v90, (char)op_result);
      }
      else
      {
        Diagnostics = __OSKextGetDiagnostics(a1, 16);
        if (Diagnostics
          && (Value = (const __CFArray *)CFDictionaryGetValue(Diagnostics, CFSTR("Dependencies aren't loadable during safe boot"))) != 0&& (v109 = Value, CFArrayGetCount(Value))&& (CFStringForPlist_new = createCFStringForPlist_new(v109, 2)) != 0)
        {
          v111 = CFStringForPlist_new;
          OSKextLogCFString(a1, 33, CFSTR("Can't load %s - dependencies ineligible during safe boot:\n%@"), v103, v104, v105, v106, v107, (char)buffer);
          CFRelease(v111);
        }
        else
        {
          OSKextLogCFString(a1, 33, CFSTR("Can't load %s - dependencies ineligible during safe boot."), v103, v104, v105, v106, v107, (char)buffer);
        }
        LoadedKextInfo = 3691020306;
      }
    }
    else
    {
      LoadedKextInfo = 3691020301;
      OSKextLog(a1, 33, "Can't load %s - dependency authentication problems.", v78, v79, v80, v81, v82, (char)buffer);
    }
    v101 = v77;
    goto LABEL_44;
  }
  OSKextLog(a1, 33, "Can't load %s - ineligible during safe boot.", v58, v59, v60, v61, v62, (char)buffer);
  LoadedKextInfo = 3691020306;
LABEL_45:
  v112 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  if (*(_QWORD *)&size[1])
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], *(mach_vm_address_t *)&size[1], size[0]);
  if (*(_QWORD *)&address[1])
    mach_vm_deallocate(*v112, *(mach_vm_address_t *)&address[1], address[0]);
  if ((_DWORD)LoadedKextInfo)
  {
    __OSKextRemovePersonalities((const void *)a1, *(void **)(a1 + 24));
    goto LABEL_53;
  }
  op_result = buffer;
  v64 = "Successfully loaded %s.";
  v24 = (CFNumberRef)a1;
  v65 = 36;
LABEL_52:
  OSKextLog((uint64_t)v24, v65, v64, v25, v26, v27, v28, v29, (char)op_result);
LABEL_53:
  CFRelease(v14);
  CFRelease(v22);
  if (v30)
  {
    v63 = v30;
    goto LABEL_55;
  }
  return LoadedKextInfo;
}

uint64_t __OSKextUnload(uint64_t a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  void *UTF8CStringForCFString;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  __CFDictionary *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFMutableDictionaryRef theDict;
  UInt8 buffer[1024];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  theDict = 0;
  if (a1)
  {
    v10 = *(_QWORD *)(a1 + 24);
    UTF8CStringForCFString = buffer;
    __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
    v17 = 0;
  }
  else
  {
    v10 = (unint64_t)a2;
    UTF8CStringForCFString = createUTF8CStringForCFString(a2);
    v17 = UTF8CStringForCFString;
  }
  OSKextLog(a1, 100, "Requesting unload of %s%s.", v12, v13, v14, v15, v16, (char)UTF8CStringForCFString);
  v18 = __OSKextCreateKextRequest(CFSTR("Unload"), v10, &theDict);
  v19 = 3690987521;
  if (v18 && theDict)
  {
    if (a3)
      CFDictionarySetValue(theDict, CFSTR("Terminate IOServices"), (const void *)*MEMORY[0x1E0C9AE50]);
    v20 = __OSKextSendKextRequest(a1, v18, 0, 0, 0);
    v19 = v20;
    if ((_DWORD)v20)
    {
      mach_error_string(v20);
      OSKextLog(a1, 65, "Failed to unload %s - %s.", v26, v27, v28, v29, v30, (char)UTF8CStringForCFString);
    }
    else
    {
      OSKextLog(a1, 100, "Successfully unloaded %s.", v21, v22, v23, v24, v25, (char)UTF8CStringForCFString);
    }
  }
  if (v17)
    free(v17);
  if (v18)
    CFRelease(v18);
  return v19;
}

uint64_t OSKextUnload(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __OSKextUnload(a1, 0, a2, a4, a5, a6, a7, a8);
}

uint64_t OSKextUnloadKextWithIdentifier(const __CFString *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __OSKextUnload(0, a1, a2, a4, a5, a6, a7, a8);
}

uint64_t OSKextIsStarted(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;

  v8 = a1[9];
  if (!v8)
    return 0;
  if (*(_QWORD *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    v8 = a1[9];
  }
  return *(_BYTE *)(v8 + 169) & 1;
}

void __OSKextCheckLoaded(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  const __CFData *Value;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char **RunningKernelArchitecture;
  CFDataRef v19;
  const __CFData *v20;
  const unsigned __int8 *BytePtr;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const unsigned __int8 *v27;
  unint64_t v28;
  const void *v29;
  const __CFBoolean *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFNumber *v36;
  const __CFNumber *v37;
  const __CFNumber *v38;
  unint64_t valuePtr;
  UInt8 v40[20];
  UInt8 buffer[1024];
  char out[48];
  char v43[40];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  memset(v43, 0, 37);
  memset(out, 0, 37);
  v8 = a1[9];
  if (!v8)
    return;
  if (*(_QWORD *)(v8 + 8))
  {
    __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, a5, a6, a7, a8);
    Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), CFSTR("OSBundleUUID"));
    RunningKernelArchitecture = OSKextGetRunningKernelArchitecture((uint64_t)Value, v11, v12, v13, v14, v15, v16, v17);
    v19 = OSKextCopyUUIDForArchitecture(a1, RunningKernelArchitecture);
    v20 = v19;
    if (Value)
    {
      BytePtr = CFDataGetBytePtr(Value);
      uuid_unparse(BytePtr, out);
      if (!v20)
      {
        OSKextVersionGetString(a1[5], v40, 0x14u);
LABEL_10:
        *(_WORD *)(a1[9] + 168) |= 0x400u;
        OSKextLog((uint64_t)a1, 103, "%s (version %s%s%s): same version, different UUID (%s) is loaded.", v22, v23, v24, v25, v26, (char)buffer);
        goto LABEL_11;
      }
    }
    else if (!v19)
    {
      OSKextVersionGetString(a1[5], v40, 0x14u);
      goto LABEL_19;
    }
    v27 = CFDataGetBytePtr(v20);
    uuid_unparse(v27, v43);
    OSKextVersionGetString(a1[5], v40, 0x14u);
    if (!Value || !CFEqual(Value, v20))
      goto LABEL_10;
LABEL_19:
    *(_WORD *)(a1[9] + 168) |= 0x80u;
    OSKextLog((uint64_t)a1, 103, "%s (version %s%s%s) is loaded.", v22, v23, v24, v25, v26, (char)buffer);
    v30 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), CFSTR("OSBundleStarted"));
    if (v30 && CFBooleanGetValue(v30))
    {
      *(_WORD *)(a1[9] + 168) |= 0x100u;
      OSKextLog((uint64_t)a1, 103, "%s (version %s): is%s started.", v31, v32, v33, v34, v35, (char)buffer);
    }
    v36 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), CFSTR("OSBundleLoadTag"));
    if (v36)
    {
      LODWORD(valuePtr) = 0;
      if (CFNumberGetValue(v36, kCFNumberSInt32Type, &valuePtr))
        *(_DWORD *)(a1[9] + 16) = valuePtr;
    }
    v37 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), CFSTR("OSBundleLoadAddress"));
    if (v37)
    {
      valuePtr = 0;
      if (CFNumberGetValue(v37, kCFNumberSInt64Type, &valuePtr))
        __OSKextSetLoadAddress((uint64_t)a1, valuePtr);
    }
    v38 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), CFSTR("OSBundleLoadSize"));
    if (v38)
    {
      LODWORD(valuePtr) = 0;
      if (CFNumberGetValue(v38, kCFNumberSInt32Type, &valuePtr))
        *(_QWORD *)(a1[9] + 48) = valuePtr;
    }
    goto LABEL_11;
  }
  v20 = 0;
LABEL_11:
  v28 = a1[9];
  if (v28)
  {
    v29 = *(const void **)(v28 + 8);
    if (v29)
    {
      CFRelease(v29);
      v28 = a1[9];
    }
    *(_QWORD *)(v28 + 8) = 0;
  }
  if (v20)
    CFRelease(v20);
}

uint64_t OSKextStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  UInt8 buffer[1024];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 100, "Requesting start of %s.", v9, v10, v11, v12, v13, (char)buffer);
  v14 = __OSKextSimpleKextRequest(a1, CFSTR("Start"));
  v20 = v14;
  if ((_DWORD)v14)
  {
    mach_error_string(v14);
    OSKextLog(a1, 33, "Failed to start %s - %s.", v21, v22, v23, v24, v25, (char)buffer);
  }
  else
  {
    OSKextLog(a1, 100, "Started %s.", v15, v16, v17, v18, v19, (char)buffer);
  }
  return v20;
}

uint64_t __OSKextSimpleKextRequest(uint64_t a1, const void *a2)
{
  unint64_t v4;
  __CFDictionary *KextRequest;
  __CFDictionary *v6;
  uint64_t v7;

  if (a1)
    v4 = *(_QWORD *)(a1 + 24);
  else
    v4 = 0;
  KextRequest = __OSKextCreateKextRequest(a2, v4, 0);
  if (!KextRequest)
    return 3691020289;
  v6 = KextRequest;
  v7 = __OSKextSendKextRequest(a1, KextRequest, 0, 0, 0);
  CFRelease(v6);
  return v7;
}

uint64_t OSKextStop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  UInt8 buffer[1024];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 100, "Requesting stop of %s.", v9, v10, v11, v12, v13, (char)buffer);
  v14 = __OSKextSimpleKextRequest(a1, CFSTR("Stop"));
  v20 = v14;
  if ((_DWORD)v14)
  {
    mach_error_string(v14);
    OSKextLog(a1, 33, "Failed to stop %s - %s.", v21, v22, v23, v24, v25, (char)buffer);
  }
  else
  {
    OSKextLog(a1, 100, "Successfully stopped %s.", v15, v16, v17, v18, v19, (char)buffer);
  }
  return v20;
}

uint64_t OSKextSendPersonalitiesToKernel(const __CFArray *a1, int a2)
{
  uint64_t v2;
  uint32_t v3;
  char Count;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFData *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFData *v17;
  const char *BytePtr;
  uint32_t Length;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v26;

  v2 = 3691020293;
  if (a2)
    v3 = 9;
  else
    v3 = 1;
  if (a1)
  {
    if (CFArrayGetCount(a1))
    {
      Count = CFArrayGetCount(a1);
      CFArrayGetCount(a1);
      OSKextLog(0, 101, "Sending %d personalit%s to the kernel.", v6, v7, v8, v9, v10, Count);
      v11 = IOCFSerialize(a1, 0);
      if (v11)
      {
        v17 = v11;
        BytePtr = (const char *)CFDataGetBytePtr(v11);
        Length = CFDataGetLength(v17);
        v2 = IOCatalogueSendData(0, v3, BytePtr, Length);
        if ((_DWORD)v2)
          OSKextLog(0, 97, "Failed to send personalities to the kernel.", v20, v21, v22, v23, v24, v26);
        CFRelease(v17);
      }
      else
      {
        OSKextLog(0, 33, "Can't serialize personalities.", v12, v13, v14, v15, v16, v26);
        return 3691020296;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t OSKextSendKextPersonalitiesToKernel(CFURLRef *a1, const __CFArray *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *ValueForInfoDictionaryKey;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  const void *ValueAtIndex;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const __CFAllocator *v24;
  CFIndex Count;
  CFMutableArrayRef Mutable;
  const __CFArray *v27;
  const __CFArray *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  int v36;
  UInt8 *v38;
  CFURLRef *context;
  CFArrayRef theArray;
  uint64_t v41;
  const __CFArray *v42;
  uint64_t v43;
  UInt8 buffer[1024];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, a5, a6, a7, a8);
  if (!a2 || !CFArrayGetCount(a2))
  {
    v28 = OSKextCopyPersonalitiesArray(a1);
    v27 = v28;
    if (v28 && CFArrayGetCount(v28))
    {
      OSKextLog((uint64_t)a1, 37, "Sending all personalties for %s to the kernel.", v29, v30, v31, v32, v33, (char)buffer);
      goto LABEL_16;
    }
    OSKextLog((uint64_t)a1, 37, "%s has no personalities to send to kernel.", v29, v30, v31, v32, v33, (char)buffer);
    if (v27)
      goto LABEL_16;
    return 0;
  }
  v43 = 0;
  ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, CFSTR("IOKitPersonalities"));
  if (!ValueForInfoDictionaryKey && !CFDictionaryGetCount(0))
  {
    v38 = buffer;
    v35 = "%s has no personalities to send to kernel.";
    Mutable = (CFMutableArrayRef)a1;
    v36 = 37;
    goto LABEL_23;
  }
  if (CFArrayGetCount(a2) >= 1)
  {
    v16 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a2, v16);
      v18 = (char)ValueAtIndex;
      if (!CFDictionaryContainsKey(ValueForInfoDictionaryKey, ValueAtIndex))
        break;
      if (++v16 >= CFArrayGetCount(a2))
        goto LABEL_9;
    }
    OSKextLogCFString((uint64_t)a1, 33, CFSTR("Personality %@ not found in %s."), v19, v20, v21, v22, v23, v18);
    return 0;
  }
LABEL_9:
  v24 = CFGetAllocator(a1);
  Count = CFArrayGetCount(a2);
  Mutable = CFArrayCreateMutable(v24, Count, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v35 = "Memory allocation failure.";
    v36 = 17;
LABEL_23:
    OSKextLog((uint64_t)Mutable, v36, v35, v11, v12, v13, v14, v15, (char)v38);
    return 0;
  }
  OSKextLog((uint64_t)a1, 102, "Sending named personalities of %s to the kernel:", v11, v12, v13, v14, v15, (char)buffer);
  context = a1;
  theArray = 0;
  v41 = 0;
  v42 = a2;
  LOBYTE(v43) = 0;
  CFDictionaryApplyFunction(ValueForInfoDictionaryKey, (CFDictionaryApplierFunction)__OSKextPersonalityPatcherApplierFunction, &context);
  v27 = theArray;
  if (!theArray)
    return 0;
LABEL_16:
  if (CFArrayGetCount(v27))
    v34 = OSKextSendPersonalitiesToKernel(v27, 0);
  else
    v34 = 0;
  CFRelease(v27);
  return v34;
}

uint64_t OSKextSendPersonalitiesOfKextsToKernel(const __CFArray *a1, int a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  uint64_t v6;

  if (!CFArrayGetCount(a1))
    return 0;
  v4 = OSKextCopyPersonalitiesOfKexts(a1);
  if (!v4)
    return 0;
  v5 = v4;
  if (CFArrayGetCount(v4))
    v6 = OSKextSendPersonalitiesToKernel(v5, a2);
  else
    v6 = 0;
  CFRelease(v5);
  return v6;
}

uint64_t __OSKextRemovePersonalities(const void *a1, void *a2)
{
  const __CFAllocator *v3;
  CFDictionaryRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFDictionaryRef v10;
  const __CFData *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFData *v17;
  const char *BytePtr;
  uint32_t Length;
  mach_error_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v28;
  void *values;
  UInt8 buffer[1024];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  values = a2;
  v3 = CFGetAllocator(a1);
  v4 = CFDictionaryCreate(v3, MEMORY[0x1E0C9AE78], (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v4)
  {
    v10 = v4;
    __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, v6, v7, v8, v9);
    v11 = IOCFSerialize(v10, 0);
    if (v11)
    {
      v17 = v11;
      BytePtr = (const char *)CFDataGetBytePtr(v11);
      Length = CFDataGetLength(v17);
      v20 = IOCatalogueSendData(0, 3u, BytePtr, Length);
      if (v20)
      {
        v21 = 3690987521;
        mach_error_string(v20);
        OSKextLog((uint64_t)a1, 65, "Failed to remove personalities of %s from IOCatalogue - %s.", v22, v23, v24, v25, v26, (char)buffer);
      }
      else
      {
        v21 = 0;
      }
      CFRelease(v17);
    }
    else
    {
      v21 = 3690987521;
      OSKextLog((uint64_t)a1, 65, "Can't serialize personalities for %s.", v12, v13, v14, v15, v16, (char)buffer);
    }
    CFRelease(v10);
  }
  else
  {
    v21 = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v28);
  }
  return v21;
}

uint64_t OSKextRemoveKextPersonalitiesFromKernel(void **a1)
{
  return __OSKextRemovePersonalities(a1, a1[3]);
}

uint64_t OSKextRemovePersonalitiesForIdentifierFromKernel(void *a1)
{
  return __OSKextRemovePersonalities(0, a1);
}

uint64_t OSKextReadLoadedKextInfo(const __CFArray *a1, int a2)
{
  uint64_t v4;
  char **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CFArray *v19;
  const __CFArray *v20;
  CFIndex Count;
  CFIndex v22;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFDictionary *v42;
  const __CFDictionary *v43;
  char v45;

  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v4 = pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v5 = __sOSKextArchInfo;
  if (v5 != OSKextGetRunningKernelArchitecture(v4, v6, v7, v8, v9, v10, v11, v12))
  {
    OSKextLog(0, 97, "Can't read loaded kext info - current architecture %s != kernel's architecture %s.", v13, v14, v15, v16, v17, (char)*v5);
    return 3691020303;
  }
  v18 = 3690987521;
  if (!a1)
  {
    OSKextFlushLoadInfo(0, a2);
    v20 = 0;
LABEL_11:
    OSKextLog(0, 100, "Reading load info for all kexts.", v25, v26, v27, v28, v29, v45);
    goto LABEL_12;
  }
  v19 = OSKextCopyKextsWithIdentifiers(a1);
  if (!v19)
    return v18;
  v20 = v19;
  Count = CFArrayGetCount(v19);
  if (Count >= 1)
  {
    v22 = Count;
    for (i = 0; i != v22; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v20, i);
      OSKextFlushLoadInfo((uint64_t)ValueAtIndex, a2);
    }
  }
  if (!CFArrayGetCount(a1))
    goto LABEL_11;
  v30 = CFArrayGetCount(a1);
  OSKextLog(0, 100, "Reading load info for %u kext%s.", v31, v32, v33, v34, v35, v30);
LABEL_12:
  v42 = (const __CFDictionary *)OSKextCopyLoadedKextInfo((unint64_t)a1, (const void *)__sOSKextInfoEssentialKeys, v36, v37, v38, v39, v40, v41);
  v43 = v42;
  if (v42)
  {
    CFDictionaryApplyFunction(v42, (CFDictionaryApplierFunction)__OSKextProcessLoadInfo, 0);
    v18 = 0;
  }
  if (v20)
    CFRelease(v20);
  if (v43)
    CFRelease(v43);
  return v18;
}

uint64_t OSKextGetLoadAddress(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;

  v8 = a1[9];
  if (!v8)
    return 0;
  if (*(_QWORD *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    v8 = a1[9];
  }
  return *(_QWORD *)(v8 + 56);
}

uint64_t __OSKextSetLoadAddress(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  UInt8 buffer[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = __OSKextCreateLoadInfo(a1);
  if ((_DWORD)result)
  {
    __OSKextGetFileSystemPath(a1, 0, 1u, buffer, v5, v6, v7, v8);
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    if (!HIDWORD(a2) || ((_DWORD)__sOSKextArchInfo[1] & 0x1000000) != 0)
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      if ((*((_BYTE *)__sOSKextArchInfo + 11) & 1) != 0)
        OSKextLog(a1, 1048615, "setting load address of %s to 0x%0llx", v14, v15, v16, v17, v18, (char)buffer);
      else
        OSKextLog(a1, 1048615, "setting load address of %s to 0x%0x", v14, v15, v16, v17, v18, (char)buffer);
      *(_QWORD *)(*(_QWORD *)(a1 + 72) + 56) = a2;
      return 1;
    }
    else
    {
      OSKextLog(a1, 33, "Attempt to set 64-bit load address - %s.", v9, v10, v11, v12, v13, (char)buffer);
      return 0;
    }
  }
  return result;
}

uint64_t OSKextSetLoadAddress(unint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = __OSKextCreateLoadInfo((uint64_t)a1);
  if ((_DWORD)result)
  {
    if (*(_QWORD *)(a1[9] + 8))
      __OSKextCheckLoaded(a1, v5, v6, v7, v8, v9, v10, v11);
    return __OSKextSetLoadAddress((uint64_t)a1, a2);
  }
  return result;
}

BOOL OSKextOtherVersionIsLoaded(unint64_t *a1, BOOL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  __int16 v11;
  _BOOL8 result;

  v8 = a1[9];
  if (!v8)
    return 0;
  if (*(_QWORD *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    v8 = a1[9];
  }
  v11 = *(_WORD *)(v8 + 168);
  result = (v11 & 0x600) != 0;
  if (a2)
    *a2 = (v11 & 0x400) != 0;
  return result;
}

uint64_t OSKextGetLoadTag(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;

  v8 = a1[9];
  if (!v8)
    return 0;
  if (*(_QWORD *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    v8 = a1[9];
  }
  return *(unsigned int *)(v8 + 16);
}

uint64_t __OSKextFlushLoadInfoApplierFunction(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  return OSKextFlushLoadInfo(a2, *a3);
}

CFTypeRef _OSKextCopyKernelRequests(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *KextRequest;
  mach_error_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  CFTypeID TypeID;
  char v24;
  char v25;
  CFTypeRef cf;

  cf = 0;
  OSKextLog(0, 71, "Reading requests from kernel.", a4, a5, a6, a7, a8, v24);
  KextRequest = __OSKextCreateKextRequest(CFSTR("Get Kernel Requests"), 0, 0);
  v9 = __OSKextSendKextRequest(0, KextRequest, &cf, 0, 0);
  if (v9)
  {
    v15 = mach_error_string(v9);
    v21 = "(unknown)";
    if (v15)
      LOBYTE(v21) = (_BYTE)v15;
    OSKextLog(0, 65, "Failed to read requests from kernel - %s.", v16, v17, v18, v19, v20, (char)v21);
    if (cf)
      CFRelease(cf);
    cf = 0;
  }
  else
  {
    if (cf)
    {
      TypeID = CFArrayGetTypeID();
      if (TypeID == CFGetTypeID(cf))
        goto LABEL_12;
      if (cf)
        CFRelease(cf);
    }
    cf = 0;
    OSKextLog(0, 65, "Requests from kernel missing or of wrong type.", v10, v11, v12, v13, v14, v25);
  }
LABEL_12:
  if (KextRequest)
    CFRelease(KextRequest);
  return cf;
}

uint64_t _OSKextSendResource(const __CFDictionary *a1, int a2, const void *a3)
{
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  const __CFAllocator *v7;
  CFMutableDictionaryRef MutableCopy;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;
  CFMutableDictionaryRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFMutableDictionaryRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  uint64_t v24;
  char v26;
  int valuePtr;

  valuePtr = a2;
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("Kext Request Arguments"));
  if (!Value)
    return 3691020293;
  v6 = Value;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a1);
  if (MutableCopy)
  {
    v14 = MutableCopy;
    v15 = CFDictionaryCreateMutableCopy(v7, 0, v6);
    if (v15)
    {
      v21 = v15;
      CFDictionarySetValue(v14, CFSTR("Kext Request Predicate"), CFSTR("Send Resource"));
      CFDictionarySetValue(v14, CFSTR("Kext Request Arguments"), v21);
      if (a3)
        CFDictionarySetValue(v21, CFSTR("Value"), a3);
      v22 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
      if (v22)
      {
        v23 = v22;
        CFDictionarySetValue(v21, CFSTR("Kext Request Result Code"), v22);
        v24 = __OSKextSendKextRequest(0, v14, 0, 0, 0);
        CFRelease(v23);
      }
      else
      {
        v24 = __OSKextSendKextRequest(0, v14, 0, 0, 0);
      }
      CFRelease(v21);
    }
    else
    {
      v24 = 3690987521;
      OSKextLog(0, 17, "Memory allocation failure.", v16, v17, v18, v19, v20, v26);
    }
    CFRelease(v14);
  }
  else
  {
    v24 = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v9, v10, v11, v12, v13, v26);
  }
  return v24;
}

CFArrayRef OSKextCreateLoadedKextInfo(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFTypeID TypeID;
  CFIndex Count;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void **v18;
  CFArrayRef v19;
  char v21;

  v8 = (const __CFDictionary *)OSKextCopyLoadedKextInfo(a1, 0, a3, a4, a5, a6, a7, a8);
  if (v8)
  {
    v9 = v8;
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v9))
    {
      Count = CFDictionaryGetCount(v9);
      v12 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      if (v12)
      {
        v18 = v12;
        CFDictionaryGetKeysAndValues(v9, 0, v12);
        v19 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, Count, MEMORY[0x1E0C9B378]);
LABEL_8:
        CFRelease(v9);
        return v19;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v13, v14, v15, v16, v17, v21);
    }
    v19 = 0;
    goto LABEL_8;
  }
  return 0;
}

uint64_t OSKextValidate(uint64_t a1)
{
  __CFArray *Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFArray *v9;
  int v10;
  const __CFDictionary *v11;
  const __CFString *TypeID;
  int v13;
  BOOL v14;
  uint64_t v15;
  BOOL v16;
  CFIndex Count;
  char v19;
  _QWORD context[3];
  uint64_t v21;
  CFDictionaryRef theDict;

  theDict = 0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v9 = Mutable;
    v10 = __OSKextValidate(a1, Mutable, v3, v4, v5, v6, v7, v8);
    CFArrayAppendValue(v9, CFSTR("IOKitPersonalities"));
    v11 = *(const __CFDictionary **)(a1 + 56);
    TypeID = (const __CFString *)CFDictionaryGetTypeID();
    v13 = __OSKextCheckProperty(a1, v11, CFSTR("IOKitPersonalities"), (const __CFString *)v9, TypeID, 0, 0, 1, 0, (const __CFString **)&theDict, 0);
    if (v10)
      v14 = v13 == 0;
    else
      v14 = 1;
    v15 = !v14;
    if (v13)
      v16 = theDict == 0;
    else
      v16 = 1;
    if (!v16)
    {
      context[0] = a1;
      context[1] = theDict;
      context[2] = v9;
      v21 = 1;
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateIOKitPersonalityTargetApplierFunction, context);
      if ((_BYTE)v21)
        v15 = v15;
      else
        v15 = 0;
    }
    Count = CFArrayGetCount(v9);
    CFArrayRemoveValueAtIndex(v9, Count - 1);
    CFRelease(v9);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v19);
    return 1;
  }
  return v15;
}

uint64_t __OSKextValidate(uint64_t a1, __CFArray *Mutable, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __CFArray *v21;
  int v22;
  _BOOL4 v23;
  int v24;
  const __CFDictionary *v25;
  const __CFString *TypeID;
  int v27;
  CFIndex Count;
  const __CFDictionary *v29;
  const __CFString *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  int v38;
  CFIndex v39;
  const __CFDictionary *v40;
  const __CFString *v41;
  int v42;
  int v43;
  CFIndex v44;
  const __CFData *v45;
  const __CFData *v46;
  int *BytePtr;
  CFIndex Length;
  int v49;
  int v50;
  int v51;
  uint64_t result;
  int v53;
  const char *v54;
  char *v55;
  const void *v56;
  CFStringRef v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const __CFData *v63;
  uint64_t v64;
  char v65;
  char v66;
  char v67;
  uint64_t context;
  CFDictionaryRef v69;
  __CFArray *v70;
  uint64_t v71;
  char v72;
  CFDictionaryRef theDict;
  unsigned __int8 v74;
  UInt8 buffer[1024];
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  theDict = 0;
  v72 = 0;
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 4101, "Validating %s.", v10, v11, v12, v13, v14, (char)buffer);
  v21 = 0;
  *(_DWORD *)(a1 + 92) &= 0xFFFFF1FF;
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v21 = Mutable;
    if (!Mutable)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v16, v17, v18, v19, v20, v65);
      v50 = *(_DWORD *)(a1 + 92);
      goto LABEL_54;
    }
  }
  v22 = __OSKextProcessInfoDictionary(a1, 0, v15, v16, v17, v18, v19, v20);
  v23 = v22 != 0;
  if (*(_QWORD *)(a1 + 56))
  {
    v24 = v22;
    CFArrayAppendValue(Mutable, CFSTR("OSBundleAllowUserLoad"));
    v25 = *(const __CFDictionary **)(a1 + 56);
    TypeID = (const __CFString *)CFBooleanGetTypeID();
    v27 = __OSKextCheckProperty(a1, v25, CFSTR("OSBundleAllowUserLoad"), (const __CFString *)Mutable, TypeID, 0, 0, 1, 0, 0, 0);
    Count = CFArrayGetCount(Mutable);
    CFArrayRemoveValueAtIndex(Mutable, Count - 1);
    CFArrayAppendValue(Mutable, CFSTR("OSBundleLibraries"));
    v29 = *(const __CFDictionary **)(a1 + 56);
    v30 = (const __CFString *)CFDictionaryGetTypeID();
    v31 = __OSKextCheckProperty(a1, v29, CFSTR("OSBundleLibraries"), (const __CFString *)Mutable, v30, 0, (*(unsigned __int8 *)(a1 + 92) >> 2) & ~*(unsigned __int8 *)(a1 + 92) & 1, 1, (*(_BYTE *)(a1 + 92) & 5) == 4, (const __CFString **)&theDict, 0);
    v35 = v31;
    if (v24)
      v36 = v27 == 0;
    else
      v36 = 1;
    v38 = !v36 && v31 != 0;
    if (theDict && CFDictionaryGetCount(theDict))
    {
      if ((*(_BYTE *)(a1 + 92) & 1) != 0)
      {
        __OSKextAddDiagnostic(a1, 1, CFSTR("A system kext has a property set that it shouldn't"), CFSTR("OSBundleLibraries"), 0, v32, v33, v34, v66);
        v38 = 0;
        if (!v35)
          goto LABEL_29;
        goto LABEL_23;
      }
      if ((*(_BYTE *)(a1 + 92) & 4) == 0 && *(uint64_t *)(a1 + 48) <= 0)
      {
        __OSKextSetDiagnostic(a1, 8, CFSTR("Kext has no executable or compatible version, so it should not declare any OSBundleLibraries."));
        if (!v35)
          goto LABEL_29;
        goto LABEL_23;
      }
    }
    else if ((*(_DWORD *)(a1 + 92) & 5) == 4)
    {
      __OSKextAddDiagnostic(a1, 1, CFSTR("Info dictionary missing required property/value"), (const __CFString *)Mutable, 0, v32, v33, v34, v66);
    }
    if (!v35)
      goto LABEL_29;
LABEL_23:
    if (theDict)
    {
      context = a1;
      v69 = theDict;
      v70 = Mutable;
      v71 = 1;
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateOSBundleLibraryApplierFunction, &context);
      if (!(_BYTE)v71)
        v38 = 0;
      if (BYTE1(v71) && BYTE2(v71))
        __OSKextSetDiagnostic(a1, 8, CFSTR("Kexts should declare dependencies on either com.apple.kernel* or com.apple.kpi.* libraries, not both."));
    }
LABEL_29:
    theDict = 0;
    v39 = CFArrayGetCount(Mutable);
    CFArrayRemoveValueAtIndex(Mutable, v39 - 1);
    CFArrayAppendValue(Mutable, CFSTR("IOKitPersonalities"));
    v40 = *(const __CFDictionary **)(a1 + 56);
    v41 = (const __CFString *)CFDictionaryGetTypeID();
    v42 = __OSKextCheckProperty(a1, v40, CFSTR("IOKitPersonalities"), (const __CFString *)Mutable, v41, 0, 0, 1, 0, (const __CFString **)&theDict, &v72);
    if (v42)
      v43 = v38;
    else
      v43 = 0;
    if (v42)
    {
      if (theDict)
      {
        context = a1;
        v69 = theDict;
        v70 = Mutable;
        v71 = 1;
        CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateIOKitPersonalityApplierFunction, &context);
        if (!(_BYTE)v71)
          v43 = 0;
      }
    }
    v44 = CFArrayGetCount(Mutable);
    CFArrayRemoveValueAtIndex(Mutable, v44 - 1);
    context = 0;
    if ((*(_DWORD *)(a1 + 92) & 6) == 4)
    {
      if (!__OSKextReadExecutable(a1))
      {
        v49 = 0;
LABEL_48:
        if (v49)
          v23 = v43;
        else
          v23 = 0;
        goto LABEL_51;
      }
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      v45 = OSKextCopyExecutableForArchitecture(a1, (uint64_t)__sOSKextArchInfo);
      if (v45)
      {
        v46 = v45;
        v74 = 0;
        BytePtr = (int *)CFDataGetBytePtr(v45);
        Length = CFDataGetLength(v46);
        if (macho_find_symbol(BytePtr, (unint64_t)BytePtr + Length, "_kmod_info", &v74, &context)
          || (~v74 & 0xE) != 0
          || !context)
        {
          __OSKextSetDiagnostic(a1, 1, CFSTR("Executable file doesn't contain kernel extension code (no kmod_info symbol or bad Mach-O layout)."));
        }
        else
        {
          if ((*(_BYTE *)(a1 + 94) & 1) == 0)
          {
            v49 = 1;
            goto LABEL_42;
          }
          pthread_once(&__sOSKextInitialized, __OSKextInitialize);
          v53 = *((_DWORD *)__sOSKextArchInfo + 2);
          if ((v53 & 0x1000000) != 0)
            v54 = (const char *)(context + 16);
          else
            v54 = (const char *)(context + 12);
          if ((v53 & 0x1000000) != 0)
            v55 = (char *)(context + 80);
          else
            v55 = (char *)(context + 76);
          v56 = *(const void **)(a1 + 24);
          v57 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v54, 0x8000100u);
          if (v57)
          {
            v63 = (const __CFData *)v57;
            if (!CFEqual(v56, v57))
              __OSKextSetDiagnostic(a1, 8, CFSTR("Kexts with a kernel library < v6.0 must set MODULE_NAME the same as CFBundleIdentifier to load on kernel < v6.0."));
            v64 = OSKextParseVersionString(v55);
            if (v64 < 0 || *(_QWORD *)(a1 + 40) != v64)
              __OSKextSetDiagnostic(a1, 8, CFSTR("Kexts with a kernel library < v6.0 must set MODULE_VERSION the same as CFBundleVersion to load on kernel < v6.0."));
            CFRelease(v46);
            v49 = 1;
            v46 = v63;
            goto LABEL_42;
          }
          OSKextLog(0, 17, "Memory allocation failure.", v58, v59, v60, v61, v62, v67);
        }
        v49 = 0;
LABEL_42:
        CFRelease(v46);
        goto LABEL_48;
      }
    }
    v49 = 1;
    goto LABEL_48;
  }
LABEL_51:
  if (v21)
    CFRelease(v21);
  v50 = *(_DWORD *)(a1 + 92);
  if (!v23)
  {
    result = 0;
    v51 = v50 | 0x400;
    goto LABEL_56;
  }
LABEL_54:
  v51 = v50 | 0xA00;
  result = 1;
LABEL_56:
  *(_DWORD *)(a1 + 92) = v51;
  return result;
}

uint64_t __OSKextCheckProperty(uint64_t a1, CFDictionaryRef theDict, const __CFString *key, const __CFString *a4, const __CFString *a5, const __CFArray *a6, int a7, int a8, char a9, const __CFString **a10, _BYTE *a11)
{
  const __CFString *ValueForInfoDictionaryKey;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  CFTypeID TypeID;
  _BOOL4 v23;
  CFIndex Count;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFIndex v28;
  const void *ValueAtIndex;
  CFIndex v30;
  const void *v31;
  int Value;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFNumber *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  CFIndex Length;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  CFTypeID v49;
  int v50;
  const __CFString *v51;
  char v53;
  int valuePtr;

  if (a11)
    *a11 = 0;
  if (a10)
    *a10 = 0;
  if (*(CFDictionaryRef *)(a1 + 56) == theDict)
    ValueForInfoDictionaryKey = (const __CFString *)OSKextGetValueForInfoDictionaryKey(a1, key);
  else
    ValueForInfoDictionaryKey = (const __CFString *)CFDictionaryGetValue(theDict, key);
  v21 = ValueForInfoDictionaryKey;
  if (!ValueForInfoDictionaryKey)
  {
    if (!a7)
      return 1;
    __OSKextAddDiagnostic(a1, 1, CFSTR("Info dictionary missing required property/value"), a4, 0, v18, v19, v20, v53);
    return 0;
  }
  if (a10)
    *a10 = ValueForInfoDictionaryKey;
  TypeID = CFNumberGetTypeID();
  v23 = TypeID == CFGetTypeID(v21) && CFNumberIsFloatType((CFNumberRef)v21) != 0;
  if ((const __CFString *)CFGetTypeID(v21) != a5 || v23)
  {
    if ((const __CFString *)CFStringGetTypeID() == a5)
    {
      v40 = "<string>";
    }
    else if ((const __CFString *)CFNumberGetTypeID() == a5 && v23)
    {
      v40 = "<integer> (kexts may not use <real>)";
    }
    else if ((const __CFString *)CFNumberGetTypeID() == a5)
    {
      v40 = "<integer>";
    }
    else if ((const __CFString *)CFDataGetTypeID() == a5)
    {
      v40 = "<data>";
    }
    else if ((const __CFString *)CFBooleanGetTypeID() == a5)
    {
      v40 = "BOOLean, <true/> or <false/>";
    }
    else if ((const __CFString *)CFArrayGetTypeID() == a5)
    {
      v40 = "<array>";
    }
    else
    {
      v49 = CFDictionaryGetTypeID();
      v40 = "<dict>";
      if ((const __CFString *)v49 != a5)
        LOBYTE(v40) = 0;
    }
    if (a5)
    {
      v53 = (char)v40;
      a5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("should be %s"));
    }
    if (a8)
      v50 = 1;
    else
      v50 = 8;
    if (a8)
      v51 = CFSTR("Info dictionary property value is of illegal type");
    else
      v51 = CFSTR("Info dictionary property value is of incorrect type");
    __OSKextAddDiagnostic(a1, v50, v51, a4, a5, v37, v38, v39, v53);
    if (a5)
      CFRelease(a5);
    return 0;
  }
  if (!a6)
    goto LABEL_26;
  Count = CFArrayGetCount(a6);
  if (Count >= 1)
  {
    v28 = Count;
    ValueAtIndex = CFArrayGetValueAtIndex(a6, 0);
    if (CFEqual(ValueAtIndex, v21))
      goto LABEL_26;
    v30 = 1;
    while (v28 != v30)
    {
      v31 = CFArrayGetValueAtIndex(a6, v30++);
      if (CFEqual(v31, v21))
      {
        if (v30 - 1 < v28)
          goto LABEL_26;
        break;
      }
    }
  }
  __OSKextAddDiagnostic(a1, 1, CFSTR("Info dictionary property value is illegal"), a4, 0, v25, v26, v27, v53);
LABEL_26:
  if ((const __CFString *)CFBooleanGetTypeID() != a5)
  {
    if ((const __CFString *)CFStringGetTypeID() == a5)
    {
      Length = CFStringGetLength(v21);
    }
    else if ((const __CFString *)CFDataGetTypeID() == a5)
    {
      Length = CFDataGetLength((CFDataRef)v21);
    }
    else if ((const __CFString *)CFArrayGetTypeID() == a5)
    {
      Length = CFArrayGetCount((CFArrayRef)v21);
    }
    else
    {
      if ((const __CFString *)CFDictionaryGetTypeID() != a5)
      {
        if ((const __CFString *)CFNumberGetTypeID() != a5)
        {
          v36 = 0;
          Value = 0;
          goto LABEL_50;
        }
        valuePtr = 0;
        v36 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
        if (!v36)
          OSKextLog(0, 17, "Memory allocation failure.", v44, v45, v46, v47, v48, v53);
        Length = CFNumberCompare((CFNumberRef)v21, v36, 0);
        goto LABEL_49;
      }
      Length = CFDictionaryGetCount((CFDictionaryRef)v21);
    }
    v36 = 0;
LABEL_49:
    Value = Length != 0;
    goto LABEL_50;
  }
  Value = CFBooleanGetValue((CFBooleanRef)v21);
  v36 = 0;
LABEL_50:
  if (a11)
    *a11 = Value;
  v43 = 1;
  if (a9 && !Value)
  {
    __OSKextAddDiagnostic(a1, 1, CFSTR("Info dictionary property value is illegal"), a4, 0, v33, v34, v35, v53);
    v43 = 0;
  }
  if (v36)
    CFRelease(v36);
  return v43;
}

void __OSKextValidateIOKitPersonalityTargetApplierFunction(const __CFString *value, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const __CFString *v8;
  const __CFString *TypeID;
  const __CFString *v10;
  uint64_t v11;
  const __CFString *v12;
  const __CFString *v13;
  int v14;
  BOOL v15;
  char v16;
  const __CFArray *KextWithIdentifier;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFArray *v29;
  CFIndex Count;
  const __CFArray *v31;
  CFIndex v32;
  char v33;
  __CFString *v34;
  char v35;

  v35 = 0;
  v34 = 0;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), value);
  v6 = *(_QWORD *)a3;
  v7 = *(const __CFDictionary **)(a3 + 8);
  v8 = *(const __CFString **)(a3 + 16);
  TypeID = (const __CFString *)CFDictionaryGetTypeID();
  if (__OSKextCheckProperty(v6, v7, value, v8, TypeID, 0, 0, 1, 0, 0, 0))
  {
    v10 = (const __CFString *)*MEMORY[0x1E0C9AE78];
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), (const void *)*MEMORY[0x1E0C9AE78]);
    v11 = *(_QWORD *)a3;
    v12 = *(const __CFString **)(a3 + 16);
    v13 = (const __CFString *)CFStringGetTypeID();
    v14 = __OSKextCheckProperty(v11, a2, v10, v12, v13, 0, 0, 1, 1, (const __CFString **)&v34, &v35);
    if (*(_BYTE *)(a3 + 24))
      v15 = v14 == 0;
    else
      v15 = 1;
    v16 = !v15;
    *(_BYTE *)(a3 + 24) = v16;
    if (v34)
    {
      KextWithIdentifier = OSKextGetKextWithIdentifier(v34);
      if (KextWithIdentifier)
      {
        if (KextWithIdentifier != *(const __CFArray **)a3
          && !OSKextIsLoadable((uint64_t)KextWithIdentifier, v18, v19, v20, v21, v22, v23, v24))
        {
          v33 = (char)v34;
          v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("'%@' -> '%@'"));
          __OSKextAddDiagnostic(*(_QWORD *)a3, 8, CFSTR("Personality CFBundleIdentifier names a kext that is not loadable (run kextutil(8) on it with -nt for more information)"), v25, 0, v26, v27, v28, v33);
          if (v25)
            CFRelease(v25);
        }
      }
    }
    v29 = *(const __CFArray **)(a3 + 16);
    Count = CFArrayGetCount(v29);
    CFArrayRemoveValueAtIndex(v29, Count - 1);
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
  }
  v31 = *(const __CFArray **)(a3 + 16);
  v32 = CFArrayGetCount(v31);
  CFArrayRemoveValueAtIndex(v31, v32 - 1);
}

uint64_t _OSKextBasicFilesystemAuthentication(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFBundle *v9;
  __CFBundle *v10;
  const __CFURL *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFURL *v17;
  CFURLRef v18;
  uint64_t v19;
  const __CFURL *v20;
  char v22;

  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
  {
    v20 = **(const __CFURL ***)(a1 + 80);
    if (v20)
      return __OSKextBasicFilesystemAuthenticationRecursive((const void *)a1, v20, 0, a4, a5, a6, a7, a8);
    __OSKextSetDiagnostic(a1, 2, CFSTR("Kext was not created from an URL and can't be authenticated"));
  }
  else
  {
    v9 = CFBundleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFURLRef *)(a1 + 16));
    if (v9)
    {
      v10 = v9;
      v11 = CFBundleCopyBuiltInPlugInsURL(v9);
      v17 = v11;
      if (v11)
      {
        v18 = CFURLCopyAbsoluteURL(v11);
        if (!v18)
        {
          OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v22);
          CFRelease(v10);
          v19 = 0;
LABEL_12:
          CFRelease(v17);
LABEL_13:
          if (v18)
            CFRelease(v18);
          return v19;
        }
      }
      else
      {
        v18 = 0;
      }
      v19 = __OSKextBasicFilesystemAuthenticationRecursive((const void *)a1, *(const __CFURL **)(a1 + 16), v18, v12, v13, v14, v15, v16);
      CFRelease(v10);
      if (!v17)
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t __OSKextBasicFilesystemAuthenticationRecursive(const void *a1, const __CFURL *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef PathComponent;
  CFStringRef v12;
  const __CFArray *v13;
  char *v14;
  CFURLRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFString *v30;
  uint64_t v31;
  int v32;
  const char *v33;
  int v34;
  int *v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const __CFAllocator *v51;
  const __CFArray *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  CFIndex Count;
  CFIndex v59;
  CFIndex i;
  const void *ValueAtIndex;
  int v62;
  BOOL v63;
  int *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  UInt8 *v74;
  char v75;
  SInt32 errorCode;
  stat v77;
  stat v78;
  UInt8 buffer[1024];
  char __s[1024];
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  memset(&v78, 0, sizeof(v78));
  memset(&v77, 0, sizeof(v77));
  errorCode = 0;
  __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, (UInt8 *)__s, a5, a6, a7, a8);
  PathComponent = CFURLCopyLastPathComponent(a2);
  v12 = PathComponent;
  if (!PathComponent || !CFEqual(PathComponent, CFSTR(".DS_Store")))
  {
    v15 = CFURLCopyAbsoluteURL(a2);
    if (v15)
    {
      if (!__OSKextGetFileSystemPath(0, a2, 1u, buffer, v18, v19, v20, v21))
      {
        v30 = CFSTR("Internal error converting URL");
        v31 = (uint64_t)a1;
        v32 = 1;
        goto LABEL_12;
      }
      OSKextLog((uint64_t)a1, 139269, "Authenticating %s file/directory %s.", v22, v23, v24, v25, v26, (char)__s);
      if (!stat((const char *)buffer, &v78) && !lstat((const char *)buffer, &v77))
      {
        if (*(_QWORD *)&v78.st_uid || (v78.st_mode & 0x12) != 0)
        {
          __OSKextAddDiagnostic((uint64_t)a1, 2, CFSTR("File owner/permissions are incorrect (must be root:wheel, nonwritable by group/other)"), (const __CFString *)a2, 0, v27, v28, v29, (char)v74);
          v16 = 0;
        }
        else
        {
          v16 = 1;
        }
        if ((v77.st_mode & 0xF000) == 0xA000)
        {
          v14 = realpath_DARWIN_EXTSN((const char *)buffer, 0);
          if (!v14)
          {
            v64 = __error();
            v65 = strerror(*v64);
            __OSKextAddDiagnostic((uint64_t)a1, 2, CFSTR("The kext contains a symlink which is either not readable or points outside of its bundle; please remove"),
              (const __CFString *)a2,
              (const __CFString *)v65,
              v66,
              v67,
              v68,
              (char)v74);
            OSKextLog((uint64_t)a1, 131073, "Can't determine real path for %s (%s)", v69, v70, v71, v72, v73, (char)buffer);
            goto LABEL_16;
          }
          OSKextLog((uint64_t)a1, 131077, "Realpath for %s is %s", v37, v38, v39, v40, v41, (char)buffer);
          v42 = strlen(__s);
          if (strncmp(__s, v14, v42))
          {
            __OSKextAddDiagnostic((uint64_t)a1, 2, CFSTR("The kext contains a symlink which is either not readable or points outside of its bundle; please remove"),
              (const __CFString *)a2,
              (const __CFString *)"Symlink points outside of bundle.",
              v43,
              v44,
              v45,
              v75);
            OSKextLog((uint64_t)a1, 131073, "Kext contains symlink at %s which points outside of its bundle at %s; rejecting.",
              v46,
              v47,
              v48,
              v49,
              v50,
              (char)buffer);
            goto LABEL_16;
          }
          __OSKextAddDiagnostic((uint64_t)a1, 8, CFSTR("The booter does not recognize symbolic links; confirm these files/directories aren't needed for startup"),
            (const __CFString *)a2,
            0,
            v43,
            v44,
            v45,
            v75);
        }
        else
        {
          v14 = 0;
        }
        if (!CFURLHasDirectoryPath(a2) || a3 && CFEqual(v15, a3))
        {
          v13 = 0;
        }
        else
        {
          v51 = CFGetAllocator(a1);
          v52 = (const __CFArray *)CFURLCreatePropertyFromResource(v51, a2, (CFStringRef)*MEMORY[0x1E0C9B430], &errorCode);
          v13 = v52;
          if (!v52 || errorCode)
          {
            OSKextLog((uint64_t)a1, 139265, "Can't read file %s.", v53, v54, v55, v56, v57, (char)buffer);
          }
          else
          {
            Count = CFArrayGetCount(v52);
            if (Count >= 1)
            {
              v59 = Count;
              for (i = 0; i != v59; ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v13, i);
                v62 = __OSKextBasicFilesystemAuthenticationRecursive(a1, ValueAtIndex, a3);
                if ((_BYTE)v16)
                  v63 = v62 == 0;
                else
                  v63 = 1;
                v16 = !v63;
              }
            }
          }
        }
LABEL_17:
        if (!v12)
          goto LABEL_19;
        goto LABEL_18;
      }
      if (*__error() == 2)
      {
        v30 = CFSTR("File not found");
        v31 = (uint64_t)a1;
        v32 = 2;
LABEL_12:
        __OSKextAddDiagnostic(v31, v32, v30, (const __CFString *)a2, 0, v24, v25, v26, (char)v74);
LABEL_15:
        v14 = 0;
LABEL_16:
        v13 = 0;
        v16 = 0;
        goto LABEL_17;
      }
      v35 = __error();
      v74 = buffer;
      strerror(*v35);
      v33 = "Can't stat %s - %s.";
      v34 = 131073;
    }
    else
    {
      v33 = "Memory allocation failure.";
      v34 = 17;
    }
    OSKextLog(0, v34, v33, v17, v18, v19, v20, v21, (char)v74);
    goto LABEL_15;
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 1;
LABEL_18:
  CFRelease(v12);
LABEL_19:
  if (v15)
    CFRelease(v15);
  if (v13)
    CFRelease(v13);
  if (v14)
    free(v14);
  return v16;
}

uint64_t OSKextAuthenticate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v10;
  int v11;
  const char *v12;
  uint64_t v13;
  int v14;
  char v15;
  UInt8 buffer[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 92) &= 0xFFFF8EFF;
  if (!__sOSKextAuthenticationFunction)
  {
    v12 = "Trying to authenticate kext with no authentication function, failing.";
    v13 = 0;
    v14 = 4097;
LABEL_9:
    OSKextLog(v13, v14, v12, a4, a5, a6, a7, a8, v15);
    v10 = *(_DWORD *)(a1 + 92);
LABEL_10:
    result = 0;
    v11 = v10 | 0x3000;
    goto LABEL_11;
  }
  if (!__OSKextGetFileSystemPath(a1, 0, 1u, buffer, a5, a6, a7, a8))
  {
    v12 = "Could not get absolute path of kext!";
    v13 = a1;
    v14 = 262161;
    goto LABEL_9;
  }
  if (!rootless_check_trusted())
    *(_DWORD *)(a1 + 92) |= 0x100u;
  result = __sOSKextAuthenticationFunction(a1, __sOSKextAuthenticationContext);
  v10 = *(_DWORD *)(a1 + 92);
  if (!(_DWORD)result)
    goto LABEL_10;
  v11 = v10 | 0x5000;
LABEL_11:
  *(_DWORD *)(a1 + 92) = v11;
  return result;
}

uint64_t OSKextIsLoadable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (__OSKextIsValid(a1, a2, a3, a4, a5, a6, a7, a8)
    && OSKextIsAuthentic(a1, v9, v10, v11, v12, v13, v14, v15)
    && OSKextResolveDependencies(a1)
    && OSKextValidateDependencies(a1))
  {
    return OSKextAuthenticateDependencies(a1);
  }
  else
  {
    return 0;
  }
}

CFDictionaryRef OSKextCopyDiagnostics(_QWORD *a1, char a2)
{
  uint64_t v4;
  const __CFAllocator *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFDictionary *Mutable;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  char v23;

  v4 = a1[8];
  v5 = CFGetAllocator(a1);
  if (!v4)
    return CFDictionaryCreate(v5, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    if ((a2 & 1) != 0)
    {
      v12 = __OSKextCopyDiagnosticsDict(a1, 1);
      if (v12)
      {
        v13 = v12;
        if (CFDictionaryGetCount(v12))
          CFDictionarySetValue(Mutable, CFSTR("Validation Failures"), v13);
        CFRelease(v13);
      }
    }
    if ((a2 & 2) != 0)
    {
      v14 = __OSKextCopyDiagnosticsDict(a1, 2);
      if (v14)
      {
        v15 = v14;
        if (CFDictionaryGetCount(v14))
          CFDictionarySetValue(Mutable, CFSTR("Authentication Failures"), v15);
        CFRelease(v15);
      }
    }
    if ((a2 & 4) != 0)
    {
      v16 = __OSKextCopyDiagnosticsDict(a1, 4);
      if (v16)
      {
        v17 = v16;
        if (CFDictionaryGetCount(v16))
          CFDictionarySetValue(Mutable, CFSTR("Dependency Resolution Failures"), v17);
        CFRelease(v17);
      }
    }
    if ((a2 & 8) != 0)
    {
      v18 = __OSKextCopyDiagnosticsDict(a1, 8);
      if (v18)
      {
        v19 = v18;
        if (CFDictionaryGetCount(v18))
          CFDictionarySetValue(Mutable, CFSTR("Warnings"), v19);
        CFRelease(v19);
      }
    }
    if ((a2 & 0x10) != 0)
    {
      v20 = __OSKextCopyDiagnosticsDict(a1, 16);
      if (v20)
      {
        v21 = v20;
        if (CFDictionaryGetCount(v20))
          CFDictionarySetValue(Mutable, CFSTR("Boot Level Restrictions"), v21);
        CFRelease(v21);
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v23);
  }
  return Mutable;
}

CFDictionaryRef __OSKextCopyDiagnosticsDict(_QWORD *cf, int a2)
{
  const __CFDictionary **v3;
  const __CFDictionary *v4;
  const __CFAllocator *v5;
  CFDictionaryRef result;
  const __CFAllocator *v7;

  v3 = (const __CFDictionary **)cf[8];
  if (!v3)
    goto LABEL_10;
  switch(a2)
  {
    case 1:
      break;
    case 2:
      ++v3;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_10;
    case 4:
      v3 += 2;
      break;
    case 8:
      v3 += 3;
      break;
    default:
      if (a2 != 16)
        goto LABEL_10;
      v3 += 4;
      break;
  }
  v4 = *v3;
  if (!*v3 || (v5 = CFGetAllocator(cf), (result = CFDictionaryCreateCopy(v5, v4)) == 0))
  {
LABEL_10:
    v7 = CFGetAllocator(cf);
    return CFDictionaryCreate(v7, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  return result;
}

void OSKextLogDiagnostics(_QWORD *a1, char a2)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  __CFString *CFStringForPlist_new;
  __CFString *v5;
  void *UTF8CStringForCFString;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const void *v13;

  v2 = OSKextCopyDiagnostics(a1, a2);
  if (v2)
  {
    v3 = v2;
    if (CFDictionaryGetCount(v2) && (CFStringForPlist_new = createCFStringForPlist_new(v3, 2)) != 0)
    {
      v5 = CFStringForPlist_new;
      UTF8CStringForCFString = createUTF8CStringForCFString(CFStringForPlist_new);
      if (UTF8CStringForCFString)
      {
        v12 = UTF8CStringForCFString;
        OSKextLog(0, 16, "%s", v7, v8, v9, v10, v11, (char)UTF8CStringForCFString);
        CFRelease(v3);
        CFRelease(v5);
        free(v12);
        return;
      }
      CFRelease(v3);
      v13 = v5;
    }
    else
    {
      v13 = v3;
    }
    CFRelease(v13);
  }
}

uint64_t __OSKextFlushDiagnosticsApplierFunction(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return OSKextFlushDiagnostics(a2, *a3);
}

BOOL OSKextMatchesRequiredFlags(uint64_t a1, int a2)
{
  const void *ValueForInfoDictionaryKey;
  const void *v4;

  ValueForInfoDictionaryKey = OSKextGetValueForInfoDictionaryKey(a1, CFSTR("OSBundleRequired"));
  v4 = ValueForInfoDictionaryKey;
  return (a2 & 1) != 0 && ValueForInfoDictionaryKey && CFEqual(ValueForInfoDictionaryKey, CFSTR("Root"))
      || (a2 & 2) != 0 && v4 && CFEqual(v4, CFSTR("Local-Root"))
      || (a2 & 4) != 0 && v4 && CFEqual(v4, CFSTR("Network-Root"))
      || (a2 & 0x10) != 0 && v4 && CFEqual(v4, CFSTR("Console"))
      || (a2 & 0x20) != 0 && v4 && CFEqual(v4, CFSTR("DriverKit"))
      || (a2 & 8) != 0 && v4 && CFEqual(v4, CFSTR("Safe Boot"))
      || a2 == 0;
}

__CFArray *OSKextFilterRequiredKexts(const __CFArray *a1, int a2)
{
  const __CFArray *AllKexts;
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const void *ValueAtIndex;
  char v16;

  AllKexts = a1;
  v4 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    if (!AllKexts)
      AllKexts = (const __CFArray *)OSKextGetAllKexts();
    Count = CFArrayGetCount(AllKexts);
    if (Count >= 1)
    {
      v12 = Count;
      for (i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(AllKexts, i);
        if (OSKextMatchesRequiredFlags((uint64_t)ValueAtIndex, a2))
          CFArrayAppendValue(Mutable, ValueAtIndex);
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v16);
  }
  return Mutable;
}

uint64_t mkext_adler32(unsigned __int8 *a1, int a2)
{
  unsigned int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  int v10;

  if (a2 < 1)
    return 1;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 1;
  v6 = a2;
  do
  {
    v7 = v3 + 5000 * (v2 / 0x1388);
    v8 = v7 == 0;
    if (!v7)
      v5 %= 0xFFF1u;
    v10 = *a1++;
    v9 = v10;
    if (v8)
      v4 %= 0xFFF1u;
    v5 += v9;
    v4 += v5;
    --v3;
    ++v2;
    --v6;
  }
  while (v6);
  return (v5 % 0xFFF1) | ((v4 % 0xFFF1) << 16);
}

const __CFData *OSKextCreateMkext(const __CFAllocator *a1, const __CFArray *a2, const __CFURL *a3, int a4, int a5)
{
  return __OSKextCreateMkext(a1, a2, a3, a4, a5, 0, 0);
}

const __CFData *__OSKextCreateMkext(const __CFAllocator *a1, const __CFArray *AllKexts, const __CFURL *a3, int a4, int a5, int a6, const void *a7)
{
  CFIndex Count;
  uint64_t v15;
  CFMutableDataRef Mutable;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFMutableDataRef v22;
  CFMutableDictionaryRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __CFDictionary *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  CFIndex v41;
  unint64_t *ValueAtIndex;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  CFIndex v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CFMutableDictionaryRef v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __CFDictionary *v84;
  const __CFDictionary *ValueForInfoDictionaryKey;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  __CFDictionary *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const __CFData *v96;
  const __CFAllocator *v97;
  CFNumberRef v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  CFNumberRef v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  const char *v112;
  const UInt8 *v113;
  const UInt8 *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const char *v120;
  const __CFAllocator *v121;
  size_t v122;
  CFStringRef v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  __CFString *v129;
  CFStringRef v130;
  __CFDictionary *v131;
  char v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  UInt8 *v138;
  const __CFData *v139;
  const __CFData *v141;
  UInt8 *v142;
  const UInt8 *BytePtr;
  CFIndex Length;
  UInt8 *MutableBytePtr;
  const __CFData *v146;
  unsigned __int8 *v147;
  uint64_t v148;
  unsigned int v149;
  int v150;
  unsigned int v151;
  unsigned int v152;
  int v153;
  BOOL v154;
  int v155;
  int v156;
  unsigned int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  char v163;
  UInt8 *v164;
  CFIndex v165;
  __CFData *v166;
  void *v167;
  const UInt8 *v168;
  __CFDictionary *object;
  int v170;
  int v171;
  uint64_t v172;
  CFMutableArrayRef value;
  int v174;
  char v175;
  UInt8 bytes[16];
  _DWORD v177[7];
  char v178;
  UInt8 v179[8];
  int valuePtr;
  UInt8 buffer[1024];
  UInt8 v182[1024];
  UInt8 v183[1024];
  uint64_t v184;

  v184 = *MEMORY[0x1E0C80C00];
  v175 = 0;
  bzero(buffer, 0x400uLL);
  if (!AllKexts)
    AllKexts = (const __CFArray *)OSKextGetAllKexts();
  Count = CFArrayGetCount(AllKexts);
  if (!Count)
    return 0;
  v15 = Count;
  Mutable = CFDataCreateMutable(a1, 0);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, v163);
    return 0;
  }
  v22 = Mutable;
  *(_OWORD *)bytes = 0u;
  memset(v177, 0, sizeof(v177));
  v23 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v23)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v24, v25, v26, v27, v28, v163);
    CFRelease(v22);
    return 0;
  }
  v29 = v23;
  value = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (!value)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v30, v31, v32, v33, v34, v163);
    v139 = 0;
    v141 = 0;
    goto LABEL_100;
  }
  if (a3 && !CFURLGetFileSystemRepresentation(a3, 1u, buffer, 1024))
  {
    OSKextLog(0, 17, "String/URL conversion failure.", v35, v36, v37, v38, v39, v163);
    v141 = 0;
    goto LABEL_92;
  }
  CFDictionarySetValue(v29, CFSTR("_MKEXTInfoDictionaries"), value);
  if (a7)
  {
    CFDictionarySetValue(v29, CFSTR("Kext Request Predicate"), CFSTR("Load"));
    CFDictionarySetValue(v29, CFSTR("Kext Request Arguments"), a7);
  }
  v171 = a5;
  object = v29;
  CFDataAppendBytes(v22, bytes, 44);
  if (v15 < 1)
  {
    LODWORD(v40) = 0;
LABEL_77:
    v29 = object;
    v141 = IOCFSerialize(object, 0);
    if (v141)
    {
      v175 = 0;
      if (!v171)
        goto LABEL_81;
      if (__OSKextAddCompressedFileToMkext(0, v22, v141, 1, &v175))
      {
        if (v175)
        {
LABEL_82:
          MutableBytePtr = CFDataGetMutableBytePtr(v22);
          *(_QWORD *)MutableBytePtr = 0x58534F4D54584B4DLL;
          *((_DWORD *)MutableBytePtr + 2) = bswap32(CFDataGetLength(v22));
          v146 = v22;
          *((_DWORD *)MutableBytePtr + 4) = 18874370;
          v147 = MutableBytePtr + 16;
          *((_DWORD *)MutableBytePtr + 5) = bswap32(v40);
          pthread_once(&__sOSKextInitialized, __OSKextInitialize);
          *((_DWORD *)MutableBytePtr + 6) = bswap32(*((_DWORD *)__sOSKextArchInfo + 2));
          pthread_once(&__sOSKextInitialized, __OSKextInitialize);
          *((_DWORD *)MutableBytePtr + 7) = bswap32(*((_DWORD *)__sOSKextArchInfo + 3));
          v148 = CFDataGetLength(v146) - 16;
          if ((int)v148 < 1)
          {
            v157 = 1;
          }
          else
          {
            v149 = 0;
            v150 = 0;
            v151 = 0;
            v152 = 1;
            do
            {
              v153 = v150 + 5000 * (v149 / 0x1388);
              v154 = v153 == 0;
              if (!v153)
                v152 %= 0xFFF1u;
              v156 = *v147++;
              v155 = v156;
              if (v154)
                v151 %= 0xFFF1u;
              v152 += v155;
              v151 += v152;
              --v150;
              ++v149;
              --v148;
            }
            while (v148);
            v157 = (v152 % 0xFFF1) | ((v151 % 0xFFF1) << 16);
          }
          *((_DWORD *)MutableBytePtr + 3) = bswap32(v157);
          v22 = v146;
          CFRetain(v146);
          OSKextLog(0, 132, "Created mkext for architecture %s containing %u kexts.", v158, v159, v160, v161, v162, (char)*__sOSKextArchInfo);
          v139 = v146;
          goto LABEL_99;
        }
LABEL_81:
        v142 = CFDataGetMutableBytePtr(v22);
        *((_QWORD *)v142 + 4) = bswap32(CFDataGetLength(v22));
        *((_DWORD *)v142 + 10) = bswap32(CFDataGetLength(v141));
        BytePtr = CFDataGetBytePtr(v141);
        Length = CFDataGetLength(v141);
        CFDataAppendBytes(v22, BytePtr, Length);
        goto LABEL_82;
      }
    }
LABEL_92:
    v139 = 0;
    goto LABEL_99;
  }
  v174 = a4;
  v40 = 0;
  v41 = 0;
  v167 = (void *)*MEMORY[0x1E0C9AE50];
  v170 = a6;
  while (1)
  {
    ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(AllKexts, v41);
    __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 0, v182, v43, v44, v45, v46);
    if (!__OSKextIsValid((uint64_t)ValueAtIndex, v47, v48, v49, v50, v51, v52, v53))
    {
      OSKextLog((uint64_t)ValueAtIndex, 133, "%s is not valid; omitting from mkext.",
        v56,
        v57,
        v58,
        v59,
        v60,
        (char)v182);
      goto LABEL_38;
    }
    if (a6 && OSKextIsLoaded(ValueAtIndex, v54, v55, v56, v57, v58, v59, v60))
    {
      OSKextLog((uint64_t)ValueAtIndex, 135, "Omitting loaded kext %s from mkext for kernel load.", v61, v62, v63, v64, v65, (char)v182);
      goto LABEL_38;
    }
    if (!OSKextMatchesRequiredFlags((uint64_t)ValueAtIndex, v174))
      goto LABEL_38;
    if (!OSKextSupportsArchitecture((uint64_t)ValueAtIndex, 0))
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      OSKextLog((uint64_t)ValueAtIndex, 133, "%s does not contain code for architecture %s.", v106, v107, v108, v109, v110, (char)v182);
      goto LABEL_38;
    }
    v66 = CFDataGetLength(v22);
    valuePtr = 0;
    *(_QWORD *)v179 = 0;
    v178 = 0;
    __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 1u, v183, v67, v68, v69, v70);
    if (!__sOSKextLoadAuditFunction(ValueAtIndex))
    {
      OSKextLog((uint64_t)ValueAtIndex, 33, "Load audit function returned false, bailing on adding %s to mkext.", v71, v72, v73, v74, v75, (char)v183);
      goto LABEL_97;
    }
    v172 = v40;
    OSKextLog((uint64_t)ValueAtIndex, 133, "Adding %s to mkext.", v71, v72, v73, v74, v75, (char)v183);
    v76 = OSKextCopyInfoDictionary((uint64_t)ValueAtIndex);
    if (!v76)
      break;
    v84 = v76;
    if ((*((_BYTE *)ValueAtIndex + 92) & 4) != 0
      && __OSKextHasSuffix((uint64_t)ValueAtIndex, v77, v78, v79, v80, v81, v82, v83)
      && (*((_BYTE *)ValueAtIndex + 92) & 1) == 0)
    {
      ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)ValueAtIndex, CFSTR("OSBundleLibraries"));
      if (!ValueForInfoDictionaryKey)
      {
        OSKextLog((uint64_t)ValueAtIndex, 129, "Executable kext %s with no dependencies?!", v86, v87, v88, v89, v90, (char)v183);
LABEL_59:
        v96 = 0;
        v104 = 0;
        goto LABEL_60;
      }
      v91 = ValueForInfoDictionaryKey;
      if (!CFDictionaryGetValue(ValueForInfoDictionaryKey, CFSTR("com.apple.kpi.kasan")))
        CFDictionarySetValue(v91, CFSTR("com.apple.kpi.kasan"), CFSTR("8.0.0b1"));
      if (!CFDictionaryGetValue(v91, CFSTR("com.apple.kpi.kcov")))
        CFDictionarySetValue(v91, CFSTR("com.apple.kpi.kcov"), CFSTR("8.0.0b1"));
    }
    if ((*((_BYTE *)ValueAtIndex + 92) & 0x10) != 0)
      CFDictionarySetValue(v84, CFSTR("OSBundleEnableKextLogging"), v167);
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    v96 = OSKextCopyExecutableForArchitecture((uint64_t)ValueAtIndex, (uint64_t)__sOSKextArchInfo);
    if (v96)
    {
      valuePtr = v66;
      v97 = CFGetAllocator(ValueAtIndex);
      v98 = CFNumberCreate(v97, kCFNumberSInt32Type, &valuePtr);
      v104 = v98;
      if (!v98)
      {
        v111 = 17;
        v112 = "Memory allocation failure.";
        goto LABEL_55;
      }
      CFDictionarySetValue(v84, CFSTR("_MKEXTExecutable"), v98);
      v105 = CFDataGetLength(v96);
      *(_DWORD *)&v179[4] = bswap32(v105);
      if (!v171)
        goto LABEL_44;
      if (!__OSKextAddCompressedFileToMkext((uint64_t)ValueAtIndex, v22, v96, 0, &v178))
      {
        v164 = v183;
        v98 = (CFNumberRef)ValueAtIndex;
        v111 = 129;
        v112 = "%s failed to compress executable.";
LABEL_55:
        OSKextLog((uint64_t)v98, v111, v112, v99, v100, v101, v102, v103, (char)v164);
LABEL_60:
        v138 = 0;
        goto LABEL_61;
      }
      if (v178)
      {
        v168 = 0;
      }
      else
      {
LABEL_44:
        v165 = v66;
        v113 = CFDataGetBytePtr(v96);
        *(_DWORD *)v179 = 0;
        CFDataAppendBytes(v22, v179, 8);
        v168 = v113;
        v114 = v113;
        v66 = v165;
        CFDataAppendBytes(v22, v114, v105);
      }
      OSKextLog((uint64_t)ValueAtIndex, 134, "%s added %u-byte %scompressed executable to mkext.", v99, v100, v101, v102, v103, (char)v183);
    }
    else
    {
      if ((*((_BYTE *)ValueAtIndex + 92) & 4) != 0)
      {
        pthread_once(&__sOSKextInitialized, __OSKextInitialize);
        OSKextLog((uint64_t)ValueAtIndex, 129, "Can't get executable for %s (architecture %s).", v133, v134, v135, v136, v137, (char)v183);
        goto LABEL_59;
      }
      v104 = 0;
      v168 = 0;
    }
    if (__OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 1u, v183, v92, v93, v94, v95))
    {
      v166 = v22;
      v120 = __absPathOnVolume((const char *)v183, (char *)buffer);
      v121 = CFGetAllocator(ValueAtIndex);
      v122 = strlen(v120);
      v123 = CFStringCreateWithBytes(v121, (const UInt8 *)v120, v122, 0x8000100u, 0);
      if (v123)
      {
        v129 = (__CFString *)v123;
        CFDictionarySetValue(v84, CFSTR("_MKEXTBundlePath"), v123);
        v130 = __OSKextCopyExecutableRelativePath((uint64_t)ValueAtIndex);
        v22 = v166;
        if (v130)
        {
          v131 = (__CFDictionary *)v130;
          CFDictionarySetValue(v84, CFSTR("_MKEXTExecutableRelativePath"), v130);
          CFArrayAppendValue(value, v84);
          CFRelease(v84);
          CFRelease(v129);
          v132 = 0;
          v84 = v131;
        }
        else
        {
          CFArrayAppendValue(value, v84);
          CFRelease(v84);
          v132 = 0;
          v84 = (__CFDictionary *)v129;
        }
        v138 = (UInt8 *)v168;
        goto LABEL_62;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v124, v125, v126, v127, v128, (char)v164);
      v22 = v166;
    }
    else
    {
      OSKextLog((uint64_t)ValueAtIndex, 17, "String/URL conversion failure.", v115, v116, v117, v118, v119, (char)v164);
    }
    v138 = (UInt8 *)v168;
LABEL_61:
    CFDataSetLength(v22, v66);
    v132 = 1;
LABEL_62:
    CFRelease(v84);
    if (v96)
      CFRelease(v96);
    if (v104)
      CFRelease(v104);
    if (v178 && v138)
      free(v138);
    a6 = v170;
    if ((v132 & 1) != 0)
      goto LABEL_98;
    v40 = v172 + 1;
LABEL_38:
    if (v15 == ++v41)
      goto LABEL_77;
  }
  OSKextLog((uint64_t)ValueAtIndex, 129, "Can't get info dictionary for %s.", v79, v80, v81, v82, v83, (char)v183);
LABEL_97:
  CFDataSetLength(v22, v66);
LABEL_98:
  v141 = 0;
  v139 = 0;
  v29 = object;
LABEL_99:
  CFRelease(value);
LABEL_100:
  CFRelease(v29);
  CFRelease(v22);
  if (v141)
    CFRelease(v141);
  return v139;
}

CFMutableArrayRef OSKextCreateKextsFromMkextFile(const __CFAllocator *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFMutableArrayRef KextsFromMkext;
  char v11;
  CFDataRef resourceData;

  resourceData = 0;
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (CFURLCreateDataAndPropertiesFromResource(a1, (CFURLRef)a2, &resourceData, 0, 0, 0))
  {
    KextsFromMkext = __OSKextCreateKextsFromMkext(a1, resourceData, a2);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v11);
    KextsFromMkext = 0;
  }
  if (resourceData)
    CFRelease(resourceData);
  return KextsFromMkext;
}

CFMutableArrayRef __OSKextCreateKextsFromMkext(const __CFAllocator *a1, const __CFData *a2, const void *a3)
{
  CFMutableArrayRef Mutable;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFMutableArrayRef v12;
  int v13;
  _DWORD *BytePtr;
  const UInt8 *v15;
  CFIndex Length;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int **v22;
  cpu_type_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFData *v29;
  void *v30;
  CFMutableArrayRef v31;
  unsigned int v32;
  unsigned int v33;
  unsigned __int8 *v34;
  CFIndex v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  BOOL v42;
  int v43;
  int v44;
  unsigned int v45;
  const char *v46;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  size_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const __CFAllocator *v57;
  const __CFData *UncompressMkext2FileData;
  const char *v59;
  _DWORD *v60;
  CFTypeID v61;
  const __CFArray *Value;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFArray *v68;
  CFTypeID v69;
  CFIndex v70;
  const __CFDictionary *ValueAtIndex;
  _OWORD *v72;
  const void *v73;
  void *UTF8CStringForCFString;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  const char *v80;
  const char *v81;
  int v82;
  char v83;
  char v84;
  const __CFArray *v85;
  CFIndex Count;
  CFTypeRef cf;
  CFIndex v88;

  cf = 0;
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v7, v8, v9, v10, v11, v83);
    return 0;
  }
  v12 = Mutable;
  v88 = 0;
  v13 = *(_DWORD *)CFDataGetBytePtr(a2);
  BytePtr = CFDataGetBytePtr(a2);
  if (v13 != -1095041334)
  {
    v22 = 0;
    v88 = (CFIndex)BytePtr + CFDataGetLength(a2);
    goto LABEL_9;
  }
  v15 = CFDataGetBytePtr(a2);
  Length = CFDataGetLength(a2);
  v22 = (int **)fat_iterator_for_data(BytePtr, (unint64_t)&v15[Length], 1);
  if (!v22)
  {
    v46 = "Can't read mkext fat header.";
    goto LABEL_24;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  v23 = *((_DWORD *)__sOSKextArchInfo + 2);
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  BytePtr = fat_iterator_find_arch(v22, v23, *((_DWORD *)__sOSKextArchInfo + 3), &v88);
  if (BytePtr)
  {
LABEL_9:
    if (*BytePtr == 1415072589 && BytePtr[1] == 1481854797)
    {
      v32 = bswap32(BytePtr[2]);
      if (v88 - (_QWORD)BytePtr == v32)
      {
        v34 = (unsigned __int8 *)(BytePtr + 4);
        v33 = BytePtr[4];
        if (v33 == 18874370)
        {
          v35 = CFDataGetLength(a2);
          v88 = (CFIndex)BytePtr + v35;
          v36 = (v35 - 16);
          if ((int)v36 < 1)
          {
            v45 = 1;
          }
          else
          {
            v37 = 0;
            v38 = 0;
            v39 = 0;
            v40 = 1;
            do
            {
              v41 = v38 + 5000 * (v37 / 0x1388);
              v42 = v41 == 0;
              if (!v41)
                v40 %= 0xFFF1u;
              v44 = *v34++;
              v43 = v44;
              if (v42)
                v39 %= 0xFFF1u;
              v40 += v43;
              v39 += v40;
              --v38;
              ++v37;
              --v36;
            }
            while (v36);
            v45 = (v40 % 0xFFF1) | ((v39 % 0xFFF1) << 16);
          }
          if (bswap32(BytePtr[3]) == v45)
          {
            v48 = BytePtr[9];
            v49 = bswap32(BytePtr[8]);
            v50 = bswap32(v48);
            OSKextLog(0, 131079, "Mkext plist compressed size is %u.", v17, v18, v19, v20, v21, v50);
            v51 = bswap32(BytePtr[10]);
            OSKextLog(0, 131079, "Mkext plist full size is %u.", v52, v53, v54, v55, v56, v51);
            if (!v48)
            {
              v29 = 0;
              v59 = (char *)BytePtr + v49;
LABEL_47:
              v60 = IOCFUnserialize(v59, a1, 0, (CFStringRef *)&cf);
              BytePtr = v60;
              if (!v60 || (v61 = CFGetTypeID(v60), v61 != CFDictionaryGetTypeID()))
              {
                UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)cf);
                v30 = UTF8CStringForCFString;
                v80 = "(unknown error)";
                if (UTF8CStringForCFString)
                  LOBYTE(v80) = (_BYTE)UTF8CStringForCFString;
                OSKextLog(0, 129, "Failed to read XML from mkext: %s.", v75, v76, v77, v78, v79, (char)v80);
                goto LABEL_26;
              }
              Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)BytePtr, CFSTR("_MKEXTInfoDictionaries"));
              if (Value && (v68 = Value, v69 = CFGetTypeID(Value), v69 == CFArrayGetTypeID()))
              {
                Count = CFArrayGetCount(v68);
                if (Count < 1)
                {
LABEL_56:
                  CFRetain(v12);
                  v30 = 0;
                  v31 = v12;
                  goto LABEL_27;
                }
                v70 = 0;
                v85 = v68;
                while (1)
                {
                  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v68, v70);
                  v72 = __OSKextAlloc();
                  if (!v72)
                  {
                    v81 = "Memory allocation failure.";
                    v82 = 17;
                    goto LABEL_61;
                  }
                  v73 = v72;
                  if (!__OSKextInitFromMkext((uint64_t)v72, ValueAtIndex, a3, a2))
                    break;
                  CFArrayAppendValue(v12, v73);
                  CFRelease(v73);
                  ++v70;
                  v68 = v85;
                  if (Count == v70)
                    goto LABEL_56;
                }
                CFRelease(v73);
              }
              else
              {
                v81 = "Mkext plist has no kexts.";
                v82 = 129;
LABEL_61:
                OSKextLog(0, v82, v81, v63, v64, v65, v66, v67, v84);
              }
              goto LABEL_6;
            }
            v57 = CFGetAllocator(a2);
            UncompressMkext2FileData = __OSKextCreateUncompressMkext2FileData(v57, (Bytef *)BytePtr + v49, v50, v51);
            v29 = UncompressMkext2FileData;
            if (UncompressMkext2FileData)
            {
              v59 = (const char *)CFDataGetBytePtr(UncompressMkext2FileData);
              goto LABEL_47;
            }
LABEL_25:
            v30 = 0;
            BytePtr = 0;
            goto LABEL_26;
          }
          v46 = "Mkext checksum error.";
        }
        else
        {
          v83 = bswap32(v33);
          v46 = "Unsupported mkext version 0x%x.";
        }
      }
      else
      {
        v83 = v32;
        v46 = "Mkext length field %d does not match mkext actual size %d.";
      }
    }
    else
    {
      v46 = "Bad mkext magic/signature.";
    }
LABEL_24:
    OSKextLog(0, 129, v46, v17, v18, v19, v20, v21, v83);
    v29 = 0;
    goto LABEL_25;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  OSKextLog(0, 129, "Architecture %s not found in mkext.", v24, v25, v26, v27, v28, (char)*__sOSKextArchInfo);
  v29 = 0;
LABEL_6:
  v30 = 0;
LABEL_26:
  v31 = 0;
LABEL_27:
  CFRelease(v12);
  if (cf)
    CFRelease(cf);
  if (BytePtr)
    CFRelease(BytePtr);
  if (v29)
    CFRelease(v29);
  if (v30)
    free(v30);
  if (v22)
    fat_iterator_close((void **)v22);
  return v31;
}

CFMutableArrayRef OSKextCreateKextsFromMkextData(const __CFAllocator *a1, const __CFData *a2)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  return __OSKextCreateKextsFromMkext(a1, a2, 0);
}

const char *__absPathOnVolume(const char *a1, char *__s)
{
  size_t v4;
  size_t v5;
  size_t v6;

  if (__s && *__s)
  {
    v4 = strlen(__s);
    v5 = __s[v4 - 1] == 47 ? v4 - 1 : v4;
    if (v5)
    {
      if (!strncmp(a1, __s, v5))
        v6 = v5;
      else
        v6 = 0;
      a1 += v6;
    }
  }
  return a1;
}

CFStringRef __OSKextCopyExecutableRelativePath(uint64_t a1)
{
  const __CFURL *v2;
  const __CFString *v3;
  CFStringRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  const __CFURL *ExecutableURL;
  const __CFURL *v14;
  const __CFURL *v15;
  CFStringRef v16;
  CFIndex v17;
  CFStringRef v18;
  CFRange v20;

  v2 = CFURLCopyAbsoluteURL(*(CFURLRef *)(a1 + 16));
  if (!v2)
    return 0;
  v3 = (const __CFString *)v2;
  v4 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle);
  if (!v4)
  {
    v18 = 0;
    v16 = v3;
LABEL_16:
    CFRelease(v16);
    return v18;
  }
  v12 = v4;
  ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((_QWORD *)a1, v5, v6, v7, v8, v9, v10, v11);
  if (!ExecutableURL)
  {
    v18 = 0;
    v15 = 0;
LABEL_11:
    v16 = 0;
    goto LABEL_13;
  }
  v14 = CFURLCopyAbsoluteURL(ExecutableURL);
  v15 = v14;
  if (!v14)
  {
    v18 = 0;
    goto LABEL_11;
  }
  v16 = CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
  if (v16)
  {
    v17 = CFStringGetLength(v12) + 1;
    v20.length = CFStringGetLength(v16) - v17;
    v20.location = v17;
    v18 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16, v20);
  }
  else
  {
    v18 = 0;
  }
LABEL_13:
  CFRelease(v3);
  CFRelease(v12);
  if (v15)
    CFRelease(v15);
  if (v16)
    goto LABEL_16;
  return v18;
}

CFStringRef OSKextCopyExecutableName(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFURL *ExecutableURL;

  if ((*(_BYTE *)(a1 + 92) & 8) != 0)
    return 0;
  ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!ExecutableURL)
    return 0;
  else
    return CFURLCopyLastPathComponent(ExecutableURL);
}

void OSKextVLogCFString(uint64_t a1, int a2, const __CFString *a3, va_list a4)
{
  int v6;
  const __CFString *v7;
  const __CFString *v8;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v11;
  char *v12;

  if (__sOSKextLogOutputFunction)
  {
    v6 = a1;
    if (__OSKextShouldLog(a1, a2))
    {
      v7 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3, a4);
      if (v7)
      {
        v8 = v7;
        Length = CFStringGetLength(v7);
        MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        v11 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0x46499120uLL);
        if (v11)
        {
          v12 = v11;
          if (CFStringGetCString(v8, v11, MaximumSizeForEncoding, 0x8000100u))
            __sOSKextLogOutputFunction(v6, a2, "%s", v12);
          CFRelease(v8);
          free(v12);
        }
        else
        {
          CFRelease(v8);
        }
      }
    }
  }
}

const void *_isDictionary(const void *result)
{
  CFTypeID v1;

  if (result)
  {
    v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFDictionaryGetTypeID());
  }
  return result;
}

const void *_isArray(const void *result)
{
  CFTypeID v1;

  if (result)
  {
    v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFArrayGetTypeID());
  }
  return result;
}

const void *_isString(const void *result)
{
  CFTypeID v1;

  if (result)
  {
    v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFStringGetTypeID());
  }
  return result;
}

void __OSKextReleaseContents(uint64_t a1)
{
  CFIndex Count;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  const __CFString *v10;
  void *UTF8CStringForCFString;
  const __CFURL *v12;
  const __CFURL *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  char v24;
  _BYTE v25[20];
  UInt8 __dst[1024];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  memcpy(__dst, "(unknown)", sizeof(__dst));
  Count = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  if (Count >= 1)
  {
    v9 = Count + 1;
    do
    {
      if (CFArrayGetValueAtIndex((CFArrayRef)__sOSAllKexts, v9 - 2) == (const void *)a1)
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)__sOSAllKexts, v9 - 2);
      --v9;
    }
    while (v9 > 1);
  }
  v10 = *(const __CFString **)(a1 + 24);
  if (v10)
    UTF8CStringForCFString = createUTF8CStringForCFString(v10);
  else
    UTF8CStringForCFString = 0;
  v12 = *(const __CFURL **)(a1 + 16);
  if (v12)
  {
    v13 = CFURLCopyAbsoluteURL(v12);
    if (v13)
    {
      __OSKextGetFileSystemPath(0, v13, 1u, __dst, v5, v6, v7, v8);
      if ((*(_BYTE *)(a1 + 88) & 8) == 0
        && CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByURL, v13) == (const void *)a1)
      {
        CFDictionaryRemoveValue((CFMutableDictionaryRef)__sOSKextsByURL, v13);
      }
    }
  }
  else
  {
    v13 = 0;
  }
  __OSKextRemoveKextFromIdentifierDict(a1, (const __CFDictionary *)__sOSKextsByIdentifier, v3, v4, v5, v6, v7, v8, v24);
  OSKextVersionGetString(*(_QWORD *)(a1 + 40), v25, 0x14u);
  OSKextLog(a1, 262149, "Removed %s, id %s%s, version %s.", v14, v15, v16, v17, v18, (char)__dst);
  if (v13)
    CFRelease(v13);
  if (UTF8CStringForCFString)
    free(UTF8CStringForCFString);
  OSKextFlushDiagnostics(a1, -1);
  OSKextFlushLoadInfo(a1, 1);
  v19 = *(CFTypeRef **)(a1 + 80);
  if (v19)
  {
    if (*v19)
    {
      CFRelease(*v19);
      v19 = *(CFTypeRef **)(a1 + 80);
    }
    *v19 = 0;
    if (v19[1])
    {
      CFRelease(v19[1]);
      v19 = *(CFTypeRef **)(a1 + 80);
    }
    v19[1] = 0;
    if (v19[2])
    {
      CFRelease(v19[2]);
      v19 = *(CFTypeRef **)(a1 + 80);
    }
    v19[2] = 0;
    if (v19[3])
    {
      CFRelease(v19[3]);
      v19 = *(CFTypeRef **)(a1 + 80);
    }
    free(v19);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v20 = *(const void **)(a1 + 16);
  if (v20)
    CFRelease(v20);
  *(_QWORD *)(a1 + 16) = 0;
  v21 = *(const void **)(a1 + 24);
  if (v21)
    CFRelease(v21);
  *(_QWORD *)(a1 + 24) = 0;
  v22 = *(const void **)(a1 + 32);
  if (v22)
    CFRelease(v22);
  *(_QWORD *)(a1 + 32) = 0;
  v23 = *(const void **)(a1 + 56);
  if (v23)
    CFRelease(v23);
  *(_QWORD *)(a1 + 56) = 0;
}

__CFString *__OSKextCopyDebugDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  const __CFString *v3;
  __CFString *Mutable;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  char v14;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = *(const __CFString **)(a1 + 24);
  Mutable = CFStringCreateMutable(v2, 0);
  v10 = Mutable;
  if (Mutable)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("<OSKext %p [%p]> { "), a1, v2);
    if ((*(_BYTE *)(a1 + 88) & 8) != 0)
    {
      v11 = **(const __CFString ***)(a1 + 80);
      if (!v11)
        v11 = CFSTR("(unknown)");
      CFStringAppendFormat(v10, 0, CFSTR("mkext URL = \"%@\", "), v11);
      if (*(_QWORD *)(a1 + 16))
        CFStringAppendFormat(v10, 0, CFSTR("original URL = \"%@\", "), *(_QWORD *)(a1 + 16));
    }
    else if (*(_QWORD *)(a1 + 16))
    {
      CFStringAppendFormat(v10, 0, CFSTR("URL = \"%@\", "), *(_QWORD *)(a1 + 16));
    }
    if (v3)
      v12 = v3;
    else
      v12 = CFSTR("(unknown)");
    CFStringAppendFormat(v10, 0, CFSTR("ID = \"%@\""), v12);
    CFStringAppendFormat(v10, 0, CFSTR(" }"));
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v14);
  }
  return v10;
}

void __OSKextReinitApplierFunction(uint64_t a1, uint64_t a2)
{
  __OSKextReinit(a2);
}

uint64_t __OSKextRecordKextInIdentifierDict(CFMutableArrayRef a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  const __CFString *v9;
  unint64_t *Value;
  unint64_t *v12;
  uint64_t v13;
  __int128 v14;
  CFMutableArrayRef v15;
  CFTypeID TypeID;
  const char *v17;
  int v18;
  void *UTF8CStringForCFString;
  int64_t v21;
  CFIndex FirstIndexOfValue;
  const __CFArray *v23;
  CFIndex v24;
  CFIndex Count;
  CFIndex v26;
  CFIndex v27;
  _QWORD *ValueAtIndex;
  int64_t v29;
  const __CFArray *v30;
  CFIndex v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  CFArrayCallBacks callBacks;
  uint64_t v40;
  CFRange v41;
  CFRange v42;
  CFRange v43;
  CFRange v44;

  v8 = (unint64_t *)a1;
  v40 = *MEMORY[0x1E0C80C00];
  v9 = (const __CFString *)*((_QWORD *)a1 + 3);
  if (!v9)
  {
    v17 = "Can't record kext in identifier lookup dictionary; no identifier.";
    v18 = 262145;
    goto LABEL_12;
  }
  Value = (unint64_t *)CFDictionaryGetValue(theDict, v9);
  v12 = Value;
  if (!Value)
  {
    CFDictionarySetValue(theDict, v9, v8);
    UTF8CStringForCFString = createUTF8CStringForCFString(v9);
    if (UTF8CStringForCFString)
      goto LABEL_30;
    return 1;
  }
  if (Value == v8)
  {
    UTF8CStringForCFString = createUTF8CStringForCFString(v9);
    v12 = v8;
    if (UTF8CStringForCFString)
      goto LABEL_30;
    return 1;
  }
  v13 = __kOSKextTypeID;
  if (v13 == CFGetTypeID(Value))
  {
    v14 = *(_OWORD *)(MEMORY[0x1E0C9B378] + 16);
    *(_OWORD *)&callBacks.version = *MEMORY[0x1E0C9B378];
    *(_OWORD *)&callBacks.release = v14;
    callBacks.equal = *(CFArrayEqualCallBack *)(MEMORY[0x1E0C9B378] + 32);
    callBacks.retain = 0;
    callBacks.release = 0;
    a1 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callBacks);
    if (a1)
    {
      v15 = a1;
      CFArrayAppendValue(a1, v12);
      CFDictionarySetValue(theDict, v9, v15);
      v12 = (unint64_t *)v15;
      goto LABEL_7;
    }
    v17 = "Memory allocation failure.";
    v18 = 17;
LABEL_12:
    OSKextLog((uint64_t)a1, v18, v17, a4, a5, a6, a7, a8, v38);
    return 0;
  }
LABEL_7:
  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(v12))
  {
    if (__sOSKextStrictRecordingByLastOpened)
    {
      v41.length = CFArrayGetCount((CFArrayRef)v12);
      v41.location = 0;
      if (CFArrayGetFirstIndexOfValue((CFArrayRef)v12, v41, v8) == -1)
        CFArrayInsertValueAtIndex((CFMutableArrayRef)v12, 0, v8);
      return 1;
    }
    v21 = v8[5];
    v42.length = CFArrayGetCount((CFArrayRef)v12);
    v42.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue((CFArrayRef)v12, v42, v8);
    if (FirstIndexOfValue != -1)
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)v12, FirstIndexOfValue);
    v23 = (const __CFArray *)__sOSAllKexts;
    v43.length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
    v43.location = 0;
    v24 = CFArrayGetFirstIndexOfValue(v23, v43, v8);
    Count = CFArrayGetCount((CFArrayRef)v12);
    if (Count < 1)
    {
      v27 = 0;
    }
    else
    {
      v26 = Count;
      v27 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v12, v27);
        v29 = ValueAtIndex[5];
        v30 = (const __CFArray *)__sOSAllKexts;
        v44.length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
        v44.location = 0;
        v31 = CFArrayGetFirstIndexOfValue(v30, v44, ValueAtIndex);
        v32 = v21 == v29;
        if (v24 <= v31)
          v32 = 0;
        if (v21 > v29 || v32)
          break;
        if (v26 == ++v27)
        {
          v27 = v26;
          break;
        }
      }
    }
    CFArrayInsertValueAtIndex((CFMutableArrayRef)v12, v27, v8);
    UTF8CStringForCFString = createUTF8CStringForCFString(v9);
    if (!UTF8CStringForCFString)
      return 1;
LABEL_30:
    OSKextVersionGetString(v8[5], &callBacks, 0x14u);
    if (v12 == v8)
      OSKextLog((uint64_t)v8, 262149, "%s, version %s is already in the identifier lookup dictionary at index %d.", v33, v34, v35, v36, v37, (char)UTF8CStringForCFString);
    else
      OSKextLog((uint64_t)v8, 262151, "%s, version %s recorded at index %d in the identifier lookup dictionary.", v33, v34, v35, v36, v37, (char)UTF8CStringForCFString);
    free(UTF8CStringForCFString);
  }
  return 1;
}

uint64_t __OSKextCreateMkextInfo(uint64_t a1)
{
  _OWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  if (*(_QWORD *)(a1 + 80))
    return 1;
  v2 = malloc_type_malloc(0x20uLL, 0x60040FAD0F902uLL);
  *(_QWORD *)(a1 + 80) = v2;
  if (v2)
  {
    *v2 = 0u;
    v2[1] = 0u;
    return 1;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v9);
  return 0;
}

CFDataRef __OSKextCreateUncompressMkext2FileData(const __CFAllocator *a1, Bytef *a2, uInt a3, size_t size)
{
  uInt v4;
  CFIndex v8;
  Bytef *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Bytef *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CFDataRef v27;
  CFDataRef v28;
  const char *v29;
  const char *v30;
  int v31;
  char v33;
  z_stream strm;

  v4 = size;
  v8 = size;
  v9 = (Bytef *)malloc_type_malloc(size, 0x92272CC3uLL);
  if (!v9)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v10, v11, v12, v13, v14, v33);
    return 0;
  }
  v15 = v9;
  memset(&strm.avail_out + 1, 0, 76);
  *(_OWORD *)&strm.avail_in = 0u;
  strm.next_in = a2;
  strm.next_out = v9;
  strm.avail_in = a3;
  strm.avail_out = v4;
  if (inflateInit_(&strm, "1.2.12", 112))
  {
    OSKextLog(0, 131073, "zlib inflateInit failed.", v16, v17, v18, v19, v20, v33);
LABEL_16:
    free(v15);
    return 0;
  }
  v21 = inflate(&strm, 4);
  if (!v21)
    goto LABEL_10;
  if (v21 != 1)
  {
    LOBYTE(v30) = strm.msg;
    if (!strm.msg)
      v30 = "unknown";
    v33 = (char)v30;
    v29 = "zlib inflate failed: %s.";
    goto LABEL_14;
  }
  if (LODWORD(strm.total_out) != v4)
  {
LABEL_10:
    v29 = "zlib inflate discrepancy, uncompressed size != original size.";
LABEL_14:
    v31 = 131073;
LABEL_15:
    OSKextLog(0, v31, v29, v22, v23, v24, v25, v26, v33);
    inflateEnd(&strm);
    goto LABEL_16;
  }
  v27 = CFDataCreateWithBytesNoCopy(a1, v15, v8, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  if (!v27)
  {
    v29 = "Memory allocation failure.";
    v31 = 17;
    goto LABEL_15;
  }
  v28 = v27;
  inflateEnd(&strm);
  return v28;
}

const __CFURL *__OSKextHasSuffix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFURL *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  UInt8 __s[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 92) & 8) != 0)
    return 0;
  result = (const __CFURL *)OSKextGetExecutableURL((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    result = (const __CFURL *)__OSKextGetFileSystemPath(0, result, 1u, __s, v9, v10, v11, v12);
    if ((_DWORD)result)
    {
      v13 = strlen((const char *)__s);
      return (const __CFURL *)(v13 >= 7 && !strncmp("_kasan", (const char *)&__s[v13 - 6], 6uLL));
    }
  }
  return result;
}

void __OSKextAddDependenciesApplierFunction(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFArray **v10;
  const __CFArray *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFArray *v17;
  UInt8 buffer[1024];
  uint64_t v19;
  CFRange v20;
  CFRange v21;

  v19 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 92) & 1) == 0)
  {
    v10 = *(const __CFArray ***)(a1 + 72);
    if (v10 && (v11 = *v10) != 0)
    {
      ++*((_DWORD *)a2 + 3);
      v20.length = CFArrayGetCount(v11);
      v20.location = 0;
      CFArrayApplyFunction(v11, v20, (CFArrayApplierFunction)__OSKextAddDependenciesApplierFunction, a2);
      --*((_DWORD *)a2 + 3);
    }
    else
    {
      __OSKextGetFileSystemPath(a1, 0, 1u, buffer, a5, a6, a7, a8);
      OSKextLog(a1, 16385, "%s - missing load info or dependencies array in applier function.", v12, v13, v14, v15, v16, (char)buffer);
      *((_BYTE *)a2 + 16) = 1;
    }
  }
  if (!*((_BYTE *)a2 + 16) && *((_DWORD *)a2 + 3) >= *((_DWORD *)a2 + 2))
  {
    v17 = (const __CFArray *)*a2;
    v21.length = CFArrayGetCount((CFArrayRef)*a2);
    v21.location = 0;
    if (CFArrayGetFirstIndexOfValue(v17, v21, (const void *)a1) == -1)
      CFArrayAppendValue((CFMutableArrayRef)*a2, (const void *)a1);
  }
}

CFMutableDictionaryRef __OSKextGetDiagnostics(uint64_t a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFMutableDictionaryRef result;
  char v11;

  if (!*(_QWORD *)(a1 + 64))
  {
    v4 = malloc_type_malloc(0x28uLL, 0x20040769AC3DAuLL);
    *(_QWORD *)(a1 + 64) = v4;
    if (!v4)
    {
LABEL_20:
      OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v11);
      return 0;
    }
    v4[4] = 0;
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
  }
  result = 0;
  switch(a2)
  {
    case 1:
      result = **(CFMutableDictionaryRef **)(a1 + 64);
      if (!result)
      {
        result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        **(_QWORD **)(a1 + 64) = result;
        if (!result)
          goto LABEL_20;
      }
      break;
    case 2:
      result = *(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 64) + 8);
      if (!result)
      {
        result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = result;
        if (!result)
          goto LABEL_20;
      }
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      return result;
    case 4:
      result = *(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 64) + 16);
      if (!result)
      {
        result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 16) = result;
        if (!result)
          goto LABEL_20;
      }
      break;
    case 8:
      result = *(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 64) + 24);
      if (!result)
      {
        result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24) = result;
        if (!result)
          goto LABEL_20;
      }
      break;
    default:
      if (a2 == 16)
      {
        result = *(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 64) + 32);
        if (!result)
        {
          result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          *(_QWORD *)(*(_QWORD *)(a1 + 64) + 32) = result;
          if (!result)
            goto LABEL_20;
        }
      }
      break;
  }
  return result;
}

void __OSKextValidateOSBundleLibraryApplierFunction(const __CFString *value, const __CFString *a2, uint64_t a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const __CFString *v8;
  const __CFString *TypeID;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFArray *v14;
  CFIndex v15;
  char v16;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), value);
  v6 = *(_QWORD *)a3;
  v7 = *(const __CFDictionary **)(a3 + 8);
  v8 = *(const __CFString **)(a3 + 16);
  TypeID = (const __CFString *)CFStringGetTypeID();
  if (__OSKextCheckProperty(v6, v7, value, v8, TypeID, 0, 0, 1, 1, 0, 0))
  {
    v13 = OSKextParseVersionCFString(a2);
    if (v13 == -1)
    {
      __OSKextAddDiagnostic(*(_QWORD *)a3, 1, CFSTR("Info dictionary property value is illegal"), *(const __CFString **)(a3 + 16), 0, v10, v11, v12, v16);
      *(_BYTE *)(a3 + 24) = 0;
    }
    if (CFStringHasPrefix(value, CFSTR("com.apple.kernel")))
    {
      *(_BYTE *)(a3 + 25) = 1;
    }
    else
    {
      if (!CFStringHasPrefix(value, CFSTR("com.apple.kpi.")))
        goto LABEL_11;
      *(_BYTE *)(a3 + 26) = 1;
    }
    if (v13 < __sOSNewKmodInfoKernelVersion)
      *(_DWORD *)(*(_QWORD *)a3 + 92) |= 0x10000u;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
  }
LABEL_11:
  v14 = *(const __CFArray **)(a3 + 16);
  v15 = CFArrayGetCount(v14) - 1;
  CFArrayRemoveValueAtIndex(v14, v15);
}

void __OSKextValidateIOKitPersonalityApplierFunction(const __CFString *value, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const __CFString *v8;
  const __CFString *TypeID;
  uint64_t v10;
  const __CFString *v11;
  const __CFString *v12;
  int v13;
  BOOL v14;
  char v15;
  const __CFArray *v16;
  CFIndex Count;
  const __CFString *v18;
  uint64_t v19;
  const __CFString *v20;
  const __CFString *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  char v27;
  uint64_t v28;
  CFStringRef v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFArray *KextWithIdentifier;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  uint64_t v38;
  const __CFString *v39;
  const __CFArray *v40;
  CFIndex v41;
  uint64_t v42;
  const __CFString *v43;
  const __CFString *v44;
  int v45;
  BOOL v46;
  char v47;
  const __CFArray *v48;
  CFIndex v49;
  uint64_t v50;
  const __CFString *v51;
  const __CFString *v52;
  int v53;
  BOOL v54;
  char v55;
  int v56;
  const __CFArray *v57;
  CFIndex v58;
  uint64_t v59;
  const __CFString *v60;
  const __CFString *v61;
  int v62;
  BOOL v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFArray *v68;
  CFIndex v69;
  uint64_t v70;
  const __CFString *v71;
  const __CFString *v72;
  const __CFArray *v73;
  CFIndex v74;
  uint64_t v75;
  const __CFString *v76;
  const __CFString *v77;
  const __CFArray *v78;
  CFIndex v79;
  const __CFArray *v80;
  CFIndex v81;
  char v82;
  char v83;
  char v84;
  CFTypeRef cf1;
  CFTypeRef v86;
  char v87;

  v87 = 0;
  cf1 = 0;
  v86 = 0;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), value);
  v6 = *(_QWORD *)a3;
  v7 = *(const __CFDictionary **)(a3 + 8);
  v8 = *(const __CFString **)(a3 + 16);
  TypeID = (const __CFString *)CFDictionaryGetTypeID();
  if (!__OSKextCheckProperty(v6, v7, value, v8, TypeID, 0, 0, 1, 0, 0, 0))
  {
    *(_BYTE *)(a3 + 24) = 0;
    goto LABEL_61;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), CFSTR("IOKitDebug"));
  v10 = *(_QWORD *)a3;
  v11 = *(const __CFString **)(a3 + 16);
  v12 = (const __CFString *)CFNumberGetTypeID();
  v13 = __OSKextCheckProperty(v10, a2, CFSTR("IOKitDebug"), v11, v12, 0, 0, 1, 0, 0, &v87);
  if (v13)
    v14 = *(_BYTE *)(a3 + 24) == 0;
  else
    v14 = 1;
  v15 = !v14;
  *(_BYTE *)(a3 + 24) = v15;
  if (v13 && v87)
    *(_DWORD *)(*(_QWORD *)a3 + 92) |= 0x40u;
  v16 = *(const __CFArray **)(a3 + 16);
  Count = CFArrayGetCount(v16);
  CFArrayRemoveValueAtIndex(v16, Count - 1);
  if (!*(_BYTE *)(a3 + 25))
  {
    v18 = (const __CFString *)*MEMORY[0x1E0C9AE78];
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), (const void *)*MEMORY[0x1E0C9AE78]);
    v19 = *(_QWORD *)a3;
    v20 = *(const __CFString **)(a3 + 16);
    v21 = (const __CFString *)CFStringGetTypeID();
    v22 = __OSKextCheckProperty(v19, a2, v18, v20, v21, 0, 0, 1, 1, (const __CFString **)&cf1, &v87);
    if (*(_BYTE *)(a3 + 24))
      v26 = v22 == 0;
    else
      v26 = 1;
    v27 = !v26;
    *(_BYTE *)(a3 + 24) = v27;
    v28 = *(_QWORD *)a3;
    if (cf1)
    {
      if (!CFEqual(cf1, *(CFTypeRef *)(v28 + 24)))
      {
        v29 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@ -> %@ (kext is %@)"));
        __OSKextAddDiagnostic(*(_QWORD *)a3, 8, CFSTR("Personality CFBundleIdentifier differs from containing kext's (not necessarily a mistake, but rarely done)"), value, 0, v30, v31, v32, (char)value);
        if (v29)
          CFRelease(v29);
      }
    }
    else
    {
      __OSKextAddDiagnostic(v28, 8, CFSTR("Personality has no CFBundleIdentifier; the kext's identifier will be inserted when sending to the IOCatalogue"),
        value,
        0,
        v23,
        v24,
        v25,
        v82);
    }
    if (cf1)
    {
      KextWithIdentifier = OSKextGetKextWithIdentifier((void *)cf1);
      if (KextWithIdentifier)
      {
        if ((*((_BYTE *)KextWithIdentifier + 92) & 4) != 0)
          goto LABEL_31;
        v83 = (char)value;
        v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("'%@' -> '%@'"));
        v38 = *(_QWORD *)a3;
        v39 = CFSTR("Personality CFBundleIdentifier names a kext that doesn't declare an executable");
      }
      else
      {
        v83 = (char)value;
        v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("'%@' -> '%@'"));
        v38 = *(_QWORD *)a3;
        v39 = CFSTR("Personality CFBundleIdentifier names a kext that can't be found");
      }
      __OSKextAddDiagnostic(v38, 8, v39, v37, 0, v34, v35, v36, v83);
      if (v37)
        CFRelease(v37);
    }
LABEL_31:
    v40 = *(const __CFArray **)(a3 + 16);
    v41 = CFArrayGetCount(v40);
    CFArrayRemoveValueAtIndex(v40, v41 - 1);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), CFSTR("IOClass"));
    v42 = *(_QWORD *)a3;
    v43 = *(const __CFString **)(a3 + 16);
    v44 = (const __CFString *)CFStringGetTypeID();
    v45 = __OSKextCheckProperty(v42, a2, CFSTR("IOClass"), v43, v44, 0, 1, 1, 1, (const __CFString **)&v86, 0);
    if (*(_BYTE *)(a3 + 24))
      v46 = v45 == 0;
    else
      v46 = 1;
    v47 = !v46;
    *(_BYTE *)(a3 + 24) = v47;
    v48 = *(const __CFArray **)(a3 + 16);
    v49 = CFArrayGetCount(v48);
    CFArrayRemoveValueAtIndex(v48, v49 - 1);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), CFSTR("IOProviderClass"));
    v50 = *(_QWORD *)a3;
    v51 = *(const __CFString **)(a3 + 16);
    v52 = (const __CFString *)CFStringGetTypeID();
    v53 = __OSKextCheckProperty(v50, a2, CFSTR("IOProviderClass"), v51, v52, 0, 1, 1, 1, (const __CFString **)&cf1, 0);
    if (v53)
      v54 = *(_BYTE *)(a3 + 24) == 0;
    else
      v54 = 1;
    v55 = !v54;
    *(_BYTE *)(a3 + 24) = v55;
    if (v53)
    {
      v56 = CFEqual(cf1, CFSTR("IOResources"));
      v57 = *(const __CFArray **)(a3 + 16);
      v58 = CFArrayGetCount(v57);
      CFArrayRemoveValueAtIndex(v57, v58 - 1);
      if (!v56)
        goto LABEL_57;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), CFSTR("IOMatchCategory"));
      v59 = *(_QWORD *)a3;
      v60 = *(const __CFString **)(a3 + 16);
      v61 = (const __CFString *)CFStringGetTypeID();
      v62 = __OSKextCheckProperty(v59, a2, CFSTR("IOMatchCategory"), v60, v61, 0, 0, 1, 0, (const __CFString **)&cf1, 0);
      if (v62)
        v63 = *(_BYTE *)(a3 + 24) == 0;
      else
        v63 = 1;
      v64 = !v63;
      *(_BYTE *)(a3 + 24) = v64;
      if (v62 && cf1 && v86 && !CFEqual(v86, cf1))
        __OSKextAddDiagnostic(*(_QWORD *)a3, 8, CFSTR("Personality matches on IOResources but IOMatchCategory is missing or not equal to its IOClass; driver may be blocked from matching or may block others"),
          value,
          0,
          v65,
          v66,
          v67,
          v84);
    }
    v68 = *(const __CFArray **)(a3 + 16);
    v69 = CFArrayGetCount(v68);
    CFArrayRemoveValueAtIndex(v68, v69 - 1);
LABEL_57:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), CFSTR("IOProbeScore"));
    v70 = *(_QWORD *)a3;
    v71 = *(const __CFString **)(a3 + 16);
    v72 = (const __CFString *)CFNumberGetTypeID();
    __OSKextCheckProperty(v70, a2, CFSTR("IOProbeScore"), v71, v72, 0, 0, 0, 0, 0, 0);
    v73 = *(const __CFArray **)(a3 + 16);
    v74 = CFArrayGetCount(v73);
    CFArrayRemoveValueAtIndex(v73, v74 - 1);
    if ((*(_BYTE *)(*(_QWORD *)a3 + 92) & 8) != 0)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), CFSTR("CFBundleIdentifierKernel"));
      v75 = *(_QWORD *)a3;
      v76 = *(const __CFString **)(a3 + 16);
      v77 = (const __CFString *)CFStringGetTypeID();
      if (!__OSKextCheckProperty(v75, a2, CFSTR("CFBundleIdentifierKernel"), v76, v77, 0, 1, 1, 1, (const __CFString **)&cf1, &v87))__OSKextSetDiagnostic(*(_QWORD *)a3, 1, CFSTR("The 'CFBundleIdentifierKernel' key is required in your personality to specify the base kext to load when your kext is instantiated."));
      v78 = *(const __CFArray **)(a3 + 16);
      v79 = CFArrayGetCount(v78);
      CFArrayRemoveValueAtIndex(v78, v79 - 1);
    }
  }
LABEL_61:
  v80 = *(const __CFArray **)(a3 + 16);
  v81 = CFArrayGetCount(v80);
  CFArrayRemoveValueAtIndex(v80, v81 - 1);
}

uint64_t __OSKextAddCompressedFileToMkext(uint64_t a1, const __CFData *a2, CFDataRef theData, int a4, _BYTE *a5)
{
  _BOOL4 v9;
  Bytef *BytePtr;
  CFIndex Length;
  unsigned int v12;
  UInt8 *MutableBytePtr;
  UInt8 *v14;
  UInt8 *v15;
  UInt8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int total_out;
  unsigned int v28;
  const char *v29;
  char v31;
  CFIndex v32;
  z_stream strm;

  v9 = a4 == 0;
  BytePtr = (Bytef *)CFDataGetBytePtr(theData);
  Length = CFDataGetLength(a2);
  v12 = CFDataGetLength(theData);
  memset(&strm.avail_in, 0, 104);
  *a5 = 0;
  v32 = Length + 8 * v9;
  CFDataSetLength(a2, v32 + v12 + (v12 + 1000) / 0x3E8 + 12);
  MutableBytePtr = CFDataGetMutableBytePtr(a2);
  v14 = MutableBytePtr;
  v15 = &MutableBytePtr[Length];
  if (a4)
  {
    v16 = 0;
  }
  else
  {
    *((_DWORD *)v15 + 1) = bswap32(v12);
    v16 = &MutableBytePtr[Length];
    v15 += 8;
  }
  strm.next_in = BytePtr;
  strm.next_out = v15;
  strm.avail_in = v12;
  strm.avail_out = v12 + (v12 + 1000) / 0x3E8 + 12;
  memset(&strm.zalloc, 0, 24);
  if (deflateInit2_(&strm, -1, 8, 15, 8, 0, "1.2.12", 112))
  {
    OSKextLog(0, 131073, "zlib deflateInit failed.", v17, v18, v19, v20, v21, v31);
LABEL_11:
    CFDataSetLength(a2, Length);
    return 0;
  }
  if (deflate(&strm, 4) > 1)
  {
    OSKextLog(0, 131073, "zlib deflate failed.", v22, v23, v24, v25, v26, v31);
    deflateEnd(&strm);
    goto LABEL_11;
  }
  total_out = strm.total_out;
  if (LODWORD(strm.total_out) >= v12)
  {
    *a5 = 0;
  }
  else
  {
    *a5 = 1;
    if (a4)
    {
      *((_DWORD *)v14 + 8) = bswap32(Length);
      v28 = CFDataGetLength(theData);
      *((_DWORD *)v14 + 9) = bswap32(total_out);
      *((_DWORD *)v14 + 10) = bswap32(v28);
      v29 = "Compressed info dict from %u to %u bytes (%.2f%%).";
    }
    else
    {
      *(_DWORD *)v16 = bswap32(total_out);
      v29 = "Compressed executable from %u to %u bytes (%.2f%%).";
    }
    OSKextLog(a1, 134, v29, v22, v23, v24, v25, v26, v12);
    CFDataSetLength(a2, total_out + v32);
  }
  deflateEnd(&strm);
  return 1;
}

uint64_t __OSKextInitFromMkext(uint64_t a1, CFDictionaryRef theDict, const void *a3, const void *a4)
{
  const __CFString *Value;
  const __CFString *v9;
  const __CFAllocator *v10;
  CFURLRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFAllocator *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v37;

  *(_BYTE *)(a1 + 88) |= 8u;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("_MKEXTBundlePath"));
  if (Value)
  {
    v9 = Value;
    v10 = CFGetAllocator((CFTypeRef)a1);
    v11 = CFURLCreateWithFileSystemPath(v10, v9, kCFURLPOSIXPathStyle, 1u);
    *(_QWORD *)(a1 + 16) = v11;
    if (!v11)
      OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v37);
  }
  v17 = CFGetAllocator(theDict);
  *(_QWORD *)(a1 + 56) = CFDictionaryCreateMutableCopy(v17, 0, theDict);
  if (__OSKextCreateMkextInfo(a1))
  {
    if (a3)
      **(_QWORD **)(a1 + 80) = CFRetain(a3);
    *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) = CFRetain(a4);
    if (__OSKextProcessInfoDictionary(a1, 0, v23, v24, v25, v26, v27, v28))
      return __OSKextRecordKext(a1, v29, v30, v31, v32, v33, v34, v35);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, v37);
  }
  return 0;
}

uint64_t _IOHIDIsSerializable(uint64_t result)
{
  CFTypeRef v1;
  BOOL v2;
  mach_vm_address_t address;

  address = 0;
  if (result)
  {
    v1 = _IOHIDSerialize((CFTypeRef)result, &address);
    if (address)
      v2 = v1 == 0;
    else
      v2 = 1;
    if (v2)
    {
      return 0;
    }
    else
    {
      mach_vm_deallocate(*MEMORY[0x1E0C83DA0], address, (mach_vm_size_t)v1);
      return 1;
    }
  }
  return result;
}

uint64_t hid_pthread_attr_init(pthread_attr_t *a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  sched_param v9;

  v9 = 0;
  v6 = pthread_attr_init(a1);
  if ((_DWORD)v6
    || (pthread_attr_setschedpolicy(a1, a3), v6 = pthread_attr_getschedparam(a1, &v9), (_DWORD)v6)
    || (v9.sched_priority = a2, v6 = pthread_attr_setschedparam(a1, &v9), (_DWORD)v6))
  {
    v7 = v6;
    goto LABEL_5;
  }
  v7 = pthread_attr_setdetachstate(a1, 1);
  if ((_DWORD)v7)
LABEL_5:
    pthread_attr_destroy(a1);
  return v7;
}

NSObject *hid_dispatch_queue_create(const char *a1, NSObject *a2, NSObject *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return hid_dispatch_queue_create_with_context_destructor(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t hid_dispatch_pthread_root_queue_create()
{
  return _dispatch_pthread_root_queue_create_with_observer_hooks_4IOHID();
}

uint64_t IOHIDServiceFilterCreateWithClass(const __CFAllocator *a1, void *a2, uint64_t a3, const void *a4, int a5)
{
  id v10;
  const void *v11;
  Protocol *Protocol;
  uint64_t Private;
  uint64_t v14;
  const char *Uid;
  const char *v16;
  const char *v17;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD block[5];

  v10 = objc_msgSend(a2, sel_getUid("alloc"));
  if (!v10)
    return 0;
  v11 = v10;
  if (!objc_msgSend(v10, sel_getUid("initWithService:"), a3))
  {
    v19 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      IOHIDServiceFilterCreateWithClass_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  Protocol = objc_getProtocol("HIDServiceFilter");
  if (!Protocol)
  {
    v27 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      IOHIDServiceFilterCreateWithClass_cold_2(v27, v28, v29, v30, v31, v32, v33, v34);
    goto LABEL_22;
  }
  if (!class_conformsToProtocol((Class)a2, Protocol))
  {
    v35 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      IOHIDServiceFilterCreateWithClass_cold_3(v35, v36, v37, v38, v39, v40, v41, v42);
    goto LABEL_22;
  }
  Private = __IOHIDServiceFilterCreatePrivate(a1);
  if (!Private)
  {
LABEL_22:
    CFRelease(v11);
    return 0;
  }
  v14 = Private;
  *(_QWORD *)(Private + 96) = v11;
  *(_QWORD *)(Private + 104) = sel_getUid("propertyForKey:client:");
  *(_QWORD *)(v14 + 112) = sel_getUid("setProperty:forKey:client:");
  *(_QWORD *)(v14 + 120) = sel_getUid("filterEvent:");
  *(_QWORD *)(v14 + 128) = sel_getUid("filterEventMatching:event:forClient:");
  *(_QWORD *)(v14 + 136) = sel_getUid("setCancelHandler:");
  *(_QWORD *)(v14 + 144) = sel_getUid("activate");
  *(_QWORD *)(v14 + 152) = sel_getUid("cancel");
  Uid = sel_getUid("setDispatchQueue:");
  if (class_respondsToSelector((Class)a2, Uid))
    *(_QWORD *)(v14 + 160) = sel_getUid("setDispatchQueue:");
  v16 = sel_getUid("setEventDispatcher:");
  if (class_respondsToSelector((Class)a2, v16))
    *(_QWORD *)(v14 + 168) = sel_getUid("setEventDispatcher:");
  v17 = sel_getUid("clientNotification:added:");
  if (class_respondsToSelector((Class)a2, v17))
    *(_QWORD *)(v14 + 176) = sel_getUid("clientNotification:added:");
  *(_DWORD *)(v14 + 40) = a5;
  *(_QWORD *)(v14 + 48) = a3;
  *(_QWORD *)(v14 + 32) = _IOHIDServiceCopyDispatchQueue(a3);
  *(_QWORD *)(v14 + 80) = a4;
  if (a4)
    CFRetain(a4);
  CFRetain((CFTypeRef)v14);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IOHIDServiceFilterCreateWithClass_block_invoke;
  block[3] = &__block_descriptor_tmp_20;
  block[4] = v14;
  *(_QWORD *)(v14 + 64) = dispatch_block_create((dispatch_block_flags_t)0, block);
  return v14;
}

uint64_t IOHIDServiceFilterGetTypeID()
{
  uint64_t result;

  result = __kIOHIDServiceFilterTypeID;
  if (!__kIOHIDServiceFilterTypeID)
  {
    pthread_once(&__systemFilterClientTypeInit_0, (void (*)(void))__IOHIDServiceFilterRegister);
    return __kIOHIDServiceFilterTypeID;
  }
  return result;
}

uint64_t __IOHIDServiceFilterRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kIOHIDServiceFilterTypeID = result;
  return result;
}

uint64_t IOHIDServiceFilterGetMatchScore(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t IOHIDServiceFilterCompare(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  BOOL v4;
  BOOL v5;
  uint64_t v6;

  v2 = *(_DWORD *)(a1 + 40);
  v3 = *(_DWORD *)(a2 + 40);
  v4 = v2 == v3;
  v5 = v2 <= v3;
  v6 = -1;
  if (v5)
    v6 = 1;
  if (v4)
    return 0;
  else
    return v6;
}

id IOHIDServiceFilterFilterCopyMatchingEvent(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  id v7;
  const __CFString *v8;
  NSObject *v9;
  int Type;
  uint64_t SenderID;
  uint64_t v12;
  _DWORD v14[2];
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  const __CFString *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = *(void **)(a1 + 96);
  v7 = a2;
  if (v6)
    v7 = objc_msgSend(v6, *(SEL *)(a1 + 128), a3, a2, a4);
  if (!v7)
  {
    v8 = _IOHIDEventDebugInfo(a2);
    v9 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      Type = IOHIDEventGetType((uint64_t)a2);
      SenderID = _IOHIDServiceGetSenderID(*(_QWORD *)(a1 + 48));
      v12 = *(_QWORD *)(a1 + 88);
      v14[0] = 67109890;
      v14[1] = Type;
      v15 = 2048;
      v16 = SenderID;
      v17 = 2112;
      v18 = v8;
      v19 = 2112;
      v20 = v12;
      _os_log_impl(&dword_18AAAF000, v9, OS_LOG_TYPE_INFO, "Copy Event filtered type:%d sender:0x%llx eventInfo:(%@) service filter:%@", (uint8_t *)v14, 0x26u);
    }
    CFRelease(v8);
  }
  return v7;
}

uint64_t IOHIDServiceFilterSetOutputEvent(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v2)(void);

  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v2 = *(uint64_t (**)(void))(*(_QWORD *)result + 104);
    if (v2)
      return v2();
  }
  return result;
}

uint64_t IOHIDServiceFilterGetStateMask(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

CFMutableDictionaryRef IOHIDServiceClientCopyProperties(uint64_t *a1, const __CFArray *a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  CFMutableArrayRef v7;
  CFMutableArrayRef v8;
  uint64_t v9;
  __CFDictionary *v10;
  CFMutableDictionaryRef v11;
  _QWORD v13[6];
  _QWORD context[5];
  _QWORD v15[7];

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v6 = Mutable;
  v7 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
  if (!v7)
  {
    CFRelease(v6);
    return 0;
  }
  v8 = v7;
  v9 = MEMORY[0x1E0C809B0];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = __IOHIDServiceClientCopyProperties_block_invoke;
  v15[3] = &__block_descriptor_tmp_16;
  v15[4] = a1;
  v15[5] = v6;
  v15[6] = v7;
  _IOHIDCFArrayApplyBlock(a2, v15);
  if (CFArrayGetCount(v8))
  {
    v10 = (__CFDictionary *)_IOHIDEventSystemClientCopyPropertiesForService(a1[1], (IOHIDServiceClientRef)a1, v8);
    if (v10)
    {
      v11 = v10;
      context[0] = v9;
      context[1] = 0x40000000;
      context[2] = __IOHIDServiceClientCopyProperties_block_invoke_2;
      context[3] = &__block_descriptor_tmp_18_0;
      context[4] = v10;
      _IOHIDCFDictionaryApplyBlock(v6, context);
    }
    else
    {
      CFRetain(v6);
      v11 = v6;
    }
    v13[0] = v9;
    v13[1] = 0x40000000;
    v13[2] = __IOHIDServiceClientCopyProperties_block_invoke_3;
    v13[3] = &__block_descriptor_tmp_19_1;
    v13[4] = v11;
    v13[5] = a1;
    _IOHIDCFArrayApplyBlock(a2, v13);
  }
  else
  {
    CFRetain(v6);
    v11 = v6;
  }
  if (!CFDictionaryGetCount(v11))
  {
    CFRelease(v11);
    v11 = 0;
  }
  CFRelease(v6);
  CFRelease(v8);
  return v11;
}

uint64_t IOHIDServiceClientRegisterRemovalBlock(_QWORD *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[5] = _Block_copy(a2);
  a1[6] = a3;
  a1[7] = a4;
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDServiceClientCopyMatchingEvent(__IOHIDServiceClient *service, const UInt8 *a2)
{
  return _IOHIDEventSystemClientCopyMatchingEventForService(*((_QWORD *)service + 1), service, a2);
}

uint64_t IOHIDServiceClientSetElementValue(__IOHIDServiceClient *service, int a2, int a3, int a4)
{
  return _IOHIDEventSystemClientSetElementValueForService(*((_QWORD *)service + 1), service, a2, a3, a4);
}

__CFString *IOHIDServiceClientCopyDescription(uint64_t a1)
{
  __CFString *Mutable;
  __CFString *v3;
  const void *v4;
  CFTypeID v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  const void *v14;
  int v15;
  const char *v16;
  CFTypeRef v17;
  const void *v18;
  CFTypeRef v19;
  const void *v20;
  CFTypeRef v21;
  const void *v22;
  CFTypeRef v23;
  const void *v24;
  CFTypeRef v25;
  const void *v26;
  CFTypeRef v27;
  const void *v28;
  CFTypeRef v29;
  const void *v30;
  CFTypeRef v31;
  const void *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  CFTypeID v35;
  NSObject *v36;
  const __CFNumber *v37;
  const __CFNumber *v38;
  CFTypeID v39;
  NSObject *v40;
  const __CFNumber *v41;
  const __CFNumber *v42;
  CFTypeID v43;
  NSObject *v44;
  CFTypeRef v45;
  const void *v46;
  CFTypeRef v47;
  const void *v48;
  const __CFArray *v49;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v52;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v55;
  const __CFNumber *Value;
  const __CFNumber *v57;
  CFTypeID v58;
  const __CFNumber *v59;
  const __CFNumber *v60;
  CFTypeID v61;
  NSObject *v62;
  uint64_t v64;
  uint64_t valuePtr;

  valuePtr = 0;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = Mutable;
  if (Mutable)
  {
    _IOHIDStringAppendIndendationAndFormat(Mutable, 0, CFSTR("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
    v4 = *(const void **)(a1 + 16);
    if (v4 && (v5 = CFGetTypeID(v4), v5 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(*(CFNumberRef *)(a1 + 16), kCFNumberSInt64Type, &valuePtr);
    }
    else
    {
      v6 = _IOHIDLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        IOHIDServiceClientCopyDescription_cold_5(a1 + 16, v6, v7, v8, v9, v10, v11, v12);
    }
    _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s 0x%016llx\n"), "SenderID:", valuePtr);
    if (*(_QWORD *)(a1 + 64))
    {
      _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s True\n"), "Virtual:");
    }
    else
    {
      v13 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("Built-In"));
      if (v13)
      {
        v14 = v13;
        v15 = CFEqual(v13, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
        v16 = "True";
        if (!v15)
          v16 = "False";
        _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %s\n"), "BuiltIn:", v16);
        CFRelease(v14);
      }
      v17 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("Manufacturer"));
      if (v17)
      {
        v18 = v17;
        _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %@\n"), "Manufacturer:", v17);
        CFRelease(v18);
      }
      v19 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("Product"));
      if (v19)
      {
        v20 = v19;
        _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %@\n"), "Product:", v19);
        CFRelease(v20);
      }
      v21 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("Transport"));
      if (v21)
      {
        v22 = v21;
        _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %@\n"), "Transport:", v21);
        CFRelease(v22);
      }
      v23 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("LocationID"));
      if (v23)
      {
        v24 = v23;
        AppendUnsignedIntOrCFType(v3, v23, (uint64_t)"LocationID:");
        CFRelease(v24);
      }
      v25 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("VendorID"));
      if (v25)
      {
        v26 = v25;
        AppendUnsignedIntOrCFType(v3, v25, (uint64_t)"VendorID:");
        CFRelease(v26);
      }
      v27 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("ProductID"));
      if (v27)
      {
        v28 = v27;
        AppendUnsignedIntOrCFType(v3, v27, (uint64_t)"ProductID:");
        CFRelease(v28);
      }
      v29 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("CountryCode"));
      if (v29)
      {
        v30 = v29;
        AppendUnsignedIntOrCFType(v3, v29, (uint64_t)"CountryCode:");
        CFRelease(v30);
      }
      v31 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("StandardType"));
      if (v31)
      {
        v32 = v31;
        AppendUnsignedIntOrCFType(v3, v31, (uint64_t)"StandardType:");
        CFRelease(v32);
      }
      v33 = (const __CFNumber *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("ReportInterval"));
      if (v33)
      {
        v34 = v33;
        v35 = CFGetTypeID(v33);
        if (v35 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v34, kCFNumberSInt64Type, &valuePtr);
          _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %llu us\n"), "ReportInterval:", valuePtr);
        }
        else
        {
          v36 = _IOHIDLog();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            IOHIDServiceClientCopyDescription_cold_4();
          _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s ERROR\n"), "ReportInterval:", v64);
        }
        CFRelease(v34);
      }
      v37 = (const __CFNumber *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("SampleInterval"));
      if (v37)
      {
        v38 = v37;
        v39 = CFGetTypeID(v37);
        if (v39 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v38, kCFNumberSInt64Type, &valuePtr);
          _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %llu us\n"), "SampleInterval:", valuePtr);
        }
        else
        {
          v40 = _IOHIDLog();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            IOHIDServiceClientCopyDescription_cold_3();
          _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s ERROR\n"), "SampleInterval:", v64);
        }
        CFRelease(v38);
      }
      v41 = (const __CFNumber *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("BatchInterval"));
      if (v41)
      {
        v42 = v41;
        v43 = CFGetTypeID(v41);
        if (v43 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v42, kCFNumberSInt64Type, &valuePtr);
          _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s %llu us\n"), "BatchInterval:", valuePtr);
        }
        else
        {
          v44 = _IOHIDLog();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            IOHIDServiceClientCopyDescription_cold_2();
          _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s ERROR\n"), "BatchInterval:", v64);
        }
        CFRelease(v42);
      }
      v45 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("PrimaryUsagePage"));
      if (v45)
      {
        v46 = v45;
        AppendUnsignedIntOrCFType(v3, v45, (uint64_t)"PrimaryUsagePage:");
        CFRelease(v46);
      }
      v47 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("PrimaryUsage"));
      if (v47)
      {
        v48 = v47;
        AppendUnsignedIntOrCFType(v3, v47, (uint64_t)"PrimaryUsage:");
        CFRelease(v48);
      }
      v49 = (const __CFArray *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, CFSTR("DeviceUsagePairs"));
      if (v49 && (TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(v49)))
      {
        _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s\n"), "DeviceUsagePairs:");
        Count = CFArrayGetCount(v49);
        if (Count >= 1)
        {
          v52 = Count;
          for (i = 0; i != v52; ++i)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v49, i);
            if (ValueAtIndex)
            {
              v55 = ValueAtIndex;
              if (i)
                _IOHIDStringAppendIndendationAndFormat(v3, 1, CFSTR("---------------------------\n"));
              Value = (const __CFNumber *)CFDictionaryGetValue(v55, CFSTR("DeviceUsagePage"));
              if (Value)
              {
                v57 = Value;
                v58 = CFGetTypeID(Value);
                if (v58 == CFNumberGetTypeID())
                {
                  CFNumberGetValue(v57, kCFNumberSInt64Type, &valuePtr);
                  _IOHIDStringAppendIndendationAndFormat(v3, 1, CFSTR("%-20.20s %llu\n"), "DeviceUsagePage:", valuePtr);
                }
              }
              v59 = (const __CFNumber *)CFDictionaryGetValue(v55, CFSTR("DeviceUsage"));
              if (v59)
              {
                v60 = v59;
                v61 = CFGetTypeID(v59);
                if (v61 == CFNumberGetTypeID())
                {
                  CFNumberGetValue(v60, kCFNumberSInt64Type, &valuePtr);
                  _IOHIDStringAppendIndendationAndFormat(v3, 1, CFSTR("%-20.20s %llu\n"), "DeviceUsage:", valuePtr);
                }
              }
            }
          }
        }
        CFRelease(v49);
      }
      else
      {
        v62 = _IOHIDLog();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
          IOHIDServiceClientCopyDescription_cold_1();
        _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("%-20.20s ERROR\n"), "DeviceUsagePairs:");
      }
    }
    _IOHIDStringAppendIndendationAndFormat(v3, 0, CFSTR("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
  }
  return v3;
}

void AppendUnsignedIntOrCFType(__CFString *a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeID v6;
  uint64_t valuePtr;

  v6 = CFGetTypeID(cf);
  if (v6 == CFNumberGetTypeID())
  {
    valuePtr = 0;
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
    _IOHIDStringAppendIndendationAndFormat(a1, 0, CFSTR("%-20.20s %llu\n"), a3, valuePtr);
  }
  else
  {
    _IOHIDStringAppendIndendationAndFormat(a1, 0, CFSTR("%-20.20s %@\n"), a3, cf);
  }
}

uint64_t IOHIDServiceClientFastPathCopyEvent(uint64_t a1)
{
  uint64_t result;
  void (*v2)(void);
  uint64_t v3;

  v3 = 0;
  result = *(_QWORD *)(a1 + 104);
  if (result)
  {
    v2 = *(void (**)(void))(*(_QWORD *)result + 64);
    if (v2)
    {
      v2();
      return v3;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IOHIDServiceClientFastPathCopyProperty(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(a1 + 104);
  if (v1 && (v2 = *(uint64_t (**)(void))(*(_QWORD *)v1 + 48)) != 0)
    return v2();
  else
    return 0;
}

uint64_t IOHIDServiceClientFastPathSetProperty(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v2)(void);

  result = *(_QWORD *)(a1 + 104);
  if (result)
  {
    v2 = *(uint64_t (**)(void))(*(_QWORD *)result + 56);
    if (v2)
      LOBYTE(result) = v2();
    else
      LOBYTE(result) = 0;
  }
  return result;
}

uint64_t _IOHIDVirtualServiceClientSetOputputEvent(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD *, uint64_t);

  v2 = a1[8];
  if (v2 && (v3 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(v2 + 40)) != 0)
    return v3(a1[9], a1[10], a1, a2);
  else
    return 3758097095;
}

uint64_t _IOHIDVirtualServiceClientCopyMatchingEvent(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD *, uint64_t);

  v2 = a1[8];
  if (v2 && (v3 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(v2 + 48)) != 0)
    return v3(a1[9], a1[10], a1, a2);
  else
    return 0;
}

void __NotificationApplier(uint64_t a1, OSQueueHead *a2)
{
  IOHIDNotificationInvalidate(a2, 0);
}

uint64_t _IOHIDEventSystemConnectionGetDispatchQueue(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t _IOHIDEventSystemConnectionGetReplyPort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

__n128 IOHIDEventSystemConnectionGetAuditToken(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  if (a2)
  {
    result = *(__n128 *)(a1 + 196);
    v3 = *(_OWORD *)(a1 + 212);
    *(__n128 *)a2 = result;
    *(_OWORD *)(a2 + 16) = v3;
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionFilterEvent(mach_port_t *cf, uint64_t a2, uint64_t a3)
{
  const __CFAllocator *v6;
  const void *RegistryID;
  const __CFData *v8;
  const __CFAllocator *v9;
  __CFData *DataInternal;
  __CFData *v11;
  const __CFAllocator *v12;
  const __CFData *v13;
  const __CFData *v14;
  mach_port_t v15;
  _QWORD *v16;
  const UInt8 *BytePtr;
  int Length;
  const UInt8 *v19;
  int v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  const __CFString *v25;
  NSObject *v26;
  uint64_t v27;
  int Type;
  uint64_t SenderID;
  uint64_t v31;
  unsigned int v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  const __CFString *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  if (a2)
  {
    v6 = CFGetAllocator(cf);
    RegistryID = (const void *)IOHIDServiceGetRegistryID(a2);
    v8 = (const __CFData *)_IOHIDCreateBinaryData(v6, RegistryID);
  }
  else
  {
    v8 = 0;
  }
  v9 = CFGetAllocator(cf);
  DataInternal = IOHIDEventCreateDataInternal(v9, a3);
  if (DataInternal)
  {
    v11 = DataInternal;
    v12 = CFGetAllocator(cf);
    v13 = (const __CFData *)_IOHIDCreateBinaryData(v12, v11);
    if (v13)
    {
      v14 = v13;
      v31 = a2;
      if (!cf[112])
      {
        os_unfair_recursive_lock_lock_with_options();
        v15 = cf[10];
        v16 = (_QWORD *)a3;
        if (v8)
        {
          BytePtr = CFDataGetBytePtr(v8);
          Length = CFDataGetLength(v8);
        }
        else
        {
          BytePtr = 0;
          Length = 0;
        }
        v19 = CFDataGetBytePtr(v14);
        v20 = CFDataGetLength(v14);
        v21 = iohideventsystem_client_dispatch_event_filter(v15, (uint64_t)BytePtr, Length, (uint64_t)v19, v20, (int *)&v32, 0x10u);
        os_unfair_recursive_lock_unlock();
        if (v21)
        {
          if (v21 == 268451843)
          {
            v22 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
            {
              v23 = *((_QWORD *)cf + 21);
              *(_DWORD *)buf = 136315394;
              v34 = v23;
              v35 = 1024;
              v36 = 268451843;
              _os_log_impl(&dword_18AAAF000, v22, OS_LOG_TYPE_INFO, "%s: iohideventsystem_client_dispatch_event_filter:0x%x", buf, 0x12u);
            }
          }
          else
          {
            v24 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              _IOHIDEventSystemConnectionFilterEvent_cold_1();
          }
          __IOHIDEventSystemConnectionCheckServerStatus(v21, (uint64_t)cf);
        }
        else
        {
          ++cf[73];
        }
        if (v32)
        {
          v25 = _IOHIDEventDebugInfo(v16);
          v26 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
          {
            v27 = *((_QWORD *)cf + 21);
            Type = IOHIDEventGetType((uint64_t)v16);
            SenderID = v31;
            if (v31)
              SenderID = _IOHIDServiceGetSenderID(v31);
            *(_DWORD *)buf = 136315906;
            v34 = v27;
            v35 = 1024;
            v36 = Type;
            v37 = 2048;
            v38 = SenderID;
            v39 = 2112;
            v40 = v25;
            _os_log_impl(&dword_18AAAF000, v26, OS_LOG_TYPE_INFO, "%s: Filtered event type:%d sender:%#llx eventInfo:(%@)", buf, 0x26u);
          }
          CFRelease(v25);
        }
      }
      CFRelease(v14);
    }
    CFRelease(v11);
  }
  if (v8)
    CFRelease(v8);
  return v32;
}

void _IOHIDEventSystemConnectionRegisterEventFilter(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 260) = a2;
  if (v3)
    _IOHIDEventSystemRegisterEventFilter(v3, (void *)a1);
}

void _IOHIDEventSystemConnectionUnregisterEventFilter(_QWORD *a1)
{
  uint64_t v2;

  v2 = a1[1];
  if (v2)
    _IOHIDEventSystemUnregisterEventFilter(v2, a1);
}

uint64_t _IOHIDEventSystemConnectionGetEventFilterPriority(uint64_t a1)
{
  return *(unsigned int *)(a1 + 260);
}

uint64_t _IOHIDEventSystemConnectionEventFilterCompare(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  BOOL v4;
  BOOL v5;
  uint64_t v6;

  v2 = *(_DWORD *)(a1 + 260);
  v3 = *(_DWORD *)(a2 + 260);
  v4 = v2 == v3;
  v5 = v2 <= v3;
  v6 = -1;
  if (v5)
    v6 = 1;
  if (v4)
    return 0;
  else
    return v6;
}

uint64_t _IOHIDEventSystemConnectionGetPID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t _IOHIDEventSystemConnectionRegisterPropertyChangedNotification(_QWORD *a1, const void *a2)
{
  __CFSet *Mutable;
  const __CFAllocator *v5;

  os_unfair_recursive_lock_lock_with_options();
  Mutable = (__CFSet *)a1[17];
  if (Mutable
    || (v5 = CFGetAllocator(a1), Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E0C9B3B0]), (a1[17] = Mutable) != 0))
  {
    CFSetAddValue(Mutable, a2);
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemConnectionUnregisterPropertyChangedNotification(uint64_t a1, const void *a2)
{
  __CFSet *v4;

  os_unfair_recursive_lock_lock_with_options();
  v4 = *(__CFSet **)(a1 + 136);
  if (v4)
    CFSetRemoveValue(v4, a2);
  return os_unfair_recursive_lock_unlock();
}

const char *IOHIDEventSystemConnectionGetTypeString(unsigned int a1)
{
  if (a1 > 4)
    return "Invalid";
  else
    return off_1E2003688[a1];
}

CFMutableDictionaryRef _IOHIDEventSystemConnectionCopyRecord(uint64_t a1)
{
  const __CFAllocator *v2;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  CFStringRef v11;
  const __CFAllocator *v12;
  CFStringRef v13;
  CFStringRef v14;
  CFMutableArrayRef v15;
  CFMutableArrayRef v16;
  CFMutableDictionaryRef v17;
  CFMutableDictionaryRef v18;
  const __CFAllocator *v19;
  CFMutableArrayRef v20;
  CFMutableArrayRef v21;
  const __CFData *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const __CFAllocator *v26;
  _BYTE *v27;
  __CFDictionary *v28;
  __CFDictionary *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  char *v37;
  const __CFAllocator *v38;
  CFStringRef v39;
  uint64_t v40;
  id v41;
  const void *v42;
  uint64_t v43;
  CFMutableDictionaryRef v44;
  CFMutableDictionaryRef v45;
  _QWORD v47[5];

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = Mutable;
  if (Mutable)
  {
    _IOHIDDictionaryAddSInt32(Mutable, CFSTR("Type"), *(_DWORD *)(a1 + 176));
    _IOHIDDictionaryAddSInt32(v4, CFSTR("PID"), *(_DWORD *)(a1 + 88));
    v5 = *(const void **)(a1 + 144);
    if (v5)
      CFDictionarySetValue(v4, CFSTR("Caller"), v5);
    v6 = *(const void **)(a1 + 152);
    if (v6)
      CFDictionarySetValue(v4, CFSTR("ProcessName"), v6);
    v7 = *(const void **)(a1 + 160);
    if (v7)
      CFDictionarySetValue(v4, CFSTR("UUID"), v7);
    v8 = *(const void **)(a1 + 184);
    if (v8)
      CFDictionarySetValue(v4, CFSTR("Attributes"), v8);
    _IOHIDDictionaryAddSInt32(v4, CFSTR("State"), *(_DWORD *)(a1 + 264));
    _IOHIDDictionaryAddSInt32(v4, CFSTR("DroppedEventCount"), *(_DWORD *)(a1 + 296));
    _IOHIDDictionaryAddSInt64(v4, CFSTR("DroppedEventMask"), *(_QWORD *)(a1 + 304));
    _IOHIDDictionaryAddSInt32(v4, CFSTR("EventFilteredCount"), *(_DWORD *)(a1 + 288));
    _IOHIDDictionaryAddSInt64(v4, CFSTR("EventFilterMask"), *(_QWORD *)(a1 + 280));
    _IOHIDDictionaryAddSInt32(v4, CFSTR("EventFilterTimeoutCount"), *(_DWORD *)(a1 + 292));
    _IOHIDDictionaryAddSInt32(v4, CFSTR("ActivityState"), *(_DWORD *)(a1 + 400));
    _IOHIDDictionaryAddSInt32(v4, CFSTR("activityStateChangeCount"), *(_DWORD *)(a1 + 404));
    _IOHIDDictionaryAddSInt64(v4, CFSTR("IdleNotificationTime"), *(_QWORD *)(a1 + 408));
    if (*(_DWORD *)(a1 + 296))
    {
      v9 = CFGetAllocator((CFTypeRef)a1);
      v10 = _IOHIDCreateTimeString(v9, (time_t *)(a1 + 344));
      if (v10)
      {
        v11 = v10;
        CFDictionarySetValue(v4, CFSTR("FirstDroppedEventTime"), v10);
        CFRelease(v11);
      }
      v12 = CFGetAllocator((CFTypeRef)a1);
      v13 = _IOHIDCreateTimeString(v12, (time_t *)(a1 + 328));
      if (v13)
      {
        v14 = v13;
        CFDictionarySetValue(v4, CFSTR("LastDroppedEventTime"), v13);
        CFRelease(v14);
      }
    }
    _IOHIDDictionaryAddSInt64(v4, CFSTR("MaxEventLatency"), *(_QWORD *)(a1 + 360));
    _IOHIDDictionaryAddSInt64(v4, CFSTR("MaxPropertyNotificationHandlingTime"), *(_QWORD *)(a1 + 376));
    v15 = _IOHIDEventSystemConnectionCopyEventLog((_QWORD *)a1);
    if (v15)
    {
      v16 = v15;
      CFDictionaryAddValue(v4, CFSTR("EventLog"), v15);
      CFRelease(v16);
    }
    v17 = _IOHIDEventSystemConnectionCopyEventCounts((_QWORD *)a1);
    if (v17)
    {
      v18 = v17;
      CFDictionaryAddValue(v4, CFSTR("EventTypeCounts"), v17);
      CFRelease(v18);
    }
    if (*(_QWORD *)(a1 + 432))
    {
      v19 = CFGetAllocator((CFTypeRef)a1);
      v20 = CFArrayCreateMutable(v19, 50, MEMORY[0x1E0C9B378]);
      if (v20)
      {
        v21 = v20;
        os_unfair_recursive_lock_lock_with_options();
        v22 = *(const __CFData **)(a1 + 432);
        v47[0] = MEMORY[0x1E0C809B0];
        v47[1] = 0x40000000;
        v47[2] = ____IOHIDEventSystemConnectionSerializeActivity_block_invoke;
        v47[3] = &__block_descriptor_tmp_146_0;
        v47[4] = a1;
        _IOHIDSimpleQueueApplyBlock(v22, (uint64_t)v47, (uint64_t)v21);
        os_unfair_recursive_lock_unlock();
        CFDictionaryAddValue(v4, CFSTR("ActivityLog"), v21);
        CFRelease(v21);
      }
    }
    v23 = (const void *)*MEMORY[0x1E0C9AE50];
    v24 = (const void *)*MEMORY[0x1E0C9AE40];
    if (*(_DWORD *)(a1 + 256))
      v25 = (const void *)*MEMORY[0x1E0C9AE50];
    else
      v25 = (const void *)*MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(v4, CFSTR("ProtectedServicesDisabled"), v25);
    v26 = CFGetAllocator((CFTypeRef)a1);
    v27 = *(_BYTE **)(a1 + 240);
    v28 = CFDictionaryCreateMutable(v26, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v28)
    {
      v29 = v28;
      if ((*v27 & 1) != 0)
        v30 = v23;
      else
        v30 = v24;
      CFDictionarySetValue(v28, CFSTR("com.apple.private.hid.client.admin"), v30);
      if ((*v27 & 2) != 0)
        v31 = v23;
      else
        v31 = v24;
      CFDictionarySetValue(v29, CFSTR("com.apple.private.hid.client.event-monitor"), v31);
      if ((*v27 & 4) != 0)
        v32 = v23;
      else
        v32 = v24;
      CFDictionarySetValue(v29, CFSTR("com.apple.private.hid.client.event-filter"), v32);
      if ((*v27 & 8) != 0)
        v33 = v23;
      else
        v33 = v24;
      CFDictionarySetValue(v29, CFSTR("com.apple.private.hid.client.event-dispatch"), v33);
      if ((*v27 & 0x10) != 0)
        v34 = v23;
      else
        v34 = v24;
      CFDictionarySetValue(v29, CFSTR("com.apple.private.hid.client.service-protected"), v34);
      if ((*v27 & 0x20) != 0)
        v35 = v23;
      else
        v35 = v24;
      CFDictionarySetValue(v29, CFSTR("com.apple.private.hid.client.motion-event-privileged"), v35);
      if ((*v27 & 0x40) != 0)
        v36 = v23;
      else
        v36 = v24;
      CFDictionarySetValue(v29, CFSTR("com.apple.private.hid.client.debug-tool"), v36);
      CFDictionaryAddValue(v4, CFSTR("EventSystemEntitlements"), v29);
      CFRelease(v29);
    }
    if (*(_QWORD *)(a1 + 248))
    {
      v37 = (char *)MEMORY[0x18D773068]();
      v38 = CFGetAllocator((CFTypeRef)a1);
      v39 = CFStringCreateWithCString(v38, v37, 0);
      CFDictionaryAddValue(v4, CFSTR("ConnectionEntitlements"), v39);
      CFRelease(v39);
      free(v37);
    }
    v40 = *(_QWORD *)(a1 + 440);
    if (v40)
    {
      v41 = IOHIDConnectionFilterCopyProperty(v40, (uint64_t)CFSTR("ConnectionPluginDebug"));
      if (v41)
      {
        v42 = v41;
        CFDictionaryAddValue(v4, CFSTR("ConnectionPluginDebug"), v41);
        CFRelease(v42);
      }
      else
      {
        CFDictionaryAddValue(v4, CFSTR("ConnectionPluginDebug"), &stru_1E2005170);
      }
    }
    v43 = *(_QWORD *)(a1 + 24);
    if (v43)
    {
      v44 = _IOHIDEventQueueSerializeState(v43);
      if (v44)
      {
        v45 = v44;
        CFDictionarySetValue(v4, CFSTR("QueueState"), v44);
        CFRelease(v45);
      }
    }
    CFSetGetCount(*(CFSetRef *)(a1 + 80));
  }
  return v4;
}

CFMutableArrayRef _IOHIDEventSystemConnectionCopyEventLog(_QWORD *a1)
{
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  const __CFData *v4;
  _QWORD v6[5];

  if (!a1[48])
    return 0;
  v2 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v2, 10, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    os_unfair_recursive_lock_lock_with_options();
    v4 = (const __CFData *)a1[48];
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = ___IOHIDEventSystemConnectionCopyEventLog_block_invoke;
    v6[3] = &__block_descriptor_tmp_96;
    v6[4] = a1;
    _IOHIDSimpleQueueApplyBlock(v4, (uint64_t)v6, (uint64_t)Mutable);
    os_unfair_recursive_lock_unlock();
  }
  return Mutable;
}

CFMutableDictionaryRef _IOHIDEventSystemConnectionCopyEventCounts(_QWORD *a1)
{
  const __CFAllocator *v2;
  CFMutableDictionaryRef Mutable;
  uint64_t i;
  const __CFString *Name;

  v2 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    for (i = 0; i != 43; ++i)
    {
      if (*(_DWORD *)(a1[49] + 4 * i))
      {
        Name = IOHIDEventTypeGetName(i);
        _IOHIDDictionaryAddSInt32(Mutable, Name, *(_DWORD *)(a1[49] + 4 * i));
      }
    }
    if (!CFDictionaryGetCount(Mutable))
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

uint64_t _IOHIDEventSystemConnectionRecordServiceChanged(uint64_t result)
{
  uint64_t v1;

  if (!*(_DWORD *)(result + 448))
  {
    v1 = result;
    os_unfair_recursive_lock_lock_with_options();
    iohideventsystem_client_dispatch_service_records_changed(*(_DWORD *)(v1 + 40));
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionRegisterRecordServiceChanged(_QWORD *a1)
{
  uint64_t result;

  result = a1[1];
  if (result)
    return _IOHIDEventSystemRegisterRecordServiceChanged(result, a1);
  return result;
}

uint64_t _IOHIDEventSystemConnectionUnregisterRecordServiceChanged(_QWORD *a1)
{
  uint64_t result;

  result = a1[1];
  if (result)
    return _IOHIDEventSystemUnregisterRecordServiceChanged(result, a1);
  return result;
}

uint64_t _IOHIDEventSystemConnectionRecordClientChanged(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(result + 448))
  {
    v1 = result;
    os_unfair_recursive_lock_lock_with_options();
    v2 = iohideventsystem_client_dispatch_client_records_changed(*(_DWORD *)(v1 + 40));
    v3 = v2;
    if ((v2 - 268435459) < 2)
      goto LABEL_5;
    if (!v2)
      return os_unfair_recursive_lock_unlock();
    if (v2 == 268451843)
    {
LABEL_5:
      v4 = _IOHIDLogCategory(9u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v5 = *(_QWORD *)(v1 + 168);
        v7 = 136315394;
        v8 = v5;
        v9 = 1024;
        v10 = v3;
        _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_INFO, "%s: iohideventsystem_client_dispatch_client_records_changed:0x%x", (uint8_t *)&v7, 0x12u);
      }
    }
    else
    {
      v6 = _IOHIDLogCategory(9u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        _IOHIDEventSystemConnectionRecordClientChanged_cold_1();
    }
    __IOHIDEventSystemConnectionCheckServerStatus(v3, v1);
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionRegisterRecordClientChanged(_QWORD *a1)
{
  uint64_t result;

  result = a1[1];
  if (result)
    return _IOHIDEventSystemRegisterRecordClientChanged(result, a1);
  return result;
}

uint64_t _IOHIDEventSystemConnectionUnregisterRecordClientChanged(_QWORD *a1)
{
  uint64_t result;

  result = a1[1];
  if (result)
    return _IOHIDEventSystemUnregisterRecordClientChanged(result, a1);
  return result;
}

uint64_t _IOHIDEventSystemConnectionLogEvent(_QWORD *a1, uint64_t a2)
{
  const __CFData *v3;
  const __CFAllocator *v4;
  uint64_t Type;
  timeval v7;

  v7.tv_sec = 0;
  *(_QWORD *)&v7.tv_usec = 0;
  Type = IOHIDEventGetType(a2);
  gettimeofday(&v7, 0);
  os_unfair_recursive_lock_lock_with_options();
  v3 = (const __CFData *)a1[48];
  if (v3 || (v4 = CFGetAllocator(a1), v3 = _IOHIDSimpleQueueCreate(v4, 24, 10), (a1[48] = v3) != 0))
    _IOHIDSimpleQueueEnqueue(v3, &Type, 1);
  ++*(_DWORD *)(a1[49] + 4 * Type);
  return os_unfair_recursive_lock_unlock();
}

void _IOHIDEventSystemConnectionRemoveVirtualService(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  const void *Value;
  const void *v7;
  NSObject *EnumerationQueue;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const void *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = _IOHIDLogCategory(9u);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 168);
    *(_DWORD *)buf = 136315394;
    v11 = v5;
    v12 = 2048;
    v13 = a2;
    _os_log_impl(&dword_18AAAF000, v4, OS_LOG_TYPE_DEFAULT, "%s: HIDVS ID:%llx destroy", buf, 0x16u);
  }
  if (a2)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 272), a2);
    if (Value)
    {
      v7 = Value;
      CFRetain(Value);
      EnumerationQueue = _IOHIDEventSystemGetEnumerationQueue(*(_QWORD *)(a1 + 8));
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = ___IOHIDEventSystemConnectionRemoveVirtualService_block_invoke;
      block[3] = &__block_descriptor_tmp_99;
      block[4] = v7;
      dispatch_async(EnumerationQueue, block);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 272), a2);
    }
  }
}

uint64_t __IOHIDServiceVirtualSetOutputEventCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t SenderID;
  const __CFAllocator *v7;
  __CFData *DataInternal;
  __CFData *v9;
  const __CFAllocator *v10;
  const __CFData *v11;
  const __CFData *v12;
  mach_port_t v13;
  const UInt8 *BytePtr;
  int Length;
  NSObject *v16;
  uint64_t v17;
  unsigned int v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = 3758097085;
  SenderID = _IOHIDServiceGetSenderID(a1);
  v19 = -536870212;
  v7 = CFGetAllocator((CFTypeRef)a2);
  DataInternal = IOHIDEventCreateDataInternal(v7, a3);
  if (DataInternal)
  {
    v9 = DataInternal;
    v10 = CFGetAllocator((CFTypeRef)a2);
    v11 = (const __CFData *)_IOHIDCreateBinaryData(v10, v9);
    if (v11)
    {
      v12 = v11;
      if (*(_DWORD *)(a2 + 448))
      {
        LODWORD(v5) = 5;
      }
      else
      {
        v13 = *(_DWORD *)(a2 + 40);
        BytePtr = CFDataGetBytePtr(v11);
        Length = CFDataGetLength(v12);
        LODWORD(v5) = iohideventsystem_output_event_to_virtual_service(v13, SenderID, (uint64_t)BytePtr, Length, (int *)&v19, 0x20u);
        if ((_DWORD)v5)
        {
          v16 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            v17 = *(_QWORD *)(a2 + 168);
            *(_DWORD *)buf = 136315650;
            v21 = v17;
            v22 = 2048;
            v23 = SenderID;
            v24 = 1024;
            v25 = v5;
            _os_log_impl(&dword_18AAAF000, v16, OS_LOG_TYPE_INFO, "%s: HIDVS ID:%llx iohideventsystem_output_event_to_virtual_service:%x", buf, 0x1Cu);
          }
          __IOHIDEventSystemConnectionCheckServerStatus(v5, a2);
        }
      }
      CFRelease(v9);
      CFRelease(v12);
      if ((_DWORD)v5)
        return v5;
      else
        return v19;
    }
    else
    {
      CFRelease(v9);
    }
  }
  return v5;
}

uint64_t __IOHIDServiceVirtualCopyMatchingEventCallback(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t SenderID;
  const __CFAllocator *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  int Length;
  int v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  UInt8 *v15;
  mach_vm_size_t v16;
  CFTypeID TypeID;
  const void *v18;
  const void *v19;
  NSObject *v20;
  unsigned int v22;
  UInt8 *v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  SenderID = _IOHIDServiceGetSenderID(a1);
  v23 = 0;
  v22 = 0;
  if (a3)
  {
    v6 = CFGetAllocator((CFTypeRef)a2);
    v7 = (const __CFData *)_IOHIDCreateBinaryData(v6, a3);
    if (!v7)
    {
      v20 = _IOHIDLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        __IOHIDServiceVirtualCopyMatchingEventCallback_cold_1(v20);
      return 0;
    }
    a3 = v7;
    BytePtr = CFDataGetBytePtr(v7);
    Length = CFDataGetLength(a3);
  }
  else
  {
    BytePtr = 0;
    Length = 0;
  }
  if (*(_DWORD *)(a2 + 448))
    goto LABEL_10;
  v10 = iohideventsystem_copy_matching_event_from_virtual_service(*(_DWORD *)(a2 + 40), SenderID, (uint64_t)BytePtr, Length, &v23, &v22, 0x20u);
  if (v10)
  {
    v11 = v10;
    v12 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = *(_QWORD *)(a2 + 168);
      *(_DWORD *)buf = 136315650;
      v25 = v13;
      v26 = 2048;
      v27 = SenderID;
      v28 = 1024;
      v29 = v11;
      _os_log_impl(&dword_18AAAF000, v12, OS_LOG_TYPE_INFO, "%s: HIDVS ID:%llx iohideventsystem_copy_matching_event_from_virtual_service:%x", buf, 0x1Cu);
    }
    __IOHIDEventSystemConnectionCheckServerStatus(v11, a2);
LABEL_10:
    v14 = 0;
    if (!a3)
      return v14;
    goto LABEL_14;
  }
  v15 = v23;
  v16 = v22;
  TypeID = CFDataGetTypeID();
  v18 = _IOHIDUnserializeAndVMDeallocWithTypeID(v15, v16, TypeID);
  if (!v18)
    goto LABEL_10;
  v19 = v18;
  v14 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E0C9AE00], v18);
  CFRelease(v19);
  if (a3)
LABEL_14:
    CFRelease(a3);
  return v14;
}

