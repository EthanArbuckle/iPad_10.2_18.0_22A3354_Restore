void dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}>(abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;
  dispatch_object_t v10;
  uint64_t *v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  NSObject *v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  NSObject *v23;
  _QWORD v24[3];
  uint64_t *v25;
  dispatch_object_t object;
  _QWORD v27[3];
  uint64_t *v28;
  _BYTE v29[24];
  _BYTE *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v4 = **a1;
  v3 = (*a1)[1];
  v23 = v3;
  if (v3)
    dispatch_retain(v3);
  v5 = v24;
  v6 = (uint64_t *)v2[5];
  if (!v6)
  {
LABEL_6:
    v25 = v6;
    object = v23;
    v7 = v27;
    if (v6)
      goto LABEL_7;
    goto LABEL_10;
  }
  if (v6 != v2 + 2)
  {
    v6 = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
    goto LABEL_6;
  }
  v25 = v24;
  (*(void (**)(uint64_t *, _QWORD *))(*v6 + 24))(v6, v24);
  v6 = v25;
  object = v23;
  v7 = v27;
  if (v25)
  {
LABEL_7:
    if (v6 == v24)
    {
      v28 = v27;
      (*(void (**)(_QWORD *, _QWORD *))(v24[0] + 24))(v24, v27);
    }
    else
    {
      v28 = v6;
      v25 = 0;
    }
    goto LABEL_12;
  }
LABEL_10:
  v28 = 0;
LABEL_12:
  v30 = 0;
  v8 = operator new(0x30uLL);
  v9 = v8;
  v10 = object;
  v11 = v28;
  *v8 = &off_1E4A090C0;
  v8[1] = v10;
  object = 0;
  if (v11)
  {
    if (v11 == v27)
    {
      v8[5] = v8 + 2;
      (*(void (**)(_QWORD *))(v27[0] + 24))(v27);
    }
    else
    {
      v8[5] = v11;
      v28 = 0;
    }
  }
  else
  {
    v8[5] = 0;
  }
  v12 = (_BYTE *)(v4 + 56);
  v30 = v9;
  if (v29 == (_BYTE *)(v4 + 56))
  {
    v14 = 5;
    goto LABEL_25;
  }
  v13 = *(_BYTE **)(v4 + 80);
  if (v13 == v12)
  {
    v9 = v29;
    (*(void (**)(_BYTE *, _BYTE *))(*(_QWORD *)v12 + 24))(v12, v29);
    (*(void (**)(_QWORD))(**(_QWORD **)(v4 + 80) + 32))(*(_QWORD *)(v4 + 80));
    *(_QWORD *)(v4 + 80) = v30;
    v30 = v29;
    goto LABEL_24;
  }
  v30 = *(_BYTE **)(v4 + 80);
  *(_QWORD *)(v4 + 80) = v9;
  v9 = v29;
  if (v13 == v29)
  {
LABEL_24:
    v14 = 4;
    goto LABEL_25;
  }
  if (!v13)
    goto LABEL_26;
  v14 = 5;
  v9 = v13;
LABEL_25:
  (*(void (**)(_QWORD *))(*v9 + 8 * v14))(v9);
LABEL_26:
  if (v28 == v27)
  {
    v15 = 4;
  }
  else
  {
    if (!v28)
      goto LABEL_31;
    v15 = 5;
    v7 = v28;
  }
  (*(void (**)(uint64_t *))(*v7 + 8 * v15))(v7);
LABEL_31:
  if (object)
    dispatch_release(object);
  if (v25 == v24)
  {
    v16 = 4;
  }
  else
  {
    if (!v25)
      goto LABEL_38;
    v16 = 5;
    v5 = v25;
  }
  (*(void (**)(uint64_t *))(*v5 + 8 * v16))(v5);
LABEL_38:
  v17 = (uint64_t *)v2[5];
  if (v17 == v2 + 2)
  {
    v18 = 4;
    v17 = v2 + 2;
  }
  else
  {
    if (!v17)
      goto LABEL_43;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_43:
  v19 = v2[1];
  if (v19)
    dispatch_release(v19);
  operator delete(v2);
  v20 = (std::__shared_weak_count *)a1[2];
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  operator delete(a1);
}

void sub_1A34A37F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;

  *a1 = &off_1E4A090C0;
  v2 = a1 + 2;
  v3 = (_QWORD *)a1[5];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = a1[1];
  if (v5)
    dispatch_release(v5);
  return a1;
}

void std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::~__func(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  NSObject *v5;

  *(_QWORD *)__p = &off_1E4A090C0;
  v2 = __p + 16;
  v3 = (char *)*((_QWORD *)__p + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  v5 = *((_QWORD *)__p + 1);
  if (v5)
    dispatch_release(v5);
  operator delete(__p);
}

_QWORD *std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;

  v2 = operator new(0x30uLL);
  v3 = *(NSObject **)(a1 + 8);
  *v2 = &off_1E4A090C0;
  v2[1] = v3;
  if (v3)
    dispatch_retain(v3);
  v4 = *(_QWORD *)(a1 + 40);
  if (!v4)
    goto LABEL_6;
  if (v4 != a1 + 16)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
LABEL_6:
    v2[5] = v4;
    return v2;
  }
  v2[5] = v2 + 2;
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  return v2;
}

void sub_1A34A3ACC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  NSObject *v3;

  v3 = v1[1];
  if (v3)
    dispatch_release(v3);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::__clone(uint64_t a1, _QWORD *a2)
{
  NSObject *v4;
  uint64_t result;

  v4 = *(NSObject **)(a1 + 8);
  *a2 = &off_1E4A090C0;
  a2[1] = v4;
  if (v4)
    dispatch_retain(v4);
  result = *(_QWORD *)(a1 + 40);
  if (!result)
    goto LABEL_6;
  if (result != a1 + 16)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
LABEL_6:
    a2[5] = result;
    return result;
  }
  a2[5] = a2 + 2;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 24))(*(_QWORD *)(a1 + 40));
}

void sub_1A34A3B6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v3;

  v3 = *(NSObject **)(v1 + 8);
  if (v3)
    dispatch_release(v3);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::destroy(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;

  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 40);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = *(NSObject **)(a1 + 8);
  if (v5)
    dispatch_release(v5);
}

void std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  NSObject *v5;

  v2 = __p + 16;
  v3 = (char *)*((_QWORD *)__p + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  v5 = *((_QWORD *)__p + 1);
  if (v5)
    dispatch_release(v5);
  operator delete(__p);
}

void std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::operator()(uint64_t a1, uint64_t a2, int *a3)
{
  std::string::value_type *v4;
  std::string::size_type v5;
  int v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  char *v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE v14[7];
  _QWORD v15[3];
  _QWORD *v16;
  std::string __p;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = *(std::string::value_type **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)v14 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)&v14[3] = *(_DWORD *)(a2 + 19);
  v6 = *(char *)(a2 + 23);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v7 = *a3;
  v8 = *(_QWORD *)(a1 + 40);
  if (!v8)
    goto LABEL_4;
  if (v8 != a1 + 16)
  {
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
LABEL_4:
    v16 = (_QWORD *)v8;
    goto LABEL_6;
  }
  v16 = v15;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 24))(v8, v15);
LABEL_6:
  if (v6 < 0)
  {
    std::string::__init_copy_ctor_external(&__p, v4, v5);
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
    __p.__r_.__value_.__l.__size_ = v5;
    LODWORD(__p.__r_.__value_.__r.__words[2]) = *(_DWORD *)v14;
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)&v14[3];
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = v6;
  }
  v18 = v7;
  v9 = *(NSObject **)(a1 + 8);
  v10 = (char *)operator new(0x40uLL);
  v11 = v10;
  if (v16)
  {
    if (v16 == v15)
    {
      *((_QWORD *)v10 + 3) = v10;
      (*(void (**)(_QWORD *, char *))(v15[0] + 24))(v15, v10);
      v7 = v18;
    }
    else
    {
      *((_QWORD *)v10 + 3) = v16;
      v16 = 0;
    }
  }
  else
  {
    *((_QWORD *)v10 + 3) = 0;
  }
  *(std::string *)(v11 + 32) = __p;
  memset(&__p, 0, sizeof(__p));
  *((_DWORD *)v11 + 14) = v7;
  dispatch_async_f(v9, v11, (dispatch_function_t)dispatch::async<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}::operator() const(std::string,abm::AppState)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}::operator() const(std::string,abm::AppState)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}::operator() const(std::string,abm::AppState)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    v12 = v16;
    if (v16 != v15)
      goto LABEL_16;
LABEL_19:
    v13 = 4;
    v12 = v15;
    goto LABEL_20;
  }
  v12 = v16;
  if (v16 == v15)
    goto LABEL_19;
LABEL_16:
  if (!v12)
    goto LABEL_21;
  v13 = 5;
LABEL_20:
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_21:
  if (v6 < 0)
    operator delete(v4);
}

void sub_1A34A3E24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm18AppMonitorInternal18setAppStateHandlerEN8dispatch5queueENSt3__18functionIFvNS3_12basic_str"
                     "ingIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS_8AppStateEEEEENKUlvE_clEvEUlSA_SB_E_")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZZN3abm18AppMonitorInternal18setAppStateHandlerEN8dispatch5queueENSt3__18functionIFvNS3_"
                                "12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS_8AppStateEEEEENKUlvE_clEvEUlSA_SB_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm18AppMonitorInternal18setAppStateHandlerEN8dispatch5queueENSt3__18functionIFvNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS_8AppStateEEEEENKUlvE_clEvEUlSA_SB_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm18AppMonitorInternal18setAppStateHandlerEN8dispatch5queueENSt3__18functionIFvNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS_8AppStateEEEEENKUlvE_clEvEUlSA_SB_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1},std::allocator<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}>,void ()(std::string,abm::AppState)>::target_type()
{
}

void dispatch::async<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}::operator() const(std::string,abm::AppState)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}::operator() const(std::string,abm::AppState)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::setAppStateHandler(dispatch::queue,std::function<void ()(std::string,abm::AppState)>)::{lambda(void)#1}::operator() const(void)::{lambda(std::string,abm::AppState)#1}::operator() const(std::string,abm::AppState)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  std::string __p;
  int v7;

  v2 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 32), *(_QWORD *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)v2;
    __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 48);
  }
  v7 = *(_DWORD *)(a1 + 56);
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, std::string *, int *))(*(_QWORD *)v3 + 48))(v3, &__p, &v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((*(char *)(a1 + 55) & 0x80000000) == 0)
    {
LABEL_7:
      v4 = *(_QWORD **)(a1 + 24);
      if (v4 != (_QWORD *)a1)
        goto LABEL_8;
LABEL_12:
      v5 = 4;
      v4 = (_QWORD *)a1;
      goto LABEL_13;
    }
  }
  else if ((*(char *)(a1 + 55) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(*v2);
  v4 = *(_QWORD **)(a1 + 24);
  if (v4 == (_QWORD *)a1)
    goto LABEL_12;
LABEL_8:
  if (v4)
  {
    v5 = 5;
LABEL_13:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  operator delete((void *)a1);
}

void sub_1A34A3FF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;
  void **v15;
  _QWORD *v17;
  uint64_t v18;

  if (*(char *)(v14 + 55) < 0)
  {
    operator delete(*v15);
    v17 = *(_QWORD **)(v14 + 24);
    if (v17 == (_QWORD *)v14)
      goto LABEL_3;
  }
  else
  {
    v17 = *(_QWORD **)(v14 + 24);
    if (v17 == (_QWORD *)v14)
    {
LABEL_3:
      v18 = 4;
      v17 = (_QWORD *)v14;
      goto LABEL_7;
    }
  }
  if (!v17)
    goto LABEL_8;
  v18 = 5;
LABEL_7:
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_8:
  operator delete((void *)v14);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::addBundleID(std::string)::{lambda(void)#1}>(abm::AppMonitorInternal::addBundleID(std::string)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::addBundleID(std::string)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::addBundleID(std::string)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(char **a1)
{
  char *v2;
  _QWORD *v3;
  void **v4;
  void *v5;
  void *v6;
  void *v7;
  NSObject *v8;
  char *v9;
  void *v10;
  NSObject *v11;
  char *v12;
  const char *v13;
  uint8_t *p_buf;
  char *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  int v19;
  char *v20;
  __int128 buf;
  void (*v22)(uint64_t, void *);
  void *v23;
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = *(_QWORD **)*a1;
  v4 = (void **)(*a1 + 8);
  v5 = v4;
  if ((*a1)[31] < 0)
    v5 = *v4;
  v6 = (void *)v3[5];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v5);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "addObject:", v7);

  v8 = v3[4];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = v2 + 8;
    if (v2[31] < 0)
      v9 = (char *)*v4;
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v9;
    _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I AppMonitor: successfully added bundle ID %s to store", (uint8_t *)&buf, 0xCu);
  }
  v10 = (void *)v3[6];
  if (v10)
  {
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3221225472;
    v22 = ___ZZN3abm18AppMonitorInternal11addBundleIDENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEENKUlvE_clEv_block_invoke;
    v23 = &__block_descriptor_40_e40_v16__0___RBSProcessMonitorConfiguring__8l;
    v24 = v3;
    objc_msgSend(v10, "updateConfiguration:", &buf);
    v11 = v3[4];
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      goto LABEL_17;
    v12 = v2 + 8;
    if (v2[31] < 0)
      v12 = (char *)*v4;
    v19 = 136315138;
    v20 = v12;
    v13 = "#I AppMonitor: successfully updated configuration after adding bundle ID %s";
    p_buf = (uint8_t *)&v19;
  }
  else
  {
    v11 = v3[4];
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      goto LABEL_17;
    v15 = v2 + 8;
    if (v2[31] < 0)
      v15 = (char *)*v4;
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v15;
    v13 = "#I AppMonitor: skipping configuration update after adding bundle ID %s";
    p_buf = (uint8_t *)&buf;
  }
  _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, v13, p_buf, 0xCu);
LABEL_17:
  if (v2[31] < 0)
    operator delete(*v4);
  operator delete(v2);
  v16 = (std::__shared_weak_count *)a1[2];
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  operator delete(a1);
}

void sub_1A34A42B0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  char *v2;
  void *v3;
  void **v4;
  void *v5;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v5 = v3;

  if (v2[31] < 0)
    operator delete(*v4);
  operator delete(v2);
  v7 = (std::__shared_weak_count *)v1[2];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZZN3abm18AppMonitorInternal11addBundleIDENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEENKUlvE_clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_msgSend(MEMORY[0x1E0D87DA0], "predicateMatchingBundleIdentifiers:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = v4;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v6, 1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setPredicates:", v5);

}

void sub_1A34A43D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZNK3ctu20SharedSynchronizableIN3abm18AppMonitorInternalEE20execute_wrapped_syncIZNS2_14removeBundleIDENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEEUlvE_EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSD__block_invoke(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  void *v10;
  NSObject *v11;
  _QWORD *v12;
  void *v13;
  NSObject *v14;
  const char *v15;
  uint8_t *p_buf;
  uint64_t v17;
  NSObject *v18;
  _BOOL4 v19;
  const char *v20;
  int v22;
  _QWORD *v23;
  __int128 buf;
  void (*v25)(uint64_t, void *);
  void *v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = *(uint64_t **)(a1 + 40);
  v2 = *v1;
  v3 = v1 + 1;
  v4 = v1 + 1;
  if (*((char *)v1 + 31) < 0)
    v4 = (_QWORD *)*v3;
  v5 = *(void **)(v2 + 40);
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "containsObject:", v6);

  v8 = *(void **)(v2 + 40);
  if ((v7 & 1) == 0)
  {
    v17 = objc_msgSend(*(id *)(v2 + 40), "count");
    v18 = *(NSObject **)(v2 + 32);
    v19 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (v17)
    {
      if (!v19)
        return v7;
      if (*((char *)v1 + 31) < 0)
        v3 = (_QWORD *)*v3;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v3;
      v20 = "AppMonitor: store does not contain bundle ID %s, so it cannot be removed ";
    }
    else
    {
      if (!v19)
        return v7;
      if (*((char *)v1 + 31) < 0)
        v3 = (_QWORD *)*v3;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v3;
      v20 = "AppMonitor: store does not contain any bundle IDs, so bundle ID %s cannot be removed";
    }
    _os_log_error_impl(&dword_1A343C000, v18, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&buf, 0xCu);
    return v7;
  }
  v9 = v1 + 1;
  if (*((char *)v1 + 31) < 0)
    v9 = (_QWORD *)*v3;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "removeObject:", v10);

  v11 = *(NSObject **)(v2 + 32);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = v1 + 1;
    if (*((char *)v1 + 31) < 0)
      v12 = (_QWORD *)*v3;
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v12;
    _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I AppMonitor: successfully removed bundle ID %s from store", (uint8_t *)&buf, 0xCu);
  }
  v13 = *(void **)(v2 + 48);
  if (v13)
  {
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3221225472;
    v25 = ___ZZN3abm18AppMonitorInternal14removeBundleIDENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEENKUlvE_clEv_block_invoke;
    v26 = &__block_descriptor_40_e40_v16__0___RBSProcessMonitorConfiguring__8l;
    v27 = v2;
    objc_msgSend(v13, "updateConfiguration:", &buf);
    v14 = *(NSObject **)(v2 + 32);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v1 + 31) < 0)
        v3 = (_QWORD *)*v3;
      v22 = 136315138;
      v23 = v3;
      v15 = "#I AppMonitor: successfully updated configuration after removing bundle ID %s";
      p_buf = (uint8_t *)&v22;
LABEL_29:
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, v15, p_buf, 0xCu);
    }
  }
  else
  {
    v14 = *(NSObject **)(v2 + 32);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v1 + 31) < 0)
        v3 = (_QWORD *)*v3;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v3;
      v15 = "#I AppMonitor: skipping configuration update after removing bundle ID %s";
      p_buf = (uint8_t *)&buf;
      goto LABEL_29;
    }
  }
  return v7;
}

void sub_1A34A46C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A34A46D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZZN3abm18AppMonitorInternal14removeBundleIDENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEENKUlvE_clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_msgSend(MEMORY[0x1E0D87DA0], "predicateMatchingBundleIdentifiers:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = v4;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v6, 1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setPredicates:", v5);

}

void sub_1A34A479C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZN8dispatch9sync_implIRU8__strongU13block_pointerFbvEEENSt3__15decayIDTclfp0_EEE4typeEP16dispatch_queue_sOT_NS5_17integral_constantIbLb0EEE_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(**(_QWORD **)(a1 + 40) + 16))();
  **(_BYTE **)(a1 + 32) = result;
  return result;
}

uint64_t ___ZN8dispatch19async_and_wait_implIRU8__strongU13block_pointerFbvEEENSt3__15decayIDTclfp0_EEE4typeEP16dispatch_queue_sOT_NS5_17integral_constantIbLb0EEE_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(**(_QWORD **)(a1 + 40) + 16))();
  **(_BYTE **)(a1 + 32) = result;
  return result;
}

void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::start(void)::{lambda(void)#1}>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(0x18uLL);
  *(_OWORD *)v8 = *(_OWORD *)a2;
  v8[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::start(void)::{lambda(void)#1}>(abm::AppMonitorInternal::start(void)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::start(void)::{lambda(void)#1},dispatch_queue_s *::default_delete<abm::AppMonitorInternal::start(void)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::start(void)::{lambda(void)#1}>(abm::AppMonitorInternal::start(void)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::start(void)::{lambda(void)#1},dispatch_queue_s *::default_delete<abm::AppMonitorInternal::start(void)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  void *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  uint64_t v9;
  void *v10;
  NSObject *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint8_t v16[16];
  uint8_t buf[8];
  uint64_t v18;
  void (*v19)(_QWORD *, void *);
  void *v20;
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v2 = *a1;
  v3 = **a1;
  if (*(_QWORD *)(v3 + 48))
  {
    v4 = *(NSObject **)(v3 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "AppMonitor: already started", buf, 2u);
    }
  }
  else
  {
    v5 = (void *)MEMORY[0x1E0D87D90];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v18 = 3321888768;
    v19 = ___ZZN3abm18AppMonitorInternal5startEvENKUlvE_clEv_block_invoke;
    v20 = &__block_descriptor_56_ea8_40c49_ZTSNSt3__18weak_ptrIN3abm18AppMonitorInternalEEE_e40_v16__0___RBSProcessMonitorConfiguring__8l;
    v21 = v3;
    v22 = v2[1];
    v6 = (std::__shared_weak_count *)v2[2];
    v23 = v6;
    if (v6)
    {
      p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
      do
        v8 = __ldxr(p_shared_weak_owners);
      while (__stxr(v8 + 1, p_shared_weak_owners));
    }
    objc_msgSend(v5, "monitorWithConfiguration:", buf);
    v9 = objc_claimAutoreleasedReturnValue();
    v10 = *(void **)(v3 + 48);
    *(_QWORD *)(v3 + 48) = v9;

    v11 = *(NSObject **)(v3 + 32);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I AppMonitor: started", v16, 2u);
    }
    if (v23)
      std::__shared_weak_count::__release_weak(v23);
  }
  v12 = (std::__shared_weak_count *)v2[2];
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  operator delete(v2);
  v13 = (std::__shared_weak_count *)a1[2];
  if (!v13)
    goto LABEL_17;
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    operator delete(a1);
  }
  else
  {
LABEL_17:
    operator delete(a1);
  }
}

void sub_1A34A4ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  _QWORD *v17;
  _QWORD *v18;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;

  if (a17)
  {
    std::__shared_weak_count::__release_weak(a17);
    v20 = (std::__shared_weak_count *)v18[2];
    if (!v20)
    {
LABEL_3:
      operator delete(v18);
      v21 = (std::__shared_weak_count *)v17[2];
      if (!v21)
        goto LABEL_11;
      goto LABEL_7;
    }
  }
  else
  {
    v20 = (std::__shared_weak_count *)v18[2];
    if (!v20)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v20);
  operator delete(v18);
  v21 = (std::__shared_weak_count *)v17[2];
  if (!v21)
    goto LABEL_11;
LABEL_7:
  p_shared_owners = (unint64_t *)&v21->__shared_owners_;
  do
    v23 = __ldaxr(p_shared_owners);
  while (__stlxr(v23 - 1, p_shared_owners));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
LABEL_11:
  operator delete(v17);
  _Unwind_Resume(a1);
}

void ___ZZN3abm18AppMonitorInternal5startEvENKUlvE_clEv_block_invoke(_QWORD *a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  void *v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = a1[4];
  objc_msgSend(MEMORY[0x1E0D87DC0], "descriptor");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "setValues:", 1);
  v16[0] = CFSTR("com.apple.frontboard.visibility");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v16, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "setEndowmentNamespaces:", v6);

  objc_msgSend(v3, "setStateDescriptor:", v5);
  objc_msgSend(MEMORY[0x1E0D87DA0], "predicateMatchingBundleIdentifiers:", *(_QWORD *)(v4 + 40));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = v7;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v15, 1);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setPredicates:", v8);

  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZZN3abm18AppMonitorInternal5startEvENKUlvE_clEv_block_invoke_2;
  v13[3] = &__block_descriptor_56_ea8_40c49_ZTSNSt3__18weak_ptrIN3abm18AppMonitorInternalEEE_e74_v32__0__RBSProcessMonitor_8__RBSProcessHandle_16__RBSProcessStateUpdate_24l;
  v10 = a1[5];
  v9 = (std::__shared_weak_count *)a1[6];
  v13[4] = v4;
  v13[5] = v10;
  v14 = v9;
  if (v9)
  {
    p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v12 = __ldxr(p_shared_weak_owners);
    while (__stxr(v12 + 1, p_shared_weak_owners));
  }
  objc_msgSend(v3, "setUpdateHandler:", v13);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);

}

void sub_1A34A4CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  void *v15;
  void *v16;

  if (a15)
    std::__shared_weak_count::__release_weak(a15);

  _Unwind_Resume(a1);
}

void ___ZZN3abm18AppMonitorInternal5startEvENKUlvE_clEv_block_invoke_2(_QWORD *a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  std::__shared_weak_count *v10;
  uint64_t *v11;
  std::__shared_weak_count *v12;
  void *v13;
  id v14;
  void *v15;
  int v16;
  int v17;
  id v18;
  const char *v19;
  size_t v20;
  size_t v21;
  __int128 *p_dst;
  std::__shared_weak_count *v23;
  int v24;
  NSObject *v25;
  const char *v26;
  int v27;
  NSObject *v28;
  uint32_t v29;
  uint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  char *v36;
  std::string *v37;
  void *v38;
  NSObject *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  NSObject *v44;
  unint64_t *v45;
  unint64_t v46;
  int v47;
  int v48;
  const char *__src;
  __int128 __dst;
  unint64_t v51;
  std::__shared_weak_count *v53;
  _BYTE buf[24];
  unint64_t v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = (std::__shared_weak_count *)a1[6];
  if (v10)
  {
    v11 = (uint64_t *)a1[4];
    v12 = std::__shared_weak_count::lock(v10);
    v53 = v12;
    if (v12)
    {
      if (a1[5])
      {
        objc_msgSend(v8, "bundle");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v9, "state");
        v14 = (id)objc_claimAutoreleasedReturnValue();
        switch(objc_msgSend(v14, "taskState"))
        {
          case 1u:
            v17 = 1;

            if (v13)
              goto LABEL_9;
            goto LABEL_18;
          case 2u:
          case 4u:
            objc_msgSend(v14, "endowmentNamespaces");
            v15 = (void *)objc_claimAutoreleasedReturnValue();
            v16 = objc_msgSend(v15, "containsObject:", CFSTR("com.apple.frontboard.visibility"));

            if (v16)
              v17 = 4;
            else
              v17 = 3;

            if (v13)
              goto LABEL_9;
            goto LABEL_18;
          case 3u:
            v17 = 2;

            if (!v13)
              goto LABEL_18;
            goto LABEL_9;
          default:
            v17 = 0;

            if (!v13)
            {
LABEL_18:
              v27 = v17;
              v25 = v11[4];
              if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
                goto LABEL_51;
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v27;
              v26 = "#D AppMonitor: received an event from unknown bundle, state: 0x%x";
              goto LABEL_20;
            }
LABEL_9:
            objc_msgSend(v13, "identifier");
            v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v19 = (const char *)objc_msgSend(v18, "UTF8String");

            if (!v19)
            {
              v24 = v17;
              v25 = v11[4];
              if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
                goto LABEL_51;
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v24;
              v26 = "#D AppMonitor: received an event from unknown bundle ID, state: 0x%x";
LABEL_20:
              v28 = v25;
              v29 = 8;
              goto LABEL_50;
            }
            v20 = strlen(v19);
            if (v20 >= 0x7FFFFFFFFFFFFFF8)
              std::string::__throw_length_error[abi:ne180100]();
            v21 = v20;
            __src = v19;
            if (v20 >= 0x17)
            {
              v30 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v20 | 7) != 0x17)
                v30 = v20 | 7;
              v31 = v30 + 1;
              p_dst = (__int128 *)operator new(v30 + 1);
              *((_QWORD *)&__dst + 1) = v21;
              v51 = v31 | 0x8000000000000000;
              *(_QWORD *)&__dst = p_dst;
            }
            else
            {
              HIBYTE(v51) = v20;
              p_dst = &__dst;
              if (!v20)
                goto LABEL_29;
            }
            memmove(p_dst, v19, v21);
LABEL_29:
            *((_BYTE *)p_dst + v21) = 0;
            *(_QWORD *)buf = v11;
            v48 = SHIBYTE(v51);
            if (SHIBYTE(v51) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)&buf[8], (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
            }
            else
            {
              *(_OWORD *)&buf[8] = __dst;
              v55 = v51;
            }
            v56 = v17;
            v32 = (std::__shared_weak_count *)v11[1];
            if (!v32 || (v33 = *v11, (v34 = std::__shared_weak_count::lock(v32)) == 0))
              std::__throw_bad_weak_ptr[abi:ne180100]();
            v35 = v34;
            v36 = (char *)operator new(0x28uLL);
            *(_QWORD *)v36 = *(_QWORD *)buf;
            v37 = (std::string *)(v36 + 8);
            if (SHIBYTE(v55) < 0)
            {
              std::string::__init_copy_ctor_external(v37, *(const std::string::value_type **)&buf[8], *(std::string::size_type *)&buf[16]);
            }
            else
            {
              *(_OWORD *)&v37->__r_.__value_.__l.__data_ = *(_OWORD *)&buf[8];
              *((_QWORD *)v36 + 3) = v55;
            }
            v47 = v17;
            v38 = v13;
            *((_DWORD *)v36 + 8) = v56;
            v39 = v11[2];
            p_shared_owners = (unint64_t *)&v35->__shared_owners_;
            do
              v41 = __ldxr(p_shared_owners);
            while (__stxr(v41 + 1, p_shared_owners));
            v42 = operator new(0x18uLL);
            *v42 = v36;
            v42[1] = v33;
            v42[2] = v35;
            dispatch_async_f(v39, v42, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1}>(abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke);
            do
              v43 = __ldaxr(p_shared_owners);
            while (__stlxr(v43 - 1, p_shared_owners));
            if (v43)
            {
              v13 = v38;
              if ((SHIBYTE(v55) & 0x80000000) == 0)
                goto LABEL_43;
            }
            else
            {
              ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
              std::__shared_weak_count::__release_weak(v35);
              v13 = v38;
              if ((SHIBYTE(v55) & 0x80000000) == 0)
              {
LABEL_43:
                if ((v48 & 0x80000000) == 0)
                  goto LABEL_44;
                goto LABEL_48;
              }
            }
            operator delete(*(void **)&buf[8]);
            if ((v48 & 0x80000000) == 0)
            {
LABEL_44:
              v44 = v11[4];
              if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                goto LABEL_51;
              goto LABEL_49;
            }
LABEL_48:
            operator delete((void *)__dst);
            v44 = v11[4];
            if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
              goto LABEL_51;
LABEL_49:
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = __src;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v47;
            v26 = "#D AppMonitor: received an event from bundle ID %s, state: 0x%x";
            v28 = v44;
            v29 = 18;
LABEL_50:
            _os_log_debug_impl(&dword_1A343C000, v28, OS_LOG_TYPE_DEBUG, v26, buf, v29);
LABEL_51:

            v23 = v53;
            if (v53)
              goto LABEL_52;
            goto LABEL_56;
        }
      }
      v23 = v12;
LABEL_52:
      v45 = (unint64_t *)&v23->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }
LABEL_56:

}

void sub_1A34A51E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  operator delete(v18);

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_40c49_ZTSNSt3__18weak_ptrIN3abm18AppMonitorInternalEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_40c49_ZTSNSt3__18weak_ptrIN3abm18AppMonitorInternalEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1}>(abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::string v9;
  int v10;

  v2 = *a1;
  v3 = **a1;
  v4 = *(_QWORD *)(v3 + 80);
  if (v4)
  {
    if (*((char *)v2 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v9, (const std::string::value_type *)v2[1], v2[2]);
      v4 = *(_QWORD *)(v3 + 80);
      v10 = *((_DWORD *)v2 + 8);
      if (!v4)
        std::__throw_bad_function_call[abi:ne180100]();
    }
    else
    {
      v5 = *(_OWORD *)(v2 + 1);
      v9.__r_.__value_.__r.__words[2] = v2[3];
      *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v5;
      v10 = *((_DWORD *)v2 + 8);
    }
    (*(void (**)(uint64_t, std::string *, int *))(*(_QWORD *)v4 + 48))(v4, &v9, &v10);
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v9.__r_.__value_.__l.__data_);
      if ((*((char *)v2 + 31) & 0x80000000) == 0)
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  if (*((char *)v2 + 31) < 0)
LABEL_7:
    operator delete((void *)v2[1]);
LABEL_8:
  operator delete(v2);
  v6 = (std::__shared_weak_count *)a1[2];
  if (!v6)
    goto LABEL_12;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    operator delete(a1);
  }
  else
  {
LABEL_12:
    operator delete(a1);
  }
}

void sub_1A34A53C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  _QWORD *v16;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;

  std::unique_ptr<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1}>>::~unique_ptr[abi:ne180100](&a10);
  v18 = (std::__shared_weak_count *)v16[2];
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  operator delete(v16);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1},std::default_delete<abm::AppMonitorInternal::invokeHandler(std::string const&,abm::AppState)::{lambda(void)#1}>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(char *)(v2 + 31) < 0)
      operator delete(*(void **)(v2 + 8));
    operator delete((void *)v2);
  }
  return a1;
}

void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>(uint64_t *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(8uLL);
  *v8 = *a2;
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>(abm::AppMonitorInternal::stop(void)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::stop(void)::{lambda(void)#1},dispatch_queue_s *::default_delete<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void dispatch::async<void ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>(abm::AppMonitorInternal::stop(void)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::AppMonitorInternal::stop(void)::{lambda(void)#1},dispatch_queue_s *::default_delete<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint8_t v10[16];

  v2 = *a1;
  v3 = **a1;
  v4 = *(void **)(v3 + 48);
  if (v4)
  {
    objc_msgSend(v4, "invalidate");
    v5 = *(void **)(v3 + 48);
    *(_QWORD *)(v3 + 48) = 0;

  }
  objc_msgSend(*(id *)(v3 + 40), "removeAllObjects");
  v6 = *(NSObject **)(v3 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v10 = 0;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I AppMonitor: stopped", v10, 2u);
  }
  operator delete(v2);
  v7 = (std::__shared_weak_count *)a1[2];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  operator delete(a1);
}

void sub_1A34A5630(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  operator delete(v2);
  v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

std::__shared_weak_count_vtbl **std::shared_ptr<abm::AppMonitorInternal>::shared_ptr[abi:ne180100]<abm::AppMonitorInternal,std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal*)#1},void>(std::__shared_weak_count_vtbl **a1, std::__shared_weak_count_vtbl *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09210;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = a2;
  a1[1] = (std::__shared_weak_count_vtbl *)v4;
  if (!a2)
    return a1;
  v6 = (std::__shared_weak_count *)a2->~__shared_weak_count_0;
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      return a1;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    a2->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))a2;
    a2->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    a2->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))a2;
    a2->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A34A578C(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal*)#1}::operator() const(abm::AppMonitorInternal*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A34A57AC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<abm::AppMonitorInternal *,std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal *)#1},std::allocator<abm::AppMonitorInternal>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<abm::AppMonitorInternal *,std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal *)#1},std::allocator<abm::AppMonitorInternal>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 16), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal*)#1}::operator() const(abm::AppMonitorInternal*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<abm::AppMonitorInternal *,std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal *)#1},std::allocator<abm::AppMonitorInternal>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableIN3abm18AppMonitorInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrI"
                     "T_EEPS7_EUlPS2_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableIN3abm18AppMonitorInternalEE15make_shared_ptrIS2_EENSt3__110"
                                "shared_ptrIT_EEPS7_EUlPS2_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableIN3abm18AppMonitorInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrIT_EEPS7_EUlPS2_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableIN3abm18AppMonitorInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrIT_EEPS7_EUlPS2_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

void std::shared_ptr<abm::AppMonitorInternal> ctu::SharedSynchronizable<abm::AppMonitorInternal>::make_shared_ptr<abm::AppMonitorInternal>(abm::AppMonitorInternal*)::{lambda(abm::AppMonitorInternal*)#1}::operator() const(abm::AppMonitorInternal*)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;

  if (!a1)
    return;
  v2 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD **)(a1 + 80);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_7;
  }
  if (v3)
  {
    v4 = 5;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  MEMORY[0x1A858F170](a1 + 32);
  v5 = *(NSObject **)(a1 + 24);
  if (v5)
    dispatch_release(v5);
  v6 = *(NSObject **)(a1 + 16);
  if (v6)
    dispatch_release(v6);
  v7 = *(std::__shared_weak_count **)(a1 + 8);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
  operator delete((void *)a1);
}

_QWORD *std::__shared_ptr_emplace<abm::AppMonitor>::__shared_ptr_emplace[abi:ne180100]<ctu::OsLogContext &,std::allocator<abm::AppMonitor>,0>(_QWORD *a1, const ctu::OsLogContext *a2)
{
  uint64_t v3;
  _BYTE v5[16];
  _BYTE v6[16];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1E4A09260;
  v3 = (uint64_t)(a1 + 3);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v5, a2);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v6, (const ctu::OsLogContext *)v5);
  abm::AppMonitorInternal::create((const ctu::OsLogContext *)v6, v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v5);
  return a1;
}

void sub_1A34A595C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::__shared_weak_count *v11;

  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v11);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<abm::AppMonitor>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09260;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::AppMonitor>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09260;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<abm::AppMonitor>::__on_zero_shared(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

char *bsp::tlv::abm::parseField(tlv *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, (const unsigned __int8 *)1);
  *a3 = *(_BYTE *)a1;
  return (char *)a1 + 1;
}

_BYTE *bsp::tlv::abm::writeField(_BYTE *a1, _BYTE *a2)
{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  a1[8] = a2[8];
  a1[9] = a2[9];
  a1[10] = a2[10];
  a1[11] = a2[11];
  return a1 + 12;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

uint64_t tlv::parseV<bsp::tlv::abm::DIAGPresetID>(tlv **a1, int a2)
{
  tlv *v3;
  uint64_t result;

  v3 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)1);
  result = *(unsigned __int8 *)v3;
  *a1 = (tlv *)((char *)v3 + 1);
  return result;
}

uint64_t sub_1A34A5A8C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  return 0;
}

uint64_t tlv::size<bsp::tlv::abm::DIAGPresetID>()
{
  return 4;
}

_BYTE **tlv::writeV<bsp::tlv::abm::DIAGPresetID>(_BYTE **result, _BYTE *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::parseV<bsp::tlv::abm::DIAGActiveIface>(tlv **a1, int a2)
{
  tlv *v3;
  uint64_t result;

  v3 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)1);
  result = *(unsigned __int8 *)v3;
  *a1 = (tlv *)((char *)v3 + 1);
  return result;
}

uint64_t sub_1A34A5B44(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  return 0;
}

uint64_t tlv::size<bsp::tlv::abm::DIAGActiveIface>()
{
  return 4;
}

_BYTE **tlv::writeV<bsp::tlv::abm::DIAGActiveIface>(_BYTE **result, _BYTE *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

_BYTE *bsp::tlv::abm::writeField(_BYTE *a1, _DWORD *a2)
{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

{
  *a1 = *a2;
  return a1 + 1;
}

uint64_t tlv::parseV<bsp::tlv::abm::DIAGConfig>(tlv **a1, int a2)
{
  tlv *v3;
  uint64_t result;

  v3 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)1);
  result = *(unsigned __int8 *)v3;
  *a1 = (tlv *)((char *)v3 + 1);
  return result;
}

uint64_t sub_1A34A5BFC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  return 0;
}

uint64_t tlv::size<bsp::tlv::abm::DIAGConfig>()
{
  return 4;
}

_BYTE **tlv::writeV<bsp::tlv::abm::DIAGConfig>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::parseV<bsp::tlv::abm::DIAGBuffering>(tlv **a1, int a2)
{
  tlv *v3;
  uint64_t result;

  v3 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)1);
  result = *(unsigned __int8 *)v3;
  *a1 = (tlv *)((char *)v3 + 1);
  return result;
}

uint64_t sub_1A34A5CB4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  return 0;
}

uint64_t tlv::size<bsp::tlv::abm::DIAGBuffering>()
{
  return 4;
}

_BYTE **tlv::writeV<bsp::tlv::abm::DIAGBuffering>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::parseV<bsp::tlv::abm::DIAGWMHigh>(tlv **a1, int a2)
{
  tlv *v3;
  uint64_t result;

  v3 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)2);
  result = *(unsigned __int16 *)v3;
  *a1 = (tlv *)((char *)v3 + 2);
  return result;
}

uint64_t sub_1A34A5D6C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  return 0;
}

uint64_t tlv::size<bsp::tlv::abm::DIAGWMHigh>()
{
  return 5;
}

_WORD **tlv::writeV<bsp::tlv::abm::DIAGWMHigh>(_WORD **result, _WORD *a2)
{
  _WORD *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::parseV<bsp::tlv::abm::DIAGWMLow>(tlv **a1, int a2)
{
  tlv *v3;
  uint64_t result;

  v3 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)2);
  result = *(unsigned __int16 *)v3;
  *a1 = (tlv *)((char *)v3 + 2);
  return result;
}

uint64_t sub_1A34A5E24(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  return 0;
}

uint64_t tlv::size<bsp::tlv::abm::DIAGWMLow>()
{
  return 5;
}

_WORD **tlv::writeV<bsp::tlv::abm::DIAGWMLow>(_WORD **result, _WORD *a2)
{
  _WORD *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

BOOL util::writeJSON(ctu **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  _BOOL8 v10;
  unsigned __int8 v11;
  NSObject *v12;
  unsigned __int8 v13;
  NSObject *v14;
  id v16;
  uint64_t v17;
  id v18;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v2 = a2;
  v24 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (*((char *)a2 + 23) < 0)
    v4 = (uint64_t *)*a2;
  v5 = (void *)MEMORY[0x1E0C99E48];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "outputStreamToFileAtPath:append:", v6, 0);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  if (v7)
  {
    objc_msgSend(v7, "open");
    if (objc_msgSend(v7, "streamStatus") == 2)
    {
      if ((objc_msgSend(v7, "hasSpaceAvailable") & 1) != 0)
      {
        cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        ctu::xpc_to_cf(*a1, v8);
        v18 = 0;
        objc_msgSend(MEMORY[0x1E0CB36D8], "writeJSONObject:toStream:options:error:", 0xAAAAAAAAAAAAAAAALL, v7, 1, &v18);
        v9 = v18;
        v10 = v9 == 0;
        if (v9)
        {
          {
            GetOsLogContext(void)::sOsLogContext = 0;
            qword_1ED114D18 = 0;
            __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
          }
          if (GetOsLogContext(void)::onceToken == -1)
          {
            v12 = qword_1ED114D18;
            if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
              goto LABEL_10;
          }
          else
          {
            dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
            v12 = qword_1ED114D18;
            if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
              goto LABEL_10;
          }
          if (*((char *)v2 + 23) < 0)
            v2 = (uint64_t *)*v2;
          objc_msgSend(v9, "localizedDescription");
          v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v17 = objc_msgSend(v16, "UTF8String");
          *(_DWORD *)buf = 136315394;
          v21 = v2;
          v22 = 2080;
          v23 = v17;
          _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "Failed to write %s with error: %s", buf, 0x16u);

        }
LABEL_10:
        if (cf)
          CFRelease(cf);

        goto LABEL_18;
      }
      {
        GetOsLogContext(void)::sOsLogContext = 0;
        qword_1ED114D18 = 0;
        __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
      }
      if (GetOsLogContext(void)::onceToken == -1)
      {
        v14 = qword_1ED114D18;
        if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          v10 = 0;
LABEL_18:
          objc_msgSend(v7, "close");
          goto LABEL_19;
        }
      }
      else
      {
        dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
        v14 = qword_1ED114D18;
        if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          goto LABEL_17;
      }
      if (*((char *)v2 + 23) < 0)
        v2 = (uint64_t *)*v2;
      *(_DWORD *)buf = 136315138;
      v21 = v2;
      _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "Failed to write %s due to no space available or invalid path.", buf, 0xCu);
      goto LABEL_17;
    }
  }
  v10 = 0;
LABEL_19:

  return v10;
}

void sub_1A34A61A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);

  ctu::cf::CFSharedRef<void const>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **ctu::cf::CFSharedRef<void const>::~CFSharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

BOOL util::writeJSONToBuffer(ctu **a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  void *v6;
  void *v7;
  void *v8;
  int v9;
  id v10;
  _BOOL8 v11;
  unsigned __int8 v12;
  NSObject *v13;
  id v14;
  uint64_t v15;
  unsigned __int8 v16;
  NSObject *v17;
  const char *v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  NSObject *v22;
  const char *v23;
  unsigned __int8 v24;
  id v26;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    {
      GetOsLogContext(void)::sOsLogContext = 0;
      qword_1ED114D18 = 0;
      __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
    }
    if (GetOsLogContext(void)::onceToken == -1)
    {
      v17 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    else
    {
      dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
      v17 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    *(_WORD *)buf = 0;
    v18 = "Failed to write json to buffer due to invalid buffer";
LABEL_23:
    _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, v18, buf, 2u);
    return 0;
  }
  if (!a4)
  {
    {
      GetOsLogContext(void)::sOsLogContext = 0;
      qword_1ED114D18 = 0;
      __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
    }
    if (GetOsLogContext(void)::onceToken == -1)
    {
      v17 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    else
    {
      dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
      v17 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    *(_WORD *)buf = 0;
    v18 = "Failed to write json to buffer due to invalid bytes written parameter";
    goto LABEL_23;
  }
  if (a3)
  {
    objc_msgSend(MEMORY[0x1E0C99E48], "outputStreamToBuffer:capacity:", a2, a3);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v6;
    if (v6)
    {
      objc_msgSend(v6, "open");
      if (objc_msgSend(v7, "streamStatus") == 2)
      {
        cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        ctu::xpc_to_cf(*a1, v8);
        v26 = 0;
        v9 = objc_msgSend(MEMORY[0x1E0CB36D8], "writeJSONObject:toStream:options:error:", 0xAAAAAAAAAAAAAAAALL, v7, 1, &v26);
        v10 = v26;
        v11 = v10 == 0;
        if (!v10)
        {
          *a4 = v9;
          goto LABEL_34;
        }
        {
          GetOsLogContext(void)::sOsLogContext = 0;
          qword_1ED114D18 = 0;
          __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
        }
        if (GetOsLogContext(void)::onceToken == -1)
        {
          v13 = qword_1ED114D18;
          if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          {
LABEL_34:
            objc_msgSend(v7, "close");
            if (cf)
              CFRelease(cf);

            goto LABEL_37;
          }
        }
        else
        {
          dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
          v13 = qword_1ED114D18;
          if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
            goto LABEL_34;
        }
        objc_msgSend(v10, "localizedDescription");
        v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v15 = objc_msgSend(v14, "UTF8String");
        *(_DWORD *)buf = 136315138;
        v29 = v15;
        _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Failed to write json to buffer with error: %s", buf, 0xCu);

        goto LABEL_34;
      }
      {
        GetOsLogContext(void)::sOsLogContext = 0;
        qword_1ED114D18 = 0;
        __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
      }
      if (GetOsLogContext(void)::onceToken == -1)
      {
        v22 = qword_1ED114D18;
        if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          goto LABEL_32;
      }
      else
      {
        dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
        v22 = qword_1ED114D18;
        if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          goto LABEL_32;
      }
      *(_WORD *)buf = 0;
      v23 = "Failed to write json to buffer due to stream opening failure";
    }
    else
    {
      {
        GetOsLogContext(void)::sOsLogContext = 0;
        qword_1ED114D18 = 0;
        __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
      }
      if (GetOsLogContext(void)::onceToken == -1)
      {
        v22 = qword_1ED114D18;
        if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        {
LABEL_32:
          v11 = 0;
LABEL_37:

          return v11;
        }
      }
      else
      {
        dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
        v22 = qword_1ED114D18;
        if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          goto LABEL_32;
      }
      *(_WORD *)buf = 0;
      v23 = "Failed to write json to buffer due to invalid stream";
    }
    _os_log_error_impl(&dword_1A343C000, v22, OS_LOG_TYPE_ERROR, v23, buf, 2u);
    goto LABEL_32;
  }
  {
    GetOsLogContext(void)::sOsLogContext = 0;
    qword_1ED114D18 = 0;
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
  }
  if (GetOsLogContext(void)::onceToken != -1)
  {
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
    v17 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return 0;
    goto LABEL_22;
  }
  v17 = qword_1ED114D18;
  if (os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
  {
LABEL_22:
    *(_WORD *)buf = 0;
    v18 = "Failed to write json to buffer due to no buffer capacity";
    goto LABEL_23;
  }
  return 0;
}

void sub_1A34A6844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);

  ctu::cf::CFSharedRef<void const>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void util::readJSON(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  xpc_object_t v4;
  uint64_t *v5;
  void *v6;
  void *v7;
  void *v8;
  ctu *v9;
  const void *v10;
  id v11;
  unsigned __int8 v12;
  NSObject *v13;
  id v14;
  uint64_t v15;
  unsigned __int8 v16;
  NSObject *v17;
  xpc_object_t v18;
  xpc_object_t v19;
  id v20;
  _BYTE buf[12];
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  v4 = xpc_null_create();
  *a2 = v4;
  v5 = a1;
  if (*((char *)a1 + 23) < 0)
    v5 = (uint64_t *)*a1;
  v6 = (void *)MEMORY[0x1E0C99DB0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v5);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "inputStreamWithFileAtPath:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (v8)
  {
    objc_msgSend(v8, "open");
    if (objc_msgSend(v8, "streamStatus") == 2)
    {
      if ((objc_msgSend(v8, "hasBytesAvailable") & 1) == 0)
      {
        {
          GetOsLogContext(void)::sOsLogContext = 0;
          qword_1ED114D18 = 0;
          __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
        }
        if (GetOsLogContext(void)::onceToken == -1)
        {
          v17 = qword_1ED114D18;
          if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          {
LABEL_25:
            objc_msgSend(v8, "close");
            goto LABEL_26;
          }
        }
        else
        {
          dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
          v17 = qword_1ED114D18;
          if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
            goto LABEL_25;
        }
        if (*((char *)a1 + 23) < 0)
          a1 = (uint64_t *)*a1;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = a1;
        _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, "Failed to read %s due to no bytes available or invalid path.", buf, 0xCu);
        goto LABEL_25;
      }
      v20 = 0;
      objc_msgSend(MEMORY[0x1E0CB36D8], "JSONObjectWithStream:options:error:", v8, 0, &v20);
      v9 = (ctu *)objc_claimAutoreleasedReturnValue();
      v11 = v20;
      if (!v11)
      {
        ctu::cf_to_xpc(v9, v10);
        v18 = *(xpc_object_t *)buf;
        if (*(_QWORD *)buf && MEMORY[0x1A85902BC](*(_QWORD *)buf) == MEMORY[0x1E0C812F8])
          xpc_retain(v18);
        else
          v18 = xpc_null_create();
        v19 = xpc_null_create();
        *a2 = v18;
        xpc_release(v4);
        xpc_release(v19);
        xpc_release(*(xpc_object_t *)buf);
        goto LABEL_24;
      }
      {
        GetOsLogContext(void)::sOsLogContext = 0;
        qword_1ED114D18 = 0;
        __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
      }
      if (GetOsLogContext(void)::onceToken == -1)
      {
        v13 = qword_1ED114D18;
        if (os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        {
LABEL_10:
          if (*((char *)a1 + 23) < 0)
            a1 = (uint64_t *)*a1;
          objc_msgSend(v11, "localizedDescription");
          v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v15 = objc_msgSend(v14, "UTF8String");
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = a1;
          v22 = 2080;
          v23 = v15;
          _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Failed to read %s with error: %s", buf, 0x16u);

        }
      }
      else
      {
        dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
        v13 = qword_1ED114D18;
        if (os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
          goto LABEL_10;
      }
LABEL_24:

      goto LABEL_25;
    }
  }
LABEL_26:

}

void sub_1A34A6C2C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t support::fs::toString@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  if ((_DWORD)result == 1)
  {
    a2[23] = 9;
    strcpy(a2, "_wireless");
  }
  else if ((_DWORD)result)
  {
    a2[23] = 0;
    *a2 = 0;
  }
  else
  {
    a2[23] = 6;
    strcpy(a2, "mobile");
  }
  return result;
}

uint64_t support::fs::updateOwner(const char *a1, uint64_t a2, uint64_t a3)
{
  const char *v5;
  timespec v6;
  size_t v7;
  __darwin_ino64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void *v13;
  stat *v14;
  uint64_t updated;
  void *v16;
  const char *v17;
  DIR *v18;
  DIR *v19;
  dirent *v20;
  char *v21;
  const std::string::value_type **v22;
  char v23;
  __int128 v24;
  int v25;
  size_t v26;
  unint64_t v27;
  char *p_dst;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  std::string *v32;
  std::string::size_type size;
  std::string *v34;
  __int128 v35;
  std::string::size_type v36;
  std::string *v37;
  std::string *v38;
  timespec v39;
  std::string *v40;
  std::string *p_p;
  size_t v42;
  __darwin_ino64_t v43;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46;
  int st_gid_high;
  void *v48;
  stat *v49;
  void *v50;
  std::string *v51;
  DIR *v52;
  DIR *v53;
  dirent *v54;
  void **v55;
  char *v57;
  std::string v58;
  std::string __p;
  std::string v60;
  void *v61;
  char *v62;
  uint64_t v63;
  stat __dst;

  v5 = a1;
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__dst.st_blksize = v6;
  *(timespec *)__dst.st_qspare = v6;
  __dst.st_birthtimespec = v6;
  *(timespec *)&__dst.st_size = v6;
  __dst.st_mtimespec = v6;
  __dst.st_ctimespec = v6;
  *(timespec *)&__dst.st_uid = v6;
  __dst.st_atimespec = v6;
  *(timespec *)&__dst.st_dev = v6;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (!stat(a1, &__dst))
  {
    v17 = v5[23] >= 0 ? v5 : *(const char **)v5;
    v18 = opendir(v17);
    if (v18)
    {
      v19 = v18;
      v20 = readdir(v18);
      closedir(v19);
      if (v20)
      {
        v61 = 0;
        v62 = 0;
        v63 = 0;
        support::fs::readDir(v5, (uint64_t)&v61);
        v21 = (char *)v61;
        v57 = v62;
        if (v61 == v62)
        {
          updated = 0;
          if (v61)
            goto LABEL_105;
          return updated;
        }
        v22 = (const std::string::value_type **)((char *)v61 + 24);
        while (1)
        {
          memset(&v60, 170, sizeof(v60));
          if (*((char *)v22 - 1) < 0)
          {
            std::string::__init_copy_ctor_external(&v60, *(v22 - 3), (std::string::size_type)*(v22 - 2));
          }
          else
          {
            v24 = *(_OWORD *)(v22 - 3);
            v60.__r_.__value_.__r.__words[2] = (std::string::size_type)*(v22 - 1);
            *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v24;
          }
          memset(&__p, 170, sizeof(__p));
          v25 = v5[23];
          if (v25 >= 0)
            v26 = *((unsigned __int8 *)v5 + 23);
          else
            v26 = *((_QWORD *)v5 + 1);
          v27 = v26 + 1;
          memset(&__dst, 170, 24);
          if (v26 + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v27 >= 0x17)
          {
            v29 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v27 | 7) != 0x17)
              v29 = v27 | 7;
            v30 = v29 + 1;
            p_dst = (char *)operator new(v29 + 1);
            __dst.st_ino = v26 + 1;
            *(_QWORD *)&__dst.st_uid = v30 | 0x8000000000000000;
            *(_QWORD *)&__dst.st_dev = p_dst;
          }
          else
          {
            memset(&__dst, 0, 24);
            p_dst = (char *)&__dst;
            HIBYTE(__dst.st_gid) = v26 + 1;
            if (!v26)
              goto LABEL_47;
          }
          if (v25 >= 0)
            v31 = v5;
          else
            v31 = *(const char **)v5;
          memmove(p_dst, v31, v26);
LABEL_47:
          *(_WORD *)&p_dst[v26] = 47;
          if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v32 = &v60;
          else
            v32 = (std::string *)v60.__r_.__value_.__r.__words[0];
          if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v60.__r_.__value_.__r.__words[2]);
          else
            size = v60.__r_.__value_.__l.__size_;
          v34 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v32, size);
          v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v35;
          v34->__r_.__value_.__l.__size_ = 0;
          v34->__r_.__value_.__r.__words[2] = 0;
          v34->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__dst.st_gid) < 0)
            operator delete(*(void **)&__dst.st_dev);
          v36 = HIBYTE(v60.__r_.__value_.__r.__words[2]);
          if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v36 = v60.__r_.__value_.__l.__size_;
          if (v36 == 2)
          {
            v38 = &v60;
            if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v38 = (std::string *)v60.__r_.__value_.__r.__words[0];
            if (LOWORD(v38->__r_.__value_.__l.__data_) == 11822)
            {
LABEL_70:
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                p_p = &__p;
              else
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              v42 = strlen((const char *)p_p);
              if (v42 > 0x7FFFFFFFFFFFFFF7)
                std::string::__throw_length_error[abi:ne180100]();
              v43 = v42;
              if (v42 >= 0x17)
              {
                v45 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v42 | 7) != 0x17)
                  v45 = v42 | 7;
                v46 = v45 + 1;
                v44 = operator new(v45 + 1);
                __dst.st_ino = v43;
                *(_QWORD *)&__dst.st_uid = v46 | 0x8000000000000000;
                *(_QWORD *)&__dst.st_dev = v44;
              }
              else
              {
                HIBYTE(__dst.st_gid) = v42;
                v44 = &__dst;
                if (!v42)
                {
LABEL_81:
                  v44[v43] = 0;
                  st_gid_high = SHIBYTE(__dst.st_gid);
                  v48 = *(void **)&__dst.st_dev;
                  if ((__dst.st_gid & 0x80000000) == 0)
                    v49 = &__dst;
                  else
                    v49 = *(stat **)&__dst.st_dev;
                  updated = chown((const char *)v49, a2, a3) == 0;
                  if (st_gid_high < 0)
                  {
                    v50 = v48;
LABEL_86:
                    operator delete(v50);
                    goto LABEL_87;
                  }
                  goto LABEL_87;
                }
              }
              memmove(v44, p_p, v43);
              goto LABEL_81;
            }
          }
          else if (v36 == 1)
          {
            v37 = &v60;
            if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v37 = (std::string *)v60.__r_.__value_.__r.__words[0];
            if (v37->__r_.__value_.__s.__data_[0] == 46)
              goto LABEL_70;
          }
          v39.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v39.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&__dst.st_blksize = v39;
          *(timespec *)__dst.st_qspare = v39;
          __dst.st_birthtimespec = v39;
          *(timespec *)&__dst.st_size = v39;
          __dst.st_mtimespec = v39;
          __dst.st_ctimespec = v39;
          *(timespec *)&__dst.st_uid = v39;
          __dst.st_atimespec = v39;
          *(timespec *)&__dst.st_dev = v39;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v40 = &__p;
          else
            v40 = (std::string *)__p.__r_.__value_.__r.__words[0];
          if (stat((const char *)v40, &__dst))
            goto LABEL_70;
          v51 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &__p
              : (std::string *)__p.__r_.__value_.__r.__words[0];
          v52 = opendir((const char *)v51);
          v53 = v52;
          if (!v52)
            goto LABEL_70;
          v54 = readdir(v52);
          closedir(v53);
          if (!v54)
            goto LABEL_70;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&v58, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          else
            v58 = __p;
          updated = support::fs::updateOwner(&v58, a2, a3);
          if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
          {
            v50 = (void *)v58.__r_.__value_.__r.__words[0];
            goto LABEL_86;
          }
LABEL_87:
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
LABEL_91:
              operator delete(v60.__r_.__value_.__l.__data_);
          }
          else if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
          {
            goto LABEL_91;
          }
          if (v22 == (const std::string::value_type **)v57)
            v23 = 0;
          else
            v23 = updated;
          v22 += 3;
          if ((v23 & 1) == 0)
          {
            v21 = (char *)v61;
            if (!v61)
              return updated;
LABEL_105:
            v55 = (void **)v62;
            v16 = v21;
            if (v62 != v21)
            {
              do
              {
                if (*((char *)v55 - 1) < 0)
                  operator delete(*(v55 - 3));
                v55 -= 3;
              }
              while (v55 != (void **)v21);
              v16 = v61;
            }
            v62 = v21;
LABEL_112:
            operator delete(v16);
            return updated;
          }
        }
      }
    }
  }
  if (v5[23] < 0)
    v5 = *(const char **)v5;
  v7 = strlen(v5);
  if (v7 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = operator new(v10 + 1);
    __dst.st_ino = v8;
    *(_QWORD *)&__dst.st_uid = v11 | 0x8000000000000000;
    *(_QWORD *)&__dst.st_dev = v9;
    goto LABEL_13;
  }
  HIBYTE(__dst.st_gid) = v7;
  v9 = &__dst;
  if (v7)
LABEL_13:
    memmove(v9, v5, v8);
  *((_BYTE *)v9 + v8) = 0;
  v12 = SHIBYTE(__dst.st_gid);
  v13 = *(void **)&__dst.st_dev;
  if ((__dst.st_gid & 0x80000000) == 0)
    v14 = &__dst;
  else
    v14 = *(stat **)&__dst.st_dev;
  updated = chown((const char *)v14, a2, a3) == 0;
  if (v12 < 0)
  {
    v16 = v13;
    goto LABEL_112;
  }
  return updated;
}

void sub_1A34A7280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31)
{
  std::vector<std::string>::~vector[abi:ne180100](&a31);
  _Unwind_Resume(a1);
}

void sub_1A34A72B0()
{
  JUMPOUT(0x1A34A72E0);
}

DIR *support::fs::isDir(const char *a1)
{
  const char *v1;
  timespec v2;
  DIR *result;
  const char *v4;
  DIR *v5;
  dirent *v6;
  stat v7;

  v1 = a1;
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v7.st_blksize = v2;
  *(timespec *)v7.st_qspare = v2;
  v7.st_birthtimespec = v2;
  *(timespec *)&v7.st_size = v2;
  v7.st_mtimespec = v2;
  v7.st_ctimespec = v2;
  *(timespec *)&v7.st_uid = v2;
  v7.st_atimespec = v2;
  *(timespec *)&v7.st_dev = v2;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (stat(a1, &v7))
    return 0;
  if (v1[23] >= 0)
    v4 = v1;
  else
    v4 = *(const char **)v1;
  result = opendir(v4);
  if (result)
  {
    v5 = result;
    v6 = readdir(result);
    closedir(v5);
    return (DIR *)(v6 != 0);
  }
  return result;
}

BOOL support::fs::chown(const char *a1, uid_t a2, gid_t a3)
{
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  return chown(a1, a2, a3) == 0;
}

DIR *support::fs::readDir(const char *a1, uint64_t a2)
{
  DIR *result;
  DIR *v4;
  dirent *v5;
  dirent *v6;
  size_t d_namlen;
  _BYTE *v8;
  std::string *v9;
  __int128 v10;
  uint64_t v11;
  _BYTE __dst[24];

  if (a1[23] < 0)
    a1 = *(const char **)a1;
  result = opendir(a1);
  if (result)
  {
    v4 = result;
    v5 = readdir(result);
    if (v5)
    {
      v6 = v5;
      do
      {
        memset(__dst, 170, sizeof(__dst));
        d_namlen = v6->d_namlen;
        if (d_namlen >= 0x17)
        {
          if ((d_namlen | 7) == 0x17)
            v11 = ((unsigned __int16)d_namlen & 0xFFF8) + 8;
          else
            v11 = d_namlen | 7;
          v8 = operator new(v11 + 1);
          *(_QWORD *)&__dst[8] = d_namlen;
          *(_QWORD *)&__dst[16] = v11 - 0x7FFFFFFFFFFFFFFFLL;
          *(_QWORD *)__dst = v8;
        }
        else
        {
          __dst[23] = v6->d_namlen;
          v8 = __dst;
          if (!(_DWORD)d_namlen)
          {
            __dst[d_namlen] = 0;
            v9 = *(std::string **)(a2 + 8);
            if ((unint64_t)v9 < *(_QWORD *)(a2 + 16))
              goto LABEL_10;
            goto LABEL_17;
          }
        }
        memmove(v8, v6->d_name, d_namlen);
        v8[d_namlen] = 0;
        v9 = *(std::string **)(a2 + 8);
        if ((unint64_t)v9 < *(_QWORD *)(a2 + 16))
        {
LABEL_10:
          if ((__dst[23] & 0x80000000) != 0)
          {
            std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)__dst, *(std::string::size_type *)&__dst[8]);
          }
          else
          {
            v10 = *(_OWORD *)__dst;
            v9->__r_.__value_.__r.__words[2] = *(_QWORD *)&__dst[16];
            *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
          }
          *(_QWORD *)(a2 + 8) = v9 + 1;
          *(_QWORD *)(a2 + 8) = v9 + 1;
          if ((__dst[23] & 0x80000000) == 0)
            goto LABEL_6;
LABEL_21:
          operator delete(*(void **)__dst);
          goto LABEL_6;
        }
LABEL_17:
        *(_QWORD *)(a2 + 8) = std::vector<std::string>::__push_back_slow_path<std::string const&>((char **)a2, (uint64_t)__dst);
        if ((__dst[23] & 0x80000000) != 0)
          goto LABEL_21;
LABEL_6:
        v6 = readdir(v4);
      }
      while (v6);
    }
    return (DIR *)closedir(v4);
  }
  return result;
}

void sub_1A34A7544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  uint64_t v16;

  *(_QWORD *)(v15 + 8) = v16;
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t support::fs::getUidGid(int a1, uid_t *a2, gid_t *a3)
{
  passwd *v5;
  unsigned __int8 v7;
  NSObject *v8;
  void *__p[3];
  uint8_t buf[4];
  void **v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(__p, 170, sizeof(__p));
  if (a1 == 1)
  {
    HIBYTE(__p[2]) = 9;
    strcpy((char *)__p, "_wireless");
    v5 = getpwnam((const char *)__p);
    if (v5)
      goto LABEL_4;
    goto LABEL_6;
  }
  if (!a1)
  {
    HIBYTE(__p[2]) = 6;
    strcpy((char *)__p, "mobile");
    v5 = getpwnam((const char *)__p);
    if (v5)
    {
LABEL_4:
      *a2 = v5->pw_uid;
      *a3 = v5->pw_gid;
      return 1;
    }
LABEL_6:
    {
      GetOsLogContext(void)::sOsLogContext = 0;
      qword_1ED114D18 = 0;
      __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
    }
    if (GetOsLogContext(void)::onceToken == -1)
    {
      v8 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    else
    {
      dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
      v8 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    *(_DWORD *)buf = 136315138;
    v11 = __p;
    _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Getting uid and gid: failed to get passwd for %s", buf, 0xCu);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
  }
  return 0;
}

BOOL support::fs::writeToCompletion(support::fs *this, char *__buf, size_t __nbyte)
{
  int v4;
  size_t v5;
  ssize_t v6;

  v4 = (int)this;
  do
  {
    v5 = __nbyte;
    if (!__nbyte)
      break;
    v6 = write(v4, __buf, __nbyte);
    __nbyte = v5 - v6;
    __buf += v6;
  }
  while ((v6 & 0x8000000000000000) == 0);
  return v5 == 0;
}

BOOL support::fs::writeToCompletion(FILE *__stream, __sFILE *__ptr, size_t __nitems)
{
  size_t v5;
  size_t v6;

  while (1)
  {
    v5 = __nitems;
    if (!__nitems)
      break;
    v6 = fwrite(__ptr, 1uLL, __nitems, __stream);
    __nitems = v5 - v6;
    __ptr = (__sFILE *)((char *)__ptr + v6);
    if (!v6)
      return v5 == 0;
  }
  fflush(__stream);
  return 1;
}

uint64_t support::fs::openFile(const char *a1, int a2, unsigned int a3)
{
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  return open(a1, a2, a3);
}

BOOL support::fs::closeFile(support::fs *this)
{
  int v1;
  int v2;

  v1 = (int)this;
  do
    v2 = close(v1);
  while (v2 && *__error() == 4);
  return v2 == 0;
}

BOOL support::fs::copyFile(const char *a1, const char *a2, int a3)
{
  const char *v6;
  size_t v7;
  size_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  int v13;
  int v14;
  const char *v15;
  size_t v16;
  size_t v17;
  _BYTE *v18;
  unsigned __int8 v19;
  NSObject *v20;
  _BOOL8 v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  int v25;
  int v26;
  ssize_t v27;
  _BYTE *v28;
  ssize_t v29;
  __int128 v30;
  unsigned __int8 v31;
  NSObject *v32;
  const char *v34;
  const char *v35;
  _BYTE __dst[1024];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a1[23] >= 0)
    v6 = a1;
  else
    v6 = *(const char **)a1;
  v7 = strlen(v6);
  if (v7 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = operator new(v10 + 1);
    *(_QWORD *)&__dst[8] = v8;
    *(_QWORD *)&__dst[16] = v11 | 0x8000000000000000;
    *(_QWORD *)__dst = v9;
    goto LABEL_11;
  }
  __dst[23] = v7;
  v9 = __dst;
  if (v7)
LABEL_11:
    memmove(v9, v6, v8);
  v9[v8] = 0;
  if (__dst[23] >= 0)
    v12 = __dst;
  else
    v12 = *(const char **)__dst;
  v13 = open(v12, 0, 420);
  v14 = v13;
  if ((__dst[23] & 0x80000000) == 0)
  {
    if ((v13 & 0x80000000) == 0)
      goto LABEL_17;
LABEL_25:
    {
      GetOsLogContext(void)::sOsLogContext = 0;
      qword_1ED114D18 = 0;
      __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
    }
    if (GetOsLogContext(void)::onceToken == -1)
    {
      v20 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    else
    {
      dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
      v20 = qword_1ED114D18;
      if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
        return 0;
    }
    if (a1[23] >= 0)
      v34 = a1;
    else
      v34 = *(const char **)a1;
    *(_DWORD *)__dst = 136315138;
    *(_QWORD *)&__dst[4] = v34;
    _os_log_error_impl(&dword_1A343C000, v20, OS_LOG_TYPE_ERROR, "Failed to open the source file(%s)", __dst, 0xCu);
    return 0;
  }
  operator delete(*(void **)__dst);
  if (v14 < 0)
    goto LABEL_25;
LABEL_17:
  if (a2[23] >= 0)
    v15 = a2;
  else
    v15 = *(const char **)a2;
  v16 = strlen(v15);
  if (v16 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v17 = v16;
  if (v16 >= 0x17)
  {
    v22 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v22 = v16 | 7;
    v23 = v22 + 1;
    v18 = operator new(v22 + 1);
    *(_QWORD *)&__dst[8] = v17;
    *(_QWORD *)&__dst[16] = v23 | 0x8000000000000000;
    *(_QWORD *)__dst = v18;
    goto LABEL_32;
  }
  __dst[23] = v16;
  v18 = __dst;
  if (v16)
LABEL_32:
    memmove(v18, v15, v17);
  v18[v17] = 0;
  if (__dst[23] >= 0)
    v24 = __dst;
  else
    v24 = *(const char **)__dst;
  v25 = open(v24, 1541, 420);
  v26 = v25;
  if ((__dst[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__dst);
    if ((v26 & 0x80000000) == 0)
      goto LABEL_38;
  }
  else if ((v25 & 0x80000000) == 0)
  {
LABEL_38:
    memset(__dst, 170, sizeof(__dst));
    v27 = read(v14, __dst, 0x400uLL);
    if (v27 < 1)
    {
LABEL_44:
      v21 = v27 == 0;
      if (!v27 && a3)
      {
        *(_QWORD *)&v30 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&__dst[112] = v30;
        *(_OWORD *)&__dst[128] = v30;
        *(_OWORD *)&__dst[80] = v30;
        *(_OWORD *)&__dst[96] = v30;
        *(_OWORD *)&__dst[48] = v30;
        *(_OWORD *)&__dst[64] = v30;
        *(_OWORD *)&__dst[16] = v30;
        *(_OWORD *)&__dst[32] = v30;
        *(_OWORD *)__dst = v30;
        if (fstat(v14, (stat *)__dst))
          v21 = 0;
        else
          v21 = fchmod(v26, *(mode_t *)&__dst[4]) == 0;
      }
    }
    else
    {
      v28 = __dst;
      do
      {
        while (!v27)
        {
          memset(__dst, 170, sizeof(__dst));
          v27 = read(v14, __dst, 0x400uLL);
          v28 = __dst;
          if (v27 <= 0)
            goto LABEL_44;
        }
        v29 = write(v26, v28, v27);
        v27 -= v29;
        v28 += v29;
      }
      while ((v29 & 0x8000000000000000) == 0);
      v21 = 0;
    }
    while (close(v26) && *__error() == 4)
      ;
    goto LABEL_56;
  }
  {
    GetOsLogContext(void)::sOsLogContext = 0;
    qword_1ED114D18 = 0;
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
  }
  if (GetOsLogContext(void)::onceToken != -1)
  {
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
    v32 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      goto LABEL_52;
LABEL_65:
    if (a2[23] >= 0)
      v35 = a2;
    else
      v35 = *(const char **)a2;
    *(_DWORD *)__dst = 136315138;
    *(_QWORD *)&__dst[4] = v35;
    _os_log_error_impl(&dword_1A343C000, v32, OS_LOG_TYPE_ERROR, "Failed to open the destination file(%s)", __dst, 0xCu);
    goto LABEL_52;
  }
  v32 = qword_1ED114D18;
  if (os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
    goto LABEL_65;
LABEL_52:
  v21 = 0;
LABEL_56:
  while (close(v14) && *__error() == 4)
    ;
  return v21;
}

void sub_1A34A7D9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL support::fs::loadFile(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  _BOOL8 v4;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  char *v18;
  char *v19;
  unint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  char v27;
  _QWORD __b[91];

  __b[89] = *MEMORY[0x1E0C80C00];
  memset(__b, 170, 0x240uLL);
  std::ifstream::basic_ifstream(__b);
  if (!__b[17]
    || (std::istream::tellg(), std::istream::seekg(), std::istream::tellg(), v3 = __b[88], std::istream::seekg(), !v3)
    || *(_DWORD *)((char *)&__b[4] + *(_QWORD *)(__b[0] - 24)))
  {
    v4 = 0;
    goto LABEL_5;
  }
  v7 = *(char **)a2;
  v6 = *(char **)(a2 + 8);
  v8 = (unint64_t)&v6[-*(_QWORD *)a2];
  v9 = v3 - v8;
  if (v3 <= v8)
  {
    if (v3 < v8)
      *(_QWORD *)(a2 + 8) = &v7[v3];
    goto LABEL_36;
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10 - (uint64_t)v6 < v9)
  {
    if ((v3 & 0x8000000000000000) != 0)
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    v11 = v10 - (_QWORD)v7;
    v12 = 2 * v11;
    if (2 * v11 <= v3)
      v12 = v3;
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL)
      v13 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v14 = (char *)operator new(v13);
    v15 = &v14[v8];
    v16 = &v14[v13];
    bzero(&v14[v8], v3 - v8);
    if (v6 == v7)
      goto LABEL_34;
    if (v8 >= 8 && (unint64_t)(v7 - v14) >= 0x20)
    {
      if (v8 < 0x20)
      {
        v17 = 0;
        goto LABEL_26;
      }
      v17 = v8 & 0xFFFFFFFFFFFFFFE0;
      v18 = v6 - 16;
      v19 = &v14[v6 - 16 - v7];
      v20 = v8 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v21 = *(_OWORD *)v18;
        *((_OWORD *)v19 - 1) = *((_OWORD *)v18 - 1);
        *(_OWORD *)v19 = v21;
        v19 -= 32;
        v18 -= 32;
        v20 -= 32;
      }
      while (v20);
      if (v8 == v17)
        goto LABEL_33;
      if ((v8 & 0x18) != 0)
      {
LABEL_26:
        v15 -= v8 & 0xFFFFFFFFFFFFFFF8;
        v22 = &v6[-v17 - 8];
        v23 = (char *)(v22 - v7);
        v24 = v17 - (v8 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          v25 = *(_QWORD *)v22;
          v22 -= 8;
          *(_QWORD *)&v23[(_QWORD)v14] = v25;
          v23 -= 8;
          v24 += 8;
        }
        while (v24);
        v6 -= v8 & 0xFFFFFFFFFFFFFFF8;
        if (v8 == (v8 & 0xFFFFFFFFFFFFFFF8))
          goto LABEL_33;
        goto LABEL_31;
      }
      v15 -= v17;
      v6 -= v17;
    }
LABEL_31:
    v26 = v15 - 1;
    do
    {
      v27 = *--v6;
      *v26-- = v27;
    }
    while (v6 != v7);
LABEL_33:
    v6 = v7;
    v15 = v14;
LABEL_34:
    *(_QWORD *)a2 = v15;
    *(_QWORD *)(a2 + 8) = &v14[v3];
    *(_QWORD *)(a2 + 16) = v16;
    if (v6)
      operator delete(v6);
    goto LABEL_36;
  }
  bzero(*(void **)(a2 + 8), v3 - v8);
  *(_QWORD *)(a2 + 8) = &v6[v9];
LABEL_36:
  std::istream::read();
  v4 = __b[1] == (int)v3;
  if (!std::filebuf::close())
    std::ios_base::clear((std::ios_base *)((char *)__b + *(_QWORD *)(__b[0] - 24)), *(_DWORD *)((char *)&__b[4] + *(_QWORD *)(__b[0] - 24)) | 4);
LABEL_5:
  __b[0] = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)__b + *(_QWORD *)(__b[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
  MEMORY[0x1A858F6F8](&__b[2]);
  std::istream::~istream();
  MEMORY[0x1A858F92C](&__b[53]);
  return v4;
}

void sub_1A34A80DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::ifstream::~ifstream((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::basic_ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x1E0DE4FA8];
  v3 = MEMORY[0x1E0DE4FA8] + 64;
  a1[53] = MEMORY[0x1E0DE4FA8] + 64;
  v4 = a1 + 2;
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 8);
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  a1[1] = 0;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 2);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[53] = v3;
  MEMORY[0x1A858F6EC](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_1A34A81D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x1A858F92C](v1 + 424);
  _Unwind_Resume(a1);
}

BOOL support::fs::getFileSize(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 136);
  if (v2)
  {
    std::istream::tellg();
    std::istream::seekg();
    std::istream::tellg();
    *a2 = v5;
    std::istream::seekg();
  }
  return v2 != 0;
}

{
  uint64_t v2;
  _BOOL8 v4;
  _QWORD v6[90];

  v6[89] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int8 *)(a1 + 23);
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  memset(v6, 170, 0x240uLL);
  std::ifstream::basic_ifstream(v6);
  v4 = v6[17] != 0;
  if (v6[17])
  {
    std::istream::tellg();
    std::istream::seekg();
    std::istream::tellg();
    *a2 = v6[88];
    std::istream::seekg();
    if (!std::filebuf::close())
      std::ios_base::clear((std::ios_base *)((char *)v6 + *(_QWORD *)(v6[0] - 24)), *(_DWORD *)((char *)&v6[4] + *(_QWORD *)(v6[0] - 24)) | 4);
  }
  v6[0] = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)v6 + *(_QWORD *)(v6[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
  MEMORY[0x1A858F6F8](&v6[2]);
  std::istream::~istream();
  MEMORY[0x1A858F92C](&v6[53]);
  return v4;
}

_QWORD *std::ifstream::~ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F40];
  v3 = *MEMORY[0x1E0DE4F40];
  *a1 = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x1A858F6F8](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1A858F92C](a1 + 53);
  return a1;
}

uint64_t support::fs::loadFile(const char *a1, uint64_t a2)
{
  FILE *v3;
  FILE *v4;
  unint64_t v5;
  size_t v6;
  char *v7;
  char *v8;
  unint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  unint64_t v22;
  __int128 v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  char v29;
  char *v30;

  if (a1[23] < 0)
    a1 = *(const char **)a1;
  v3 = fopen(a1, "rb");
  if (v3)
  {
    v4 = v3;
    fseek(v3, 0, 2);
    v5 = MEMORY[0x1A858FE18](v4);
    if (v5 != -1)
    {
      v6 = v5;
      v8 = *(char **)a2;
      v7 = *(char **)(a2 + 8);
      v9 = (unint64_t)&v7[-*(_QWORD *)a2];
      v10 = v5 - v9;
      if (v5 <= v9)
      {
        if (v5 < v9)
          *(_QWORD *)(a2 + 8) = &v8[v5];
        goto LABEL_36;
      }
      v11 = *(_QWORD *)(a2 + 16);
      if (v11 - (uint64_t)v7 >= v10)
      {
        bzero(*(void **)(a2 + 8), v10);
        *(_QWORD *)(a2 + 8) = &v7[v10];
LABEL_36:
        rewind(v4);
        v30 = *(char **)a2;
        v19 = 1;
        fread(v30, v6, 1uLL, v4);
        fclose(v4);
        return v19;
      }
      if ((v5 & 0x8000000000000000) != 0)
        std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
      v12 = v11 - (_QWORD)v8;
      v13 = 2 * v12;
      if (2 * v12 <= v5)
        v13 = v5;
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
        v14 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      v15 = (char *)operator new(v14);
      v16 = &v15[v9];
      v17 = &v15[v14];
      bzero(&v15[v9], v10);
      if (v7 == v8)
      {
LABEL_34:
        *(_QWORD *)a2 = v16;
        *(_QWORD *)(a2 + 8) = &v15[v6];
        *(_QWORD *)(a2 + 16) = v17;
        if (v7)
          operator delete(v7);
        goto LABEL_36;
      }
      if (v9 >= 8 && (unint64_t)(v8 - v15) >= 0x20)
      {
        if (v9 < 0x20)
        {
          v18 = 0;
          goto LABEL_26;
        }
        v18 = v9 & 0xFFFFFFFFFFFFFFE0;
        v20 = v7 - 16;
        v21 = &v15[v7 - 16 - v8];
        v22 = v9 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v23 = *(_OWORD *)v20;
          *((_OWORD *)v21 - 1) = *((_OWORD *)v20 - 1);
          *(_OWORD *)v21 = v23;
          v21 -= 32;
          v20 -= 32;
          v22 -= 32;
        }
        while (v22);
        if (v9 == v18)
          goto LABEL_33;
        if ((v9 & 0x18) != 0)
        {
LABEL_26:
          v16 -= v9 & 0xFFFFFFFFFFFFFFF8;
          v24 = &v7[-v18 - 8];
          v25 = (char *)(v24 - v8);
          v26 = v18 - (v9 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v27 = *(_QWORD *)v24;
            v24 -= 8;
            *(_QWORD *)&v25[(_QWORD)v15] = v27;
            v25 -= 8;
            v26 += 8;
          }
          while (v26);
          v7 -= v9 & 0xFFFFFFFFFFFFFFF8;
          if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_33;
          goto LABEL_31;
        }
        v16 -= v18;
        v7 -= v18;
      }
LABEL_31:
      v28 = v16 - 1;
      do
      {
        v29 = *--v7;
        *v28-- = v29;
      }
      while (v7 != v8);
LABEL_33:
      v7 = v8;
      v16 = v15;
      goto LABEL_34;
    }
  }
  return 0;
}

BOOL support::fs::fileExists(const char *a1)
{
  timespec v1;
  stat v3;

  v1.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v1.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v3.st_blksize = v1;
  *(timespec *)v3.st_qspare = v1;
  v3.st_birthtimespec = v1;
  *(timespec *)&v3.st_size = v1;
  v3.st_mtimespec = v1;
  v3.st_ctimespec = v1;
  *(timespec *)&v3.st_uid = v1;
  v3.st_atimespec = v1;
  *(timespec *)&v3.st_dev = v1;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  return stat(a1, &v3) == 0;
}

void support::fs::createUniqueFilename(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v4;
  unsigned int i;
  timespec v6;
  std::string *v7;
  uint64_t v8;
  std::sub_match<const char *> *v9;
  std::sub_match<std::__wrap_iter<const char *>> *v10;
  __int128 v11;
  int v12;
  int v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  uint64_t v18;
  std::__wrap_iter<const char *> v19;
  std::__wrap_iter<const char *> v20;
  char *v21;
  std::__shared_weak_count *cntrl;
  uint64_t *p_shared_owners;
  unint64_t v24;
  std::string v25;
  std::string v26;
  std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type v27;
  stat v28;
  std::vector<std::ssub_match> v29[2];
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v27.__loop_count_ = v4;
  *(_OWORD *)&v27.__start_.__cntrl_ = v4;
  *(_OWORD *)&v27.__traits_.__loc_.__locale_ = v4;
  *(_OWORD *)&v27.__traits_.__col_ = v4;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v27, "^([/_\\-[:alnum:]]*)(.*)", 0);
  memset(&v26, 170, sizeof(v26));
  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    v26 = *(std::string *)a1;
  for (i = 1; ; ++i)
  {
    v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v28.st_blksize = v6;
    *(timespec *)v28.st_qspare = v6;
    v28.st_birthtimespec = v6;
    *(timespec *)&v28.st_size = v6;
    v28.st_mtimespec = v6;
    v28.st_ctimespec = v6;
    *(timespec *)&v28.st_uid = v6;
    v28.st_atimespec = v6;
    *(timespec *)&v28.st_dev = v6;
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v7 = &v26;
    else
      v7 = (std::string *)v26.__r_.__value_.__r.__words[0];
    if (stat((const char *)v7, &v28))
    {
      *(std::string *)a2 = v26;
      goto LABEL_42;
    }
    v8 = *(unsigned __int8 *)(a1 + 23);
    if ((v8 & 0x80u) == 0)
      v9 = (std::sub_match<const char *> *)a1;
    else
      v9 = *(std::sub_match<const char *> **)a1;
    if ((v8 & 0x80u) != 0)
      v8 = *(_QWORD *)(a1 + 8);
    v10 = (std::sub_match<std::__wrap_iter<const char *>> *)((char *)v9 + v8);
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v35 = v11;
    v32 = 0xAAAAAAAAAAAAAA00;
    v29[1].__end_cap_.__value_ = (std::sub_match<std::__wrap_iter<const char *>> *)0xAAAAAAAAAAAAAAAALL;
    v30 = 0;
    v31 = 0;
    v33 = 0;
    v34 = 0;
    LOBYTE(v35) = 0;
    BYTE8(v35) = 0;
    v36 = 0;
    memset(v29, 0, 41);
    *(_OWORD *)&v28.st_birthtimespec.tv_nsec = v11;
    v28.st_ctimespec.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v28.st_atimespec.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    memset(&v28.st_mtimespec, 0, 17);
    memset(&v28.st_ctimespec.tv_nsec, 0, 17);
    LOBYTE(v28.st_size) = 0;
    v28.st_blocks = 0;
    memset(&v28, 0, 41);
    v12 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&v27, v9, (std::sub_match<const char *> *)((char *)v9 + v8), (std::vector<std::csub_match> *)&v28, 4160);
    std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v29, (uint64_t)v9, v10, (uint64_t *)&v28.st_dev, 0);
    if (*(_QWORD *)&v28.st_dev)
    {
      v28.st_ino = *(_QWORD *)&v28.st_dev;
      operator delete(*(void **)&v28.st_dev);
    }
    if ((_BYTE)v35)
      v13 = v12 ^ 1;
    else
      v13 = 1;
    if (v29[0].__begin_)
    {
      v29[0].__end_ = v29[0].__begin_;
      operator delete(v29[0].__begin_);
    }
    if ((v12 & v13) == 0)
      break;
    memset(&v28, 170, 24);
    std::to_string(&v25, i);
    v14 = std::string::insert(&v25, 0, "$1-", 3uLL);
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v29[0].__end_cap_.__value_ = (std::sub_match<std::__wrap_iter<const char *>> *)v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29[0].__begin_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    v16 = std::string::append((std::string *)v29, "$2", 2uLL);
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    *(_QWORD *)&v28.st_uid = *((_QWORD *)&v16->__r_.__value_.__l + 2);
    *(_OWORD *)&v28.st_dev = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v29[0].__end_cap_.__value_) < 0)
    {
      operator delete(v29[0].__begin_);
      if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_26;
    }
    else if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_26;
    }
    operator delete(v25.__r_.__value_.__l.__data_);
LABEL_26:
    memset(v29, 0, 24);
    v18 = *(unsigned __int8 *)(a1 + 23);
    if ((v18 & 0x80u) == 0)
      v19.__i_ = (std::__wrap_iter<const char *>::iterator_type)a1;
    else
      v19.__i_ = *(std::__wrap_iter<const char *>::iterator_type *)a1;
    if ((v18 & 0x80u) != 0)
      v18 = *(_QWORD *)(a1 + 8);
    if ((v28.st_gid & 0x80000000) == 0)
      v21 = (char *)&v28;
    else
      v21 = *(char **)&v28.st_dev;
    v20.__i_ = &v19.__i_[v18];
    std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>((std::string *)v29, v19, v20, &v27, v21, 0);
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v26.__r_.__value_.__l.__data_);
      v26 = (std::string)v29[0];
      if ((SHIBYTE(v28.st_gid) & 0x80000000) == 0)
        continue;
    }
    else
    {
      v26 = (std::string)v29[0];
      if ((SHIBYTE(v28.st_gid) & 0x80000000) == 0)
        continue;
    }
    operator delete(*(void **)&v28.st_dev);
  }
  *(_BYTE *)(a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v26.__r_.__value_.__l.__data_);
LABEL_42:
  cntrl = v27.__start_.__cntrl_;
  if (v27.__start_.__cntrl_)
  {
    p_shared_owners = &v27.__start_.__cntrl_->__shared_owners_;
    do
      v24 = __ldaxr((unint64_t *)p_shared_owners);
    while (__stlxr(v24 - 1, (unint64_t *)p_shared_owners));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))cntrl->__on_zero_shared)(cntrl);
      std::__shared_weak_count::__release_weak(cntrl);
    }
  }
  std::locale::~locale(&v27.__traits_.__loc_);
}

void sub_1A34A894C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::locale a19)
{
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a19);
  _Unwind_Resume(a1);
}

void sub_1A34A8960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::locale a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v38;

  if (*(char *)(v38 - 185) < 0)
    operator delete(*(void **)(v38 - 208));
  if (a38 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a25);
  _Unwind_Resume(a1);
}

void support::fs::createUniquePath(const char *a1@<X0>, std::string *a2@<X8>)
{
  const char *v2;
  timespec v4;
  timespec v5;
  size_t v6;
  __darwin_ino64_t v7;
  int v8;
  timespec v9;
  stat *p_dst;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const std::string::value_type *v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  timespec v18;
  const char *v19;
  stat __dst;
  stat __src;
  timespec v22;
  timespec v23;
  timespec v24;
  timespec v25;
  timespec v26;
  timespec v27;
  timespec v28;
  uint64_t v29;

  v2 = a1;
  v29 = *MEMORY[0x1E0C80C00];
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__src.st_blksize = v4;
  *(timespec *)__src.st_qspare = v4;
  __src.st_birthtimespec = v4;
  *(timespec *)&__src.st_size = v4;
  __src.st_mtimespec = v4;
  __src.st_ctimespec = v4;
  *(timespec *)&__src.st_uid = v4;
  __src.st_atimespec = v4;
  *(timespec *)&__src.st_dev = v4;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (!stat(a1, &__src))
  {
    v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    v27 = v5;
    v28 = v5;
    v25 = v5;
    v26 = v5;
    v23 = v5;
    v24 = v5;
    *(timespec *)__src.st_qspare = v5;
    v22 = v5;
    *(timespec *)&__src.st_size = v5;
    *(timespec *)&__src.st_blksize = v5;
    __src.st_ctimespec = v5;
    __src.st_birthtimespec = v5;
    __src.st_atimespec = v5;
    __src.st_mtimespec = v5;
    *(timespec *)&__src.st_dev = v5;
    *(timespec *)&__src.st_uid = v5;
    snprintf((char *)&__src, 0x100uLL, "-%u", 1);
    memset(a2, 170, sizeof(std::string));
    v6 = strlen((const char *)&__src);
    if (v6 > 0x7FFFFFFFFFFFFFF7)
LABEL_32:
      std::string::__throw_length_error[abi:ne180100]();
    v7 = v6;
    v8 = 2;
    while (v7 < 0x17)
    {
      HIBYTE(__dst.st_gid) = v7;
      p_dst = &__dst;
      if (v7)
        goto LABEL_15;
LABEL_16:
      *((_BYTE *)&p_dst->st_dev + v7) = 0;
      v13 = v2[23];
      if (v13 >= 0)
        v14 = v2;
      else
        v14 = *(const std::string::value_type **)v2;
      if (v13 >= 0)
        v15 = *((unsigned __int8 *)v2 + 23);
      else
        v15 = *((_QWORD *)v2 + 1);
      v16 = std::string::insert((std::string *)&__dst, 0, v14, v15);
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      a2->__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__dst.st_gid) < 0)
        operator delete(*(void **)&__dst.st_dev);
      v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&__dst.st_blksize = v18;
      *(timespec *)__dst.st_qspare = v18;
      __dst.st_birthtimespec = v18;
      *(timespec *)&__dst.st_size = v18;
      __dst.st_mtimespec = v18;
      __dst.st_ctimespec = v18;
      *(timespec *)&__dst.st_uid = v18;
      __dst.st_atimespec = v18;
      *(timespec *)&__dst.st_dev = v18;
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v19 = (const char *)a2;
      else
        v19 = (const char *)a2->__r_.__value_.__r.__words[0];
      if (stat(v19, &__dst))
        return;
      if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
        operator delete(a2->__r_.__value_.__l.__data_);
      v9.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v9.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      v27 = v9;
      v28 = v9;
      v25 = v9;
      v26 = v9;
      v23 = v9;
      v24 = v9;
      *(timespec *)__src.st_qspare = v9;
      v22 = v9;
      *(timespec *)&__src.st_size = v9;
      *(timespec *)&__src.st_blksize = v9;
      __src.st_ctimespec = v9;
      __src.st_birthtimespec = v9;
      __src.st_atimespec = v9;
      __src.st_mtimespec = v9;
      *(timespec *)&__src.st_dev = v9;
      *(timespec *)&__src.st_uid = v9;
      snprintf((char *)&__src, 0x100uLL, "-%u", v8);
      memset(a2, 170, sizeof(std::string));
      v7 = strlen((const char *)&__src);
      ++v8;
      if (v7 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_32;
    }
    v11 = (v7 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v11 = v7 | 7;
    v12 = v11 + 1;
    p_dst = (stat *)operator new(v11 + 1);
    __dst.st_ino = v7;
    *(_QWORD *)&__dst.st_uid = v12 | 0x8000000000000000;
    *(_QWORD *)&__dst.st_dev = p_dst;
LABEL_15:
    memcpy(p_dst, &__src, v7);
    goto LABEL_16;
  }
  if (v2[23] < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v2;
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)v2 + 2);
  }
}

void sub_1A34A8C9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL support::fs::createDir(const char *a1, mode_t a2, int a3)
{
  const char *v5;
  timespec v6;
  const char *v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  void **v11;
  std::string::size_type v12;
  uint64_t v13;
  int v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  timespec v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  _BYTE __p[56];
  void *v27[2];
  uint64_t v28;
  stat v29;

  v5 = a1;
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v29.st_blksize = v6;
  *(timespec *)v29.st_qspare = v6;
  v29.st_birthtimespec = v6;
  *(timespec *)&v29.st_size = v6;
  v29.st_mtimespec = v6;
  v29.st_ctimespec = v6;
  *(timespec *)&v29.st_uid = v6;
  v29.st_atimespec = v6;
  *(timespec *)&v29.st_dev = v6;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (!stat(a1, &v29))
    return 1;
  if (!a3)
  {
    if (v5[23] >= 0)
      v21 = v5;
    else
      v21 = *(const char **)v5;
    return mkdir(v21, a2) == 0;
  }
  v27[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v28 = 0x1AAAAAAAAAAAAAALL;
  v27[0] = (void *)0xAAAAAAAAAAAA002FLL;
  memset(&__p[32], 170, 24);
  ctu::tokenize();
  memset(__p, 0, 24);
  if (v5[23] >= 0)
    v7 = v5;
  else
    v7 = *(const char **)v5;
  if (*v7 == 47)
  {
    *(_OWORD *)__p = *(_OWORD *)v27;
    *(_QWORD *)&__p[16] = v28;
  }
  v8 = *(_QWORD *)&__p[32];
  if (*(_QWORD *)&__p[40] != *(_QWORD *)&__p[32])
  {
    v9 = 0;
    v10 = 1;
    while (1)
    {
      if (v10 != 1)
      {
        if (v28 >= 0)
          v11 = v27;
        else
          v11 = (void **)v27[0];
        if (v28 >= 0)
          v12 = HIBYTE(v28);
        else
          v12 = (std::string::size_type)v27[1];
        std::string::append((std::string *)__p, (const std::string::value_type *)v11, v12);
        v8 = *(_QWORD *)&__p[32];
      }
      v13 = v8 + 24 * v9;
      v14 = *(char *)(v13 + 23);
      v15 = v14 >= 0 ? (const std::string::value_type *)v13 : *(const std::string::value_type **)v13;
      v16 = v14 >= 0 ? *(unsigned __int8 *)(v13 + 23) : *(_QWORD *)(v13 + 8);
      std::string::append((std::string *)__p, v15, v16);
      v17.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v17.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v29.st_blksize = v17;
      *(timespec *)v29.st_qspare = v17;
      v29.st_birthtimespec = v17;
      *(timespec *)&v29.st_size = v17;
      v29.st_mtimespec = v17;
      v29.st_ctimespec = v17;
      *(timespec *)&v29.st_uid = v17;
      v29.st_atimespec = v17;
      *(timespec *)&v29.st_dev = v17;
      v18 = __p[23] >= 0 ? __p : *(const char **)__p;
      if (stat(v18, &v29))
      {
        v19 = __p[23] >= 0 ? __p : *(const char **)__p;
        if (mkdir(v19, a2))
          break;
      }
      v9 = v10;
      v8 = *(_QWORD *)&__p[32];
      ++v10;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&__p[40] - *(_QWORD *)&__p[32]) >> 3) <= v9)
        goto LABEL_42;
    }
    v20 = 0;
    if ((__p[23] & 0x80000000) == 0)
      goto LABEL_44;
    goto LABEL_43;
  }
LABEL_42:
  v20 = 1;
  if ((__p[23] & 0x80000000) != 0)
LABEL_43:
    operator delete(*(void **)__p);
LABEL_44:
  v22 = *(_QWORD *)&__p[32];
  if (*(_QWORD *)&__p[32])
  {
    v23 = *(_QWORD *)&__p[40];
    v24 = *(void **)&__p[32];
    if (*(_QWORD *)&__p[40] != *(_QWORD *)&__p[32])
    {
      do
      {
        if (*(char *)(v23 - 1) < 0)
          operator delete(*(void **)(v23 - 24));
        v23 -= 24;
      }
      while (v23 != v22);
      v24 = *(void **)&__p[32];
    }
    *(_QWORD *)&__p[40] = v22;
    operator delete(v24);
  }
  if (SHIBYTE(v28) < 0)
    operator delete(v27[0]);
  return v20;
}

void sub_1A34A8F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::vector<std::string>::~vector[abi:ne180100](&a16);
    if ((a24 & 0x80000000) == 0)
LABEL_3:
      _Unwind_Resume(a1);
  }
  else
  {
    std::vector<std::string>::~vector[abi:ne180100](&a16);
    if ((a24 & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(a19);
  _Unwind_Resume(a1);
}

BOOL support::fs::rename(const std::__fs::filesystem::path *a1, const std::__fs::filesystem::path *a2, std::error_code *a3)
{
  int v3;

  if ((a1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    a1 = (const std::__fs::filesystem::path *)a1->__pn_.__r_.__value_.__r.__words[0];
  if ((a2->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    a2 = (const std::__fs::filesystem::path *)a2->__pn_.__r_.__value_.__r.__words[0];
  rename(a1, a2, a3);
  return v3 == 0;
}

BOOL support::fs::chmod(const char *a1, mode_t a2)
{
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  return chmod(a1, a2) == 0;
}

uint64_t support::fs::removeDir(const char *a1)
{
  const std::__fs::filesystem::path *v1;
  timespec v2;
  _BOOL8 v3;
  std::error_code *v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  char *v8;
  __int128 v9;
  int v10;
  std::string::size_type size;
  std::string *v12;
  std::string *p_p;
  int v14;
  size_t v15;
  unint64_t v16;
  char *p_dst;
  uint64_t v18;
  uint64_t v19;
  const std::__fs::filesystem::path *v20;
  std::string *v21;
  std::string *v22;
  std::string::size_type v23;
  char v24;
  timespec v25;
  std::string *v26;
  std::error_code *v27;
  const std::__fs::filesystem::path *v28;
  std::string *v29;
  char v30;
  std::string *v31;
  DIR *v32;
  DIR *v33;
  dirent *v34;
  const std::__fs::filesystem::path *v35;
  const char *v36;
  void **v37;
  void **v38;
  void *v39;
  std::string __p;
  void *v42;
  void **v43;
  uint64_t v44;
  stat __dst;
  _QWORD v46[5];

  v1 = (const std::__fs::filesystem::path *)a1;
  v46[2] = *MEMORY[0x1E0C80C00];
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__dst.st_blksize = v2;
  *(timespec *)__dst.st_qspare = v2;
  __dst.st_birthtimespec = v2;
  *(timespec *)&__dst.st_size = v2;
  __dst.st_mtimespec = v2;
  __dst.st_ctimespec = v2;
  *(timespec *)&__dst.st_uid = v2;
  __dst.st_atimespec = v2;
  *(timespec *)&__dst.st_dev = v2;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (stat(a1, &__dst))
    return 1;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  support::fs::readDir((const char *)v1, (uint64_t)&v42);
  v5 = 0;
  while (1)
  {
    v6 = v5;
    v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v43 - (_BYTE *)v42) >> 3);
    v3 = v7 <= v5;
    if (v7 <= v5)
      break;
    v8 = (char *)v42 + 24 * v5;
    memset(&__p, 170, sizeof(__p));
    if (v8[23] < 0)
    {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
    }
    else
    {
      v9 = *(_OWORD *)v8;
      __p.__r_.__value_.__r.__words[2] = *((_QWORD *)v8 + 2);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v9;
    }
    v10 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    if (size == 2)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      if (LOWORD(p_p->__r_.__value_.__l.__data_) == 11822)
      {
LABEL_58:
        v30 = 1;
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_7;
        goto LABEL_6;
      }
    }
    else if (size == 1)
    {
      v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &__p;
      if (v12->__r_.__value_.__s.__data_[0] == 46)
        goto LABEL_58;
    }
    v14 = SHIBYTE(v1->__pn_.__r_.__value_.__r.__words[2]);
    if (v14 >= 0)
      v15 = HIBYTE(v1->__pn_.__r_.__value_.__r.__words[2]);
    else
      v15 = v1->__pn_.__r_.__value_.__l.__size_;
    v16 = v15 + 1;
    memset(&__dst, 170, 24);
    if (v15 + 1 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v16 >= 0x17)
    {
      v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17)
        v18 = v16 | 7;
      v19 = v18 + 1;
      p_dst = (char *)operator new(v18 + 1);
      __dst.st_ino = v15 + 1;
      *(_QWORD *)&__dst.st_uid = v19 | 0x8000000000000000;
      *(_QWORD *)&__dst.st_dev = p_dst;
    }
    else
    {
      memset(&__dst, 0, 24);
      p_dst = (char *)&__dst;
      HIBYTE(__dst.st_gid) = v15 + 1;
      if (!v15)
        goto LABEL_38;
    }
    if (v14 >= 0)
      v20 = v1;
    else
      v20 = (const std::__fs::filesystem::path *)v1->__pn_.__r_.__value_.__r.__words[0];
    memmove(p_dst, v20, v15);
LABEL_38:
    *(_WORD *)&p_dst[v15] = 47;
    if (v10 >= 0)
      v21 = &__p;
    else
      v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
    v22 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v21, size);
    v23 = v22->__r_.__value_.__r.__words[0];
    v46[0] = v22->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v46 + 7) = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
    v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p.__r_.__value_.__r.__words[0] = v23;
    __p.__r_.__value_.__l.__size_ = v46[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)v46 + 7);
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = v24;
    if (SHIBYTE(__dst.st_gid) < 0)
    {
      operator delete(*(void **)&__dst.st_dev);
      v24 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      v23 = __p.__r_.__value_.__r.__words[0];
    }
    v25.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v25.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&__dst.st_blksize = v25;
    *(timespec *)__dst.st_qspare = v25;
    __dst.st_birthtimespec = v25;
    *(timespec *)&__dst.st_size = v25;
    __dst.st_mtimespec = v25;
    __dst.st_ctimespec = v25;
    *(timespec *)&__dst.st_uid = v25;
    __dst.st_atimespec = v25;
    if (v24 >= 0)
      v26 = &__p;
    else
      v26 = (std::string *)v23;
    *(timespec *)&__dst.st_dev = v25;
    if (!stat((const char *)v26, &__dst)
      && ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (v31 = &__p)
        : (v31 = (std::string *)__p.__r_.__value_.__r.__words[0]),
          (v32 = opendir((const char *)v31), (v33 = v32) != 0) && (v34 = readdir(v32), closedir(v33), v34)))
    {
      std::string::append(&__p, "/", 1uLL);
      v30 = support::fs::removeDir(&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_7;
    }
    else
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = (const std::__fs::filesystem::path *)&__p;
      else
        v28 = (const std::__fs::filesystem::path *)__p.__r_.__value_.__r.__words[0];
      if (!remove(v28, v27))
        goto LABEL_58;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v29 = &__p;
      else
        v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
      v30 = unlink((const char *)v29) == 0;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_7;
    }
LABEL_6:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_7:
    v5 = v6 + 1;
    if ((v30 & 1) == 0)
      goto LABEL_75;
  }
  if ((v1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v35 = v1;
  else
    v35 = (const std::__fs::filesystem::path *)v1->__pn_.__r_.__value_.__r.__words[0];
  if (remove(v35, v4))
  {
    if ((v1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v36 = (const char *)v1;
    else
      v36 = (const char *)v1->__pn_.__r_.__value_.__r.__words[0];
    unlink(v36);
  }
LABEL_75:
  v37 = (void **)v42;
  if (v42)
  {
    v38 = v43;
    v39 = v42;
    if (v43 != v42)
    {
      do
      {
        if (*((char *)v38 - 1) < 0)
          operator delete(*(v38 - 3));
        v38 -= 3;
      }
      while (v38 != v37);
      v39 = v42;
    }
    v43 = v37;
    operator delete(v39);
  }
  return v3;
}

void sub_1A34A943C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_1A34A9454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((a16 & 0x80000000) == 0)
  {
    std::vector<std::string>::~vector[abi:ne180100](&a17);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::vector<std::string>::~vector[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

BOOL support::fs::removeFile(const std::__fs::filesystem::path *a1, std::error_code *a2)
{
  const std::__fs::filesystem::path *v2;
  const char *v3;

  v2 = a1;
  if ((a1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    a1 = (const std::__fs::filesystem::path *)a1->__pn_.__r_.__value_.__r.__words[0];
  if (!remove(a1, a2))
    return 1;
  if ((v2->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v3 = (const char *)v2;
  else
    v3 = (const char *)v2->__pn_.__r_.__value_.__r.__words[0];
  return unlink(v3) == 0;
}

uint64_t support::fs::removeDirContents(const char *a1, unint64_t a2)
{
  const char *v3;
  void **v4;
  void **v5;
  double v6;
  __int128 v7;
  int v8;
  std::string::size_type v9;
  std::string *v10;
  std::string *v11;
  int v12;
  size_t v13;
  unint64_t v14;
  stat *p_dst;
  std::string::size_type v16;
  void **v17;
  void **v18;
  const char *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  std::string *v24;
  std::string *v25;
  __int128 v26;
  timespec v27;
  void **v28;
  char v29;
  int v30;
  timespec v31;
  void **v32;
  std::error_code *v33;
  const std::__fs::filesystem::path *v34;
  void **v35;
  void **v36;
  DIR *v37;
  DIR *v38;
  dirent *v39;
  int v40;
  size_t v41;
  unint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  std::string *v47;
  std::string::size_type size;
  std::string *v49;
  __int128 v50;
  char v51;
  char v52;
  void **v53;
  void *v54;
  time_t v56;
  char v57;
  int v58;
  std::string v59;
  void *__p[4];
  std::string v61;
  void *v62;
  void **v63;
  uint64_t v64;
  stat __dst;

  v3 = a1;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  support::fs::readDir(a1, (uint64_t)&v62);
  v56 = time(0);
  v5 = (void **)v62;
  v4 = v63;
  if (v62 == v63)
  {
    v52 = 1;
    if (v62)
      goto LABEL_105;
    return v52 & 1;
  }
  v6 = (double)a2;
  v57 = 1;
  while (1)
  {
    memset(&v61, 170, sizeof(v61));
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v61, (const std::string::value_type *)*v5, (std::string::size_type)v5[1]);
    }
    else
    {
      v7 = *(_OWORD *)v5;
      v61.__r_.__value_.__r.__words[2] = (std::string::size_type)v5[2];
      *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v7;
    }
    v8 = SHIBYTE(v61.__r_.__value_.__r.__words[2]);
    v9 = (v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? HIBYTE(v61.__r_.__value_.__r.__words[2])
       : v61.__r_.__value_.__l.__size_;
    if (v9 == 2)
      break;
    if (v9 == 1)
    {
      v10 = (std::string *)v61.__r_.__value_.__r.__words[0];
      if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v10 = &v61;
      if (v10->__r_.__value_.__s.__data_[0] == 46)
        goto LABEL_95;
    }
LABEL_19:
    memset(__p, 170, 24);
    v12 = v3[23];
    if (v12 >= 0)
      v13 = *((unsigned __int8 *)v3 + 23);
    else
      v13 = *((_QWORD *)v3 + 1);
    v14 = v13 + 1;
    memset(&__dst, 170, 24);
    if (v13 + 1 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    if (v14 >= 0x17)
    {
      v58 = SHIBYTE(v61.__r_.__value_.__r.__words[2]);
      v16 = v9;
      v17 = v5;
      v18 = v4;
      v19 = v3;
      v20 = a2;
      v21 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17)
        v21 = v14 | 7;
      v22 = v21 + 1;
      p_dst = (stat *)operator new(v21 + 1);
      __dst.st_ino = v13 + 1;
      *(_QWORD *)&__dst.st_uid = v22 | 0x8000000000000000;
      *(_QWORD *)&__dst.st_dev = p_dst;
      a2 = v20;
      v3 = v19;
      v4 = v18;
      v5 = v17;
      v9 = v16;
      v8 = v58;
    }
    else
    {
      memset(&__dst, 0, 24);
      p_dst = &__dst;
      HIBYTE(__dst.st_gid) = v13 + 1;
      if (!v13)
        goto LABEL_33;
    }
    if (v12 >= 0)
      v23 = v3;
    else
      v23 = *(const char **)v3;
    memmove(p_dst, v23, v13);
LABEL_33:
    *(_WORD *)((char *)&p_dst->st_dev + v13) = 47;
    if (v8 >= 0)
      v24 = &v61;
    else
      v24 = (std::string *)v61.__r_.__value_.__r.__words[0];
    v25 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v24, v9);
    v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    __p[2] = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.st_gid) < 0)
    {
      operator delete(*(void **)&__dst.st_dev);
      if (!a2)
        goto LABEL_47;
    }
    else if (!a2)
    {
      goto LABEL_47;
    }
    v27.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v27.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&__dst.st_blksize = v27;
    *(timespec *)__dst.st_qspare = v27;
    __dst.st_birthtimespec = v27;
    *(timespec *)&__dst.st_size = v27;
    __dst.st_mtimespec = v27;
    __dst.st_ctimespec = v27;
    __dst.st_atimespec = v27;
    *(timespec *)&__dst.st_dev = v27;
    *(timespec *)&__dst.st_uid = v27;
    if (SHIBYTE(__p[2]) >= 0)
      v28 = __p;
    else
      v28 = (void **)__p[0];
    if (!stat((const char *)v28, &__dst) && difftime(v56, __dst.st_ctimespec.tv_sec) >= v6)
    {
LABEL_47:
      v31.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v31.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&__dst.st_blksize = v31;
      *(timespec *)__dst.st_qspare = v31;
      __dst.st_birthtimespec = v31;
      *(timespec *)&__dst.st_size = v31;
      __dst.st_mtimespec = v31;
      __dst.st_ctimespec = v31;
      __dst.st_atimespec = v31;
      *(timespec *)&__dst.st_dev = v31;
      *(timespec *)&__dst.st_uid = v31;
      if (SHIBYTE(__p[2]) >= 0)
        v32 = __p;
      else
        v32 = (void **)__p[0];
      if (stat((const char *)v32, &__dst)
        || (SHIBYTE(__p[2]) >= 0 ? (v36 = __p) : (v36 = (void **)__p[0]),
            (v37 = opendir((const char *)v36), (v38 = v37) == 0) || (v39 = readdir(v37), closedir(v38), !v39)))
      {
        if (SHIBYTE(__p[2]) >= 0)
          v34 = (const std::__fs::filesystem::path *)__p;
        else
          v34 = (const std::__fs::filesystem::path *)__p[0];
        if (!remove(v34, v33)
          || (SHIBYTE(__p[2]) >= 0 ? (v35 = __p) : (v35 = (void **)__p[0]), !unlink((const char *)v35)))
        {
LABEL_89:
          v30 = 0;
          v57 = 1;
          v29 = 1;
          if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
            goto LABEL_91;
          goto LABEL_90;
        }
        goto LABEL_59;
      }
      v40 = v3[23];
      if (v40 >= 0)
        v41 = *((unsigned __int8 *)v3 + 23);
      else
        v41 = *((_QWORD *)v3 + 1);
      v42 = v41 + 1;
      memset(&v59, 170, sizeof(v59));
      if (v41 + 1 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      if (v42 >= 0x17)
      {
        v44 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v42 | 7) != 0x17)
          v44 = v42 | 7;
        v45 = v44 + 1;
        v43 = (char *)operator new(v44 + 1);
        v59.__r_.__value_.__l.__size_ = v41 + 1;
        v59.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
        v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
      }
      else
      {
        memset(&v59, 0, sizeof(v59));
        v43 = (char *)&v59;
        *((_BYTE *)&v59.__r_.__value_.__s + 23) = v41 + 1;
        if (!v41)
          goto LABEL_80;
      }
      if (v40 >= 0)
        v46 = v3;
      else
        v46 = *(const char **)v3;
      memmove(v43, v46, v41);
LABEL_80:
      *(_WORD *)&v43[v41] = 47;
      if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v47 = &v61;
      else
        v47 = (std::string *)v61.__r_.__value_.__r.__words[0];
      if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v61.__r_.__value_.__r.__words[2]);
      else
        size = v61.__r_.__value_.__l.__size_;
      v49 = std::string::append(&v59, (const std::string::value_type *)v47, size);
      v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
      *(_QWORD *)&__dst.st_uid = *((_QWORD *)&v49->__r_.__value_.__l + 2);
      *(_OWORD *)&__dst.st_dev = v50;
      v49->__r_.__value_.__l.__size_ = 0;
      v49->__r_.__value_.__r.__words[2] = 0;
      v49->__r_.__value_.__r.__words[0] = 0;
      v51 = support::fs::removeDir((const char *)&__dst);
      if (SHIBYTE(__dst.st_gid) < 0)
      {
        operator delete(*(void **)&__dst.st_dev);
        if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_88;
      }
      else if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_88:
        if ((v51 & 1) != 0)
          goto LABEL_89;
LABEL_59:
        v57 = 0;
        v29 = 0;
        v30 = 2;
        if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
          goto LABEL_91;
        goto LABEL_90;
      }
      operator delete(v59.__r_.__value_.__l.__data_);
      if ((v51 & 1) != 0)
        goto LABEL_89;
      goto LABEL_59;
    }
    v29 = 0;
    v30 = 3;
    if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      goto LABEL_91;
LABEL_90:
    operator delete(__p[0]);
LABEL_91:
    if ((v29 & 1) != 0)
      goto LABEL_95;
    if ((SHIBYTE(v61.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_93;
LABEL_96:
    operator delete(v61.__r_.__value_.__l.__data_);
    if (v30 != 3)
      goto LABEL_97;
LABEL_3:
    v5 += 3;
    if (v5 == v4)
      goto LABEL_102;
  }
  v11 = (std::string *)v61.__r_.__value_.__r.__words[0];
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v61;
  if (LOWORD(v11->__r_.__value_.__l.__data_) != 11822)
    goto LABEL_19;
LABEL_95:
  v30 = 0;
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_96;
LABEL_93:
  if (v30 == 3)
    goto LABEL_3;
LABEL_97:
  if (!v30)
    goto LABEL_3;
LABEL_102:
  v5 = (void **)v62;
  v52 = v57;
  if (!v62)
    return v52 & 1;
LABEL_105:
  v53 = v63;
  v54 = v5;
  if (v63 != v5)
  {
    do
    {
      if (*((char *)v53 - 1) < 0)
        operator delete(*(v53 - 3));
      v53 -= 3;
    }
    while (v53 != v5);
    v54 = v62;
  }
  v63 = v5;
  operator delete(v54);
  return v52 & 1;
}

void sub_1A34A9A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a23 < 0)
    operator delete(__p);
  if (a30 < 0)
    operator delete(a25);
  std::vector<std::string>::~vector[abi:ne180100](&a31);
  _Unwind_Resume(a1);
}

void support::fs::moveDirUnique(const char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  const std::__fs::filesystem::path *v4;
  timespec v6;
  const char *v7;
  DIR *v8;
  DIR *v9;
  dirent *v10;
  std::error_code *v11;
  const std::__fs::filesystem::path *v12;
  const std::__fs::filesystem::path *v13;
  int v14;
  std::string __p;
  stat v16;

  v4 = (const std::__fs::filesystem::path *)a1;
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v16.st_blksize = v6;
  *(timespec *)v16.st_qspare = v6;
  v16.st_birthtimespec = v6;
  *(timespec *)&v16.st_size = v6;
  v16.st_mtimespec = v6;
  v16.st_ctimespec = v6;
  *(timespec *)&v16.st_uid = v6;
  v16.st_atimespec = v6;
  *(timespec *)&v16.st_dev = v6;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (stat(a1, &v16))
    goto LABEL_4;
  v7 = (v4->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
     ? (const char *)v4
     : (const char *)v4->__pn_.__r_.__value_.__r.__words[0];
  v8 = opendir(v7);
  if (!v8)
    goto LABEL_4;
  v9 = v8;
  v10 = readdir(v8);
  closedir(v9);
  if (!v10)
    goto LABEL_4;
  memset((void *)a3, 170, 24);
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  support::fs::createUniquePath((const char *)&__p, (std::string *)a3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((v4->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = v4;
  else
    v12 = (const std::__fs::filesystem::path *)v4->__pn_.__r_.__value_.__r.__words[0];
  if (*(char *)(a3 + 23) >= 0)
    v13 = (const std::__fs::filesystem::path *)a3;
  else
    v13 = *(const std::__fs::filesystem::path **)a3;
  rename(v12, v13, v11);
  if (v14)
  {
    if (*(char *)(a3 + 23) < 0)
      operator delete(*(void **)a3);
LABEL_4:
    *(_BYTE *)(a3 + 23) = 0;
    *(_BYTE *)a3 = 0;
  }
}

void sub_1A34A9CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void support::fs::getFileName(std::string *a1@<X8>)
{
  __int128 v2;
  void **v3;
  void *v4;
  void *__p[3];

  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  if (*((char *)__p[1] - 1) < 0)
  {
    std::string::__init_copy_ctor_external(a1, *((const std::string::value_type **)__p[1] - 3), *((_QWORD *)__p[1] - 2));
  }
  else
  {
    v2 = *(_OWORD *)((char *)__p[1] - 24);
    a1->__r_.__value_.__r.__words[2] = *((_QWORD *)__p[1] - 1);
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v2;
  }
  if (__p[0])
  {
    v3 = (void **)__p[1];
    v4 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v3 - 1) < 0)
          operator delete(*(v3 - 3));
        v3 -= 3;
      }
      while (v3 != __p[0]);
      v4 = __p[0];
    }
    operator delete(v4);
  }
}

void sub_1A34A9D70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

uint64_t support::fs::lockDir(const char *a1)
{
  uint64_t v1;
  _QWORD v3[2];
  pid_t v4;
  int v5;

  if (a1[23] < 0)
    a1 = *(const char **)a1;
  v1 = open(a1, 0);
  if ((v1 & 0x80000000) != 0)
    return v1;
  v5 = 1;
  v3[0] = 0;
  v3[1] = 0;
  v4 = getpid();
  if ((fcntl(v1, 9, v3) & 0x80000000) == 0)
    return v1;
  close(v1);
  return 0xFFFFFFFFLL;
}

BOOL support::fs::unlockDir(support::fs *this)
{
  int v1;
  _BOOL8 v2;
  _QWORD v4[2];
  pid_t v5;
  int v6;

  v1 = (int)this;
  v6 = 2;
  v4[0] = 0;
  v4[1] = 0;
  v5 = getpid();
  v2 = fcntl(v1, 9, v4) == 0;
  close(v1);
  return v2;
}

BOOL support::fs::getFilteredFiles(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  DIR *v7;
  DIR *v8;
  dirent *v9;
  char *d_name;
  size_t v11;
  size_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  std::string::size_type v19;
  _BYTE *v20;
  _WORD *v21;
  DIR *v22;
  uint64_t v23;
  uint64_t v24;
  timespec v25;
  int v26;
  size_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  const std::string::value_type *v33;
  std::string *v34;
  __int128 v35;
  void **v36;
  std::sub_match<const char *> *v37;
  std::sub_match<std::__wrap_iter<const char *>> *v38;
  __int128 v39;
  int v40;
  int v41;
  unint64_t v42;
  __int128 v43;
  std::string *v44;
  unsigned __int8 v45;
  NSObject *v46;
  _BOOL8 result;
  int *v48;
  char *v49;
  char v50;
  const char *v52;
  std::string v53;
  _BYTE __dst[24];
  void *__p[2];
  _QWORD v56[9];
  __int128 v57;
  uint64_t v58;
  stat v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  *__error() = 0;
  if (a1[23] < 0)
  {
    v7 = opendir(*(const char **)a1);
    if (v7)
      goto LABEL_3;
  }
  else
  {
    v7 = opendir(a1);
    if (v7)
    {
LABEL_3:
      v8 = v7;
      v9 = readdir(v7);
      if (v9)
      {
        v52 = a1;
        v50 = 0;
        while (1)
        {
          d_name = v9->d_name;
          memset(__dst, 170, sizeof(__dst));
          v11 = strlen(v9->d_name);
          if (v11 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          v12 = v11;
          if (v11 >= 0x17)
            break;
          __dst[23] = v11;
          v13 = __dst;
          if (v11)
            goto LABEL_12;
LABEL_13:
          v13[v12] = 0;
          v16 = __dst[23];
          v17 = __dst[23];
          v18 = *(_QWORD *)&__dst[8];
          if (__dst[23] >= 0)
            v19 = __dst[23];
          else
            v19 = *(_QWORD *)&__dst[8];
          if (v19 == 2)
          {
            v21 = *(_WORD **)__dst;
            if (__dst[23] >= 0)
              v21 = __dst;
            if (*v21 == 11822)
              goto LABEL_73;
          }
          else if (v19 == 1)
          {
            v20 = *(_BYTE **)__dst;
            if (__dst[23] >= 0)
              v20 = __dst;
            if (*v20 == 46)
              goto LABEL_73;
          }
          if ((a4 & 1) != 0)
            goto LABEL_53;
          v22 = v8;
          v23 = a4;
          v24 = a3;
          v25.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v25.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v59.st_blksize = v25;
          *(timespec *)v59.st_qspare = v25;
          v59.st_birthtimespec = v25;
          *(timespec *)&v59.st_size = v25;
          v59.st_mtimespec = v25;
          v59.st_ctimespec = v25;
          *(timespec *)&v59.st_uid = v25;
          v59.st_atimespec = v25;
          *(timespec *)&v59.st_dev = v25;
          v26 = v52[23];
          if (v26 >= 0)
            v27 = *((unsigned __int8 *)v52 + 23);
          else
            v27 = *((_QWORD *)v52 + 1);
          v28 = v27 + 1;
          memset(&v53, 170, sizeof(v53));
          if (v27 + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v28 >= 0x17)
          {
            v30 = (v28 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v28 | 7) != 0x17)
              v30 = v28 | 7;
            v31 = v30 + 1;
            v29 = (char *)operator new(v30 + 1);
            v53.__r_.__value_.__l.__size_ = v27 + 1;
            v53.__r_.__value_.__r.__words[2] = v31 | 0x8000000000000000;
            v53.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
          }
          else
          {
            memset(&v53, 0, sizeof(v53));
            v29 = (char *)&v53;
            *((_BYTE *)&v53.__r_.__value_.__s + 23) = v27 + 1;
            if (!v27)
              goto LABEL_40;
          }
          if (v26 >= 0)
            v32 = v52;
          else
            v32 = *(const char **)v52;
          memmove(v29, v32, v27);
LABEL_40:
          a3 = v24;
          *(_WORD *)&v29[v27] = 47;
          if (v17 >= 0)
            v33 = __dst;
          else
            v33 = *(const std::string::value_type **)__dst;
          v34 = std::string::append(&v53, v33, v19);
          a4 = v23;
          v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
          v56[0] = *((_QWORD *)&v34->__r_.__value_.__l + 2);
          *(_OWORD *)__p = v35;
          v34->__r_.__value_.__l.__size_ = 0;
          v34->__r_.__value_.__r.__words[2] = 0;
          v34->__r_.__value_.__r.__words[0] = 0;
          if (v56[0] >= 0)
            v36 = __p;
          else
            v36 = (void **)__p[0];
          lstat((const char *)v36, &v59);
          v8 = v22;
          if (SHIBYTE(v56[0]) < 0)
          {
            operator delete(__p[0]);
            if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_48:
              if ((v59.st_mode & 0xF000) != 0xA000)
                goto LABEL_52;
              goto LABEL_73;
            }
          }
          else if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_48;
          }
          operator delete(v53.__r_.__value_.__l.__data_);
          if ((v59.st_mode & 0xF000) != 0xA000)
          {
LABEL_52:
            v16 = __dst[23];
            v18 = *(_QWORD *)&__dst[8];
            LOBYTE(v17) = __dst[23];
LABEL_53:
            if ((v17 & 0x80u) == 0)
              v37 = (std::sub_match<const char *> *)__dst;
            else
              v37 = *(std::sub_match<const char *> **)__dst;
            if ((v17 & 0x80u) != 0)
              v16 = v18;
            v38 = (std::sub_match<std::__wrap_iter<const char *>> *)((char *)v37 + v16);
            *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v57 = v39;
            v56[6] = 0xAAAAAAAAAAAAAA00;
            v56[3] = 0xAAAAAAAAAAAAAAAALL;
            v56[4] = 0;
            v56[5] = 0;
            v56[7] = 0;
            v56[8] = 0;
            LOBYTE(v57) = 0;
            BYTE8(v57) = 0;
            v58 = 0;
            *(_OWORD *)__p = 0u;
            memset(v56, 0, 25);
            *(_OWORD *)&v59.st_birthtimespec.tv_nsec = v39;
            v59.st_ctimespec.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v59.st_atimespec.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            memset(&v59.st_mtimespec, 0, 17);
            memset(&v59.st_ctimespec.tv_nsec, 0, 17);
            LOBYTE(v59.st_size) = 0;
            v59.st_blocks = 0;
            memset(&v59, 0, 41);
            v40 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a2, v37, (std::sub_match<const char *> *)((char *)v37 + v16), (std::vector<std::csub_match> *)&v59, 4160);
            std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)__p, (uint64_t)v37, v38, (uint64_t *)&v59.st_dev, 0);
            if (*(_QWORD *)&v59.st_dev)
            {
              v59.st_ino = *(_QWORD *)&v59.st_dev;
              operator delete(*(void **)&v59.st_dev);
            }
            if ((_BYTE)v57)
              v41 = v40 ^ 1;
            else
              v41 = 1;
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            if ((v40 & v41) != 0)
            {
              v42 = *(_QWORD *)(a3 + 8);
              if (v42 >= *(_QWORD *)(a3 + 16))
              {
                v44 = std::vector<std::string>::__push_back_slow_path<std::string const&>((char **)a3, (uint64_t)__dst);
              }
              else
              {
                if ((__dst[23] & 0x80000000) != 0)
                {
                  std::string::__init_copy_ctor_external(*(std::string **)(a3 + 8), *(const std::string::value_type **)__dst, *(std::string::size_type *)&__dst[8]);
                }
                else
                {
                  v43 = *(_OWORD *)__dst;
                  *(_QWORD *)(v42 + 16) = *(_QWORD *)&__dst[16];
                  *(_OWORD *)v42 = v43;
                }
                v44 = (std::string *)(v42 + 24);
                *(_QWORD *)(a3 + 8) = v42 + 24;
              }
              *(_QWORD *)(a3 + 8) = v44;
              v50 = 1;
            }
          }
LABEL_73:
          if ((__dst[23] & 0x80000000) != 0)
            operator delete(*(void **)__dst);
          v9 = readdir(v8);
          if (!v9)
            goto LABEL_85;
        }
        v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v11 | 7) != 0x17)
          v14 = v11 | 7;
        v15 = v14 + 1;
        v13 = operator new(v14 + 1);
        *(_QWORD *)&__dst[8] = v12;
        *(_QWORD *)&__dst[16] = v15 | 0x8000000000000000;
        *(_QWORD *)__dst = v13;
LABEL_12:
        memmove(v13, d_name, v12);
        goto LABEL_13;
      }
      v50 = 0;
LABEL_85:
      closedir(v8);
      return v50 & 1;
    }
  }
  {
    GetOsLogContext(void)::sOsLogContext = 0;
    qword_1ED114D18 = 0;
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
  }
  if (GetOsLogContext(void)::onceToken == -1)
  {
    v46 = qword_1ED114D18;
    result = os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
  }
  else
  {
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
    v46 = qword_1ED114D18;
    result = os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
  }
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  v48 = __error();
  v49 = strerror(*v48);
  v59.st_dev = 136315394;
  *(_QWORD *)&v59.st_mode = a1;
  WORD2(v59.st_ino) = 2080;
  *(__darwin_ino64_t *)((char *)&v59.st_ino + 6) = (__darwin_ino64_t)v49;
  _os_log_error_impl(&dword_1A343C000, v46, OS_LOG_TYPE_ERROR, "Error %s (%s)\n", (uint8_t *)&v59, 0x16u);
  return 0;
}

void sub_1A34AA474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49)
{
  uint64_t v49;
  uint64_t v50;

  *(_QWORD *)(v49 + 8) = v50;
  if (a30 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A34AA680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ifstream::~ifstream(&a9);
  _Unwind_Resume(a1);
}

void support::fs::getBasePath(const std::string::value_type **a1@<X0>, uint64_t a2@<X8>)
{
  unsigned __int8 *v2;
  size_t v4;
  size_t v5;
  std::string::size_type size;
  char v7;
  std::string *p_p;
  unsigned __int8 *v9;
  BOOL v10;
  BOOL v11;
  size_t v12;
  __int128 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  unint64_t v22;
  std::string __p;

  v2 = (unsigned __int8 *)a1;
  if (*((char *)a1 + 23) < 0)
  {
    if (!a1[1])
    {
      std::string::__init_copy_ctor_external((std::string *)a2, *a1, 0);
      return;
    }
  }
  else if (!*((_BYTE *)a1 + 23))
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    *(_QWORD *)(a2 + 16) = a1[2];
    return;
  }
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  memset(&__p, 170, sizeof(__p));
  support::fs::getFileName(&__p);
  v4 = *((_QWORD *)v2 + 1);
  if ((v2[23] & 0x80u) == 0)
  {
    v5 = v2[23];
  }
  else
  {
    v2 = *(unsigned __int8 **)v2;
    v5 = v4;
  }
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v7 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  v9 = &v2[v5];
  if (v5)
    v10 = size == 0;
  else
    v10 = 1;
  if (v10)
  {
    v15 = &v2[v5];
  }
  else
  {
    v14 = v2;
    v15 = &v2[v5];
    do
    {
      if (*v14 == p_p->__r_.__value_.__s.__data_[0])
      {
        v16 = 1;
        while (size != v16)
        {
          if (&v14[v16] == v9)
            goto LABEL_20;
          v17 = v14[v16];
          v18 = p_p->__r_.__value_.__s.__data_[v16++];
          if (v17 != v18)
            goto LABEL_37;
        }
        v15 = v14;
      }
LABEL_37:
      ++v14;
    }
    while (v14 != v9);
  }
LABEL_20:
  v11 = v15 != v9 || size == 0;
  if (v11 && v15 - v2 != -1)
  {
    if (v5 >= v15 - v2)
      v12 = v15 - v2;
    else
      v12 = v5;
    if (v12 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v12 >= 0x17)
    {
      v19 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17)
        v19 = v12 | 7;
      v20 = v19 + 1;
      v13 = (__int128 *)operator new(v19 + 1);
      *((_QWORD *)&v21 + 1) = v12;
      v22 = v20 | 0x8000000000000000;
      *(_QWORD *)&v21 = v13;
    }
    else
    {
      HIBYTE(v22) = v12;
      v13 = &v21;
      if (!v12)
      {
        LOBYTE(v21) = 0;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_33:
          *(_OWORD *)a2 = v21;
          *(_QWORD *)(a2 + 16) = v22;
          v7 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          goto LABEL_34;
        }
LABEL_49:
        operator delete(*(void **)a2);
        goto LABEL_33;
      }
    }
    memmove(v13, v2, v12);
    *((_BYTE *)v13 + v12) = 0;
    if ((*(char *)(a2 + 23) & 0x80000000) == 0)
      goto LABEL_33;
    goto LABEL_49;
  }
LABEL_34:
  if (v7 < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1A34AA8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void support::fs::getLastNumberDir(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::string *v4;
  std::string *v5;
  std::string::size_type size;
  std::string::size_type v7;
  std::string::size_type v8;
  int v9;
  std::string::size_type v10;
  std::string::size_type v11;
  std::string::size_type v12;
  int v13;
  size_t v14;
  unint64_t v15;
  void **v16;
  uint64_t v17;
  uint64_t v18;
  std::string *v19;
  __int128 v20;
  unint64_t *v21;
  unint64_t v22;
  void **v23;
  void **v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  char *v31;
  char *v32;
  unsigned int v33;
  void *v34;
  __int128 v35;
  std::string *v36;
  unsigned int v37;
  std::string::size_type v38;
  std::string::size_type v39;
  void **v40;
  int v41;
  size_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  std::string *v47;
  std::string *v48;
  std::string::size_type v49;
  std::string *v50;
  __int128 v51;
  std::string *v52;
  __int128 v53;
  void **v54;
  void *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::string v59;
  std::string v60;
  std::string __p;
  std::locale v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  uint64_t v67;
  std::string v68;
  void *v69;
  void **v70;
  uint64_t v71;
  _BYTE v72[48];
  __int128 v73;
  void *__dst[3];
  std::string v75;
  std::string v76;
  std::string v77;

  memset(&v77, 170, sizeof(v77));
  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&v77, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    v77 = *(std::string *)a1;
  v4 = (std::string *)v77.__r_.__value_.__r.__words[0];
  if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v77;
  else
    v5 = (std::string *)v77.__r_.__value_.__r.__words[0];
  if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v77.__r_.__value_.__r.__words[2]);
  else
    size = v77.__r_.__value_.__l.__size_;
  v7 = size + 1;
  do
  {
    v8 = v7 - 1;
    if (v7 == 1)
      goto LABEL_20;
    v9 = v5->__r_.__value_.__s.__data_[v7-- - 2];
  }
  while (v9 == 47);
  if (v8)
  {
    v10 = v8 - 1;
    if ((*((_BYTE *)&v77.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (v77.__r_.__value_.__l.__size_ > v10)
      {
        v77.__r_.__value_.__l.__size_ = v8;
        goto LABEL_19;
      }
    }
    else if (v10 < HIBYTE(v77.__r_.__value_.__r.__words[2]))
    {
      *((_BYTE *)&v77.__r_.__value_.__s + 23) = v8 & 0x7F;
      v4 = &v77;
LABEL_19:
      v4->__r_.__value_.__s.__data_[v8] = 0;
      goto LABEL_20;
    }
    std::string::__throw_out_of_range[abi:ne180100]();
  }
LABEL_20:
  memset(&v76, 170, sizeof(v76));
  support::fs::getBasePath((const std::string::value_type **)&v77.__r_.__value_.__l.__data_, (uint64_t)&v76);
  v11 = HIBYTE(v77.__r_.__value_.__r.__words[2]);
  if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v11 = v77.__r_.__value_.__l.__size_;
  if (!v11)
    goto LABEL_33;
  v12 = HIBYTE(v76.__r_.__value_.__r.__words[2]);
  if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v12 = v76.__r_.__value_.__l.__size_;
  if (!v12)
  {
LABEL_33:
    if ((*(char *)(a1 + 23) & 0x80000000) == 0)
    {
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
      a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
      if ((SHIBYTE(v76.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_132;
      goto LABEL_137;
    }
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    goto LABEL_131;
  }
  memset(&v75, 170, sizeof(v75));
  support::fs::getFileName(&v75);
  v13 = SHIBYTE(v75.__r_.__value_.__r.__words[2]);
  if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = HIBYTE(v75.__r_.__value_.__r.__words[2]);
  else
    v14 = v75.__r_.__value_.__l.__size_;
  v15 = v14 + 13;
  memset(__dst, 170, sizeof(__dst));
  if (v14 + 13 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v15 >= 0x17)
  {
    v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v17 = v15 | 7;
    v18 = v17 + 1;
    v16 = (void **)operator new(v17 + 1);
    __dst[1] = (void *)(v14 + 13);
    __dst[2] = (void *)(v18 | 0x8000000000000000);
    __dst[0] = v16;
  }
  else
  {
    memset(__dst, 0, sizeof(__dst));
    v16 = __dst;
    HIBYTE(__dst[2]) = v14 + 13;
    if (!v14)
      goto LABEL_44;
  }
  if (v13 >= 0)
    v19 = &v75;
  else
    v19 = (std::string *)v75.__r_.__value_.__r.__words[0];
  memmove(v16, v19, v14);
LABEL_44:
  strcpy((char *)v16 + v14, "-[[:alnum:]]*");
  *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v72[32] = v20;
  v73 = v20;
  *(_OWORD *)v72 = v20;
  *(_OWORD *)&v72[16] = v20;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)v72, (uint64_t)__dst, 0);
  v69 = 0;
  v70 = 0;
  v71 = 0;
  if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v68, v76.__r_.__value_.__l.__data_, v76.__r_.__value_.__l.__size_);
  else
    v68 = v76;
  std::locale::locale(&v62, (const std::locale *)v72);
  v63 = *(_OWORD *)&v72[8];
  v64 = *(_OWORD *)&v72[24];
  v65 = *(_QWORD *)&v72[40];
  v66 = (std::__shared_weak_count *)v73;
  if ((_QWORD)v73)
  {
    v21 = (unint64_t *)(v73 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v67 = *((_QWORD *)&v73 + 1);
  if (!support::fs::getFilteredFiles((const char *)&v68, (uint64_t)&v62, (uint64_t)&v69, 0))
  {
    v28 = v66;
    if (v66)
    {
      p_shared_owners = (unint64_t *)&v66->__shared_owners_;
      do
        v30 = __ldaxr(p_shared_owners);
      while (__stlxr(v30 - 1, p_shared_owners));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    std::locale::~locale(&v62);
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v68.__r_.__value_.__l.__data_);
    goto LABEL_89;
  }
  v23 = (void **)v69;
  v24 = v70;
  v25 = v66;
  if (v66)
  {
    v26 = (unint64_t *)&v66->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  std::locale::~locale(&v62);
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v68.__r_.__value_.__l.__data_);
    if (v23 == v24)
    {
LABEL_89:
      if ((*(char *)(a1 + 23) & 0x80000000) == 0)
      {
        *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
        a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
        v40 = (void **)v69;
        if (!v69)
          goto LABEL_125;
        goto LABEL_118;
      }
      std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
LABEL_117:
      v40 = (void **)v69;
      if (!v69)
        goto LABEL_125;
      goto LABEL_118;
    }
  }
  else if (v23 == v24)
  {
    goto LABEL_89;
  }
  v31 = (char *)v69;
  v32 = (char *)v70;
  if (v69 != v70)
  {
    v33 = 0;
    while (1)
    {
      memset(&__p, 170, sizeof(__p));
      ctu::tokenize();
      memset(&v60, 170, sizeof(v60));
      if (*(char *)(__p.__r_.__value_.__l.__size_ - 1) < 0)
      {
        std::string::__init_copy_ctor_external(&v60, *(const std::string::value_type **)(__p.__r_.__value_.__l.__size_ - 24), *(_QWORD *)(__p.__r_.__value_.__l.__size_ - 16));
      }
      else
      {
        v35 = *(_OWORD *)(__p.__r_.__value_.__l.__size_ - 24);
        v60.__r_.__value_.__r.__words[2] = *(_QWORD *)(__p.__r_.__value_.__l.__size_ - 8);
        *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v35;
      }
      if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v36 = &v60;
      else
        v36 = (std::string *)v60.__r_.__value_.__r.__words[0];
      v37 = strtol((const char *)v36, 0, 0);
      if (v33 <= v37)
        v33 = v37;
      if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v60.__r_.__value_.__l.__data_);
        v38 = __p.__r_.__value_.__r.__words[0];
        if (__p.__r_.__value_.__r.__words[0])
        {
LABEL_84:
          v39 = __p.__r_.__value_.__l.__size_;
          v34 = (void *)v38;
          if (__p.__r_.__value_.__l.__size_ != v38)
          {
            do
            {
              if (*(char *)(v39 - 1) < 0)
                operator delete(*(void **)(v39 - 24));
              v39 -= 24;
            }
            while (v39 != v38);
            v34 = (void *)__p.__r_.__value_.__r.__words[0];
          }
          __p.__r_.__value_.__l.__size_ = v38;
          operator delete(v34);
        }
      }
      else
      {
        v38 = __p.__r_.__value_.__r.__words[0];
        if (__p.__r_.__value_.__r.__words[0])
          goto LABEL_84;
      }
      v31 += 24;
      if (v31 == v32)
        goto LABEL_94;
    }
  }
  v33 = 0;
LABEL_94:
  v41 = SHIBYTE(v77.__r_.__value_.__r.__words[2]);
  if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v42 = HIBYTE(v77.__r_.__value_.__r.__words[2]);
  else
    v42 = v77.__r_.__value_.__l.__size_;
  v43 = v42 + 1;
  memset(&v60, 170, sizeof(v60));
  if (v42 + 1 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v43 >= 0x17)
  {
    v45 = (v43 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v43 | 7) != 0x17)
      v45 = v43 | 7;
    v46 = v45 + 1;
    v44 = (char *)operator new(v45 + 1);
    v60.__r_.__value_.__l.__size_ = v42 + 1;
    v60.__r_.__value_.__r.__words[2] = v46 | 0x8000000000000000;
    v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
  }
  else
  {
    memset(&v60, 0, sizeof(v60));
    v44 = (char *)&v60;
    *((_BYTE *)&v60.__r_.__value_.__s + 23) = v42 + 1;
    if (!v42)
      goto LABEL_108;
  }
  if (v41 >= 0)
    v47 = &v77;
  else
    v47 = (std::string *)v77.__r_.__value_.__r.__words[0];
  memmove(v44, v47, v42);
LABEL_108:
  *(_WORD *)&v44[v42] = 45;
  std::to_string(&v59, v33);
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v48 = &v59;
  else
    v48 = (std::string *)v59.__r_.__value_.__r.__words[0];
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v49 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
  else
    v49 = v59.__r_.__value_.__l.__size_;
  v50 = std::string::append(&v60, (const std::string::value_type *)v48, v49);
  v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v51;
  v50->__r_.__value_.__l.__size_ = 0;
  v50->__r_.__value_.__r.__words[2] = 0;
  v50->__r_.__value_.__r.__words[0] = 0;
  v52 = std::string::append(&__p, "/", 1uLL);
  v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  a2->__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v53;
  v52->__r_.__value_.__l.__size_ = 0;
  v52->__r_.__value_.__r.__words[2] = 0;
  v52->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_116:
      if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_117;
      goto LABEL_141;
    }
  }
  else if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_116;
  }
  operator delete(v59.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_117;
LABEL_141:
  operator delete(v60.__r_.__value_.__l.__data_);
  v40 = (void **)v69;
  if (!v69)
    goto LABEL_125;
LABEL_118:
  v54 = v70;
  v55 = v40;
  if (v70 != v40)
  {
    do
    {
      if (*((char *)v54 - 1) < 0)
        operator delete(*(v54 - 3));
      v54 -= 3;
    }
    while (v54 != v40);
    v55 = v69;
  }
  v70 = v40;
  operator delete(v55);
LABEL_125:
  v56 = (std::__shared_weak_count *)v73;
  if (!(_QWORD)v73)
    goto LABEL_129;
  v57 = (unint64_t *)(v73 + 8);
  do
    v58 = __ldaxr(v57);
  while (__stlxr(v58 - 1, v57));
  if (!v58)
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
    std::locale::~locale((std::locale *)v72);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
    {
LABEL_130:
      if ((SHIBYTE(v75.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_131;
      goto LABEL_136;
    }
  }
  else
  {
LABEL_129:
    std::locale::~locale((std::locale *)v72);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
      goto LABEL_130;
  }
  operator delete(__dst[0]);
  if ((SHIBYTE(v75.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_131:
    if ((SHIBYTE(v76.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_132;
    goto LABEL_137;
  }
LABEL_136:
  operator delete(v75.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v76.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_132:
    if ((SHIBYTE(v77.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_138:
    operator delete(v77.__r_.__value_.__l.__data_);
    return;
  }
LABEL_137:
  operator delete(v76.__r_.__value_.__l.__data_);
  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_138;
}

void sub_1A34AB034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,std::locale a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,uint64_t a46,std::locale a47)
{
  uint64_t v47;

  if (a28 < 0)
  {
    operator delete(__p);
    if ((a15 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a21 & 0x80000000) == 0)
      {
LABEL_8:
        std::vector<std::string>::~vector[abi:ne180100](&a44);
        std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a47);
        if (*(char *)(v47 - 161) < 0)
        {
          operator delete(*(void **)(v47 - 184));
          if ((*(char *)(v47 - 137) & 0x80000000) == 0)
          {
LABEL_10:
            if ((*(char *)(v47 - 113) & 0x80000000) == 0)
              goto LABEL_11;
            goto LABEL_15;
          }
        }
        else if ((*(char *)(v47 - 137) & 0x80000000) == 0)
        {
          goto LABEL_10;
        }
        operator delete(*(void **)(v47 - 160));
        if ((*(char *)(v47 - 113) & 0x80000000) == 0)
        {
LABEL_11:
          if ((*(char *)(v47 - 89) & 0x80000000) == 0)
            goto LABEL_12;
          goto LABEL_16;
        }
LABEL_15:
        operator delete(*(void **)(v47 - 136));
        if ((*(char *)(v47 - 89) & 0x80000000) == 0)
LABEL_12:
          _Unwind_Resume(a1);
LABEL_16:
        operator delete(*(void **)(v47 - 112));
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(a16);
      goto LABEL_8;
    }
  }
  else if ((a15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a10);
  if ((a21 & 0x80000000) == 0)
    goto LABEL_8;
  goto LABEL_7;
}

BOOL support::fs::getPartitionInfo(uint64_t a1, _QWORD *a2, _QWORD *a3, unint64_t *a4)
{
  int v7;
  _BOOL8 result;
  int v9;
  uint64_t f_bavail;
  statvfs v11;

  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    if (*(_BYTE *)(a1 + 23))
    {
      memset(&v11, 0, sizeof(v11));
      v7 = statvfs((const char *)a1, &v11);
      result = v7 == 0;
      if (v7)
        return result;
LABEL_7:
      *a4 = v11.f_frsize;
      f_bavail = v11.f_bavail;
      *a2 = v11.f_blocks;
      *a3 = f_bavail;
      return result;
    }
    return 0;
  }
  if (!*(_QWORD *)(a1 + 8))
    return 0;
  memset(&v11, 0, sizeof(v11));
  v9 = statvfs(*(const char **)a1, &v11);
  result = v9 == 0;
  if (!v9)
    goto LABEL_7;
  return result;
}

_QWORD *support::fs::readCurrentLine@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  const std::locale::facet *v6;
  unsigned __int8 v7;
  std::locale v9[16];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::istream::tellg();
  v4 = v10;
  if (v10 >= 2)
  {
    do
    {
      std::istream::seekg();
      if (std::istream::peek() == 10)
        break;
    }
    while (v4-- > 1);
  }
  std::istream::seekg();
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
  v6 = std::locale::use_facet(v9, MEMORY[0x1E0DE4A90]);
  v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(v9);
  return std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, (uint64_t)a2, v7);
}

void sub_1A34AB37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  std::locale::~locale(&a9);
  _Unwind_Resume(a1);
}

void sub_1A34AB390(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
  {
    operator delete(*(void **)v1);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(std::string *a1, std::__wrap_iter<const char *> a2, std::__wrap_iter<const char *> a3, const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *a4, char *a5, unsigned __int32 __m)
{
  __int16 v6;
  std::string::value_type *i;
  std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> v11;
  std::sub_match<std::__wrap_iter<const char *>> *end;
  std::regex_iterator<std::__wrap_iter<const char *>, char>::value_type *p_match;
  size_t v14;
  unsigned __int8 *v15;
  std::string::value_type *v16;
  std::__wrap_iter<const char *>::iterator_type v17;
  std::string::value_type ***v18;
  std::__wrap_iter<const char *>::iterator_type v19;
  std::__wrap_iter<const char *>::iterator_type v20;
  size_t size;
  std::string *v22;
  char *v23;
  char v24;
  int v25;
  std::string *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  size_t v30;
  std::string *v31;
  std::string::value_type *v33;
  std::__wrap_iter<const char *>::iterator_type j;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  __int16 v37;
  std::regex_iterator<std::__wrap_iter<const char *>, char> v38;

  v6 = __m;
  i = (std::string::value_type *)a2.__i_;
  v11.first.__i_ = (std::__wrap_iter<const char *>::iterator_type)0xAAAAAAAAAAAAAAAALL;
  v11.second.__i_ = (std::__wrap_iter<const char *>::iterator_type)0xAAAAAAAAAAAAAAAALL;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__suffix_.second.__i_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__ready_ = v11;
  v38.__match_.__prefix_.std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__prefix_.matched = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__matches_.__end_cap_.__value_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__unmatched_.second.__i_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__pregex_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__matches_.__begin_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__begin_.__i_ = v11;
  std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::regex_iterator(&v38, a2, a3, a4, (std::regex_constants::match_flag_type)__m);
  end = v38.__match_.__matches_.__end_;
  if (v38.__match_.__matches_.__end_ == v38.__match_.__matches_.__begin_)
  {
    if ((v6 & 0x200) != 0)
      goto LABEL_44;
    for (; i != a3.__i_; ++i)
      std::string::push_back(a1, *i);
    goto LABEL_43;
  }
  p_match = &v38.__match_;
  v14 = strlen(a5);
  v15 = (unsigned __int8 *)&a5[v14];
  if ((v6 & 0x200) == 0)
  {
    if ((v6 & 0x400) != 0)
    {
      v33 = (std::string::value_type *)v38.__match_.__prefix_.first.__i_;
      for (j = v38.__match_.__prefix_.second.__i_; v33 != j; ++v33)
        std::string::push_back(a1, *v33);
      a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v38.__match_, a1, (unsigned __int8 *)a5, v15, v6);
      v16 = (std::string::value_type *)v38.__match_.__suffix_.first.__i_;
      v17 = v38.__match_.__suffix_.second.__i_;
      if ((v6 & 0x200) != 0)
        goto LABEL_43;
      goto LABEL_39;
    }
    v37 = v6;
    v35 = (unsigned __int8 *)&a5[v14];
    v36 = (unsigned __int8 *)a5;
LABEL_12:
    v18 = (std::string::value_type ***)p_match;
    v20 = v38.__match_.__prefix_.first.__i_;
    v19 = v38.__match_.__prefix_.second.__i_;
    while (1)
    {
      if (v20 == v19)
      {
        p_match = (std::regex_iterator<std::__wrap_iter<const char *>, char>::value_type *)v18;
        v6 = v37;
        a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>(v18, a1, v36, v35, v37);
        v16 = (std::string::value_type *)v38.__match_.__suffix_.first.__i_;
        v17 = v38.__match_.__suffix_.second.__i_;
        std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(&v38);
        if (v38.__match_.__matches_.__end_ == v38.__match_.__matches_.__begin_)
          goto LABEL_38;
        goto LABEL_12;
      }
      v24 = *v20;
      v25 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
      if ((v25 & 0x80000000) == 0)
        break;
      v27 = a1->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL;
      size = v27 - 1;
      if (a1->__r_.__value_.__l.__size_ == v27 - 1)
      {
        if (v27 == 0x7FFFFFFFFFFFFFF8)
          std::string::__throw_length_error[abi:ne180100]();
        v26 = (std::string *)a1->__r_.__value_.__r.__words[0];
        if (size <= 0x3FFFFFFFFFFFFFF2)
          goto LABEL_22;
        v30 = 0x7FFFFFFFFFFFFFF7;
LABEL_30:
        v31 = (std::string *)operator new(v30);
        v22 = v31;
        if (!size || (memmove(v31, v26, size), size != 22))
          operator delete(v26);
        a1->__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
        a1->__r_.__value_.__r.__words[2] = v30 | 0x8000000000000000;
        goto LABEL_35;
      }
      v22 = (std::string *)a1->__r_.__value_.__r.__words[0];
      size = a1->__r_.__value_.__l.__size_;
LABEL_35:
      a1->__r_.__value_.__l.__size_ = size + 1;
LABEL_14:
      v23 = (char *)v22 + size;
      *v23 = v24;
      v23[1] = 0;
      ++v20;
    }
    if (*((_BYTE *)&a1->__r_.__value_.__s + 23) != 22)
    {
      size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
      *((_BYTE *)&a1->__r_.__value_.__s + 23) = (v25 + 1) & 0x7F;
      v22 = a1;
      goto LABEL_14;
    }
    v26 = a1;
    size = 22;
LABEL_22:
    if (size + 1 > 2 * size)
      v28 = size + 1;
    else
      v28 = 2 * size;
    v29 = (v28 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v28 | 7) != 0x17)
      v29 = v28 | 7;
    if (v28 >= 0x17)
      v30 = v29 + 1;
    else
      v30 = 23;
    goto LABEL_30;
  }
  if ((v6 & 0x400) == 0)
  {
    do
    {
      a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v38.__match_, a1, (unsigned __int8 *)a5, v15, v6);
      v16 = (std::string::value_type *)v38.__match_.__suffix_.first.__i_;
      v17 = v38.__match_.__suffix_.second.__i_;
      std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(&v38);
    }
    while (v38.__match_.__matches_.__end_ != v38.__match_.__matches_.__begin_);
LABEL_38:
    if ((v6 & 0x200) != 0)
      goto LABEL_43;
LABEL_39:
    while (v16 != v17)
      std::string::push_back(a1, *v16++);
    goto LABEL_43;
  }
  a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v38.__match_, a1, (unsigned __int8 *)a5, v15, v6);
LABEL_43:
  end = v38.__match_.__matches_.__begin_;
LABEL_44:
  if (end)
  {
    v38.__match_.__matches_.__end_ = end;
    operator delete(end);
  }
  return a1;
}

void sub_1A34AB6CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

std::string *std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>(std::string::value_type ***a1, std::string *this, unsigned __int8 *a3, unsigned __int8 *a4, __int16 a5)
{
  unsigned __int8 *v6;
  std::string::value_type ***v8;
  int v9;
  unsigned __int8 *v10;
  int v11;
  std::string::value_type *v12;
  std::string::value_type *v13;
  std::string::value_type v14;
  std::string::value_type *v15;
  std::string::value_type *v16;
  std::string::value_type v17;
  std::string::value_type *v18;
  std::string::value_type *v19;
  std::string::value_type v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  std::string::value_type *v26;
  std::string::value_type *v27;
  std::string::value_type v28;
  int v29;
  unsigned __int8 *v30;
  std::string::value_type **v31;
  std::string::value_type *v32;
  std::string::value_type *v33;
  size_t size;
  std::string *v35;
  std::string::value_type *v36;
  std::string::value_type v37;
  int v38;
  std::string *v39;
  std::string::size_type v40;
  unint64_t v41;
  uint64_t v42;
  size_t v43;
  unint64_t v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  std::string::value_type *v48;
  std::string::value_type *v49;
  std::string::value_type v50;
  _QWORD **v52;

  v6 = a3;
  v8 = a1;
  if ((a5 & 0x100) != 0)
  {
    if (a3 == a4)
      return this;
    v52 = a1 + 3;
    while (1)
    {
      v29 = *v6;
      if (v29 != 92)
        break;
      v30 = v6 + 1;
      if (v6 + 1 == a4)
      {
        LOBYTE(v29) = 92;
LABEL_38:
        std::string::push_back(this, v29);
        v30 = v6;
        goto LABEL_39;
      }
      v29 = *v30;
      if ((v29 - 48) > 9u)
      {
        ++v6;
        goto LABEL_38;
      }
      v44 = (v29 - 48);
      v45 = (uint64_t)&(*v8)[3 * v44];
      v46 = 0xAAAAAAAAAAAAAAABLL * (v8[1] - *v8) > v44;
      v47 = (uint64_t)v52;
      if (v46)
        v47 = v45;
      v48 = *(std::string::value_type **)v47;
      v49 = *(std::string::value_type **)(v47 + 8);
      if (*(std::string::value_type **)v47 != v49)
      {
        do
        {
          v50 = *v48++;
          std::string::push_back(this, v50);
        }
        while (v48 != v49);
      }
LABEL_39:
      v6 = v30 + 1;
      if (v30 + 1 == a4)
        return this;
    }
    if (v29 != 38)
      goto LABEL_38;
    v31 = *v8;
    v33 = **v8;
    v32 = v31[1];
    while (1)
    {
      if (v33 == v32)
      {
        v30 = v6;
        v8 = a1;
        goto LABEL_39;
      }
      v37 = *v33;
      v38 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
      if (v38 < 0)
      {
        v40 = this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL;
        size = v40 - 1;
        if (this->__r_.__value_.__l.__size_ != v40 - 1)
        {
          v35 = (std::string *)this->__r_.__value_.__r.__words[0];
          size = this->__r_.__value_.__l.__size_;
          goto LABEL_65;
        }
        if (v40 == 0x7FFFFFFFFFFFFFF8)
          std::string::__throw_length_error[abi:ne180100]();
        v39 = (std::string *)this->__r_.__value_.__r.__words[0];
        if (size > 0x3FFFFFFFFFFFFFF2)
        {
          v43 = 0x7FFFFFFFFFFFFFF7;
          v35 = (std::string *)operator new(0x7FFFFFFFFFFFFFF7uLL);
          goto LABEL_61;
        }
      }
      else
      {
        if (*((_BYTE *)&this->__r_.__value_.__s + 23) != 22)
        {
          size = HIBYTE(this->__r_.__value_.__r.__words[2]);
          *((_BYTE *)&this->__r_.__value_.__s + 23) = (v38 + 1) & 0x7F;
          v35 = this;
          goto LABEL_44;
        }
        v39 = this;
        size = 22;
      }
      if (size + 1 > 2 * size)
        v41 = size + 1;
      else
        v41 = 2 * size;
      v42 = (v41 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v41 | 7) != 0x17)
        v42 = v41 | 7;
      if (v41 >= 0x17)
        v43 = v42 + 1;
      else
        v43 = 23;
      v35 = (std::string *)operator new(v43);
      if (!size)
      {
LABEL_62:
        operator delete(v39);
        goto LABEL_63;
      }
LABEL_61:
      memmove(v35, v39, size);
      if (size != 22)
        goto LABEL_62;
LABEL_63:
      this->__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
      this->__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
LABEL_65:
      this->__r_.__value_.__l.__size_ = size + 1;
LABEL_44:
      v36 = (char *)v35 + size;
      *v36 = v37;
      v36[1] = 0;
      ++v33;
    }
  }
  if (a3 != a4)
  {
    do
    {
      v9 = *v6;
      if (v9 == 36)
      {
        v10 = v6 + 1;
        if (v6 + 1 != a4)
        {
          v11 = (char)*v10;
          v9 = *v10;
          if (v11 > 38)
          {
            if (v11 == 39)
            {
              v18 = (std::string::value_type *)v8[9];
              v19 = (std::string::value_type *)v8[10];
              while (v18 != v19)
              {
                v20 = *v18++;
                std::string::push_back(this, v20);
              }
              goto LABEL_6;
            }
            if (v11 == 96)
            {
              v15 = (std::string::value_type *)v8[6];
              v16 = (std::string::value_type *)v8[7];
              while (v15 != v16)
              {
                v17 = *v15++;
                std::string::push_back(this, v17);
              }
              goto LABEL_6;
            }
          }
          else
          {
            if (v11 == 36)
            {
              ++v6;
              goto LABEL_5;
            }
            if (v11 == 38)
            {
              v12 = **v8;
              v13 = (*v8)[1];
              while (v12 != v13)
              {
                v14 = *v12++;
                std::string::push_back(this, v14);
              }
              goto LABEL_6;
            }
          }
          if ((v9 - 48) <= 9)
          {
            v21 = *v10 - 48;
            if (v6 + 2 != a4)
            {
              v22 = v6[2];
              v23 = v22 - 48;
              v24 = v22 + 10 * (int)v21 - 48;
              if (v23 > 9)
              {
                v10 = v6 + 1;
              }
              else
              {
                v21 = v24;
                v10 = v6 + 2;
              }
            }
            if (0xAAAAAAAAAAAAAAABLL * (v8[1] - *v8) <= v21)
              v25 = (uint64_t)(v8 + 3);
            else
              v25 = (uint64_t)&(*v8)[3 * (int)v21];
            v26 = *(std::string::value_type **)v25;
            v27 = *(std::string::value_type **)(v25 + 8);
            if (*(std::string::value_type **)v25 != v27)
            {
              do
              {
                v28 = *v26++;
                std::string::push_back(this, v28);
              }
              while (v26 != v27);
            }
            goto LABEL_6;
          }
        }
        LOBYTE(v9) = 36;
      }
LABEL_5:
      std::string::push_back(this, v9);
      v10 = v6;
LABEL_6:
      v6 = v10 + 1;
    }
    while (v10 + 1 != a4);
  }
  return this;
}

_QWORD *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  int v9;
  char v11;

  v11 = -86;
  MEMORY[0x1A858F734](&v11, a1, 1);
  if (!v11)
    return a1;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD **)((char *)a1 + *(_QWORD *)(*a1 - 24) + 40);
    v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(_QWORD *))(*v7 + 80))(v7);
    if ((_DWORD)v7 == -1)
      break;
LABEL_9:
    if (v7 == a3)
    {
      v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(_QWORD *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6)
    v9 = 2;
  else
    v9 = 6;
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1A34ABC1C(void *a1)
{
  _QWORD *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  v2 = *v1;
  *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(_QWORD *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1A34ABBE8);
  }
  __cxa_rethrow();
}

void sub_1A34ABC60(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Capabilities::create_default_global@<X0>(_QWORD *a1@<X8>)
{
  void *v3;
  _QWORD *result;

  v3 = operator new(1uLL);
  *a1 = v3;
  result = operator new(0x20uLL);
  *result = off_1E4A092B0;
  result[1] = 0;
  result[2] = 0;
  result[3] = v3;
  a1[1] = result;
  return result;
}

void sub_1A34ABCBC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t Capabilities::isCMHandDetectionSupported(Capabilities *this)
{
  capabilities::abs::supportsCMHandDetection(this);
  return objc_msgSend(MEMORY[0x1E0CA5600], "isCallHandednessAvailable");
}

void std::__shared_ptr_pointer<Capabilities *,std::shared_ptr<Capabilities>::__shared_ptr_default_delete<Capabilities,Capabilities>,std::allocator<Capabilities>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<Capabilities *,std::shared_ptr<Capabilities>::__shared_ptr_default_delete<Capabilities,Capabilities>,std::allocator<Capabilities>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<Capabilities *,std::shared_ptr<Capabilities>::__shared_ptr_default_delete<Capabilities,Capabilities>,std::allocator<Capabilities>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001A35809EBLL)
    return a1 + 24;
  if (((v3 & 0x80000001A35809EBLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A35809EBLL))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A35809EBLL & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

const char *diag::config::toString(unsigned int a1)
{
  if (a1 > 4)
    return "Unknown";
  else
    return off_1E4A09308[a1];
}

{
  if (a1 > 2)
    return "Unknown";
  else
    return off_1E4A09330[a1];
}

{
  if (a1 > 2)
    return "Unknown";
  else
    return off_1E4A09348[a1];
}

const char *diag::config::toStringCompact(unsigned int a1)
{
  if (a1 > 2)
    return "unknown";
  else
    return off_1E4A09360[a1];
}

BOOL diag::config::equal_nocase(const char *a1, const char *a2)
{
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  return strcasecmp(a1, a2) == 0;
}

uint64_t diag::config::asEnum(uint64_t a1, _DWORD *a2)
{
  const char *v3;
  int v4;
  uint64_t result;
  char v6[23];
  char v7;

  v7 = 4;
  strcpy(v6, "none");
  if (*(char *)(a1 + 23) >= 0)
    v3 = (const char *)a1;
  else
    v3 = *(const char **)a1;
  if (!strcasecmp(v3, v6))
  {
    *a2 = 0;
    return 1;
  }
  else
  {
    v7 = 5;
    strcpy(v6, "reset");
    if (!strcasecmp(v3, v6))
    {
      *a2 = 1;
      return 1;
    }
    else
    {
      v7 = 11;
      strcpy(v6, "reconfigure");
      v4 = strcasecmp(v3, v6);
      result = 0;
      if (!v4)
      {
        *a2 = 2;
        return 1;
      }
    }
  }
  return result;
}

uint64_t diag::config::getShouldAlwaysFilter(diag::config *this)
{
  int IsCarrierBuild;
  int IsInternalBuild;

  IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  IsInternalBuild = TelephonyUtilIsInternalBuild();
  return (IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild()) ^ 1;
}

_DWORD *abm::DirectoryQuery::DirectoryQuery(_DWORD *a1, int a2, __int128 *a3)
{
  std::string *v4;
  __int128 v5;

  *a1 = a2;
  v4 = (std::string *)(a1 + 2);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v5 = *a3;
    v4->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
  a1[8] = 0;
  return a1;
}

{
  std::string *v4;
  __int128 v5;

  *a1 = a2;
  v4 = (std::string *)(a1 + 2);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v5 = *a3;
    v4->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
  a1[8] = 0;
  return a1;
}

uint64_t abm::FileProperties::FileProperties(uint64_t a1, int a2, __int128 *a3, char a4, int a5)
{
  std::string *v8;
  __int128 v9;

  *(_DWORD *)a1 = a2;
  v8 = (std::string *)(a1 + 8);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v9 = *a3;
    v8->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(_BYTE *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = a5;
  return a1;
}

{
  std::string *v8;
  __int128 v9;

  *(_DWORD *)a1 = a2;
  v8 = (std::string *)(a1 + 8);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v9 = *a3;
    v8->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(_BYTE *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = a5;
  return a1;
}

uint64_t abm::FileProperties::isDirectory(abm::FileProperties *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t abm::FileProperties::getDir(abm::FileProperties *this)
{
  return *(unsigned int *)this;
}

uint64_t abm::FileProperties::getState(abm::FileProperties *this)
{
  return *((unsigned int *)this + 9);
}

void abm::FileProperties::getName(abm::FileProperties *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 31) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 1), *((_QWORD *)this + 2));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 8);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 3);
  }
}

std::string *abm::FileProperties::getPath@<X0>(abm::FileProperties *this@<X0>, std::string *a2@<X8>)
{
  const char *v4;
  std::string *result;
  int v6;
  size_t v7;
  unint64_t v8;
  size_t v9;
  std::string *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  v4 = (const char *)abm::sBaseDirectories[2 * *(unsigned int *)this];
  result = (std::string *)strlen(v4);
  v6 = *((char *)this + 31);
  if (v6 >= 0)
    v7 = *((unsigned __int8 *)this + 31);
  else
    v7 = *((_QWORD *)this + 2);
  v8 = (unint64_t)result + v7;
  memset(a2, 170, sizeof(std::string));
  if ((unint64_t)result + v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (size_t)result;
  if (v8 <= 0x16)
  {
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    a2->__r_.__value_.__r.__words[0] = 0;
    v10 = a2;
    *((_BYTE *)&a2->__r_.__value_.__s + 23) = v8;
    if (!result)
      goto LABEL_12;
LABEL_11:
    result = (std::string *)memcpy(v10, v4, v9);
    goto LABEL_12;
  }
  v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v8 | 7) != 0x17)
    v11 = v8 | 7;
  v12 = v11 + 1;
  result = (std::string *)operator new(v11 + 1);
  v10 = result;
  a2->__r_.__value_.__l.__size_ = v8;
  a2->__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
  a2->__r_.__value_.__r.__words[0] = (std::string::size_type)result;
  if (v9)
    goto LABEL_11;
LABEL_12:
  if (v7)
  {
    if (v6 >= 0)
      v13 = (char *)this + 8;
    else
      v13 = (char *)*((_QWORD *)this + 1);
    result = (std::string *)memmove((char *)v10 + v9, v13, v7);
  }
  v10->__r_.__value_.__s.__data_[v9 + v7] = 0;
  if (*((_BYTE *)this + 32))
    return std::string::append(a2, "/", 1uLL);
  return result;
}

void sub_1A34AC2B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

unint64_t abm::FileProperties::getDirPath@<X0>(abm::FileProperties *this@<X0>, _QWORD *a2@<X8>)
{
  const char *v3;
  unint64_t result;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v3 = (const char *)abm::sBaseDirectories[2 * *(unsigned int *)this];
  result = strlen(v3);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = result;
  if (result >= 0x17)
  {
    v6 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v6 = result | 7;
    v7 = v6 + 1;
    v8 = operator new(v6 + 1);
    a2[1] = v5;
    a2[2] = v7 | 0x8000000000000000;
    *a2 = v8;
    a2 = v8;
  }
  else
  {
    *((_BYTE *)a2 + 23) = result;
    if (!result)
    {
      *(_BYTE *)a2 = 0;
      return result;
    }
  }
  result = (unint64_t)memmove(a2, v3, v5);
  *((_BYTE *)a2 + v5) = 0;
  return result;
}

uint64_t abm::FileProperties::setState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

void abm::asString(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v2;
  __int128 v3;

  v2 = *a1;
  if (*(char *)(*a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(v2 + 8), *(_QWORD *)(v2 + 16));
  }
  else
  {
    v3 = *(_OWORD *)(v2 + 8);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(v2 + 24);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v3;
  }
}

size_t abm::baseDirectoryString@<X0>(unsigned int a1@<W0>, _QWORD *a2@<X8>)
{
  const char *v3;
  size_t result;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v3 = (const char *)abm::sBaseDirectories[2 * a1];
  result = strlen(v3);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = result;
  if (result >= 0x17)
  {
    v6 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v6 = result | 7;
    v7 = v6 + 1;
    v8 = operator new(v6 + 1);
    a2[1] = v5;
    a2[2] = v7 | 0x8000000000000000;
    *a2 = v8;
    a2 = v8;
  }
  else
  {
    *((_BYTE *)a2 + 23) = result;
    if (!result)
    {
      *(_BYTE *)a2 = 0;
      return result;
    }
  }
  result = (size_t)memmove(a2, v3, v5);
  *((_BYTE *)a2 + v5) = 0;
  return result;
}

void abm::findFiles(unsigned int **a1@<X0>, unsigned int a2@<W1>, char ***a3@<X8>)
{
  char **v5;
  unsigned int *v6;
  void *v7;
  const char *v8;
  size_t v9;
  std::string::size_type v10;
  std::string *p_dst;
  uint64_t v12;
  uint64_t v13;
  const std::string::value_type **v14;
  __int128 v15;
  std::string::size_type v16;
  const char *v17;
  size_t v18;
  std::string::size_type v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  unsigned int *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  const std::string::value_type *i;
  char **v31;
  int v32;
  size_t size;
  int v34;
  size_t v35;
  unint64_t v36;
  char *v37;
  std::string *v38;
  char *v39;
  const std::string::value_type *v40;
  timespec v41;
  void **v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  void **v46;
  DIR *v47;
  DIR *v48;
  dirent *v49;
  char *v50;
  char *v51;
  std::string *v52;
  __int128 v53;
  char *v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  __int128 v66;
  char *v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  void **v77;
  void **v78;
  unsigned int **v80;
  unsigned int *v81;
  char ***v82;
  void *v83[3];
  char *v84;
  std::__shared_weak_count *v85;
  std::locale v86;
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  uint64_t v91;
  std::string v92;
  _BYTE v93[48];
  __int128 v94;
  std::string v95;
  std::string __dst;
  void *__p;
  void **v98;
  uint64_t v99;
  stat v100;

  *a3 = (char **)0xAAAAAAAAAAAAAAAALL;
  a3[1] = (char **)0xAAAAAAAAAAAAAAAALL;
  v5 = (char **)operator new(0x30uLL);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = (char *)off_1E4A09388;
  v5[4] = 0;
  v5[5] = 0;
  a3[1] = v5;
  v5[3] = 0;
  v82 = a3;
  *a3 = v5 + 3;
  v6 = *a1;
  v80 = a1;
  if (*a1 != a1[1])
  {
    while (1)
    {
      __p = 0;
      v98 = 0;
      v99 = 0;
      memset(&__dst, 170, sizeof(__dst));
      v8 = (const char *)abm::sBaseDirectories[2 * *v6];
      v9 = strlen(v8);
      if (v9 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      v10 = v9;
      v81 = v6;
      if (v9 >= 0x17)
        break;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v9;
      p_dst = &__dst;
      if (v9)
        goto LABEL_13;
LABEL_14:
      p_dst->__r_.__value_.__s.__data_[v10] = 0;
      v14 = (const std::string::value_type **)(v6 + 2);
      memset(&v95, 170, sizeof(v95));
      if (*((char *)v6 + 31) < 0)
      {
        v16 = *((_QWORD *)v6 + 2);
        if (v16)
        {
          std::string::__init_copy_ctor_external(&v95, *v14, v16);
          goto LABEL_28;
        }
      }
      else if (*((_BYTE *)v6 + 31))
      {
        v15 = *(_OWORD *)v14;
        v95.__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 3);
        *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v15;
        goto LABEL_28;
      }
      v17 = (const char *)abm::sBaseDirectories[2 * *v6 + 1];
      v18 = strlen(v17);
      if (v18 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      v19 = v18;
      if (v18 >= 0x17)
      {
        v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v18 | 7) != 0x17)
          v21 = v18 | 7;
        v22 = v21 + 1;
        v20 = operator new(v21 + 1);
        v95.__r_.__value_.__l.__size_ = v19;
        v95.__r_.__value_.__r.__words[2] = v22 | 0x8000000000000000;
        v95.__r_.__value_.__r.__words[0] = (std::string::size_type)v20;
      }
      else
      {
        *((_BYTE *)&v95.__r_.__value_.__s + 23) = v18;
        v20 = &v95;
        if (!v18)
          goto LABEL_27;
      }
      memmove(v20, v17, v19);
LABEL_27:
      *((_BYTE *)v20 + v19) = 0;
LABEL_28:
      *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v93[32] = v23;
      v94 = v23;
      *(_OWORD *)v93 = v23;
      *(_OWORD *)&v93[16] = v23;
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)v93, (uint64_t)&v95, 0);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v92, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      else
        v92 = __dst;
      std::locale::locale(&v86, (const std::locale *)v93);
      v87 = *(_OWORD *)&v93[8];
      v88 = *(_OWORD *)&v93[24];
      v89 = *(_QWORD *)&v93[40];
      v90 = (std::__shared_weak_count *)v94;
      v24 = v81;
      if ((_QWORD)v94)
      {
        v25 = (unint64_t *)(v94 + 8);
        do
          v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
      }
      v91 = *((_QWORD *)&v94 + 1);
      support::fs::getFilteredFiles((const char *)&v92, (uint64_t)&v86, (uint64_t)&__p, a2);
      v27 = v90;
      if (v90)
      {
        p_shared_owners = (unint64_t *)&v90->__shared_owners_;
        do
          v29 = __ldaxr(p_shared_owners);
        while (__stlxr(v29 - 1, p_shared_owners));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
          std::locale::~locale(&v86);
          if ((SHIBYTE(v92.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_40;
LABEL_39:
          operator delete(v92.__r_.__value_.__l.__data_);
          goto LABEL_40;
        }
      }
      std::locale::~locale(&v86);
      if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_39;
LABEL_40:
      for (i = (const std::string::value_type *)__p; i != (const std::string::value_type *)v98; i += 24)
      {
        v31 = *v82;
        v32 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          size = __dst.__r_.__value_.__l.__size_;
        v34 = i[23];
        if (v34 >= 0)
          v35 = *((unsigned __int8 *)i + 23);
        else
          v35 = *((_QWORD *)i + 1);
        v36 = v35 + size;
        memset(v83, 170, sizeof(v83));
        if (v35 + size > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        if (v36 <= 0x16)
        {
          memset(v83, 0, sizeof(v83));
          v37 = (char *)v83;
          HIBYTE(v83[2]) = v35 + size;
          if (!size)
            goto LABEL_58;
LABEL_54:
          if (v32 >= 0)
            v38 = &__dst;
          else
            v38 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          memmove(v37, v38, size);
          goto LABEL_58;
        }
        v44 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v36 | 7) != 0x17)
          v44 = v36 | 7;
        v45 = v44 + 1;
        v37 = (char *)operator new(v44 + 1);
        v83[1] = (void *)(v35 + size);
        v83[2] = (void *)(v45 | 0x8000000000000000);
        v83[0] = v37;
        v24 = v81;
        if (size)
          goto LABEL_54;
LABEL_58:
        v39 = &v37[size];
        if (v35)
        {
          if (v34 >= 0)
            v40 = i;
          else
            v40 = *(const std::string::value_type **)i;
          memmove(v39, v40, v35);
        }
        v39[v35] = 0;
        v41.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v41.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v100.st_blksize = v41;
        *(timespec *)v100.st_qspare = v41;
        v100.st_birthtimespec = v41;
        *(timespec *)&v100.st_size = v41;
        v100.st_mtimespec = v41;
        v100.st_ctimespec = v41;
        *(timespec *)&v100.st_uid = v41;
        v100.st_atimespec = v41;
        *(timespec *)&v100.st_dev = v41;
        if (SHIBYTE(v83[2]) >= 0)
          v42 = v83;
        else
          v42 = (void **)v83[0];
        if (stat((const char *)v42, &v100)
          || (SHIBYTE(v83[2]) >= 0 ? (v46 = v83) : (v46 = (void **)v83[0]),
              v47 = opendir((const char *)v46),
              (v48 = v47) == 0))
        {
          v43 = 0;
        }
        else
        {
          v49 = readdir(v47);
          closedir(v48);
          v43 = v49 != 0;
        }
        v50 = (char *)operator new(0x40uLL);
        *((_QWORD *)v50 + 1) = 0;
        *((_QWORD *)v50 + 2) = 0;
        *(_QWORD *)v50 = off_1E4A093D8;
        *((_DWORD *)v50 + 6) = *v24;
        v51 = v50 + 24;
        v52 = (std::string *)(v50 + 32);
        if (i[23] < 0)
        {
          std::string::__init_copy_ctor_external(v52, *(const std::string::value_type **)i, *((_QWORD *)i + 1));
        }
        else
        {
          v53 = *(_OWORD *)i;
          *((_QWORD *)v50 + 6) = *((_QWORD *)i + 2);
          *(_OWORD *)&v52->__r_.__value_.__l.__data_ = v53;
        }
        v50[56] = v43;
        *((_DWORD *)v50 + 15) = 1;
        v84 = v50 + 24;
        v85 = (std::__shared_weak_count *)v50;
        v54 = v31[1];
        v55 = (unint64_t)v31[2];
        if ((unint64_t)v54 >= v55)
        {
          v57 = (v54 - *v31) >> 4;
          v58 = v57 + 1;
          if ((unint64_t)(v57 + 1) >> 60)
            std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
          v59 = v55 - (_QWORD)*v31;
          if (v59 >> 3 > v58)
            v58 = v59 >> 3;
          if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0)
            v60 = 0xFFFFFFFFFFFFFFFLL;
          else
            v60 = v58;
          if (v60 >> 60)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v61 = (char *)operator new(16 * v60);
          v62 = &v61[16 * v57];
          v63 = &v61[16 * v60];
          *(_QWORD *)v62 = v51;
          *((_QWORD *)v62 + 1) = v50;
          v84 = 0;
          v85 = 0;
          v56 = v62 + 16;
          v64 = *v31;
          v65 = v31[1];
          if (v65 == *v31)
          {
            *v31 = v62;
            v31[1] = v56;
            v31[2] = v63;
          }
          else
          {
            do
            {
              v66 = *((_OWORD *)v65 - 1);
              v65 -= 16;
              *((_OWORD *)v62 - 1) = v66;
              v62 -= 16;
              *(_QWORD *)v65 = 0;
              *((_QWORD *)v65 + 1) = 0;
            }
            while (v65 != v64);
            v65 = *v31;
            v67 = v31[1];
            *v31 = v62;
            v31[1] = v56;
            v31[2] = v63;
            while (v67 != v65)
            {
              v68 = (std::__shared_weak_count *)*((_QWORD *)v67 - 1);
              if (v68)
              {
                v69 = (unint64_t *)&v68->__shared_owners_;
                do
                  v70 = __ldaxr(v69);
                while (__stlxr(v70 - 1, v69));
                if (!v70)
                {
                  ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
                  std::__shared_weak_count::__release_weak(v68);
                }
              }
              v67 -= 16;
            }
          }
          if (v65)
            operator delete(v65);
        }
        else
        {
          *(_QWORD *)v54 = v51;
          *((_QWORD *)v54 + 1) = v50;
          v56 = v54 + 16;
          v84 = 0;
          v85 = 0;
        }
        v31[1] = v56;
        v71 = v85;
        if (v85)
        {
          v72 = (unint64_t *)&v85->__shared_owners_;
          do
            v73 = __ldaxr(v72);
          while (__stlxr(v73 - 1, v72));
          if (!v73)
          {
            ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
            std::__shared_weak_count::__release_weak(v71);
          }
        }
        if (SHIBYTE(v83[2]) < 0)
          operator delete(v83[0]);
      }
      v74 = (std::__shared_weak_count *)v94;
      if ((_QWORD)v94)
      {
        v75 = (unint64_t *)(v94 + 8);
        do
          v76 = __ldaxr(v75);
        while (__stlxr(v76 - 1, v75));
        if (!v76)
        {
          ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
          std::__shared_weak_count::__release_weak(v74);
        }
      }
      std::locale::~locale((std::locale *)v93);
      if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v95.__r_.__value_.__l.__data_);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_117;
LABEL_114:
        v77 = (void **)__p;
        if (__p)
        {
LABEL_118:
          v78 = v98;
          v7 = v77;
          if (v98 != v77)
          {
            do
            {
              if (*((char *)v78 - 1) < 0)
                operator delete(*(v78 - 3));
              v78 -= 3;
            }
            while (v78 != v77);
            v7 = __p;
          }
          v98 = v77;
          operator delete(v7);
        }
      }
      else
      {
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_114;
LABEL_117:
        operator delete(__dst.__r_.__value_.__l.__data_);
        v77 = (void **)__p;
        if (__p)
          goto LABEL_118;
      }
      v6 = v24 + 10;
      if (v6 == v80[1])
        return;
    }
    v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v12 = v9 | 7;
    v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v10;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    v6 = v81;
LABEL_13:
    memmove(p_dst, v8, v10);
    goto LABEL_14;
  }
}

void sub_1A34ACD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  uint64_t v53;

  if ((a52 & 0x80000000) == 0)
  {
    std::vector<std::string>::~vector[abi:ne180100](&v53);
    ((void (*)())std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100])();
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A34ACCF4);
}

void sub_1A34ACD24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if ((a52 & 0x80000000) == 0)
    JUMPOUT(0x1A34ACD30);
  JUMPOUT(0x1A34ACCF4);
}

void sub_1A34ACD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50)
{
  std::vector<std::string>::~vector[abi:ne180100](&a50);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](a17);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<abm::FileProperties>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09388;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<abm::FileProperties>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09388;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<abm::FileProperties>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  void *v8;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(void **)(a1 + 24);
    if (v3 == v1)
    {
      *(_QWORD *)(a1 + 32) = v1;
      operator delete(v4);
    }
    else
    {
      do
      {
        v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v1);
      v8 = *(void **)(a1 + 24);
      *(_QWORD *)(a1 + 32) = v1;
      operator delete(v8);
    }
  }
}

void std::__shared_ptr_emplace<abm::FileProperties>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A093D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::FileProperties>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A093D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<abm::FileProperties>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
}

void _GLOBAL__sub_I_HelperTaskUtils_cpp()
{
  abm::sBaseDirectories = (uint64_t)abm::trace::kTrashFolder[0];
  *(_QWORD *)algn_1ED114D38 = ".*";
  qword_1ED114D40 = (uint64_t)abm::trace::kScratchFolder[0];
  unk_1ED114D48 = ".*";
  qword_1ED114D50 = (uint64_t)"/var/wireless/Library/Logs/abm.workspace/";
  unk_1ED114D58 = ".*";
  qword_1ED114D60 = (uint64_t)"/var/mobile/Library/Logs/CrashReporter/Baseband/";
  unk_1ED114D68 = ".*";
  qword_1ED114D70 = (uint64_t)"/var/wireless/Library/Logs/";
  unk_1ED114D78 = "^\b$";
  qword_1ED114D80 = (uint64_t)"/var/wireless/Library/Logs/CrashReporter/";
  unk_1ED114D88 = "^CommCenter.*";
  qword_1ED114D90 = (uint64_t)abm::trace::kSnapshotFolder[0];
  unk_1ED114D98 = ".*";
  qword_1ED114DA0 = (uint64_t)abm::trace::kMobileBasebandServicesFolder[0];
  unk_1ED114DA8 = ".*";
}

void abm::CellularLoggingEUR::create(uint64_t *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, _QWORD *a4@<X8>)
{
  std::allocate_shared[abi:ne180100]<abm::CellularLoggingEUR,std::allocator<abm::CellularLoggingEUR>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(a1, a2, a3, a4);
}

uint64_t abm::CellularLoggingEUR::CellularLoggingEUR(uint64_t a1, uint64_t *a2, uint64_t *a3, dispatch_object_t *a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  NSObject *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v22;
  std::__shared_weak_count *v23;
  const char *v24;

  v5 = (std::__shared_weak_count *)a2[1];
  v22 = *a2;
  v23 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *a3;
  v8 = (std::__shared_weak_count *)a3[1];
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v11 = __ldxr(p_shared_weak_owners);
    while (__stxr(v11 + 1, p_shared_weak_owners));
  }
  v12 = *a4;
  if (*a4)
    dispatch_retain(*a4);
  *(_QWORD *)a1 = off_1E4A0B6E8;
  v24 = "carriercellularlogging.modem";
  ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>((_QWORD *)a1, &v24, &v22);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)a1 = off_1E4A0B6E8;
  *(_QWORD *)(a1 + 88) = v9;
  *(_QWORD *)(a1 + 96) = v8;
  if (v8)
  {
    v13 = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = v23;
  *(_QWORD *)(a1 + 104) = v22;
  *(_QWORD *)(a1 + 112) = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  *(_QWORD *)(a1 + 120) = v12;
  if (v12)
  {
    dispatch_retain(v12);
    dispatch_release(v12);
  }
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  v18 = v23;
  if (v23)
  {
    v19 = (unint64_t *)&v23->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  *(_QWORD *)a1 = off_1E4A09428;
  *(_WORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 184) = 0;
  return a1;
}

void sub_1A34AD0D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::__shared_weak_count *v10;
  NSObject *v11;

  if (v11)
  {
    dispatch_release(v11);
    if (!v10)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
      _Unwind_Resume(a1);
    }
  }
  else if (!v10)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::~CellularLoggingEUR(void **this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;

  *this = off_1E4A09428;
  if (*((char *)this + 247) < 0)
  {
    operator delete(this[28]);
    v2 = (std::__shared_weak_count *)this[26];
    if (!v2)
      goto LABEL_8;
  }
  else
  {
    v2 = (std::__shared_weak_count *)this[26];
    if (!v2)
      goto LABEL_8;
  }
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (v4)
  {
LABEL_8:
    v5 = (std::__shared_weak_count *)this[23];
    if (!v5)
      goto LABEL_14;
    goto LABEL_9;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  v5 = (std::__shared_weak_count *)this[23];
  if (!v5)
    goto LABEL_14;
LABEL_9:
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_14:
  v8 = (std::__shared_weak_count *)this[21];
  if (!v8)
    goto LABEL_18;
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (v10)
  {
LABEL_18:
    if ((*((char *)this + 159) & 0x80000000) == 0)
      goto LABEL_19;
LABEL_31:
    operator delete(this[17]);
    *this = off_1E4A0B6E8;
    v11 = this[15];
    if (!v11)
      goto LABEL_21;
    goto LABEL_20;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  if (*((char *)this + 159) < 0)
    goto LABEL_31;
LABEL_19:
  *this = off_1E4A0B6E8;
  v11 = this[15];
  if (v11)
LABEL_20:
    dispatch_release(v11);
LABEL_21:
  v12 = (std::__shared_weak_count *)this[14];
  if (!v12)
    goto LABEL_25;
  v13 = (unint64_t *)&v12->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (v14)
  {
LABEL_25:
    v15 = (std::__shared_weak_count *)this[12];
    if (!v15)
      goto LABEL_27;
    goto LABEL_26;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  v15 = (std::__shared_weak_count *)this[12];
  if (v15)
LABEL_26:
    std::__shared_weak_count::__release_weak(v15);
LABEL_27:
  v16 = (std::__shared_weak_count *)this[10];
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  *this = off_1E4A0B858;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
}

{
  void *v1;

  abm::CellularLoggingEUR::~CellularLoggingEUR(this);
  operator delete(v1);
}

uint64_t abm::CellularLoggingEUR::start(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v4;
  BOOL v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  _BOOL4 v11;
  NSObject *v12;
  const char *v13;
  _BYTE *v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  const char *v18;
  xpc_object_t value;
  void **v20;
  NSObject *v21;
  std::string *v22;
  void *v23;
  int *v24;
  xpc_object_t v25;
  NSObject *v26;
  std::string *v27;
  int v28;
  xpc_object_t v29;
  unsigned int v30;
  capabilities::radio *v31;
  capabilities::abs *v32;
  unsigned int v33;
  NSObject *v34;
  int v35;
  const char *v36;
  NSObject *v37;
  unsigned int v38;
  NSObject *v39;
  _BOOL8 v40;
  const std::string::value_type *v41;
  std::__shared_weak_count *v42;
  unint64_t *p_shared_owners;
  unint64_t v44;
  NSObject *v45;
  __int128 v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *size;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  __int128 v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  const char *v63;
  size_t v64;
  void *v65;
  void **v66;
  NSObject *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  size_t v71;
  void *v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  size_t v76;
  void *v77;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  std::string v82;
  void *v83[2];
  unint64_t v84;
  std::string v85;
  void *v86[2];
  char v87;
  std::string v88;
  void *v89[2];
  char v90;
  void *v91[2];
  unint64_t v92;
  void *v93[2];
  char v94;
  std::string v95;
  void *__dst[2];
  unint64_t v97;
  std::string v98;
  void *v99[2];
  char v100;
  dispatch_object_t v101;
  uint64_t v102;
  std::__shared_weak_count *v103;
  void *v104[2];
  char v105;
  void *v106[2];
  char v107;
  xpc_object_t object;
  void *v109[2];
  char v110;
  void *__p[2];
  char v112;
  void *v113[2];
  char v114;
  BOOL v115;
  void *v116[2];
  char v117;
  void *v118[2];
  char v119;
  std::string v120;
  uint64_t v121;
  std::string buf;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  if (*a2)
    xpc_retain(*a2);
  else
    v4 = xpc_null_create();
  v5 = abm::CellularLoggingCommon::start();
  xpc_release(v4);
  v121 = 0;
  if (v5)
  {
    memset(&v120, 170, sizeof(v120));
    v119 = 4;
    strcpy((char *)v118, "Mode");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v118, &v120);
    if (v119 < 0)
      operator delete(v118[0]);
    LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
    if (util::convert<int>(&v120, &buf, 0))
      *(_DWORD *)(a1 + 196) = buf.__r_.__value_.__l.__data_;
    v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(int *)(a1 + 196);
      if (v7 > 4)
        v8 = "Unknown";
      else
        v8 = off_1E4A095A8[v7];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Previous trace mode: %s", (uint8_t *)&buf, 0xCu);
    }
    v117 = 7;
    strcpy((char *)v116, "Enabled");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v116, &buf);
    if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v120.__r_.__value_.__l.__data_);
    v120 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v117 < 0)
      operator delete(v116[0]);
    v115 = 0;
    util::convert<BOOL>(&v120, &v115, 0);
    if (*(_BYTE *)(a1 + 129))
      *(_BYTE *)(a1 + 129) = 0;
    v11 = v115;
    *(_BYTE *)(a1 + 128) = v115;
    *(_BYTE *)(a1 + 129) = 1;
    v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = "true";
      if (!v11)
        v13 = "false";
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
      _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Previous trace enabled: %s", (uint8_t *)&buf, 0xCu);
    }
    v114 = 9;
    strcpy((char *)v113, "High_Tput");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v113, &buf);
    if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v120.__r_.__value_.__l.__data_);
    v120 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v114 < 0)
      operator delete(v113[0]);
    v14 = (_BYTE *)(a1 + 130);
    util::convert<BOOL>(&v120, (BOOL *)(a1 + 130), 0);
    v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (*v14)
        v16 = "true";
      else
        v16 = "false";
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
      _os_log_impl(&dword_1A343C000, v15, OS_LOG_TYPE_DEFAULT, "#I Previous trace QDSS enabled: %s", (uint8_t *)&buf, 0xCu);
    }
    v112 = 12;
    strcpy((char *)__p, "Data_Logging");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)__p, &buf);
    if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v120.__r_.__value_.__l.__data_);
    v120 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v112 < 0)
      operator delete(__p[0]);
    util::convert<BOOL>(&v120, (BOOL *)(a1 + 131), 0);
    v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 131))
        v18 = "true";
      else
        v18 = "false";
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
      _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, "#I Previous trace ADPL enabled: %s", (uint8_t *)&buf, 0xCu);
    }
    v110 = 4;
    strcpy((char *)v109, "File");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v109, &buf);
    if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v120.__r_.__value_.__l.__data_);
    v120 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v110 < 0)
      operator delete(v109[0]);
    value = xpc_dictionary_get_value(*a2, "kKeyConfigName");
    object = value;
    if (value)
      xpc_retain(value);
    else
      object = xpc_null_create();
    xpc::dyn_cast_or_default();
    v20 = (void **)(a1 + 224);
    if (*(char *)(a1 + 247) < 0)
      operator delete(*v20);
    *(_OWORD *)v20 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(_QWORD *)(a1 + 240) = *((_QWORD *)&buf.__r_.__value_.__l + 2);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    xpc_release(object);
    v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = &v120;
      if ((v120.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v22 = (std::string *)v120.__r_.__value_.__r.__words[0];
      v23 = (void *)(a1 + 224);
      if (*(char *)(a1 + 247) < 0)
        v23 = *v20;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v23;
      _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I Previous trace DMC: %s, Current trace DMC: %s", (uint8_t *)&buf, 0x16u);
    }
    v107 = 7;
    strcpy((char *)v106, "History");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v106, &buf);
    if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v120.__r_.__value_.__l.__data_);
    v120 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v107 < 0)
      operator delete(v106[0]);
    v24 = (int *)(a1 + 216);
    util::convert<int>(&v120, (_DWORD *)(a1 + 216), 0);
    v25 = xpc_dictionary_get_value(*a2, "kKeyConfigHistory");
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
    if (v25)
      xpc_retain(v25);
    else
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    *v24 = xpc::dyn_cast_or_default();
    xpc_release(buf.__r_.__value_.__l.__data_);
    v26 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = &v120;
      if ((v120.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v27 = (std::string *)v120.__r_.__value_.__r.__words[0];
      v28 = *v24;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v28;
      _os_log_impl(&dword_1A343C000, v26, OS_LOG_TYPE_DEFAULT, "#I Previous trace history size: %s, Current trace history size: %d", (uint8_t *)&buf, 0x12u);
    }
    v105 = 8;
    strcpy((char *)v104, "FileSize");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v104, &buf);
    if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v120.__r_.__value_.__l.__data_);
    v120 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v105 < 0)
      operator delete(v104[0]);
    LODWORD(object) = 0;
    util::convert<unsigned int>(&v120, &object, 0);
    v29 = xpc_dictionary_get_value(*a2, "kKeyFileSize");
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
    if (v29)
      xpc_retain(v29);
    else
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    *(_DWORD *)(a1 + 248) = xpc::dyn_cast_or_default();
    xpc_release(buf.__r_.__value_.__l.__data_);
    v30 = *(_DWORD *)(a1 + 248);
    v32 = (capabilities::abs *)capabilities::radio::vendor(v31);
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v32))
      v33 = 0x4000;
    else
      v33 = 0x8000;
    if (v30 < v33)
    {
      v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        v35 = *(_DWORD *)(a1 + 248) >> 10;
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v35;
        v36 = "Given file size (%u) KB is beyond the boundary.";
        v37 = v34;
LABEL_91:
        _os_log_error_impl(&dword_1A343C000, v37, OS_LOG_TYPE_ERROR, v36, (uint8_t *)&buf, 8u);
        goto LABEL_180;
      }
      goto LABEL_180;
    }
    v38 = *(_DWORD *)(a1 + 248);
    v39 = *(NSObject **)(a1 + 40);
    if ((v38 & (v38 - 1)) != 0)
    {
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v38;
        v36 = "File size (%u) KB must be the power of 2";
        v37 = v39;
        goto LABEL_91;
      }
LABEL_180:
      v10 = 0;
LABEL_181:
      if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v120.__r_.__value_.__l.__data_);
      return v10;
    }
    v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    if (v40)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = object >> 10;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v38 >> 10;
      _os_log_impl(&dword_1A343C000, v39, OS_LOG_TYPE_DEFAULT, "#I Previous trace file size: %u KB, Current trace file size: %u KB", (uint8_t *)&buf, 0xEu);
    }
    if (*v14)
    {
      v41 = ".bin";
    }
    else if (capabilities::diag::diagVersion((capabilities::diag *)v40) == 3)
    {
      v41 = ".diag.qmdl2";
    }
    else
    {
      v41 = ".diag.qmdl";
    }
    std::string::__assign_external((std::string *)(a1 + 136), v41);
    *(_DWORD *)(a1 + 192) = 2 * *(unsigned __int8 *)(a1 + 130);
    v42 = *(std::__shared_weak_count **)(a1 + 112);
    v102 = *(_QWORD *)(a1 + 104);
    v103 = v42;
    if (v42)
    {
      p_shared_owners = (unint64_t *)&v42->__shared_owners_;
      do
        v44 = __ldxr(p_shared_owners);
      while (__stxr(v44 + 1, p_shared_owners));
    }
    v45 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
    v101 = dispatch_queue_create("CellularLogging.DIAG.reader.queue", v45);
    BasebandTransport::create((capabilities::radio *)&v102, &v101, (uint64_t)&buf);
    v46 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
    v47 = *(std::__shared_weak_count **)(a1 + 168);
    *(_OWORD *)(a1 + 160) = v46;
    if (v47)
    {
      v48 = (unint64_t *)&v47->__shared_owners_;
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_)
    {
      v51 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    if (v101)
      dispatch_release(v101);
    v53 = v103;
    if (v103)
    {
      v54 = (unint64_t *)&v103->__shared_owners_;
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    if (*(_QWORD *)(a1 + 160))
    {
      abm::CellularLoggingEUR::getGUID((abm::CellularLoggingEUR *)a1, &buf);
      v56 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
      v57 = *(std::__shared_weak_count **)(a1 + 208);
      *(_OWORD *)(a1 + 200) = v56;
      if (v57)
      {
        v58 = (unint64_t *)&v57->__shared_owners_;
        do
          v59 = __ldaxr(v58);
        while (__stlxr(v59 - 1, v58));
        if (!v59)
        {
          ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
          std::__shared_weak_count::__release_weak(v57);
        }
      }
      v60 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
      if (buf.__r_.__value_.__l.__size_)
      {
        v61 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
        do
          v62 = __ldaxr(v61);
        while (__stlxr(v62 - 1, v61));
        if (!v62)
        {
          ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
          std::__shared_weak_count::__release_weak(v60);
        }
      }
      if (*(_QWORD *)(a1 + 200))
      {
        v100 = 12;
        strcpy((char *)v99, "Data_Logging");
        std::to_string(&buf, 0);
        v98 = buf;
        abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v99, (const std::string::value_type *)&v98);
        if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v98.__r_.__value_.__l.__data_);
        if (v100 < 0)
          operator delete(v99[0]);
        v63 = (const char *)*MEMORY[0x1E0CFAF68];
        v64 = strlen((const char *)*MEMORY[0x1E0CFAF68]);
        if (v64 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_190;
        v65 = (void *)v64;
        if (v64 >= 0x17)
        {
          v69 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v64 | 7) != 0x17)
            v69 = v64 | 7;
          v70 = v69 + 1;
          v66 = (void **)operator new(v69 + 1);
          __dst[1] = v65;
          v97 = v70 | 0x8000000000000000;
          __dst[0] = v66;
        }
        else
        {
          HIBYTE(v97) = v64;
          v66 = __dst;
          if (!v64)
          {
LABEL_144:
            *((_BYTE *)v65 + (_QWORD)v66) = 0;
            std::to_string(&buf, 0);
            v95 = buf;
            abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)__dst, (const std::string::value_type *)&v95);
            if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v95.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v97) & 0x80000000) == 0)
              {
LABEL_146:
                v94 = 4;
                strcpy((char *)v93, "File");
                if ((*(char *)(a1 + 247) & 0x80000000) == 0)
                  goto LABEL_147;
                goto LABEL_186;
              }
            }
            else if ((SHIBYTE(v97) & 0x80000000) == 0)
            {
              goto LABEL_146;
            }
            operator delete(__dst[0]);
            v94 = 4;
            strcpy((char *)v93, "File");
            if ((*(char *)(a1 + 247) & 0x80000000) == 0)
            {
LABEL_147:
              v71 = strlen((const char *)(a1 + 224));
              if (v71 <= 0x7FFFFFFFFFFFFFF7)
                goto LABEL_148;
              goto LABEL_187;
            }
LABEL_186:
            v20 = (void **)*v20;
            v71 = strlen((const char *)v20);
            if (v71 <= 0x7FFFFFFFFFFFFFF7)
            {
LABEL_148:
              v72 = (void *)v71;
              if (v71 >= 0x17)
              {
                v74 = (v71 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v71 | 7) != 0x17)
                  v74 = v71 | 7;
                v75 = v74 + 1;
                v73 = operator new(v74 + 1);
                v91[1] = v72;
                v92 = v75 | 0x8000000000000000;
                v91[0] = v73;
              }
              else
              {
                HIBYTE(v92) = v71;
                v73 = v91;
                if (!v71)
                {
LABEL_155:
                  *((_BYTE *)v72 + (_QWORD)v73) = 0;
                  abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v93, (const std::string::value_type *)v91);
                  if (SHIBYTE(v92) < 0)
                    operator delete(v91[0]);
                  if (v94 < 0)
                    operator delete(v93[0]);
                  v90 = 14;
                  strcpy((char *)v89, "TraceOwnership");
                  std::to_string(&buf, 1);
                  v88 = buf;
                  abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v89, (const std::string::value_type *)&v88);
                  if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v88.__r_.__value_.__l.__data_);
                  if (v90 < 0)
                    operator delete(v89[0]);
                  v87 = 4;
                  strcpy((char *)v86, "Mode");
                  std::to_string(&buf, 4);
                  v85 = buf;
                  abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v86, (const std::string::value_type *)&v85);
                  if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
                  {
                    operator delete(v85.__r_.__value_.__l.__data_);
                    if ((v87 & 0x80000000) == 0)
                    {
LABEL_165:
                      v76 = strlen(v63);
                      if (v76 <= 0x7FFFFFFFFFFFFFF7)
                        goto LABEL_166;
                      goto LABEL_190;
                    }
                  }
                  else if ((v87 & 0x80000000) == 0)
                  {
                    goto LABEL_165;
                  }
                  operator delete(v86[0]);
                  v76 = strlen(v63);
                  if (v76 <= 0x7FFFFFFFFFFFFFF7)
                  {
LABEL_166:
                    v77 = (void *)v76;
                    if (v76 >= 0x17)
                    {
                      v79 = (v76 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v76 | 7) != 0x17)
                        v79 = v76 | 7;
                      v80 = v79 + 1;
                      v78 = operator new(v79 + 1);
                      v83[1] = v77;
                      v84 = v80 | 0x8000000000000000;
                      v83[0] = v78;
                    }
                    else
                    {
                      HIBYTE(v84) = v76;
                      v78 = v83;
                      if (!v76)
                        goto LABEL_173;
                    }
                    memmove(v78, v63, (size_t)v77);
LABEL_173:
                    *((_BYTE *)v77 + (_QWORD)v78) = 0;
                    std::to_string(&buf, 1);
                    v82 = buf;
                    abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v83, (const std::string::value_type *)&v82);
                    if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v82.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v84) < 0)
                      operator delete(v83[0]);
                    if ((abm::CellularLoggingEUR::startReader((abm::CellularLoggingEUR *)a1, 1) & 1) != 0)
                    {
                      v10 = 1;
                      goto LABEL_181;
                    }
                    abm::CellularLoggingEUR::stopReader((abm::CellularLoggingEUR *)a1, 1);
                    goto LABEL_180;
                  }
LABEL_190:
                  std::string::__throw_length_error[abi:ne180100]();
                }
              }
              memmove(v73, v20, (size_t)v72);
              goto LABEL_155;
            }
LABEL_187:
            std::string::__throw_length_error[abi:ne180100]();
          }
        }
        memmove(v66, v63, (size_t)v65);
        goto LABEL_144;
      }
      v67 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        goto LABEL_180;
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v68 = "Failed to retrieve GUID for DIAG trace";
    }
    else
    {
      v67 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        goto LABEL_180;
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v68 = "Failed to create transport!";
    }
    _os_log_error_impl(&dword_1A343C000, v67, OS_LOG_TYPE_ERROR, v68, (uint8_t *)&buf, 2u);
    goto LABEL_180;
  }
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Failed creating path", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A34AE26C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (*(char *)(v20 - 137) < 0)
    operator delete(*(void **)(v20 - 160));
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::getGUID(abm::CellularLoggingEUR *this@<X0>, _QWORD *a2@<X8>)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  capabilities::abs *shouldUseMinBasebandTransportIOReadSize;
  int v8;
  int v9;
  char v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  const char *v15;
  char v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  NSObject *v21;
  void **v22;
  void *__p[2];
  uint64_t v24;
  void *aBlock;
  int v26;
  char v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  char v32;
  _QWORD v33[6];
  _QWORD v34[4];
  _QWORD *v35;
  __int128 block;
  _QWORD *(*v37)(uint64_t);
  void *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = (char *)operator new(0x70uLL);
  *((_QWORD *)v4 + 2) = 0;
  *(_QWORD *)v4 = &unk_1E4A09568;
  *((_QWORD *)v4 + 1) = 0;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_OWORD *)(v4 + 88) = 0u;
  *((_QWORD *)v4 + 13) = 0;
  *a2 = v4 + 24;
  a2[1] = v4;
  v5 = capabilities::diag::supportsQShrink4((capabilities::diag *)v4);
  if ((v5 & 1) == 0)
  {
    v13 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block) = 0;
      _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I No GUID supported device!", (uint8_t *)&block, 2u);
    }
    return;
  }
  v6 = *((_QWORD *)this + 20);
  if (!v6)
  {
    v14 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    LOWORD(block) = 0;
    v15 = "Transport is not created!";
    goto LABEL_20;
  }
  v26 = 2;
  v27 = 0;
  v28 = 10;
  shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v5);
  if ((_DWORD)shouldUseMinBasebandTransportIOReadSize)
    v8 = 0x4000;
  else
    v8 = 0x8000;
  v29 = v8;
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize))
    v9 = 4;
  else
    v9 = 16;
  v30 = v9;
  v31 = 0;
  v32 = 0;
  aBlock = 0;
  v10 = (*(uint64_t (**)(uint64_t, int *, void **))(*(_QWORD *)v6 + 48))(v6, &v26, &aBlock);
  if (aBlock)
    _Block_release(aBlock);
  if ((v10 & 1) == 0)
  {
    v14 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    LOWORD(block) = 0;
    v15 = "Failed to open DIAG transport to get GUID info";
LABEL_20:
    _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&block, 2u);
    return;
  }
  __p[0] = 0;
  __p[1] = 0;
  v24 = 0;
  v11 = *((_QWORD *)this + 20);
  v34[0] = 0;
  v34[1] = v34;
  v34[2] = 0x2000000000;
  v34[3] = 0;
  v33[0] = MEMORY[0x1E0C809B0];
  v33[1] = 0x40000000;
  v33[2] = ___ZN17BasebandTransportdeEv_block_invoke;
  v33[3] = &unk_1E4A0A0E8;
  v33[4] = v34;
  v33[5] = v11;
  v35 = v33;
  *(_QWORD *)&block = MEMORY[0x1E0C809B0];
  *((_QWORD *)&block + 1) = 0x40000000;
  v37 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  v38 = &__block_descriptor_tmp_77;
  v39 = v11 + 72;
  v40 = &v35;
  v12 = *(NSObject **)(v11 + 88);
  if (*(_QWORD *)(v11 + 96))
    dispatch_async_and_wait(v12, &block);
  else
    dispatch_sync(v12, &block);
  _Block_object_dispose(v34, 8);
  v16 = ETLDIAGGetGUID();
  if ((BasebandTransport::close(*((BasebandTransport **)this + 20)) & 1) == 0)
  {
    v17 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(block) = 0;
      v18 = "Failed to close transport!";
      goto LABEL_29;
    }
LABEL_31:
    if ((SHIBYTE(v24) & 0x80000000) == 0)
      return;
    goto LABEL_32;
  }
  if ((v16 & 1) != 0)
  {
    if (*((_QWORD *)v4 + 4) == *((_QWORD *)v4 + 5))
    {
      v17 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        LOWORD(block) = 0;
        v18 = "Querying GUID returns empty!";
LABEL_29:
        v19 = v17;
        v20 = 2;
        goto LABEL_37;
      }
    }
    goto LABEL_31;
  }
  v21 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    goto LABEL_31;
  v22 = __p;
  if (v24 < 0)
    v22 = (void **)__p[0];
  LODWORD(block) = 136315138;
  *(_QWORD *)((char *)&block + 4) = v22;
  v18 = "Failed to get GUID and error description: %s";
  v19 = v21;
  v20 = 12;
LABEL_37:
  _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, v18, (uint8_t *)&block, v20);
  if (SHIBYTE(v24) < 0)
LABEL_32:
    operator delete(__p[0]);
}

void sub_1A34AE950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *aBlock)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingEUR::startReader(abm::CellularLoggingEUR *this, int a2)
{
  int v4;
  capabilities::trace *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  char *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  NSObject *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v18;
  int v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  void *v41;
  NSObject *v42;
  uint64_t v43;
  unsigned int v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  NSObject *v54;
  NSObject *v55;
  uint64_t v56;
  NSObject *v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  BOOL v63;
  NSObject *v64;
  void *v65;
  char v66;
  void *v67;
  dispatch_object_t object;
  uint64_t v69;
  std::__shared_weak_count *v70;
  _QWORD aBlock[5];
  uint8_t v72[16];
  uint64_t v73;
  std::__shared_weak_count *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;
  uint64_t v77;
  std::__shared_weak_count *v78;
  void *__p[2];
  char v80;
  std::string v81;
  uint8_t v82[4];
  const char *v83;
  uint8_t buf[24];
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  memset(&v81, 170, sizeof(v81));
  v80 = 14;
  strcpy((char *)__p, "TraceOwnership");
  abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)__p, &v81);
  if (v80 < 0)
    operator delete(__p[0]);
  v4 = -1431655766;
  *(_DWORD *)buf = -1431655766;
  if ((util::convert<int>(&v81, buf, 0) & 1) == 0 || (v4 = *(_DWORD *)buf, *(_DWORD *)buf != 1))
  {
    v14 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v4;
      _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "Trace Owner: %d, CellularLogging does not own trace transport. Skip creating trace reader", buf, 8u);
    }
    goto LABEL_16;
  }
  v5 = (capabilities::trace *)operator new(0x40uLL);
  v6 = (std::__shared_weak_count *)v5;
  *((_QWORD *)v5 + 1) = 0;
  v7 = (unint64_t *)((char *)v5 + 8);
  *((_QWORD *)v5 + 2) = 0;
  *(_QWORD *)v5 = off_1E4A0CA58;
  v8 = (char *)v5 + 24;
  *((_QWORD *)v5 + 7) = 0;
  *((_QWORD *)v5 + 6) = 0;
  *((_QWORD *)v5 + 5) = (char *)v5 + 48;
  do
    v9 = __ldxr(v7);
  while (__stxr(v9 + 1, v7));
  v10 = (unint64_t *)((char *)v5 + 16);
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  *((_QWORD *)v5 + 3) = (char *)v5 + 24;
  *((_QWORD *)v5 + 4) = v5;
  do
    v12 = __ldaxr(v7);
  while (__stlxr(v12 - 1, v7));
  if (!v12)
  {
    (*(void (**)(capabilities::trace *))(*(_QWORD *)v5 + 16))(v5);
    std::__shared_weak_count::__release_weak(v6);
    v13 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
    *((_QWORD *)this + 22) = v8;
    *((_QWORD *)this + 23) = v6;
    if (!v13)
      goto LABEL_25;
    goto LABEL_21;
  }
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 22) = v8;
  *((_QWORD *)this + 23) = v5;
  if (v13)
  {
LABEL_21:
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (v18)
    {
      if (*((_QWORD *)this + 22))
        goto LABEL_25;
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      if (*((_QWORD *)this + 22))
        goto LABEL_25;
    }
    v55 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v55, OS_LOG_TYPE_ERROR, "Failed to create DIAG reader!", buf, 2u);
    }
LABEL_16:
    v15 = 0;
    goto LABEL_17;
  }
LABEL_25:
  memset(buf, 170, 16);
  v19 = *((unsigned __int8 *)this + 130);
  v20 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  v77 = *((_QWORD *)this + 20);
  v78 = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v23 = (std::__shared_weak_count *)*((_QWORD *)this + 26);
  v75 = *((_QWORD *)this + 25);
  v76 = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  v26 = (std::__shared_weak_count *)*((_QWORD *)this + 14);
  v73 = *((_QWORD *)this + 13);
  v74 = v26;
  if (v26)
  {
    v27 = (unint64_t *)&v26->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v29 = *((_DWORD *)this + 54);
  v30 = capabilities::trace::defaultMemoryFileMaxCount(v5);
  if (v19)
    v31 = 15;
  else
    v31 = 2;
  diag::DIAGReader::Parameters::create(v31, &v77, &v75, &v73, v29, "/private/var/mobile/Library/Logs/CellularLogging", v30, *((_DWORD *)this + 62), buf);
  v32 = v74;
  if (v74)
  {
    v33 = (unint64_t *)&v74->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v76;
  if (v76)
  {
    v36 = (unint64_t *)&v76->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = v78;
  if (v78)
  {
    v39 = (unint64_t *)&v78->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  if (!*(_QWORD *)buf)
  {
    v54 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v72 = 0;
      _os_log_error_impl(&dword_1A343C000, v54, OS_LOG_TYPE_ERROR, "Failed to create reader parameters", v72, 2u);
    }
    v15 = 0;
    goto LABEL_88;
  }
  memset(v72, 170, sizeof(v72));
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN3abm18CellularLoggingEUR11startReaderEb_block_invoke;
  aBlock[3] = &__block_descriptor_40_e211_v32__0_basic_string_char__std::char_traits_char___std::allocator_char______compressed_pair_std::basic_string_char_::__rep__std::allocator_char______rep_______short__23c__0C_b7b1____long__Qb63b1____raw__3Q______8l;
  aBlock[4] = this;
  v41 = _Block_copy(aBlock);
  v42 = *((_QWORD *)this + 15);
  if (v42)
    dispatch_retain(*((dispatch_object_t *)this + 15));
  *(_QWORD *)v72 = v41;
  *(_QWORD *)&v72[8] = v42;
  v43 = *((_QWORD *)this + 22);
  v44 = *((_DWORD *)this + 48);
  v69 = *(_QWORD *)buf;
  v70 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v45 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  if (v41)
  {
    v67 = _Block_copy(v41);
    object = v42;
    if (!v42)
      goto LABEL_61;
    goto LABEL_60;
  }
  v67 = 0;
  object = v42;
  if (v42)
LABEL_60:
    dispatch_retain(v42);
LABEL_61:
  diag::DIAGReaderManager::addReader(v43, v44, &v69, (uint64_t)&v67);
  if (object)
    dispatch_release(object);
  if (v67)
    _Block_release(v67);
  v47 = v70;
  if (v70)
  {
    v48 = (unint64_t *)&v70->__shared_owners_;
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  v50 = *((_QWORD *)this + 22);
  v66 = 0;
  LOBYTE(v65) = 0;
  diag::DIAGReaderManager::pushInfo(v50, 4, (uint64_t)&v65);
  if (v66 < 0)
  {
    operator delete(v65);
    v56 = *((_QWORD *)this + 22);
    v52 = *(_QWORD **)(v56 + 16);
    v53 = (_QWORD *)(v56 + 24);
    if (v52 == (_QWORD *)(v56 + 24))
      goto LABEL_82;
  }
  else
  {
    v51 = *((_QWORD *)this + 22);
    v52 = *(_QWORD **)(v51 + 16);
    v53 = (_QWORD *)(v51 + 24);
    if (v52 == (_QWORD *)(v51 + 24))
      goto LABEL_82;
  }
  do
  {
    diag::DIAGReader::start((diag::DIAGReader *)v52[5]);
    v61 = (_QWORD *)v52[1];
    if (v61)
    {
      do
      {
        v62 = v61;
        v61 = (_QWORD *)*v61;
      }
      while (v61);
    }
    else
    {
      do
      {
        v62 = (_QWORD *)v52[2];
        v63 = *v62 == (_QWORD)v52;
        v52 = v62;
      }
      while (!v63);
    }
    v52 = v62;
  }
  while (v62 != v53);
LABEL_82:
  if (!a2 || (abm::CellularLoggingCommon::changeState(this, 1) & 1) != 0)
  {
    v15 = 1;
    v57 = *(NSObject **)&v72[8];
    if (!*(_QWORD *)&v72[8])
      goto LABEL_86;
    goto LABEL_85;
  }
  v64 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
  {
    v15 = 0;
    v57 = *(NSObject **)&v72[8];
    if (!*(_QWORD *)&v72[8])
      goto LABEL_86;
LABEL_85:
    dispatch_release(v57);
    goto LABEL_86;
  }
  *(_DWORD *)v82 = 136315138;
  v83 = "true";
  _os_log_error_impl(&dword_1A343C000, v64, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", v82, 0xCu);
  v15 = 0;
  v57 = *(NSObject **)&v72[8];
  if (*(_QWORD *)&v72[8])
    goto LABEL_85;
LABEL_86:
  if (*(_QWORD *)v72)
    _Block_release(*(const void **)v72);
LABEL_88:
  v58 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v59 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }
LABEL_17:
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v81.__r_.__value_.__l.__data_);
  return v15;
}

void sub_1A34AF044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  uint64_t v37;

  dispatch::callback<void({block_pointer})(std::string)>::~callback((uint64_t)&a24);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v37 - 96);
  if (*(char *)(v37 - 113) < 0)
    operator delete(*(void **)(v37 - 136));
  _Unwind_Resume(a1);
}

BOOL abm::CellularLoggingEUR::stopReader(abm::CellularLoggingEUR *this, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  _BOOL8 result;
  _QWORD *v23;
  _QWORD *v24;
  void *__p;
  char v26;
  uint8_t buf[4];
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)((char *)this + 176);
  v4 = *((_QWORD *)this + 22);
  if (!v4)
    goto LABEL_28;
  v26 = 0;
  LOBYTE(__p) = 0;
  diag::DIAGReaderManager::pushInfo(v4, 6, (uint64_t)&__p);
  if (v26 < 0)
  {
    operator delete(__p);
    v6 = *v5;
    v7 = *(_QWORD **)(*v5 + 16);
    v8 = *v5 + 24;
    if (v7 == (_QWORD *)v8)
      goto LABEL_6;
  }
  else
  {
    v6 = *v5;
    v7 = *(_QWORD **)(*v5 + 16);
    v8 = *v5 + 24;
    if (v7 == (_QWORD *)v8)
    {
LABEL_6:
      v9 = v6 + 24;
      if (v7 == (_QWORD *)(v6 + 24))
        goto LABEL_19;
      goto LABEL_33;
    }
  }
  do
  {
    v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7[5] + 16) + 24) + 336);
    usleep(0x7A120u);
    v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7[5] + 16) + 24) + 336);
    if (v10 != v11)
    {
      usleep(0x7A120u);
      if (v11 != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7[5] + 16) + 24) + 336))
        usleep(0x7A120u);
    }
    v12 = (_QWORD *)v7[1];
    if (v12)
    {
      do
      {
        v13 = v12;
        v12 = (_QWORD *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        v13 = (_QWORD *)v7[2];
        v14 = *v13 == (_QWORD)v7;
        v7 = v13;
      }
      while (!v14);
    }
    v7 = v13;
  }
  while (v13 != (_QWORD *)v8);
  v7 = *(_QWORD **)(*v5 + 16);
  v9 = *v5 + 24;
  if (v7 != (_QWORD *)v9)
  {
    do
    {
LABEL_33:
      diag::DIAGReader::stop((diag::DIAGReader *)v7[5]);
      v23 = (_QWORD *)v7[1];
      if (v23)
      {
        do
        {
          v24 = v23;
          v23 = (_QWORD *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          v24 = (_QWORD *)v7[2];
          v14 = *v24 == (_QWORD)v7;
          v7 = v24;
        }
        while (!v14);
      }
      v7 = v24;
    }
    while (v24 != (_QWORD *)v9);
  }
LABEL_19:
  v15 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  if (!v15)
  {
    *v5 = 0;
    v5[1] = 0;
    if (!a2)
      return 1;
    goto LABEL_29;
  }
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v18 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
  *v5 = 0;
  v5[1] = 0;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
      if (!a2)
        return 1;
      goto LABEL_29;
    }
  }
LABEL_28:
  if (!a2)
    return 1;
LABEL_29:
  if ((abm::CellularLoggingCommon::changeState(this, 0) & 1) != 0)
    return 1;
  v21 = *((_QWORD *)this + 5);
  result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136315138;
    v28 = "false";
    _os_log_error_impl(&dword_1A343C000, v21, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", buf, 0xCu);
    return 0;
  }
  return result;
}

void sub_1A34AF3D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingEUR::pause(abm::CellularLoggingEUR *a1)
{
  return abm::CellularLoggingEUR::stopReader(a1, 0);
}

uint64_t abm::CellularLoggingEUR::resume(abm::CellularLoggingEUR *a1)
{
  return abm::CellularLoggingEUR::startReader(a1, 0);
}

void ___ZN3abm18CellularLoggingEUR11startReaderEb_block_invoke(uint64_t a1, uint64_t *a2)
{
  NSObject *v3;
  int v4;
  uint64_t *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) < 0)
      a2 = (uint64_t *)*a2;
    v4 = 136315138;
    v5 = a2;
    _os_log_error_impl(&dword_1A343C000, v3, OS_LOG_TYPE_ERROR, "Diag Reader Error: %s", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t dispatch::callback<void({block_pointer})(std::string)>::~callback(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 8);
  if (v2)
    dispatch_release(v2);
  if (*(_QWORD *)a1)
    _Block_release(*(const void **)a1);
  return a1;
}

void abm::CellularLoggingEUR::getGUIDStrings(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  __int128 v7;
  unint64_t v8;
  char *v9;
  int v10;
  NSObject *v11;
  void *__p[2];
  uint64_t v13;

  v4 = *a2;
  if (*a2)
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    v5 = *(_QWORD *)(v4 + 8);
    for (i = *(_QWORD *)(v4 + 16); v5 != i; v5 += 16)
    {
      while (1)
      {
        while (1)
        {
          ETLDIAGLoggingGetGUIDString();
          v8 = *(_QWORD *)(a3 + 8);
          if (v8 >= *(_QWORD *)(a3 + 16))
            break;
          v7 = *(_OWORD *)__p;
          *(_QWORD *)(v8 + 16) = v13;
          *(_OWORD *)v8 = v7;
          *(_QWORD *)(a3 + 8) = v8 + 24;
          v5 += 16;
          if (v5 == i)
            return;
        }
        v9 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a3, (uint64_t)__p);
        v10 = SHIBYTE(v13);
        *(_QWORD *)(a3 + 8) = v9;
        if (v10 < 0)
          break;
        v5 += 16;
        if (v5 == i)
          return;
      }
      operator delete(__p[0]);
    }
  }
  else
  {
    v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "No DIAG GUID parameter is given", (uint8_t *)__p, 2u);
    }
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
  }
}

void sub_1A34AF620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void **v14;

  if (a14 < 0)
  {
    operator delete(__p);
    std::vector<std::string>::~vector[abi:ne180100](v14);
    _Unwind_Resume(a1);
  }
  std::vector<std::string>::~vector[abi:ne180100](v14);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::stop(abm::CellularLoggingEUR *this)
{
  const void *v2;
  size_t v3;
  void *v4;
  void **v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  int v10;
  const char *v11;
  size_t v12;
  _BOOL8 v13;
  int v14;
  _BOOL8 v15;
  unsigned int v16;
  _BOOL8 v17;
  int v18;
  size_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  std::string v24;
  void *v25[2];
  unint64_t v26;
  std::string v27;
  void *v28[2];
  char v29;
  std::string v30;
  void *v31[2];
  char v32;
  std::string v33;
  void *v34[2];
  char v35;
  void *v36[2];
  char v37;
  void *v38[2];
  char v39;
  std::string __p;
  void *v41[2];
  char v42;
  std::string v43;
  void *v44[2];
  char v45;
  std::string v46;
  void *__dst[2];
  unint64_t v48;
  std::string buf;

  if (!abm::CellularLoggingCommon::isStarted(this))
  {
    v6 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", (uint8_t *)&buf, 2u);
    }
    return;
  }
  abm::CellularLoggingEUR::stopReader(this, 1);
  v2 = (const void *)*MEMORY[0x1E0CFAF68];
  v3 = strlen((const char *)*MEMORY[0x1E0CFAF68]);
  if (v3 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v4 = (void *)v3;
  if (v3 >= 0x17)
  {
    v7 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17)
      v7 = v3 | 7;
    v8 = v7 + 1;
    v5 = (void **)operator new(v7 + 1);
    __dst[1] = v4;
    v48 = v8 | 0x8000000000000000;
    __dst[0] = v5;
    goto LABEL_11;
  }
  HIBYTE(v48) = v3;
  v5 = __dst;
  if (v3)
LABEL_11:
    memmove(v5, v2, (size_t)v4);
  *((_BYTE *)v4 + (_QWORD)v5) = 0;
  std::to_string(&buf, 0);
  v46 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)__dst, (const std::string::value_type *)&v46);
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v46.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v48) & 0x80000000) == 0)
      goto LABEL_14;
  }
  else if ((SHIBYTE(v48) & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(__dst[0]);
LABEL_14:
  v45 = 14;
  strcpy((char *)v44, "TraceOwnership");
  std::to_string(&buf, 0);
  v43 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v44, (const std::string::value_type *)&v43);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((v45 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v45 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v44[0]);
LABEL_16:
  v42 = 4;
  strcpy((char *)v41, "Mode");
  std::to_string(&buf, 0);
  __p = buf;
  v9 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v41, (const std::string::value_type *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v42 & 0x80000000) == 0)
      goto LABEL_18;
  }
  else if ((v42 & 0x80000000) == 0)
  {
    goto LABEL_18;
  }
  operator delete(v41[0]);
LABEL_18:
  v39 = 4;
  strcpy((char *)v38, "File");
  v10 = config::hw::watch((config::hw *)v9);
  if (v10)
    v11 = "Lite";
  else
    v11 = "Default";
  if (v10)
    v12 = 4;
  else
    v12 = 7;
  v37 = v12;
  memcpy(v36, v11, v12);
  *(_BYTE *)((unint64_t)v36 | v12) = 0;
  v13 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v38, (const std::string::value_type *)v36);
  if (v37 < 0)
  {
    operator delete(v36[0]);
    if ((v39 & 0x80000000) == 0)
      goto LABEL_26;
  }
  else if ((v39 & 0x80000000) == 0)
  {
    goto LABEL_26;
  }
  operator delete(v38[0]);
LABEL_26:
  v35 = 7;
  strcpy((char *)v34, "History");
  v14 = capabilities::trace::defaultHistorySizeMB((capabilities::trace *)v13);
  std::to_string(&buf, v14);
  v33 = buf;
  v15 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v34, (const std::string::value_type *)&v33);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((v35 & 0x80000000) == 0)
      goto LABEL_28;
  }
  else if ((v35 & 0x80000000) == 0)
  {
    goto LABEL_28;
  }
  operator delete(v34[0]);
LABEL_28:
  v32 = 8;
  strcpy((char *)v31, "FileSize");
  v16 = capabilities::trace::defaultFileSizeBytes((capabilities::trace *)v15);
  std::to_string(&buf, v16);
  v30 = buf;
  v17 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v31, (const std::string::value_type *)&v30);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v30.__r_.__value_.__l.__data_);
    if ((v32 & 0x80000000) == 0)
      goto LABEL_30;
  }
  else if ((v32 & 0x80000000) == 0)
  {
    goto LABEL_30;
  }
  operator delete(v31[0]);
LABEL_30:
  v29 = 12;
  strcpy((char *)v28, "Data_Logging");
  v18 = capabilities::trace::supportsDataLoggingByDefault((capabilities::trace *)v17);
  std::to_string(&buf, v18);
  v27 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v28, (const std::string::value_type *)&v27);
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v27.__r_.__value_.__l.__data_);
    if ((v29 & 0x80000000) == 0)
    {
LABEL_32:
      if (!*((_BYTE *)this + 129))
        return;
      goto LABEL_48;
    }
  }
  else if ((v29 & 0x80000000) == 0)
  {
    goto LABEL_32;
  }
  operator delete(v28[0]);
  if (!*((_BYTE *)this + 129))
    return;
LABEL_48:
  v19 = strlen((const char *)v2);
  if (v19 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v20 = (void *)v19;
  if (v19 >= 0x17)
  {
    v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v22 = v19 | 7;
    v23 = v22 + 1;
    v21 = operator new(v22 + 1);
    v25[1] = v20;
    v26 = v23 | 0x8000000000000000;
    v25[0] = v21;
  }
  else
  {
    HIBYTE(v26) = v19;
    v21 = v25;
    if (!v19)
      goto LABEL_56;
  }
  memmove(v21, v2, (size_t)v20);
LABEL_56:
  *((_BYTE *)v20 + (_QWORD)v21) = 0;
  if (!*((_BYTE *)this + 129))
    std::__throw_bad_optional_access[abi:ne180100]();
  std::to_string(&buf, *((unsigned __int8 *)this + 128));
  v24 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v25, (const std::string::value_type *)&v24);
  if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v26) & 0x80000000) == 0)
      return;
LABEL_61:
    operator delete(v25[0]);
    return;
  }
  operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v26) < 0)
    goto LABEL_61;
}

void sub_1A34AFBEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(a1);
}

void sub_1A34AFDE8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A34AF774);
}

void sub_1A34AFDF4()
{
  uint64_t v0;

  if ((*(char *)(v0 - 121) & 0x80000000) == 0)
    JUMPOUT(0x1A34AFDCCLL);
  JUMPOUT(0x1A34AFDC4);
}

void abm::CellularLoggingEUR::stopWithConfig(abm::CellularLoggingEUR *a1, uint64_t a2)
{
  uint64_t v3;
  xpc_object_t object;
  char v5;

  abm::CellularLoggingEUR::stop(a1);
  object = xpc_null_create();
  v5 = 1;
  v3 = *(_QWORD *)(a2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, xpc_object_t *))(*(_QWORD *)v3 + 48))(v3, &v5, &object);
  xpc_release(object);
}

void sub_1A34AFE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::getConfigName(abm::CellularLoggingEUR *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 247) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 28), *((_QWORD *)this + 29));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 14);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 30);
  }
}

uint64_t abm::CellularLoggingEUR::getConfigHistoryMB(abm::CellularLoggingEUR *this)
{
  return *((unsigned int *)this + 54);
}

void abm::CellularLoggingEUR::getFileExtension(abm::CellularLoggingEUR *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 159) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 17), *((_QWORD *)this + 18));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 136);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 19);
  }
}

uint64_t abm::CellularLoggingEUR::getMaxNumberOfFiles(abm::CellularLoggingEUR *this)
{
  return *((unsigned int *)this + 54);
}

uint64_t abm::CellularLoggingEUR::getFileSize(abm::CellularLoggingEUR *this)
{
  return *((unsigned int *)this + 62);
}

void abm::CellularLoggingEUR::getModemInformation1(abm::CellularLoggingEUR *this@<X0>, xpc_object_t *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  __int128 v6;
  _OWORD *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  uint64_t v10;
  NSObject *v11;
  xpc_object_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  const char *v16;
  xpc_object_t v17;
  char *v18;
  char *v19;
  void *__p[2];
  uint64_t v21;
  uint8_t buf[8];
  char *v23;
  unint64_t v24;

  v3 = *((_QWORD *)this + 25);
  if (v3)
  {
    v23 = 0;
    v24 = 0;
    *(_QWORD *)buf = 0;
    v4 = *(_QWORD *)(v3 + 8);
    for (i = *(_QWORD *)(v3 + 16); v4 != i; v4 += 16)
    {
      while (1)
      {
        while (1)
        {
          ETLDIAGLoggingGetGUIDString();
          v7 = v23;
          if ((unint64_t)v23 >= v24)
            break;
          v6 = *(_OWORD *)__p;
          *((_QWORD *)v23 + 2) = v21;
          *v7 = v6;
          v23 = (char *)v7 + 24;
          v4 += 16;
          if (v4 == i)
            goto LABEL_10;
        }
        v23 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)buf, (uint64_t)__p);
        if (SHIBYTE(v21) < 0)
          break;
        v4 += 16;
        if (v4 == i)
          goto LABEL_10;
      }
      operator delete(__p[0]);
    }
LABEL_10:
    *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    v8 = xpc_array_create(0, 0);
    v9 = v8;
    v10 = MEMORY[0x1E0C812C8];
    if (v8)
    {
      *a2 = v8;
    }
    else
    {
      v9 = xpc_null_create();
      *a2 = v9;
      if (!v9)
      {
        v12 = xpc_null_create();
        v9 = 0;
        goto LABEL_21;
      }
    }
    if (MEMORY[0x1A85902BC](v9) == v10)
    {
      xpc_retain(v9);
      goto LABEL_22;
    }
    v12 = xpc_null_create();
LABEL_21:
    *a2 = v12;
LABEL_22:
    xpc_release(v9);
    v13 = MEMORY[0x1A85902BC](*a2);
    v14 = *(char **)buf;
    if (v13 == v10)
    {
      v15 = v23;
      if (*(char **)buf != v23)
      {
        do
        {
          v16 = v14;
          if (v14[23] < 0)
            v16 = *(const char **)v14;
          v17 = xpc_string_create(v16);
          if (!v17)
            v17 = xpc_null_create();
          xpc_array_append_value(*a2, v17);
          xpc_release(v17);
          v14 += 24;
        }
        while (v14 != v15);
        v14 = *(char **)buf;
      }
    }
    if (v14)
    {
      v18 = v23;
      v19 = v14;
      if (v23 != v14)
      {
        do
        {
          if (*(v18 - 1) < 0)
            operator delete(*((void **)v18 - 3));
          v18 -= 24;
        }
        while (v18 != v14);
        v19 = *(char **)buf;
      }
      v23 = v14;
      operator delete(v19);
    }
    return;
  }
  v11 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "GUID Parameter has not been created!", buf, 2u);
  }
  *a2 = xpc_null_create();
}

void sub_1A34B013C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  xpc_object_t *v13;

  xpc::array::~array(v13);
  std::vector<std::string>::~vector[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

void sub_1A34B0188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    std::vector<std::string>::~vector[abi:ne180100](&a16);
    _Unwind_Resume(a1);
  }
  std::vector<std::string>::~vector[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

void xpc::array::~array(xpc_object_t *this)
{
  xpc_release(*this);
  *this = 0;
}

void abm::CellularLoggingEUR::getModemInformation2(abm::CellularLoggingEUR *this@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4;
  xpc_object_t v5;
  uint64_t v6;
  NSObject *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *i;
  xpc_object_t v13;
  __int16 v14[8];

  if (*((_QWORD *)this + 25))
  {
    *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    v4 = xpc_array_create(0, 0);
    v5 = v4;
    v6 = MEMORY[0x1E0C812C8];
    if (v4)
    {
      *a2 = v4;
    }
    else
    {
      v5 = xpc_null_create();
      *a2 = v5;
      if (!v5)
      {
        v8 = xpc_null_create();
        v5 = 0;
        goto LABEL_12;
      }
    }
    if (MEMORY[0x1A85902BC](v5) == v6)
    {
      xpc_retain(v5);
LABEL_13:
      xpc_release(v5);
      v9 = *a2;
      if (MEMORY[0x1A85902BC](*a2) == v6)
      {
        v10 = *((_QWORD *)this + 25);
        v11 = *(unsigned __int8 **)(v10 + 32);
        for (i = *(unsigned __int8 **)(v10 + 40); v11 != i; ++v11)
        {
          v13 = xpc_int64_create(*v11);
          if (!v13)
            v13 = xpc_null_create();
          xpc_array_append_value(v9, v13);
          xpc_release(v13);
        }
      }
      return;
    }
    v8 = xpc_null_create();
LABEL_12:
    *a2 = v8;
    goto LABEL_13;
  }
  v7 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v14[0] = 0;
    _os_log_error_impl(&dword_1A343C000, v7, OS_LOG_TYPE_ERROR, "GUID Parameter has not been created!", (uint8_t *)v14, 2u);
  }
  *a2 = xpc_null_create();
}

void sub_1A34B036C(_Unwind_Exception *a1)
{
  xpc_object_t *v1;

  xpc::array::~array(v1);
  _Unwind_Resume(a1);
}

void sub_1A34B0394(_Unwind_Exception *a1)
{
  xpc_object_t *v1;
  void *v2;

  xpc_release(v2);
  xpc::array::~array(v1);
  _Unwind_Resume(a1);
}

uint64_t abm::CellularLoggingEUR::getCurrentIndex(abm::CellularLoggingEUR *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  uint64_t *v9;
  TraceFileCollection *v10;
  NSObject *v12;
  uint8_t v13[16];

  v1 = *((_QWORD *)this + 22);
  if (v1)
  {
    v4 = *(_QWORD *)(v1 + 24);
    v2 = v1 + 24;
    v3 = v4;
    if (v4)
    {
      v5 = *((_DWORD *)this + 48);
      v6 = v2;
      do
      {
        v7 = *(_DWORD *)(v3 + 32);
        v8 = v7 >= v5;
        if (v7 >= v5)
          v9 = (uint64_t *)v3;
        else
          v9 = (uint64_t *)(v3 + 8);
        if (v8)
          v6 = v3;
        v3 = *v9;
      }
      while (*v9);
      if (v6 != v2 && *(_DWORD *)(v6 + 32) <= v5)
      {
        v10 = *(TraceFileCollection **)(*(_QWORD *)(v6 + 40) + 32);
        if (v10)
          return TraceFileCollection::getNewestFileNumber(v10);
      }
    }
    return 0;
  }
  v12 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    return 0;
  *(_WORD *)v13 = 0;
  _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "Reader does not exist!", v13, 2u);
  return 0;
}

void abm::CellularLoggingEUR::getCandidateConfigNames(_QWORD *a1@<X8>)
{
  unsigned __int8 **v3;
  unsigned __int8 **v4;
  void **v5;
  void **v6;
  char v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  void **v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  const void **v14;
  unsigned __int8 **v15;
  __int128 v16;
  const void **v17;
  void **v18;
  void **v19;
  int v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned __int8 *v24;
  uint64_t v25;
  unsigned __int8 **v26;
  void **v27;
  void **v28;
  void *v29;
  void **v30;
  void **v31;
  void *v32;
  void *v33;
  void **v34;
  uint64_t v35;
  void *v36[3];
  void *v37[2];
  char v38;
  void *v39[2];
  char v40;
  void *v41[2];
  char v42;
  void *__p[2];
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  memset(a1, 170, 24);
  ETLDIAGLoggingGetAvailableDMCNames();
  memset(v36, 170, sizeof(v36));
  v38 = 7;
  strcpy((char *)v37, "Default");
  v40 = 4;
  strcpy((char *)v39, "Tput");
  v42 = 4;
  strcpy((char *)v41, "Lite");
  v44 = 5;
  strcpy((char *)__p, "VoLTE");
  std::vector<std::string>::vector[abi:ne180100](v36, (uint64_t)v37, 4uLL);
  if (v44 < 0)
  {
    operator delete(__p[0]);
    if ((v42 & 0x80000000) == 0)
    {
LABEL_3:
      if ((v40 & 0x80000000) == 0)
        goto LABEL_4;
LABEL_59:
      operator delete(v39[0]);
      if ((v38 & 0x80000000) == 0)
        goto LABEL_5;
LABEL_60:
      operator delete(v37[0]);
      goto LABEL_5;
    }
  }
  else if ((v42 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v41[0]);
  if (v40 < 0)
    goto LABEL_59;
LABEL_4:
  if (v38 < 0)
    goto LABEL_60;
LABEL_5:
  v4 = (unsigned __int8 **)*a1;
  v3 = (unsigned __int8 **)a1[1];
  v34 = 0;
  v35 = 0;
  v33 = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v33, (uint64_t)v36[0], (uint64_t)v36[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v36[1] - (char *)v36[0]) >> 3));
  if (v4 == v3)
    goto LABEL_55;
  v5 = (void **)v33;
  v6 = v34;
  if (v33 == v34)
    goto LABEL_28;
  while (2)
  {
    v7 = *((_BYTE *)v4 + 23);
    if (v7 >= 0)
      v8 = (unsigned __int8 *)*((unsigned __int8 *)v4 + 23);
    else
      v8 = v4[1];
    if (v7 >= 0)
      v9 = (unsigned __int8 *)v4;
    else
      v9 = *v4;
    v10 = v5;
    while (1)
    {
      v11 = *((unsigned __int8 *)v10 + 23);
      if ((v11 & 0x80u) == 0)
        v12 = (unsigned __int8 *)*((unsigned __int8 *)v10 + 23);
      else
        v12 = (unsigned __int8 *)v10[1];
      if (v12 != v8)
        goto LABEL_15;
      if ((v11 & 0x80) == 0)
        break;
      if (!memcmp(*v10, v9, (size_t)v10[1]))
        goto LABEL_25;
LABEL_15:
      v10 += 3;
      if (v10 == v6)
        goto LABEL_28;
    }
    if (*((_BYTE *)v10 + 23))
    {
      v13 = 0;
      while (*((unsigned __int8 *)v10 + v13) == v9[v13])
      {
        if (v11 == ++v13)
          goto LABEL_25;
      }
      goto LABEL_15;
    }
LABEL_25:
    if (v10 != v6)
    {
      v4 += 3;
      if (v4 == v3)
      {
        v15 = v3;
        v26 = (unsigned __int8 **)a1[1];
        if (v3 == v26)
          goto LABEL_71;
        goto LABEL_67;
      }
      continue;
    }
    break;
  }
LABEL_28:
  if (v4 == v3)
  {
    v15 = v4;
LABEL_64:
    v26 = (unsigned __int8 **)a1[1];
    if (v15 == v26)
      goto LABEL_71;
  }
  else
  {
    v14 = (const void **)(v4 + 3);
    if (v4 + 3 != v3)
    {
      v15 = v4;
      do
      {
        v17 = v14;
        v18 = (void **)v33;
        v19 = v34;
        if (v33 != v34)
        {
          v20 = *((char *)v4 + 47);
          if (v20 >= 0)
            v21 = (unsigned __int8 *)*((unsigned __int8 *)v4 + 47);
          else
            v21 = v4[4];
          if (v20 >= 0)
            v22 = (unsigned __int8 *)v14;
          else
            v22 = (unsigned __int8 *)*v14;
          while (1)
          {
            v23 = *((unsigned __int8 *)v18 + 23);
            if ((v23 & 0x80u) == 0)
              v24 = (unsigned __int8 *)*((unsigned __int8 *)v18 + 23);
            else
              v24 = (unsigned __int8 *)v18[1];
            if (v24 == v21)
            {
              if ((v23 & 0x80) != 0)
              {
                if (!memcmp(*v18, v22, (size_t)v18[1]))
                  break;
              }
              else
              {
                if (!*((_BYTE *)v18 + 23))
                  break;
                v25 = 0;
                while (*((unsigned __int8 *)v18 + v25) == v22[v25])
                {
                  if (v23 == ++v25)
                    goto LABEL_51;
                }
              }
            }
            v18 += 3;
            if (v18 == v19)
              goto LABEL_32;
          }
        }
LABEL_51:
        if (v18 != v19)
        {
          if (*((char *)v15 + 23) < 0)
            operator delete(*v15);
          v16 = *(_OWORD *)v17;
          v15[2] = (unsigned __int8 *)v17[2];
          *(_OWORD *)v15 = v16;
          v15 += 3;
          *((_BYTE *)v4 + 47) = 0;
          *(_BYTE *)v17 = 0;
        }
LABEL_32:
        v14 = v17 + 3;
        v4 = (unsigned __int8 **)v17;
      }
      while (v17 + 3 != (const void **)v3);
      goto LABEL_64;
    }
LABEL_55:
    v15 = v4;
    v26 = (unsigned __int8 **)a1[1];
    if (v4 == v26)
      goto LABEL_71;
  }
LABEL_67:
  while (v26 != v15)
  {
    if (*((char *)v26 - 1) < 0)
      operator delete(*(v26 - 3));
    v26 -= 3;
  }
  a1[1] = v15;
LABEL_71:
  v27 = (void **)v33;
  if (v33)
  {
    v28 = v34;
    v29 = v33;
    if (v34 != v33)
    {
      do
      {
        if (*((char *)v28 - 1) < 0)
          operator delete(*(v28 - 3));
        v28 -= 3;
      }
      while (v28 != v27);
      v29 = v33;
    }
    v34 = v27;
    operator delete(v29);
  }
  v30 = (void **)v36[0];
  if (v36[0])
  {
    v31 = (void **)v36[1];
    v32 = v36[0];
    if (v36[1] != v36[0])
    {
      do
      {
        if (*((char *)v31 - 1) < 0)
          operator delete(*(v31 - 3));
        v31 -= 3;
      }
      while (v31 != v30);
      v32 = v36[0];
    }
    v36[1] = v30;
    operator delete(v32);
  }
}

void sub_1A34B0934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void **v5;
  va_list va;

  va_start(va, a5);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  std::vector<std::string>::~vector[abi:ne180100](v5);
  _Unwind_Resume(a1);
}

void sub_1A34B0950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  void **v39;

  if (a39 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_3:
    if (a27 < 0)
      goto LABEL_4;
    goto LABEL_8;
  }
  operator delete(a28);
  if (a27 < 0)
  {
LABEL_4:
    operator delete(a22);
    if ((a21 & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_9;
  }
LABEL_8:
  if ((a21 & 0x80000000) == 0)
  {
LABEL_5:
    std::vector<std::string>::~vector[abi:ne180100](v39);
    _Unwind_Resume(a1);
  }
LABEL_9:
  operator delete(a16);
  std::vector<std::string>::~vector[abi:ne180100](v39);
  _Unwind_Resume(a1);
}

BOOL abm::CellularLoggingEUR::handleAppCrash(abm::CellularLoggingEUR *a1, std::string::size_type a2)
{
  std::string *v4;
  __int128 v5;
  size_t v6;
  std::string *v7;
  __int128 v8;
  void **v9;
  std::string::size_type v10;
  std::string *v11;
  _BOOL8 Dir;
  _BOOL8 v13;
  NSObject *v14;
  NSObject *v15;
  std::string::size_type v16;
  std::string *v17;
  void *__p[2];
  unsigned __int8 v20;
  std::string v21;
  std::string v22;
  _QWORD *v23[3];
  std::string v24;
  std::string v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  abm::CellularLoggingEUR::stopReader(a1, 1);
  memset(v23, 170, sizeof(v23));
  Timestamp::Timestamp((Timestamp *)v23);
  *((_BYTE *)&v21.__r_.__value_.__s + 23) = 1;
  LOWORD(v21.__r_.__value_.__l.__data_) = 47;
  v4 = std::string::insert(&v21, 0, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging", 0x47uLL);
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  v6 = strlen(abm::trace::kLogDirPrefix[0]);
  v7 = std::string::append(&v24, abm::trace::kLogDirPrefix[0], v6);
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  Timestamp::asString((uint64_t)v23, 0, 9, __p);
  if ((v20 & 0x80u) == 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v10 = v20;
  else
    v10 = (std::string::size_type)__p[1];
  v11 = std::string::append(&v25, (const std::string::value_type *)v9, v10);
  v22 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if ((char)v20 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_10;
LABEL_19:
      operator delete(v24.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_11;
      goto LABEL_20;
    }
  }
  else if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_19;
LABEL_10:
  if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_11;
LABEL_20:
  operator delete(v21.__r_.__value_.__l.__data_);
LABEL_11:
  v25.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
  *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A357F760;
  strcpy(v25.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging");
  Dir = support::fs::createDir((const char *)&v25, 0x1EDu, 1);
  v13 = Dir;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v25.__r_.__value_.__l.__data_);
    if (v13)
      goto LABEL_13;
LABEL_22:
    v15 = *((_QWORD *)a1 + 5);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)"/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging";
      _os_log_error_impl(&dword_1A343C000, v15, OS_LOG_TYPE_ERROR, "Failed to create directory %s", (uint8_t *)&v25, 0xCu);
    }
    goto LABEL_32;
  }
  if (!Dir)
    goto LABEL_22;
LABEL_13:
  memset(&v25, 170, sizeof(v25));
  v24.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x38uLL);
  *(_OWORD *)&v24.__r_.__value_.__r.__words[1] = xmmword_1A3580B20;
  strcpy(v24.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CellularLogging");
  support::fs::moveDirUnique((const char *)&v24, (uint64_t)&v22, (uint64_t)&v25);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24.__r_.__value_.__l.__data_);
    v14 = *((_QWORD *)a1 + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
LABEL_15:
      if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_32;
      goto LABEL_31;
    }
  }
  else
  {
    v14 = *((_QWORD *)a1 + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_15;
  }
  if (*(char *)(a2 + 23) >= 0)
    v16 = a2;
  else
    v16 = *(_QWORD *)a2;
  v17 = &v25;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v17 = (std::string *)v25.__r_.__value_.__r.__words[0];
  LODWORD(v24.__r_.__value_.__l.__data_) = 136315394;
  *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = v16;
  WORD2(v24.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&v24.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
  _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#N Detected %s crash, moving logs to %s", (uint8_t *)&v24, 0x16u);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
LABEL_31:
    operator delete(v25.__r_.__value_.__l.__data_);
LABEL_32:
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v23, v23[1]);
  return v13;
}

void sub_1A34B0D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,_QWORD *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a27, a28);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::snapshot(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  xpc_object_t object;
  uint8_t buf[15];
  char v7;

  v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Telephony log snapshot not supported", buf, 2u);
  }
  object = xpc_null_create();
  v7 = 0;
  v4 = *(_QWORD *)(a2 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, xpc_object_t *))(*(_QWORD *)v4 + 48))(v4, &v7, &object);
  xpc_release(object);
}

void sub_1A34B0EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig()
{
  return ctu::LoggerCommonBase::setInheritedLogLevel();
}

double ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName@<D0>(uint64_t a1@<X8>)
{
  char *v2;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v2;
  *(_OWORD *)(a1 + 8) = xmmword_1A357F830;
  strcpy(v2, "carriercellularlogging.modem");
  return *(double *)"larlogging.modem";
}

uint64_t ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return ctu::LoggerCommonBase::getLocalLogLevel((ctu::LoggerCommonBase *)(a1 + 8));
}

char *std::vector<std::string>::__push_back_slow_path<std::string>(void **a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  void **v11;
  void **v12;
  __int128 v13;
  void **v14;

  v3 = 0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) > v4)
    v4 = 0x5555555555555556 * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3);
  if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) >= 0x555555555555555)
    v6 = 0xAAAAAAAAAAAAAAALL;
  else
    v6 = v4;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v7 = (char *)operator new(24 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = &v7[24 * v3];
  v9 = &v7[24 * v6];
  *(_OWORD *)v8 = *(_OWORD *)a2;
  *((_QWORD *)v8 + 2) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v10 = v8 + 24;
  v11 = (void **)*a1;
  v12 = (void **)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }
  else
  {
    do
    {
      v13 = *(_OWORD *)(v12 - 3);
      *((_QWORD *)v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 24) = v13;
      v8 -= 24;
      *(v12 - 2) = 0;
      *(v12 - 1) = 0;
      *(v12 - 3) = 0;
      v12 -= 3;
    }
    while (v12 != v11);
    v12 = (void **)*a1;
    v14 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    while (v14 != v12)
    {
      if (*((char *)v14 - 1) < 0)
        operator delete(*(v14 - 3));
      v14 -= 3;
    }
  }
  if (v12)
    operator delete(v12);
  return v10;
}

void std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v8;
  uint64_t v9;
  std::string *v10;
  uint64_t v11;

  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL)
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    v8 = (char *)operator new(24 * a4);
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[24 * a4];
    if (a2 != a3)
    {
      v9 = 0;
      do
      {
        v10 = (std::string *)&v8[v9];
        v11 = a2 + v9;
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)v11, *(_QWORD *)(v11 + 8));
        }
        else
        {
          *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)v11;
          v10->__r_.__value_.__r.__words[2] = *(_QWORD *)(v11 + 16);
        }
        v9 += 24;
      }
      while (a2 + v9 != a3);
      v8 += v9;
    }
    a1[1] = v8;
  }
}

void sub_1A34B1198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::__exception_guard_exceptions<std::vector<std::string>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void sub_1A34B11AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  for (; v11; v11 -= 24)
  {
    if (*(char *)(v10 + v11 - 1) < 0)
      operator delete(*(void **)(v10 + v11 - 24));
  }
  *(_QWORD *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<std::string>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<abm::CellularLoggingEUR,std::allocator<abm::CellularLoggingEUR>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, NSObject **a3@<X3>, _QWORD *a4@<X8>)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count_vtbl *v10;
  std::__shared_weak_count *shared_owners;
  unint64_t v12;
  unint64_t *p_shared_weak_owners;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;

  v8 = (std::__shared_weak_count *)operator new(0x118uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09518;
  v10 = (std::__shared_weak_count_vtbl *)&v8[1];
  std::construct_at[abi:ne180100]<abm::CellularLoggingEUR,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingEUR*>((uint64_t)&v8[1], a1, a2, a3);
  *a4 = v8 + 1;
  a4[1] = v8;
  shared_owners = (std::__shared_weak_count *)v8[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
      return;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v14 = __ldxr(p_shared_weak_owners);
    while (__stxr(v14 + 1, p_shared_weak_owners));
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    v16 = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
  }
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1A34B1314(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<abm::CellularLoggingEUR>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09518;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::CellularLoggingEUR>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09518;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<abm::CellularLoggingEUR>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::construct_at[abi:ne180100]<abm::CellularLoggingEUR,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingEUR*>(uint64_t a1, uint64_t *a2, uint64_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  NSObject *v11;
  unint64_t *v12;
  unint64_t v13;
  dispatch_object_t v15;
  uint64_t v16[2];
  uint64_t v17[2];

  v5 = (std::__shared_weak_count *)a2[1];
  v17[0] = *a2;
  v17[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a3[1];
  v16[0] = *a3;
  v16[1] = (uint64_t)v8;
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  v11 = *a4;
  v15 = v11;
  if (v11)
    dispatch_retain(v11);
  abm::CellularLoggingEUR::CellularLoggingEUR(a1, v17, v16, &v15);
  if (v11)
    dispatch_release(v11);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  if (!v5)
    return a1;
  v12 = (unint64_t *)&v5->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (v13)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void sub_1A34B1468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  std::__shared_weak_count *v13;
  NSObject *v14;

  if (v14)
  {
    dispatch_release(v14);
    if (!v13)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
      _Unwind_Resume(a1);
    }
  }
  else if (!v13)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v13);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ETLDIAGGUIDParameter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E4A09568;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ETLDIAGGUIDParameter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E4A09568;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<ETLDIAGGUIDParameter>::__on_zero_shared(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[4];
  if (v4)
  {
    a1[5] = v4;
    operator delete(v4);
  }
}

uint64_t _GLOBAL__sub_I_CellularLoggingEUR_mm()
{
  uint64_t result;

  result = ETLDIAGLoggingGetDefaultView();
  dword_1ED114A2C = result;
  return result;
}

double CoredumpTrace::createInternal@<D0>(_OWORD *a1@<X8>)
{
  CoredumpTrace *v3;
  double result;
  __int128 v5;

  v3 = (CoredumpTrace *)operator new(0xF0uLL);
  CoredumpTrace::CoredumpTrace(v3);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<CoredumpTrace>::shared_ptr[abi:ne180100]<CoredumpTrace,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  result = *(double *)&v5;
  *a1 = v5;
  return result;
}

void sub_1A34B15AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A34B15C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void CoredumpTrace::CoredumpTrace(CoredumpTrace *this)
{
  capabilities::trace *v2;
  uint64_t v3;
  void *__p[2];
  char v5;

  v5 = 14;
  strcpy((char *)__p, "trace.coredump");
  v2 = (capabilities::trace *)Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v5 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_1E4A095E0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 168) = capabilities::trace::allowed(v2);
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  v3 = (*(uint64_t (**)(CoredumpTrace *))(*(_QWORD *)this + 160))(this);
  if (*(char *)(v3 + 23) < 0)
    v3 = *(_QWORD *)v3;
  *((_QWORD *)this + 28) = dispatch_queue_create((const char *)v3, 0);
  *((_BYTE *)this + 232) = 0;
}

void sub_1A34B16A4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  if (*(char *)(v1 + 223) < 0)
    operator delete(*(void **)(v1 + 200));
  if (*(char *)(v1 + 199) < 0)
    operator delete(*v3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2);
  Trace::~Trace((Trace *)v1);
  _Unwind_Resume(a1);
}

void sub_1A34B16E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const char *CoredumpTrace::getName(CoredumpTrace *this)
{
  return "trace.coredump";
}

void CoredumpTrace::getSettingPrefix(char *a1@<X8>)
{
  a1[23] = 10;
  strcpy(a1, "CoreDump::");
}

BOOL CoredumpTrace::init(uint64_t a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  _QWORD v16[6];
  std::string __p;
  uint64_t v18;
  std::__shared_weak_count *v19;
  dispatch_object_t object;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;
  _QWORD *v25;
  _QWORD block[6];

  v21 = 0;
  v22 = &v21;
  v23 = 0x2020000000;
  v24 = 0;
  v7 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3321888768;
  v16[2] = ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke;
  v16[3] = &unk_1E4A096E8;
  v16[4] = &v21;
  v16[5] = a1;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  v8 = (std::__shared_weak_count *)a3[1];
  v18 = *a3;
  v19 = v8;
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  v11 = *a4;
  object = v11;
  if (v11)
    dispatch_retain(v11);
  v25 = v16;
  block[0] = v7;
  block[1] = 3221225472;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2;
  block[3] = &__block_descriptor_48_e5_v8__0l;
  block[4] = a1 + 72;
  block[5] = &v25;
  v12 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(a1 + 96))
  {
    dispatch_async_and_wait(v12, block);
    v13 = *((unsigned __int8 *)v22 + 24);
    v14 = object;
    if (!object)
      goto LABEL_12;
    goto LABEL_11;
  }
  dispatch_sync(v12, block);
  v13 = *((unsigned __int8 *)v22 + 24);
  v14 = object;
  if (object)
LABEL_11:
    dispatch_release(v14);
LABEL_12:
  if (v19)
    std::__shared_weak_count::__release_weak(v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  _Block_object_dispose(&v21, 8);
  return v13 != 0;
}

void sub_1A34B18C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  NSObject *v6;
  uint64_t v7;
  char v8;
  CommandDriverFactory *v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *size;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  __int128 v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  void *v38;
  NSObject *v39;
  uint64_t v40;
  void *v41;
  dispatch_object_t v42;
  _QWORD aBlock[6];
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  void *__p[2];
  char v48;
  dispatch_object_t object;
  uint64_t v50;
  std::__shared_weak_count *v51;
  std::string v52;
  std::string v53;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(char *)(a1 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(&v52, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
    v3 = *(std::__shared_weak_count **)(a1 + 80);
    v50 = *(_QWORD *)(a1 + 72);
    v51 = v3;
    if (!v3)
      goto LABEL_7;
  }
  else
  {
    v52 = *(std::string *)(a1 + 48);
    v3 = *(std::__shared_weak_count **)(a1 + 80);
    v50 = *(_QWORD *)(a1 + 72);
    v51 = v3;
    if (!v3)
      goto LABEL_7;
  }
  p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
  do
    v5 = __ldxr(p_shared_weak_owners);
  while (__stxr(v5 + 1, p_shared_weak_owners));
LABEL_7:
  v6 = *(NSObject **)(a1 + 88);
  object = v6;
  if (v6)
    dispatch_retain(v6);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Trace::init(v2, (void **)&v52.__r_.__value_.__l.__data_, &v50, &object);
  if (object)
    dispatch_release(object);
  if (v51)
    std::__shared_weak_count::__release_weak(v51);
  if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v7 + 24))
      goto LABEL_15;
LABEL_19:
    *(_BYTE *)(v7 + 24) = 0;
    v9 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    v10 = off_1ED114670;
    if (off_1ED114670)
      goto LABEL_37;
    goto LABEL_25;
  }
  operator delete(v52.__r_.__value_.__l.__data_);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v7 + 24))
    goto LABEL_19;
LABEL_15:
  v48 = 7;
  strcpy((char *)__p, "Enabled");
  memset(&v53, 0, sizeof(v53));
  if (prop::coredump::get((char *)__p, (uint64_t)&v53))
  {
    v8 = util::convert<BOOL>(&v53, (BOOL *)(v2 + 168), 0);
    if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_23;
  }
  else
  {
    v8 = 0;
    if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_23;
  }
  operator delete(v53.__r_.__value_.__l.__data_);
LABEL_23:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v8;
  if (v48 < 0)
  {
    operator delete(__p[0]);
    v9 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    v10 = off_1ED114670;
    if (off_1ED114670)
      goto LABEL_37;
  }
  else
  {
    v9 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    v10 = off_1ED114670;
    if (off_1ED114670)
      goto LABEL_37;
  }
LABEL_25:
  CommandDriverFactory::create_default_global(v9);
  v11 = *(_OWORD *)&v53.__r_.__value_.__l.__data_;
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = 0uLL;
  v12 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
  off_1ED114670 = v11;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  size = (std::__shared_weak_count *)v53.__r_.__value_.__l.__size_;
  if (v53.__r_.__value_.__l.__size_)
  {
    v16 = (unint64_t *)(v53.__r_.__value_.__l.__size_ + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  v10 = off_1ED114670;
LABEL_37:
  v45 = v10;
  v46 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
  if (*(&off_1ED114670 + 1))
  {
    v18 = (unint64_t *)(*(&off_1ED114670 + 1) + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v10 + 136))(__p, v10);
  v20 = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  v21 = *(std::__shared_weak_count **)(v2 + 160);
  *(_OWORD *)(v2 + 152) = v20;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v25 = (unint64_t *)((char *)__p[1] + 8);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (v46)
  {
    v27 = &v46->__shared_owners_;
    do
      v28 = __ldaxr((unint64_t *)v27);
    while (__stlxr(v28 - 1, (unint64_t *)v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  v29 = *(std::__shared_weak_count **)(v2 + 80);
  if (!v29 || (v30 = *(_QWORD *)(v2 + 72), (v31 = std::__shared_weak_count::lock(v29)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v32 = v31;
  v33 = (unint64_t *)&v31->__shared_weak_owners_;
  do
    v34 = __ldxr(v33);
  while (__stxr(v34 + 1, v33));
  v35 = (unint64_t *)&v31->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v32);
  }
  memset(&v53, 170, 16);
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke_2;
  aBlock[3] = &__block_descriptor_56_e8_40c29_ZTSNSt3__18weak_ptrI5TraceEE_e5_v8__0l;
  aBlock[4] = v2;
  aBlock[5] = v30;
  v44 = v32;
  do
    v37 = __ldxr(v33);
  while (__stxr(v37 + 1, v33));
  v38 = _Block_copy(aBlock);
  v39 = *(NSObject **)(v2 + 88);
  if (v39)
    dispatch_retain(*(dispatch_object_t *)(v2 + 88));
  v53.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
  v53.__r_.__value_.__l.__size_ = (std::string::size_type)v39;
  v40 = *(_QWORD *)(v2 + 152);
  if (v38)
  {
    v41 = _Block_copy(v38);
    v42 = v39;
    if (!v39)
      goto LABEL_70;
    goto LABEL_69;
  }
  v41 = 0;
  v42 = v39;
  if (v39)
LABEL_69:
    dispatch_retain(v39);
LABEL_70:
  (*(void (**)(uint64_t, void **))(*(_QWORD *)v40 + 104))(v40, &v41);
  if (v42)
    dispatch_release(v42);
  if (v41)
    _Block_release(v41);
  if (v39)
    dispatch_release(v39);
  if (v38)
    _Block_release(v38);
  if (v44)
    std::__shared_weak_count::__release_weak(v44);
  std::__shared_weak_count::__release_weak(v32);
}

void sub_1A34B1D94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,dispatch_object_t object,uint64_t a28,std::__shared_weak_count *a29)
{
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  _Unwind_Resume(a1);
}

void ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke_2(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  CoredumpTrace *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = (CoredumpTrace *)a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (a1[5])
        CoredumpTrace::processCrashReason_sync(v3);
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_1A34B1F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void CoredumpTrace::processCrashReason_sync(CoredumpTrace *this)
{
  NSObject *v2;
  const char *v3;
  xpc_object_t object;

  v2 = *((_QWORD *)this + 18);
  if (v2)
  {
    dispatch_retain(*((dispatch_object_t *)this + 18));
    dispatch_group_enter(v2);
  }
  if (*((_BYTE *)this + 232))
  {
    *((_BYTE *)this + 232) = 0;
    CoredumpTrace::createScratchPath_sync(this);
    if (CoredumpTrace::fetchPostBootCrashReport_sync((int **)this))
    {
      object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(xpc_object_t *__return_ptr, CoredumpTrace *))(*(_QWORD *)this + 192))(&object, this);
      CoredumpTrace::storeCrashReason_sync((NSObject **)this, (const xpc::dict *)&object);
      CoredumpTrace::submitCrashReason_sync(this, &object);
      CoredumpTrace::updateAnalyticsEvent_sync(this, &object);
      xpc_release(object);
    }
    v3 = (char *)this + 176;
    support::fs::removeDirContents(v3, 0);
    support::fs::removeDir(v3);
  }
  if (v2)
  {
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

void sub_1A34B2000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  NSObject *v10;

  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  _Unwind_Resume(exception_object);
}

void CoredumpTrace::abort(uint64_t a1, const void *a2, ctu **a3)
{
  xpc_object_t v4;
  uint64_t v5;
  xpc_object_t value;
  const char *v7;
  char v8;
  xpc_object_t *v9;
  int v10;
  NSObject *v11;
  xpc_object_t v12;
  xpc_object_t object[3];

  ctu::cf_to_xpc(*a3, a2);
  v4 = object[0];
  v5 = MEMORY[0x1E0C812F8];
  if (object[0] && MEMORY[0x1A85902BC](object[0]) == v5)
    xpc_retain(object[0]);
  else
    v4 = xpc_null_create();
  xpc_release(object[0]);
  if (MEMORY[0x1A85902BC](v4) == v5)
  {
    memset(object, 170, sizeof(object));
    value = xpc_dictionary_get_value(v4, (const char *)*MEMORY[0x1E0CFB8D0]);
    v12 = value;
    if (value)
      xpc_retain(value);
    else
      v12 = xpc_null_create();
    xpc::dyn_cast_or_default();
    xpc_release(v12);
    v7 = (const char *)*MEMORY[0x1E0CFBF98];
    v8 = HIBYTE(object[2]);
    if (SHIBYTE(object[2]) < 0)
    {
      v9 = (xpc_object_t *)object[0];
      if (!strcasecmp(v7, (const char *)object[0])
        || !strcasecmp((const char *)*MEMORY[0x1E0CFC000], (const char *)object[0]))
      {
LABEL_21:
        *(_BYTE *)(a1 + 232) = 1;
        v11 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          goto LABEL_18;
        goto LABEL_17;
      }
    }
    else
    {
      if (!strcasecmp(v7, (const char *)object))
        goto LABEL_21;
      v9 = object;
      if (!strcasecmp((const char *)*MEMORY[0x1E0CFC000], (const char *)object))
        goto LABEL_21;
    }
    v10 = strcasecmp((const char *)*MEMORY[0x1E0CFBEA0], (const char *)v9);
    *(_BYTE *)(a1 + 232) = v10 == 0;
    if (v10 || (v11 = *(NSObject **)(a1 + 40), !os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)))
    {
LABEL_18:
      if (v8 < 0)
        operator delete(object[0]);
      goto LABEL_20;
    }
LABEL_17:
    LOWORD(v12) = 0;
    _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I Baseband crash reason will be parsed", (uint8_t *)&v12, 2u);
    v8 = HIBYTE(object[2]);
    goto LABEL_18;
  }
LABEL_20:
  xpc_release(v4);
}

void sub_1A34B2228(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  void *v9;

  xpc_release(object);
  xpc_release(v9);
  _Unwind_Resume(a1);
}

void CoredumpTrace::snapshot(_QWORD *a1, dispatch_object_t *a2, const __CFDictionary **a3)
{
  NSObject *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  void *v15;
  void **v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  NSObject *v26;
  unint64_t v27;
  NSObject *v28;
  const __CFDictionary *v29;
  _QWORD v30[5];
  dispatch_group_t group;
  uint64_t v32;
  std::__shared_weak_count *v33;
  dispatch_object_t object;
  CFTypeRef cf;
  void *__p;
  __int128 v37;
  void *v38[3];
  _QWORD v39[2];
  _QWORD v40[2];

  v6 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v6);
  }
  v8 = a1[9];
  v7 = (std::__shared_weak_count *)a1[10];
  if (!v7 || (v9 = std::__shared_weak_count::lock(v7)) == 0)
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v10 = v9;
  p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
  do
    v12 = __ldxr(p_shared_weak_owners);
  while (__stxr(v12 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v10);
  }
  v39[0] = 0xAAAAAAAAAAAAAAAALL;
  v39[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v39, *a3);
  memset(v38, 170, sizeof(v38));
  __p = operator new(0x28uLL);
  v37 = xmmword_1A357F480;
  strcpy((char *)__p, "kCollectTelephonyLogsWithCoredump");
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v40, "kKeyTraceAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](v40);
  operator delete(__p);
  v15 = (void *)HIBYTE(v38[2]);
  if (SHIBYTE(v38[2]) < 0)
    v15 = v38[1];
  if (v15 != (void *)33)
    goto LABEL_31;
  v16 = v38;
  if (SHIBYTE(v38[2]) < 0)
    v16 = (void **)v38[0];
  v17 = *v16;
  v18 = v16[1];
  v19 = v16[2];
  v20 = v16[3];
  v21 = *((unsigned __int8 *)v16 + 32);
  v22 = v17 == *(void **)"kCollectTelephonyLogsWithCoredump" && v18 == *(void **)"TelephonyLogsWithCoredump";
  v23 = v22 && v19 == *(void **)"yLogsWithCoredump";
  v24 = v23 && v20 == *(void **)"hCoredump";
  if (v24 && v21 == str_67[32])
  {
    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 3321888768;
    v30[2] = ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
    v30[3] = &__block_descriptor_80_e8_40c30_ZTSN8dispatch13group_sessionE48c29_ZTSNSt3__18weak_ptrI5TraceEE64c21_ZTSN8dispatch5groupE72c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_e5_v8__0l;
    v30[4] = a1;
    group = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    v32 = v8;
    v33 = v10;
    do
      v27 = __ldxr(p_shared_weak_owners);
    while (__stxr(v27 + 1, p_shared_weak_owners));
    v28 = *a2;
    object = v28;
    if (v28)
      dispatch_retain(v28);
    v29 = *a3;
    cf = v29;
    if (v29)
      CFRetain(v29);
    ctu::SharedSynchronizable<Trace>::execute_wrapped(a1 + 9, (uint64_t)v30);
    if (cf)
      CFRelease(cf);
    if (object)
      dispatch_release(object);
    if (v33)
      std::__shared_weak_count::__release_weak(v33);
    if (group)
    {
      dispatch_group_leave(group);
      if (group)
        dispatch_release(group);
    }
  }
  else
  {
LABEL_31:
    v26 = a1[5];
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl(&dword_1A343C000, v26, OS_LOG_TYPE_DEFAULT, "#I Skipping coredump collection", (uint8_t *)&__p, 2u);
    }
  }
  if (SHIBYTE(v38[2]) < 0)
    operator delete(v38[0]);
  MEMORY[0x1A858F2D8](v39);
  std::__shared_weak_count::__release_weak(v10);
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
}

void ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  NSObject *global_queue;
  NSObject *v8;
  NSObject *v9;
  const void *v10;
  NSObject *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD block[5];
  dispatch_group_t v15;
  dispatch_group_t group;
  dispatch_object_t object;
  CFTypeRef cf;
  uint8_t buf[16];
  std::__shared_weak_count *v21;

  v2 = a1[4];
  v3 = *(NSObject **)(v2 + 144);
  if (v3)
  {
    dispatch_retain(*(dispatch_object_t *)(v2 + 144));
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    v5 = std::__shared_weak_count::lock(v4);
    v21 = v5;
    if (v5)
    {
      v6 = v5;
      if (a1[6])
      {
        if (*(_BYTE *)(v2 + 168)
          || (capabilities::trace::supportsCoredumpCrashReasonOnCustomerBuild((capabilities::trace *)v5) & 1) != 0)
        {
          global_queue = dispatch_get_global_queue(0, 0);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3321888768;
          block[2] = ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_5;
          block[3] = &__block_descriptor_72_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c21_ZTSN8dispatch5groupE64c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_e5_v8__0l;
          v8 = a1[5];
          block[4] = v2;
          v15 = v8;
          if (v8)
          {
            dispatch_retain(v8);
            dispatch_group_enter(v8);
          }
          group = v3;
          if (v3)
          {
            dispatch_retain(v3);
            dispatch_group_enter(v3);
          }
          v9 = a1[8];
          object = v9;
          if (v9)
            dispatch_retain(v9);
          v10 = (const void *)a1[9];
          cf = v10;
          if (v10)
            CFRetain(v10);
          dispatch_async(global_queue, block);
          if (cf)
            CFRelease(cf);
          if (object)
            dispatch_release(object);
          if (group)
          {
            dispatch_group_leave(group);
            if (group)
              dispatch_release(group);
          }
          if (v15)
          {
            dispatch_group_leave(v15);
            if (v15)
              dispatch_release(v15);
          }
        }
        else
        {
          v11 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I skipping coredump collection (disabled)", buf, 2u);
          }
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
}

void sub_1A34B27B4(_Unwind_Exception *a1)
{
  NSObject *v1;
  uint64_t v2;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 64);
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_5(_QWORD *a1)
{
  _QWORD *v2;
  NSObject *v3;
  const void *v4;
  NSObject *v5;
  uint8_t v6[16];
  CFTypeRef cf;
  dispatch_object_t object;

  v2 = (_QWORD *)a1[4];
  v3 = a1[7];
  object = v3;
  if (v3)
    dispatch_retain(v3);
  v4 = (const void *)a1[8];
  cf = v4;
  if (v4)
    CFRetain(v4);
  (*(void (**)(_QWORD *, dispatch_object_t *, CFTypeRef *))(*v2 + 168))(v2, &object, &cf);
  if (cf)
    CFRelease(cf);
  if (object)
    dispatch_release(object);
  v5 = v2[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I snapshot complete", v6, 2u);
  }
}

void sub_1A34B28A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, dispatch_object_t object)
{
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a11);
  if (object)
    dispatch_release(object);
  _Unwind_Resume(a1);
}

CFTypeRef __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c21_ZTSN8dispatch5groupE64c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(_QWORD *a1, _QWORD *a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  CFTypeRef result;

  v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = a1[5];
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = a2[6];
  a1[6] = v6;
  if (v6)
  {
    dispatch_retain(v6);
    v7 = a1[6];
    if (v7)
      dispatch_group_enter(v7);
  }
  v8 = a2[7];
  a1[7] = v8;
  if (v8)
    dispatch_retain(v8);
  result = (CFTypeRef)a2[8];
  a1[8] = result;
  if (result)
    return CFRetain(result);
  return result;
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c21_ZTSN8dispatch5groupE64c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(_QWORD *a1)
{
  const void *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;

  v2 = (const void *)a1[8];
  if (v2)
    CFRelease(v2);
  v3 = a1[7];
  if (v3)
    dispatch_release(v3);
  v4 = a1[6];
  if (v4)
  {
    dispatch_group_leave(v4);
    v5 = a1[6];
    if (v5)
      dispatch_release(v5);
  }
  v6 = a1[5];
  if (v6)
  {
    dispatch_group_leave(v6);
    v7 = a1[5];
    if (v7)
      dispatch_release(v7);
  }
}

void CoredumpTrace::dumpState(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 168))
      v3 = "True";
    else
      v3 = "False";
    v4 = 136315138;
    v5 = v3;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Enabled: %s", (uint8_t *)&v4, 0xCu);
  }
}

BOOL CoredumpTrace::setProperty(capabilities::trace *a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  _BOOL8 v10;
  NSObject *v11;
  NSObject *v12;
  _QWORD v14[6];
  dispatch_group_t group;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;
  _QWORD *v22;
  _QWORD block[6];

  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if ((capabilities::trace::allowed(a1) & 1) != 0)
  {
    v18 = 0;
    v19 = &v18;
    v20 = 0x2020000000;
    v21 = 0;
    v8 = MEMORY[0x1E0C809B0];
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3321888768;
    v14[2] = ___ZN13CoredumpTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke;
    v14[3] = &unk_1E4A09780;
    v14[5] = a1;
    group = v7;
    if (v7)
    {
      dispatch_retain(v7);
      dispatch_group_enter(v7);
    }
    v16 = a3;
    v17 = a4;
    v14[4] = &v18;
    v22 = v14;
    block[0] = v8;
    block[1] = 3221225472;
    block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2;
    block[3] = &__block_descriptor_48_e5_v8__0l;
    block[4] = (char *)a1 + 72;
    block[5] = &v22;
    v9 = *((_QWORD *)a1 + 11);
    if (*((_QWORD *)a1 + 12))
    {
      dispatch_async_and_wait(v9, block);
      v10 = *((_BYTE *)v19 + 24) != 0;
      v11 = group;
      if (!group)
        goto LABEL_14;
    }
    else
    {
      dispatch_sync(v9, block);
      v10 = *((_BYTE *)v19 + 24) != 0;
      v11 = group;
      if (!group)
      {
LABEL_14:
        _Block_object_dispose(&v18, 8);
        goto LABEL_15;
      }
    }
    dispatch_group_leave(v11);
    if (group)
      dispatch_release(group);
    goto LABEL_14;
  }
  v12 = *((_QWORD *)a1 + 5);
  v10 = 0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Set property is not allowed", (uint8_t *)block, 2u);
    v10 = 0;
  }
LABEL_15:
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v10;
}

void sub_1A34B2C20(_Unwind_Exception *exception_object)
{
  NSObject *v1;

  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN13CoredumpTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  char *v6;
  char v7;
  std::string __p;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 56);
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&__p, "Enabled");
  if (*(char *)(v3 + 23) >= 0)
    v4 = (const char *)v3;
  else
    v4 = *(const char **)v3;
  if (!strcasecmp(v4, (const char *)&__p))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = prop::coredump::set(v3, *(char **)(a1 + 64));
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v5 + 24))
    {
      *(_BYTE *)(v5 + 24) = 0;
      return;
    }
    v6 = *(char **)(a1 + 56);
    memset(&__p, 0, sizeof(__p));
    if (prop::coredump::get(v6, (uint64_t)&__p))
    {
      v7 = util::convert<BOOL>(&__p, (BOOL *)(v2 + 168), 0);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_11;
    }
    else
    {
      v7 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_11:
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v7;
  }
}

void sub_1A34B2D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CoredumpTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[8];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  _QWORD *v12;
  _QWORD block[6];

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN13CoredumpTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke;
  v7[3] = &unk_1E4A097B8;
  v7[6] = a2;
  v7[7] = a3;
  v7[4] = &v8;
  v7[5] = a1;
  v12 = v7;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2;
  block[3] = &__block_descriptor_48_e5_v8__0l;
  block[4] = a1 + 72;
  block[5] = &v12;
  v4 = a1 + 88;
  v3 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(v4 + 8))
    dispatch_async_and_wait(v3, block);
  else
    dispatch_sync(v3, block);
  v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void ___ZN13CoredumpTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  int v5;
  std::string::size_type v6;
  char v7;
  uint64_t v8;
  std::string *p_p;
  std::string::size_type size;
  std::string *v11;
  std::string::size_type v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  std::string __p;
  std::string v17;
  std::string v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v3 = a1[5];
  v2 = a1[6];
  *((_BYTE *)&v17.__r_.__value_.__s + 23) = 5;
  LODWORD(v17.__r_.__value_.__l.__data_) = *(_DWORD *)"State";
  WORD2(v17.__r_.__value_.__r.__words[0]) = str_22_0[4];
  if (*(char *)(v2 + 23) >= 0)
    v4 = (const char *)v2;
  else
    v4 = *(const char **)v2;
  if (!strcasecmp(v4, (const char *)&v17))
  {
    *((_BYTE *)&v18.__r_.__value_.__s + 23) = 9;
    strcpy((char *)&v18, "Enabled: ");
    std::to_string(&v17, *(unsigned __int8 *)(v3 + 168));
    __p = v17;
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v11 = std::string::append(&v18, (const std::string::value_type *)p_p, size);
    v12 = v11->__r_.__value_.__r.__words[0];
    v19[0] = v11->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v19 + 7) = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
    v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    v14 = a1[7];
    if (*(char *)(v14 + 23) < 0)
      operator delete(*(void **)v14);
    v15 = v19[0];
    *(_QWORD *)v14 = v12;
    *(_QWORD *)(v14 + 8) = v15;
    *(_QWORD *)(v14 + 15) = *(_QWORD *)((char *)v19 + 7);
    *(_BYTE *)(v14 + 23) = v13;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_19;
    }
    else if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_19;
    }
    operator delete(v18.__r_.__value_.__l.__data_);
    goto LABEL_19;
  }
  *((_BYTE *)&v17.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v17, "Enabled");
  if (strcasecmp(v4, (const char *)&v17))
    return;
  v5 = *(unsigned __int8 *)(v3 + 168);
  v18.__r_.__value_.__r.__words[0] = 0;
  *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 7) = 0;
  std::to_string(&v17, v5);
  v18.__r_.__value_.__r.__words[0] = v17.__r_.__value_.__l.__size_;
  v6 = v17.__r_.__value_.__r.__words[0];
  *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v17.__r_.__value_.__r.__words[1] + 7);
  v7 = HIBYTE(v17.__r_.__value_.__r.__words[2]);
  v8 = a1[7];
  if (*(char *)(v8 + 23) < 0)
    operator delete(*(void **)v8);
  *(_QWORD *)v8 = v6;
  *(_QWORD *)(v8 + 8) = v18.__r_.__value_.__r.__words[0];
  *(_QWORD *)(v8 + 15) = *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 7);
  *(_BYTE *)(v8 + 23) = v7;
LABEL_19:
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
}

void sub_1A34B305C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    if (*(char *)(*(_QWORD *)(v23 + 56) + 23) < 0)
      JUMPOUT(0x1A34B2F20);
    JUMPOUT(0x1A34B2F28);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A34B30DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((a14 & 0x80000000) == 0)
    JUMPOUT(0x1A34B30A4);
  JUMPOUT(0x1A34B309CLL);
}

BOOL CoredumpTrace::createScratchPath_sync(CoredumpTrace *this)
{
  char *v2;
  size_t v3;
  std::string::size_type v4;
  std::string *p_dst;
  uint64_t v6;
  uint64_t v7;
  std::string *v8;
  std::string::value_type *v9;
  std::string::size_type size;
  std::string::size_type v11;
  void **v12;
  _BOOL8 Dir;
  int v14;
  size_t v15;
  unint64_t v16;
  _BOOL8 v17;
  std::string *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  std::string *v22;
  std::string::size_type v23;
  char v24;
  uint64_t v25;
  NSObject *v26;
  std::string v28;
  std::string::value_type __s[23];
  char v30;
  std::string __dst;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (*((char *)this + 199) < 0)
  {
    **((_BYTE **)this + 22) = 0;
    *((_QWORD *)this + 23) = 0;
  }
  else
  {
    *((_BYTE *)this + 176) = 0;
    *((_BYTE *)this + 199) = 0;
  }
  v2 = abm::trace::kScratchFolder[0];
  v3 = strlen(abm::trace::kScratchFolder[0]);
  if (v3 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v4 = v3;
  if (v3 >= 0x17)
  {
    v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17)
      v6 = v3 | 7;
    v7 = v6 + 1;
    p_dst = (std::string *)operator new(v6 + 1);
    __dst.__r_.__value_.__l.__size_ = v4;
    __dst.__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_11;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v3;
  p_dst = &__dst;
  if (v3)
LABEL_11:
    memmove(p_dst, v2, v4);
  p_dst->__r_.__value_.__s.__data_[v4] = 0;
  v30 = 16;
  strcpy(__s, "CoreDump.scratch");
  v8 = std::string::append(&__dst, __s, 0x10uLL);
  v9 = (std::string::value_type *)v8->__r_.__value_.__r.__words[0];
  size = v8->__r_.__value_.__l.__size_;
  v11 = v8->__r_.__value_.__r.__words[2];
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if ((v30 & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_14;
LABEL_17:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((v11 & 0x8000000000000000) == 0)
      goto LABEL_15;
    goto LABEL_18;
  }
  operator delete(*(void **)__s);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_17;
LABEL_14:
  if ((v11 & 0x8000000000000000) == 0)
  {
LABEL_15:
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)v9;
    v28.__r_.__value_.__l.__size_ = size;
    v28.__r_.__value_.__r.__words[2] = v11;
    goto LABEL_19;
  }
LABEL_18:
  std::string::__init_copy_ctor_external(&v28, v9, size);
LABEL_19:
  support::fs::createUniquePath((const char *)&v28, &__dst);
  v12 = (void **)((char *)this + 176);
  if (*((char *)this + 199) < 0)
    operator delete(*v12);
  *(_OWORD *)v12 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *((_QWORD *)this + 24) = *((_QWORD *)&__dst.__r_.__value_.__l + 2);
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = 0;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
  Dir = support::fs::createDir((const char *)this + 176, 0x1EDu, 1);
  v14 = *((char *)this + 199);
  if (v14 >= 0)
    v15 = *((unsigned __int8 *)this + 199);
  else
    v15 = *((_QWORD *)this + 23);
  v16 = v15 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v15 + 1 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v17 = Dir;
  if (v16 >= 0x17)
  {
    v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v19 = v16 | 7;
    v20 = v19 + 1;
    v18 = (std::string *)operator new(v19 + 1);
    __dst.__r_.__value_.__l.__size_ = v15 + 1;
    __dst.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    v18 = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v15 + 1;
    if (!v15)
      goto LABEL_37;
  }
  if (v14 >= 0)
    v21 = (char *)this + 176;
  else
    v21 = (char *)*v12;
  memmove(v18, v21, v15);
LABEL_37:
  *(_WORD *)((char *)&v18->__r_.__value_.__l.__data_ + v15) = 47;
  v22 = std::string::append(&__dst, "report.json", 0xBuLL);
  v23 = v22->__r_.__value_.__r.__words[0];
  *(_QWORD *)__s = v22->__r_.__value_.__l.__size_;
  *(_QWORD *)&__s[7] = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
  v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  v25 = *(_QWORD *)__s;
  *((_QWORD *)this + 25) = v23;
  *((_QWORD *)this + 26) = v25;
  *(_QWORD *)((char *)this + 215) = *(_QWORD *)&__s[7];
  *((_BYTE *)this + 223) = v24;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (v17)
      goto LABEL_44;
  }
  else if (v17)
  {
    goto LABEL_44;
  }
  v26 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)this + 199) < 0)
      v12 = (void **)*v12;
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
    _os_log_error_impl(&dword_1A343C000, v26, OS_LOG_TYPE_ERROR, "Failed creating coredump scratch path. fScratchFolder=[%s]", (uint8_t *)&__dst, 0xCu);
    if ((v11 & 0x8000000000000000) != 0)
      goto LABEL_45;
    return v17;
  }
LABEL_44:
  if ((v11 & 0x8000000000000000) != 0)
LABEL_45:
    operator delete(v9);
  return v17;
}

void sub_1A34B3474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  uint64_t v29;

  if (v29 < 0)
    operator delete(v28);
  _Unwind_Resume(exception_object);
}

uint64_t CoredumpTrace::fetchPostBootCrashReport_sync(int **this)
{
  const char *v2;
  int v3;
  int v4;
  __int128 v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v9;
  unsigned int v10;
  _DWORD v11[4];
  _BYTE v12[32];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v10 = -1431655766;
  if (AriHost::RegisterClient((AriHost *)"CoreDumpTrace", (const char *)&v10, this[28], (dispatch_queue_s *)0xFFFFFFFFLL))
  {
    v9 = GetOsLogContext()[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      goto LABEL_22;
    *(_DWORD *)v12 = 136315906;
    *(_QWORD *)&v12[4] = "ABM ASSERT";
    *(_WORD *)&v12[12] = 2080;
    *(_QWORD *)&v12[14] = "ARI_RESULT_OK == AriHost::RegisterClient( \"CoreDumpTrace\", &ctxId, *fClientQueue)";
    *(_WORD *)&v12[22] = 2080;
    *(_QWORD *)&v12[24] = "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHe"
                          "lper/Server/Tasks/Wireless/Trace/CoreDump/CoreDumpTrace.mm";
    LOWORD(v13) = 1024;
    *(_DWORD *)((char *)&v13 + 2) = 878;
    goto LABEL_21;
  }
  if (!v10)
  {
    v9 = GetOsLogContext()[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      goto LABEL_22;
    *(_DWORD *)v12 = 136315906;
    *(_QWORD *)&v12[4] = "ABM ASSERT";
    *(_WORD *)&v12[12] = 2080;
    *(_QWORD *)&v12[14] = "ctxId != ARI_AP_SINGLE_MODE_CTX";
    *(_WORD *)&v12[22] = 2080;
    *(_QWORD *)&v12[24] = "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHe"
                          "lper/Server/Tasks/Wireless/Trace/CoreDump/CoreDumpTrace.mm";
    LOWORD(v13) = 1024;
    *(_DWORD *)((char *)&v13 + 2) = 879;
LABEL_21:
    _os_log_fault_impl(&dword_1A343C000, v9, OS_LOG_TYPE_FAULT, "%s (%s): File: %s Line: %d", v12, 0x26u);
LABEL_22:
    __break(1u);
  }
  if (!KTLInitOptions() || !KTLOpenChannel())
    goto LABEL_13;
  v2 = *((char *)this + 223) >= 0 ? (const char *)(this + 25) : (const char *)this[25];
  v3 = open(v2, 1537, 420);
  if (v3 < 0)
    goto LABEL_13;
  v4 = v3;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14 = v5;
  v15 = v5;
  *(_OWORD *)&v12[16] = v5;
  v13 = v5;
  *(_OWORD *)v12 = v5;
  if (TelephonyUtilTransportCreateWithFD())
  {
    KTLSahGetCrashReport();
    v6 = this[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v11[0] = 67109120;
      v11[1] = 0;
      _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Baseband crash report size: %d bytes", (uint8_t *)v11, 8u);
    }
    close(v4);
    TelephonyUtilTransportFree();
    CoredumpTrace::cleanCrashReport_sync((CoredumpTrace *)this);
    KTLCloseChannel();
    AriHost::DeregisterClient((AriHost *)v10);
  }
  else
  {
LABEL_13:
    KTLCloseChannel();
    AriHost::DeregisterClient((AriHost *)v10);
  }
  v7 = this[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v12 = 0;
    _os_log_error_impl(&dword_1A343C000, v7, OS_LOG_TYPE_ERROR, "Error fetching post-boot Baseband crash report", v12, 2u);
  }
  return 0;
}

void CoredumpTrace::storeCrashReason_sync(NSObject **this, const xpc::dict *a2)
{
  NSObject *v4;
  NSObject *v5;
  std::string *p_buf;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _QWORD v13[2];
  std::string v14;
  std::string buf;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (MEMORY[0x1A85902BC](*(_QWORD *)a2) == MEMORY[0x1E0C812F8])
  {
    memset(&buf, 170, sizeof(buf));
    ((void (*)(std::string *__return_ptr, NSObject **, const xpc::dict *))(*this)[25].isa)(&buf, this, a2);
    v5 = this[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      p_buf = &buf;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v16) = 136446210;
      *(_QWORD *)((char *)&v16 + 4) = p_buf;
      _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Baseband crash: %{public}s", (uint8_t *)&v16, 0xCu);
    }
    v7 = (std::__shared_weak_count *)this[17];
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      *((_QWORD *)&v16 + 1) = v8;
      if (v8)
      {
        v9 = v8;
        v10 = (uint64_t)this[16];
        *(_QWORD *)&v16 = v10;
        if (v10)
        {
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&v14, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
          else
            v14 = buf;
          v13[0] = 0;
          v13[1] = 0;
          abm::BasebandTracingTask::setLastCrashReason(v10, (uint64_t)&v14, (uint64_t)v13);
          if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v14.__r_.__value_.__l.__data_);
        }
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf.__r_.__value_.__l.__data_);
  }
  else
  {
    v4 = this[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Invalid Baseband crash dictionary", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_1A34B3A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v23 - 48);
  if (a23 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void CoredumpTrace::submitCrashReason_sync(CoredumpTrace *this, xpc_object_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  xpc_object_t v12;
  uint8_t *v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t value;
  uint8_t *v17;
  unsigned int v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t v21;
  const char *p_object;
  xpc_object_t v23;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  xpc_object_t v27;
  xpc_object_t v28;
  xpc_object_t v29;
  xpc_object_t v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  void *v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  xpc_object_t v37;
  xpc_object_t v38;
  xpc_object_t object;
  std::__shared_weak_count *v40;
  char v41;
  uint8_t buf[32];

  v4 = MEMORY[0x1A85902BC](*a2);
  v5 = MEMORY[0x1E0C812F8];
  v6 = *((_QWORD *)this + 5);
  if (v4 != MEMORY[0x1E0C812F8])
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v6, OS_LOG_TYPE_ERROR, "Invalid Baseband crash dictionary", buf, 2u);
    }
    return;
  }
  if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Submitting AWD of crash info", buf, 2u);
  }
  v7 = xpc_dictionary_create(0, 0, 0);
  if (v7 || (v7 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v7) == v5)
    {
      xpc_retain(v7);
      v8 = v7;
    }
    else
    {
      v8 = xpc_null_create();
    }
  }
  else
  {
    v8 = xpc_null_create();
    v7 = 0;
  }
  xpc_release(v7);
  v9 = xpc_array_create(0, 0);
  if (v9 || (v9 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v9) == MEMORY[0x1E0C812C8])
    {
      xpc_retain(v9);
      v10 = v9;
    }
    else
    {
      v10 = xpc_null_create();
    }
  }
  else
  {
    v10 = xpc_null_create();
    v9 = 0;
  }
  xpc_release(v9);
  v11 = xpc_dictionary_create(0, 0, 0);
  if (v11 || (v11 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v11) == v5)
    {
      xpc_retain(v11);
      v12 = v11;
    }
    else
    {
      v12 = xpc_null_create();
    }
  }
  else
  {
    v12 = xpc_null_create();
    v11 = 0;
  }
  xpc_release(v11);
  (*(void (**)(uint8_t *__return_ptr, CoredumpTrace *, xpc_object_t *))(*(_QWORD *)this + 200))(buf, this, a2);
  if ((buf[23] & 0x80u) == 0)
    v13 = buf;
  else
    v13 = *(uint8_t **)buf;
  v14 = xpc_string_create((const char *)v13);
  if (!v14)
    v14 = xpc_null_create();
  xpc_dictionary_set_value(v12, (const char *)*MEMORY[0x1E0CFB758], v14);
  v15 = xpc_null_create();
  xpc_release(v14);
  xpc_release(v15);
  if ((char)buf[23] < 0)
    operator delete(*(void **)buf);
  memset(buf, 170, 24);
  value = xpc_dictionary_get_value(*a2, "host_line");
  object = value;
  if (value)
    xpc_retain(value);
  else
    object = xpc_null_create();
  xpc::dyn_cast_or_default();
  xpc_release(object);
  if ((buf[23] & 0x80u) == 0)
    v17 = buf;
  else
    v17 = *(uint8_t **)buf;
  v18 = atoi((const char *)v17);
  v19 = xpc_int64_create(v18);
  if (!v19)
    v19 = xpc_null_create();
  xpc_dictionary_set_value(v12, (const char *)*MEMORY[0x1E0CFB640], v19);
  v20 = xpc_null_create();
  xpc_release(v19);
  xpc_release(v20);
  v21 = xpc_dictionary_get_value(*a2, "host_filename");
  v38 = v21;
  if (v21)
    xpc_retain(v21);
  else
    v38 = xpc_null_create();
  xpc::dyn_cast_or_default();
  if (v41 >= 0)
    p_object = (const char *)&object;
  else
    p_object = (const char *)object;
  v23 = xpc_string_create(p_object);
  if (!v23)
    v23 = xpc_null_create();
  xpc_dictionary_set_value(v12, (const char *)*MEMORY[0x1E0CFB3E0], v23);
  v24 = xpc_null_create();
  xpc_release(v23);
  xpc_release(v24);
  if (v41 < 0)
    operator delete(object);
  xpc_release(v38);
  xpc_array_append_value(v10, v12);
  v25 = xpc_string_create((const char *)*MEMORY[0x1E0CFC190]);
  if (!v25)
    v25 = xpc_null_create();
  xpc_dictionary_set_value(v8, (const char *)*MEMORY[0x1E0CFB020], v25);
  v26 = xpc_null_create();
  xpc_release(v25);
  xpc_release(v26);
  v27 = xpc_int64_create(524365);
  if (!v27)
    v27 = xpc_null_create();
  xpc_dictionary_set_value(v8, (const char *)*MEMORY[0x1E0CFB0E8], v27);
  v28 = xpc_null_create();
  xpc_release(v27);
  xpc_release(v28);
  if (v10)
  {
    xpc_retain(v10);
    v29 = v10;
  }
  else
  {
    v29 = xpc_null_create();
  }
  xpc_dictionary_set_value(v8, (const char *)*MEMORY[0x1E0CFB018], v29);
  v30 = xpc_null_create();
  xpc_release(v29);
  xpc_release(v30);
  v31 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  if (v31)
  {
    v32 = std::__shared_weak_count::lock(v31);
    v40 = v32;
    if (v32)
    {
      v33 = (void *)*((_QWORD *)this + 16);
      object = v33;
      if (!v33)
      {
        v34 = v32;
        goto LABEL_64;
      }
      v37 = v8;
      if (v8)
        xpc_retain(v8);
      else
        v37 = xpc_null_create();
      abm::BasebandTracingTask::commandReportStatsAWD((uint64_t)v33, &v37);
      xpc_release(v37);
      v37 = 0;
      v34 = v40;
      if (v40)
      {
LABEL_64:
        p_shared_owners = (unint64_t *)&v34->__shared_owners_;
        do
          v36 = __ldaxr(p_shared_owners);
        while (__stlxr(v36 - 1, p_shared_owners));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
  }
  if ((char)buf[23] < 0)
    operator delete(*(void **)buf);
  xpc_release(v12);
  xpc_release(v10);
  xpc_release(v8);
}

void sub_1A34B4068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  void *v20;
  void *v21;
  void *v22;

  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  if (a20 < 0)
    operator delete(__p);
  xpc_release(v22);
  xpc_release(v21);
  xpc_release(v20);
  _Unwind_Resume(a1);
}

void CoredumpTrace::updateAnalyticsEvent_sync(CoredumpTrace *this, xpc_object_t *a2)
{
  NSObject *v4;
  xpc_object_t v5;
  uint64_t v6;
  xpc_object_t v7;
  uint8_t *v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t value;
  xpc_object_t v12;
  size_t v13;
  unint64_t v14;
  void **p_dst;
  uint64_t v16;
  uint64_t v17;
  xpc_object_t *v18;
  uint8_t *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  const char *v23;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t *v26;
  xpc_object_t v27;
  xpc_object_t v28;
  xpc_object_t v29;
  xpc_object_t v30;
  xpc_object_t v31;
  xpc_object_t v32;
  xpc_object_t v33;
  xpc_object_t v34;
  xpc_object_t v35;
  xpc_object_t v36;
  xpc_object_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  xpc_object_t v40;
  xpc_object_t v41;
  xpc_object_t v42;
  xpc_object_t v43;
  xpc_object_t v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count *v46;
  void **v47;
  std::__shared_weak_count *v48;
  unint64_t *p_shared_owners;
  unint64_t v50;
  xpc_object_t v51;
  void **__dst;
  unint64_t v53;
  _QWORD v54[4];
  xpc_object_t object[3];
  uint8_t buf[32];

  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Updating Analytics metric of crash info", buf, 2u);
  }
  v5 = xpc_dictionary_create(0, 0, 0);
  v6 = MEMORY[0x1E0C812F8];
  if (v5 || (v5 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v5) == v6)
    {
      xpc_retain(v5);
      v7 = v5;
    }
    else
    {
      v7 = xpc_null_create();
    }
  }
  else
  {
    v7 = xpc_null_create();
    v5 = 0;
  }
  xpc_release(v5);
  (*(void (**)(uint8_t *__return_ptr, CoredumpTrace *, xpc_object_t *))(*(_QWORD *)this + 200))(buf, this, a2);
  if ((buf[23] & 0x80u) == 0)
    v8 = buf;
  else
    v8 = *(uint8_t **)buf;
  v9 = xpc_string_create((const char *)v8);
  if (!v9)
    v9 = xpc_null_create();
  xpc_dictionary_set_value(v7, "resetReason", v9);
  v10 = xpc_null_create();
  xpc_release(v9);
  xpc_release(v10);
  if ((char)buf[23] < 0)
    operator delete(*(void **)buf);
  memset(buf, 170, 24);
  value = xpc_dictionary_get_value(*a2, "host_line");
  object[0] = value;
  if (value)
    xpc_retain(value);
  else
    object[0] = xpc_null_create();
  xpc::dyn_cast_or_default();
  xpc_release(object[0]);
  memset(object, 170, sizeof(object));
  v12 = xpc_dictionary_get_value(*a2, "host_filename");
  v54[1] = v12;
  if (v12)
    xpc_retain(v12);
  else
    v54[1] = xpc_null_create();
  xpc::dyn_cast_or_default();
  xpc_release((xpc_object_t)v54[1]);
  memset(v54, 170, sizeof(v54));
  if (SHIBYTE(object[2]) >= 0)
    v13 = HIBYTE(object[2]);
  else
    v13 = (size_t)object[1];
  v14 = v13 + 1;
  __dst = (void **)0xAAAAAAAAAAAAAAAALL;
  v53 = 0xAAAAAAAAAAAAAAAALL;
  if (v13 + 1 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v14 >= 0x17)
  {
    v16 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17)
      v16 = v14 | 7;
    v17 = v16 + 1;
    p_dst = (void **)operator new(v16 + 1);
    v53 = v13 + 1;
    v54[0] = v17 | 0x8000000000000000;
    __dst = p_dst;
  }
  else
  {
    v53 = 0;
    v54[0] = 0;
    __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v54[0]) = v13 + 1;
    if (!v13)
      goto LABEL_36;
  }
  if (SHIBYTE(object[2]) >= 0)
    v18 = object;
  else
    v18 = (xpc_object_t *)object[0];
  memmove(p_dst, v18, v13);
LABEL_36:
  *(_WORD *)((char *)p_dst + v13) = 58;
  if ((buf[23] & 0x80u) == 0)
    v19 = buf;
  else
    v19 = *(uint8_t **)buf;
  if ((buf[23] & 0x80u) == 0)
    v20 = buf[23];
  else
    v20 = *(_QWORD *)&buf[8];
  v21 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v19, v20);
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v54[3] = *((_QWORD *)&v21->__r_.__value_.__l + 2);
  *(_OWORD *)&v54[1] = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v54[0]) < 0)
    operator delete(__dst);
  if (v54[3] >= 0)
    v23 = (const char *)&v54[1];
  else
    v23 = (const char *)v54[1];
  v24 = xpc_string_create(v23);
  if (!v24)
    v24 = xpc_null_create();
  xpc_dictionary_set_value(v7, "shortResetReason", v24);
  v25 = xpc_null_create();
  xpc_release(v24);
  xpc_release(v25);
  if (SHIBYTE(object[2]) >= 0)
    v26 = object;
  else
    v26 = (xpc_object_t *)object[0];
  v27 = xpc_string_create((const char *)v26);
  if (!v27)
    v27 = xpc_null_create();
  xpc_dictionary_set_value(v7, "basebandCrashFileName", v27);
  v28 = xpc_null_create();
  xpc_release(v27);
  xpc_release(v28);
  v29 = xpc_dictionary_create(0, 0, 0);
  if (v29 || (v29 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v29) == v6)
    {
      xpc_retain(v29);
      v30 = v29;
    }
    else
    {
      v30 = xpc_null_create();
    }
  }
  else
  {
    v30 = xpc_null_create();
    v29 = 0;
  }
  xpc_release(v29);
  v31 = xpc_string_create("metricsCCBasebandResetInfo");
  if (!v31)
    v31 = xpc_null_create();
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E0CFB278], v31);
  v32 = xpc_null_create();
  xpc_release(v31);
  xpc_release(v32);
  v33 = xpc_string_create("Crash");
  if (!v33)
    v33 = xpc_null_create();
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E0CFB3F0], v33);
  v34 = xpc_null_create();
  xpc_release(v33);
  xpc_release(v34);
  if (v7)
  {
    xpc_retain(v7);
    v35 = v7;
  }
  else
  {
    v35 = xpc_null_create();
  }
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E0CFB9D8], v35);
  v36 = xpc_null_create();
  xpc_release(v35);
  xpc_release(v36);
  v37 = xpc_string_create((const char *)*MEMORY[0x1E0CFB448]);
  if (!v37)
    v37 = xpc_null_create();
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E0CFB3E8], v37);
  v38 = xpc_null_create();
  xpc_release(v37);
  xpc_release(v38);
  v39 = xpc_dictionary_create(0, 0, 0);
  if (v39 || (v39 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v39) == v6)
    {
      xpc_retain(v39);
      v40 = v39;
    }
    else
    {
      v40 = xpc_null_create();
    }
  }
  else
  {
    v40 = xpc_null_create();
    v39 = 0;
  }
  xpc_release(v39);
  v41 = xpc_string_create((const char *)*MEMORY[0x1E0CFAFE8]);
  if (!v41)
    v41 = xpc_null_create();
  xpc_dictionary_set_value(v40, (const char *)*MEMORY[0x1E0CFB020], v41);
  v42 = xpc_null_create();
  xpc_release(v41);
  xpc_release(v42);
  if (v30)
  {
    xpc_retain(v30);
    v43 = v30;
  }
  else
  {
    v43 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, (const char *)*MEMORY[0x1E0CFB018], v43);
  v44 = xpc_null_create();
  xpc_release(v43);
  xpc_release(v44);
  v45 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  if (v45)
  {
    v46 = std::__shared_weak_count::lock(v45);
    v53 = (unint64_t)v46;
    if (v46)
    {
      v47 = (void **)*((_QWORD *)this + 16);
      __dst = v47;
      if (!v47)
      {
        v48 = v46;
LABEL_88:
        p_shared_owners = (unint64_t *)&v48->__shared_owners_;
        do
          v50 = __ldaxr(p_shared_owners);
        while (__stlxr(v50 - 1, p_shared_owners));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
          std::__shared_weak_count::__release_weak(v48);
        }
        goto LABEL_92;
      }
      v51 = v40;
      if (v40)
        xpc_retain(v40);
      else
        v51 = xpc_null_create();
      abm::BasebandTracingTask::commandReportStatsAWD((uint64_t)v47, &v51);
      xpc_release(v51);
      v51 = 0;
      v48 = (std::__shared_weak_count *)v53;
      if (v53)
        goto LABEL_88;
    }
  }
LABEL_92:
  xpc_release(v40);
  xpc_release(v30);
  if ((SHIBYTE(v54[3]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(object[2]) & 0x80000000) == 0)
      goto LABEL_94;
LABEL_97:
    operator delete(object[0]);
    if (((char)buf[23] & 0x80000000) == 0)
      goto LABEL_95;
LABEL_98:
    operator delete(*(void **)buf);
    goto LABEL_95;
  }
  operator delete((void *)v54[1]);
  if (SHIBYTE(object[2]) < 0)
    goto LABEL_97;
LABEL_94:
  if ((char)buf[23] < 0)
    goto LABEL_98;
LABEL_95:
  xpc_release(v7);
}

void sub_1A34B4914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  void *v33;
  void *v34;
  void *v35;

  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  xpc_release(v35);
  xpc_release(v34);
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  xpc_release(v33);
  _Unwind_Resume(a1);
}

uint64_t CoredumpTrace::crashBasebandARI_sync(CoredumpTrace *this)
{
  uint64_t (*v2)(uint64_t);
  NSObject *v3;
  const char *v4;
  NSObject *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  void *__p;
  __int128 v11;
  unint64_t v12;
  CFTypeRef cf;
  char v14;

  v14 = 0;
  cf = (CFTypeRef)TelephonyBasebandCreateController();
  v2 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  if (!cf)
    v2 = 0;
  if (!v2)
  {
    v3 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
LABEL_18:
      v6 = 0;
      v7 = 0;
      goto LABEL_19;
    }
    LOWORD(__p) = 0;
    v4 = "Failed to create TelephonyBasebandController";
LABEL_25:
    _os_log_error_impl(&dword_1A343C000, v3, OS_LOG_TYPE_ERROR, v4, (uint8_t *)&__p, 2u);
    goto LABEL_18;
  }
  if ((TelephonyBasebandGetReset() & 1) == 0)
  {
    v5 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, "Failed to get baseband reset state", (uint8_t *)&__p, 2u);
    }
    v14 = 0;
  }
  support::transport::AriRT::create((support::transport::AriRT *)"CoredumpTrace", (dispatch_queue_s *)0x2710, 0, (support::transport::ARI **)&__p);
  v6 = __p;
  if (!__p)
  {
    v3 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    LOWORD(__p) = 0;
    v4 = "Failed to open ARI interface (is baseband booted and ready?)";
    goto LABEL_25;
  }
  v12 = 0xAAAAAAAAAAAAAAAALL;
  Bsp::BspCommandDriver::BspCommandDriver();
  __p = operator new(0x28uLL);
  v11 = xmmword_1A3580C00;
  strcpy((char *)__p, "AP triggered baseband reset over ARI");
  v7 = Bsp::BspCommandDriver::SwTrap();
  if (SHIBYTE(v11) < 0)
    operator delete(__p);
  if ((v7 & 1) == 0)
  {
    v8 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to send SW Trap", (uint8_t *)&__p, 2u);
    }
  }
LABEL_19:
  if (cf)
    CFRelease(cf);
  if (v6)
    (*(void (**)(void *))(*(_QWORD *)v6 + 8))(v6);
  return v7;
}

void sub_1A34B4D68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16)
{
  uint64_t v16;

  if (a14 < 0)
    operator delete(__p);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(&a16);
  (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  _Unwind_Resume(a1);
}

void sub_1A34B4DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1A34B4DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

const void **ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t CoredumpTrace::crashBaseband_sync(CoredumpTrace *a1, const std::string::value_type *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  const void *Controller;
  uint64_t (*v7)(uint64_t);
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  char v13;
  __int128 v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  const std::string::value_type *v19;
  uint8_t v20[16];
  const void *v21;
  char v22;
  uint8_t buf[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)a1 + 5);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    v19 = a2;
    if (a2[23] < 0)
      v19 = *(const std::string::value_type **)a2;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v19;
    _os_log_debug_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEBUG, "#D Crashing baseband with reason: \"%s\"", buf, 0xCu);
  }
  if (capabilities::coredump::supportsSPMISignalling((capabilities::coredump *)v5))
  {
    v22 = 0;
    Controller = (const void *)TelephonyBasebandCreateController();
    v21 = Controller;
    v7 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
    if (!Controller)
      v7 = 0;
    if (v7)
    {
      if ((TelephonyBasebandGetReset() & 1) != 0)
      {
        v8 = *((_QWORD *)a1 + 5);
      }
      else
      {
        v8 = *((_QWORD *)a1 + 5);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to get baseband reset state", buf, 2u);
          v8 = *((_QWORD *)a1 + 5);
        }
        v22 = 0;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I Crashing baseband (SPMI)", buf, 2u);
      }
      v27 = -86;
      *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v25 = v14;
      v26 = v14;
      *(_OWORD *)buf = v14;
      v24 = v14;
      ResetReasonEncoder::encode(a2, (uint64_t)buf);
      if (v27)
      {
        v15 = TelephonyBasebandCrashModemWithSPMIWithReason();
      }
      else
      {
        v16 = *((_QWORD *)a1 + 5);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v20 = 0;
          _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#I Failed to encode reset reason, so crashing baseband with SPMI without specifying reason", v20, 2u);
        }
        v15 = TelephonyBasebandCrashModemWithSPMI();
      }
      v10 = v15;
      if ((v15 & 1) != 0 || (v17 = *((_QWORD *)a1 + 5), !os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)))
      {
        v13 = 1;
        if (!Controller)
          goto LABEL_31;
        goto LABEL_30;
      }
      *(_WORD *)v20 = 0;
      _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, "Failed to crash baseband via SPMI", v20, 2u);
      v13 = 1;
      if (!Controller)
      {
LABEL_31:
        if ((v13 & 1) == 0)
          return 0;
        return v10;
      }
    }
    else
    {
      v12 = *((_QWORD *)a1 + 5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "Failed to create TelephonyBasebandController", buf, 2u);
        v10 = 0;
        v13 = 0;
        if (!Controller)
          goto LABEL_31;
      }
      else
      {
        v10 = 0;
        v13 = 0;
        if (!Controller)
          goto LABEL_31;
      }
    }
LABEL_30:
    CFRelease(Controller);
    goto LABEL_31;
  }
  v9 = *((_QWORD *)a1 + 5);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#I Crashing baseband (ARI)", buf, 2u);
  }
  if ((CoredumpTrace::crashBasebandARI_sync(a1) & 1) == 0)
  {
    v11 = *((_QWORD *)a1 + 5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to crash (ARI)", buf, 2u);
    }
    return 0;
  }
  return 1;
}

void sub_1A34B519C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void CoredumpTrace::handleBBULog(CoredumpTrace *this, int a2, const char *__s)
{
  size_t v6;
  std::string::size_type v7;
  std::string *p_dst;
  uint64_t v9;
  uint64_t v10;
  std::string::size_type v11;
  char v12;
  std::string::size_type v13;
  std::string::size_type size;
  std::string *v15;
  size_t v16;
  _BYTE *v17;
  unint64_t v18;
  std::string *v19;
  char *v21;
  int v22;
  char *v23;
  std::string *v24;
  std::string::size_type v25;
  std::string::size_type v26;
  NSObject *v27;
  std::string *v28;
  std::string __dst;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  std::string *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  memset(&__dst, 170, sizeof(__dst));
  v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_dst = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v6;
  p_dst = &__dst;
  if (v6)
LABEL_8:
    memcpy(p_dst, __s, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  v12 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  size = __dst.__r_.__value_.__l.__size_;
  v13 = __dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = &__dst;
  else
    v15 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v16 = __dst.__r_.__value_.__l.__size_;
  v17 = memchr(v15, 10, v16);
  if (v17)
    v18 = (unint64_t)v17;
  else
    v18 = (unint64_t)v15 + v16;
  v19 = (std::string *)(v18 + 1);
  if (v18 - (_QWORD)v15 != v16 && v19 != (std::string *)((char *)v15 + v16))
  {
    v21 = (char *)v15 + v16 + ~v18;
    do
    {
      v22 = v19->__r_.__value_.__s.__data_[0];
      if (v22 != 10)
        *(_BYTE *)v18++ = v22;
      v19 = (std::string *)((char *)v19 + 1);
      --v21;
    }
    while (v21);
    v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    size = __dst.__r_.__value_.__l.__size_;
    v13 = __dst.__r_.__value_.__r.__words[0];
    v12 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  if (v12 >= 0)
    v23 = (char *)&__dst + v11;
  else
    v23 = (char *)(v13 + size);
  if (v12 >= 0)
    v24 = &__dst;
  else
    v24 = (std::string *)v13;
  if (v12 >= 0)
    v25 = v11;
  else
    v25 = size;
  v26 = v18 - (_QWORD)v24;
  if (v25 < v18 - (unint64_t)v24)
    std::string::__throw_out_of_range[abi:ne180100]();
  if (&v23[-v18] == (char *)-1)
  {
    if (v12 < 0)
    {
      __dst.__r_.__value_.__l.__size_ = v18 - (_QWORD)v24;
      *(_BYTE *)(v13 + v26) = 0;
      v27 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        goto LABEL_45;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v26 & 0x7F;
      __dst.__r_.__value_.__s.__data_[v26] = 0;
      v27 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        goto LABEL_45;
    }
LABEL_39:
    v28 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v28 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 67109378;
    v31 = a2;
    v32 = 2080;
    v33 = v28;
    _os_log_impl(&dword_1A343C000, v27, OS_LOG_TYPE_DEFAULT, "#I BBUpdater:  %04x:%s", buf, 0x12u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_42;
    return;
  }
  std::string::__erase_external_with_move(&__dst, v26, (std::string::size_type)&v23[-v18]);
  v27 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    goto LABEL_39;
LABEL_45:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
LABEL_42:
    operator delete(__dst.__r_.__value_.__l.__data_);
}

void sub_1A34B5498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CoredumpTrace::collectBasebandCoreDump_sync(CoredumpTrace *this)
{
  const void *v2;
  const __CFAllocator *v3;
  __CFDictionary *Mutable;
  _QWORD *v5;
  uint64_t (***v6)(void *, const void *);
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  const char *v15;
  const void *v16;
  char v17;
  size_t v18;
  _BYTE *v19;
  size_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  NSObject *v25;
  uint8_t *v26;
  CFMutableDictionaryRef v27;
  CFTypeRef v28;
  CFTypeRef v29;
  const void *v30;
  const void *v31;
  CFNumberRef v32;
  capabilities::radio *v33;
  int v34;
  int v35;
  _QWORD *v36;
  NSObject *v37;
  CFTypeRef v38;
  int v39;
  NSObject *v40;
  const void *v41;
  int valuePtr;
  _BYTE __p[24];
  CFTypeRef v45;
  const void *v46;
  uint8_t __dst[16];
  uint64_t v48;
  void *v49[3];
  CFTypeRef cf;
  CFTypeRef v51;
  const void *v52;
  uint8_t buf[24];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  cf = 0;
  v2 = (const void *)BBUpdaterExtremeCreate();
  if (!v2)
  {
    v7 = 0;
    goto LABEL_85;
  }
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v8 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
LABEL_79:
      v7 = 0;
      goto LABEL_83;
    }
    LOWORD(v49[0]) = 0;
    v9 = "Failed to create options dictionary";
LABEL_95:
    _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)v49, 2u);
    v7 = 0;
    goto LABEL_83;
  }
  BYTE5(v49[2]) = -86;
  HIWORD(v49[2]) = 5290;
  strcpy((char *)v49, "boot::debugArguments");
  memset(__dst, 0, sizeof(__dst));
  v48 = 0;
  v45 = 0;
  v46 = (const void *)0xAAAAAAAAAAAAAAAALL;
  pthread_mutex_lock(&ctu::Singleton<ABMProperties,ABMProperties,ctu::PthreadMutexGuardPolicy<ABMProperties>>::sInstance);
  if (!(_QWORD)xmmword_1ED1147D8)
  {
    v6 = (uint64_t (***)(void *, const void *))operator new(0x18uLL);
    MEMORY[0x1A858F2E4](v6, CFSTR("com.apple.AppleBasebandManager"), *MEMORY[0x1E0C9B260]);
    v5 = operator new(0x20uLL);
    *v5 = &unk_1E4A09890;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
    v10 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1147D8 + 1);
    *(_QWORD *)&xmmword_1ED1147D8 = v6;
    *((_QWORD *)&xmmword_1ED1147D8 + 1) = v5;
    if (!v10)
    {
      *(_QWORD *)buf = v6;
      *(_QWORD *)&buf[8] = v5;
LABEL_15:
      v13 = v5 + 1;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      goto LABEL_17;
    }
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v5 = (_QWORD *)*((_QWORD *)&xmmword_1ED1147D8 + 1);
  v6 = (uint64_t (***)(void *, const void *))xmmword_1ED1147D8;
  *(_OWORD *)buf = xmmword_1ED1147D8;
  if (*((_QWORD *)&xmmword_1ED1147D8 + 1))
    goto LABEL_15;
LABEL_17:
  pthread_mutex_unlock(&ctu::Singleton<ABMProperties,ABMProperties,ctu::PthreadMutexGuardPolicy<ABMProperties>>::sInstance);
  *(_QWORD *)__p = 0xAAAAAAAAAAAAAA00;
  *(_OWORD *)&__p[8] = xmmword_1A3580C10;
  if (SHIBYTE(v49[2]) >= 0)
    v15 = (const char *)v49;
  else
    v15 = (const char *)v49[0];
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v52, v15);
  v16 = (const void *)(**v6)(v6, v52);
  if (v16)
  {
    v17 = ctu::cf::assign();
    CFRelease(v16);
    MEMORY[0x1A858F29C](&v52);
    if ((v17 & 1) != 0)
      goto LABEL_34;
    v18 = __p[23];
    if ((SHIBYTE(v48) & 0x80000000) == 0)
      goto LABEL_23;
  }
  else
  {
    MEMORY[0x1A858F29C](&v52);
    v18 = __p[23];
    if ((SHIBYTE(v48) & 0x80000000) == 0)
    {
LABEL_23:
      if ((v18 & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(__dst, *(void **)__p, *(size_t *)&__p[8]);
      }
      else
      {
        *(_OWORD *)__dst = *(_OWORD *)__p;
        v48 = *(_QWORD *)&__p[16];
      }
      goto LABEL_34;
    }
  }
  if ((v18 & 0x80u) == 0)
    v19 = __p;
  else
    v19 = *(_BYTE **)__p;
  if ((v18 & 0x80u) == 0)
    v20 = v18;
  else
    v20 = *(_QWORD *)&__p[8];
  std::string::__assign_no_alias<false>((void **)__dst, v19, v20);
LABEL_34:
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v21 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v22 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = HIBYTE(v48);
  if (v48 < 0)
    v24 = *(_QWORD *)&__dst[8];
  if (v24 && ctu::cf::convert_copy())
  {
    v25 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = __dst;
      if (v48 < 0)
        v26 = *(uint8_t **)__dst;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v26;
      _os_log_impl(&dword_1A343C000, v25, OS_LOG_TYPE_DEFAULT, "#N Retrieved debug args: %s", buf, 0xCu);
    }
    v27 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v27)
    {
      v28 = cf;
      cf = v27;
      if (v28)
        CFRelease(v28);
      CFDictionarySetValue(Mutable, CFSTR("Options"), v27);
      v29 = v45;
      v30 = v46;
      v45 = v46;
      if (v29)
        CFRelease(v29);
      *(_QWORD *)buf = CFSTR("DebugArgs");
      CFRetain(CFSTR("DebugArgs"));
      v52 = v30;
      if (v30)
      {
        CFRetain(v30);
        CFDictionarySetValue(v27, CFSTR("DebugArgs"), v30);
        CFRelease(v30);
      }
      CFRelease(CFSTR("DebugArgs"));
    }
  }
  v31 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionarySetValue(Mutable, CFSTR("DisallowFusing"), (const void *)*MEMORY[0x1E0C9AE50]);
  valuePtr = 2;
  v32 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, CFSTR("BootMode"), v32);
  CFRelease(v32);
  v52 = 0;
  capabilities::radio::personalizedFirmwarePath(v33);
  v34 = ctu::cf::convert_copy();
  v35 = v34;
  if ((char)buf[23] < 0)
  {
    operator delete(*(void **)buf);
    if (!v35)
      goto LABEL_62;
    goto LABEL_61;
  }
  if (v34)
  {
LABEL_61:
    CFDictionarySetValue(Mutable, CFSTR("firmwareDataFolder"), v52);
    CFRelease(v52);
  }
LABEL_62:
  CFDictionaryAddValue(Mutable, CFSTR("coreDumpPathNoTimestamp"), v31);
  v36 = (_QWORD *)((char *)this + 176);
  v7 = ctu::cf::convert_copy();
  if ((_DWORD)v7)
  {
    CFDictionarySetValue(Mutable, CFSTR("coreDumpPath"), 0);
    CFRelease(0);
    goto LABEL_65;
  }
  v37 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
LABEL_65:
    v38 = v45;
    if (!v45)
      goto LABEL_67;
    goto LABEL_66;
  }
  if (*((char *)this + 199) < 0)
    v36 = (_QWORD *)*v36;
  *(_DWORD *)buf = 136315138;
  *(_QWORD *)&buf[4] = v36;
  _os_log_error_impl(&dword_1A343C000, v37, OS_LOG_TYPE_ERROR, "Failed to convert CoreDump path (%s)", buf, 0xCu);
  v38 = v45;
  if (v45)
LABEL_66:
    CFRelease(v38);
LABEL_67:
  if ((SHIBYTE(v48) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v49[2]) & 0x80000000) == 0)
      goto LABEL_69;
LABEL_72:
    operator delete(v49[0]);
    if (!(_DWORD)v7)
      goto LABEL_83;
    goto LABEL_73;
  }
  operator delete(*(void **)__dst);
  if (SHIBYTE(v49[2]) < 0)
    goto LABEL_72;
LABEL_69:
  if (!(_DWORD)v7)
    goto LABEL_83;
LABEL_73:
  if (!BBUpdaterSetOptions())
  {
    v8 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_79;
    LOWORD(v49[0]) = 0;
    v9 = "Failed to set CoreDump options";
    goto LABEL_95;
  }
  v49[0] = 0;
  v39 = BBUpdaterExecCommand();
  v7 = v39 != 0;
  v40 = *((_QWORD *)this + 5);
  if (v39)
  {
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__dst = 0;
      _os_log_impl(&dword_1A343C000, v40, OS_LOG_TYPE_DEFAULT, "#I CoreDump success", __dst, 2u);
      v41 = v49[0];
      if (!v49[0])
        goto LABEL_83;
LABEL_82:
      CFRelease(v41);
      goto LABEL_83;
    }
LABEL_81:
    v41 = v49[0];
    if (!v49[0])
      goto LABEL_83;
    goto LABEL_82;
  }
  if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    goto LABEL_81;
  *(_WORD *)__dst = 0;
  _os_log_error_impl(&dword_1A343C000, v40, OS_LOG_TYPE_ERROR, "Failed to execute CoreDump command", __dst, 2u);
  v41 = v49[0];
  if (v49[0])
    goto LABEL_82;
LABEL_83:
  CFRelease(v2);
  if (Mutable)
    CFRelease(Mutable);
LABEL_85:
  if (v51)
    CFRelease(v51);
  if (cf)
    CFRelease(cf);
  return v7;
}

void sub_1A34B5BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

const void **ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void CoredumpTrace::snapshot_sync(CoredumpTrace *this, uint64_t a2, const __CFDictionary **a3)
{
  NSObject *v5;
  char v6;
  char v7;
  NSObject *v8;
  capabilities::trace *v9;
  _QWORD *v10;
  NSObject *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  std::string v14;
  std::string buf;
  _QWORD v16[2];
  uint64_t v17;
  _BYTE v18[12];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*((char *)this + 199) < 0)
  {
    **((_BYTE **)this + 22) = 0;
    *((_QWORD *)this + 23) = 0;
    if (CoredumpTrace::createScratchPath_sync(this))
    {
LABEL_3:
      v16[0] = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = 0xAAAAAAAAAAAAAAAALL;
      ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v16, *a3);
      memset(&buf, 170, sizeof(buf));
      v19 = 0;
      v18[0] = 0;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v17, "kKeyTraceDumpStateReason");
      ctu::cf::map_adapter::getString();
      MEMORY[0x1A858F29C](&v17);
      if (v19 < 0)
      {
        operator delete(*(void **)v18);
        if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_5;
      }
      else if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_5:
        v14 = buf;
        goto LABEL_11;
      }
      std::string::__init_copy_ctor_external(&v14, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
LABEL_11:
      v6 = (*(uint64_t (**)(CoredumpTrace *, std::string *))(*(_QWORD *)this + 176))(this, &v14);
      v7 = v6;
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v14.__r_.__value_.__l.__data_);
        if ((v7 & 1) != 0)
          goto LABEL_17;
      }
      else if ((v6 & 1) != 0)
      {
LABEL_17:
        v9 = (capabilities::trace *)(*(uint64_t (**)(CoredumpTrace *))(*(_QWORD *)this + 184))(this);
        if ((_DWORD)v9 && *((_BYTE *)this + 232))
        {
          *((_BYTE *)this + 232) = 0;
          CoredumpTrace::cleanCrashReport_sync(this);
          *(_QWORD *)v18 = 0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(_BYTE *__return_ptr, CoredumpTrace *))(*(_QWORD *)this + 192))(v18, this);
          CoredumpTrace::storeCrashReason_sync((NSObject **)this, (const xpc::dict *)v18);
          CoredumpTrace::submitCrashReason_sync(this, (xpc_object_t *)v18);
          CoredumpTrace::updateAnalyticsEvent_sync(this, (xpc_object_t *)v18);
          xpc_release(*(xpc_object_t *)v18);
        }
        if (*((_BYTE *)this + 168)
          || !capabilities::trace::supportsCoredumpCrashReasonOnCustomerBuild(v9))
        {
          v12 = *a3;
          v13 = v12;
          if (v12)
            CFRetain(v12);
          CoredumpTrace::moveToSnapshotPath_sync((uint64_t)this, &v13);
          if (v12)
            CFRelease(v12);
        }
        else
        {
          v10 = (_QWORD *)((char *)this + 176);
          if (!support::fs::removeDirContents((const char *)this + 176, 0)
            || (support::fs::removeDir((const char *)this + 176) & 1) == 0)
          {
            v11 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              if (*((char *)this + 199) < 0)
                v10 = (_QWORD *)*v10;
              *(_DWORD *)v18 = 136315138;
              *(_QWORD *)&v18[4] = v10;
              _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to clean up scratch path %s", v18, 0xCu);
            }
          }
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          operator delete(buf.__r_.__value_.__l.__data_);
        MEMORY[0x1A858F2D8](v16);
        return;
      }
      v8 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v18 = 0;
        _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to crash baseband, continuing with coredump anyway (coredump may be invalid)", v18, 2u);
      }
      goto LABEL_17;
    }
  }
  else
  {
    *((_BYTE *)this + 176) = 0;
    *((_BYTE *)this + 199) = 0;
    if (CoredumpTrace::createScratchPath_sync(this))
      goto LABEL_3;
  }
  v5 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, "Failed to create scratch path", (uint8_t *)&buf, 2u);
  }
}

void sub_1A34B6068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a23 < 0)
    operator delete(__p);
  MEMORY[0x1A858F2D8](&a24);
  _Unwind_Resume(a1);
}

void CoredumpTrace::cleanCrashReport_sync(CoredumpTrace *this)
{
  const char *v2;
  void *v3;
  size_t v4;
  void **v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  int v9;
  void **v10;
  size_t v11;
  ssize_t v12;
  void *__dst[3];
  void *__p;
  _BYTE *v15;
  uint64_t v16;

  __p = 0;
  v15 = 0;
  v16 = 0;
  v2 = (char *)this + 200;
  support::fs::loadFile((uint64_t)this + 200, (uint64_t)&__p);
  memset(__dst, 170, sizeof(__dst));
  v3 = __p;
  v4 = v15 - (_BYTE *)__p;
  if ((unint64_t)(v15 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v4 >= 0x17)
  {
    v6 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v6 = v4 | 7;
    v7 = v6 + 1;
    v5 = (void **)operator new(v6 + 1);
    __dst[1] = (void *)v4;
    __dst[2] = (void *)(v7 | 0x8000000000000000);
    __dst[0] = v5;
    goto LABEL_8;
  }
  HIBYTE(__dst[2]) = (_BYTE)v15 - (_BYTE)__p;
  v5 = __dst;
  if (v15 != __p)
LABEL_8:
    memmove(v5, v3, v4);
  *((_BYTE *)v5 + v4) = 0;
  util::convert_garbage((uint64_t)__dst);
  if (*((char *)this + 223) >= 0)
    v8 = v2;
  else
    v8 = (const char *)*((_QWORD *)this + 25);
  v9 = open(v8, 1537, 420);
  if ((v9 & 0x80000000) == 0)
  {
    if (SHIBYTE(__dst[2]) >= 0)
      v10 = __dst;
    else
      v10 = (void **)__dst[0];
    if (SHIBYTE(__dst[2]) >= 0)
      v11 = HIBYTE(__dst[2]);
    else
      v11 = (size_t)__dst[1];
    do
    {
      if (!v11)
        break;
      v12 = write(v9, v10, v11);
      v11 -= v12;
      v10 = (void **)((char *)v10 + v12);
    }
    while ((v12 & 0x8000000000000000) == 0);
    while (close(v9) && *__error() == 4)
      ;
  }
  if (SHIBYTE(__dst[2]) < 0)
    operator delete(__dst[0]);
  if (__p)
  {
    v15 = __p;
    operator delete(__p);
  }
}

void sub_1A34B629C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  void *v19;

  if (a16 < 0)
  {
    operator delete(__p);
    v19 = a17;
    if (!a17)
LABEL_3:
      _Unwind_Resume(exception_object);
  }
  else
  {
    v19 = a17;
    if (!a17)
      goto LABEL_3;
  }
  operator delete(v19);
  _Unwind_Resume(exception_object);
}

BOOL CoredumpTrace::moveToSnapshotPath_sync(uint64_t a1, const __CFDictionary **a2)
{
  const void *v3;
  size_t v4;
  __darwin_ino64_t v5;
  stat *p_p;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  void *v10;
  void **v11;
  void *v12;
  void *v13;
  uint64_t v14;
  BOOL v15;
  char v17;
  const char *v18;
  _QWORD *v19;
  timespec v20;
  const char *v21;
  NSObject *v22;
  _BOOL8 v23;
  const char *v25;
  DIR *v26;
  DIR *v27;
  dirent *v28;
  char *v29;
  int v30;
  size_t size;
  size_t v32;
  std::string::size_type v33;
  size_t v34;
  std::string *p_dst;
  std::string *v36;
  char *v37;
  void **v38;
  std::string::size_type v39;
  std::string *v40;
  __int128 v41;
  size_t v42;
  std::string *v43;
  __int128 v44;
  std::error_code *v45;
  const std::__fs::filesystem::path *v46;
  const std::__fs::filesystem::path *v47;
  int v48;
  NSObject *v49;
  stat *v50;
  char *v51;
  size_t v52;
  std::string::size_type v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  stat *v59;
  NSObject *v60;
  void **v61;
  char v62;
  std::string __dst;
  void *v64[2];
  std::string::size_type v65;
  void *v66[3];
  void *v67[3];
  _QWORD v68[2];
  std::string v69;
  std::string v70;
  stat __p;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  memset(&v69, 0, sizeof(v69));
  v68[0] = 0xAAAAAAAAAAAAAAAALL;
  v68[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v68, *a2);
  memset(v67, 170, sizeof(v67));
  strcpy((char *)&__p, "kTraceFilterActionNone");
  HIBYTE(__p.st_gid) = 22;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v66, "kKeyTraceFilterAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](v66);
  if (SHIBYTE(__p.st_gid) < 0)
    operator delete(*(void **)&__p.st_dev);
  memset(v66, 170, sizeof(v66));
  v3 = (const void *)*MEMORY[0x1E0CFB250];
  v4 = strlen((const char *)*MEMORY[0x1E0CFB250]);
  if (v4 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    p_p = (stat *)operator new(v7 + 1);
    __p.st_ino = v5;
    *(_QWORD *)&__p.st_uid = v8 | 0x8000000000000000;
    *(_QWORD *)&__p.st_dev = p_p;
    goto LABEL_10;
  }
  HIBYTE(__p.st_gid) = v4;
  p_p = &__p;
  if (v4)
LABEL_10:
    memmove(p_p, v3, v5);
  v9 = (const char *)*MEMORY[0x1E0CFB370];
  *((_BYTE *)&p_p->st_dev + v5) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v70, v9);
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](&v70);
  if (SHIBYTE(__p.st_gid) < 0)
    operator delete(*(void **)&__p.st_dev);
  v10 = (void *)HIBYTE(v67[2]);
  if (SHIBYTE(v67[2]) < 0)
    v10 = v67[1];
  if (v10 != (void *)22)
    goto LABEL_25;
  v11 = v67;
  if (SHIBYTE(v67[2]) < 0)
    v11 = (void **)v67[0];
  v12 = *v11;
  v13 = v11[1];
  v14 = *(uint64_t *)((char *)v11 + 14);
  v15 = v12 == *(void **)"kTraceFilterActionNone" && v13 == *(void **)"lterActionNone";
  if (!v15 || v14 != *(_QWORD *)"tionNone")
  {
LABEL_25:
    std::string::__assign_external(&v69, abm::trace::kTrashFolder[0]);
    v17 = 0;
    goto LABEL_26;
  }
  v51 = abm::trace::kSnapshotFolder[0];
  v52 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v52 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v53 = v52;
  if (v52 >= 0x17)
  {
    v55 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v52 | 7) != 0x17)
      v55 = v52 | 7;
    v56 = v55 + 1;
    v54 = operator new(v55 + 1);
    v70.__r_.__value_.__l.__size_ = v53;
    v70.__r_.__value_.__r.__words[2] = v56 | 0x8000000000000000;
    v70.__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
  }
  else
  {
    *((_BYTE *)&v70.__r_.__value_.__s + 23) = v52;
    v54 = &v70;
    if (!v52)
      goto LABEL_84;
  }
  memmove(v54, v51, v53);
LABEL_84:
  *((_BYTE *)v54 + v53) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&__dst, "kKeyTraceDumpStatePath");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](&__dst);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v69.__r_.__value_.__l.__data_);
  *(_OWORD *)&v69.__r_.__value_.__l.__data_ = *(_OWORD *)&__p.st_dev;
  v69.__r_.__value_.__r.__words[2] = *(_QWORD *)&__p.st_uid;
  HIBYTE(__p.st_gid) = 0;
  LOBYTE(__p.st_dev) = 0;
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v70.__r_.__value_.__l.__data_);
  v17 = 1;
LABEL_26:
  v19 = (_QWORD *)(a1 + 176);
  v18 = *(const char **)(a1 + 176);
  v20.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v20.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__p.st_blksize = v20;
  *(timespec *)__p.st_qspare = v20;
  __p.st_birthtimespec = v20;
  *(timespec *)&__p.st_size = v20;
  __p.st_mtimespec = v20;
  __p.st_ctimespec = v20;
  *(timespec *)&__p.st_uid = v20;
  __p.st_atimespec = v20;
  *(timespec *)&__p.st_dev = v20;
  if (*(char *)(a1 + 199) >= 0)
    v21 = (const char *)(a1 + 176);
  else
    v21 = v18;
  if (!stat(v21, &__p))
  {
    v25 = *(char *)(a1 + 199) >= 0 ? (const char *)(a1 + 176) : *(const char **)(a1 + 176);
    v26 = opendir(v25);
    v27 = v26;
    if (v26)
    {
      v28 = readdir(v26);
      closedir(v27);
      if (v28)
      {
        v62 = v17;
        memset(&__p, 170, 24);
        v29 = abm::trace::kLogDirPrefix[0];
        v30 = SHIBYTE(v69.__r_.__value_.__r.__words[2]);
        if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
        else
          size = v69.__r_.__value_.__l.__size_;
        v32 = strlen(abm::trace::kLogDirPrefix[0]);
        v33 = size + v32;
        memset(&__dst, 170, sizeof(__dst));
        if (size + v32 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v34 = v32;
        if (v33 > 0x16)
        {
          v57 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v33 | 7) != 0x17)
            v57 = v33 | 7;
          v58 = v57 + 1;
          p_dst = (std::string *)operator new(v57 + 1);
          __dst.__r_.__value_.__l.__size_ = v33;
          __dst.__r_.__value_.__r.__words[2] = v58 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          if (!size)
          {
LABEL_51:
            v37 = (char *)p_dst + size;
            if (v34)
              memmove(v37, v29, v34);
            v37[v34] = 0;
            if (SHIBYTE(v66[2]) >= 0)
              v38 = v66;
            else
              v38 = (void **)v66[0];
            if (SHIBYTE(v66[2]) >= 0)
              v39 = HIBYTE(v66[2]);
            else
              v39 = (std::string::size_type)v66[1];
            v40 = std::string::append(&__dst, (const std::string::value_type *)v38, v39);
            v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
            v70.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v41;
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v40->__r_.__value_.__r.__words[0] = 0;
            v42 = strlen(abm::trace::kCoreDumpSnapshotDirectorySuffix[0]);
            v43 = std::string::append(&v70, abm::trace::kCoreDumpSnapshotDirectorySuffix[0], v42);
            v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
            v65 = v43->__r_.__value_.__r.__words[2];
            *(_OWORD *)v64 = v44;
            v43->__r_.__value_.__l.__size_ = 0;
            v43->__r_.__value_.__r.__words[2] = 0;
            v43->__r_.__value_.__r.__words[0] = 0;
            support::fs::createUniquePath((const char *)v64, (std::string *)&__p);
            if (SHIBYTE(v65) < 0)
            {
              operator delete(v64[0]);
              if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_61:
                if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_62:
                  support::fs::createDir((const char *)&__p, 0x1EDu, 1);
                  if (*(char *)(a1 + 199) >= 0)
                    v46 = (const std::__fs::filesystem::path *)(a1 + 176);
                  else
                    v46 = *(const std::__fs::filesystem::path **)(a1 + 176);
                  if ((__p.st_gid & 0x80000000) == 0)
                    v47 = (const std::__fs::filesystem::path *)&__p;
                  else
                    v47 = *(const std::__fs::filesystem::path **)&__p.st_dev;
                  rename(v46, v47, v45);
                  v23 = v48 == 0;
                  v49 = *(NSObject **)(a1 + 40);
                  if (v48)
                  {
                    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
                    {
                      v50 = &__p;
                      if ((__p.st_gid & 0x80000000) != 0)
                        v50 = *(stat **)&__p.st_dev;
                      LODWORD(v70.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
                      _os_log_error_impl(&dword_1A343C000, v49, OS_LOG_TYPE_ERROR, "Failed creating coredump snapshot path. snapshotUniquePath=[%s]", (uint8_t *)&v70, 0xCu);
                    }
                  }
                  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
                  {
                    v59 = &__p;
                    if ((__p.st_gid & 0x80000000) != 0)
                      v59 = *(stat **)&__p.st_dev;
                    LODWORD(v70.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
                    _os_log_impl(&dword_1A343C000, v49, OS_LOG_TYPE_DEFAULT, "#I Coredump files are placed in path [%s]", (uint8_t *)&v70, 0xCu);
                  }
                  if ((v62 & 1) == 0)
                  {
                    v60 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                    {
                      v61 = v67;
                      if (SHIBYTE(v67[2]) < 0)
                        v61 = (void **)v67[0];
                      LODWORD(v70.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v61;
                      _os_log_impl(&dword_1A343C000, v60, OS_LOG_TYPE_DEFAULT, "#I Trashing coredump logs. Trace filter is '%s'", (uint8_t *)&v70, 0xCu);
                    }
                    support::fs::removeDir((const char *)&__p);
                  }
                  if (SHIBYTE(__p.st_gid) < 0)
                    operator delete(*(void **)&__p.st_dev);
                  goto LABEL_32;
                }
LABEL_95:
                operator delete(__dst.__r_.__value_.__l.__data_);
                goto LABEL_62;
              }
            }
            else if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_61;
            }
            operator delete(v70.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_62;
            goto LABEL_95;
          }
        }
        else
        {
          memset(&__dst, 0, sizeof(__dst));
          p_dst = &__dst;
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = size + v32;
          if (!size)
            goto LABEL_51;
        }
        if (v30 >= 0)
          v36 = &v69;
        else
          v36 = (std::string *)v69.__r_.__value_.__r.__words[0];
        memmove(p_dst, v36, size);
        goto LABEL_51;
      }
    }
  }
  v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a1 + 199) < 0)
      v19 = (_QWORD *)*v19;
    __p.st_dev = 136315138;
    *(_QWORD *)&__p.st_mode = v19;
    _os_log_error_impl(&dword_1A343C000, v22, OS_LOG_TYPE_ERROR, "Failed: Couldn't find Scratch path [%s] to move to Snapshot path", (uint8_t *)&__p, 0xCu);
  }
  v23 = 0;
LABEL_32:
  if ((SHIBYTE(v66[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v67[2]) & 0x80000000) == 0)
      goto LABEL_34;
LABEL_74:
    operator delete(v67[0]);
    MEMORY[0x1A858F2D8](v68);
    if ((SHIBYTE(v69.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v23;
LABEL_75:
    operator delete(v69.__r_.__value_.__l.__data_);
    return v23;
  }
  operator delete(v66[0]);
  if (SHIBYTE(v67[2]) < 0)
    goto LABEL_74;
LABEL_34:
  MEMORY[0x1A858F2D8](v68);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_75;
  return v23;
}

void sub_1A34B6A8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,_Unwind_Exception *exception_object,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if (a49 < 0)
    {
LABEL_5:
      operator delete(a44);
      if ((a15 & 0x80000000) == 0)
      {
LABEL_9:
        if (a28 < 0)
          operator delete(a23);
        if (a34 < 0)
          operator delete(a29);
        MEMORY[0x1A858F2D8](&a35);
        if (a42 < 0)
          operator delete(a37);
        _Unwind_Resume(a1);
      }
LABEL_8:
      operator delete(a10);
      goto LABEL_9;
    }
  }
  else if (a49 < 0)
  {
    goto LABEL_5;
  }
  if ((a15 & 0x80000000) == 0)
    goto LABEL_9;
  goto LABEL_8;
}

void CoredumpTrace::loadRawCrashReport_sync(uint64_t a1, xpc_object_t *a2, uint64_t a3)
{
  void *v5;
  size_t v6;
  void *v7;
  const char *v8;
  xpc_object_t v9;
  xpc_object_t v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  xpc_object_t v14;
  xpc_object_t v15;
  void *__p[2];
  int64_t v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;

  v18 = 0;
  v19 = 0;
  v20 = 0;
  if (support::fs::loadFile(a1 + 200, (uint64_t)&v18))
  {
    v5 = v18;
    v6 = v19 - (_BYTE *)v18;
    if ((unint64_t)(v19 - (_BYTE *)v18) >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v6 >= 0x17)
    {
      v11 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17)
        v11 = v6 | 7;
      v12 = v11 + 1;
      v7 = operator new(v11 + 1);
      __p[1] = (void *)v6;
      v17 = v12 | 0x8000000000000000;
      __p[0] = v7;
    }
    else
    {
      HIBYTE(v17) = (_BYTE)v19 - (_BYTE)v18;
      v7 = __p;
      if (v19 == v18)
        goto LABEL_16;
    }
    memmove(v7, v5, v6);
LABEL_16:
    *((_BYTE *)v7 + v6) = 0;
    if (v17 >= 0)
      v13 = __p;
    else
      v13 = (void **)__p[0];
    v14 = xpc_string_create((const char *)v13);
    if (!v14)
      v14 = xpc_null_create();
    xpc_dictionary_set_value(*a2, "fullreport", v14);
    v15 = xpc_null_create();
    xpc_release(v14);
    xpc_release(v15);
    if (SHIBYTE(v17) < 0)
      operator delete(__p[0]);
    goto LABEL_23;
  }
  if (*(char *)(a3 + 23) >= 0)
    v8 = (const char *)a3;
  else
    v8 = *(const char **)a3;
  v9 = xpc_string_create(v8);
  if (!v9)
    v9 = xpc_null_create();
  xpc_dictionary_set_value(*a2, "ioerror", v9);
  v10 = xpc_null_create();
  xpc_release(v9);
  xpc_release(v10);
LABEL_23:
  if (v18)
  {
    v19 = v18;
    operator delete(v18);
  }
}

void sub_1A34B6DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CoredumpTrace::parseCrashReason_sync(CoredumpTrace *this@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4;
  NSObject *v5;
  _QWORD *v6;
  const char *v7;
  _QWORD *v8;
  timespec v9;
  const char *v10;
  NSObject *v11;
  xpc_object_t v12;
  xpc_object_t v13;
  void *v14;
  void *v15;
  ctu *v16;
  const void *v17;
  xpc_object_t v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  xpc_object_t v23;
  xpc_object_t v24;
  std::string *v25;
  __int128 v26;
  const char *p_buf;
  xpc_object_t v28;
  xpc_object_t v29;
  void *v30;
  NSObject *v31;
  uint64_t v32;
  xpc_object_t v33;
  xpc_object_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  xpc_object_t v40;
  xpc_object_t v41;
  NSObject *v42;
  uint64_t v43;
  xpc_object_t v44;
  xpc_object_t v45;
  std::string *v46;
  __int128 v47;
  xpc_object_t value;
  NSObject *v49;
  std::string *p_p;
  xpc_object_t v51;
  xpc_object_t v52;
  uint64_t v53;
  xpc_object_t v54;
  xpc_object_t v55;
  uint64_t v56;
  NSObject *v57;
  xpc_object_t v58;
  std::string *v59;
  xpc_object_t v60;
  xpc_object_t v61;
  timespec v62;
  xpc_object_t v63;
  xpc_object_t v64;
  xpc_object_t v65;
  std::string *v66;
  __int128 v67;
  std::string::size_type v68;
  std::string *v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  size_t v74;
  xpc_object_t v75;
  unint64_t v76;
  size_t v77;
  size_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  xpc_object_t v84;
  std::string::size_type size;
  std::string::size_type v86;
  _BYTE *v87;
  uint64_t tv_nsec;
  timespec *p_st_ctimespec;
  stat *v90;
  const void *tv_sec;
  uint64_t v92;
  uint64_t v93;
  std::string::size_type v94;
  xpc_object_t v95;
  std::string::size_type v96;
  std::string *v97;
  unint64_t first_not_of;
  unint64_t v99;
  unint64_t v100;
  uint64_t last_not_of;
  size_t v102;
  xpc_object_t v103;
  unint64_t v104;
  size_t v105;
  size_t v106;
  void *p_dst;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  void *v111;
  uint64_t v112;
  char st_gen;
  std::string::size_type v114;
  void *v115;
  timespec *p_tv_nsec;
  uint64_t v117;
  const void *v118;
  uint64_t v119;
  uint64_t v120;
  std::string *v121;
  xpc_object_t v122;
  xpc_object_t v123;
  uint64_t v124;
  void *v125;
  std::string::size_type v126;
  char v127;
  xpc_object_t __dst;
  unint64_t v129;
  int64_t v130;
  xpc_object_t v131;
  xpc_object_t v132;
  xpc_object_t xdict;
  void *v134;
  std::string __p;
  xpc_object_t object;
  stat buf;
  timespec v138;
  timespec v139;
  timespec v140;
  timespec v141;
  timespec v142;
  timespec v143;
  timespec v144;
  timespec v145;
  unint64_t v146;
  std::string v147;
  uint64_t v148;

  v148 = *MEMORY[0x1E0C80C00];
  object = xpc_null_create();
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v4 = xpc_null_create();
  *a2 = v4;
  memset(&__p, 0, sizeof(__p));
  v134 = 0;
  v5 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v6 = (_QWORD *)*v6;
    buf.st_dev = 136315138;
    *(_QWORD *)&buf.st_mode = v6;
    _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Looking for crash report file: %s", (uint8_t *)&buf, 0xCu);
  }
  v8 = (_QWORD *)((char *)this + 200);
  v7 = (const char *)*((_QWORD *)this + 25);
  v9.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v9.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&buf.st_blksize = v9;
  *(timespec *)buf.st_qspare = v9;
  buf.st_birthtimespec = v9;
  *(timespec *)&buf.st_size = v9;
  buf.st_mtimespec = v9;
  buf.st_ctimespec = v9;
  *(timespec *)&buf.st_uid = v9;
  buf.st_atimespec = v9;
  *(timespec *)&buf.st_dev = v9;
  if (*((char *)this + 223) >= 0)
    v10 = (char *)this + 200;
  else
    v10 = v7;
  if (!stat(v10, &buf))
  {
    if (*((char *)this + 223) < 0)
      v8 = (_QWORD *)*v8;
    v14 = (void *)objc_msgSend(MEMORY[0x1E0C99DB0], "inputStreamWithFileAtPath:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8));
    v15 = v14;
    if (v14)
    {
      objc_msgSend(v14, "open");
      v16 = (ctu *)objc_msgSend(MEMORY[0x1E0CB36D8], "JSONObjectWithStream:options:error:", v15, 0, &v134);
      if (v16)
      {
        ctu::cf_to_xpc(v16, v17);
        v18 = *(xpc_object_t *)&buf.st_dev;
        if (*(_QWORD *)&buf.st_dev && MEMORY[0x1A85902BC](*(_QWORD *)&buf.st_dev) == MEMORY[0x1E0C812F8])
          xpc_retain(v18);
        else
          v18 = xpc_null_create();
        v33 = xpc_null_create();
        v34 = object;
        object = v18;
        xpc_release(v34);
        xpc_release(v33);
        xpc_release(*(xpc_object_t *)&buf.st_dev);
        v35 = MEMORY[0x1A85902BC](object);
        v36 = MEMORY[0x1E0C812F8];
        if (v35 != MEMORY[0x1E0C812F8])
          goto LABEL_44;
        v42 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          xpc::object::to_string((xpc::object *)&object);
          v90 = (buf.st_gid & 0x80000000) == 0 ? &buf : *(stat **)&buf.st_dev;
          LODWORD(v147.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v147.__r_.__value_.__r.__words + 4) = (std::string::size_type)v90;
          _os_log_debug_impl(&dword_1A343C000, v42, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v147, 0xCu);
          if (SHIBYTE(buf.st_gid) < 0)
            operator delete(*(void **)&buf.st_dev);
        }
        xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&buf.st_dev = &object;
        buf.st_ino = (__darwin_ino64_t)"title";
        xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &xdict);
        v43 = MEMORY[0x1A85902BC](xdict);
        if (v43 == v36)
        {
          value = xpc_dictionary_get_value(xdict, "name");
          v132 = value;
          if (value)
            xpc_retain(value);
          else
            v132 = xpc_null_create();
          memset(&buf, 0, 24);
          xpc::dyn_cast_or_default();
          if (SHIBYTE(buf.st_gid) < 0)
            operator delete(*(void **)&buf.st_dev);
        }
        else
        {
          *((_BYTE *)&v147.__r_.__value_.__s + 23) = 7;
          strcpy((char *)&v147, "unknown");
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        __p = v147;
        *((_BYTE *)&v147.__r_.__value_.__s + 23) = 0;
        v147.__r_.__value_.__s.__data_[0] = 0;
        if (v43 == v36)
          xpc_release(v132);
        v49 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          buf.st_dev = 136315138;
          *(_QWORD *)&buf.st_mode = p_p;
          _os_log_impl(&dword_1A343C000, v49, OS_LOG_TYPE_DEFAULT, "#I Found crash '%s'", (uint8_t *)&buf, 0xCu);
        }
        v131 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        v51 = xpc_dictionary_get_value(object, "crash_details");
        v52 = v51;
        v53 = MEMORY[0x1E0C812C8];
        if (v51)
        {
          xpc_retain(v51);
          v131 = v52;
        }
        else
        {
          v52 = xpc_null_create();
          v131 = v52;
          if (!v52)
          {
            v54 = xpc_null_create();
            v52 = 0;
            goto LABEL_86;
          }
        }
        if (MEMORY[0x1A85902BC](v52) == v53)
        {
          xpc_retain(v52);
          goto LABEL_87;
        }
        v54 = xpc_null_create();
LABEL_86:
        v131 = v54;
LABEL_87:
        xpc_release(v52);
        if (MEMORY[0x1A85902BC](v131) == v53)
        {
          __dst = &v131;
          v129 = 0;
          xpc::array::object_proxy::operator xpc::dict((uint64_t)&__dst, &buf);
        }
        else
        {
          *(_QWORD *)&buf.st_dev = v4;
          if (v4)
            xpc_retain(v4);
          else
            *(_QWORD *)&buf.st_dev = xpc_null_create();
        }
        v55 = *(xpc_object_t *)&buf.st_dev;
        *(_QWORD *)&buf.st_dev = xpc_null_create();
        *a2 = v55;
        xpc_release(v4);
        xpc_release(*(xpc_object_t *)&buf.st_dev);
        v56 = MEMORY[0x1A85902BC](v55);
        if (v56 != v36)
        {
          v57 = *((_QWORD *)this + 5);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.st_dev) = 0;
            _os_log_impl(&dword_1A343C000, v57, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to unrecognized or missing system_details", (uint8_t *)&buf, 2u);
          }
          v58 = xpc_dictionary_create(0, 0, 0);
          if (v58 || (v58 = xpc_null_create()) != 0)
          {
            if (MEMORY[0x1A85902BC](v58) == v36)
            {
              xpc_retain(v58);
              v4 = v58;
            }
            else
            {
              v4 = xpc_null_create();
            }
          }
          else
          {
            v4 = xpc_null_create();
            v58 = 0;
          }
          xpc_release(v58);
          v64 = xpc_null_create();
          v65 = *a2;
          *a2 = v4;
          xpc_release(v65);
          xpc_release(v64);
          v147.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x40uLL);
          *(_OWORD *)&v147.__r_.__value_.__r.__words[1] = xmmword_1A3580C20;
          strcpy(v147.__r_.__value_.__l.__data_, "Coredump invalid, unrecognized or missing crash details: ");
          v66 = std::string::append(&v147, "report.json", 0xBuLL);
          v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
          *(_QWORD *)&buf.st_uid = *((_QWORD *)&v66->__r_.__value_.__l + 2);
          *(_OWORD *)&buf.st_dev = v67;
          v66->__r_.__value_.__l.__size_ = 0;
          v66->__r_.__value_.__r.__words[2] = 0;
          v66->__r_.__value_.__r.__words[0] = 0;
          CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
          if (SHIBYTE(buf.st_gid) < 0)
            operator delete(*(void **)&buf.st_dev);
          if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v147.__r_.__value_.__l.__data_);
          objc_msgSend(v15, "close");
          goto LABEL_245;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v59 = &__p;
        else
          v59 = (std::string *)__p.__r_.__value_.__r.__words[0];
        v60 = xpc_string_create((const char *)v59);
        if (!v60)
          v60 = xpc_null_create();
        xpc_dictionary_set_value(v55, "name", v60);
        v61 = xpc_null_create();
        xpc_release(v60);
        xpc_release(v61);
        v146 = 0xAAAAAAAAAAAAAAAALL;
        v62.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v62.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        v144 = v62;
        v145 = v62;
        v142 = v62;
        v143 = v62;
        v140 = v62;
        v141 = v62;
        v138 = v62;
        v139 = v62;
        *(timespec *)&buf.st_blksize = v62;
        *(timespec *)buf.st_qspare = v62;
        buf.st_birthtimespec = v62;
        *(timespec *)&buf.st_size = v62;
        buf.st_mtimespec = v62;
        buf.st_ctimespec = v62;
        *(timespec *)&buf.st_uid = v62;
        buf.st_atimespec = v62;
        *(timespec *)&buf.st_dev = v62;
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&buf);
        if (!xpc_dictionary_get_value(v55, "log_data"))
        {
LABEL_148:
          if (!xpc_dictionary_get_value(v55, "ucs_crash_id"))
            goto LABEL_217;
          v84 = xpc_dictionary_get_value(v55, "ucs_crash_id");
          __dst = v84;
          if (v84)
            xpc_retain(v84);
          else
            __dst = xpc_null_create();
          xpc::dyn_cast_or_default();
          if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v147.__r_.__value_.__r.__words[2]);
          else
            size = v147.__r_.__value_.__l.__size_;
          if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v147.__r_.__value_.__l.__data_);
          xpc_release(__dst);
          if (!size)
            goto LABEL_217;
          if ((buf.st_gen & 0x10) != 0)
          {
            tv_nsec = *(_QWORD *)&buf.st_blksize;
            if (*(_QWORD *)&buf.st_blksize < buf.st_ctimespec.tv_nsec)
            {
              *(_QWORD *)&buf.st_blksize = buf.st_ctimespec.tv_nsec;
              tv_nsec = buf.st_ctimespec.tv_nsec;
            }
            p_st_ctimespec = &buf.st_ctimespec;
          }
          else
          {
            if ((buf.st_gen & 8) == 0)
            {
              v86 = 0;
              *((_BYTE *)&v147.__r_.__value_.__s + 23) = 0;
              v87 = &v147;
              goto LABEL_178;
            }
            p_st_ctimespec = (timespec *)&buf.st_atimespec.tv_nsec;
            tv_nsec = buf.st_mtimespec.tv_nsec;
          }
          tv_sec = (const void *)p_st_ctimespec->tv_sec;
          v86 = tv_nsec - p_st_ctimespec->tv_sec;
          if (v86 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v86 >= 0x17)
          {
            v92 = (v86 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v86 | 7) != 0x17)
              v92 = v86 | 7;
            v93 = v92 + 1;
            v87 = operator new(v92 + 1);
            v147.__r_.__value_.__l.__size_ = v86;
            v147.__r_.__value_.__r.__words[2] = v93 | 0x8000000000000000;
            v147.__r_.__value_.__r.__words[0] = (std::string::size_type)v87;
          }
          else
          {
            *((_BYTE *)&v147.__r_.__value_.__s + 23) = tv_nsec - LOBYTE(p_st_ctimespec->tv_sec);
            v87 = &v147;
            if (!v86)
            {
LABEL_178:
              v87[v86] = 0;
              if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
              {
                v94 = v147.__r_.__value_.__l.__size_;
                operator delete(v147.__r_.__value_.__l.__data_);
                if (!v94)
                  goto LABEL_183;
              }
              else if (!*((_BYTE *)&v147.__r_.__value_.__s + 23))
              {
LABEL_183:
                memset(&v147, 170, sizeof(v147));
                v95 = xpc_dictionary_get_value(*a2, "ucs_crash_id");
                __dst = v95;
                if (v95)
                  xpc_retain(v95);
                else
                  __dst = xpc_null_create();
                xpc::dyn_cast_or_default();
                xpc_release(__dst);
                v96 = HIBYTE(v147.__r_.__value_.__r.__words[2]);
                v97 = &v147;
                if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                {
                  v96 = v147.__r_.__value_.__l.__size_;
                  v97 = (std::string *)v147.__r_.__value_.__r.__words[0];
                }
                v125 = v97;
                v126 = v96;
                first_not_of = ctu::llvm::StringRef::find_first_not_of();
                if (first_not_of >= v126)
                  v99 = v126;
                else
                  v99 = first_not_of;
                if (*MEMORY[0x1E0DE39A0] >= v126 - v99)
                  v100 = v126 - v99;
                else
                  v100 = *MEMORY[0x1E0DE39A0];
                __dst = (char *)v125 + v99;
                v129 = v100;
                last_not_of = ctu::llvm::StringRef::find_last_not_of();
                v103 = __dst;
                v102 = v129;
                if (last_not_of + 1 < v129)
                  v104 = last_not_of + 1;
                else
                  v104 = v129;
                v105 = v129 - v100 + v104;
                v129 = 0xAAAAAAAAAAAAAAAALL;
                v130 = 0xAAAAAAAAAAAAAAAALL;
                if (v105 >= v102)
                  v106 = v102;
                else
                  v106 = v105;
                __dst = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
                if (v106 > 0x7FFFFFFFFFFFFFF7)
                  std::string::__throw_length_error[abi:ne180100]();
                if (v106 >= 0x17)
                {
                  v108 = (v106 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v106 | 7) != 0x17)
                    v108 = v106 | 7;
                  v109 = v108 + 1;
                  p_dst = operator new(v108 + 1);
                  v129 = v106;
                  v130 = v109 | 0x8000000000000000;
                  __dst = p_dst;
                }
                else
                {
                  HIBYTE(v130) = v106;
                  p_dst = &__dst;
                  if (!v106)
                    goto LABEL_208;
                }
                memmove(p_dst, v103, v106);
LABEL_208:
                *((_BYTE *)p_dst + v106) = 0;
                v127 = 2;
                strcpy((char *)&v125, "c:");
                v110 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)&v125, 2);
                if (v130 >= 0)
                  v111 = &__dst;
                else
                  v111 = __dst;
                if (v130 >= 0)
                  v112 = HIBYTE(v130);
                else
                  v112 = v129;
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)v111, v112);
                if (v127 < 0)
                {
                  operator delete(v125);
                  if ((SHIBYTE(v130) & 0x80000000) == 0)
                  {
LABEL_216:
                    if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_217;
LABEL_223:
                    operator delete(v147.__r_.__value_.__l.__data_);
                    st_gen = buf.st_gen;
                    if ((buf.st_gen & 0x10) == 0)
                      goto LABEL_218;
                    goto LABEL_224;
                  }
                }
                else if ((SHIBYTE(v130) & 0x80000000) == 0)
                {
                  goto LABEL_216;
                }
                operator delete(__dst);
                if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
                  goto LABEL_223;
LABEL_217:
                st_gen = buf.st_gen;
                if ((buf.st_gen & 0x10) == 0)
                {
LABEL_218:
                  if ((st_gen & 8) == 0)
                  {
                    v114 = 0;
                    *((_BYTE *)&v147.__r_.__value_.__s + 23) = 0;
                    v115 = &v147;
                    goto LABEL_235;
                  }
                  p_tv_nsec = (timespec *)&buf.st_atimespec.tv_nsec;
                  v117 = buf.st_mtimespec.tv_nsec;
LABEL_227:
                  v118 = (const void *)p_tv_nsec->tv_sec;
                  v114 = v117 - p_tv_nsec->tv_sec;
                  if (v114 > 0x7FFFFFFFFFFFFFF7)
                    std::string::__throw_length_error[abi:ne180100]();
                  if (v114 >= 0x17)
                  {
                    v119 = (v114 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v114 | 7) != 0x17)
                      v119 = v114 | 7;
                    v120 = v119 + 1;
                    v115 = operator new(v119 + 1);
                    v147.__r_.__value_.__l.__size_ = v114;
                    v147.__r_.__value_.__r.__words[2] = v120 | 0x8000000000000000;
                    v147.__r_.__value_.__r.__words[0] = (std::string::size_type)v115;
                  }
                  else
                  {
                    *((_BYTE *)&v147.__r_.__value_.__s + 23) = v117 - LOBYTE(p_tv_nsec->tv_sec);
                    v115 = &v147;
                    if (!v114)
                      goto LABEL_235;
                  }
                  memmove(v115, v118, v114);
LABEL_235:
                  *((_BYTE *)v115 + v114) = 0;
                  if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    v121 = &v147;
                  else
                    v121 = (std::string *)v147.__r_.__value_.__r.__words[0];
                  v122 = xpc_string_create((const char *)v121);
                  if (!v122)
                    v122 = xpc_null_create();
                  v4 = *a2;
                  xpc_dictionary_set_value(*a2, "log_data", v122);
                  v123 = xpc_null_create();
                  xpc_release(v122);
                  xpc_release(v123);
                  if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v147.__r_.__value_.__l.__data_);
                  *(_QWORD *)&buf.st_dev = *MEMORY[0x1E0DE4F50];
                  v124 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
                  *(_QWORD *)((char *)&buf.st_dev + *(_QWORD *)(*(_QWORD *)&buf.st_dev - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
                  *(_QWORD *)&buf.st_uid = v124;
                  *(_QWORD *)&buf.st_rdev = MEMORY[0x1E0DE4FB8] + 16;
                  if (SHIBYTE(buf.st_blocks) < 0)
                    operator delete((void *)buf.st_birthtimespec.tv_nsec);
                  std::streambuf::~streambuf();
                  std::iostream::~basic_iostream();
                  MEMORY[0x1A858F92C](buf.st_qspare);
LABEL_245:
                  xpc_release(v131);
                  xpc_release(xdict);
                  if (v56 != v36)
                    goto LABEL_60;
LABEL_44:
                  v37 = MEMORY[0x1A85902BC](v4);
                  v38 = MEMORY[0x1E0C812F8];
                  if (v37 == MEMORY[0x1E0C812F8])
                    goto LABEL_58;
                  v39 = *((_QWORD *)this + 5);
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf.st_dev) = 0;
                    _os_log_impl(&dword_1A343C000, v39, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to processing errors", (uint8_t *)&buf, 2u);
                  }
                  v40 = xpc_dictionary_create(0, 0, 0);
                  if (v40 || (v40 = xpc_null_create()) != 0)
                  {
                    if (MEMORY[0x1A85902BC](v40) == v38)
                    {
                      xpc_retain(v40);
                      v41 = v40;
                    }
                    else
                    {
                      v41 = xpc_null_create();
                    }
                  }
                  else
                  {
                    v41 = xpc_null_create();
                    v40 = 0;
                  }
                  xpc_release(v40);
                  v44 = xpc_null_create();
                  v45 = *a2;
                  *a2 = v41;
                  xpc_release(v45);
                  xpc_release(v44);
                  v147.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
                  *(_OWORD *)&v147.__r_.__value_.__r.__words[1] = xmmword_1A3580C30;
                  strcpy(v147.__r_.__value_.__l.__data_, "Coredump invalid, file read error: ");
                  v46 = std::string::append(&v147, "report.json", 0xBuLL);
                  v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
                  *(_QWORD *)&buf.st_uid = *((_QWORD *)&v46->__r_.__value_.__l + 2);
                  *(_OWORD *)&buf.st_dev = v47;
                  v46->__r_.__value_.__l.__size_ = 0;
                  v46->__r_.__value_.__r.__words[2] = 0;
                  v46->__r_.__value_.__r.__words[0] = 0;
                  CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
                  if (SHIBYTE(buf.st_gid) < 0)
                  {
                    operator delete(*(void **)&buf.st_dev);
                    if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
LABEL_58:
                      if (!v15)
                        goto LABEL_60;
                      goto LABEL_59;
                    }
                  }
                  else if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
                    goto LABEL_58;
                  }
                  operator delete(v147.__r_.__value_.__l.__data_);
                  if (!v15)
                    goto LABEL_60;
LABEL_59:
                  objc_msgSend(v15, "close", v125);
                  goto LABEL_60;
                }
LABEL_224:
                v117 = *(_QWORD *)&buf.st_blksize;
                if (*(_QWORD *)&buf.st_blksize < buf.st_ctimespec.tv_nsec)
                {
                  *(_QWORD *)&buf.st_blksize = buf.st_ctimespec.tv_nsec;
                  v117 = buf.st_ctimespec.tv_nsec;
                }
                p_tv_nsec = &buf.st_ctimespec;
                goto LABEL_227;
              }
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)", ", 2);
              goto LABEL_183;
            }
          }
          memmove(v87, tv_sec, v86);
          goto LABEL_178;
        }
        memset(&v147, 170, sizeof(v147));
        v63 = xpc_dictionary_get_value(v55, "log_data");
        __dst = v63;
        if (v63)
          xpc_retain(v63);
        else
          __dst = xpc_null_create();
        xpc::dyn_cast_or_default();
        xpc_release(__dst);
        v68 = HIBYTE(v147.__r_.__value_.__r.__words[2]);
        v69 = &v147;
        if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v68 = v147.__r_.__value_.__l.__size_;
          v69 = (std::string *)v147.__r_.__value_.__r.__words[0];
        }
        v125 = v69;
        v126 = v68;
        v70 = ctu::llvm::StringRef::find_first_not_of();
        if (v70 >= v126)
          v71 = v126;
        else
          v71 = v70;
        if (*MEMORY[0x1E0DE39A0] >= v126 - v71)
          v72 = v126 - v71;
        else
          v72 = *MEMORY[0x1E0DE39A0];
        __dst = (char *)v125 + v71;
        v129 = v72;
        v73 = ctu::llvm::StringRef::find_last_not_of();
        v75 = __dst;
        v74 = v129;
        if (v73 + 1 < v129)
          v76 = v73 + 1;
        else
          v76 = v129;
        v77 = v129 - v72 + v76;
        v129 = 0xAAAAAAAAAAAAAAAALL;
        v130 = 0xAAAAAAAAAAAAAAAALL;
        if (v77 >= v74)
          v78 = v74;
        else
          v78 = v77;
        __dst = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        if (v78 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        if (v78 >= 0x17)
        {
          v80 = (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v78 | 7) != 0x17)
            v80 = v78 | 7;
          v81 = v80 + 1;
          v79 = operator new(v80 + 1);
          v129 = v78;
          v130 = v81 | 0x8000000000000000;
          __dst = v79;
        }
        else
        {
          HIBYTE(v130) = v78;
          v79 = &__dst;
          if (!v78)
            goto LABEL_137;
        }
        memmove(v79, v75, v78);
LABEL_137:
        *((_BYTE *)v79 + v78) = 0;
        if (v130 >= 0)
          v82 = &__dst;
        else
          v82 = __dst;
        if (v130 >= 0)
          v83 = HIBYTE(v130);
        else
          v83 = v129;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)v82, v83);
        if (SHIBYTE(v130) < 0)
          operator delete(__dst);
        if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v147.__r_.__value_.__l.__data_);
        v55 = *a2;
        goto LABEL_148;
      }
      v30 = v134;
      if (!v134)
        goto LABEL_44;
      v31 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      v32 = objc_msgSend((id)objc_msgSend(v30, "localizedDescription"), "UTF8String");
      buf.st_dev = 136315138;
      *(_QWORD *)&buf.st_mode = v32;
      v20 = "Error parsing file via return code: %s";
      v21 = v31;
      v22 = 12;
    }
    else
    {
      v19 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      LOWORD(buf.st_dev) = 0;
      v20 = "Error reading file";
      v21 = v19;
      v22 = 2;
    }
    _os_log_error_impl(&dword_1A343C000, v21, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&buf, v22);
    goto LABEL_44;
  }
  v11 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)this + 223) < 0)
      v8 = (_QWORD *)*v8;
    buf.st_dev = 136315138;
    *(_QWORD *)&buf.st_mode = v8;
    _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "File not found: %s", (uint8_t *)&buf, 0xCu);
  }
  v12 = xpc_dictionary_create(0, 0, 0);
  if (v12 || (v12 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v12) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(v12);
      v13 = v12;
    }
    else
    {
      v13 = xpc_null_create();
    }
  }
  else
  {
    v13 = xpc_null_create();
    v12 = 0;
  }
  xpc_release(v12);
  v23 = xpc_null_create();
  v24 = *a2;
  *a2 = v13;
  xpc_release(v24);
  xpc_release(v23);
  *((_BYTE *)&v147.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v147, "report.json");
  v25 = std::string::append(&v147, " missing", 8uLL);
  v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf.st_uid = *((_QWORD *)&v25->__r_.__value_.__l + 2);
  *(_OWORD *)&buf.st_dev = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((buf.st_gid & 0x80000000) == 0)
    p_buf = (const char *)&buf;
  else
    p_buf = *(const char **)&buf.st_dev;
  v28 = xpc_string_create(p_buf);
  if (!v28)
    v28 = xpc_null_create();
  xpc_dictionary_set_value(v13, "ioerror", v28);
  v29 = xpc_null_create();
  xpc_release(v28);
  xpc_release(v29);
  if (SHIBYTE(buf.st_gid) < 0)
  {
    operator delete(*(void **)&buf.st_dev);
    if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_60;
  }
  else if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_60;
  }
  operator delete(v147.__r_.__value_.__l.__data_);
LABEL_60:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  xpc_release(object);
}

void sub_1A34B7F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,xpc_object_t a22,xpc_object_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,xpc_object_t a31,__int128 buf)
{
  xpc_object_t *v32;
  uint64_t v33;
  void *v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&buf);
  xpc_release(object);
  xpc_release(a23);
  if (a2 == 2)
  {
    v36 = __cxa_begin_catch(a1);
    v37 = *(NSObject **)(v33 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      v38 = objc_msgSend((id)objc_msgSend(v36, "name"), "UTF8String");
      v39 = objc_msgSend((id)objc_msgSend(v36, "reason"), "UTF8String");
      LODWORD(buf) = 136315394;
      *(_QWORD *)((char *)&buf + 4) = v38;
      WORD6(buf) = 2080;
      *(_QWORD *)((char *)&buf + 14) = v39;
      _os_log_error_impl(&dword_1A343C000, v37, OS_LOG_TYPE_ERROR, "Error parsing file via exception: %s: %s", (uint8_t *)&buf, 0x16u);
    }
    __cxa_end_catch();
    JUMPOUT(0x1A34B71DCLL);
  }
  if (a30 < 0)
    operator delete(__p);
  xpc::dict::~dict(v32);
  xpc_release(a31);
  _Unwind_Resume(a1);
}

void xpc::array::object_proxy::operator xpc::dict(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  xpc_object_t value;
  xpc_object_t v4;
  xpc_object_t v5;

  value = xpc_array_get_value(**(xpc_object_t **)a1, *(_QWORD *)(a1 + 8));
  if (value)
  {
    v4 = value;
    xpc_retain(value);
    *a2 = v4;
  }
  else
  {
    v4 = xpc_null_create();
    *a2 = v4;
    if (!v4)
    {
      v5 = xpc_null_create();
      v4 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A85902BC](v4) != MEMORY[0x1E0C812F8])
  {
    v5 = xpc_null_create();
LABEL_8:
    *a2 = v5;
    goto LABEL_9;
  }
  xpc_retain(v4);
LABEL_9:
  xpc_release(v4);
}

uint64_t CoredumpTrace::makeCrashString@<X0>(xpc_object_t *a1@<X1>, _BYTE *a2@<X8>)
{
  __int128 v5;
  xpc_object_t value;
  xpc_object_t v7;
  __int128 *v8;
  std::string *p_p;
  std::string::size_type size;
  _QWORD *v11;
  xpc_object_t v12;
  std::string *v13;
  std::string::size_type v14;
  _QWORD *v15;
  _QWORD *v16;
  xpc_object_t v17;
  xpc_object_t *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  xpc_object_t v22;
  void **v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  xpc_object_t v27;
  void **v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  xpc_object_t v32;
  void **v33;
  uint64_t v34;
  size_t v35;
  uint64_t v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  xpc_object_t v43;
  void *v44[2];
  unsigned __int8 v45;
  xpc_object_t v46;
  void *v47[2];
  unsigned __int8 v48;
  xpc_object_t v49;
  void *v50[2];
  unsigned __int8 v51;
  xpc_object_t v52;
  xpc_object_t object[2];
  unsigned __int8 v54;
  xpc_object_t v55;
  std::string __p;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  void *v62[2];
  __int128 v63;
  __int128 v64;
  _OWORD v65[9];
  unint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;

  v66 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v65[7] = v5;
  v65[8] = v5;
  v65[5] = v5;
  v65[6] = v5;
  v65[3] = v5;
  v65[4] = v5;
  v65[1] = v5;
  v65[2] = v5;
  v64 = v5;
  v65[0] = v5;
  *(_OWORD *)v62 = v5;
  v63 = v5;
  v60 = v5;
  v61 = v5;
  v58 = v5;
  v59 = v5;
  v57 = v5;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v57);
  if (xpc_dictionary_get_value(*a1, "ioerror"))
  {
    memset(&__p, 170, sizeof(__p));
    value = xpc_dictionary_get_value(*a1, "ioerror");
    object[0] = value;
    if (value)
      xpc_retain(value);
    else
      object[0] = xpc_null_create();
    v67 = 0;
    v68 = 0;
    v69 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v69) < 0)
      operator delete(v67);
    xpc_release(object[0]);
    v8 = &v58;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
LABEL_27:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_93;
  }
  if (xpc_dictionary_get_value(*a1, "fullreport"))
  {
    memset(&__p, 170, sizeof(__p));
    v7 = xpc_dictionary_get_value(*a1, "fullreport");
    object[0] = v7;
    if (v7)
      xpc_retain(v7);
    else
      object[0] = xpc_null_create();
    v67 = 0;
    v68 = 0;
    v69 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v69) < 0)
      operator delete(v67);
    xpc_release(object[0]);
    util::strip_non_printable(&__p);
    v8 = (__int128 *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v58, (uint64_t)"RAW=", 4);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    goto LABEL_27;
  }
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v58, (uint64_t)"TASK=", 5);
  v12 = xpc_dictionary_get_value(*a1, "host_taskname");
  v55 = v12;
  if (v12)
    xpc_retain(v12);
  else
    v55 = xpc_null_create();
  v67 = 0;
  v68 = 0;
  v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0)
    operator delete(v67);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = &__p;
  else
    v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v14 = __p.__r_.__value_.__l.__size_;
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v13, v14);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" @ ", 3);
  v17 = xpc_dictionary_get_value(*a1, "host_filename");
  v52 = v17;
  if (v17)
    xpc_retain(v17);
  else
    v52 = xpc_null_create();
  v67 = 0;
  v68 = 0;
  v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0)
    operator delete(v67);
  if ((v54 & 0x80u) == 0)
    v18 = object;
  else
    v18 = (xpc_object_t *)object[0];
  if ((v54 & 0x80u) == 0)
    v19 = v54;
  else
    v19 = (uint64_t)object[1];
  v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v18, v19);
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)":", 1);
  v22 = xpc_dictionary_get_value(*a1, "host_line");
  v49 = v22;
  if (v22)
    xpc_retain(v22);
  else
    v49 = xpc_null_create();
  v67 = 0;
  v68 = 0;
  v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0)
    operator delete(v67);
  if ((v51 & 0x80u) == 0)
    v23 = v50;
  else
    v23 = (void **)v50[0];
  if ((v51 & 0x80u) == 0)
    v24 = v51;
  else
    v24 = (uint64_t)v50[1];
  v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v23, v24);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)",CPU=", 5);
  v27 = xpc_dictionary_get_value(*a1, "subsystem");
  v46 = v27;
  if (v27)
    xpc_retain(v27);
  else
    v46 = xpc_null_create();
  v67 = 0;
  v68 = 0;
  v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0)
    operator delete(v67);
  if ((v48 & 0x80u) == 0)
    v28 = v47;
  else
    v28 = (void **)v47[0];
  if ((v48 & 0x80u) == 0)
    v29 = v48;
  else
    v29 = (uint64_t)v47[1];
  v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)v28, v29);
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)",LOG=", 5);
  v32 = xpc_dictionary_get_value(*a1, "log_data");
  v43 = v32;
  if (v32)
    xpc_retain(v32);
  else
    v43 = xpc_null_create();
  v67 = 0;
  v68 = 0;
  v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0)
    operator delete(v67);
  if ((v45 & 0x80u) == 0)
    v33 = v44;
  else
    v33 = (void **)v44[0];
  if ((v45 & 0x80u) == 0)
    v34 = v45;
  else
    v34 = (uint64_t)v44[1];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)v33, v34);
  if ((char)v45 < 0)
    operator delete(v44[0]);
  xpc_release(v43);
  if ((char)v48 < 0)
    operator delete(v47[0]);
  xpc_release(v46);
  if ((char)v51 < 0)
    operator delete(v50[0]);
  xpc_release(v49);
  if ((char)v54 < 0)
    operator delete(object[0]);
  xpc_release(v52);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  xpc_release(v55);
LABEL_93:
  if ((BYTE8(v64) & 0x10) != 0)
  {
    v36 = v64;
    if ((unint64_t)v64 < *((_QWORD *)&v61 + 1))
    {
      *(_QWORD *)&v64 = *((_QWORD *)&v61 + 1);
      v36 = *((_QWORD *)&v61 + 1);
    }
    v37 = (const void *)v61;
    v35 = v36 - v61;
    if ((unint64_t)(v36 - v61) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_110;
  }
  else
  {
    if ((BYTE8(v64) & 8) == 0)
    {
      v35 = 0;
      a2[23] = 0;
      goto LABEL_106;
    }
    v37 = (const void *)*((_QWORD *)&v59 + 1);
    v35 = *((_QWORD *)&v60 + 1) - *((_QWORD *)&v59 + 1);
    if (*((_QWORD *)&v60 + 1) - *((_QWORD *)&v59 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_110:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v35 >= 0x17)
  {
    v38 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17)
      v38 = v35 | 7;
    v39 = v38 + 1;
    v40 = operator new(v38 + 1);
    *((_QWORD *)a2 + 1) = v35;
    *((_QWORD *)a2 + 2) = v39 | 0x8000000000000000;
    *(_QWORD *)a2 = v40;
    a2 = v40;
    goto LABEL_105;
  }
  a2[23] = v35;
  if (v35)
LABEL_105:
    memmove(a2, v37, v35);
LABEL_106:
  a2[v35] = 0;
  *(_QWORD *)&v57 = *MEMORY[0x1E0DE4F50];
  v41 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v57 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v58 = v41;
  *((_QWORD *)&v58 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v63) < 0)
    operator delete(v62[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A858F92C](v65);
}

void sub_1A34B89DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,xpc_object_t a30,xpc_object_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,xpc_object_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  if (a15 < 0)
    operator delete(__p);
  xpc_release(object);
  if (a22 < 0)
    operator delete(a17);
  xpc_release(a16);
  if (a29 < 0)
    operator delete(a24);
  xpc_release(a23);
  if (a36 < 0)
    operator delete(a31);
  xpc_release(a30);
  if (a43 < 0)
    operator delete(a38);
  xpc_release(a37);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void CoredumpTrace::~CoredumpTrace(CoredumpTrace *this)
{
  void *v1;

  CoredumpTrace::~CoredumpTrace(this);
  operator delete(v1);
}

{
  NSObject *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  *(_QWORD *)this = off_1E4A095E0;
  v2 = *((_QWORD *)this + 28);
  if (v2)
    dispatch_release(v2);
  if (*((char *)this + 223) < 0)
  {
    operator delete(*((void **)this + 25));
    if ((*((char *)this + 199) & 0x80000000) == 0)
    {
LABEL_5:
      v3 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
      if (!v3)
        goto LABEL_6;
      goto LABEL_10;
    }
  }
  else if ((*((char *)this + 199) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*((void **)this + 22));
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  if (!v3)
    goto LABEL_6;
LABEL_10:
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    Trace::~Trace(this);
    return;
  }
LABEL_6:
  Trace::~Trace(this);
}

uint64_t ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  pthread_mutex_lock((pthread_mutex_t *)a1);
  v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v5)
    return a1;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

_QWORD *std::shared_ptr<CoredumpTrace>::shared_ptr[abi:ne180100]<CoredumpTrace,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1},void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09840;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2)
    return a1;
  v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      return a1;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A34B8E54(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1}::operator() const(CoredumpTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A34B8E74(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<CoredumpTrace *,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace *)#1},std::allocator<CoredumpTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<CoredumpTrace *,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace *)#1},std::allocator<CoredumpTrace>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1}::operator() const(CoredumpTrace*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<CoredumpTrace *,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace *)#1},std::allocator<CoredumpTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_p"
                                "trIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1}::operator() const(CoredumpTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<ABMProperties *,std::shared_ptr<ABMProperties>::__shared_ptr_default_delete<ABMProperties,ABMProperties>,std::allocator<ABMProperties>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<ABMProperties *,std::shared_ptr<ABMProperties>::__shared_ptr_default_delete<ABMProperties,ABMProperties>,std::allocator<ABMProperties>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  if (*(_QWORD *)(a1 + 24))
  {
    v1 = (void *)MEMORY[0x1A858F2F0]();
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<ABMProperties *,std::shared_ptr<ABMProperties>::__shared_ptr_default_delete<ABMProperties,ABMProperties>,std::allocator<ABMProperties>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001A3580DF2)
    return a1 + 24;
  if (((v3 & 0x80000001A3580DF2 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A3580DF2))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A3580DF2 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

uint64_t ctu::PthreadMutexGuardPolicy<ABMProperties>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  pthread_mutex_lock((pthread_mutex_t *)a1);
  v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v5)
    return a1;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

uint64_t __cxx_global_var_init_70()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t __cxx_global_var_init_71()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<CommandDriverFactory>::~PthreadMutexGuardPolicy, &ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t __cxx_global_var_init_72()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ABMProperties>::~PthreadMutexGuardPolicy, &ctu::Singleton<ABMProperties,ABMProperties,ctu::PthreadMutexGuardPolicy<ABMProperties>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t support::transport::ARI::getLogClient(support::transport::ARI *this)
{
  return (uint64_t)this + 32;
}

BOOL support::transport::ARI::initRT(support::transport::ARI *this, char *__s, dispatch_queue_s *a3)
{
  size_t v6;
  std::string::size_type v7;
  std::string *v8;
  uint64_t v9;
  uint64_t v10;
  std::string *v11;
  __int128 v12;
  void **v13;
  std::string::size_type v14;
  std::string *v15;
  AriHost *v16;
  NSObject *v17;
  _OWORD *v18;
  _QWORD *v19;
  int v20;
  int v21;
  void *v22;
  _BOOL8 v23;
  support::log::manager *v25;
  support::log::buffer *v26;
  int v27;
  support::log::manager *v28;
  support::log::buffer *v29;
  int v30;
  support::log::buffer *v31;
  int v32;
  support::log::buffer *v33;
  int v34;
  support::log::manager *v35;
  support::log::buffer *v36;
  int v37;
  support::log::buffer *v38;
  int v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  char *v45;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  char v47;
  std::string __dst;
  void *__p[2];
  char *v50;
  std::string *p_dst;
  std::string v52;

  strcpy((char *)&v52, "com.apple.ARITransport");
  *((_BYTE *)&v52.__r_.__value_.__s + 23) = 22;
  if (!__s || !*__s)
  {
    v25 = (support::log::manager *)*((_QWORD *)this + 13);
    LOBYTE(rep) = 1;
    v26 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v25 + 16))(v25, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v26)
    {
      if (*((_QWORD *)v25 + 17))
      {
        support::log::buffer::borrow(v26);
        v27 = 2;
      }
      else
      {
        v27 = 0;
      }
      if (v27 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v40 = _os_log_send_and_compose_impl();
        if (v40)
        {
          v41 = (char *)v40;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = off_1E4A09968;
          __p[1] = (char *)this + 40;
          v50 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v25, (const support::log::details *)__p, v41);
        }
      }
    }
    goto LABEL_75;
  }
  v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    v8 = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    goto LABEL_10;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v6;
  v8 = &__dst;
  if (v6)
LABEL_10:
    memcpy(v8, __s, v7);
  v8->__r_.__value_.__s.__data_[v7] = 0;
  v11 = std::string::insert(&__dst, 0, ".", 1uLL);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v50 = (char *)v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v50) >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  if (SHIBYTE(v50) >= 0)
    v14 = HIBYTE(v50);
  else
    v14 = (std::string::size_type)__p[1];
  std::string::append(&v52, (const std::string::value_type *)v13, v14);
  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_19;
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_19:
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = &v52;
  else
    v15 = (std::string *)v52.__r_.__value_.__r.__words[0];
  v16 = (AriHost *)dispatch_queue_create((const char *)v15, 0);
  v17 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v16;
  if (v17)
  {
    dispatch_release(v17);
    v16 = (AriHost *)*((_QWORD *)this + 1);
  }
  if (!v16)
  {
    v28 = (support::log::manager *)*((_QWORD *)this + 13);
    LOBYTE(rep) = 1;
    v29 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v28 + 16))(v28, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v29)
    {
      if (*((_QWORD *)v28 + 17))
      {
        support::log::buffer::borrow(v29);
        v30 = 2;
      }
      else
      {
        v30 = 0;
      }
      if (v30 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v42 = _os_log_send_and_compose_impl();
        if (v42)
          goto LABEL_74;
      }
    }
    goto LABEL_75;
  }
  if (AriHost::Init(v16))
  {
    v28 = (support::log::manager *)*((_QWORD *)this + 13);
    LOBYTE(rep) = 1;
    v31 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v28 + 16))(v28, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v31)
    {
      if (*((_QWORD *)v28 + 17))
      {
        support::log::buffer::borrow(v31);
        v32 = 2;
      }
      else
      {
        v32 = 0;
      }
      if (v32 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v42 = _os_log_send_and_compose_impl();
        if (v42)
          goto LABEL_74;
      }
    }
    goto LABEL_75;
  }
  if (AriHost::RegisterClient((AriHost *)__s, (const char *)this + 16, *((int **)this + 1), a3))
  {
    v28 = (support::log::manager *)*((_QWORD *)this + 13);
    LOBYTE(rep) = 1;
    v33 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v28 + 16))(v28, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v33)
    {
      if (*((_QWORD *)v28 + 17))
      {
        support::log::buffer::borrow(v33);
        v34 = 2;
      }
      else
      {
        v34 = 0;
      }
      if (v34 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v42 = _os_log_send_and_compose_impl();
        if (v42)
        {
LABEL_74:
          v43 = (char *)v42;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = off_1E4A09968;
          __p[1] = (char *)this + 40;
          v50 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v28, (const support::log::details *)__p, v43);
        }
      }
    }
LABEL_75:
    v23 = 0;
    if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v23;
    goto LABEL_39;
  }
  v18 = operator new(0x20uLL);
  *v18 = 0u;
  v18[1] = 0u;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
  if ((KTLInitOptions() & 1) != 0)
  {
    if ((KTLOpenChannel() & 1) != 0)
    {
      __dst.__r_.__value_.__r.__words[0] = 0;
      v19 = (_QWORD *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = v18;
      if (!v19)
      {
        v23 = 1;
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_39;
        return v23;
      }
      if (v19[1])
      {
        TelephonyUtilTransportFree();
        v20 = 0;
        v21 = 0;
        v22 = (void *)v19[1];
        if (!v22)
          goto LABEL_38;
        goto LABEL_32;
      }
      v21 = 0;
      goto LABEL_38;
    }
    v35 = (support::log::manager *)*((_QWORD *)this + 13);
    v47 = 1;
    v38 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v35 + 16))(v35, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v38)
    {
      if (*((_QWORD *)v35 + 17))
      {
        support::log::buffer::borrow(v38);
        v39 = 2;
      }
      else
      {
        v39 = 0;
      }
      if (v39 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v44 = _os_log_send_and_compose_impl();
        if (v44)
          goto LABEL_84;
      }
    }
  }
  else
  {
    v35 = (support::log::manager *)*((_QWORD *)this + 13);
    v47 = 1;
    v36 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v35 + 16))(v35, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v36)
    {
      if (*((_QWORD *)v35 + 17))
      {
        support::log::buffer::borrow(v36);
        v37 = 2;
      }
      else
      {
        v37 = 0;
      }
      if (v37 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v44 = _os_log_send_and_compose_impl();
        if (v44)
        {
LABEL_84:
          v45 = (char *)v44;
          rep = std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = off_1E4A09968;
          __p[1] = (char *)this + 40;
          v50 = &v47;
          p_dst = (std::string *)&rep;
          support::log::manager::message_delegates(v35, (const support::log::details *)__p, v45);
        }
      }
    }
  }
  __dst.__r_.__value_.__r.__words[0] = 0;
  if (*((_QWORD *)v18 + 1))
  {
    TelephonyUtilTransportFree();
    v22 = (void *)*((_QWORD *)v18 + 1);
    v20 = 8;
    v19 = v18;
    v21 = 8;
    if (v22)
    {
LABEL_32:
      operator delete(v22);
      v21 = v20;
    }
  }
  else
  {
    v21 = 8;
    v19 = v18;
  }
LABEL_38:
  operator delete(v19);
  v23 = v21 == 0;
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
    operator delete(v52.__r_.__value_.__l.__data_);
  return v23;
}

void sub_1A34B99B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100]((_QWORD **)&a14);
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

_QWORD **std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](_QWORD **a1)
{
  _QWORD *v2;
  void *v3;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (v2[1])
    {
      TelephonyUtilTransportFree();
      v3 = (void *)v2[1];
      if (v3)
        operator delete(v3);
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t support::transport::ARI::initLibTU(support::transport::ARI *this, const char *__s, int a3)
{
  size_t v6;
  std::string::size_type v7;
  std::string *v8;
  uint64_t v9;
  uint64_t v10;
  std::string *v11;
  __int128 v12;
  void **v13;
  std::string::size_type v14;
  std::string *v15;
  dispatch_queue_t v16;
  NSObject *v17;
  uint64_t v18;
  _OWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  support::log::manager *v24;
  support::log::buffer *v25;
  int v26;
  support::log::manager *v27;
  support::log::buffer *v28;
  int v29;
  support::log::manager *v30;
  support::log::buffer *v31;
  int v32;
  support::log::manager *v33;
  support::log::buffer *v34;
  int v35;
  support::log::buffer *v36;
  int v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  char *v45;
  void *v46;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  char v48;
  _QWORD v49[5];
  std::string __dst;
  void *__p[2];
  char *v52;
  std::string *p_dst;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  std::string v60;

  strcpy((char *)&v60, "com.apple.ARITransport");
  *((_BYTE *)&v60.__r_.__value_.__s + 23) = 22;
  v59 = 0;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v54 = 0u;
  if (!__s || !*__s)
  {
    v24 = (support::log::manager *)*((_QWORD *)this + 13);
    LOBYTE(rep) = 1;
    v25 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v24 + 16))(v24, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v25)
    {
      if (*((_QWORD *)v24 + 17))
      {
        support::log::buffer::borrow(v25);
        v26 = 2;
      }
      else
      {
        v26 = 0;
      }
      if (v26 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v38 = _os_log_send_and_compose_impl();
        if (v38)
        {
          v39 = (char *)v38;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = off_1E4A09968;
          __p[1] = (char *)this + 40;
          v52 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v24, (const support::log::details *)__p, v39);
        }
      }
    }
LABEL_78:
    v22 = 0;
    if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v22;
    goto LABEL_37;
  }
  v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    v8 = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    goto LABEL_10;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v6;
  v8 = &__dst;
  if (v6)
LABEL_10:
    memcpy(v8, __s, v7);
  v8->__r_.__value_.__s.__data_[v7] = 0;
  v11 = std::string::insert(&__dst, 0, ".", 1uLL);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v52 = (char *)v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v52) >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  if (SHIBYTE(v52) >= 0)
    v14 = HIBYTE(v52);
  else
    v14 = (std::string::size_type)__p[1];
  std::string::append(&v60, (const std::string::value_type *)v13, v14);
  if (SHIBYTE(v52) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_19;
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_19:
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = &v60;
  else
    v15 = (std::string *)v60.__r_.__value_.__r.__words[0];
  v16 = dispatch_queue_create((const char *)v15, 0);
  v17 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v16;
  if (v17)
  {
    dispatch_release(v17);
    v16 = (dispatch_queue_t)*((_QWORD *)this + 1);
  }
  if (!v16)
  {
    v27 = (support::log::manager *)*((_QWORD *)this + 13);
    LOBYTE(rep) = 1;
    v28 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v27 + 16))(v27, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v28)
    {
      if (*((_QWORD *)v27 + 17))
      {
        support::log::buffer::borrow(v28);
        v29 = 2;
      }
      else
      {
        v29 = 0;
      }
      if (v29 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v40 = _os_log_send_and_compose_impl();
        if (v40)
        {
          v41 = (char *)v40;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = off_1E4A09968;
          __p[1] = (char *)this + 40;
          v52 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v27, (const support::log::details *)__p, v41);
        }
      }
    }
    goto LABEL_78;
  }
  TelephonyBasebandPCITransportInitParameters();
  v18 = *((_QWORD *)this + 1);
  DWORD2(v55) = a3;
  LODWORD(v56) = v56 | 1;
  LODWORD(v54) = 8;
  v49[0] = MEMORY[0x1E0C809B0];
  v49[1] = 0x40000000;
  v49[2] = ___ZN7support9transport3ARI9initLibTUEPKcjj_block_invoke;
  v49[3] = &__block_descriptor_tmp_8;
  v49[4] = this;
  __dst.__r_.__value_.__r.__words[0] = 0;
  *((_QWORD *)&v54 + 1) = v18;
  *(_QWORD *)&v55 = v49;
  operator new(0x58uLL);
  if ((TelephonyBasebandPCITransportCreate() & 1) == 0)
  {
    v30 = (support::log::manager *)*((_QWORD *)this + 13);
    v48 = 1;
    v31 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v30 + 16))(v30, 1, **((_QWORD **)this + 10));
    if ((_DWORD)v31)
    {
      if (*((_QWORD *)v30 + 17))
      {
        support::log::buffer::borrow(v31);
        v32 = 2;
      }
      else
      {
        v32 = 0;
      }
      if (v32 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        v42 = _os_log_send_and_compose_impl();
        if (v42)
        {
          v43 = (char *)v42;
          rep = std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = off_1E4A09968;
          __p[1] = (char *)this + 40;
          v52 = &v48;
          p_dst = (std::string *)&rep;
          support::log::manager::message_delegates(v30, (const support::log::details *)__p, v43);
        }
      }
    }
    goto LABEL_78;
  }
  v19 = operator new(0x20uLL);
  *v19 = 0u;
  v19[1] = 0u;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
  if ((KTLInitOptions() & 1) == 0)
  {
    v33 = (support::log::manager *)*((_QWORD *)this + 13);
    v48 = 1;
    v34 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v33 + 16))(v33, 1, **((_QWORD **)this + 10));
    if (!(_DWORD)v34)
      goto LABEL_74;
    if (*((_QWORD *)v33 + 17))
    {
      support::log::buffer::borrow(v34);
      v35 = 2;
    }
    else
    {
      v35 = 0;
    }
    if (!(v35 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR)))
      goto LABEL_74;
    LOWORD(__p[0]) = 0;
    v44 = _os_log_send_and_compose_impl();
    if (!v44)
      goto LABEL_74;
LABEL_73:
    v45 = (char *)v44;
    rep = std::chrono::system_clock::now().__d_.__rep_;
    __p[0] = off_1E4A09968;
    __p[1] = (char *)this + 40;
    v52 = &v48;
    p_dst = (std::string *)&rep;
    support::log::manager::message_delegates(v33, (const support::log::details *)__p, v45);
LABEL_74:
    __dst.__r_.__value_.__r.__words[0] = 0;
    if (*((_QWORD *)v19 + 1))
    {
      TelephonyUtilTransportFree();
      v46 = (void *)*((_QWORD *)v19 + 1);
      if (v46)
        operator delete(v46);
    }
    operator delete(v19);
    goto LABEL_78;
  }
  if ((KTLOpenChannel() & 1) == 0)
  {
    v33 = (support::log::manager *)*((_QWORD *)this + 13);
    v48 = 1;
    v36 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, _QWORD))(*(_QWORD *)v33 + 16))(v33, 1, **((_QWORD **)this + 10));
    if (!(_DWORD)v36)
      goto LABEL_74;
    if (*((_QWORD *)v33 + 17))
    {
      support::log::buffer::borrow(v36);
      v37 = 2;
    }
    else
    {
      v37 = 0;
    }
    if (!(v37 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR)))
      goto LABEL_74;
    LOWORD(__p[0]) = 0;
    v44 = _os_log_send_and_compose_impl();
    if (!v44)
      goto LABEL_74;
    goto LABEL_73;
  }
  __dst.__r_.__value_.__r.__words[0] = 0;
  v20 = (_QWORD *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v19;
  if (v20)
  {
    if (v20[1])
    {
      TelephonyUtilTransportFree();
      v21 = (void *)v20[1];
      if (v21)
        operator delete(v21);
    }
    operator delete(v20);
    v22 = 1;
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_37;
  }
  else
  {
    v22 = 1;
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
LABEL_37:
      operator delete(v60.__r_.__value_.__l.__data_);
  }
  return v22;
}

void sub_1A34BA288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v29;

  std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100]((_QWORD **)&a18);
  if (*(char *)(v29 - 73) < 0)
  {
    operator delete(*(void **)(v29 - 96));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void ___ZN7support9transport3ARI9initLibTUEPKcjj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  _QWORD *v4;
  support::log::buffer *v5;
  int v6;
  _QWORD *v7;
  support::log::buffer *v8;
  int v9;
  _QWORD *v10;
  support::log::buffer *v11;
  int v12;
  uint64_t v13;
  char *v14;
  std::chrono::system_clock::time_point v15;
  _QWORD *v16;
  uint64_t k;
  uint64_t v18;
  _QWORD *v19;
  uint64_t i;
  uint64_t v21;
  _QWORD *v22;
  uint64_t j;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  char v25;
  void (**v26)(support::log::details *__hidden);
  uint64_t v27;
  char *v28;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep *p_rep;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((_DWORD)a2 == 1)
  {
    v7 = *(_QWORD **)(v2 + 104);
    v25 = 1;
    v8 = (support::log::buffer *)(*(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v7 + 16))(v7, a2, **(_QWORD **)(v2 + 80));
    if ((_DWORD)v8)
    {
      if (v7[17])
      {
        v9 = 2;
        support::log::buffer::borrow(v8);
      }
      else
      {
        v9 = 0;
      }
      if (v9 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
      {
        LOWORD(v26) = 0;
        v18 = _os_log_send_and_compose_impl();
        if (v18)
        {
          v14 = (char *)v18;
          v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          rep = v15.__d_.__rep_;
          v26 = off_1E4A09968;
          v27 = v2 + 40;
          v28 = &v25;
          p_rep = &rep;
          v19 = v7 + 15;
          for (i = v7[16]; (_QWORD *)i != v19; i = *(_QWORD *)(i + 8))
            v15.__d_.__rep_ = (***(uint64_t (****)(_QWORD, void (***)(support::log::details *__hidden), char *))(i + 16))(*(_QWORD *)(i + 16), &v26, v14);
          goto LABEL_29;
        }
      }
    }
  }
  else
  {
    v3 = a2;
    if ((_DWORD)a2)
    {
      v10 = *(_QWORD **)(v2 + 104);
      v25 = 1;
      v11 = (support::log::buffer *)(*(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v10 + 16))(v10, 1, **(_QWORD **)(v2 + 80));
      if ((_DWORD)v11)
      {
        if (v10[17])
        {
          v12 = 2;
          support::log::buffer::borrow(v11);
        }
        else
        {
          v12 = 0;
        }
        if (v12 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
        {
          LODWORD(v26) = 67109120;
          HIDWORD(v26) = v3;
          v21 = _os_log_send_and_compose_impl();
          if (v21)
          {
            v14 = (char *)v21;
            v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
            rep = v15.__d_.__rep_;
            v26 = off_1E4A09968;
            v27 = v2 + 40;
            v28 = &v25;
            p_rep = &rep;
            v22 = v10 + 15;
            for (j = v10[16]; (_QWORD *)j != v22; j = *(_QWORD *)(j + 8))
              v15.__d_.__rep_ = (***(uint64_t (****)(_QWORD, void (***)(support::log::details *__hidden), char *))(j + 16))(*(_QWORD *)(j + 16), &v26, v14);
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      v4 = *(_QWORD **)(v2 + 104);
      v25 = 1;
      v5 = (support::log::buffer *)(*(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v4 + 16))(v4, 1, **(_QWORD **)(v2 + 80));
      if ((_DWORD)v5)
      {
        if (v4[17])
        {
          v6 = 2;
          support::log::buffer::borrow(v5);
        }
        else
        {
          v6 = 0;
        }
        if (v6 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
        {
          LOWORD(v26) = 0;
          v13 = _os_log_send_and_compose_impl();
          if (v13)
          {
            v14 = (char *)v13;
            v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
            rep = v15.__d_.__rep_;
            v26 = off_1E4A09968;
            v27 = v2 + 40;
            v28 = &v25;
            p_rep = &rep;
            v16 = v4 + 15;
            for (k = v4[16]; (_QWORD *)k != v16; k = *(_QWORD *)(k + 8))
              v15.__d_.__rep_ = (***(uint64_t (****)(_QWORD, void (***)(support::log::details *__hidden), char *))(k + 16))(*(_QWORD *)(k + 16), &v26, v14);
LABEL_29:
            support::log::manager::release_log_buffer((support::log::manager *)v15.__d_.__rep_, v14);
          }
        }
      }
    }
  }
}

uint64_t support::transport::ARI::getKTLOptions(support::transport::ARI *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t support::transport::ARI::getLibTUTransport(support::transport::ARI *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 3) + 8);
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, dispatch_queue_s *a2@<X1>, char a3@<W3>, const support::log::manager *a4@<X4>, support::transport::ARI **a5@<X8>)
{
  __int128 v11;
  support::transport::ARI *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  int isProcessRunning;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  support::log::manager *v20;
  support::log::buffer *v21;
  int v22;
  support::log::buffer *v23;
  int v24;
  support::log::buffer *v25;
  int v26;
  uint64_t v27;
  char *v28;
  void *v29[2];
  char *v30;
  _QWORD *v31;
  char v32;
  _QWORD v33[2];
  char v34;
  void *__p[2];
  char v36;
  void *v37;
  __int128 v38;
  _OWORD v39[3];
  __int128 v40;
  __int128 v41;

  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40 = v11;
  v41 = v11;
  v39[1] = v11;
  v39[2] = v11;
  v39[0] = v11;
  v37 = operator new(0x30uLL);
  v38 = xmmword_1A3580E40;
  strcpy((char *)v37, "com.apple.telephony.basebandservices.support");
  v36 = 10;
  strcpy((char *)__p, "ari.create");
  support::log::client::client(v39, (uint64_t)&v37, (uint64_t)__p, (uint64_t)a4);
  if (v36 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v38) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_10:
    operator delete(v37);
    goto LABEL_3;
  }
  if (SHIBYTE(v38) < 0)
    goto LABEL_10;
LABEL_3:
  *a5 = (support::transport::ARI *)0xAAAAAAAAAAAAAAAALL;
  v12 = (support::transport::ARI *)operator new(0x70uLL);
  support::transport::ARI::ARI(v12, a4);
  *a5 = v12;
  v13 = getprogname();
  if (!strncmp(v13, "CommCenter", 0xAuLL))
    goto LABEL_13;
  v14 = getprogname();
  if (!strncmp(v14, "CommCenter-asan", 0xFuLL))
    goto LABEL_13;
  v15 = getprogname();
  if (!strncmp(v15, "basebandd", 9uLL))
    goto LABEL_13;
  HIBYTE(v30) = 10;
  strcpy((char *)v29, "CommCenter");
  if ((ctu::isProcessRunning() & 1) == 0)
  {
    v34 = 9;
    strcpy((char *)v33, "basebandd");
    isProcessRunning = ctu::isProcessRunning();
    if (SHIBYTE(v30) < 0)
      goto LABEL_21;
    goto LABEL_12;
  }
  isProcessRunning = 1;
  if ((SHIBYTE(v30) & 0x80000000) == 0)
  {
LABEL_12:
    if (!isProcessRunning)
      goto LABEL_22;
LABEL_13:
    if ((a3 & 1) != 0)
    {
      if (support::transport::ARI::initRT(v12, (char *)this, a2))
        goto LABEL_15;
      v32 = 1;
      v20 = (support::log::manager *)*((_QWORD *)&v41 + 1);
      v25 = (support::log::buffer *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)&v41 + 1) + 16))(*((_QWORD *)&v41 + 1), 1, *(_QWORD *)v40);
      if (!(_DWORD)v25)
        goto LABEL_40;
      if (*((_QWORD *)v20 + 17))
      {
        support::log::buffer::borrow(v25);
        v26 = 2;
      }
      else
      {
        v26 = 0;
      }
      if (!(v26 | os_log_type_enabled(*(os_log_t *)v40, OS_LOG_TYPE_ERROR)))
        goto LABEL_40;
      LOWORD(v29[0]) = 0;
      v27 = _os_log_send_and_compose_impl();
      if (!v27)
        goto LABEL_40;
    }
    else
    {
      v32 = 1;
      v20 = (support::log::manager *)*((_QWORD *)&v41 + 1);
      v23 = (support::log::buffer *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)&v41 + 1) + 16))(*((_QWORD *)&v41 + 1), 1, *(_QWORD *)v40);
      if (!(_DWORD)v23)
        goto LABEL_40;
      if (*((_QWORD *)v20 + 17))
      {
        support::log::buffer::borrow(v23);
        v24 = 2;
      }
      else
      {
        v24 = 0;
      }
      if (!(v24 | os_log_type_enabled(*(os_log_t *)v40, OS_LOG_TYPE_ERROR)))
        goto LABEL_40;
      LOWORD(v29[0]) = 0;
      v27 = _os_log_send_and_compose_impl();
      if (!v27)
        goto LABEL_40;
    }
    goto LABEL_39;
  }
LABEL_21:
  operator delete(v29[0]);
  if (isProcessRunning)
    goto LABEL_13;
LABEL_22:
  if ((support::transport::ARI::initLibTU(v12, (const char *)this, (int)a2) & 1) != 0)
    goto LABEL_15;
  v32 = 1;
  v20 = (support::log::manager *)*((_QWORD *)&v41 + 1);
  v21 = (support::log::buffer *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)&v41 + 1) + 16))(*((_QWORD *)&v41 + 1), 1, *(_QWORD *)v40);
  if ((_DWORD)v21)
  {
    if (*((_QWORD *)v20 + 17))
    {
      support::log::buffer::borrow(v21);
      v22 = 2;
    }
    else
    {
      v22 = 0;
    }
    if (v22 | os_log_type_enabled(*(os_log_t *)v40, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v29[0]) = 0;
      v27 = _os_log_send_and_compose_impl();
      if (v27)
      {
LABEL_39:
        v28 = (char *)v27;
        v33[0] = std::chrono::system_clock::now().__d_.__rep_;
        v29[0] = off_1E4A09968;
        v29[1] = (char *)v39 + 8;
        v30 = &v32;
        v31 = v33;
        support::log::manager::message_delegates(v20, (const support::log::details *)v29, v28);
      }
    }
  }
LABEL_40:
  *a5 = 0;
  (*(void (**)(support::transport::ARI *))(*(_QWORD *)v12 + 8))(v12);
LABEL_15:
  *(_QWORD *)&v39[0] = &unk_1E4A09998;
  v17 = (std::__shared_weak_count *)v41;
  if ((_QWORD)v41)
  {
    v18 = (unint64_t *)(v41 + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1A34BAC90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  _QWORD *v37;
  uint64_t v38;

  *v37 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
  support::log::client::~client((support::log::client *)&a37);
  _Unwind_Resume(a1);
}

void support::log::client::~client(support::log::client *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  *(_QWORD *)this = &unk_1E4A09998;
  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  *(_QWORD *)this = &unk_1E4A09998;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    operator delete(this);
  }
  else
  {
LABEL_5:
    operator delete(this);
  }
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, dispatch_queue_s *a2@<X1>, const support::log::manager *a3@<X3>, support::transport::ARI **a4@<X8>)
{
  support::transport::ARI::create(this, a2, 0, a3, a4);
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, const char *a2@<X1>, const support::log::manager *a3@<X2>, support::transport::ARI **a4@<X8>)
{
  support::transport::ARI::create(this, (dispatch_queue_s *)0x2710, (char)a2, a3, a4);
}

support::transport::ARI *support::transport::ARI::ARI(support::transport::ARI *this, const support::log::manager *a2)
{
  void *__p;
  char v6;
  void *v7;
  __int128 v8;

  *(_QWORD *)this = off_1E4A09900;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  v7 = operator new(0x30uLL);
  v8 = xmmword_1A3580E40;
  strcpy((char *)v7, "com.apple.telephony.basebandservices.support");
  v6 = 3;
  LODWORD(__p) = 6910561;
  support::log::client::client((_QWORD *)this + 4, (uint64_t)&v7, (uint64_t)&__p, (uint64_t)a2);
  if (v6 < 0)
  {
    operator delete(__p);
    if ((SHIBYTE(v8) & 0x80000000) == 0)
      return this;
  }
  else if ((SHIBYTE(v8) & 0x80000000) == 0)
  {
    return this;
  }
  operator delete(v7);
  return this;
}

void sub_1A34BAED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  _QWORD **v21;
  NSObject *v23;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0)
    {
LABEL_3:
      std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](v21);
      v23 = *(NSObject **)(v20 + 8);
      if (!v23)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a20 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a15);
  std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](v21);
  v23 = *(NSObject **)(v20 + 8);
  if (!v23)
LABEL_4:
    _Unwind_Resume(a1);
LABEL_7:
  dispatch_release(v23);
  _Unwind_Resume(a1);
}

void support::transport::ARI::~ARI(support::transport::ARI *this)
{
  AriHost *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD *v6;
  void *v7;
  NSObject *v8;

  *(_QWORD *)this = off_1E4A09900;
  if (*((_QWORD *)this + 3))
    KTLCloseChannel();
  v2 = (AriHost *)*((unsigned int *)this + 4);
  if ((_DWORD)v2)
    AriHost::DeregisterClient(v2);
  *((_QWORD *)this + 4) = &unk_1E4A09998;
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 12);
  if (!v3)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    v6 = (_QWORD *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = 0;
    if (!v6)
      goto LABEL_14;
  }
  else
  {
LABEL_9:
    v6 = (_QWORD *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = 0;
    if (!v6)
      goto LABEL_14;
  }
  if (v6[1])
  {
    TelephonyUtilTransportFree();
    v7 = (void *)v6[1];
    if (v7)
      operator delete(v7);
  }
  operator delete(v6);
LABEL_14:
  v8 = *((_QWORD *)this + 1);
  if (v8)
    dispatch_release(v8);
}

{
  void *v1;

  support::transport::ARI::~ARI(this);
  operator delete(v1);
}

support::transport::ARI *support::transport::AriRT::AriRT(support::transport::AriRT *this, const support::log::manager *a2)
{
  support::transport::ARI *result;

  result = support::transport::ARI::ARI(this, a2);
  *(_QWORD *)result = off_1E4A09920;
  return result;
}

{
  support::transport::ARI *result;

  result = support::transport::ARI::ARI(this, a2);
  *(_QWORD *)result = off_1E4A09920;
  return result;
}

void support::transport::AriRT::create(support::transport::AriRT *this@<X0>, dispatch_queue_s *a2@<X1>, const support::log::manager *a3@<X3>, support::transport::ARI **a4@<X8>)
{
  __int128 v9;
  support::transport::ARI *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  support::log::manager *v14;
  support::log::buffer *v15;
  int v16;
  uint64_t v17;
  char *v18;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  _QWORD v20[5];
  char v21;
  void *__p[2];
  char v23;
  void *v24;
  __int128 v25;
  _OWORD v26[3];
  __int128 v27;
  __int128 v28;

  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v27 = v9;
  v28 = v9;
  v26[2] = v9;
  v26[0] = v9;
  v26[1] = v9;
  v24 = operator new(0x30uLL);
  v25 = xmmword_1A3580E40;
  strcpy((char *)v24, "com.apple.telephony.basebandservices.support");
  v23 = 13;
  strcpy((char *)__p, "ari.rt.create");
  support::log::client::client(v26, (uint64_t)&v24, (uint64_t)__p, (uint64_t)a3);
  if (v23 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v25) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((SHIBYTE(v25) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v24);
LABEL_3:
  *a4 = (support::transport::ARI *)0xAAAAAAAAAAAAAAAALL;
  v10 = (support::transport::ARI *)operator new(0x70uLL);
  support::transport::ARI::ARI(v10, a3);
  *(_QWORD *)v10 = off_1E4A09920;
  *a4 = v10;
  if (support::transport::ARI::initRT(v10, (char *)this, a2))
  {
    *(_QWORD *)&v26[0] = &unk_1E4A09998;
    v11 = (std::__shared_weak_count *)v28;
    if (!(_QWORD)v28)
      return;
    goto LABEL_5;
  }
  v21 = 1;
  v14 = (support::log::manager *)*((_QWORD *)&v28 + 1);
  v15 = (support::log::buffer *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)&v28 + 1) + 16))(*((_QWORD *)&v28 + 1), 1, *(_QWORD *)v27);
  if ((_DWORD)v15)
  {
    if (*((_QWORD *)v14 + 17))
    {
      support::log::buffer::borrow(v15);
      v16 = 2;
    }
    else
    {
      v16 = 0;
    }
    if (v16 | os_log_type_enabled(*(os_log_t *)v27, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20[0]) = 0;
      v17 = _os_log_send_and_compose_impl();
      if (v17)
      {
        v18 = (char *)v17;
        rep = std::chrono::system_clock::now().__d_.__rep_;
        v20[0] = off_1E4A09968;
        v20[1] = (char *)v26 + 8;
        v20[2] = &v21;
        v20[3] = &rep;
        support::log::manager::message_delegates(v14, (const support::log::details *)v20, v18);
      }
    }
  }
  *a4 = 0;
  (*(void (**)(support::transport::ARI *))(*(_QWORD *)v10 + 8))(v10);
  *(_QWORD *)&v26[0] = &unk_1E4A09998;
  v11 = (std::__shared_weak_count *)v28;
  if ((_QWORD)v28)
  {
LABEL_5:
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1A34BB324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  _QWORD *v17;
  uint64_t v18;
  va_list va;

  va_start(va, a17);
  *v17 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  support::log::client::~client((support::log::client *)va);
  _Unwind_Resume(a1);
}

void sub_1A34BB370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
    operator delete(__p);
  if (a30 < 0)
  {
    operator delete(a25);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A34BB368);
}

void support::transport::AriRT::create(support::transport::AriRT *this@<X0>, const support::log::manager *a2@<X1>, support::transport::ARI **a3@<X8>)
{
  support::transport::AriRT::create(this, (dispatch_queue_s *)0x2710, a2, a3);
}

void support::transport::AriRT::~AriRT(support::transport::AriRT *this)
{
  void *v1;

  support::transport::ARI::~ARI(this);
  operator delete(v1);
}

uint64_t __cxx_global_var_init_0()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t *GetOsLogContext(void)
{
  unsigned __int8 v0;

  {
    GetOsLogContext(void)::sOsLogContext = 0;
    qword_1ED114D18 = 0;
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
  }
  if (GetOsLogContext(void)::onceToken != -1)
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
  return &GetOsLogContext(void)::sOsLogContext;
}

void ___Z15GetOsLogContextv_block_invoke()
{
  _BYTE v0[16];

  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v0, "com.apple.telephony.abm", "global");
  ctu::OsLogContext::operator=();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v0);
}

void *GetGlobalLogger(uint64_t *a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD v10[5];
  std::__shared_weak_count *v11;

  if ((v2 & 1) == 0
  {
    MEMORY[0x1A858F1C4](&GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::sLogger);
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3788], &GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::sLogger, &dword_1A343C000);
  }
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 1174405120;
  v10[2] = ___Z15GetGlobalLoggerNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  v10[3] = &__block_descriptor_tmp_3;
  v3 = *a1;
  v4 = (std::__shared_weak_count *)a1[1];
  v10[4] = v3;
  v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  if (GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::onceToken != -1)
  {
    dispatch_once(&GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::onceToken, v10);
    v4 = v11;
    if (v11)
      goto LABEL_7;
    return &GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::sLogger;
  }
  if (!v4)
    return &GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::sLogger;
LABEL_7:
  v7 = (unint64_t *)&v4->__shared_owners_;
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (v8)
    return &GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::sLogger;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return &GetGlobalLogger(std::shared_ptr<ctu::LogServer>)::sLogger;
}

void sub_1A34BB6A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___Z15GetGlobalLoggerNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _BYTE v10[16];
  _BYTE v11[48];
  uint64_t v12;
  uint64_t v13;

  {
    GetOsLogContext(void)::sOsLogContext = 0;
    qword_1ED114D18 = 0;
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
  }
  if (GetOsLogContext(void)::onceToken != -1)
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v10, (const ctu::OsLogContext *)&GetOsLogContext(void)::sOsLogContext);
  MEMORY[0x1A858F1B8](v11, v10, a1 + 32);
  ctu::LoggerCommonBase::operator=();
  v4 = v12;
  v3 = v13;
  if (v13)
  {
    v5 = (unint64_t *)(v13 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)qword_1ED114CD0;
  qword_1ED114CC8 = v4;
  qword_1ED114CD0 = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  ctu::StaticLogger::~StaticLogger((ctu::StaticLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v10);
}

void sub_1A34BB7F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3ctu9LogServerEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3ctu9LogServerEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void ResetDetection::create(NSObject **a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  void *v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  dispatch_object_t object;

  *a4 = 0xAAAAAAAAAAAAAAAALL;
  a4[1] = 0xAAAAAAAAAAAAAAAALL;
  v8 = operator new(0xB8uLL);
  v9 = *a1;
  object = v9;
  if (v9)
    dispatch_retain(v9);
  v10 = (std::__shared_weak_count *)a2[1];
  v16 = *a2;
  v17 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  ResetDetection::ResetDetection((uint64_t)v8, &object, &v16, a3);
  *a4 = 0xAAAAAAAAAAAAAAAALL;
  a4[1] = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<ResetDetection>::shared_ptr[abi:ne180100]<ResetDetection,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1},void>(a4, (uint64_t)v8);
  ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*a4);
  v13 = v17;
  if (v17)
  {
    v14 = (unint64_t *)&v17->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (object)
    dispatch_release(object);
}

void sub_1A34BB98C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  NSObject *v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v2)
    dispatch_release(v2);
  _Unwind_Resume(a1);
}

uint64_t ResetDetection::ResetDetection(uint64_t a1, NSObject **a2, _QWORD *a3, uint64_t a4)
{
  NSObject *v8;
  _BYTE v10[16];

  *(_QWORD *)a1 = off_1E4A09A38;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v10, "com.apple.telephony.abm", "reset.detect");
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  v8 = *a2;
  *(_QWORD *)(a1 + 88) = *a2;
  if (v8)
    dispatch_retain(v8);
  *(_QWORD *)(a1 + 96) = 0;
  ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>&>((_QWORD *)a1, (uint64_t)v10, a3);
  *(_QWORD *)a1 = off_1E4A09C58;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v10);
  *(_QWORD *)a1 = off_1E4A09A38;
  *(_QWORD *)(a1 + 104) = a4;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = TelephonyBasebandCreateController();
  *(_DWORD *)(a1 + 128) = 2;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 136) = a1 + 144;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = a1 + 168;
  return a1;
}

void sub_1A34BBAC4(_Unwind_Exception *a1)
{
  _QWORD *v1;

  ctu::SharedLoggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(v1);
  _Unwind_Resume(a1);
}

void sub_1A34BBAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;

  ctu::SharedSynchronizable<diag::DIAGConfigurer>::~SharedSynchronizable(v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  _Unwind_Resume(a1);
}

const char *ResetDetection::getName(ResetDetection *this)
{
  return "reset.detect";
}

_QWORD *ctu::SharedLoggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A09BC8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A09BC8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void ResetDetection::~ResetDetection(ResetDetection *this)
{
  const void *v2;
  __CFRunLoop *v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  _QWORD block[5];

  *(_QWORD *)this = off_1E4A09A38;
  v2 = (const void *)*((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v2)
    CFRelease(v2);
  v3 = (__CFRunLoop *)*((_QWORD *)this + 13);
  v4 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  v5 = (const void *)*MEMORY[0x1E0C9B280];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN14ResetDetectionD2Ev_block_invoke;
  block[3] = &__block_descriptor_tmp_10;
  block[4] = v4;
  CFRunLoopPerformBlock(v3, v5, block);
  CFRunLoopWakeUp(*((CFRunLoopRef *)this + 13));
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*((char **)this + 21));
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*((char **)this + 18));
  v6 = (const void *)*((_QWORD *)this + 15);
  if (v6)
    CFRelease(v6);
  *(_QWORD *)this = off_1E4A09BC8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v7 = *((_QWORD *)this + 12);
  if (v7)
    dispatch_release(v7);
  v8 = *((_QWORD *)this + 11);
  if (v8)
    dispatch_release(v8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
}

{
  void *v1;

  ResetDetection::~ResetDetection(this);
  operator delete(v1);
}

void ___ZN14ResetDetectionD2Ev_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v2;

  v1 = *(_QWORD **)(a1 + 32);
  if (v1)
  {
    v2 = (std::__shared_weak_count *)v1[1];
    if (v2)
      std::__shared_weak_count::__release_weak(v2);
    operator delete(v1);
  }
}

void ResetDetection::start(ResetDetection *this)
{
  _QWORD v1[5];

  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 0x40000000;
  v1[2] = ___ZN14ResetDetection5startEv_block_invoke;
  v1[3] = &__block_descriptor_tmp_3_0;
  v1[4] = this;
  ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)this + 9, (uint64_t)v1);
}

void ___ZN14ResetDetection5startEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  NSObject *v12;
  uint64_t (*v13)(uint64_t);
  NSObject *v14;
  uint64_t (*v15)(uint64_t);
  uint8_t v16[16];
  uint8_t buf[16];
  uint8_t v18[15];
  unsigned __int8 v19;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Started", buf, 2u);
  }
  v3 = operator new(0x10uLL);
  v4 = *(std::__shared_weak_count **)(v1 + 80);
  if (!v4 || (v5 = *(_QWORD *)(v1 + 72), (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  *v3 = v5;
  v3[1] = v6;
  p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
  do
    v9 = __ldxr(p_shared_weak_owners);
  while (__stxr(v9 + 1, p_shared_weak_owners));
  *(_QWORD *)(v1 + 112) = v3;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (v11)
  {
    if ((TelephonyBasebandRegisterForReset() & 1) != 0)
      goto LABEL_14;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
    if ((TelephonyBasebandRegisterForReset() & 1) != 0)
      goto LABEL_14;
  }
  v12 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v16 = 0;
    _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "failed registering for reset detect", v16, 2u);
    v15 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
    if (!*(_QWORD *)(v1 + 120))
      v15 = 0;
    if (v15)
      goto LABEL_17;
    return;
  }
LABEL_14:
  v13 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  if (!*(_QWORD *)(v1 + 120))
    v13 = 0;
  if (v13)
  {
LABEL_17:
    v19 = 1;
    if ((TelephonyBasebandGetReset() & 1) != 0)
    {
      *(_DWORD *)(v1 + 128) = v19;
    }
    else
    {
      v14 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v18 = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "failed to poll for reset detect", v18, 2u);
      }
    }
  }
}

void sub_1A34BBEE8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void ResetDetection::sResetDetectCallback(ResetDetection *this, void *a2, int a3, unsigned int a4, void *a5)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD v14[5];
  int v15;

  if (this)
  {
    v5 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
    if (v5)
    {
      v7 = *(_QWORD *)this;
      p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
      do
        v9 = __ldxr(p_shared_weak_owners);
      while (__stxr(v9 + 1, p_shared_weak_owners));
      v10 = std::__shared_weak_count::lock(v5);
      if (v10)
      {
        v11 = v10;
        if (v7)
        {
          v14[0] = MEMORY[0x1E0C809B0];
          v14[1] = 0x40000000;
          v14[2] = ___ZN14ResetDetection19resetDetectCallbackEPvjjS0__block_invoke;
          v14[3] = &__block_descriptor_tmp_6_3;
          v14[4] = v7;
          v15 = a3;
          ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)(v7 + 72), (uint64_t)v14);
        }
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldaxr(p_shared_owners);
        while (__stlxr(v13 - 1, p_shared_owners));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t ResetDetection::poll(ResetDetection *this, BOOL *a2)
{
  uint64_t (*v3)(uint64_t);
  uint64_t Reset;
  NSObject *v7;
  uint8_t v8[15];
  BOOL v9;

  v3 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  if (!*((_QWORD *)this + 15))
    v3 = 0;
  if (!v3)
    return 0;
  v9 = 1;
  Reset = TelephonyBasebandGetReset();
  if ((_DWORD)Reset)
  {
    *a2 = v9;
    return Reset;
  }
  v7 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    return Reset;
  *(_WORD *)v8 = 0;
  _os_log_error_impl(&dword_1A343C000, v7, OS_LOG_TYPE_ERROR, "failed to poll for reset detect", v8, 2u);
  return Reset;
}

void ResetDetection::add(uint64_t a1, uint64_t a2, char a3, void **a4, uint64_t a5)
{
  void *v9;
  _QWORD v10[5];
  std::string __p;
  void *aBlock;
  uint64_t v13;
  char v14;

  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 1174405120;
  v10[2] = ___ZN14ResetDetection3addENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEbN8dispatch5blockIU13block_pointerFviEEEy_block_invoke;
  v10[3] = &__block_descriptor_tmp_4_0;
  v10[4] = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    v14 = a3;
    v9 = *a4;
    if (!*a4)
      goto LABEL_6;
    goto LABEL_5;
  }
  __p = *(std::string *)a2;
  v14 = a3;
  v9 = *a4;
  if (*a4)
LABEL_5:
    v9 = _Block_copy(v9);
LABEL_6:
  aBlock = v9;
  v13 = a5;
  ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)(a1 + 72), (uint64_t)v10);
  if (aBlock)
    _Block_release(aBlock);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void ___ZN14ResetDetection3addENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEbN8dispatch5blockIU13block_pointerFviEEEy_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  _BOOL4 v9;
  BOOL v10;
  BOOL v11;
  _OWORD *v13;
  int v14;
  const void *v15;
  void *v16;
  void *v17;
  const void *v18;
  void *v19;
  void *v20;
  std::string v21;
  void *v22;
  std::string v23;
  uint8_t buf[4];
  _QWORD *v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v4 = (_QWORD *)*v4;
    v5 = *(unsigned __int8 *)(a1 + 80);
    *(_DWORD *)buf = 136315394;
    v25 = v4;
    v26 = 1024;
    v27 = v5;
    _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Added detection with key '%s', reset=%d", buf, 0x12u);
  }
  v6 = *(_DWORD *)(v2 + 128);
  v7 = *(unsigned __int8 *)(a1 + 80);
  if (v6)
  {
    if (v6 != 2)
    {
      v8 = v6 != 1 || v7 == 0;
      v9 = !v8;
      v10 = v6 | v7 || v6 == 1;
      v11 = !v10 && v7 == 0;
      if (v11 || v9)
        goto LABEL_28;
    }
  }
  else if (!*(_BYTE *)(a1 + 80))
  {
LABEL_28:
    (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
    return;
  }
  v13 = (_OWORD *)(a1 + 40);
  v14 = *(char *)(a1 + 63);
  if (*(_BYTE *)(a1 + 80))
  {
    if (v14 < 0)
    {
      std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)(a1 + 40), *(_QWORD *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *v13;
      v23.__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 56);
    }
    v15 = *(const void **)(a1 + 64);
    if (v15)
      v16 = _Block_copy(v15);
    else
      v16 = 0;
    v22 = v16;
    ResetDetection::addToBlocks_sync(v2, (uint64_t)&v23, &v22, (uint64_t **)(v2 + 136), *(_QWORD *)(a1 + 72));
    if (v16)
      _Block_release(v16);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      v17 = (void *)v23.__r_.__value_.__r.__words[0];
LABEL_47:
      operator delete(v17);
    }
  }
  else
  {
    if (v14 < 0)
    {
      std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)(a1 + 40), *(_QWORD *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *v13;
      v21.__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 56);
    }
    v18 = *(const void **)(a1 + 64);
    if (v18)
      v19 = _Block_copy(v18);
    else
      v19 = 0;
    v20 = v19;
    ResetDetection::addToBlocks_sync(v2, (uint64_t)&v21, &v20, (uint64_t **)(v2 + 160), *(_QWORD *)(a1 + 72));
    if (v19)
      _Block_release(v19);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      v17 = (void *)v21.__r_.__value_.__r.__words[0];
      goto LABEL_47;
    }
  }
}

void sub_1A34BC3D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ResetDetection::addToBlocks_sync(uint64_t a1, uint64_t a2, void **a3, uint64_t **a4, dispatch_time_t a5)
{
  NSObject *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  unint64_t v19;
  void *v20;
  uint64_t *v21;
  uint64_t **v22;
  int v23;
  const std::string::value_type *v24;
  size_t v25;
  uint64_t **v26;
  _QWORD *v27;
  const void *v28;
  const void *v29;
  int v30;
  const void *v31;
  size_t v32;
  size_t v33;
  int v34;
  int v35;
  _QWORD *v36;
  std::string *v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t *v41;
  _QWORD handler[6];
  std::__shared_weak_count *v43;
  uint64_t **v44;
  std::string __p;

  v10 = dispatch_source_create(MEMORY[0x1E0C80DD0], 1uLL, 0, *(dispatch_queue_t *)(a1 + 88));
  dispatch_source_set_timer(v10, a5, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
  v11 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v11 || (v12 = *(_QWORD *)(a1 + 72), (v13 = std::__shared_weak_count::lock(v11)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v14 = v13;
  p_shared_weak_owners = (unint64_t *)&v13->__shared_weak_owners_;
  do
    v16 = __ldxr(p_shared_weak_owners);
  while (__stxr(v16 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v14);
  }
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 1174405120;
  handler[2] = ___ZN14ResetDetection16addToBlocks_syncENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN8dispatch5blockIU13block_pointerFviEEERNS0_3mapIS6_NS0_4pairIP17dispatch_source_sSB_EENS0_4lessIS6_EENS4_INSD_IKS6_SG_EEEEEEy_block_invoke;
  handler[3] = &__block_descriptor_tmp_5_0;
  handler[4] = a1;
  handler[5] = v12;
  v43 = v14;
  do
    v19 = __ldxr(p_shared_weak_owners);
  while (__stxr(v19 + 1, p_shared_weak_owners));
  v44 = a4;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  dispatch_source_set_event_handler(v10, handler);
  dispatch_activate(v10);
  v20 = *a3;
  if (*a3)
    v20 = _Block_copy(v20);
  v41 = (uint64_t *)v20;
  v22 = a4 + 1;
  v21 = a4[1];
  if (v21)
  {
    v23 = *(char *)(a2 + 23);
    if (v23 >= 0)
      v24 = (const std::string::value_type *)a2;
    else
      v24 = *(const std::string::value_type **)a2;
    if (v23 >= 0)
      v25 = *(unsigned __int8 *)(a2 + 23);
    else
      v25 = *(_QWORD *)(a2 + 8);
    while (1)
    {
      v26 = (uint64_t **)v21;
      v29 = (const void *)v21[4];
      v27 = v21 + 4;
      v28 = v29;
      v30 = *((char *)v27 + 23);
      if (v30 >= 0)
        v31 = v27;
      else
        v31 = v28;
      if (v30 >= 0)
        v32 = *((unsigned __int8 *)v27 + 23);
      else
        v32 = v27[1];
      if (v32 >= v25)
        v33 = v25;
      else
        v33 = v32;
      v34 = memcmp(v24, v31, v33);
      if (v34)
      {
        if (v34 < 0)
          goto LABEL_23;
LABEL_37:
        v35 = memcmp(v31, v24, v33);
        if (v35)
        {
          if ((v35 & 0x80000000) == 0)
            goto LABEL_51;
        }
        else if (v32 >= v25)
        {
LABEL_51:
          v40 = v26[8];
          v26[7] = (uint64_t *)v10;
          v26[8] = v41;
          if (v40)
            goto LABEL_52;
          goto LABEL_53;
        }
        v21 = v26[1];
        if (!v21)
        {
          v22 = v26 + 1;
          goto LABEL_44;
        }
      }
      else
      {
        if (v25 >= v32)
          goto LABEL_37;
LABEL_23:
        v21 = *v26;
        v22 = v26;
        if (!*v26)
          goto LABEL_44;
      }
    }
  }
  v26 = a4 + 1;
LABEL_44:
  v36 = operator new(0x48uLL);
  v37 = (std::string *)(v36 + 4);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v37, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v37->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v36[6] = *(_QWORD *)(a2 + 16);
  }
  v36[7] = 0;
  v36[8] = 0;
  *v36 = 0;
  v36[1] = 0;
  v36[2] = v26;
  *v22 = v36;
  v38 = (uint64_t *)**a4;
  v39 = v36;
  if (v38)
  {
    *a4 = v38;
    v39 = *v22;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a4[1], v39);
  a4[2] = (uint64_t *)((char *)a4[2] + 1);
  v40 = (uint64_t *)v36[8];
  v36[7] = v10;
  v36[8] = v41;
  if (v40)
LABEL_52:
    _Block_release(v40);
LABEL_53:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v43)
    std::__shared_weak_count::__release_weak(v43);
  std::__shared_weak_count::__release_weak(v14);
}

void sub_1A34BC760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::__shared_weak_count *v25;
  void *v26;
  std::__shared_weak_count *v28;

  operator delete(v26);
  std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>::~pair((uint64_t)&a10);
  if (a25 < 0)
  {
    operator delete(__p);
    v28 = a18;
    if (a18)
      goto LABEL_3;
  }
  else
  {
    v28 = a18;
    if (a18)
    {
LABEL_3:
      std::__shared_weak_count::__release_weak(v28);
      std::__shared_weak_count::__release_weak(v25);
      _Unwind_Resume(a1);
    }
  }
  std::__shared_weak_count::__release_weak(v25);
  _Unwind_Resume(a1);
}

void *__copy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE64c43_ZTSN8dispatch5blockIU13block_pointerFviEEE(uint64_t a1, uint64_t a2)
{
  std::string *v4;
  __int128 v5;
  void *result;

  v4 = (std::string *)(a1 + 40);
  if ((*(char *)(a2 + 63) & 0x80000000) == 0)
  {
    v5 = *(_OWORD *)(a2 + 40);
    v4->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 56);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
    result = *(void **)(a2 + 64);
    if (!result)
      goto LABEL_6;
    goto LABEL_5;
  }
  std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 40), *(_QWORD *)(a2 + 48));
  result = *(void **)(a2 + 64);
  if (result)
LABEL_5:
    result = _Block_copy(result);
LABEL_6:
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

void __destroy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE64c43_ZTSN8dispatch5blockIU13block_pointerFviEEE(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 64);
  if (v2)
    _Block_release(v2);
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

void ___ZN14ResetDetection16addToBlocks_syncENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN8dispatch5blockIU13block_pointerFviEEERNS0_3mapIS6_NS0_4pairIP17dispatch_source_sSB_EENS0_4lessIS6_EENS4_INSD_IKS6_SG_EEEEEEy_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t **v9;
  int v10;
  const void *v11;
  size_t v12;
  uint64_t *v13;
  int v14;
  uint64_t *v15;
  size_t v16;
  size_t v17;
  int v18;
  int v19;
  const void *v20;
  size_t v21;
  size_t v22;
  int v23;
  uint64_t **v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  BOOL v28;
  uint64_t *v29;
  const void *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;

  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2)
    return;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return;
  v5 = v4;
  if (!*(_QWORD *)(a1 + 40))
    goto LABEL_54;
  v6 = *(_QWORD *)(a1 + 56);
  v9 = *(uint64_t ***)(v6 + 8);
  v7 = (uint64_t *)(v6 + 8);
  v8 = v9;
  if (!v9)
    goto LABEL_54;
  v10 = *(char *)(a1 + 87);
  if (v10 >= 0)
    v11 = (const void *)(a1 + 64);
  else
    v11 = *(const void **)(a1 + 64);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 87);
  else
    v12 = *(_QWORD *)(a1 + 72);
  v13 = v7;
  do
  {
    while (1)
    {
      v14 = *((char *)v8 + 55);
      v15 = v14 >= 0 ? (uint64_t *)(v8 + 4) : v8[4];
      v16 = v14 >= 0 ? *((unsigned __int8 *)v8 + 55) : (size_t)v8[5];
      v17 = v12 >= v16 ? v16 : v12;
      v18 = memcmp(v15, v11, v17);
      if (v18)
        break;
      if (v16 >= v12)
        goto LABEL_26;
LABEL_12:
      v8 = (uint64_t **)v8[1];
      if (!v8)
        goto LABEL_27;
    }
    if (v18 < 0)
      goto LABEL_12;
LABEL_26:
    v13 = (uint64_t *)v8;
    v8 = (uint64_t **)*v8;
  }
  while (v8);
LABEL_27:
  if (v13 != v7)
  {
    v19 = *((char *)v13 + 55);
    if (v19 >= 0)
      v20 = v13 + 4;
    else
      v20 = (const void *)v13[4];
    if (v19 >= 0)
      v21 = *((unsigned __int8 *)v13 + 55);
    else
      v21 = v13[5];
    if (v21 >= v12)
      v22 = v12;
    else
      v22 = v21;
    v23 = memcmp(v11, v20, v22);
    if (v23)
    {
      if (v23 < 0)
        goto LABEL_54;
LABEL_41:
      ResetDetection::invokeBlock_sync(v3, (uint64_t)(v13 + 4), 3760250883);
      v24 = *(uint64_t ***)(a1 + 56);
      v25 = (uint64_t *)v13[1];
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        v27 = v13;
        do
        {
          v26 = (uint64_t *)v27[2];
          v28 = *v26 == (_QWORD)v27;
          v27 = v26;
        }
        while (!v28);
      }
      if (*v24 == v13)
        *v24 = v26;
      v29 = v24[1];
      v24[2] = (uint64_t *)((char *)v24[2] - 1);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v29, v13);
      v30 = (const void *)v13[8];
      if (v30)
        _Block_release(v30);
      if (*((char *)v13 + 55) < 0)
        operator delete((void *)v13[4]);
      operator delete(v13);
    }
    else if (v12 >= v21)
    {
      goto LABEL_41;
    }
  }
LABEL_54:
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v32 = __ldaxr(p_shared_owners);
  while (__stlxr(v32 - 1, p_shared_owners));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_1A34BCAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ResetDetection::invokeBlock_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  NSObject *v7;
  void (**v8)(void *, _QWORD);
  NSObject *v9;
  std::string *p_p;
  std::string __p;
  uint8_t buf[4];
  std::string *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(&__p, 170, sizeof(__p));
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  v7 = *(NSObject **)(a2 + 24);
  v6 = *(const void **)(a2 + 32);
  if (v6)
  {
    v8 = (void (**)(void *, _QWORD))_Block_copy(v6);
    *(_QWORD *)(a2 + 24) = 0;
    if (!v7)
      goto LABEL_7;
    goto LABEL_6;
  }
  v8 = 0;
  *(_QWORD *)(a2 + 24) = 0;
  if (v7)
  {
LABEL_6:
    dispatch_source_cancel(v7);
    dispatch_release(v7);
  }
LABEL_7:
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315138;
    v13 = p_p;
    _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#I Signalling %s", buf, 0xCu);
  }
  v8[2](v8, a3);
  _Block_release(v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1A34BCC1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void __copy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14ResetDetectionEE64c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::string *v6;
  __int128 v7;

  v3 = *(_QWORD *)(a2 + 48);
  a1[5] = *(_QWORD *)(a2 + 40);
  a1[6] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::string *)(a1 + 8);
  if (*(char *)(a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 64), *(_QWORD *)(a2 + 72));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 64);
    a1[10] = *(_QWORD *)(a2 + 80);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
}

void sub_1A34BCCD4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14ResetDetectionEE64c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    v2 = *(std::__shared_weak_count **)(a1 + 48);
    if (!v2)
      return;
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 64));
  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
LABEL_3:
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>::~pair(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    _Block_release(v2);
  return a1;
}

void ResetDetection::notifyResetDetectBlocks_sync(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  __int128 v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  void *__p[2];
  __int128 v13;
  void *aBlock;
  _QWORD *v15;
  _QWORD v16[2];

  v3 = &v15;
  v4 = *(char **)(a2 + 8);
  v15 = *(_QWORD **)a2;
  v16[0] = v4;
  v5 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v16[1] = v5;
  if (v5)
    v3 = v4 + 16;
  *v3 = v16;
  *(_QWORD *)a2 = a2 + 8;
  v6 = v15;
  if (v15 != v16)
  {
    while (1)
    {
      aBlock = (void *)0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)__p = v7;
      v13 = v7;
      if (*((char *)v6 + 55) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)__p, (const std::string::value_type *)v6[4], v6[5]);
      }
      else
      {
        *(_OWORD *)__p = *((_OWORD *)v6 + 2);
        *(_QWORD *)&v13 = v6[6];
      }
      v8 = (void *)v6[8];
      *((_QWORD *)&v13 + 1) = v6[7];
      if (v8)
        v8 = _Block_copy(v8);
      aBlock = v8;
      ResetDetection::invokeBlock_sync(a1, (uint64_t)__p, 0);
      if (aBlock)
        _Block_release(aBlock);
      if (SBYTE7(v13) < 0)
      {
        operator delete(__p[0]);
        v9 = (_QWORD *)v6[1];
        if (v9)
        {
          do
          {
LABEL_17:
            v10 = v9;
            v9 = (_QWORD *)*v9;
          }
          while (v9);
          goto LABEL_5;
        }
      }
      else
      {
        v9 = (_QWORD *)v6[1];
        if (v9)
          goto LABEL_17;
      }
      do
      {
        v10 = (_QWORD *)v6[2];
        v11 = *v10 == (_QWORD)v6;
        v6 = v10;
      }
      while (!v11);
LABEL_5:
      v6 = v10;
      if (v10 == v16)
      {
        v4 = (char *)v16[0];
        break;
      }
    }
  }
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(v4);
}

void sub_1A34BCEA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15)
{
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(a15);
  _Unwind_Resume(a1);
}

void sub_1A34BCEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15)
{
  std::pair<std::string const,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>::~pair((uint64_t)&a9);
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(a15);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>::~pair(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 32);
  if (v2)
    _Block_release(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void ResetDetection::resetDetectCallback(ResetDetection *this, void *a2, unsigned int a3, int a4, void *a5)
{
  _QWORD v5[5];
  int v6;

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___ZN14ResetDetection19resetDetectCallbackEPvjjS0__block_invoke;
  v5[3] = &__block_descriptor_tmp_6_3;
  v5[4] = this;
  v6 = a4;
  ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)this + 9, (uint64_t)v5);
}

void ___ZN14ResetDetection19resetDetectCallbackEPvjjS0__block_invoke(uint64_t a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  os_activity_scope_state_s state;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 40);
  if (v2 == -469794815)
  {
    v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(state.opaque[0]) = 0;
      _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I baseband alive detected", (uint8_t *)&state, 2u);
    }
    *(_DWORD *)(v1 + 128) = 0;
    ResetDetection::notifyResetDetectBlocks_sync(v1, v1 + 160);
  }
  else if (v2 == -469794816)
  {
    v3 = _os_activity_create(&dword_1A343C000, "Baseband state: reset detected", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v3, &state);
    os_activity_scope_leave(&state);
    v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(state.opaque[0]) = 0;
      _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I baseband reset detected", (uint8_t *)&state, 2u);
    }
    *(_DWORD *)(v1 + 128) = 1;
    ResetDetection::notifyResetDetectBlocks_sync(v1, v1 + 136);
    if (v3)
      os_release(v3);
  }
}

void sub_1A34BD0DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::os::scoped_activity::~scoped_activity((void **)va);
  _Unwind_Resume(a1);
}

void ctu::os::scoped_activity::~scoped_activity(void **this)
{
  void *v1;

  v1 = *this;
  if (v1)
    os_release(v1);
}

uint64_t ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig()
{
  return ctu::LoggerCommonBase::setInheritedLogLevel();
}

void ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName(char *a1@<X8>)
{
  a1[23] = 12;
  strcpy(a1, "reset.detect");
}

uint64_t ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return ctu::LoggerCommonBase::getLocalLogLevel((ctu::LoggerCommonBase *)(a1 + 8));
}

_QWORD *ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A09BC8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  return a1;
}

void ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A09BC8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  operator delete(a1);
}

void ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  v1 = a1 + 56;
  if (*(_QWORD *)(a1 + 56))
  {
    if (!*(_QWORD *)(a1 + 80) || (v2 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 80))) == 0)
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v3 = v2;
    ctu::LoggerCommonBase::getLogDomain((ctu::LoggerCommonBase *)(v1 - 48));
    ctu::TrackedLogger::registerLoggerToServer();
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1A34BD2BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A34BD2D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<ResetDetection>::shared_ptr[abi:ne180100]<ResetDetection,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1},void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A09C08;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2)
    return a1;
  v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      return a1;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A34BD3F4(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1}::operator() const(ResetDetection*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A34BD414(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<ResetDetection *,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection *)#1},std::allocator<ResetDetection>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<ResetDetection *,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection *)#1},std::allocator<ResetDetection>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1}::operator() const(ResetDetection*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<ResetDetection *,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection *)#1},std::allocator<ResetDetection>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptr"
                                "IT_EEPS6_EUlPS1_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1}::operator() const(ResetDetection*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>&>(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v9;
  _BYTE v10[16];

  *a1 = off_1E4A09BC8;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v10);
  a1[1] = &unk_1E4A06330;
  a1[7] = *a3;
  v5 = a3[1];
  a1[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  return a1;
}

void sub_1A34BD584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedLoggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A09BC8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  operator delete(a1);
}

void std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(char *a1)
{
  const void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*((_QWORD *)a1 + 1));
    v2 = (const void *)*((_QWORD *)a1 + 8);
    if (v2)
      _Block_release(v2);
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

void ctu::SharedSynchronizable<ResetDetection>::execute_wrapped(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD block[6];
  std::__shared_weak_count *v16;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI14ResetDetectionE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E4A09C90;
  block[5] = v5;
  v16 = v7;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  block[4] = a2;
  dispatch_async(v8, block);
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t ___ZNK3ctu20SharedSynchronizableI14ResetDetectionE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrIK14ResetDetectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrIK14ResetDetectionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

_QWORD *diag::DIAGConfigurerPCI::DIAGConfigurerPCI(_QWORD *a1, uint64_t *a2, int *a3, uint64_t a4)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  const void *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  CFTypeRef v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  int v28;
  CFTypeRef cf;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;

  v7 = (std::__shared_weak_count *)a2[1];
  v34 = *a2;
  v35 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v28 = *a3;
  v10 = (const void *)*((_QWORD *)a3 + 1);
  cf = v10;
  if (v10)
    CFRetain(v10);
  v11 = (std::__shared_weak_count *)*((_QWORD *)a3 + 3);
  v30 = *((_QWORD *)a3 + 2);
  v31 = v11;
  if (v11)
  {
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = *((_QWORD *)a3 + 4);
  v15 = (std::__shared_weak_count *)*((_QWORD *)a3 + 5);
  v32 = v14;
  v33 = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  diag::DIAGConfigurer::DIAGConfigurer((uint64_t)a1, &v34, (uint64_t)&v28, a4);
  if (v15)
  {
    v18 = (unint64_t *)&v15->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v20 = v31;
  if (v31)
  {
    v21 = (unint64_t *)&v31->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
      v23 = cf;
      if (!cf)
        goto LABEL_23;
      goto LABEL_22;
    }
  }
  v23 = cf;
  if (cf)
LABEL_22:
    CFRelease(v23);
LABEL_23:
  v24 = v35;
  if (v35)
  {
    v25 = (unint64_t *)&v35->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  *a1 = off_1E4A09CD0;
  a1[22] = 0;
  a1[23] = 0;
  return a1;
}

void sub_1A34BD9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  diag::DIAGConfigurer::Parameters_t::~Parameters_t((diag::DIAGConfigurer::Parameters_t *)&a9);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void diag::DIAGConfigurer::Parameters_t::~Parameters_t(diag::DIAGConfigurer::Parameters_t *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  const void *v8;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (!v5)
    goto LABEL_10;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    v8 = (const void *)*((_QWORD *)this + 1);
    if (!v8)
      return;
  }
  else
  {
LABEL_10:
    v8 = (const void *)*((_QWORD *)this + 1);
    if (!v8)
      return;
  }
  CFRelease(v8);
}

void diag::DIAGConfigurerPCI::~DIAGConfigurerPCI(diag::DIAGConfigurerPCI *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  *(_QWORD *)this = off_1E4A09CD0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
  else
  {
LABEL_5:
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
}

{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  *(_QWORD *)this = off_1E4A09CD0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
  else
  {
LABEL_5:
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
}

{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  void *v5;

  *(_QWORD *)this = off_1E4A09CD0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
  else
  {
LABEL_5:
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
  operator delete(v5);
}

void diag::DIAGConfigurerPCI::reset(diag::DIAGConfigurerPCI *this)
{
  NSObject *v1;
  char *v2;
  _QWORD v3[5];
  _QWORD *v4;
  _QWORD block[6];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZN4diag17DIAGConfigurerPCI5resetEv_block_invoke;
  v3[3] = &__block_descriptor_tmp_11;
  v3[4] = this;
  v4 = v3;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN4diag14DIAGConfigurerEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke_0;
  block[3] = &__block_descriptor_tmp_7_3;
  block[4] = (char *)this + 72;
  block[5] = &v4;
  v2 = (char *)this + 88;
  v1 = *((_QWORD *)this + 11);
  if (*((_QWORD *)v2 + 1))
    dispatch_async_and_wait(v1, block);
  else
    dispatch_sync(v1, block);
}

void ___ZN4diag17DIAGConfigurerPCI5resetEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting DIAG configuration", v3, 2u);
  }
  if ((*(_DWORD *)(v1 + 104) | 4) == 4)
    BasebandTransport::close(*(BasebandTransport **)(v1 + 120));
}

void diag::DIAGConfigurerPCI::starting(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t *v5;
  NSObject *v6;
  _QWORD v7[5];
  void *aBlock;
  dispatch_object_t object;

  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI8startingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_3_1;
  v7[4] = a1;
  v4 = *(void **)a2;
  if (*(_QWORD *)a2)
    v4 = _Block_copy(v4);
  v5 = (uint64_t *)(a1 + 72);
  v6 = *(NSObject **)(a2 + 8);
  aBlock = v4;
  object = v6;
  if (v6)
    dispatch_retain(v6);
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object)
    dispatch_release(object);
  if (aBlock)
    _Block_release(aBlock);
}

void ___ZN4diag17DIAGConfigurerPCI8startingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(capabilities::abs *a1)
{
  uint64_t v2;
  uint64_t v3;
  capabilities::abs *shouldUseMinBasebandTransportIOReadSize;
  int v5;
  int v6;
  char v7;
  int v8;
  SoftwareBypassShim *v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  __int128 v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  const void *v22;
  void *v23;
  const void *v24;
  NSObject *v25;
  void *v26;
  void *aBlock;
  int v28;
  char v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  char v34;
  _BYTE buf[24];
  void *v36;
  void *v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)a1 + 4);
  if ((*(_DWORD *)(v2 + 104) | 4) == 4)
  {
    v3 = *(_QWORD *)(v2 + 120);
    v28 = 2;
    v29 = 0;
    v30 = 10;
    shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(a1);
    if ((_DWORD)shouldUseMinBasebandTransportIOReadSize)
      v5 = 0x4000;
    else
      v5 = 0x8000;
    v31 = v5;
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize))
      v6 = 4;
    else
      v6 = 16;
    v32 = v6;
    v33 = 0;
    v34 = 0;
    aBlock = 0;
    v7 = (*(uint64_t (**)(uint64_t, int *, void **))(*(_QWORD *)v3 + 48))(v3, &v28, &aBlock);
    if (aBlock)
      _Block_release(aBlock);
    if ((v7 & 1) != 0)
    {
      LOBYTE(v8) = 1;
      goto LABEL_36;
    }
    v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Failed to opening transport.", buf, 2u);
    }
    BasebandTransport::close(*(BasebandTransport **)(v2 + 120));
LABEL_35:
    LOBYTE(v8) = 0;
    goto LABEL_36;
  }
  v9 = *(SoftwareBypassShim **)(v2 + 176);
  if (!v9)
  {
    SoftwareBypassShim::create((std::__shared_weak_count **)buf);
    v14 = *(_OWORD *)buf;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v15 = *(std::__shared_weak_count **)(v2 + 184);
    *(_OWORD *)(v2 + 176) = v14;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v19 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v9 = *(SoftwareBypassShim **)(v2 + 176);
    if (*((_QWORD *)v9 + 2))
      goto LABEL_14;
LABEL_33:
    v21 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v21, OS_LOG_TYPE_ERROR, "Expected to use software bypass, but it is not supported", buf, 2u);
    }
    goto LABEL_35;
  }
  if (!*((_QWORD *)v9 + 2))
    goto LABEL_33;
LABEL_14:
  if (*(_BYTE *)(*(_QWORD *)(v2 + 168) + 22))
    v10 = 11;
  else
    v10 = 13;
  v8 = SoftwareBypassShim::bypassCtl(v9, v10);
  v11 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = SoftwareBypassShim::bypassInterfaceMaskAsString(*(SoftwareBypassShim **)(v2 + 176), v10);
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v12;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I bypassCtl( %s): success: %d", buf, 0x12u);
  }
LABEL_36:
  v22 = (const void *)*((_QWORD *)a1 + 5);
  if (v22 && *((_QWORD *)a1 + 6))
  {
    v23 = _Block_copy(v22);
    v24 = v23;
    v25 = *((_QWORD *)a1 + 6);
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 1174405120;
    *(_QWORD *)&buf[16] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
    v36 = &__block_descriptor_tmp_8_4;
    if (v23)
      v26 = _Block_copy(v23);
    else
      v26 = 0;
    v37 = v26;
    v38 = v8;
    dispatch_async(v25, buf);
    if (v37)
      _Block_release(v37);
    if (v24)
      _Block_release(v24);
  }
}

void sub_1A34BE11C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void __copy_helper_block_e8_40c46_ZTSN8dispatch8callbackIU13block_pointerFvbEEE(uint64_t a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;

  v4 = *(void **)(a2 + 40);
  if (v4)
    v4 = _Block_copy(v4);
  v5 = *(NSObject **)(a2 + 48);
  *(_QWORD *)(a1 + 40) = v4;
  *(_QWORD *)(a1 + 48) = v5;
  if (v5)
    dispatch_retain(v5);
}

void __destroy_helper_block_e8_40c46_ZTSN8dispatch8callbackIU13block_pointerFvbEEE(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  v2 = *(NSObject **)(a1 + 48);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    _Block_release(v3);
}

void diag::DIAGConfigurerPCI::started(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t *v5;
  NSObject *v6;
  _QWORD v7[5];
  void *aBlock;
  dispatch_object_t object;

  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI7startedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_4_1;
  v7[4] = a1;
  v4 = *(void **)a2;
  if (*(_QWORD *)a2)
    v4 = _Block_copy(v4);
  v5 = (uint64_t *)(a1 + 72);
  v6 = *(NSObject **)(a2 + 8);
  aBlock = v4;
  object = v6;
  if (v6)
    dispatch_retain(v6);
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object)
    dispatch_release(object);
  if (aBlock)
    _Block_release(aBlock);
}

void ___ZN4diag17DIAGConfigurerPCI7startedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  char v3;
  const void *v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  void *v8;
  _QWORD v9[4];
  void *aBlock;
  char v11;

  v2 = a1[4];
  if (*(_DWORD *)(v2 + 104) == 4)
  {
    v3 = BasebandTransport::close(*(BasebandTransport **)(v2 + 120));
    v4 = (const void *)a1[5];
    if (!v4)
      return;
  }
  else
  {
    v3 = 1;
    v4 = (const void *)a1[5];
    if (!v4)
      return;
  }
  if (a1[6])
  {
    v5 = _Block_copy(v4);
    v6 = v5;
    v7 = a1[6];
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 1174405120;
    v9[2] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
    v9[3] = &__block_descriptor_tmp_8_4;
    if (v5)
      v8 = _Block_copy(v5);
    else
      v8 = 0;
    aBlock = v8;
    v11 = v3;
    dispatch_async(v7, v9);
    if (aBlock)
      _Block_release(aBlock);
    if (v6)
      _Block_release(v6);
  }
}

void diag::DIAGConfigurerPCI::stopping(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t *v5;
  NSObject *v6;
  _QWORD v7[5];
  void *aBlock;
  dispatch_object_t object;

  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI8stoppingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_5_1;
  v7[4] = a1;
  v4 = *(void **)a2;
  if (*(_QWORD *)a2)
    v4 = _Block_copy(v4);
  v5 = (uint64_t *)(a1 + 72);
  v6 = *(NSObject **)(a2 + 8);
  aBlock = v4;
  object = v6;
  if (v6)
    dispatch_retain(v6);
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object)
    dispatch_release(object);
  if (aBlock)
    _Block_release(aBlock);
}

void ___ZN4diag17DIAGConfigurerPCI8stoppingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(capabilities::abs *a1)
{
  uint64_t v2;
  uint64_t v3;
  capabilities::abs *shouldUseMinBasebandTransportIOReadSize;
  int v5;
  int v6;
  char v7;
  const void *v8;
  void *v9;
  const void *v10;
  NSObject *v11;
  void *v12;
  void *aBlock;
  int v14;
  char v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  char v20;
  _QWORD block[4];
  void *v22;
  char v23;

  v2 = *((_QWORD *)a1 + 4);
  if ((*(_DWORD *)(v2 + 104) | 4) != 4)
  {
    v7 = 1;
    v8 = (const void *)*((_QWORD *)a1 + 5);
    if (!v8)
      return;
    goto LABEL_13;
  }
  v3 = *(_QWORD *)(v2 + 120);
  v14 = 2;
  v15 = 0;
  v16 = 10;
  shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(a1);
  if ((_DWORD)shouldUseMinBasebandTransportIOReadSize)
    v5 = 0x4000;
  else
    v5 = 0x8000;
  v17 = v5;
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize))
    v6 = 4;
  else
    v6 = 16;
  v18 = v6;
  v19 = 0;
  v20 = 0;
  aBlock = 0;
  v7 = (*(uint64_t (**)(uint64_t, int *, void **))(*(_QWORD *)v3 + 48))(v3, &v14, &aBlock);
  if (aBlock)
    _Block_release(aBlock);
  v8 = (const void *)*((_QWORD *)a1 + 5);
  if (v8)
  {
LABEL_13:
    if (*((_QWORD *)a1 + 6))
    {
      v9 = _Block_copy(v8);
      v10 = v9;
      v11 = *((_QWORD *)a1 + 6);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 1174405120;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
      block[3] = &__block_descriptor_tmp_8_4;
      if (v9)
        v12 = _Block_copy(v9);
      else
        v12 = 0;
      v22 = v12;
      v23 = v7;
      dispatch_async(v11, block);
      if (v22)
        _Block_release(v22);
      if (v10)
        _Block_release(v10);
    }
  }
}

void sub_1A34BE58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock)
{
  if (aBlock)
    _Block_release(aBlock);
  _Unwind_Resume(exception_object);
}

void diag::DIAGConfigurerPCI::stopped(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t *v5;
  NSObject *v6;
  _QWORD v7[5];
  void *aBlock;
  dispatch_object_t object;

  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI7stoppedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_6_4;
  v7[4] = a1;
  v4 = *(void **)a2;
  if (*(_QWORD *)a2)
    v4 = _Block_copy(v4);
  v5 = (uint64_t *)(a1 + 72);
  v6 = *(NSObject **)(a2 + 8);
  aBlock = v4;
  object = v6;
  if (v6)
    dispatch_retain(v6);
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object)
    dispatch_release(object);
  if (aBlock)
    _Block_release(aBlock);
}

void ___ZN4diag17DIAGConfigurerPCI7stoppedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  char v3;
  const void *v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  void *v8;
  _QWORD v9[4];
  void *aBlock;
  char v11;

  v2 = a1[4];
  if ((*(_DWORD *)(v2 + 104) | 4) == 4)
  {
    v3 = BasebandTransport::close(*(BasebandTransport **)(v2 + 120));
    v4 = (const void *)a1[5];
    if (!v4)
      return;
  }
  else
  {
    v3 = 1;
    v4 = (const void *)a1[5];
    if (!v4)
      return;
  }
  if (a1[6])
  {
    v5 = _Block_copy(v4);
    v6 = v5;
    v7 = a1[6];
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 1174405120;
    v9[2] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
    v9[3] = &__block_descriptor_tmp_8_4;
    if (v5)
      v8 = _Block_copy(v5);
    else
      v8 = 0;
    aBlock = v8;
    v11 = v3;
    dispatch_async(v7, v9);
    if (aBlock)
      _Block_release(aBlock);
    if (v6)
      _Block_release(v6);
  }
}

uint64_t ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t _GLOBAL__sub_I_DIAGConfigurerPCI_cpp()
{
  uint64_t result;

  result = ETLDIAGLoggingGetDefaultView();
  dword_1ED114A34 = result;
  return result;
}

uint64_t *BasebandTransport::getSupportedProtocols@<X0>(BasebandTransport *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *result;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  _DWORD *v17;
  _DWORD *v18;
  _DWORD *v19;
  _DWORD *v20;
  _DWORD *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;

  *a2 = (uint64_t)a2;
  a2[1] = (uint64_t)a2;
  a2[2] = 0;
  result = (uint64_t *)capabilities::radio::vendor(this);
  if ((_DWORD)result == 1)
  {
    v13 = operator new(0x18uLL);
    v13[4] = 0;
    *(_QWORD *)v13 = &v33;
    *((_QWORD *)v13 + 1) = &v33;
    v34 = (uint64_t *)v13;
    v14 = operator new(0x18uLL);
    v14[4] = 1;
    *(_QWORD *)v14 = v13;
    *((_QWORD *)v14 + 1) = &v33;
    *((_QWORD *)v13 + 1) = v14;
    v15 = operator new(0x18uLL);
    v15[4] = 2;
    *(_QWORD *)v15 = v14;
    *((_QWORD *)v15 + 1) = &v33;
    *((_QWORD *)v14 + 1) = v15;
    v16 = operator new(0x18uLL);
    v16[4] = 3;
    *(_QWORD *)v16 = v15;
    *((_QWORD *)v16 + 1) = &v33;
    *((_QWORD *)v15 + 1) = v16;
    v17 = operator new(0x18uLL);
    v17[4] = 4;
    *(_QWORD *)v17 = v16;
    *((_QWORD *)v17 + 1) = &v33;
    *((_QWORD *)v16 + 1) = v17;
    v18 = operator new(0x18uLL);
    v18[4] = 5;
    *(_QWORD *)v18 = v17;
    *((_QWORD *)v18 + 1) = &v33;
    *((_QWORD *)v17 + 1) = v18;
    v19 = operator new(0x18uLL);
    v19[4] = 10;
    *(_QWORD *)v19 = v18;
    *((_QWORD *)v19 + 1) = &v33;
    *((_QWORD *)v18 + 1) = v19;
    v20 = operator new(0x18uLL);
    v20[4] = 12;
    *(_QWORD *)v20 = v19;
    *((_QWORD *)v20 + 1) = &v33;
    *((_QWORD *)v19 + 1) = v20;
    v21 = operator new(0x18uLL);
    v21[4] = 14;
    *(_QWORD *)v21 = v20;
    *((_QWORD *)v21 + 1) = &v33;
    *((_QWORD *)v20 + 1) = v21;
    v33 = (uint64_t)v21;
    v35 = 9;
    result = (uint64_t *)capabilities::radio::mav20Plus((capabilities::radio *)v21);
    if ((_DWORD)result)
    {
      v22 = operator new(0x18uLL);
      v22[4] = 11;
      v23 = v33;
      *(_QWORD *)v22 = v33;
      *((_QWORD *)v22 + 1) = &v33;
      *(_QWORD *)(v23 + 8) = v22;
      v24 = v35;
      v33 = (uint64_t)v22;
      ++v35;
      result = (uint64_t *)operator new(0x18uLL);
      *((_DWORD *)result + 4) = 15;
      *result = (uint64_t)v22;
      result[1] = (uint64_t)&v33;
      *((_QWORD *)v22 + 1) = result;
      v33 = (uint64_t)result;
      v35 = v24 + 2;
    }
    if (a2[2])
    {
      v25 = *a2;
      result = (uint64_t *)a2[1];
      v26 = *result;
      *(_QWORD *)(v26 + 8) = *(_QWORD *)(*a2 + 8);
      **(_QWORD **)(v25 + 8) = v26;
      a2[2] = 0;
      if (result != a2)
      {
        do
        {
          v27 = result[1];
          operator delete(result);
          result = (uint64_t *)v27;
        }
        while ((uint64_t *)v27 != a2);
      }
    }
  }
  else
  {
    if ((_DWORD)result != 2)
      return result;
    v4 = operator new(0x18uLL);
    v4[4] = 6;
    *(_QWORD *)v4 = &v33;
    *((_QWORD *)v4 + 1) = &v33;
    v34 = (uint64_t *)v4;
    v5 = operator new(0x18uLL);
    v5[4] = 7;
    *(_QWORD *)v5 = v4;
    *((_QWORD *)v5 + 1) = &v33;
    *((_QWORD *)v4 + 1) = v5;
    v6 = operator new(0x18uLL);
    v6[4] = 8;
    *(_QWORD *)v6 = v5;
    *((_QWORD *)v6 + 1) = &v33;
    *((_QWORD *)v5 + 1) = v6;
    v7 = operator new(0x18uLL);
    v7[4] = 9;
    *(_QWORD *)v7 = v6;
    *((_QWORD *)v7 + 1) = &v33;
    *((_QWORD *)v6 + 1) = v7;
    v8 = operator new(0x18uLL);
    v8[4] = 10;
    *(_QWORD *)v8 = v7;
    *((_QWORD *)v8 + 1) = &v33;
    *((_QWORD *)v7 + 1) = v8;
    v33 = (uint64_t)v8;
    v35 = 5;
    result = (uint64_t *)capabilities::abs::supportsETSProtocol((capabilities::abs *)v8);
    if ((_DWORD)result)
    {
      result = (uint64_t *)operator new(0x18uLL);
      *((_DWORD *)result + 4) = 13;
      v9 = v33;
      *result = v33;
      result[1] = (uint64_t)&v33;
      *(_QWORD *)(v9 + 8) = result;
      v33 = (uint64_t)result;
      ++v35;
    }
    if (a2[2])
    {
      v10 = *a2;
      result = (uint64_t *)a2[1];
      v11 = *result;
      *(_QWORD *)(v11 + 8) = *(_QWORD *)(*a2 + 8);
      **(_QWORD **)(v10 + 8) = v11;
      a2[2] = 0;
      if (result != a2)
      {
        do
        {
          v12 = result[1];
          operator delete(result);
          result = (uint64_t *)v12;
        }
        while ((uint64_t *)v12 != a2);
      }
    }
  }
  v28 = v35;
  if (v35)
  {
    v30 = v33;
    v29 = v34;
    v31 = *v34;
    *(_QWORD *)(v31 + 8) = *(_QWORD *)(v33 + 8);
    **(_QWORD **)(v30 + 8) = v31;
    v32 = *a2;
    *(_QWORD *)(v32 + 8) = v29;
    *v29 = v32;
    *a2 = v30;
    *(_QWORD *)(v30 + 8) = a2;
    a2[2] += v28;
  }
  return result;
}

void sub_1A34BEAE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t *v2;
  va_list va;

  va_start(va, a2);
  std::list<BasebandTransport::Protocol>::~list((uint64_t *)va);
  std::list<BasebandTransport::Protocol>::~list(v2);
  _Unwind_Resume(a1);
}

void sub_1A34BEB14(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::list<BasebandTransport::Protocol>::~list(v1);
  _Unwind_Resume(a1);
}

void sub_1A34BEB2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v16;

  do
  {
    v16 = (_QWORD *)v13[1];
    operator delete(v13);
    v13 = v16;
  }
  while (v16 != v14);
  std::list<BasebandTransport::Protocol>::~list(v12);
  _Unwind_Resume(a1);
}

uint64_t *std::list<BasebandTransport::Protocol>::~list(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v3 = *a1;
    v2 = (uint64_t *)a1[1];
    v4 = *v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = (uint64_t *)v2[1];
        operator delete(v2);
        v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void BasebandTransport::getSupportedProtocolsAsStringLowerCase(BasebandTransport *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t i;
  int v4;
  char v5;
  char v6;
  char v7;
  char v8;
  __darwin_ct_rune_t v9;
  char v10;
  __darwin_ct_rune_t v11;
  _QWORD *v12;
  std::string *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  __darwin_ct_rune_t v19[6];
  uint64_t v20[3];

  *a2 = (uint64_t)a2;
  a2[1] = (uint64_t)a2;
  a2[2] = 0;
  memset(v20, 170, sizeof(v20));
  BasebandTransport::getSupportedProtocols(this, v20);
  for (i = v20[1]; (uint64_t *)i != v20; i = *(_QWORD *)(i + 8))
  {
    v4 = *(_DWORD *)(i + 16);
    memset(v19, 170, sizeof(v19));
    switch(v4)
    {
      case 0:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 4997712;
        goto LABEL_30;
      case 1:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 4997715;
        goto LABEL_30;
      case 2:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1195460932;
        goto LABEL_26;
      case 3:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1397114194;
        goto LABEL_26;
      case 4:
        v5 = 0;
        v10 = 0;
        v6 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 5;
        strcpy((char *)v19, "QMUX1");
        v7 = 1;
        break;
      case 5:
        v5 = 0;
        v10 = 0;
        v6 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 5;
        strcpy((char *)v19, "QMUX2");
        v7 = 1;
        break;
      case 6:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 5066578;
        goto LABEL_30;
      case 7:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1414483778;
        goto LABEL_26;
      case 8:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 4805185;
        goto LABEL_30;
      case 9:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 5526611;
        goto LABEL_30;
      case 10:
        v10 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 2;
        strcpy((char *)v19, "AT");
        v5 = 1;
        break;
      case 11:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1280328769;
        goto LABEL_26;
      case 12:
        v5 = 0;
        v10 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 8;
        strcpy((char *)v19, "MEDIACTL");
        break;
      case 13:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 5461061;
        goto LABEL_30;
      case 14:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        strcpy((char *)v19, "GNSS");
        v6 = 1;
        break;
      case 15:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1397965905;
        goto LABEL_26;
      case 16:
        v5 = 0;
        v10 = 0;
        v6 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 5;
        strcpy((char *)v19, "RCTTH");
        v7 = 1;
        break;
      case 17:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 5260097;
        goto LABEL_30;
      case 18:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1297040214;
        goto LABEL_26;
      case 19:
        v5 = 0;
        v10 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 4;
        v11 = 1129335117;
LABEL_26:
        v19[0] = v11;
        v6 = 1;
        LOBYTE(v19[1]) = 0;
        break;
      case 20:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 4999236;
        goto LABEL_30;
      case 21:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 5789005;
        goto LABEL_30;
      case 22:
        v5 = 0;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        HIBYTE(v19[5]) = 3;
        v9 = 4407622;
LABEL_30:
        v19[0] = v9;
        v10 = 1;
        break;
      default:
        v5 = 0;
        v10 = 0;
        v6 = 0;
        v7 = 0;
        HIBYTE(v19[5]) = 7;
        strcpy((char *)v19, "Unknown");
        v8 = 1;
        break;
    }
    LOBYTE(v19[0]) = __tolower(SLOBYTE(v19[0]));
    BYTE1(v19[0]) = __tolower(SBYTE1(v19[0]));
    if ((v5 & 1) == 0)
    {
      BYTE2(v19[0]) = __tolower(SBYTE2(v19[0]));
      if ((v10 & 1) == 0)
      {
        HIBYTE(v19[0]) = __tolower(SHIBYTE(v19[0]));
        if ((v6 & 1) == 0)
        {
          LOBYTE(v19[1]) = __tolower(SLOBYTE(v19[1]));
          if ((v7 & 1) == 0)
          {
            BYTE1(v19[1]) = __tolower(SBYTE1(v19[1]));
            BYTE2(v19[1]) = __tolower(SBYTE2(v19[1]));
            if ((v8 & 1) == 0)
              HIBYTE(v19[1]) = __tolower(SHIBYTE(v19[1]));
          }
        }
      }
    }
    v12 = operator new(0x28uLL);
    v13 = (std::string *)(v12 + 2);
    *v12 = 0;
    v12[1] = 0;
    if (SHIBYTE(v19[5]) < 0)
    {
      std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)v19, *(std::string::size_type *)&v19[2]);
    }
    else
    {
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)v19;
      v12[4] = *(_QWORD *)&v19[4];
    }
    v14 = *a2;
    *v12 = *a2;
    v12[1] = a2;
    *(_QWORD *)(v14 + 8) = v12;
    *a2 = (uint64_t)v12;
    ++a2[2];
    if (SHIBYTE(v19[5]) < 0)
      operator delete(*(void **)v19);
  }
  if (v20[2])
  {
    v16 = v20[0];
    v15 = (uint64_t *)v20[1];
    v17 = *(_QWORD *)v20[1];
    *(_QWORD *)(v17 + 8) = *(_QWORD *)(v20[0] + 8);
    **(_QWORD **)(v16 + 8) = v17;
    v20[2] = 0;
    if (v15 != v20)
    {
      do
      {
        v18 = (uint64_t *)v15[1];
        operator delete(v15);
        v15 = v18;
      }
      while (v18 != v20);
    }
  }
}

void sub_1A34BF1A0(_Unwind_Exception *a1)
{
  char *v1;

  std::list<std::string>::~list(v1);
  _Unwind_Resume(a1);
}

void sub_1A34BF1B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  char *v15;
  void *v16;
  void *v17;

  v17 = v16;
  operator delete(v17);
  if (a14 < 0)
    operator delete(__p);
  std::list<BasebandTransport::Protocol>::~list(&a15);
  std::list<std::string>::~list(v15);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::asStringLowerCase@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  char *v6;
  _BYTE *v7;
  _BYTE *v8;

  memset(a2, 170, 24);
  result = BasebandTransport::asString(a1, (char *)a2);
  v4 = *((unsigned __int8 *)a2 + 23);
  v5 = (char)v4;
  v6 = (char *)a2 + v4;
  if (v5 >= 0)
    v7 = v6;
  else
    v7 = (_BYTE *)(*a2 + a2[1]);
  if (v5 >= 0)
    v8 = a2;
  else
    v8 = (_BYTE *)*a2;
  for (; v8 != v7; ++v8)
  {
    result = __tolower((char)*v8);
    *v8 = result;
  }
  return result;
}

void sub_1A34BF26C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

char *std::list<std::string>::~list(char *a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  char *v6;

  if (*((_QWORD *)a1 + 2))
  {
    v2 = *(_QWORD *)a1;
    v3 = (char *)*((_QWORD *)a1 + 1);
    v4 = *(_QWORD *)v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*(_QWORD *)a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    *((_QWORD *)a1 + 2) = 0;
    if (v3 != a1)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        if (v3[39] < 0)
          operator delete(*((void **)v3 + 2));
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != a1);
    }
  }
  return a1;
}

void BasebandTransport::getSupportedProtocolsAsString(BasebandTransport *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18[3];

  *a2 = a2;
  a2[1] = a2;
  a2[2] = 0;
  memset(v18, 170, sizeof(v18));
  BasebandTransport::getSupportedProtocols(this, v18);
  v3 = (uint64_t *)v18[1];
  if ((uint64_t *)v18[1] != v18)
  {
    v4 = a2[2];
    v5 = v4 + 1;
    v6 = (_QWORD *)*a2;
    v7 = v18[1];
    do
    {
      v8 = 8;
      v9 = 0x4C5443414944454DLL;
      switch(*(_DWORD *)(v7 + 16))
      {
        case 0:
          v9 = v4 & 0xFFFFFFFF00000000 | 0x4C4250;
          v8 = 3;
          break;
        case 1:
          v9 = (v4 & 0xFFFFFFFF00000000 | 0x4C4250) + 3;
          v8 = 3;
          break;
        case 2:
          v10 = 1195460932;
          goto LABEL_25;
        case 3:
          v10 = 1397114194;
          goto LABEL_25;
        case 4:
          v11 = 0x3158554D51;
          goto LABEL_21;
        case 5:
          v11 = 0x3258554D51;
          goto LABEL_21;
        case 6:
          v12 = 5066578;
          goto LABEL_29;
        case 7:
          v10 = 1414483778;
          goto LABEL_25;
        case 8:
          v12 = 4805185;
          goto LABEL_29;
        case 9:
          v12 = 5526611;
          goto LABEL_29;
        case 0xA:
          v13 = v4 & 0xFFFFFFFFFF000000 | 0x5441;
          v8 = 2;
          goto LABEL_30;
        case 0xB:
          v10 = 1280328769;
          goto LABEL_25;
        case 0xC:
          break;
        case 0xD:
          v12 = 5461061;
          goto LABEL_29;
        case 0xE:
          v9 = (v4 & 0xFFFFFF0000000000 | 0x53534451) + 2550;
          v8 = 4;
          break;
        case 0xF:
          v9 = v4 & 0xFFFFFF0000000000 | 0x53534451;
          v8 = 4;
          break;
        case 0x10:
          v11 = 0x4854544352;
LABEL_21:
          v13 = v4 & 0xFFFF000000000000 | v11 & 0xFFFFFFFFFFFFLL;
          v8 = 5;
          goto LABEL_30;
        case 0x11:
          v12 = 5260097;
          goto LABEL_29;
        case 0x12:
          v10 = 1297040214;
          goto LABEL_25;
        case 0x13:
          v10 = 1129335117;
LABEL_25:
          v13 = v4 & 0xFFFFFF0000000000 | v10 & 0xFFFFFFFFFFLL;
          v8 = 4;
          goto LABEL_30;
        case 0x14:
          v9 = (v4 & 0xFFFFFFFF00000000 | 0x4C4250) + 1524;
          v8 = 3;
          break;
        case 0x15:
          v12 = 5789005;
          goto LABEL_29;
        case 0x16:
          v12 = 4407622;
LABEL_29:
          v13 = v4 & 0xFFFFFFFF00000000 | v12;
          v8 = 3;
LABEL_30:
          v9 = v13;
          break;
        default:
          v8 = 7;
          v9 = 0x6E776F6E6B6E55;
          break;
      }
      v14 = operator new(0x28uLL);
      v14[2] = v9;
      v14[3] = 0;
      *((_BYTE *)v14 + 39) = v8;
      *v14 = v6;
      v14[1] = a2;
      v6[1] = v14;
      *a2 = v14;
      a2[2] = v5;
      v7 = *(_QWORD *)(v7 + 8);
      ++v5;
      v4 = v9;
      v6 = v14;
    }
    while ((uint64_t *)v7 != v18);
  }
  if (v18[2])
  {
    v15 = v18[0];
    v16 = *v3;
    *(_QWORD *)(v16 + 8) = *(_QWORD *)(v18[0] + 8);
    **(_QWORD **)(v15 + 8) = v16;
    v18[2] = 0;
    if (v3 != v18)
    {
      do
      {
        v17 = (uint64_t *)v3[1];
        operator delete(v3);
        v3 = v17;
      }
      while (v17 != v18);
    }
  }
}

void sub_1A34BF5C4(_Unwind_Exception *a1)
{
  char *v1;

  std::list<std::string>::~list(v1);
  _Unwind_Resume(a1);
}

void sub_1A34BF5D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  char *v2;
  va_list va;

  va_start(va, a2);
  std::list<BasebandTransport::Protocol>::~list((uint64_t *)va);
  std::list<std::string>::~list(v2);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::asString@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  switch((int)result)
  {
    case 0:
      a2[23] = 3;
      *(_DWORD *)a2 = 4997712;
      break;
    case 1:
      a2[23] = 3;
      *(_DWORD *)a2 = 4997715;
      break;
    case 2:
      a2[23] = 4;
      strcpy(a2, "DIAG");
      break;
    case 3:
      a2[23] = 4;
      strcpy(a2, "REFS");
      break;
    case 4:
      a2[23] = 5;
      strcpy(a2, "QMUX1");
      break;
    case 5:
      a2[23] = 5;
      strcpy(a2, "QMUX2");
      break;
    case 6:
      a2[23] = 3;
      *(_DWORD *)a2 = 5066578;
      break;
    case 7:
      a2[23] = 4;
      strcpy(a2, "BOOT");
      break;
    case 8:
      a2[23] = 3;
      *(_DWORD *)a2 = 4805185;
      break;
    case 9:
      a2[23] = 3;
      *(_DWORD *)a2 = 5526611;
      break;
    case 10:
      a2[23] = 2;
      strcpy(a2, "AT");
      break;
    case 11:
      a2[23] = 4;
      strcpy(a2, "ADPL");
      break;
    case 12:
      a2[23] = 8;
      strcpy(a2, "MEDIACTL");
      break;
    case 13:
      a2[23] = 3;
      *(_DWORD *)a2 = 5461061;
      break;
    case 14:
      a2[23] = 4;
      strcpy(a2, "GNSS");
      break;
    case 15:
      a2[23] = 4;
      strcpy(a2, "QDSS");
      break;
    case 16:
      a2[23] = 5;
      strcpy(a2, "RCTTH");
      break;
    case 17:
      a2[23] = 3;
      *(_DWORD *)a2 = 5260097;
      break;
    case 18:
      a2[23] = 4;
      strcpy(a2, "VCOM");
      break;
    case 19:
      a2[23] = 4;
      strcpy(a2, "MIPC");
      break;
    case 20:
      a2[23] = 3;
      *(_DWORD *)a2 = 4999236;
      break;
    case 21:
      a2[23] = 3;
      *(_DWORD *)a2 = 5789005;
      break;
    case 22:
      a2[23] = 3;
      *(_DWORD *)a2 = 4407622;
      break;
    default:
      a2[23] = 7;
      strcpy(a2, "Unknown");
      break;
  }
  return result;
}

{
  switch((int)result)
  {
    case 0:
      a2[23] = 8;
      strcpy(a2, "NotReady");
      break;
    case 1:
      a2[23] = 5;
      strcpy(a2, "Ready");
      break;
    case 2:
      a2[23] = 5;
      strcpy(a2, "Error");
      break;
    case 3:
      a2[23] = 7;
      strcpy(a2, "Stalled");
      break;
    default:
      a2[23] = 7;
      strcpy(a2, "Unknown");
      break;
  }
  return result;
}

uint64_t BasebandTransport::asProtocol(char *__s1)
{
  const char *v1;
  uint64_t result;

  v1 = __s1;
  if ((__s1[23] & 0x80000000) == 0)
  {
    result = strcmp(__s1, "PBL");
    if (!(_DWORD)result)
      return result;
    if (!strcmp(v1, "SBL"))
      return 1;
    if (strcasecmp(v1, "DIAG"))
    {
      if (strcasecmp(v1, "REFS"))
      {
        if (strcasecmp(v1, "QMUX1"))
        {
          if (strcasecmp(v1, "QMUX2"))
          {
            if (strcasecmp(v1, "ROM"))
            {
              if (strcasecmp(v1, "BOOT"))
              {
                if (strcasecmp(v1, "ARI"))
                {
                  if (strcasecmp(v1, "STT"))
                  {
                    if (strcasecmp(v1, "AT"))
                    {
                      if (strcasecmp(v1, "ADPL"))
                      {
                        if (strcasecmp(v1, "MEDIACTL"))
                        {
                          if (strcasecmp(v1, "ETS"))
                          {
                            if (strcasecmp(v1, "GNSS"))
                            {
                              if (strcasecmp(v1, "QDSS"))
                              {
                                if (strcasecmp(v1, "RCTTH"))
                                {
                                  if (strcasecmp(v1, "ACP"))
                                  {
                                    if (strcasecmp(v1, "VCOM"))
                                    {
                                      if (strcasecmp(v1, "MIPC"))
                                      {
                                        if (strcasecmp(v1, "DHL"))
                                        {
                                          if (strcasecmp(v1, "MUX"))
                                            goto LABEL_24;
                                          return 21;
                                        }
                                        return 20;
                                      }
                                      return 19;
                                    }
                                    return 18;
                                  }
                                  return 17;
                                }
                                return 16;
                              }
                              return 15;
                            }
                            return 14;
                          }
                          return 13;
                        }
                        return 12;
                      }
                      return 11;
                    }
                    return 10;
                  }
                  return 9;
                }
                return 8;
              }
              return 7;
            }
            return 6;
          }
          return 5;
        }
        return 4;
      }
      return 3;
    }
    return 2;
  }
  v1 = *(const char **)__s1;
  result = strcmp(*(const char **)__s1, "PBL");
  if (!(_DWORD)result)
    return result;
  if (!strcmp(v1, "SBL"))
    return 1;
  if (!strcasecmp(v1, "DIAG"))
    return 2;
  if (!strcasecmp(v1, "REFS"))
    return 3;
  if (!strcasecmp(v1, "QMUX1"))
    return 4;
  if (!strcasecmp(v1, "QMUX2"))
    return 5;
  if (!strcasecmp(v1, "ROM"))
    return 6;
  if (!strcasecmp(v1, "BOOT"))
    return 7;
  if (!strcasecmp(v1, "ARI"))
    return 8;
  if (!strcasecmp(v1, "STT"))
    return 9;
  if (!strcasecmp(v1, "AT"))
    return 10;
  if (!strcasecmp(v1, "ADPL"))
    return 11;
  if (!strcasecmp(v1, "MEDIACTL"))
    return 12;
  if (!strcasecmp(v1, "ETS"))
    return 13;
  if (!strcasecmp(v1, "GNSS"))
    return 14;
  if (!strcasecmp(v1, "QDSS"))
    return 15;
  if (!strcasecmp(v1, "RCTTH"))
    return 16;
  if (!strcasecmp(v1, "ACP"))
    return 17;
  if (!strcasecmp(v1, "VCOM"))
    return 18;
  if (!strcasecmp(v1, "MIPC"))
    return 19;
  if (!strcasecmp(v1, "DHL"))
    return 20;
  if (!strcasecmp(v1, "MUX"))
    return 21;
LABEL_24:
  if (!strcasecmp(v1, "FAC"))
    return 22;
  else
    return 23;
}

uint64_t BasebandTransport::getDefaultTransportIOReadSize(capabilities::abs *a1)
{
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(a1))
    return 0x4000;
  else
    return 0x8000;
}

uint64_t BasebandTransport::getDefaultTransportIOReadCount(capabilities::abs *a1)
{
  int v1;
  char shouldUseMinBasebandTransportIOReadCount;
  int v3;
  int v4;
  unsigned int v5;

  v1 = (int)a1;
  shouldUseMinBasebandTransportIOReadCount = capabilities::abs::shouldUseMinBasebandTransportIOReadCount(a1);
  if (v1 == 15)
    v3 = 36;
  else
    v3 = 4;
  if (v1 == 16)
    v4 = 36;
  else
    v4 = v3;
  if (v1 == 2)
    v5 = 16;
  else
    v5 = v4;
  if ((shouldUseMinBasebandTransportIOReadCount & 1) != 0)
    return 4;
  else
    return v5;
}

double BasebandTransport::Status::Status(BasebandTransport::Status *this)
{
  double result;

  *(_DWORD *)this = 0;
  *((_BYTE *)this + 4) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

{
  double result;

  *(_DWORD *)this = 0;
  *((_BYTE *)this + 4) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

double BasebandTransport::Status::init(BasebandTransport::Status *this)
{
  double result;

  *(_DWORD *)this = 0;
  *((_BYTE *)this + 4) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

uint64_t BasebandTransport::Status::toString@<X0>(BasebandTransport::Status *this@<X0>, _BYTE *a2@<X8>)
{
  __int128 v4;
  _QWORD *v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  char v16;
  size_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  void *__p[2];
  char v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  void *v32[2];
  __int128 v33;
  __int128 v34;
  _OWORD v35[9];
  unint64_t v36;

  v36 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35[7] = v4;
  v35[8] = v4;
  v35[5] = v4;
  v35[6] = v4;
  v35[3] = v4;
  v35[4] = v4;
  v35[1] = v4;
  v35[2] = v4;
  v34 = v4;
  v35[0] = v4;
  *(_OWORD *)v32 = v4;
  v33 = v4;
  v30 = v4;
  v31 = v4;
  v28 = v4;
  v29 = v4;
  v27 = v4;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v27);
  v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v28, (uint64_t)"State: ", 7);
  switch(*(_DWORD *)this)
  {
    case 0:
      v6 = 8;
      v26 = 8;
      strcpy((char *)__p, "NotReady");
      break;
    case 1:
      v6 = 5;
      v26 = 5;
      strcpy((char *)__p, "Ready");
      break;
    case 2:
      v6 = 5;
      v26 = 5;
      strcpy((char *)__p, "Error");
      break;
    case 3:
      v6 = 7;
      v26 = 7;
      LODWORD(__p[0]) = 1818326099;
      v7 = 1684368492;
      goto LABEL_7;
    default:
      v6 = 7;
      v26 = 7;
      LODWORD(__p[0]) = 1852534357;
      v7 = 1853321070;
LABEL_7:
      *(_DWORD *)((char *)__p + 3) = v7;
      HIBYTE(__p[0]) = 0;
      break;
  }
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)__p, v6);
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)", ", 2);
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"Async: ", 7);
  *(_DWORD *)((char *)v10 + *(_QWORD *)(*v10 - 24) + 8) |= 1u;
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"Total Rx: ", 10);
  v13 = (_QWORD *)std::ostream::operator<<();
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" KB, ", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"Total Tx: ", 10);
  v15 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" KB", 3);
  if ((v26 & 0x80000000) == 0)
  {
    v16 = BYTE8(v34);
    if ((BYTE8(v34) & 0x10) == 0)
      goto LABEL_10;
LABEL_13:
    v18 = v34;
    if ((unint64_t)v34 < *((_QWORD *)&v31 + 1))
    {
      *(_QWORD *)&v34 = *((_QWORD *)&v31 + 1);
      v18 = *((_QWORD *)&v31 + 1);
    }
    v19 = (const void *)v31;
    v17 = v18 - v31;
    if ((unint64_t)(v18 - v31) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_27;
    goto LABEL_16;
  }
  operator delete(__p[0]);
  v16 = BYTE8(v34);
  if ((BYTE8(v34) & 0x10) != 0)
    goto LABEL_13;
LABEL_10:
  if ((v16 & 8) == 0)
  {
    v17 = 0;
    a2[23] = 0;
    goto LABEL_23;
  }
  v19 = (const void *)*((_QWORD *)&v29 + 1);
  v17 = *((_QWORD *)&v30 + 1) - *((_QWORD *)&v29 + 1);
  if (*((_QWORD *)&v30 + 1) - *((_QWORD *)&v29 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_27:
    std::string::__throw_length_error[abi:ne180100]();
LABEL_16:
  if (v17 >= 0x17)
  {
    v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17)
      v20 = v17 | 7;
    v21 = v20 + 1;
    v22 = operator new(v20 + 1);
    *((_QWORD *)a2 + 1) = v17;
    *((_QWORD *)a2 + 2) = v21 | 0x8000000000000000;
    *(_QWORD *)a2 = v22;
    a2 = v22;
    goto LABEL_22;
  }
  a2[23] = v17;
  if (v17)
LABEL_22:
    memmove(a2, v19, v17);
LABEL_23:
  a2[v17] = 0;
  *(_QWORD *)&v27 = *MEMORY[0x1E0DE4F50];
  v23 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v27 + *(_QWORD *)(v27 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v28 = v23;
  *((_QWORD *)&v28 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v33) < 0)
    operator delete(v32[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A858F92C](v35);
}

void sub_1A34C01D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34C01E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
    operator delete(__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::Parameters::toString@<X0>(BasebandTransport::Parameters *this@<X0>, _BYTE *a2@<X8>)
{
  __int128 v4;
  size_t v5;
  int v6;
  uint64_t p_p;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  char v18;
  size_t v19;
  uint64_t v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  void *v27[2];
  char v28;
  void *__p;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  void *v37[2];
  __int128 v38;
  __int128 v39;
  _OWORD v40[9];
  unint64_t v41;

  v41 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v4;
  v40[8] = v4;
  v40[5] = v4;
  v40[6] = v4;
  v40[3] = v4;
  v40[4] = v4;
  v40[1] = v4;
  v40[2] = v4;
  v39 = v4;
  v40[0] = v4;
  *(_OWORD *)v37 = v4;
  v38 = v4;
  v35 = v4;
  v36 = v4;
  v33 = v4;
  v34 = v4;
  v32 = v4;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v32);
  switch(*(_DWORD *)this)
  {
    case 0:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "PBL");
      break;
    case 1:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "SBL");
      break;
    case 2:
      v5 = 4;
      v28 = 4;
      v6 = 1195460932;
      goto LABEL_25;
    case 3:
      v5 = 4;
      v28 = 4;
      v6 = 1397114194;
      goto LABEL_25;
    case 4:
      v5 = 5;
      v28 = 5;
      strcpy((char *)v27, "QMUX1");
      break;
    case 5:
      v5 = 5;
      v28 = 5;
      strcpy((char *)v27, "QMUX2");
      break;
    case 6:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "ROM");
      break;
    case 7:
      v5 = 4;
      v28 = 4;
      v6 = 1414483778;
      goto LABEL_25;
    case 8:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "ARI");
      break;
    case 9:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "STT");
      break;
    case 0xA:
      v5 = 2;
      v28 = 2;
      strcpy((char *)v27, "AT");
      break;
    case 0xB:
      v5 = 4;
      v28 = 4;
      v6 = 1280328769;
      goto LABEL_25;
    case 0xC:
      v5 = 8;
      v28 = 8;
      strcpy((char *)v27, "MEDIACTL");
      break;
    case 0xD:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "ETS");
      break;
    case 0xE:
      v5 = 4;
      v28 = 4;
      v6 = 1397968455;
      goto LABEL_25;
    case 0xF:
      v5 = 4;
      v28 = 4;
      v6 = 1397965905;
      goto LABEL_25;
    case 0x10:
      v5 = 5;
      v28 = 5;
      strcpy((char *)v27, "RCTTH");
      break;
    case 0x11:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "ACP");
      break;
    case 0x12:
      v5 = 4;
      v28 = 4;
      v6 = 1297040214;
      goto LABEL_25;
    case 0x13:
      v5 = 4;
      v28 = 4;
      v6 = 1129335117;
LABEL_25:
      LODWORD(v27[0]) = v6;
      BYTE4(v27[0]) = 0;
      break;
    case 0x14:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "DHL");
      break;
    case 0x15:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "MUX");
      break;
    case 0x16:
      v5 = 3;
      v28 = 3;
      strcpy((char *)v27, "FAC");
      break;
    default:
      v5 = 7;
      v28 = 7;
      strcpy((char *)v27, "Unknown");
      break;
  }
  v30 = 8250;
  v31 = 0;
  HIBYTE(v31) = v5 + 10;
  __p = *(void **)"Protocol: ";
  memcpy((char *)&v30 + 2, v27, v5);
  *((_BYTE *)&v30 + v5 + 2) = 0;
  if (v31 >= 0)
    p_p = (uint64_t)&__p;
  else
    p_p = 0x6C6F636F746F7250;
  if (v31 >= 0)
    v8 = HIBYTE(v31);
  else
    v8 = v30;
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, p_p, v8);
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"Powersave: ", 11);
  *(_DWORD *)((char *)v11 + *(_QWORD *)(*v11 - 24) + 8) |= 1u;
  v12 = (_QWORD *)std::ostream::operator<<();
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"Create Timeout: ", 16);
  v14 = (_QWORD *)std::ostream::operator<<();
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" sec, ", 6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"IO Size: ", 9);
  v16 = (_QWORD *)std::ostream::operator<<();
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" KB, ", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"Num Pending Reads: ", 19);
  std::ostream::operator<<();
  if (SHIBYTE(v31) < 0)
  {
    operator delete(__p);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_34:
      v18 = BYTE8(v39);
      if ((BYTE8(v39) & 0x10) == 0)
        goto LABEL_35;
LABEL_39:
      v20 = v39;
      if ((unint64_t)v39 < *((_QWORD *)&v36 + 1))
      {
        *(_QWORD *)&v39 = *((_QWORD *)&v36 + 1);
        v20 = *((_QWORD *)&v36 + 1);
      }
      v21 = (const void *)v36;
      v19 = v20 - v36;
      if ((unint64_t)(v20 - v36) >= 0x7FFFFFFFFFFFFFF8)
        goto LABEL_53;
      goto LABEL_42;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_34;
  }
  operator delete(v27[0]);
  v18 = BYTE8(v39);
  if ((BYTE8(v39) & 0x10) != 0)
    goto LABEL_39;
LABEL_35:
  if ((v18 & 8) == 0)
  {
    v19 = 0;
    a2[23] = 0;
    goto LABEL_49;
  }
  v21 = (const void *)*((_QWORD *)&v34 + 1);
  v19 = *((_QWORD *)&v35 + 1) - *((_QWORD *)&v34 + 1);
  if (*((_QWORD *)&v35 + 1) - *((_QWORD *)&v34 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_53:
    std::string::__throw_length_error[abi:ne180100]();
LABEL_42:
  if (v19 >= 0x17)
  {
    v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v22 = v19 | 7;
    v23 = v22 + 1;
    v24 = operator new(v22 + 1);
    *((_QWORD *)a2 + 1) = v19;
    *((_QWORD *)a2 + 2) = v23 | 0x8000000000000000;
    *(_QWORD *)a2 = v24;
    a2 = v24;
    goto LABEL_48;
  }
  a2[23] = v19;
  if (v19)
LABEL_48:
    memmove(a2, v21, v19);
LABEL_49:
  a2[v19] = 0;
  *(_QWORD *)&v32 = *MEMORY[0x1E0DE4F50];
  v25 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v32 + *(_QWORD *)(v32 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v33 = v25;
  *((_QWORD *)&v33 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v38) < 0)
    operator delete(v37[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A858F92C](v40);
}

void sub_1A34C0868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34C087C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0)
  {
    operator delete(__p);
    if ((a14 & 0x80000000) == 0)
    {
LABEL_3:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a21);
      _Unwind_Resume(a1);
    }
  }
  else if ((a14 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::BasebandTransport(uint64_t a1, _QWORD *a2, NSObject **a3)
{
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  capabilities::abs *v11;
  capabilities::abs *shouldUseMinBasebandTransportIOReadSize;
  int v13;
  NSObject *v14;
  uint64_t Controller;
  _BYTE v17[16];
  _BYTE v18[16];
  _BYTE v19[16];

  *(_QWORD *)a1 = off_1E4A09EB8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v17, "com.apple.telephony.abm", "ipc.bb");
  v6 = dispatch_queue_create("ipc.bb", 0);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = v6;
  if (v6)
  {
    v7 = v6;
    dispatch_retain(v6);
    *(_QWORD *)(a1 + 96) = 0;
    dispatch_release(v7);
  }
  else
  {
    *(_QWORD *)(a1 + 96) = 0;
  }
  *(_QWORD *)a1 = off_1E4A0A340;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v19);
  *(_QWORD *)(a1 + 8) = &unk_1E4A06330;
  *(_QWORD *)(a1 + 56) = *a2;
  v8 = a2[1];
  *(_QWORD *)(a1 + 64) = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
  *(_QWORD *)a1 = off_1E4A0A458;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v17);
  *(_QWORD *)a1 = off_1E4A09EB8;
  *(_DWORD *)(a1 + 104) = 23;
  *(_BYTE *)(a1 + 108) = 0;
  *(_QWORD *)(a1 + 112) = 10;
  shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v11);
  if ((_DWORD)shouldUseMinBasebandTransportIOReadSize)
    v13 = 0x4000;
  else
    v13 = 0x8000;
  *(_DWORD *)(a1 + 120) = v13;
  capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize);
  *(_DWORD *)(a1 + 124) = 4;
  *(_QWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  v14 = *a3;
  *(_QWORD *)(a1 + 152) = *a3;
  if (v14)
    dispatch_retain(v14);
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  Controller = TelephonyBasebandCreateController();
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 264) = Controller;
  *(_QWORD *)(a1 + 285) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 320) = dispatch_group_create();
  *(_DWORD *)(a1 + 328) = 0;
  *(_BYTE *)(a1 + 332) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_QWORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_QWORD *)(a1 + 365) = 0;
  return a1;
}

void sub_1A34C0ABC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  const void **v2;
  const void *v4;
  NSObject *v5;
  const void *v6;

  v4 = (const void *)v1[21];
  if (v4)
    _Block_release(v4);
  if (*v2)
    _Block_release(*v2);
  v5 = v1[19];
  if (v5)
    dispatch_release(v5);
  v6 = (const void *)v1[18];
  if (v6)
    _Block_release(v6);
  ctu::SharedLoggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(v1);
  _Unwind_Resume(a1);
}

const char *BasebandTransport::getName(BasebandTransport *this)
{
  return "ipc.bb";
}

_QWORD *ctu::SharedLoggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A0A340;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A0A340;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void BasebandTransport::~BasebandTransport(BasebandTransport *this)
{
  NSObject *v2;
  NSObject *v3;
  const void *v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  uint8_t v16[16];

  *(_QWORD *)this = off_1E4A09EB8;
  v2 = *((_QWORD *)this + 35);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((_QWORD *)this + 35) = 0;
    v3 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", v16, 2u);
    }
  }
  (*(void (**)(BasebandTransport *))(*(_QWORD *)this + 80))(this);
  v4 = (const void *)*((_QWORD *)this + 33);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 33) = 0;
  }
  v5 = (void *)*((_QWORD *)this + 37);
  if (v5)
  {
    operator delete[](v5);
    *((_QWORD *)this + 37) = 0;
  }
  v6 = *((_QWORD *)this + 40);
  if (v6)
    dispatch_release(v6);
  v7 = *((_QWORD *)this + 39);
  if (v7)
    dispatch_release(v7);
  v8 = (const void *)*((_QWORD *)this + 34);
  if (v8)
    _Block_release(v8);
  v9 = (const void *)*((_QWORD *)this + 21);
  if (v9)
    _Block_release(v9);
  v10 = (const void *)*((_QWORD *)this + 20);
  if (v10)
    _Block_release(v10);
  v11 = *((_QWORD *)this + 19);
  if (v11)
    dispatch_release(v11);
  v12 = (const void *)*((_QWORD *)this + 18);
  if (v12)
    _Block_release(v12);
  *(_QWORD *)this = off_1E4A0A340;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v13 = *((_QWORD *)this + 12);
  if (v13)
    dispatch_release(v13);
  v14 = *((_QWORD *)this + 11);
  if (v14)
    dispatch_release(v14);
  v15 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
}

{
  void *v1;

  BasebandTransport::~BasebandTransport(this);
  operator delete(v1);
}

void BasebandTransport::timerOff_sync(BasebandTransport *this)
{
  NSObject *v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *((_QWORD *)this + 35);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((_QWORD *)this + 35) = 0;
    v3 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", v4, 2u);
    }
  }
}

void BasebandTransport::create(NSObject **a1@<X0>, uint64_t a2@<X8>)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  NSObject *v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZL14sLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  block[3] = &__block_descriptor_tmp_75;
  block[4] = &qword_1ED114A40;
  if (_MergedGlobals_10 == -1)
  {
    v4 = *(std::__shared_weak_count **)algn_1ED114A48;
    v11 = qword_1ED114A40;
    v12 = *(_QWORD *)algn_1ED114A48;
    if (!*(_QWORD *)algn_1ED114A48)
      goto LABEL_5;
  }
  else
  {
    dispatch_once(&_MergedGlobals_10, block);
    v4 = *(std::__shared_weak_count **)algn_1ED114A48;
    v11 = qword_1ED114A40;
    v12 = *(_QWORD *)algn_1ED114A48;
    if (!*(_QWORD *)algn_1ED114A48)
      goto LABEL_5;
  }
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldxr(p_shared_owners);
  while (__stxr(v6 + 1, p_shared_owners));
LABEL_5:
  v7 = *a1;
  v10 = v7;
  if (v7)
    dispatch_retain(v7);
  BasebandTransport::create((capabilities::radio *)&v11, &v10, a2);
  if (v7)
    dispatch_release(v7);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A34C0EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  NSObject *v10;

  if (v10)
    dispatch_release(v10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void BasebandTransport::create(capabilities::radio *a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  int v6;
  std::__shared_weak_count_vtbl *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  std::__shared_weak_count *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  BasebandTransportICE *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  NSObject *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  std::__shared_weak_count *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t *v44;
  std::__shared_weak_count_vtbl *v45;
  std::__shared_weak_count *v46;
  unint64_t *p_shared_owners;
  unint64_t v48;
  NSObject *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  std::__shared_weak_count *v52;
  unint64_t v53;
  unint64_t *p_shared_weak_owners;
  unint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t *v62;
  NSObject *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  dispatch_object_t object;
  uint64_t v67;
  std::__shared_weak_count *v68;
  dispatch_object_t v69;
  uint64_t v70;
  std::__shared_weak_count *v71;
  _QWORD *v72;
  unint64_t v73;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v6 = capabilities::radio::vendor(a1);
  if (v6 == 1)
  {
    v45 = (std::__shared_weak_count_vtbl *)operator new(0x198uLL);
    v46 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
    v70 = *(_QWORD *)a1;
    v71 = v46;
    if (v46)
    {
      p_shared_owners = (unint64_t *)&v46->__shared_owners_;
      do
        v48 = __ldxr(p_shared_owners);
      while (__stxr(v48 + 1, p_shared_owners));
    }
    v49 = *a2;
    v69 = v49;
    if (v49)
      dispatch_retain(v49);
    BasebandTransportMAV::BasebandTransportMAV(v45, &v70, &v69);
    v72 = &v45->~__shared_weak_count;
    v73 = 0xAAAAAAAAAAAAAAAALL;
    v50 = (std::__shared_weak_count *)operator new(0x20uLL);
    v50->__shared_owners_ = 0;
    v51 = (unint64_t *)&v50->__shared_owners_;
    v50->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A498;
    v50->__shared_weak_owners_ = 0;
    v50[1].__vftable = v45;
    v73 = (unint64_t)v50;
    v52 = (std::__shared_weak_count *)v45[2].~__shared_weak_count;
    if (v52)
    {
      if (v52->__shared_owners_ != -1)
      {
LABEL_70:
        v60 = (uint64_t)v72;
        ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v72);
        v61 = v73;
        v72 = 0;
        v73 = 0;
        *(_QWORD *)a3 = v60;
        *(_QWORD *)(a3 + 8) = v61;
        if (v69)
          dispatch_release(v69);
        v24 = v71;
        if (!v71)
          goto LABEL_77;
        v62 = (unint64_t *)&v71->__shared_owners_;
        do
          v26 = __ldaxr(v62);
        while (__stlxr(v26 - 1, v62));
        goto LABEL_75;
      }
      do
        v53 = __ldxr(v51);
      while (__stxr(v53 + 1, v51));
      p_shared_weak_owners = (unint64_t *)&v50->__shared_weak_owners_;
      do
        v55 = __ldxr(p_shared_weak_owners);
      while (__stxr(v55 + 1, p_shared_weak_owners));
      v45[1].__on_zero_shared_weak = (void (__cdecl *)(std::__shared_weak_count *__hidden))v45;
      v45[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v50;
      std::__shared_weak_count::__release_weak(v52);
    }
    else
    {
      do
        v56 = __ldxr(v51);
      while (__stxr(v56 + 1, v51));
      v57 = (unint64_t *)&v50->__shared_weak_owners_;
      do
        v58 = __ldxr(v57);
      while (__stxr(v58 + 1, v57));
      v45[1].__on_zero_shared_weak = (void (__cdecl *)(std::__shared_weak_count *__hidden))v45;
      v45[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v50;
    }
    do
      v59 = __ldaxr(v51);
    while (__stlxr(v59 - 1, v51));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
    goto LABEL_70;
  }
  if (v6 == 2)
  {
    v27 = (BasebandTransportICE *)operator new(0x208uLL);
    v28 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
    v67 = *(_QWORD *)a1;
    v68 = v28;
    if (v28)
    {
      v29 = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    v31 = *a2;
    object = v31;
    if (v31)
      dispatch_retain(v31);
    BasebandTransportICE::BasebandTransportICE(v27, &v67, &object);
    v72 = v27;
    v73 = 0xAAAAAAAAAAAAAAAALL;
    v32 = (std::__shared_weak_count *)operator new(0x20uLL);
    v32->__shared_owners_ = 0;
    v33 = (unint64_t *)&v32->__shared_owners_;
    v32->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A4E8;
    v32->__shared_weak_owners_ = 0;
    v32[1].__vftable = (std::__shared_weak_count_vtbl *)v27;
    v73 = (unint64_t)v32;
    v34 = (std::__shared_weak_count *)*((_QWORD *)v27 + 10);
    if (v34)
    {
      if (v34->__shared_owners_ != -1)
      {
LABEL_46:
        v42 = (uint64_t)v72;
        ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v72);
        v43 = v73;
        v72 = 0;
        v73 = 0;
        *(_QWORD *)a3 = v42;
        *(_QWORD *)(a3 + 8) = v43;
        if (object)
          dispatch_release(object);
        v24 = v68;
        if (!v68)
          goto LABEL_77;
        v44 = (unint64_t *)&v68->__shared_owners_;
        do
          v26 = __ldaxr(v44);
        while (__stlxr(v26 - 1, v44));
        goto LABEL_75;
      }
      do
        v35 = __ldxr(v33);
      while (__stxr(v35 + 1, v33));
      v36 = (unint64_t *)&v32->__shared_weak_owners_;
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
      *((_QWORD *)v27 + 9) = v27;
      *((_QWORD *)v27 + 10) = v32;
      std::__shared_weak_count::__release_weak(v34);
    }
    else
    {
      do
        v38 = __ldxr(v33);
      while (__stxr(v38 + 1, v33));
      v39 = (unint64_t *)&v32->__shared_weak_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
      *((_QWORD *)v27 + 9) = v27;
      *((_QWORD *)v27 + 10) = v32;
    }
    do
      v41 = __ldaxr(v33);
    while (__stlxr(v41 - 1, v33));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
    goto LABEL_46;
  }
  if (v6 != 3)
    return;
  v7 = (std::__shared_weak_count_vtbl *)operator new(0x198uLL);
  v8 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
  v64 = *(_QWORD *)a1;
  v65 = v8;
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = *a2;
  v63 = v11;
  if (v11)
    dispatch_retain(v11);
  BasebandTransport::BasebandTransport((uint64_t)v7, &v64, &v63);
  v72 = &v7->~__shared_weak_count;
  v73 = 0xAAAAAAAAAAAAAAAALL;
  v12 = (std::__shared_weak_count *)operator new(0x20uLL);
  v12->__shared_owners_ = 0;
  v13 = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A538;
  v12->__shared_weak_owners_ = 0;
  v12[1].__vftable = v7;
  v73 = (unint64_t)v12;
  v14 = (std::__shared_weak_count *)v7[2].~__shared_weak_count;
  if (!v14)
  {
    do
      v18 = __ldxr(v13);
    while (__stxr(v18 + 1, v13));
    v19 = (unint64_t *)&v12->__shared_weak_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    v7[1].__on_zero_shared_weak = (void (__cdecl *)(std::__shared_weak_count *__hidden))v7;
    v7[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v12;
    do
LABEL_19:
      v21 = __ldaxr(v13);
    while (__stlxr(v21 - 1, v13));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    goto LABEL_22;
  }
  if (v14->__shared_owners_ == -1)
  {
    do
      v15 = __ldxr(v13);
    while (__stxr(v15 + 1, v13));
    v16 = (unint64_t *)&v12->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    v7[1].__on_zero_shared_weak = (void (__cdecl *)(std::__shared_weak_count *__hidden))v7;
    v7[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v12;
    std::__shared_weak_count::__release_weak(v14);
    goto LABEL_19;
  }
LABEL_22:
  v22 = (uint64_t)v72;
  ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v72);
  v23 = v73;
  v72 = 0;
  v73 = 0;
  *(_QWORD *)a3 = v22;
  *(_QWORD *)(a3 + 8) = v23;
  if (v11)
    dispatch_release(v11);
  v24 = v65;
  if (!v65)
    goto LABEL_77;
  v25 = (unint64_t *)&v65->__shared_owners_;
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 - 1, v25));
LABEL_75:
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
LABEL_77:
  BasebandTransport::init(*(BasebandTransport **)a3);
}

void sub_1A34C1374(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, dispatch_object_t a13, char a14, uint64_t a15, dispatch_object_t object, char a17)
{
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v19 - 64);
  if (v18)
    dispatch_release(v18);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v17);
  _Unwind_Resume(a1);
}

void BasebandTransport::init(BasebandTransport *this)
{
  std::__shared_weak_count *v3;
  char *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  _QWORD v16[6];
  std::__shared_weak_count *v17;
  _QWORD *v18;
  _QWORD block[6];

  v5 = *((_QWORD *)this + 9);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  v4 = (char *)this + 72;
  if (!v3 || (v6 = std::__shared_weak_count::lock(v3)) == 0)
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
  do
    v9 = __ldxr(p_shared_weak_owners);
  while (__stxr(v9 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
  }
  v12 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 1174405120;
  v16[2] = ___ZN17BasebandTransport4initEv_block_invoke;
  v16[3] = &__block_descriptor_tmp_47_0;
  v16[4] = this;
  v16[5] = v5;
  v17 = v7;
  do
    v13 = __ldxr(p_shared_weak_owners);
  while (__stxr(v13 + 1, p_shared_weak_owners));
  v18 = v16;
  block[0] = v12;
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_77;
  block[4] = v4;
  block[5] = &v18;
  v14 = *((_QWORD *)this + 11);
  if (!*((_QWORD *)this + 12))
  {
    dispatch_sync(v14, block);
    v15 = v17;
    if (!v17)
      goto LABEL_14;
    goto LABEL_13;
  }
  dispatch_async_and_wait(v14, block);
  v15 = v17;
  if (v17)
LABEL_13:
    std::__shared_weak_count::__release_weak(v15);
LABEL_14:
  std::__shared_weak_count::__release_weak(v7);
}

void ___ZN17BasebandTransport4initEv_block_invoke(capabilities::ipc *a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  void *v8;
  const void *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  void *v14;
  const void *v15;
  _QWORD v16[6];
  std::__shared_weak_count *v17;
  _QWORD aBlock[6];
  std::__shared_weak_count *v19;

  v2 = *((_QWORD *)a1 + 4);
  if (capabilities::ipc::supportsPCI(a1))
  {
    v3 = MEMORY[0x1E0C809B0];
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN17BasebandTransport4initEv_block_invoke_2;
    aBlock[3] = &__block_descriptor_tmp_12;
    v5 = *((_QWORD *)a1 + 5);
    v4 = (std::__shared_weak_count *)*((_QWORD *)a1 + 6);
    aBlock[4] = v2;
    aBlock[5] = v5;
    v19 = v4;
    if (v4)
    {
      p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
      do
        v7 = __ldxr(p_shared_weak_owners);
      while (__stxr(v7 + 1, p_shared_weak_owners));
    }
    v8 = _Block_copy(aBlock);
    v9 = *(const void **)(v2 + 160);
    *(_QWORD *)(v2 + 160) = v8;
    if (v9)
      _Block_release(v9);
    v16[0] = v3;
    v16[1] = 1174405120;
    v16[2] = ___ZN17BasebandTransport4initEv_block_invoke_43;
    v16[3] = &__block_descriptor_tmp_45_0;
    v11 = *((_QWORD *)a1 + 5);
    v10 = (std::__shared_weak_count *)*((_QWORD *)a1 + 6);
    v16[4] = v2;
    v16[5] = v11;
    v17 = v10;
    if (v10)
    {
      v12 = (unint64_t *)&v10->__shared_weak_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v14 = _Block_copy(v16);
    v15 = *(const void **)(v2 + 168);
    *(_QWORD *)(v2 + 168) = v14;
    if (v15)
      _Block_release(v15);
    if (v17)
      std::__shared_weak_count::__release_weak(v17);
    if (v19)
      std::__shared_weak_count::__release_weak(v19);
  }
}

void ___ZN17BasebandTransport4initEv_block_invoke_2(_QWORD *a1, int a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  NSObject *v12;
  const void *v13;
  void *v14;
  const void *v15;
  __int128 v16;
  NSObject *v17;
  void *v18;
  char *v19;
  __int128 v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  _BYTE v23[32];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v9 = a1[4];
    v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      v11 = v10;
      if (a1[5])
      {
        v12 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v23 = 67109632;
          *(_DWORD *)&v23[4] = a2;
          *(_WORD *)&v23[8] = 2048;
          *(_QWORD *)&v23[10] = a3;
          *(_WORD *)&v23[18] = 2048;
          *(_QWORD *)&v23[20] = a4;
          _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "PCI Transport Status: 0x%x (0x%08lx, 0x%08lx)", v23, 0x1Cu);
        }
        *(_DWORD *)(v9 + 328) = 2 * (a2 != 0);
        *(int64x2_t *)(v9 + 352) = vsubq_s64(*(int64x2_t *)(v9 + 336), *(int64x2_t *)(v9 + 376));
        v13 = *(const void **)(v9 + 272);
        if (v13)
        {
          v14 = _Block_copy(v13);
          v15 = v14;
          v16 = *(_OWORD *)(v9 + 344);
          *(_OWORD *)v23 = *(_OWORD *)(v9 + 328);
          *(_OWORD *)&v23[16] = v16;
          v24 = *(_QWORD *)(v9 + 360);
          v17 = *(NSObject **)(v9 + 152);
          if (v14)
            v18 = _Block_copy(v14);
          else
            v18 = 0;
          v19 = (char *)operator new(0x30uLL);
          *(_QWORD *)v19 = v18;
          v20 = *(_OWORD *)&v23[16];
          *(_OWORD *)(v19 + 8) = *(_OWORD *)v23;
          *(_OWORD *)(v19 + 24) = v20;
          *((_QWORD *)v19 + 5) = v24;
          dispatch_async_f(v17, v19, (dispatch_function_t)_ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb0_E3__0EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_);
          if (v15)
            _Block_release(v15);
        }
      }
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
}

void sub_1A34C1910(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

int64x2_t BasebandTransport::updateDeltas_sync(BasebandTransport *this)
{
  int64x2_t result;

  result = vsubq_s64(*((int64x2_t *)this + 21), *(int64x2_t *)((char *)this + 376));
  *((int64x2_t *)this + 22) = result;
  return result;
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrI17BasebandTransportEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrI17BasebandTransportEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN17BasebandTransport4initEv_block_invoke_43(_QWORD *a1, int a2, void *a3, unsigned int a4)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  const void *v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  char v21;
  NSObject *v22;
  void *v23;
  void *v24;
  size_t v25;
  char *v26;
  char *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *__p;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint8_t buf[8];
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v6 = a1[4];
  v33 = 0;
  v34 = 0;
  v7 = (std::__shared_weak_count *)a1[6];
  if (v7 && (v34 = std::__shared_weak_count::lock(v7)) != 0 && (v10 = a1[5], (v33 = v10) != 0))
  {
    v11 = *(NSObject **)(v10 + 320);
    if (v11)
    {
      dispatch_retain(*(dispatch_object_t *)(v10 + 320));
      dispatch_group_enter(v11);
    }
    if (a2)
    {
      v12 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = a2;
        _os_log_debug_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEBUG, "#D Async read error 0x%08x", buf, 8u);
      }
    }
    else
    {
      *(_QWORD *)(v6 + 336) += a4;
      v16 = *(const void **)(v6 + 144);
      if (v16)
      {
        v17 = _Block_copy(v16);
        v18 = *(_QWORD *)(v6 + 128);
        if (v18)
        {
          __p = 0;
          v31 = 0;
          v32 = 0;
          (*(void (**)(uint64_t, void *, _QWORD, void **))(*(_QWORD *)v18 + 8))(v18, a3, a4, &__p);
          v19 = *(NSObject **)(v6 + 152);
          if (v17)
            v20 = _Block_copy(v17);
          else
            v20 = 0;
          *(_QWORD *)buf = v20;
          v36 = 0;
          v37 = 0;
          v38 = 0;
          v24 = __p;
          v25 = v31 - (_BYTE *)__p;
          if (v31 == __p)
          {
            v27 = 0;
            v26 = 0;
          }
          else
          {
            if ((v25 & 0x8000000000000000) != 0)
              std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
            v26 = (char *)operator new(v31 - (_BYTE *)__p);
            v27 = &v26[v25];
            v36 = v26;
            v38 = &v26[v25];
            memcpy(v26, v24, v25);
            v37 = &v26[v25];
          }
          v28 = operator new(0x20uLL);
          *v28 = v20;
          v28[1] = v26;
          v28[2] = v27;
          v28[3] = v27;
          dispatch_async_f(v19, v28, (dispatch_function_t)_ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_);
          if (__p)
          {
            v31 = __p;
            operator delete(__p);
          }
        }
        else
        {
          v21 = *(_BYTE *)(v6 + 136);
          v22 = *(NSObject **)(v6 + 152);
          if (v17)
            v23 = _Block_copy(v17);
          else
            v23 = 0;
          v29 = operator new(0x18uLL);
          *v29 = v23;
          v29[1] = a3;
          *((_DWORD *)v29 + 4) = a4;
          *((_BYTE *)v29 + 20) = v21;
          dispatch_async_f(v22, v29, (dispatch_function_t)_ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_);
          a3 = 0;
        }
        if (v17)
          _Block_release(v17);
      }
    }
    if (a3 && !*(_BYTE *)(v6 + 136))
      free(a3);
    if (v11)
    {
      dispatch_group_leave(v11);
      dispatch_release(v11);
    }
  }
  else if (a3)
  {
    free(a3);
  }
  v13 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1A34C1C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *aBlock, void *a16, uint64_t a17)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

BOOL BasebandTransport::open(BasebandTransport *a1, __int128 *a2, void **a3)
{
  uint64_t v6;
  __int128 v7;
  void *v8;
  NSObject *v9;
  int v10;
  void *v11;
  _QWORD v13[6];
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  void *aBlock;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;
  _QWORD *v22;
  _QWORD block[6];

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  BasebandTransport::stopReader(a1);
  v6 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 1174405120;
  v13[2] = ___ZN17BasebandTransport4openENS_10ParametersEN8dispatch5blockIU13block_pointerFvPhjEEE_block_invoke;
  v13[3] = &unk_1E4A09FA8;
  v13[5] = a1;
  v7 = a2[1];
  v14 = *a2;
  v15 = v7;
  v16 = *((_QWORD *)a2 + 4);
  v8 = *a3;
  if (*a3)
    v8 = _Block_copy(v8);
  aBlock = v8;
  v13[4] = &v18;
  v22 = v13;
  block[0] = v6;
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_77;
  block[4] = (char *)a1 + 72;
  block[5] = &v22;
  v9 = *((_QWORD *)a1 + 11);
  if (*((_QWORD *)a1 + 12))
  {
    dispatch_async_and_wait(v9, block);
    v10 = *((unsigned __int8 *)v19 + 24);
    v11 = aBlock;
    if (!aBlock)
      goto LABEL_8;
    goto LABEL_7;
  }
  dispatch_sync(v9, block);
  v10 = *((unsigned __int8 *)v19 + 24);
  v11 = aBlock;
  if (aBlock)
LABEL_7:
    _Block_release(v11);
LABEL_8:
  _Block_object_dispose(&v18, 8);
  return v10 != 0;
}

void sub_1A34C1E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void BasebandTransport::stopReader(BasebandTransport *this)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  NSObject *v7;
  dispatch_time_t v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  _QWORD v13[6];
  _QWORD v14[6];
  _QWORD v15[3];
  char v16;
  _QWORD *v17;
  _QWORD block[6];

  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x2000000000;
  v16 = 0;
  v2 = (uint64_t *)((char *)this + 72);
  v3 = MEMORY[0x1E0C809B0];
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = ___ZN17BasebandTransport10stopReaderEv_block_invoke;
  v14[3] = &unk_1E4A0A110;
  v14[4] = v15;
  v14[5] = this;
  v17 = v14;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_77;
  block[4] = (char *)this + 72;
  block[5] = &v17;
  v5 = (char *)this + 88;
  v4 = *((_QWORD *)this + 11);
  if (*((_QWORD *)v5 + 1))
    dispatch_async_and_wait(v4, block);
  else
    dispatch_sync(v4, block);
  v13[0] = v3;
  v13[1] = 0x40000000;
  v13[2] = ___ZN17BasebandTransport10stopReaderEv_block_invoke_2;
  v13[3] = &unk_1E4A0A138;
  v13[4] = v15;
  v13[5] = this;
  ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v2, (uint64_t)v13);
  v6 = *((_QWORD *)this + 40);
  if (v6)
  {
    v7 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block[0]) = 0;
      _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I Waiting for reader to be stopped", (uint8_t *)block, 2u);
      v6 = *((_QWORD *)this + 40);
    }
    v8 = dispatch_time(0, 3000000000);
    if (dispatch_group_wait(v6, v8))
    {
      (*(void (**)(BasebandTransport *))(*(_QWORD *)this + 80))(this);
      v9 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LOWORD(block[0]) = 0;
        _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Timeout waiting for read to unblock, freed transport to force read unblock", (uint8_t *)block, 2u);
      }
    }
    else
    {
      v11 = (void *)*((_QWORD *)this + 37);
      if (v11)
      {
        operator delete[](v11);
        *((_QWORD *)this + 37) = 0;
        v12 = *((_QWORD *)this + 39);
        *((_QWORD *)this + 39) = 0;
        if (v12)
          dispatch_release(v12);
      }
    }
    v10 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block[0]) = 0;
      _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Reader stopped", (uint8_t *)block, 2u);
    }
  }
  _Block_object_dispose(v15, 8);
}

void sub_1A34C2050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN17BasebandTransport4openENS_10ParametersEN8dispatch5blockIU13block_pointerFvPhjEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  char v5;
  __int128 v6;
  void *v7;
  const void *v8;
  _QWORD v9[5];
  char v10;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(NSObject **)(v2 + 280);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v2 + 280));
    *(_QWORD *)(v2 + 280) = 0;
    v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9[0]) = 0;
      _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", (uint8_t *)v9, 2u);
    }
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
  *(_DWORD *)(v2 + 328) = 0;
  *(_BYTE *)(v2 + 332) = 0;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 336) = 0u;
  *(_OWORD *)(v2 + 352) = 0u;
  *(_QWORD *)(v2 + 365) = 0;
  v5 = *(_BYTE *)(a1 + 80);
  v6 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(v2 + 104) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v2 + 120) = v6;
  *(_BYTE *)(v2 + 136) = v5;
  v7 = *(void **)(a1 + 88);
  if (v7)
    v7 = _Block_copy(v7);
  v8 = *(const void **)(v2 + 144);
  *(_QWORD *)(v2 + 144) = v7;
  if (v8)
    _Block_release(v8);
  if (*(_DWORD *)(v2 + 104) != 23)
  {
    if (capabilities::ipc::supportsPCI((capabilities::ipc *)v7))
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = BasebandTransport::openPCI_sync((BasebandTransport *)v2);
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      BasebandTransport::timerOn_sync((BasebandTransport *)v2);
    else
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = ___ZN17BasebandTransport9dumpStateEb_block_invoke;
    v9[3] = &__block_descriptor_tmp_70;
    v9[4] = v2;
    v10 = 0;
    ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped((uint64_t *)(v2 + 72), (uint64_t)v9);
  }
}

uint64_t BasebandTransport::openPCI_sync(BasebandTransport *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_weak_owners;
  unint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  capabilities::abs *inited;
  int v10;
  uint64_t shouldUseMinBasebandTransportIOReadCount;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  uint8_t *v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  int v27;
  int v28;
  int v29;
  unsigned int v31;
  unsigned int v32;
  uint8_t buf[23];
  char v34;
  uint8_t v35[4];
  uint8_t *v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2 || (v3 = std::__shared_weak_count::lock(v2)) == 0)
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v4 = v3;
  p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
  do
    v6 = __ldxr(p_shared_weak_owners);
  while (__stxr(v6 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v4);
  }
  inited = (capabilities::abs *)TelephonyBasebandPCITransportInitParameters();
  v10 = *((_DWORD *)this + 28);
  shouldUseMinBasebandTransportIOReadCount = capabilities::abs::traceTransportTimeoutScalingFactor(inited);
  v12 = 1000 * v10;
  if ((((1000 * v10) * (unint64_t)shouldUseMinBasebandTransportIOReadCount) & 0xFFFFFFFF00000000) != 0)
  {
    v13 = *((_QWORD *)this + 5);
    shouldUseMinBasebandTransportIOReadCount = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if ((_DWORD)shouldUseMinBasebandTransportIOReadCount)
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v12;
      _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Scaled create timeout overflowed, falling back to unscaled value: %u", buf, 8u);
    }
  }
  v14 = *((_DWORD *)this + 31);
  if (v14)
    goto LABEL_20;
  v15 = *((_DWORD *)this + 26);
  shouldUseMinBasebandTransportIOReadCount = capabilities::abs::shouldUseMinBasebandTransportIOReadCount((capabilities::abs *)shouldUseMinBasebandTransportIOReadCount);
  if ((shouldUseMinBasebandTransportIOReadCount & 1) != 0)
    goto LABEL_14;
  if (v15 != 2)
  {
    if (v15 != 16 && v15 != 15)
    {
LABEL_14:
      v31 = 4;
      v16 = *((_DWORD *)this + 30);
      if (!v16)
        goto LABEL_21;
      goto LABEL_24;
    }
    v14 = 36;
LABEL_20:
    v31 = v14;
    v16 = *((_DWORD *)this + 30);
    if (!v16)
      goto LABEL_21;
    goto LABEL_24;
  }
  v31 = 16;
  v16 = *((_DWORD *)this + 30);
  if (!v16)
  {
LABEL_21:
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)shouldUseMinBasebandTransportIOReadCount))
      v16 = 0x4000;
    else
      v16 = 0x8000;
  }
LABEL_24:
  v32 = v16;
  v17 = *((_DWORD *)this + 26);
  switch(v17)
  {
    case 0:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 1:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 2:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 3:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 4:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 5:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 6:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 7:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 8:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 9:
    case 17:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 10:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 11:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 12:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 13:
    case 18:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 14:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 15:
      v18 = v31;
      if (v31 < 0x41)
        goto LABEL_60;
      goto LABEL_30;
    case 16:
      v18 = v31;
      if (v31 >= 0x41)
      {
LABEL_30:
        v19 = *((_QWORD *)this + 5);
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          goto LABEL_148;
        switch(v17)
        {
          case 0:
            v34 = 3;
            strcpy((char *)buf, "PBL");
            break;
          case 1:
            v34 = 3;
            strcpy((char *)buf, "SBL");
            break;
          case 2:
            v34 = 4;
            v28 = 1195460932;
            goto LABEL_122;
          case 3:
            v34 = 4;
            v28 = 1397114194;
            goto LABEL_122;
          case 4:
            v34 = 5;
            strcpy((char *)buf, "QMUX1");
            break;
          case 5:
            v34 = 5;
            strcpy((char *)buf, "QMUX2");
            break;
          case 6:
            v34 = 3;
            strcpy((char *)buf, "ROM");
            break;
          case 7:
            v34 = 4;
            v28 = 1414483778;
            goto LABEL_122;
          case 8:
            v34 = 3;
            strcpy((char *)buf, "ARI");
            break;
          case 9:
            v34 = 3;
            strcpy((char *)buf, "STT");
            break;
          case 10:
            v34 = 2;
            strcpy((char *)buf, "AT");
            break;
          case 11:
            v34 = 4;
            v28 = 1280328769;
            goto LABEL_122;
          case 12:
            v34 = 8;
            strcpy((char *)buf, "MEDIACTL");
            break;
          case 13:
            v34 = 3;
            strcpy((char *)buf, "ETS");
            break;
          case 14:
            v34 = 4;
            v28 = 1397968455;
            goto LABEL_122;
          case 15:
            v34 = 4;
            v28 = 1397965905;
            goto LABEL_122;
          case 16:
            v34 = 5;
            strcpy((char *)buf, "RCTTH");
            break;
          case 17:
            v34 = 3;
            strcpy((char *)buf, "ACP");
            break;
          case 18:
            v34 = 4;
            v28 = 1297040214;
LABEL_122:
            *(_DWORD *)buf = v28;
            buf[4] = 0;
            break;
          default:
            v34 = 7;
            strcpy((char *)buf, "Unknown");
            break;
        }
        *(_DWORD *)v35 = 136315394;
        v36 = buf;
        v37 = 2048;
        v38 = v18;
        v24 = "%s: invalid transport io read count (%lu)";
LABEL_145:
        v25 = v19;
        v26 = 22;
LABEL_146:
        _os_log_error_impl(&dword_1A343C000, v25, OS_LOG_TYPE_ERROR, v24, v35, v26);
        if (v34 < 0)
          operator delete(*(void **)buf);
        goto LABEL_148;
      }
LABEL_60:
      if (v16 - 0x4000 > 0xFC000)
      {
        v19 = *((_QWORD *)this + 5);
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          goto LABEL_148;
        switch(v17)
        {
          case 0:
            v34 = 3;
            strcpy((char *)buf, "PBL");
            break;
          case 1:
            v34 = 3;
            strcpy((char *)buf, "SBL");
            break;
          case 2:
            v34 = 4;
            v29 = 1195460932;
            goto LABEL_143;
          case 3:
            v34 = 4;
            v29 = 1397114194;
            goto LABEL_143;
          case 4:
            v34 = 5;
            strcpy((char *)buf, "QMUX1");
            break;
          case 5:
            v34 = 5;
            strcpy((char *)buf, "QMUX2");
            break;
          case 6:
            v34 = 3;
            strcpy((char *)buf, "ROM");
            break;
          case 7:
            v34 = 4;
            v29 = 1414483778;
            goto LABEL_143;
          case 8:
            v34 = 3;
            strcpy((char *)buf, "ARI");
            break;
          case 9:
            v34 = 3;
            strcpy((char *)buf, "STT");
            break;
          case 10:
            v34 = 2;
            strcpy((char *)buf, "AT");
            break;
          case 11:
            v34 = 4;
            v29 = 1280328769;
            goto LABEL_143;
          case 12:
            v34 = 8;
            strcpy((char *)buf, "MEDIACTL");
            break;
          case 13:
            v34 = 3;
            strcpy((char *)buf, "ETS");
            break;
          case 14:
            v34 = 4;
            v29 = 1397968455;
            goto LABEL_143;
          case 15:
            v34 = 4;
            v29 = 1397965905;
            goto LABEL_143;
          case 16:
            v34 = 5;
            strcpy((char *)buf, "RCTTH");
            break;
          case 17:
            v34 = 3;
            strcpy((char *)buf, "ACP");
            break;
          case 18:
            v34 = 4;
            v29 = 1297040214;
LABEL_143:
            *(_DWORD *)buf = v29;
            buf[4] = 0;
            break;
          default:
            v34 = 7;
            strcpy((char *)buf, "Unknown");
            break;
        }
        *(_DWORD *)v35 = 136315394;
        v36 = buf;
        v37 = 2048;
        v38 = v16;
        v24 = "%s: invalid transport io read size (%lu)";
        goto LABEL_145;
      }
      if (*((_QWORD *)this + 18))
        *((_BYTE *)this + 332) = 1;
      if (!TelephonyBasebandPCITransportCreate())
      {
        *((_DWORD *)this + 82) = 2;
        v22 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          BasebandTransport::asString(*((unsigned int *)this + 26), (char *)buf);
          if (v34 >= 0)
            v23 = buf;
          else
            v23 = *(uint8_t **)buf;
          *(_DWORD *)v35 = 136315138;
          v36 = v23;
          v24 = "%s: transport open failed";
          v25 = v22;
          v26 = 12;
          goto LABEL_146;
        }
LABEL_148:
        v20 = 0;
        goto LABEL_149;
      }
      v20 = 1;
      *((_DWORD *)this + 82) = 1;
      v21 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        switch(*((_DWORD *)this + 26))
        {
          case 0:
            v34 = 3;
            strcpy((char *)buf, "PBL");
            break;
          case 1:
            v34 = 3;
            strcpy((char *)buf, "SBL");
            break;
          case 2:
            v34 = 4;
            v27 = 1195460932;
            goto LABEL_97;
          case 3:
            v34 = 4;
            v27 = 1397114194;
            goto LABEL_97;
          case 4:
            v34 = 5;
            strcpy((char *)buf, "QMUX1");
            break;
          case 5:
            v34 = 5;
            strcpy((char *)buf, "QMUX2");
            break;
          case 6:
            v34 = 3;
            strcpy((char *)buf, "ROM");
            break;
          case 7:
            v34 = 4;
            v27 = 1414483778;
            goto LABEL_97;
          case 8:
            v34 = 3;
            strcpy((char *)buf, "ARI");
            break;
          case 9:
            v34 = 3;
            strcpy((char *)buf, "STT");
            break;
          case 0xA:
            v34 = 2;
            strcpy((char *)buf, "AT");
            break;
          case 0xB:
            v34 = 4;
            v27 = 1280328769;
            goto LABEL_97;
          case 0xC:
            v34 = 8;
            strcpy((char *)buf, "MEDIACTL");
            break;
          case 0xD:
            v34 = 3;
            strcpy((char *)buf, "ETS");
            break;
          case 0xE:
            v34 = 4;
            v27 = 1397968455;
            goto LABEL_97;
          case 0xF:
            v34 = 4;
            v27 = 1397965905;
            goto LABEL_97;
          case 0x10:
            v34 = 5;
            strcpy((char *)buf, "RCTTH");
            break;
          case 0x11:
            v34 = 3;
            strcpy((char *)buf, "ACP");
            break;
          case 0x12:
            v34 = 4;
            v27 = 1297040214;
            goto LABEL_97;
          case 0x13:
            v34 = 4;
            v27 = 1129335117;
LABEL_97:
            *(_DWORD *)buf = v27;
            buf[4] = 0;
            break;
          case 0x14:
            v34 = 3;
            strcpy((char *)buf, "DHL");
            break;
          case 0x15:
            v34 = 3;
            strcpy((char *)buf, "MUX");
            break;
          case 0x16:
            v34 = 3;
            strcpy((char *)buf, "FAC");
            break;
          default:
            v34 = 7;
            strcpy((char *)buf, "Unknown");
            break;
        }
        *(_DWORD *)v35 = 136315394;
        v36 = buf;
        v37 = 1024;
        LODWORD(v38) = v32;
        _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I %s: transport successfully opened with read io size as %u", v35, 0x12u);
        if (v34 < 0)
          operator delete(*(void **)buf);
      }
LABEL_149:
      std::__shared_weak_count::__release_weak(v4);
      return v20;
    default:
      goto LABEL_148;
  }
}

void sub_1A34C2E40(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void sub_1A34C2E54(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void BasebandTransport::timerOn_sync(BasebandTransport *this)
{
  NSObject *v2;
  NSObject *v3;
  unsigned int v4;
  uint64_t v5;
  NSObject *v6;
  dispatch_time_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  NSObject *v16;
  unint64_t v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  _QWORD handler[6];
  std::__shared_weak_count *v22;
  uint8_t buf[4];
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 35);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((_QWORD *)this + 35) = 0;
    v3 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", buf, 2u);
    }
  }
  if (*((_DWORD *)this + 82) == 1)
  {
    v4 = *((_DWORD *)this + 72);
    if (v4 && *((_QWORD *)this + 34))
    {
      v5 = 1000000000 * v4;
      v6 = dispatch_source_create(MEMORY[0x1E0C80DD0], 1uLL, 0, *((dispatch_queue_t *)this + 11));
      *((_QWORD *)this + 35) = v6;
      v7 = dispatch_time(0, v5);
      dispatch_source_set_timer(v6, v7, v5, 0xBEBC200uLL);
      v8 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
      if (!v8 || (v9 = *((_QWORD *)this + 9), (v10 = std::__shared_weak_count::lock(v8)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v11 = v10;
      p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
      do
        v13 = __ldxr(p_shared_weak_owners);
      while (__stxr(v13 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v11);
      }
      v16 = *((_QWORD *)this + 35);
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 1174405120;
      handler[2] = ___ZN17BasebandTransport12timerOn_syncEv_block_invoke;
      handler[3] = &__block_descriptor_tmp_69;
      handler[4] = this;
      handler[5] = v9;
      v22 = v11;
      do
        v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
      dispatch_source_set_event_handler(v16, handler);
      dispatch_activate(*((dispatch_object_t *)this + 35));
      v18 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *((_DWORD *)this + 72);
        *(_DWORD *)buf = 67109120;
        v24 = v19;
        _os_log_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEFAULT, "#I Status report enabled(%d sec)", buf, 8u);
      }
      if (v22)
        std::__shared_weak_count::__release_weak(v22);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
    v20 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v20, OS_LOG_TYPE_DEFAULT, "#I Invalid state for status report enable.  Ignoring enable request.", buf, 2u);
    }
  }
}

void BasebandTransport::dumpState(BasebandTransport *this, char a2)
{
  _QWORD v2[5];
  char v3;

  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 0x40000000;
  v2[2] = ___ZN17BasebandTransport9dumpStateEb_block_invoke;
  v2[3] = &__block_descriptor_tmp_70;
  v2[4] = this;
  v3 = a2;
  ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped((uint64_t *)this + 9, (uint64_t)v2);
}

void *__copy_helper_block_e8_88c45_ZTSN8dispatch5blockIU13block_pointerFvPhjEEE(uint64_t a1, uint64_t a2)
{
  void *result;

  result = *(void **)(a2 + 88);
  if (result)
    result = _Block_copy(result);
  *(_QWORD *)(a1 + 88) = result;
  return result;
}

void __destroy_helper_block_e8_88c45_ZTSN8dispatch5blockIU13block_pointerFvPhjEEE(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 88);
  if (v1)
    _Block_release(v1);
}

BOOL BasebandTransport::write(BasebandTransport *this, const unsigned __int8 *a2, uint64_t a3, unsigned int *a4)
{
  char *v7;
  _QWORD *v8;
  NSObject *v9;
  char *v10;
  NSObject *v11;
  uint64_t (**v12)(_QWORD, uint64_t);
  int v13;
  NSObject *v14;
  _BOOL8 v15;
  _QWORD v17[6];
  _QWORD v18[10];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  const unsigned __int8 *v26;
  uint64_t block;
  uint64_t p_block;
  uint64_t v29;
  __n128 (*v30)(_QWORD *, uint64_t);
  void (*v31)(uint64_t);
  void *__p;
  void *v33;
  uint64_t v34;
  _QWORD v35[7];
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  char v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  _QWORD *(*v47)(uint64_t);
  void *v48;
  char *v49;
  _QWORD *v50;

  v40 = 0;
  v41 = &v40;
  v42 = 0x2000000000;
  v43 = 0;
  v36 = 0;
  v37 = &v36;
  v38 = 0x2000000000;
  v39 = 0;
  v7 = (char *)this + 72;
  v8 = (_QWORD *)MEMORY[0x1E0C809B0];
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 0x40000000;
  v35[2] = ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke;
  v35[3] = &unk_1E4A09FE0;
  v35[5] = &v40;
  v35[6] = this;
  v35[4] = &v36;
  v45 = v35;
  block = MEMORY[0x1E0C809B0];
  p_block = 0x40000000;
  v29 = (uint64_t)___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  v30 = (__n128 (*)(_QWORD *, uint64_t))&__block_descriptor_tmp_77;
  v31 = (void (*)(uint64_t))((char *)this + 72);
  __p = &v45;
  v10 = (char *)this + 88;
  v9 = *((_QWORD *)this + 11);
  if (*((_QWORD *)v10 + 1))
  {
    dispatch_async_and_wait(v9, &block);
    if (*((_BYTE *)v41 + 24))
      goto LABEL_3;
LABEL_10:
    v15 = 0;
    goto LABEL_19;
  }
  dispatch_sync(v9, &block);
  if (!*((_BYTE *)v41 + 24))
    goto LABEL_10;
LABEL_3:
  block = 0;
  p_block = (uint64_t)&block;
  v29 = 0x4002000000;
  v30 = __Block_byref_object_copy_;
  v31 = __Block_byref_object_dispose_;
  v33 = 0;
  v34 = 0;
  __p = 0;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = a2;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = a3;
  v18[0] = v8;
  v18[1] = 0x40000000;
  v18[2] = ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_50;
  v18[3] = &unk_1E4A0A008;
  v18[8] = a2;
  v18[9] = a3;
  v18[4] = &block;
  v18[5] = &v23;
  v18[6] = &v19;
  v18[7] = this;
  v44 = v18;
  v45 = v8;
  v46 = 0x40000000;
  v47 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  v48 = &__block_descriptor_tmp_77;
  v49 = v7;
  v50 = &v44;
  v11 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12))
  {
    dispatch_async_and_wait(v11, &v45);
    if (v20[3])
      goto LABEL_5;
  }
  else
  {
    dispatch_sync(v11, &v45);
    if (v20[3])
    {
LABEL_5:
      v12 = (uint64_t (**)(_QWORD, uint64_t))v37[3];
      if (*v12)
      {
        v13 = (*v12)(v12, v24[3]);
        *((_BYTE *)v41 + 24) = v13;
        if (v13)
        {
          v17[0] = v8;
          v17[1] = 0x40000000;
          v17[2] = ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_2;
          v17[3] = &unk_1E4A0A030;
          v17[4] = &v19;
          v17[5] = this;
          v44 = v17;
          v45 = v8;
          v46 = 0x40000000;
          v47 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
          v48 = &__block_descriptor_tmp_77;
          v49 = v7;
          v50 = &v44;
          v14 = *((_QWORD *)this + 11);
          if (*((_QWORD *)this + 12))
            dispatch_async_and_wait(v14, &v45);
          else
            dispatch_sync(v14, &v45);
          v15 = *((_BYTE *)v41 + 24) != 0;
        }
        else
        {
          v15 = 0;
        }
      }
      else
      {
        v15 = 0;
        *((_BYTE *)v41 + 24) = 0;
      }
      goto LABEL_17;
    }
  }
  v15 = 1;
LABEL_17:
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&block, 8);
  if (__p)
  {
    v33 = __p;
    operator delete(__p);
  }
LABEL_19:
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  return v15;
}

void sub_1A34C3474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40)
{
  uint64_t v40;

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);
  if (__p)
  {
    a40 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v40 - 224), 8);
  _Block_object_dispose((const void *)(v40 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t result;

  v2 = a1[6];
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v2 + 176;
  v3 = *(uint64_t (**)(void))(v2 + 232);
  if (v3)
  {
    result = v3();
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = result;
  }
  else
  {
    result = 0;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
  }
  return result;
}

__n128 __Block_byref_object_copy_(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(v2 + 344) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_QWORD *)(v2 + 344) = v3;
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v6 = 134218240;
    v7 = v5;
    v8 = 2048;
    v9 = v3;
    _os_log_debug_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEBUG, "#D Written: %zu bytes, for a total of: %llu", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t BasebandTransport::read(BasebandTransport *this, unsigned __int8 *a2, unint64_t a3, unsigned int *a4)
{
  uint64_t *v6;
  uint64_t v7;
  NSObject *v8;
  char *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t (*v12)(void);
  char v13;
  void (*v14)(void);
  uint64_t v15;
  _QWORD v17[6];
  _QWORD v18[7];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;
  _QWORD *v27;
  _QWORD block[6];

  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v6 = (uint64_t *)((char *)this + 72);
  v7 = MEMORY[0x1E0C809B0];
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 0x40000000;
  v18[2] = ___ZN17BasebandTransport4readEPhmPjbj_block_invoke;
  v18[3] = &unk_1E4A0A058;
  v18[5] = &v23;
  v18[6] = this;
  v18[4] = &v19;
  v27 = v18;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_77;
  block[4] = (char *)this + 72;
  block[5] = &v27;
  v9 = (char *)this + 88;
  v8 = *((_QWORD *)this + 11);
  if (*((_QWORD *)v9 + 1))
  {
    dispatch_async_and_wait(v8, block);
    v10 = v24;
    if (!*((_BYTE *)v24 + 24))
      goto LABEL_13;
LABEL_5:
    v11 = v20[3];
    if (v11 && (v12 = *(uint64_t (**)(void))(v11 + 8)) != 0)
    {
      v13 = v12();
      *((_BYTE *)v24 + 24) = v13;
      if ((v13 & 1) != 0)
      {
        v17[0] = v7;
        v17[1] = 0x40000000;
        v17[2] = ___ZN17BasebandTransport4readEPhmPjbj_block_invoke_54;
        v17[3] = &__block_descriptor_tmp_55_0;
        v17[4] = this;
        v17[5] = a4;
        ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v6, (uint64_t)v17);
        goto LABEL_13;
      }
      v14 = *(void (**)(void))(v20[3] + 24);
      if (!v14)
        goto LABEL_13;
    }
    else
    {
      *((_BYTE *)v10 + 24) = 0;
      v14 = *(void (**)(void))(v11 + 24);
      if (!v14)
        goto LABEL_13;
    }
    v14();
    goto LABEL_13;
  }
  dispatch_sync(v8, block);
  v10 = v24;
  if (*((_BYTE *)v24 + 24))
    goto LABEL_5;
LABEL_13:
  v15 = *((unsigned __int8 *)v24 + 24);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  return v15;
}

void sub_1A34C3894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void ___ZN17BasebandTransport4readEPhmPjbj_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  unsigned int (*v3)(void);
  NSObject *v4;
  uint8_t v5[16];

  v2 = a1[6];
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v2 + 176;
  v3 = *(unsigned int (**)(void))(v2 + 232);
  if (v3)
  {
    if (!v3())
    {
      *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
      if (!*(_BYTE *)(v2 + 332))
        return;
      goto LABEL_7;
    }
    LOBYTE(v3) = *(_BYTE *)(v2 + 332) == 0;
  }
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = (_BYTE)v3;
  if (!*(_BYTE *)(v2 + 332))
    return;
LABEL_7:
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Explicit reads not allowed in async mode", v5, 2u);
  }
}

uint64_t ___ZN17BasebandTransport4readEPhmPjbj_block_invoke_54(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 32) + 336) += **(unsigned int **)(result + 40);
  return result;
}

uint64_t BasebandTransport::close(BasebandTransport *this)
{
  char *v2;
  uint64_t v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD v9[6];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  _QWORD *v15;
  uint64_t block;
  uint64_t v17;
  _QWORD *(*v18)(uint64_t);
  void *v19;
  char *v20;
  _QWORD *v21;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 1;
  *((_DWORD *)this + 72) = 0;
  v2 = (char *)this + 72;
  v3 = MEMORY[0x1E0C809B0];
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = ___ZN17BasebandTransport5closeEv_block_invoke;
  v10[3] = &__block_descriptor_tmp_56_1;
  v10[4] = this;
  v15 = v10;
  block = MEMORY[0x1E0C809B0];
  v17 = 0x40000000;
  v18 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  v19 = &__block_descriptor_tmp_77;
  v20 = (char *)this + 72;
  v21 = &v15;
  v5 = (char *)this + 88;
  v4 = *((_QWORD *)this + 11);
  if (*((_QWORD *)v5 + 1))
    dispatch_async_and_wait(v4, &block);
  else
    dispatch_sync(v4, &block);
  BasebandTransport::stopReader(this);
  v9[0] = v3;
  v9[1] = 0x40000000;
  v9[2] = ___ZN17BasebandTransport5closeEv_block_invoke_2;
  v9[3] = &unk_1E4A0A0C0;
  v9[4] = &v11;
  v9[5] = this;
  v15 = v9;
  block = v3;
  v17 = 0x40000000;
  v18 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  v19 = &__block_descriptor_tmp_77;
  v20 = v2;
  v21 = &v15;
  v6 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12))
    dispatch_async_and_wait(v6, &block);
  else
    dispatch_sync(v6, &block);
  v7 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v7;
}

void sub_1A34C3AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN17BasebandTransport5closeEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  uint8_t v4[16];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 280);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(v1 + 280));
    *(_QWORD *)(v1 + 280) = 0;
    v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", v4, 2u);
    }
  }
}

uint64_t ___ZN17BasebandTransport5closeEv_block_invoke_2(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 80))(*(_QWORD *)(a1 + 40));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t BasebandTransport::operator*(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD block[6];

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___ZN17BasebandTransportdeEv_block_invoke;
  v5[3] = &unk_1E4A0A0E8;
  v5[4] = &v6;
  v5[5] = a1;
  v10 = v5;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_77;
  block[4] = a1 + 72;
  block[5] = &v10;
  v2 = a1 + 88;
  v1 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(v2 + 8))
    dispatch_async_and_wait(v1, block);
  else
    dispatch_sync(v1, block);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZN17BasebandTransportdeEv_block_invoke(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_QWORD *)(result + 40) + 176;
  return result;
}

uint64_t BasebandTransport::switchDIAG_sync(BasebandTransport *this)
{
  return 0;
}

uint64_t BasebandTransport::getIOSizeRx(BasebandTransport *this)
{
  return *((unsigned int *)this + 30);
}

uint64_t BasebandTransport::close_sync(BasebandTransport *this)
{
  unsigned int (*v2)(char *);
  _OWORD *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  const char *v7;
  void *__p[2];
  char v10;
  uint8_t buf[4];
  void **v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned int (*)(char *))*((_QWORD *)this + 29);
  if (v2 && (v3 = (_OWORD *)((char *)this + 176), v2((char *)this + 176)))
  {
    *((_DWORD *)this + 82) = 0;
    v4 = TelephonyUtilTransportFree();
    *v3 = 0u;
    *((_OWORD *)this + 12) = 0u;
    *((_OWORD *)this + 13) = 0u;
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
    *((_QWORD *)this + 32) = 0;
    v5 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      return v4;
  }
  else
  {
    v4 = 1;
    v5 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      return v4;
  }
  switch(*((_DWORD *)this + 26))
  {
    case 0:
      v10 = 3;
      LODWORD(__p[0]) = 4997712;
      break;
    case 1:
      v10 = 3;
      LODWORD(__p[0]) = 4997715;
      break;
    case 2:
      v10 = 4;
      v6 = 1195460932;
      goto LABEL_28;
    case 3:
      v10 = 4;
      v6 = 1397114194;
      goto LABEL_28;
    case 4:
      v10 = 5;
      strcpy((char *)__p, "QMUX1");
      break;
    case 5:
      v10 = 5;
      strcpy((char *)__p, "QMUX2");
      break;
    case 6:
      v10 = 3;
      LODWORD(__p[0]) = 5066578;
      break;
    case 7:
      v10 = 4;
      v6 = 1414483778;
      goto LABEL_28;
    case 8:
      v10 = 3;
      LODWORD(__p[0]) = 4805185;
      break;
    case 9:
      v10 = 3;
      LODWORD(__p[0]) = 5526611;
      break;
    case 0xA:
      v10 = 2;
      strcpy((char *)__p, "AT");
      break;
    case 0xB:
      v10 = 4;
      v6 = 1280328769;
      goto LABEL_28;
    case 0xC:
      v10 = 8;
      strcpy((char *)__p, "MEDIACTL");
      break;
    case 0xD:
      v10 = 3;
      LODWORD(__p[0]) = 5461061;
      break;
    case 0xE:
      v10 = 4;
      v6 = 1397968455;
      goto LABEL_28;
    case 0xF:
      v10 = 4;
      v6 = 1397965905;
      goto LABEL_28;
    case 0x10:
      v10 = 5;
      strcpy((char *)__p, "RCTTH");
      break;
    case 0x11:
      v10 = 3;
      LODWORD(__p[0]) = 5260097;
      break;
    case 0x12:
      v10 = 4;
      v6 = 1297040214;
      goto LABEL_28;
    case 0x13:
      v10 = 4;
      v6 = 1129335117;
LABEL_28:
      LODWORD(__p[0]) = v6;
      BYTE4(__p[0]) = 0;
      break;
    case 0x14:
      v10 = 3;
      LODWORD(__p[0]) = 4999236;
      break;
    case 0x15:
      v10 = 3;
      LODWORD(__p[0]) = 5789005;
      break;
    case 0x16:
      v10 = 3;
      LODWORD(__p[0]) = 4407622;
      break;
    default:
      v10 = 7;
      strcpy((char *)__p, "Unknown");
      break;
  }
  v7 = "error";
  if ((_DWORD)v4)
    v7 = "success";
  *(_DWORD *)buf = 136315394;
  v12 = __p;
  v13 = 2080;
  v14 = v7;
  _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Transport close %s: %s", buf, 0x16u);
  if (v10 < 0)
    operator delete(__p[0]);
  return v4;
}

uint64_t BasebandTransport::startReader_sync(NSObject **this)
{
  size_t v2;
  dispatch_queue_t v3;
  NSObject *v4;

  if (!this[37])
  {
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)this))
      v2 = 0x4000;
    else
      v2 = 0x8000;
    this[38] = v2;
    this[37] = operator new[](v2);
    v3 = dispatch_queue_create("ipc.bb", 0);
    v4 = this[39];
    this[39] = v3;
    if (v4)
      dispatch_release(v4);
  }
  *((_BYTE *)this + 292) = 1;
  *((_BYTE *)this + 332) = 1;
  BasebandTransport::queueRead_sync((BasebandTransport *)this);
  return *((unsigned __int8 *)this + 292);
}

void BasebandTransport::queueRead_sync(BasebandTransport *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  dispatch_group_t group;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2 || (v3 = *((_QWORD *)this + 9), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  v6 = *((_QWORD *)this + 40);
  if (v6)
  {
    dispatch_retain(*((dispatch_object_t *)this + 40));
    dispatch_group_enter(v6);
  }
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 1174405120;
  v13[2] = ___ZN17BasebandTransport14queueRead_syncEv_block_invoke;
  v13[3] = &__block_descriptor_tmp_63;
  v13[4] = this;
  v13[5] = v3;
  v14 = v5;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  group = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
  }
  dispatch_async(*((dispatch_queue_t *)this + 39), v13);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  v9 = v14;
  if (v14)
  {
    v10 = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t ___ZN17BasebandTransport10stopReaderEv_block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 40);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_BYTE *)(v1 + 292);
  *(_BYTE *)(v1 + 292) = 0;
  *(_BYTE *)(v1 + 332) = 0;
  return result;
}

uint64_t ___ZN17BasebandTransport10stopReaderEv_block_invoke_2(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t);
  uint64_t v3;
  uint64_t (*v4)(uint64_t);

  v1 = *(_QWORD *)(result + 40);
  v2 = *(uint64_t (**)(uint64_t))(v1 + 232);
  if (v2)
  {
    v3 = result;
    result = v2(v1 + 176);
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24))
      {
        v4 = *(uint64_t (**)(uint64_t))(v1 + 192);
        if (v4)
          return v4(v1 + 176);
      }
    }
  }
  return result;
}

void ___ZN17BasebandTransport14queueRead_syncEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(a1 + 56);
  v3 = v2;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
  BasebandTransport::read_sync(v1, &v3);
  if (v2)
  {
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

void sub_1A34C4330(_Unwind_Exception *exception_object)
{
  NSObject *v1;

  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void BasebandTransport::read_sync(uint64_t a1, NSObject **a2)
{
  std::__shared_weak_count *v4;
  uint64_t *v5;
  uint64_t v6;
  std::__shared_weak_count *v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t, int *, _QWORD, uint64_t, _QWORD);
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  NSObject *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD v31[6];
  std::__shared_weak_count *v32;
  _QWORD block[6];
  std::__shared_weak_count *v34;
  dispatch_group_t group;
  int v36;
  _QWORD v37[5];
  int v38;
  int v39;
  uint64_t v40;
  std::__shared_weak_count *v41;

  v6 = *(_QWORD *)(a1 + 72);
  v4 = *(std::__shared_weak_count **)(a1 + 80);
  v5 = (uint64_t *)(a1 + 72);
  v40 = v6;
  if (!v4 || (v8 = std::__shared_weak_count::lock(v4), (v41 = v8) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v39 = 0;
  v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, _QWORD, uint64_t, _QWORD))(a1 + 184);
  v10 = MEMORY[0x1E0C809B0];
  if (v9)
  {
    v11 = v8;
    v12 = *(_QWORD *)(a1 + 296);
    v13 = capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v8)
        ? 0x4000
        : 0x8000;
    v14 = v9(a1 + 176, v12, v13, &v39, 0, 0xFFFFFFFFLL, 0);
    v15 = v39 ? v14 : 0;
    if (v15 == 1)
    {
      v37[0] = v10;
      v37[1] = 0x40000000;
      v37[2] = ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke;
      v37[3] = &__block_descriptor_tmp_64;
      v37[4] = a1;
      v38 = v39;
      ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v5, (uint64_t)v37);
      block[0] = v10;
      block[1] = 1174405120;
      block[2] = ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_2;
      block[3] = &__block_descriptor_tmp_65_0;
      block[4] = a1;
      block[5] = v6;
      v34 = v11;
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
      v18 = *a2;
      group = v18;
      if (v18)
      {
        dispatch_retain(v18);
        dispatch_group_enter(v18);
      }
      v36 = v39;
      dispatch_sync(*(dispatch_queue_t *)(a1 + 152), block);
      v19 = group;
      if (group)
      {
        dispatch_group_leave(group);
        dispatch_release(v19);
      }
      v20 = v34;
      if (v34)
      {
        v21 = (unint64_t *)&v34->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }
  v31[0] = v10;
  v31[1] = 1174405120;
  v31[2] = ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_66;
  v31[3] = &__block_descriptor_tmp_67_0;
  v31[4] = a1;
  v31[5] = v40;
  v32 = v41;
  if (v41)
  {
    v23 = (unint64_t *)&v41->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v5, (uint64_t)v31);
  v25 = v32;
  if (v32)
  {
    v26 = (unint64_t *)&v32->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v41;
  if (v41)
  {
    v29 = (unint64_t *)&v41->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void sub_1A34C45D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 96);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE56c30_ZTSN8dispatch13group_sessionE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;

  v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = a2[7];
  a1[7] = v6;
  if (v6)
  {
    dispatch_retain(v6);
    v7 = a1[7];
    if (v7)
      dispatch_group_enter(v7);
  }
}

void __destroy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE56c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 56);
    if (v3)
      dispatch_release(v3);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 32) + 336) += *(unsigned int *)(result + 40);
  return result;
}

void ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *__p;
  void *v5;
  uint64_t v6;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = v2[16];
  if (v3)
  {
    __p = 0;
    v5 = 0;
    v6 = 0;
    (*(void (**)(uint64_t, _QWORD, _QWORD, void **))(*(_QWORD *)v3 + 8))(v3, v2[37], *(unsigned int *)(a1 + 64), &__p);
    (*(void (**)(void))(v2[18] + 16))();
    if (__p)
    {
      v5 = __p;
      operator delete(__p);
    }
  }
  else
  {
    (*(void (**)(void))(v2[18] + 16))();
  }
}

void sub_1A34C476C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void ___ZN17BasebandTransport12timerOn_syncEv_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  __int128 v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  _QWORD block[6];
  std::__shared_weak_count *v22;

  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      v6 = a1[5];
      if (!v6)
      {
LABEL_19:
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        return;
      }
      v7 = (_OWORD *)(v3 + 328);
      v8 = *(_QWORD *)(v3 + 336);
      v9 = *(_QWORD *)(v3 + 376);
      v10 = *(_QWORD *)(v3 + 344) - *(_QWORD *)(v3 + 384);
      *(_QWORD *)(v3 + 352) = v8 - v9;
      *(_QWORD *)(v3 + 360) = v10;
      if (v10)
        v11 = 0;
      else
        v11 = v8 == v9;
      if (v11)
      {
        v12 = 3;
      }
      else
      {
        if (*(_DWORD *)v7 != 3)
        {
LABEL_12:
          v13 = *(_OWORD *)(v3 + 344);
          *(_OWORD *)(v3 + 368) = *v7;
          *(_OWORD *)(v3 + 384) = v13;
          *(_QWORD *)(v3 + 400) = *(_QWORD *)(v3 + 360);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 1174405120;
          block[2] = ___ZN17BasebandTransport12timerOn_syncEv_block_invoke_2;
          block[3] = &__block_descriptor_tmp_68;
          block[4] = v3;
          block[5] = v6;
          v14 = (unint64_t *)&v4->__shared_owners_;
          v22 = v4;
          do
            v15 = __ldxr(v14);
          while (__stxr(v15 + 1, v14));
          dispatch_async(*(dispatch_queue_t *)(v3 + 152), block);
          v16 = v22;
          if (v22)
          {
            v17 = (unint64_t *)&v22->__shared_owners_;
            do
              v18 = __ldaxr(v17);
            while (__stlxr(v18 - 1, v17));
            if (!v18)
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
          }
          goto LABEL_19;
        }
        v12 = 1;
      }
      *(_DWORD *)v7 = v12;
      goto LABEL_12;
    }
  }
}

uint64_t ___ZN17BasebandTransport12timerOn_syncEv_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  _OWORD v9[2];
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(v5 + 272);
  v10 = *(_QWORD *)(v5 + 400);
  v7 = *(_OWORD *)(v5 + 384);
  v9[0] = *(_OWORD *)(v5 + 368);
  v9[1] = v7;
  return (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(v6 + 16))(v6, v9, a3, a4, a5);
}

__n128 BasebandTransport::getStatus@<Q0>(BasebandTransport *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)(a2 + 32) = *((_QWORD *)this + 45);
  result = *(__n128 *)((char *)this + 328);
  v3 = *(_OWORD *)((char *)this + 344);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

void ___ZN17BasebandTransport9dumpStateEb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  void **v4;
  void **v5;
  void *__p[2];
  char v7;
  uint8_t buf[4];
  void **v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  *(int64x2_t *)(v2 + 352) = vsubq_s64(*(int64x2_t *)(v2 + 336), *(int64x2_t *)(v2 + 376));
  v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    BasebandTransport::Parameters::toString((BasebandTransport::Parameters *)(v2 + 104), __p);
    if (v7 >= 0)
      v4 = __p;
    else
      v4 = (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    v9 = v4;
    _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    if (v7 < 0)
      operator delete(__p[0]);
    v3 = *(NSObject **)(v2 + 40);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)
    && ((BasebandTransport::Status::toString((BasebandTransport::Status *)(v2 + 328), __p), v7 >= 0)
      ? (v5 = __p)
      : (v5 = (void **)__p[0]),
        *(_DWORD *)buf = 136315138,
        v9 = v5,
        _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu),
        v7 < 0))
  {
    operator delete(__p[0]);
    if (!*(_BYTE *)(a1 + 40))
      return;
  }
  else if (!*(_BYTE *)(a1 + 40))
  {
    return;
  }
  *(_DWORD *)(v2 + 328) = 0;
  *(_BYTE *)(v2 + 332) = 0;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 336) = 0u;
  *(_OWORD *)(v2 + 352) = 0u;
  *(_QWORD *)(v2 + 365) = 0;
  BasebandTransport::timerOn_sync((BasebandTransport *)v2);
}

void BasebandTransport::reportStatus(uint64_t a1, int a2, void **a3)
{
  uint64_t v4;
  void *v5;
  NSObject *v6;
  void *v7;
  _QWORD v8[5];
  void *aBlock;
  int v10;
  _QWORD *v11;
  _QWORD block[6];

  v4 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 1174405120;
  v8[2] = ___ZN17BasebandTransport12reportStatusEjN8dispatch5blockIU13block_pointerFvNS_6StatusEEEE_block_invoke;
  v8[3] = &__block_descriptor_tmp_71;
  v8[4] = a1;
  v10 = a2;
  v5 = *a3;
  if (*a3)
    v5 = _Block_copy(v5);
  aBlock = v5;
  v11 = v8;
  block[0] = v4;
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_77;
  block[4] = a1 + 72;
  block[5] = &v11;
  v6 = *(NSObject **)(a1 + 88);
  if (!*(_QWORD *)(a1 + 96))
  {
    dispatch_sync(v6, block);
    v7 = aBlock;
    if (!aBlock)
      return;
    goto LABEL_7;
  }
  dispatch_async_and_wait(v6, block);
  v7 = aBlock;
  if (aBlock)
LABEL_7:
    _Block_release(v7);
}

void ___ZN17BasebandTransport12reportStatusEjN8dispatch5blockIU13block_pointerFvNS_6StatusEEEE_block_invoke(uint64_t a1)
{
  int v1;
  void *v2;
  uint64_t v3;
  const void *v4;

  v1 = *(_DWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  *(_DWORD *)(v3 + 288) = v1;
  if (v2)
    v2 = _Block_copy(v2);
  v4 = *(const void **)(v3 + 272);
  *(_QWORD *)(v3 + 272) = v2;
  if (v4)
    _Block_release(v4);
  BasebandTransport::timerOn_sync((BasebandTransport *)v3);
}

void *__copy_helper_block_e8_40c70_ZTSN8dispatch5blockIU13block_pointerFvN17BasebandTransport6StatusEEEE(uint64_t a1, uint64_t a2)
{
  void *result;

  result = *(void **)(a2 + 40);
  if (result)
    result = _Block_copy(result);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_e8_40c70_ZTSN8dispatch5blockIU13block_pointerFvN17BasebandTransport6StatusEEEE(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 40);
  if (v1)
    _Block_release(v1);
}

uint64_t ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig()
{
  return ctu::LoggerCommonBase::setInheritedLogLevel();
}

double ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_QWORD *)(a1 + 16) = 0x600000000000000;
  result = *(double *)"ipc.bb";
  *(_OWORD *)a1 = *(_OWORD *)"ipc.bb";
  return result;
}

uint64_t ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return ctu::LoggerCommonBase::getLocalLogLevel((ctu::LoggerCommonBase *)(a1 + 8));
}

_QWORD *ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A0A340;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  return a1;
}

void ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A0A340;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  operator delete(a1);
}

void ___ZL14sLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count_vtbl *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  char __p[19];
  char v19;
  __int128 v20;

  v19 = 18;
  strcpy(__p, "baseband.transport");
  ctu::LogServer::create();
  v2 = *(_QWORD *)(a1 + 32);
  v3 = v20;
  v20 = 0uLL;
  v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)v2 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*((_QWORD *)&v20 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v20 + 1) + 16))(*((_QWORD *)&v20 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v20 + 1));
      if ((v19 & 0x80000000) == 0)
        goto LABEL_12;
      goto LABEL_11;
    }
  }
  if (v19 < 0)
LABEL_11:
    operator delete(*(void **)__p);
LABEL_12:
  v9 = (std::__shared_weak_count_vtbl *)operator new(8uLL);
  v9->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_1E4A0A3A0;
  *(_QWORD *)__p = v9;
  v10 = (std::__shared_weak_count *)operator new(0x20uLL);
  v10->__shared_owners_ = 0;
  v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A408;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = v9;
  *(_QWORD *)&__p[8] = v10;
  v17 = v10;
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  ctu::LogServer::addWriter();
  if (v17)
  {
    v13 = (unint64_t *)&v17->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  ctu::LogServer::start(**(ctu::LogServer ***)(a1 + 32));
  ctu::LogServer::setEnabled(**(ctu::LogServer ***)(a1 + 32));
  if (*(_QWORD *)&__p[8])
  {
    v15 = (unint64_t *)(*(_QWORD *)&__p[8] + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(_QWORD))(**(_QWORD **)&__p[8] + 16))(*(_QWORD *)&__p[8]);
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&__p[8]);
    }
  }
}

void sub_1A34C4F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A34C4F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;

  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_1A34C4FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<EmptyLogWriter *,std::shared_ptr<ctu::LogWriter>::__shared_ptr_default_delete<ctu::LogWriter,EmptyLogWriter>,std::allocator<EmptyLogWriter>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<EmptyLogWriter *,std::shared_ptr<ctu::LogWriter>::__shared_ptr_default_delete<ctu::LogWriter,EmptyLogWriter>,std::allocator<EmptyLogWriter>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<EmptyLogWriter *,std::shared_ptr<ctu::LogWriter>::__shared_ptr_default_delete<ctu::LogWriter,EmptyLogWriter>,std::allocator<EmptyLogWriter>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001A35813E7)
    return a1 + 24;
  if (((v3 & 0x80000001A35813E7 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A35813E7))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A35813E7 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

void ctu::SharedLoggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A0A340;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  operator delete(a1);
}

void ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  v1 = a1 + 56;
  if (*(_QWORD *)(a1 + 56))
  {
    if (!*(_QWORD *)(a1 + 80) || (v2 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 80))) == 0)
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v3 = v2;
    ctu::LoggerCommonBase::getLogDomain((ctu::LoggerCommonBase *)(v1 - 48));
    ctu::TrackedLogger::registerLoggerToServer();
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1A34C5228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A34C5244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BasebandTransportMAV *,std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV *)#1},std::allocator<BasebandTransportMAV>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandTransportMAV *,std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV *)#1},std::allocator<BasebandTransportMAV>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV*)#1}::operator() const(BasebandTransportMAV*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<BasebandTransportMAV *,std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV *)#1},std::allocator<BasebandTransportMAV>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMAVEENSt3__11"
                     "0shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMA"
                                "VEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMAVEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMAVEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV*)#1}::operator() const(BasebandTransportMAV*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<BasebandTransportICE *,std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE *)#1},std::allocator<BasebandTransportICE>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandTransportICE *,std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE *)#1},std::allocator<BasebandTransportICE>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE*)#1}::operator() const(BasebandTransportICE*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<BasebandTransportICE *,std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE *)#1},std::allocator<BasebandTransportICE>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportICEEENSt3__11"
                     "0shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportIC"
                                "EEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportICEEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportICEEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE*)#1}::operator() const(BasebandTransportICE*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<BasebandTransport *,std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport *)#1},std::allocator<BasebandTransport>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandTransport *,std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport *)#1},std::allocator<BasebandTransport>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport*)#1}::operator() const(BasebandTransport*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<BasebandTransport *,std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport *)#1},std::allocator<BasebandTransport>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_"
                                "ptrIT_EEPS6_EUlPS1_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport*)#1}::operator() const(BasebandTransport*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void _ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb0_E3__0EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (**v6)(const void *, _OWORD *, uint64_t, uint64_t, uint64_t);
  __int128 v7;
  _OWORD v8[2];
  uint64_t v9;

  v6 = *(void (***)(const void *, _OWORD *, uint64_t, uint64_t, uint64_t))a1;
  v7 = *(_OWORD *)(a1 + 24);
  v9 = *(_QWORD *)(a1 + 40);
  v8[0] = *(_OWORD *)(a1 + 8);
  v8[1] = v7;
  v6[2](v6, v8, a3, a4, a5);
  if (*(_QWORD *)a1)
    _Block_release(*(const void **)a1);
  operator delete((void *)a1);
}

void sub_1A34C54C8(_Unwind_Exception *a1)
{
  const void **v1;

  if (*v1)
    _Block_release(*v1);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_(const void **a1)
{
  void *v2;

  (*((void (**)(void))*a1 + 2))();
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  if (*a1)
    _Block_release(*a1);
  operator delete(a1);
}

void sub_1A34C5540(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  if (*(_QWORD *)v1)
    _Block_release(*(const void **)v1);
  operator delete((void *)v1);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_(void *a1)
{
  const void *v2;

  (*(void (**)(void))(*(_QWORD *)a1 + 16))();
  if (*((_BYTE *)a1 + 20))
  {
    v2 = *(const void **)a1;
    if (!*(_QWORD *)a1)
      goto LABEL_6;
    goto LABEL_5;
  }
  free(*((void **)a1 + 1));
  v2 = *(const void **)a1;
  if (*(_QWORD *)a1)
LABEL_5:
    _Block_release(v2);
LABEL_6:
  operator delete(a1);
}

void sub_1A34C55D0(_Unwind_Exception *a1)
{
  const void **v1;

  if (*v1)
    _Block_release(*v1);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD block[6];
  std::__shared_weak_count *v16;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E4A0A5A0;
  block[5] = v5;
  v16 = v7;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  block[4] = a2;
  dispatch_async(v8, block);
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17BasebandTransportEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17BasebandTransportEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void Timestamp::Timestamp(Timestamp *this)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  char *v7;
  uint64_t v8;
  uint64_t *v9;
  int *v10;
  char *v11;
  unsigned __int128 v12;
  uint8_t buf[4];
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  v2 = (_QWORD *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = (char *)this + 8;
  v12 = 0uLL;
  if ((gettimeofday((timeval *)&v12, 0) & 0x80000000) == 0
    || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v3 = *v2;
    v4 = v2;
    if (*v2)
      goto LABEL_4;
LABEL_10:
    v7 = (char *)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 5) = 0;
    *((_QWORD *)v7 + 6) = 0;
    *(_QWORD *)v7 = 0;
    *((_QWORD *)v7 + 1) = 0;
    *((_QWORD *)v7 + 2) = v4;
    *v2 = v7;
    v8 = **(_QWORD **)this;
    v9 = (uint64_t *)v7;
    if (v8)
    {
      *(_QWORD *)this = v8;
      v9 = (uint64_t *)*v2;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 1), v9);
    ++*((_QWORD *)this + 2);
    goto LABEL_13;
  }
  v10 = __error();
  v11 = strerror(*v10);
  *(_DWORD *)buf = 136315138;
  v14 = v11;
  _os_log_error_impl(&dword_1A343C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to get current time. Error: %s\n", buf, 0xCu);
  v3 = *v2;
  v4 = v2;
  if (!*v2)
    goto LABEL_10;
LABEL_4:
  v5 = v3;
  while (1)
  {
    while (1)
    {
      v4 = (_QWORD *)v5;
      v6 = *(_DWORD *)(v5 + 32);
      if (v6 < 1)
        break;
      v5 = *v4;
      v2 = v4;
      if (!*v4)
        goto LABEL_10;
    }
    if ((v6 & 0x80000000) == 0)
      break;
    v5 = v4[1];
    if (!v5)
    {
      v2 = v4 + 1;
      goto LABEL_10;
    }
  }
  v7 = (char *)v4;
LABEL_13:
  *(_OWORD *)(v7 + 40) = v12;
}

void sub_1A34C5938(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD **v2;

  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

void sub_1A34C5954(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;

  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, v2);
  _Unwind_Resume(a1);
}

void Timestamp::Timestamp(Timestamp *this, const Timestamp *a2)
{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>((uint64_t *)this, *(int **)a2, (int *)a2 + 2);
}

{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>((uint64_t *)this, *(int **)a2, (int *)a2 + 2);
}

void sub_1A34C59AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1A34C5A00(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

_QWORD *Timestamp::Timestamp(_QWORD *a1, _OWORD *a2, int a3)
{
  _QWORD *v6;
  char *v7;

  a1[2] = 0;
  a1[1] = 0;
  v6 = a1 + 1;
  *a1 = a1 + 1;
  v7 = (char *)operator new(0x38uLL);
  *((_DWORD *)v7 + 8) = a3;
  *(_QWORD *)v7 = 0;
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 2) = v6;
  *v6 = v7;
  *a1 = v7;
  v7[24] = 1;
  a1[2] = 1;
  *(_OWORD *)(v7 + 40) = *a2;
  return a1;
}

{
  _QWORD *v6;
  char *v7;

  a1[2] = 0;
  a1[1] = 0;
  v6 = a1 + 1;
  *a1 = a1 + 1;
  v7 = (char *)operator new(0x38uLL);
  *((_DWORD *)v7 + 8) = a3;
  *(_QWORD *)v7 = 0;
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 2) = v6;
  *v6 = v7;
  *a1 = v7;
  v7[24] = 1;
  a1[2] = 1;
  *(_OWORD *)(v7 + 40) = *a2;
  return a1;
}

__n128 Timestamp::set(uint64_t **a1, __n128 *a2, int a3)
{
  char *v6;
  uint64_t **v7;
  char *v8;
  int v9;
  char *v10;
  uint64_t *v11;
  uint64_t *v12;
  __n128 result;

  v7 = a1 + 1;
  v6 = (char *)a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        v8 = v6;
        v9 = *((_DWORD *)v6 + 8);
        if (v9 <= a3)
          break;
        v6 = *(char **)v8;
        v7 = (uint64_t **)v8;
        if (!*(_QWORD *)v8)
          goto LABEL_8;
      }
      if (v9 >= a3)
        break;
      v6 = (char *)*((_QWORD *)v8 + 1);
      if (!v6)
      {
        v7 = (uint64_t **)(v8 + 8);
        goto LABEL_8;
      }
    }
  }
  else
  {
    v8 = (char *)(a1 + 1);
LABEL_8:
    v10 = v8;
    v8 = (char *)operator new(0x38uLL);
    *((_DWORD *)v8 + 8) = a3;
    *((_QWORD *)v8 + 5) = 0;
    *((_QWORD *)v8 + 6) = 0;
    *(_QWORD *)v8 = 0;
    *((_QWORD *)v8 + 1) = 0;
    *((_QWORD *)v8 + 2) = v10;
    *v7 = (uint64_t *)v8;
    v11 = (uint64_t *)**a1;
    v12 = (uint64_t *)v8;
    if (v11)
    {
      *a1 = v11;
      v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  result = *a2;
  *(__n128 *)(v8 + 40) = *a2;
  return result;
}

_QWORD *Timestamp::Timestamp(_QWORD *a1, uint64_t a2, int a3)
{
  _QWORD *v6;
  _DWORD *v7;

  a1[2] = 0;
  a1[1] = 0;
  v6 = a1 + 1;
  *a1 = a1 + 1;
  v7 = operator new(0x38uLL);
  v7[8] = a3;
  *(_QWORD *)v7 = 0;
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 2) = v6;
  *v6 = v7;
  *a1 = v7;
  *((_BYTE *)v7 + 24) = 1;
  a1[2] = 1;
  *((_QWORD *)v7 + 5) = a2;
  *((_QWORD *)v7 + 6) = 0xAAAAAAAAAAAAAAAALL;
  return a1;
}

{
  _QWORD *v6;
  _DWORD *v7;

  a1[2] = 0;
  a1[1] = 0;
  v6 = a1 + 1;
  *a1 = a1 + 1;
  v7 = operator new(0x38uLL);
  v7[8] = a3;
  *(_QWORD *)v7 = 0;
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 2) = v6;
  *v6 = v7;
  *a1 = v7;
  *((_BYTE *)v7 + 24) = 1;
  a1[2] = 1;
  *((_QWORD *)v7 + 5) = a2;
  *((_QWORD *)v7 + 6) = 0xAAAAAAAAAAAAAAAALL;
  return a1;
}

uint64_t **Timestamp::Timestamp(uint64_t **a1, char *a2, char a3, int a4)
{
  const char *v5;
  uint64_t **v7;
  int *v8;
  char *v9;
  NSObject *v10;
  const char *v11;
  uint64_t *v12;
  uint64_t **v13;
  int v14;
  char *v15;
  uint64_t *v16;
  uint64_t *v17;
  int *v19;
  char *v20;
  int *v21;
  char *v22;
  unsigned __int128 v23;
  tm v24;
  void *__p[4];
  uint8_t buf[4];
  char *v27;
  uint64_t v28;

  v5 = a2;
  v28 = *MEMORY[0x1E0C80C00];
  a1[1] = 0;
  v7 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  __p[2] = (void *)0x11AAAAAAAAAA0053;
  *(_OWORD *)__p = *(_OWORD *)"%Y-%m-%d-%H-%M-%S";
  if ((a3 & 0x10) != 0)
  {
    HIBYTE(__p[2]) = 19;
    strcpy((char *)__p, "%Y.%m.%d_%H-%M-%S%z");
  }
  *((_QWORD *)&v23 + 1) = 0xAAAAAAAA00000000;
  memset(&v24, 0, sizeof(v24));
  if (a2[23] < 0)
    v5 = *(const char **)a2;
  if (strptime(v5, (const char *)__p, &v24))
  {
    v24.tm_isdst = -1;
    *(_QWORD *)&v23 = mktime(&v24);
    if ((_QWORD)v23 != -1)
      goto LABEL_15;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v19 = __error();
      v20 = strerror(*v19);
      *(_DWORD *)buf = 136315138;
      v27 = v20;
      _os_log_error_impl(&dword_1A343C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to convert to absolute time. Error: %s\n", buf, 0xCu);
      v23 = 0uLL;
      if ((gettimeofday((timeval *)&v23, 0) & 0x80000000) == 0)
        goto LABEL_15;
    }
    else
    {
      v23 = 0uLL;
      if ((gettimeofday((timeval *)&v23, 0) & 0x80000000) == 0)
        goto LABEL_15;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    v8 = __error();
    v9 = strerror(*v8);
    *(_DWORD *)buf = 136315138;
    v27 = v9;
    v10 = MEMORY[0x1E0C81028];
    v11 = "Failed to get current time after absolute time conversion failed. Error: %s\n";
    goto LABEL_32;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Failed to convert time from string format\n", buf, 2u);
  }
  v23 = 0uLL;
  if (gettimeofday((timeval *)&v23, 0) < 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v21 = __error();
    v22 = strerror(*v21);
    *(_DWORD *)buf = 136315138;
    v27 = v22;
    v10 = MEMORY[0x1E0C81028];
    v11 = "Failed to get current time after conversion failure. Error: %s\n";
LABEL_32:
    _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
  }
LABEL_15:
  v12 = *v7;
  v13 = v7;
  if (*v7)
  {
    while (1)
    {
      while (1)
      {
        v13 = (uint64_t **)v12;
        v14 = *((_DWORD *)v12 + 8);
        if (v14 <= a4)
          break;
        v12 = *v13;
        v7 = v13;
        if (!*v13)
          goto LABEL_22;
      }
      if (v14 >= a4)
        break;
      v12 = v13[1];
      if (!v12)
      {
        v7 = v13 + 1;
        goto LABEL_22;
      }
    }
    *(_OWORD *)(v13 + 5) = v23;
    if (SHIBYTE(__p[2]) < 0)
      goto LABEL_25;
  }
  else
  {
LABEL_22:
    v15 = (char *)operator new(0x38uLL);
    *((_DWORD *)v15 + 8) = a4;
    *((_QWORD *)v15 + 5) = 0;
    *((_QWORD *)v15 + 6) = 0;
    *(_QWORD *)v15 = 0;
    *((_QWORD *)v15 + 1) = 0;
    *((_QWORD *)v15 + 2) = v13;
    *v7 = (uint64_t *)v15;
    v16 = (uint64_t *)**a1;
    v17 = (uint64_t *)v15;
    if (v16)
    {
      *a1 = v16;
      v17 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v17);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    *(_OWORD *)(v15 + 40) = v23;
    if (SHIBYTE(__p[2]) < 0)
LABEL_25:
      operator delete(__p[0]);
  }
  return a1;
}

void sub_1A34C6004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v24;

  if (a24 < 0)
    operator delete(__p);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v24, *(_QWORD **)(v24 + 8));
  _Unwind_Resume(a1);
}

uint64_t Timestamp::get(uint64_t a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;

  *a2 = 0;
  a2[1] = 0;
  v5 = *(_QWORD *)(a1 + 8);
  v3 = a1 + 8;
  v4 = v5;
  if (!v5)
    return 0;
  v6 = v3;
  do
  {
    v7 = *(_DWORD *)(v4 + 32);
    v8 = v7 < a3;
    if (v7 >= a3)
      v9 = (uint64_t *)v4;
    else
      v9 = (uint64_t *)(v4 + 8);
    if (!v8)
      v6 = v4;
    v4 = *v9;
  }
  while (*v9);
  if (v6 == v3 || *(_DWORD *)(v6 + 32) > a3)
    return 0;
  *(_OWORD *)a2 = *(_OWORD *)(v6 + 40);
  return 1;
}

uint64_t Timestamp::now(timeval *this, timeval *a2)
{
  return gettimeofday(this, 0);
}

uint64_t Timestamp::asString@<X0>(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, _BYTE *a4@<X8>)
{
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  uint64_t *v15;
  time_t v16;
  __int128 v17;
  const char *v18;
  size_t v19;
  uint64_t v20;
  char *v21;
  const std::locale::facet *v22;
  size_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  tm v31;
  time_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *__p[2];
  __int128 v39;
  __int128 v40;
  _OWORD v41[9];
  unint64_t v42;
  std::locale v43;
  char __s[16];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v42 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[7] = v8;
  v41[8] = v8;
  v41[5] = v8;
  v41[6] = v8;
  v41[3] = v8;
  v41[4] = v8;
  v41[1] = v8;
  v41[2] = v8;
  v40 = v8;
  v41[0] = v8;
  *(_OWORD *)__p = v8;
  v39 = v8;
  v36 = v8;
  v37 = v8;
  v34 = v8;
  v35 = v8;
  v33 = v8;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v33);
  v11 = *(_QWORD *)(a1 + 8);
  v10 = a1 + 8;
  v9 = v11;
  if (!v11)
    goto LABEL_11;
  v12 = v10;
  do
  {
    v13 = *(_DWORD *)(v9 + 32);
    v14 = v13 < a2;
    if (v13 >= a2)
      v15 = (uint64_t *)v9;
    else
      v15 = (uint64_t *)(v9 + 8);
    if (!v14)
      v12 = v9;
    v9 = *v15;
  }
  while (*v15);
  if (v12 != v10 && *(_DWORD *)(v12 + 32) <= a2)
  {
    v16 = *(_QWORD *)(v12 + 40);
    if ((a3 & 0x11) != 0)
    {
LABEL_12:
      v31.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
      v32 = v16;
      *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v31.tm_mon = v17;
      *(_OWORD *)&v31.tm_isdst = v17;
      *(_OWORD *)&v31.tm_sec = v17;
      localtime_r(&v32, &v31);
      v46 = 0u;
      v47 = 0u;
      *(_OWORD *)__s = 0u;
      v45 = 0u;
      if ((a3 & 0x10) != 0)
        v18 = "%Y.%m.%d_%H-%M-%S%z";
      else
        v18 = "%Y-%m-%d-%H-%M-%S";
      strftime(__s, 0x40uLL, v18, &v31);
      v19 = strlen(__s);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)__s, v19);
      if ((a3 & 8) != 0)
      {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"-", 1);
        v20 = v34;
        v21 = (char *)&v34 + *(_QWORD *)(v34 - 24);
        if (*((_DWORD *)v21 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&v34 + *(_QWORD *)(v34 - 24)));
          v22 = std::locale::use_facet(&v43, MEMORY[0x1E0DE4A90]);
          ((void (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 32);
          std::locale::~locale(&v43);
          v20 = v34;
        }
        *((_DWORD *)v21 + 36) = 48;
        *(_QWORD *)((char *)&v35 + *(_QWORD *)(v20 - 24) + 8) = 3;
        std::ostream::operator<<();
      }
      goto LABEL_23;
    }
  }
  else
  {
LABEL_11:
    v16 = 0;
    if ((a3 & 0x11) != 0)
      goto LABEL_12;
  }
  std::ostream::operator<<();
  if ((a3 & 4) != 0 || (a3 & 8) != 0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)".", 1);
    std::ostream::operator<<();
  }
LABEL_23:
  if ((BYTE8(v40) & 0x10) != 0)
  {
    v24 = v40;
    if ((unint64_t)v40 < *((_QWORD *)&v37 + 1))
    {
      *(_QWORD *)&v40 = *((_QWORD *)&v37 + 1);
      v24 = *((_QWORD *)&v37 + 1);
    }
    v25 = (const void *)v37;
    v23 = v24 - v37;
    if ((unint64_t)(v24 - v37) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_40;
  }
  else
  {
    if ((BYTE8(v40) & 8) == 0)
    {
      v23 = 0;
      a4[23] = 0;
      goto LABEL_36;
    }
    v25 = (const void *)*((_QWORD *)&v35 + 1);
    v23 = *((_QWORD *)&v36 + 1) - *((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v36 + 1) - *((_QWORD *)&v35 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_40:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v23 >= 0x17)
  {
    v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17)
      v26 = v23 | 7;
    v27 = v26 + 1;
    v28 = operator new(v26 + 1);
    *((_QWORD *)a4 + 1) = v23;
    *((_QWORD *)a4 + 2) = v27 | 0x8000000000000000;
    *(_QWORD *)a4 = v28;
    a4 = v28;
    goto LABEL_35;
  }
  a4[23] = v23;
  if (v23)
LABEL_35:
    memmove(a4, v25, v23);
LABEL_36:
  a4[v23] = 0;
  *(_QWORD *)&v33 = *MEMORY[0x1E0DE4F50];
  v29 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v33 + *(_QWORD *)(v33 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v34 = v29;
  *((_QWORD *)&v34 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v39) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A858F92C](v41);
}

void sub_1A34C644C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34C6460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  std::locale::~locale((std::locale *)(v9 - 136));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34C647C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34C6494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34C64A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *Timestamp::convert(uint64_t a1)
{
  uint64_t *v1;
  uint64_t **v2;
  uint64_t *v3;
  uint64_t **v4;
  uint64_t **v5;
  int v6;
  uint64_t **v7;
  uint64_t *v8;
  std::string __p;
  uint64_t *v11[3];

  memset(v11, 170, sizeof(v11));
  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    __p = *(std::string *)a1;
  Timestamp::Timestamp(v11, (char *)&__p, 9, 0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    v1 = v11[1];
    if (!v11[1])
    {
LABEL_18:
      v8 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    v1 = v11[1];
    if (!v11[1])
      goto LABEL_18;
  }
  v2 = &v11[1];
  v3 = v1;
  do
  {
    v4 = (uint64_t **)v3;
    v5 = v2;
    v6 = *((_DWORD *)v3 + 8);
    if (v6 >= 0)
      v2 = (uint64_t **)v3;
    else
      ++v3;
    v3 = (uint64_t *)*v3;
  }
  while (v3);
  if (v2 == &v11[1])
    goto LABEL_18;
  v7 = v6 >= 0 ? v4 : v5;
  if (*((int *)v7 + 8) > 0)
    goto LABEL_18;
  if (v6 < 0)
    v4 = v5;
  v8 = v4[5];
LABEL_19:
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v11, v1);
  return v8;
}

void sub_1A34C65B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>(uint64_t *result, int *a2, int *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  int *v6;
  uint64_t *v7;
  uint64_t *v8;
  int *v9;
  uint64_t *v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t *v15;
  int *v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19[11];

  if (a2 != a3)
  {
    v19[9] = v3;
    v19[10] = v4;
    v6 = a2;
    v7 = result;
    v8 = result + 1;
    do
    {
      v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      v19[0] = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      result = std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::__find_equal<Timestamp::TimeDomain>(v7, v8, v19, &v18, v6 + 8);
      if (*result)
      {
        v9 = (int *)*((_QWORD *)v6 + 1);
        if (v9)
          goto LABEL_11;
      }
      else
      {
        v10 = result;
        v11 = operator new(0x38uLL);
        v12 = *((_QWORD *)v6 + 6);
        v11[2] = *((_OWORD *)v6 + 2);
        *((_QWORD *)v11 + 6) = v12;
        v13 = v19[0];
        *(_QWORD *)v11 = 0;
        *((_QWORD *)v11 + 1) = 0;
        *((_QWORD *)v11 + 2) = v13;
        *v10 = (uint64_t)v11;
        v14 = *(_QWORD **)*v7;
        if (v14)
        {
          *v7 = (uint64_t)v14;
          v15 = (uint64_t *)*v10;
        }
        else
        {
          v15 = (uint64_t *)v11;
        }
        result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], v15);
        ++v7[2];
        v9 = (int *)*((_QWORD *)v6 + 1);
        if (v9)
        {
          do
          {
LABEL_11:
            v16 = v9;
            v9 = *(int **)v9;
          }
          while (v9);
          goto LABEL_3;
        }
      }
      do
      {
        v16 = (int *)*((_QWORD *)v6 + 2);
        v17 = *(_QWORD *)v16 == (_QWORD)v6;
        v6 = v16;
      }
      while (!v17);
LABEL_3:
      v6 = v16;
    }
    while (v16 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::__find_equal<Timestamp::TimeDomain>(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, int *a5)
{
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  int v24;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v14 = a2;
      do
      {
        v10 = (uint64_t *)v14[2];
        v15 = *v10 == (_QWORD)v14;
        v14 = v10;
      }
      while (v15);
    }
    v16 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5)
      goto LABEL_17;
    v18 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v19 = (uint64_t *)v18;
          v20 = *(_DWORD *)(v18 + 32);
          if (v16 >= v20)
            break;
          v18 = *v19;
          v5 = v19;
          if (!*v19)
            goto LABEL_25;
        }
        if (v20 >= v16)
          break;
        v5 = v19 + 1;
        v18 = v19[1];
      }
      while (v18);
LABEL_25:
      *a3 = v19;
      return v5;
    }
    else
    {
      *a3 = v5;
      return a1 + 1;
    }
  }
  else if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  else
  {
    v11 = a2[1];
    if (v11)
    {
      v12 = (uint64_t *)a2[1];
      do
      {
        v13 = v12;
        v12 = (uint64_t *)*v12;
      }
      while (v12);
    }
    else
    {
      v21 = a2;
      do
      {
        v13 = (uint64_t *)v21[2];
        v15 = *v13 == (_QWORD)v21;
        v21 = v13;
      }
      while (!v15);
    }
    if (v13 == v5 || v6 < *((_DWORD *)v13 + 8))
    {
      if (v11)
      {
        *a3 = v13;
        return v13;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
    }
    else
    {
      v22 = *v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            v23 = (uint64_t *)v22;
            v24 = *(_DWORD *)(v22 + 32);
            if (v6 >= v24)
              break;
            v22 = *v23;
            v5 = v23;
            if (!*v23)
              goto LABEL_41;
          }
          if (v24 >= v6)
            break;
          v5 = v23 + 1;
          v22 = v23[1];
        }
        while (v22);
LABEL_41:
        *a3 = v23;
        return v5;
      }
      else
      {
        *a3 = v5;
        return a1 + 1;
      }
    }
  }
}

void SoftwareBypassShim::create(std::__shared_weak_count **a1@<X8>)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t v13;

  v3 = (std::__shared_weak_count *)operator new(0x40uLL);
  v3->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A5F8;
  v5 = v3 + 1;
  SoftwareBypassShim::SoftwareBypassShim((SoftwareBypassShim *)&v3[1]);
  shared_owners = (std::__shared_weak_count *)v3[1].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
    {
LABEL_3:
      *a1 = v5;
      a1[1] = v3;
      return;
    }
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v12 = __ldxr(p_shared_weak_owners);
    while (__stxr(v12 + 1, p_shared_weak_owners));
    v3[1].__vftable = (std::__shared_weak_count_vtbl *)&v3[1];
    v3[1].__shared_owners_ = (uint64_t)v3;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v8 = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    v3[1].__vftable = (std::__shared_weak_count_vtbl *)&v3[1];
    v3[1].__shared_owners_ = (uint64_t)v3;
  }
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
    goto LABEL_3;
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  *a1 = v5;
  a1[1] = v3;
}

void sub_1A34C69B4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void SoftwareBypassShim::SoftwareBypassShim(SoftwareBypassShim *this)
{
  void *v2;
  char *v3;
  unsigned __int8 v4;
  NSObject *v5;
  const char *v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v2 = dlopen("/usr/local/lib/libSWBypassClient.dylib", 1);
  *((_QWORD *)this + 2) = v2;
  if (v2)
  {
    *((_QWORD *)this + 3) = dlsym(v2, "bypassCtl");
    *((_QWORD *)this + 4) = dlsym(*((void **)this + 2), "BypassInterfaceMaskAsString");
    return;
  }
  v3 = dlerror();
  {
    GetOsLogContext(void)::sOsLogContext = 0;
    qword_1ED114D18 = 0;
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
  }
  if (GetOsLogContext(void)::onceToken == -1)
  {
    v5 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return;
  }
  else
  {
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
    v5 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return;
  }
  v6 = "unknown";
  if (v3)
    v6 = v3;
  v7 = 136315138;
  v8 = v6;
  _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, "dlopen error: %s ", (uint8_t *)&v7, 0xCu);
}

void sub_1A34C6B94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

void SoftwareBypassShim::~SoftwareBypassShim(SoftwareBypassShim *this)
{
  void *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;

  v3 = (_QWORD *)((char *)this + 16);
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
    dlclose(v2);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

{
  void *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;

  v3 = (_QWORD *)((char *)this + 16);
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
    dlclose(v2);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

BOOL SoftwareBypassShim::isSupported(SoftwareBypassShim *this)
{
  return *((_QWORD *)this + 2) != 0;
}

uint64_t SoftwareBypassShim::bypassCtl(SoftwareBypassShim *this, uint64_t a2)
{
  uint64_t (*v2)(uint64_t);
  unsigned __int8 v4;
  NSObject *v5;
  uint8_t v6[16];

  v2 = (uint64_t (*)(uint64_t))*((_QWORD *)this + 3);
  if (v2)
    return v2(a2);
  if ((v4 & 1) == 0)
  {
    {
      GetOsLogContext(void)::sOsLogContext = 0;
      qword_1ED114D18 = 0;
      __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
    }
  }
  if (GetOsLogContext(void)::onceToken == -1)
  {
    v5 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return 0;
  }
  else
  {
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
    v5 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return 0;
  }
  *(_WORD *)v6 = 0;
  _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, "bypassCtl is not found", v6, 2u);
  return 0;
}

const char *SoftwareBypassShim::bypassInterfaceMaskAsString(SoftwareBypassShim *this, uint64_t a2)
{
  uint64_t (*v2)(uint64_t);
  unsigned __int8 v4;
  NSObject *v5;
  uint8_t v6[16];

  v2 = (uint64_t (*)(uint64_t))*((_QWORD *)this + 4);
  if (v2)
    return (const char *)v2(a2);
  if ((v4 & 1) == 0)
  {
    {
      GetOsLogContext(void)::sOsLogContext = 0;
      qword_1ED114D18 = 0;
      __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE3768], &GetOsLogContext(void)::sOsLogContext, &dword_1A343C000);
    }
  }
  if (GetOsLogContext(void)::onceToken == -1)
  {
    v5 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return "unknown";
  }
  else
  {
    dispatch_once(&GetOsLogContext(void)::onceToken, &__block_literal_global_1);
    v5 = qword_1ED114D18;
    if (!os_log_type_enabled((os_log_t)qword_1ED114D18, OS_LOG_TYPE_ERROR))
      return "unknown";
  }
  *(_WORD *)v6 = 0;
  _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, "BypassInterfaceMaskAsString is not found", v6, 2u);
  return "unknown";
}

void std::__shared_ptr_emplace<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate,std::allocator<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A5F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate,std::allocator<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A5F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate,std::allocator<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate>>::__on_zero_shared(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;

  v3 = (_QWORD *)(a1 + 40);
  v2 = *(void **)(a1 + 40);
  if (v2)
    dlclose(v2);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void KernelPCIABPTrace::PipeContext::stop(KernelPCIABPTrace::PipeContext *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
    v3 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

void KernelPCIABPTrace::PipeContext::start(KernelPCIABPTrace::PipeContext *this, CircularFileLogWriter::Params *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;
  __int128 v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  _QWORD v17[5];
  _QWORD *v18;
  __int128 block;
  _QWORD *(*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  _QWORD *v23;

  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v7 = operator new(0xB8uLL);
  CircularFileLogWriter::CircularFileLogWriter((uint64_t)v7, (__int128 *)a2);
  std::shared_ptr<CircularFileLogWriter>::shared_ptr[abi:ne180100]<CircularFileLogWriter,std::shared_ptr<CircularFileLogWriter> ctu::SharedSynchronizable<CircularFileLogWriter>::make_shared_ptr<CircularFileLogWriter>(CircularFileLogWriter*)::{lambda(CircularFileLogWriter*)#1},void>(&block, (uint64_t)v7);
  v8 = block;
  block = 0uLL;
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
  *((_OWORD *)this + 2) = v8;
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = *((_QWORD *)this + 4);
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 0x40000000;
  v17[2] = ___ZN21CircularFileLogWriter4openEv_block_invoke;
  v17[3] = &__block_descriptor_tmp_0;
  v17[4] = v15;
  v18 = v17;
  *(_QWORD *)&block = MEMORY[0x1E0C809B0];
  *((_QWORD *)&block + 1) = 0x40000000;
  v20 = ___ZNK3ctu20SharedSynchronizableI21CircularFileLogWriterE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  v21 = &__block_descriptor_tmp_16_0;
  v22 = v15 + 8;
  v23 = &v18;
  v16 = *(NSObject **)(v15 + 24);
  if (*(_QWORD *)(v15 + 32))
    dispatch_async_and_wait(v16, &block);
  else
    dispatch_sync(v16, &block);
}

void sub_1A34C7130(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::PipeContext::write(KernelPCIABPTrace::PipeContext *this, const char *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (result)
    return (*(uint64_t (**)(uint64_t, const char *))(*(_QWORD *)result + 72))(result, a2);
  return result;
}

uint64_t KernelPCIABPTrace::PipeContext::pause(KernelPCIABPTrace::PipeContext *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

void KernelPCIABPTrace::PipeContext::resume(KernelPCIABPTrace::PipeContext *this)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD v3[5];
  _QWORD *v4;
  _QWORD block[6];

  v1 = *((_QWORD *)this + 4);
  if (v1)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = ___ZN21CircularFileLogWriter4openEv_block_invoke;
    v3[3] = &__block_descriptor_tmp_0;
    v3[4] = v1;
    v4 = v3;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZNK3ctu20SharedSynchronizableI21CircularFileLogWriterE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    block[3] = &__block_descriptor_tmp_16_0;
    block[4] = v1 + 8;
    block[5] = &v4;
    v2 = *(NSObject **)(v1 + 24);
    if (*(_QWORD *)(v1 + 32))
      dispatch_async_and_wait(v2, block);
    else
      dispatch_sync(v2, block);
  }
}

void KernelPCIABPTrace::PipeContext::setFileCapacity(KernelPCIABPTrace::PipeContext *this, uint64_t a2)
{
  uint64_t v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = ___ZN21CircularFileLogWriter11setCapacityEm_block_invoke;
    v3[3] = &__block_descriptor_tmp_8_0;
    v3[4] = v2;
    v3[5] = a2;
    ctu::SharedSynchronizable<CircularFileLogWriter>::execute_wrapped((uint64_t *)(v2 + 8), (uint64_t)v3);
  }
}

void KernelPCIABPTrace::KernelPCIABPTrace(KernelPCIABPTrace *this)
{
  capabilities::ipc *v2;
  void *__p[2];
  char v4;

  v4 = 13;
  strcpy((char *)__p, "trace.pci.bin");
  v2 = (capabilities::ipc *)Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v4 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_1E4A0A648;
  *((_WORD *)this + 76) = 0;
  *((_DWORD *)this + 39) = capabilities::ipc::defaultPCIBinaryTraceHistorySizeMB(v2);
  *((_QWORD *)this + 20) = 0x400000000004;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 21) = (char *)this + 176;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = (char *)this + 200;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
}

void sub_1A34C7320(_Unwind_Exception *a1)
{
  Trace *v1;

  Trace::~Trace(v1);
  _Unwind_Resume(a1);
}

void sub_1A34C7334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::~KernelPCIABPTrace(KernelPCIABPTrace *this)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  *(_QWORD *)this = off_1E4A0A648;
  v2 = *((_QWORD *)this + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *((_QWORD *)this + 32);
    if (v3)
      dispatch_release(v3);
  }
  if (*((char *)this + 255) < 0)
  {
    operator delete(*((void **)this + 29));
    v4 = (std::__shared_weak_count *)*((_QWORD *)this + 28);
    if (!v4)
      goto LABEL_12;
  }
  else
  {
    v4 = (std::__shared_weak_count *)*((_QWORD *)this + 28);
    if (!v4)
      goto LABEL_12;
  }
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_12:
  std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(*((_QWORD **)this + 25));
  std::__tree<KernelPCITrace::BuffContext *>::destroy(*((_QWORD **)this + 22));
  Trace::~Trace(this);
}

{
  void *v1;

  KernelPCIABPTrace::~KernelPCIABPTrace(this);
  operator delete(v1);
}

double KernelPCIABPTrace::createInternal@<D0>(_QWORD *a1@<X8>)
{
  KernelPCIABPTrace *v3;
  double result;
  __int128 v5;

  *a1 = 0xAAAAAAAAAAAAAAAALL;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  v3 = (KernelPCIABPTrace *)operator new(0x110uLL);
  KernelPCIABPTrace::KernelPCIABPTrace(v3);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<KernelPCIABPTrace>::shared_ptr[abi:ne180100]<KernelPCIABPTrace,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  result = *(double *)&v5;
  *(_OWORD *)a1 = v5;
  return result;
}

void sub_1A34C7478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A34C748C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::init(uint64_t a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v13;
  uint64_t v14;
  dispatch_object_t object;
  uint64_t v16;
  std::__shared_weak_count *v17;
  std::string v18;
  _QWORD block[6];

  *(_BYTE *)(a1 + 264) = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    v7 = (std::__shared_weak_count *)a3[1];
    v16 = *a3;
    v17 = v7;
    if (!v7)
      goto LABEL_7;
  }
  else
  {
    v18 = *(std::string *)a2;
    v7 = (std::__shared_weak_count *)a3[1];
    v16 = *a3;
    v17 = v7;
    if (!v7)
      goto LABEL_7;
  }
  p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
  do
    v9 = __ldxr(p_shared_weak_owners);
  while (__stxr(v9 + 1, p_shared_weak_owners));
LABEL_7:
  v10 = *a4;
  object = v10;
  if (v10)
    dispatch_retain(v10);
  v11 = Trace::init(a1, (void **)&v18.__r_.__value_.__l.__data_, &v16, &object);
  if (object)
    dispatch_release(object);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if (!(_DWORD)v11)
      return v11;
  }
  else if (!(_DWORD)v11)
  {
    return v11;
  }
  v14 = a1;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke;
  block[3] = &__block_descriptor_tmp_39;
  block[4] = a1 + 72;
  block[5] = &v14;
  v13 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(a1 + 96))
    dispatch_async_and_wait(v13, block);
  else
    dispatch_sync(v13, block);
  return v11;
}

void sub_1A34C760C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  std::__shared_weak_count *v19;

  if (object)
  {
    dispatch_release(object);
    v19 = a12;
    if (!a12)
    {
LABEL_3:
      if ((a18 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else
  {
    v19 = a12;
    if (!a12)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v19);
  if ((a18 & 0x80000000) == 0)
LABEL_4:
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::initProperty_sync(KernelPCIABPTrace *this)
{
  NSObject *v2;
  _BOOL4 v3;
  _BOOL4 v4;
  _BOOL4 v5;
  void *v6[2];
  char v7;
  std::string __p;
  void *v9[2];
  char v10;
  std::string v11;
  std::string buf;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"initProperty_sync";
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&buf, 0xCu);
  }
  v7 = 7;
  strcpy((char *)v6, "Enabled");
  memset(&__p, 0, sizeof(__p));
  v10 = 3;
  LOWORD(v9[0]) = *(_WORD *)"IPC";
  WORD1(v9[0]) = str_41[2];
  memset(&buf, 0, sizeof(buf));
  v3 = defaults::get((char *)v9, (char *)v6, &buf);
  if (v3)
  {
    prop::file::get<std::string>((const void **)v9, (uint64_t)v6, (uint64_t)&buf, &v11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v11;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v10 & 0x80000000) == 0)
      goto LABEL_9;
LABEL_12:
    operator delete(v9[0]);
    if (!v3)
      goto LABEL_14;
    goto LABEL_13;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v10 < 0)
    goto LABEL_12;
LABEL_9:
  if (v3)
LABEL_13:
    util::convert<BOOL>(&__p, (BOOL *)this + 152, 0);
LABEL_14:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v7 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v7 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v6[0]);
LABEL_16:
  v7 = 7;
  strcpy((char *)v6, "History");
  memset(&__p, 0, sizeof(__p));
  v10 = 3;
  LOWORD(v9[0]) = *(_WORD *)"IPC";
  WORD1(v9[0]) = str_41[2];
  memset(&buf, 0, sizeof(buf));
  v4 = defaults::get((char *)v9, (char *)v6, &buf);
  if (v4)
  {
    prop::file::get<std::string>((const void **)v9, (uint64_t)v6, (uint64_t)&buf, &v11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v11;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v10 & 0x80000000) == 0)
      goto LABEL_22;
LABEL_27:
    operator delete(v9[0]);
    if (!v4)
      goto LABEL_29;
    goto LABEL_28;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v10 < 0)
    goto LABEL_27;
LABEL_22:
  if (v4)
LABEL_28:
    util::convert<int>(&__p, (_DWORD *)this + 39, 0);
LABEL_29:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v7 & 0x80000000) == 0)
      goto LABEL_31;
  }
  else if ((v7 & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v6[0]);
LABEL_31:
  v7 = 11;
  strcpy((char *)v6, "BufferCount");
  memset(&__p, 0, sizeof(__p));
  v10 = 3;
  LOWORD(v9[0]) = *(_WORD *)"IPC";
  WORD1(v9[0]) = str_41[2];
  memset(&buf, 0, sizeof(buf));
  v5 = defaults::get((char *)v9, (char *)v6, &buf);
  if (v5)
  {
    prop::file::get<std::string>((const void **)v9, (uint64_t)v6, (uint64_t)&buf, &v11);
    __p = v11;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v10 & 0x80000000) == 0)
      goto LABEL_35;
LABEL_40:
    operator delete(v9[0]);
    if (!v5)
      goto LABEL_42;
    goto LABEL_41;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v10 < 0)
    goto LABEL_40;
LABEL_35:
  if (v5)
LABEL_41:
    util::convert<unsigned int>(&__p, (_DWORD *)this + 40, 0);
LABEL_42:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0)
      return;
LABEL_46:
    operator delete(v6[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v7 < 0)
    goto LABEL_46;
}

void sub_1A34C7A28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::dumpCodeRegistry_sync(KernelPCIABPTrace *this)
{
  NSObject *v2;
  xpc_object_t v3;
  uint64_t v4;
  xpc_object_t v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  xpc_object_t v12;
  xpc_object_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  xpc_object_t v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  _QWORD *v27;
  xpc_object_t v28;
  NSObject *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  void *v34;
  uint64_t v35;
  void **v36;
  void **i;
  xpc_object_t v38;
  xpc_object_t v39;
  int v40;
  xpc_object_t v41;
  uint64_t v42;
  xpc_object_t v43;
  char *v44;
  char *v45;
  __int128 v46;
  __int128 v47;
  xpc_object_t v48;
  xpc_object_t v49;
  const char *v50;
  xpc_object_t v51;
  xpc_object_t v52;
  xpc_object_t v53;
  xpc_object_t v54;
  xpc_object_t v55;
  xpc_object_t v56;
  xpc_object_t v57;
  xpc_object_t v58;
  const char *v59;
  xpc_object_t v60;
  xpc_object_t v61;
  const char *v62;
  xpc_object_t v63;
  xpc_object_t v64;
  xpc_object_t v65;
  xpc_object_t v66;
  void **v67;
  void **v68;
  void *v69;
  xpc_object_t v70;
  xpc_object_t object;
  _BYTE v72[32];
  int64_t v73;
  timeval v74;
  _BYTE value[20];
  char *string[2];
  __int128 v77;
  int64_t v78;
  void *__p;
  void **v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)&value[4] = 136315138;
    *(_QWORD *)&value[8] = "dumpCodeRegistry_sync";
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D %s", &value[4], 0xCu);
    if (!*((_QWORD *)this + 27))
      return;
  }
  else if (!*((_QWORD *)this + 27))
  {
    return;
  }
  v3 = xpc_dictionary_create(0, 0, 0);
  v4 = MEMORY[0x1E0C812F8];
  if (v3 || (v3 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v3) == v4)
    {
      xpc_retain(v3);
      v5 = v3;
    }
    else
    {
      v5 = xpc_null_create();
    }
  }
  else
  {
    v5 = xpc_null_create();
    v3 = 0;
  }
  xpc_release(v3);
  if (MEMORY[0x1A85902BC](v5) == v4)
  {
    *(_DWORD *)value = -1431655766;
    if ((*(unsigned int (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 27) + 104))(*((_QWORD *)this + 27), value))
    {
      v7 = xpc_int64_create(*(unsigned int *)value);
      if (!v7)
        v7 = xpc_null_create();
      xpc_dictionary_set_value(v5, "TraceCodeSize", v7);
      v8 = xpc_null_create();
      xpc_release(v7);
      xpc_release(v8);
    }
    if ((*(unsigned int (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 27) + 112))(*((_QWORD *)this + 27), value))
    {
      v9 = xpc_int64_create(*(unsigned int *)value);
      if (!v9)
        v9 = xpc_null_create();
      xpc_dictionary_set_value(v5, "MinTraceBufferSize", v9);
      v10 = xpc_null_create();
      xpc_release(v9);
      xpc_release(v10);
    }
    if ((*(unsigned int (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 27) + 120))(*((_QWORD *)this + 27), value))
    {
      v11 = xpc_int64_create(*(unsigned int *)value);
      if (!v11)
        v11 = xpc_null_create();
      xpc_dictionary_set_value(v5, "MaxTraceBufferSize", v11);
      v12 = xpc_null_create();
      xpc_release(v11);
      xpc_release(v12);
    }
    if ((*(unsigned int (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 27) + 136))(*((_QWORD *)this + 27), value))
    {
      v13 = xpc_int64_create(*(unsigned int *)value);
      if (!v13)
        v13 = xpc_null_create();
      xpc_dictionary_set_value(v5, "MaxTraceBuffersInFlight", v13);
      v14 = xpc_null_create();
      xpc_release(v13);
      xpc_release(v14);
    }
    if ((*(unsigned int (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 27) + 128))(*((_QWORD *)this + 27), value))
    {
      v15 = xpc_int64_create(*(unsigned int *)value);
      if (!v15)
        v15 = xpc_null_create();
      xpc_dictionary_set_value(v5, "SnapshotBufferSize", v15);
      v16 = xpc_null_create();
      xpc_release(v15);
      xpc_release(v16);
    }
    v74.tv_sec = 0;
    *(_QWORD *)&v74.tv_usec = 0;
    v73 = 0;
    if (!gettimeofday(&v74, &v73))
    {
      v17 = xpc_int64_create((int)v73);
      if (!v17)
        v17 = xpc_null_create();
      xpc_dictionary_set_value(v5, "TimeZoneMinutesWest", v17);
      v18 = xpc_null_create();
      xpc_release(v17);
      xpc_release(v18);
      v19 = xpc_int64_create(SHIDWORD(v73));
      if (!v19)
        v19 = xpc_null_create();
      xpc_dictionary_set_value(v5, "TimeZoneAdjust", v19);
      v20 = xpc_null_create();
      xpc_release(v19);
      xpc_release(v20);
    }
    v21 = xpc_array_create(0, 0);
    v22 = MEMORY[0x1E0C812C8];
    if (v21 || (v21 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A85902BC](v21) == v22)
      {
        xpc_retain(v21);
        object = v21;
      }
      else
      {
        object = xpc_null_create();
      }
    }
    else
    {
      object = xpc_null_create();
      v21 = 0;
    }
    xpc_release(v21);
    if (!(*(unsigned int (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 27) + 96))(*((_QWORD *)this + 27), value)|| MEMORY[0x1A85902BC](object) != v22)
    {
      goto LABEL_47;
    }
    v78 = 0xAAAAAAAAAAAAAAAALL;
    __p = 0;
    v80 = 0;
    v81 = 0;
    *(_OWORD *)&value[4] = 0u;
    *(_OWORD *)string = 0u;
    v77 = 0u;
    if (*(_DWORD *)value)
    {
      v35 = 0;
      v70 = v5;
      do
      {
        v36 = (void **)__p;
        for (i = v80; i != v36; i -= 4)
        {
          if (*((char *)i - 9) < 0)
            operator delete(*(i - 4));
        }
        v80 = v36;
        if (((*(uint64_t (**)(_QWORD, uint64_t, _BYTE *))(**((_QWORD **)this + 27) + 144))(*((_QWORD *)this + 27), v35, &value[4]) & 1) == 0)goto LABEL_61;
        v38 = xpc_dictionary_create(0, 0, 0);
        if (v38 || (v38 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v38) == v4)
          {
            xpc_retain(v38);
            v39 = v38;
          }
          else
          {
            v39 = xpc_null_create();
          }
        }
        else
        {
          v39 = xpc_null_create();
          v38 = 0;
        }
        xpc_release(v38);
        if (MEMORY[0x1A85902BC](v39) != v4)
        {
          v40 = 6;
          goto LABEL_131;
        }
        v41 = xpc_array_create(0, 0);
        v42 = MEMORY[0x1E0C812C8];
        if (v41 || (v41 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v41) == v42)
          {
            xpc_retain(v41);
            v43 = v41;
          }
          else
          {
            v43 = xpc_null_create();
          }
        }
        else
        {
          v43 = xpc_null_create();
          v41 = 0;
        }
        xpc_release(v41);
        if (MEMORY[0x1A85902BC](v43) == v42)
        {
          v45 = (char *)__p;
          v44 = (char *)v80;
          while (v45 != v44)
          {
            *(_QWORD *)&v46 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v46 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)v72 = v46;
            *(_OWORD *)&v72[16] = v46;
            if (v45[23] < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)v72, *(const std::string::value_type **)v45, *((_QWORD *)v45 + 1));
            }
            else
            {
              v47 = *(_OWORD *)v45;
              *(_QWORD *)&v72[16] = *((_QWORD *)v45 + 2);
              *(_OWORD *)v72 = v47;
            }
            *(_DWORD *)&v72[24] = *((_DWORD *)v45 + 6);
            v48 = xpc_dictionary_create(0, 0, 0);
            if (v48 || (v48 = xpc_null_create()) != 0)
            {
              if (MEMORY[0x1A85902BC](v48) == v4)
              {
                xpc_retain(v48);
                v49 = v48;
              }
              else
              {
                v49 = xpc_null_create();
              }
            }
            else
            {
              v49 = xpc_null_create();
              v48 = 0;
            }
            xpc_release(v48);
            if (MEMORY[0x1A85902BC](v49) != v4)
            {
              xpc_release(v49);
              v5 = v70;
              if ((v72[23] & 0x80000000) != 0)
                operator delete(*(void **)v72);
              v40 = 1;
              goto LABEL_130;
            }
            if (v72[23] >= 0)
              v50 = v72;
            else
              v50 = *(const char **)v72;
            v51 = xpc_string_create(v50);
            if (!v51)
              v51 = xpc_null_create();
            xpc_dictionary_set_value(v49, "TypeName", v51);
            v52 = xpc_null_create();
            xpc_release(v51);
            xpc_release(v52);
            v53 = xpc_int64_create(*(unsigned int *)&v72[24]);
            if (!v53)
              v53 = xpc_null_create();
            xpc_dictionary_set_value(v49, "Size", v53);
            v54 = xpc_null_create();
            xpc_release(v53);
            xpc_release(v54);
            xpc_array_append_value(v43, v49);
            xpc_release(v49);
            if ((v72[23] & 0x80000000) != 0)
              operator delete(*(void **)v72);
            v45 += 32;
          }
          v5 = v70;
          if (MEMORY[0x1A85902BC](v43) == MEMORY[0x1E0C812C8] && xpc_array_get_count(v43))
          {
            if (v43)
            {
              xpc_retain(v43);
              v55 = v43;
            }
            else
            {
              v55 = xpc_null_create();
            }
            xpc_dictionary_set_value(v39, "Attachments", v55);
            v56 = xpc_null_create();
            xpc_release(v55);
            xpc_release(v56);
          }
        }
        v57 = xpc_int64_create(v78);
        if (!v57)
          v57 = xpc_null_create();
        xpc_dictionary_set_value(v39, "Code", v57);
        v58 = xpc_null_create();
        xpc_release(v57);
        xpc_release(v58);
        if (SHIBYTE(string[0]) >= 0)
          v59 = &value[4];
        else
          v59 = *(const char **)&value[4];
        v60 = xpc_string_create(v59);
        if (!v60)
          v60 = xpc_null_create();
        xpc_dictionary_set_value(v39, "Text", v60);
        v61 = xpc_null_create();
        xpc_release(v60);
        xpc_release(v61);
        if (SHIBYTE(v77) < 0)
        {
          if (!(_QWORD)v77)
            goto LABEL_129;
          v62 = string[1];
        }
        else
        {
          v62 = (const char *)&string[1];
          if (!HIBYTE(v77))
            goto LABEL_129;
        }
        v63 = xpc_string_create(v62);
        if (!v63)
          v63 = xpc_null_create();
        xpc_dictionary_set_value(v39, "Location", v63);
        v64 = xpc_null_create();
        xpc_release(v63);
        xpc_release(v64);
LABEL_129:
        xpc_array_append_value(object, v39);
        v40 = 0;
LABEL_130:
        xpc_release(v43);
LABEL_131:
        xpc_release(v39);
        if (v40 != 6 && v40)
          goto LABEL_138;
LABEL_61:
        v35 = (v35 + 1);
      }
      while (v35 < *(_DWORD *)value);
    }
    v65 = object;
    if (object)
      xpc_retain(object);
    else
      v65 = xpc_null_create();
    xpc_dictionary_set_value(v5, "TraceCodes", v65);
    v66 = xpc_null_create();
    xpc_release(v65);
    xpc_release(v66);
    v40 = 0;
LABEL_138:
    v67 = (void **)__p;
    if (__p)
    {
      v68 = v80;
      v69 = __p;
      if (v80 != __p)
      {
        do
        {
          if (*((char *)v68 - 9) < 0)
            operator delete(*(v68 - 4));
          v68 -= 4;
        }
        while (v68 != v67);
        v69 = __p;
      }
      v80 = v67;
      operator delete(v69);
    }
    if (SHIBYTE(v77) < 0)
    {
      operator delete(string[1]);
      if ((SHIBYTE(string[0]) & 0x80000000) == 0)
      {
LABEL_148:
        if (!v40)
        {
LABEL_47:
          v6 = xpc_null_create();
          v23 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
          if (!v23 || (v24 = *((_QWORD *)this + 9), (v25 = std::__shared_weak_count::lock(v23)) == 0))
            std::__throw_bad_weak_ptr[abi:ne180100]();
          v26 = v25;
          v27 = operator new(0x10uLL);
          *v27 = this;
          v27[1] = v5;
          v28 = xpc_null_create();
          v29 = *((_QWORD *)this + 11);
          p_shared_owners = (unint64_t *)&v26->__shared_owners_;
          do
            v31 = __ldxr(p_shared_owners);
          while (__stxr(v31 + 1, p_shared_owners));
          v32 = operator new(0x18uLL);
          *v32 = v27;
          v32[1] = v24;
          v32[2] = v26;
          dispatch_async_f(v29, v32, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>(KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke);
          do
            v33 = __ldaxr(p_shared_owners);
          while (__stlxr(v33 - 1, p_shared_owners));
          if (!v33)
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
          }
          xpc_release(v28);
          v34 = object;
          goto LABEL_56;
        }
LABEL_152:
        v6 = v5;
        v34 = object;
LABEL_56:
        xpc_release(v34);
        goto LABEL_57;
      }
    }
    else if ((SHIBYTE(string[0]) & 0x80000000) == 0)
    {
      goto LABEL_148;
    }
    operator delete(*(void **)&value[4]);
    if (!v40)
      goto LABEL_47;
    goto LABEL_152;
  }
  v6 = v5;
LABEL_57:
  xpc_release(v6);
}

void sub_1A34C8580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void pci::transport::kernelTrace::traceCodeDict::~traceCodeDict(pci::transport::kernelTrace::traceCodeDict *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    v3 = *((_QWORD *)this + 8);
    v4 = (void *)*((_QWORD *)this + 7);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 9) < 0)
          operator delete(*(void **)(v3 - 32));
        v3 -= 32;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 7);
    }
    *((_QWORD *)this + 8) = v2;
    operator delete(v4);
  }
  if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    if ((*((char *)this + 23) & 0x80000000) == 0)
      return;
LABEL_13:
    operator delete(*(void **)this);
    return;
  }
  operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0)
    goto LABEL_13;
}

_QWORD *KernelPCIABPTrace::createBuffContext_sync(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  size_t v21;
  uint64_t *v22;
  uint64_t **v23;
  uint64_t **v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  unint64_t v30;

  v6 = operator new(0x30uLL);
  v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v7 || (v8 = *(_QWORD *)(a1 + 72), (v9 = std::__shared_weak_count::lock(v7)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v10 = v9;
  p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
  do
    v12 = __ldxr(p_shared_weak_owners);
  while (__stxr(v12 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v10);
  }
  v15 = *a3;
  v16 = (std::__shared_weak_count *)a3[1];
  if (!v16)
  {
    *v6 = 0;
    v6[1] = a2;
    v6[2] = v8;
    v6[3] = v10;
    do
      v30 = __ldxr(p_shared_weak_owners);
    while (__stxr(v30 + 1, p_shared_weak_owners));
    v6[4] = v15;
    v6[5] = 0;
LABEL_33:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  v17 = (unint64_t *)&v16->__shared_weak_owners_;
  do
    v18 = __ldxr(v17);
  while (__stxr(v18 + 1, v17));
  *v6 = 0;
  v6[1] = a2;
  v6[2] = v8;
  v6[3] = v10;
  do
    v19 = __ldxr(p_shared_weak_owners);
  while (__stxr(v19 + 1, p_shared_weak_owners));
  v6[4] = v15;
  v20 = std::__shared_weak_count::lock(v16);
  v6[5] = v20;
  if (!v20)
    goto LABEL_33;
  v21 = v6[1];
  if (v21)
    *v6 = malloc_type_malloc(v21, 0x4D6292B9uLL);
  std::__shared_weak_count::__release_weak(v16);
  std::__shared_weak_count::__release_weak(v10);
  v23 = (uint64_t **)(a1 + 176);
  v22 = *(uint64_t **)(a1 + 176);
  if (v22)
  {
    while (1)
    {
      while (1)
      {
        v24 = (uint64_t **)v22;
        v25 = v22[4];
        if ((unint64_t)v6 >= v25)
          break;
        v22 = *v24;
        v23 = v24;
        if (!*v24)
          goto LABEL_24;
      }
      if (v25 >= (unint64_t)v6)
        break;
      v22 = v24[1];
      if (!v22)
      {
        v23 = v24 + 1;
        goto LABEL_24;
      }
    }
  }
  else
  {
    v24 = (uint64_t **)(a1 + 176);
LABEL_24:
    v26 = (uint64_t *)operator new(0x28uLL);
    v26[4] = (uint64_t)v6;
    *v26 = 0;
    v26[1] = 0;
    v26[2] = (uint64_t)v24;
    *v23 = v26;
    v27 = **(_QWORD **)(a1 + 168);
    if (v27)
    {
      *(_QWORD *)(a1 + 168) = v27;
      v28 = *v23;
    }
    else
    {
      v28 = v26;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 176), v28);
    ++*(_QWORD *)(a1 + 184);
  }
  return v6;
}

void sub_1A34C8A7C(_Unwind_Exception *a1)
{
  void *v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  std::__shared_weak_count **v5;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v4);
  if (*v5)
    std::__shared_weak_count::__release_weak(*v5);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  std::__shared_weak_count::__release_weak(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A34C8AC0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::deleteBuffContext_sync(_QWORD *a1, unint64_t a2)
{
  uint64_t *v2;
  uint64_t *v4;
  _QWORD *v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;

  if (a2)
  {
    v2 = (uint64_t *)a1[22];
    if (v2)
    {
      v4 = a1 + 22;
      v5 = (_QWORD *)a1[22];
      do
      {
        v6 = v5[4];
        v7 = v6 >= a2;
        if (v6 >= a2)
          v8 = v5;
        else
          v8 = v5 + 1;
        if (v7)
          v4 = v5;
        v5 = (_QWORD *)*v8;
      }
      while (*v8);
      if (v4 != a1 + 22 && v4[4] <= a2)
      {
        v9 = (uint64_t *)v4[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = (uint64_t *)*v9;
          }
          while (v9);
        }
        else
        {
          v11 = v4;
          do
          {
            v10 = (uint64_t *)v11[2];
            v12 = *v10 == (_QWORD)v11;
            v11 = v10;
          }
          while (!v12);
        }
        if ((uint64_t *)a1[21] == v4)
          a1[21] = v10;
        --a1[23];
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v2, v4);
        operator delete(v4);
        if (*(_QWORD *)a2)
          free(*(void **)a2);
        v13 = *(std::__shared_weak_count **)(a2 + 40);
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v15 = __ldaxr(p_shared_owners);
          while (__stlxr(v15 - 1, p_shared_owners));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        v16 = *(std::__shared_weak_count **)(a2 + 24);
        if (v16)
          std::__shared_weak_count::__release_weak(v16);
        operator delete((void *)a2);
      }
    }
  }
}

void KernelPCIABPTrace::deleteAllBuffContext_sync(KernelPCIABPTrace *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  char *v9;
  char *v10;
  BOOL v11;

  v2 = (char *)*((_QWORD *)this + 21);
  v3 = (char *)this + 176;
  if (v2 != (char *)this + 176)
  {
    while (1)
    {
      v4 = *((_QWORD *)v2 + 4);
      if (v4)
        break;
LABEL_14:
      v9 = (char *)*((_QWORD *)v2 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (char *)*((_QWORD *)v2 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v2;
          v2 = v10;
        }
        while (!v11);
      }
      v2 = v10;
      if (v10 == v3)
        goto LABEL_2;
    }
    if (*(_QWORD *)v4)
      free(*(void **)v4);
    v5 = *(std::__shared_weak_count **)(v4 + 40);
    if (!v5)
      goto LABEL_11;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      v8 = *(std::__shared_weak_count **)(v4 + 24);
      if (!v8)
        goto LABEL_13;
    }
    else
    {
LABEL_11:
      v8 = *(std::__shared_weak_count **)(v4 + 24);
      if (!v8)
      {
LABEL_13:
        operator delete((void *)v4);
        goto LABEL_14;
      }
    }
    std::__shared_weak_count::__release_weak(v8);
    goto LABEL_13;
  }
LABEL_2:
  std::__tree<KernelPCITrace::BuffContext *>::destroy(*((_QWORD **)this + 22));
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 21) = v3;
}

void KernelPCIABPTrace::updateTraceState_sync(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if (*(_BYTE *)(a1 + 152))
      goto LABEL_3;
LABEL_6:
    KernelPCIABPTrace::stopTrace(a1, a2);
    return;
  }
  v5 = 136315138;
  v6 = "updateTraceState_sync";
  _os_log_debug_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v5, 0xCu);
  if (!*(_BYTE *)(a1 + 152))
    goto LABEL_6;
LABEL_3:
  if (!*(_BYTE *)(a1 + 153))
    KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)a1);
}

void KernelPCIABPTrace::startTrace_sync(KernelPCIABPTrace *this)
{
  NSObject *v2;
  KernelPCIABPTrace *v3;
  std::__shared_weak_count *v4;
  __int128 *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  char *v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t *v13;
  unint64_t v14;
  KernelPCIABPTrace *v15;
  KernelPCIABPTrace *v16;
  BOOL v17;
  NSObject *v18;
  uint8_t buf[16];
  std::string v20;
  __int128 *v21;
  std::__shared_weak_count *v22;
  _BYTE v23[32];
  __int128 v24;
  void *__p[2];
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v23 = 136315138;
    *(_QWORD *)&v23[4] = "startTrace_sync";
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D %s", v23, 0xCu);
  }
  *((_BYTE *)this + 153) = 1;
  if ((KernelPCIABPTrace::registerWithKernel_sync(this) & 1) != 0)
  {
    v3 = (KernelPCIABPTrace *)*((_QWORD *)this + 24);
    if (v3 != (KernelPCIABPTrace *)((char *)this + 200))
    {
      while (1)
      {
        v5 = (__int128 *)*((_QWORD *)v3 + 4);
        v4 = (std::__shared_weak_count *)*((_QWORD *)v3 + 5);
        v21 = v5;
        v22 = v4;
        if (v4)
        {
          p_shared_owners = (unint64_t *)&v4->__shared_owners_;
          do
            v7 = __ldxr(p_shared_owners);
          while (__stxr(v7 + 1, p_shared_owners));
        }
        *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v26 = v8;
        v27 = v8;
        v24 = v8;
        *(_OWORD *)__p = v8;
        *(_OWORD *)v23 = v8;
        *(_OWORD *)&v23[16] = v8;
        if (*((char *)v5 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)v5, *((_QWORD *)v5 + 1));
        }
        else
        {
          v9 = *v5;
          v20.__r_.__value_.__r.__words[2] = *((_QWORD *)v5 + 2);
          *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v9;
        }
        v10 = (char *)operator new(0x48uLL);
        strcpy(v10, "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/");
        v11 = *((int *)this + 39);
        if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external((std::string *)v23, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
        else
          *(std::string *)v23 = v20;
        std::string::__init_copy_ctor_external((std::string *)&v23[24], v10, 0x40uLL);
        __p[1] = 0;
        *(_QWORD *)&v26 = 0xB00000000000000;
        *((_QWORD *)&v26 + 1) = v11 << 20;
        *(_QWORD *)&v27 = 0x100000;
        BYTE8(v27) = 0;
        *(_DWORD *)((char *)__p + 7) = 1701011826;
        __p[0] = *(void **)".acipctrace";
        operator delete(v10);
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          break;
        operator delete(v20.__r_.__value_.__l.__data_);
        v12 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          goto LABEL_18;
LABEL_19:
        KernelPCIABPTrace::PipeContext::start((KernelPCIABPTrace::PipeContext *)v5, (CircularFileLogWriter::Params *)v23);
        if (SBYTE7(v26) < 0)
        {
          operator delete(__p[0]);
          if ((SHIBYTE(v24) & 0x80000000) == 0)
          {
LABEL_21:
            if ((v23[23] & 0x80000000) == 0)
              goto LABEL_22;
            goto LABEL_28;
          }
        }
        else if ((SHIBYTE(v24) & 0x80000000) == 0)
        {
          goto LABEL_21;
        }
        operator delete(*(void **)&v23[24]);
        if ((v23[23] & 0x80000000) == 0)
        {
LABEL_22:
          if (!v4)
            goto LABEL_32;
          goto LABEL_29;
        }
LABEL_28:
        operator delete(*(void **)v23);
        if (!v4)
          goto LABEL_32;
LABEL_29:
        v13 = (unint64_t *)&v4->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (v14)
        {
LABEL_32:
          v15 = (KernelPCIABPTrace *)*((_QWORD *)v3 + 1);
          if (!v15)
            goto LABEL_36;
          goto LABEL_33;
        }
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
        v15 = (KernelPCIABPTrace *)*((_QWORD *)v3 + 1);
        if (!v15)
        {
          do
          {
LABEL_36:
            v16 = (KernelPCIABPTrace *)*((_QWORD *)v3 + 2);
            v17 = *(_QWORD *)v16 == (_QWORD)v3;
            v3 = v16;
          }
          while (!v17);
          goto LABEL_6;
        }
        do
        {
LABEL_33:
          v16 = v15;
          v15 = *(KernelPCIABPTrace **)v15;
        }
        while (v15);
LABEL_6:
        v3 = v16;
        if (v16 == (KernelPCIABPTrace *)((char *)this + 200))
          goto LABEL_42;
      }
      v12 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
LABEL_18:
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Create and open log writer", buf, 2u);
      goto LABEL_19;
    }
LABEL_42:
    KernelPCIABPTrace::dumpCodeRegistry_sync(this);
  }
  else
  {
    v18 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v23 = 0;
      _os_log_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEFAULT, "#E Registering with Kernel driver failed. De-register to cleanup", v23, 2u);
    }
    KernelPCIABPTrace::deregisterWithKernel_sync(this);
  }
}

void sub_1A34C9148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;

  operator delete(v27);
  if (a18 < 0)
    operator delete(__p);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::stopTrace(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  _QWORD *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD v9[6];
  const __CFDictionary *v10;
  NSObject *v11;
  uint8_t buf[4];
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315138;
    v13 = "stopTrace";
    _os_log_debug_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  }
  v5 = *(_QWORD **)(a1 + 200);
  *(_BYTE *)(a1 + 153) = 0;
  std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(v5);
  *(_QWORD *)(a1 + 192) = a1 + 200;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  v6 = dispatch_group_create();
  v7 = v6;
  v11 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v7);
  }
  v10 = 0;
  KernelPCIABPTrace::snapshot_sync(a1, &v11, &v10);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  v8 = *(NSObject **)(a1 + 88);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = ___ZN17KernelPCIABPTrace9stopTraceERKN8dispatch13group_sessionE_block_invoke;
  v9[3] = &__block_descriptor_tmp_13;
  v9[4] = a1;
  v9[5] = a2;
  dispatch_group_notify(v7, v8, v9);
  if (v7)
    dispatch_release(v7);
}

void sub_1A34C9320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  NSObject *v7;
  va_list va;

  va_start(va, a7);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)va);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
    dispatch_release(v7);
  }
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::snapshot_sync(uint64_t a1, NSObject **a2, const __CFDictionary **a3)
{
  NSObject *v6;
  const char *v7;
  void *v8;
  char **v9;
  const char *v10;
  size_t v11;
  std::string::size_type v12;
  std::string *p_dst;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  size_t v17;
  std::string::size_type v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  void **v22;
  std::string::size_type v23;
  std::string *v24;
  __int128 v25;
  void **v26;
  std::string::size_type v27;
  std::string *v28;
  __int128 v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  std::string::size_type v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint8_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  _QWORD *v46;
  std::__shared_weak_count *v47;
  std::string::size_type v48;
  unint64_t *p_shared_owners;
  unint64_t v50;
  _QWORD *BuffContext_sync;
  int v52;
  NSObject *v53;
  _BOOL4 v54;
  NSObject *v55;
  unint64_t *v56;
  unint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60[2];
  char v61;
  std::string v62;
  std::string v63;
  std::string v64;
  std::string __dst;
  void *v66[3];
  void *__p[3];
  _QWORD v68[2];
  _QWORD v69[2];
  uint8_t buf[24];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v6 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    if (!*(_QWORD *)(a1 + 216))
      return;
LABEL_3:
    v68[0] = 0xAAAAAAAAAAAAAAAALL;
    v68[1] = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v68, *a3);
    memset(buf, 170, sizeof(buf));
    __p[0] = operator new(0x28uLL);
    *(_OWORD *)&__p[1] = xmmword_1A357F480;
    strcpy((char *)__p[0], "kCollectTelephonyLogsWithCoredump");
    ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v66, "kKeyTraceAction");
    ctu::cf::map_adapter::getString();
    MEMORY[0x1A858F29C](v66);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    memset(__p, 170, sizeof(__p));
    v7 = (const char *)*MEMORY[0x1E0CFB370];
    memset(v66, 0, sizeof(v66));
    ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&__dst, v7);
    ctu::cf::map_adapter::getString();
    MEMORY[0x1A858F29C](&__dst);
    if (SHIBYTE(v66[2]) < 0)
      operator delete(v66[0]);
    memset(v66, 170, sizeof(v66));
    v8 = (void *)HIBYTE(__p[2]);
    if (SHIBYTE(__p[2]) < 0)
      v8 = __p[1];
    if (v8)
      v9 = abm::trace::kSnapshotFolder;
    else
      v9 = abm::trace::kTrashFolder;
    v10 = *v9;
    v11 = strlen(*v9);
    if (v11 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v12 = v11;
    if (v11 >= 0x17)
    {
      v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17)
        v14 = v11 | 7;
      v15 = v14 + 1;
      p_dst = (std::string *)operator new(v14 + 1);
      __dst.__r_.__value_.__l.__size_ = v12;
      __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v11;
      p_dst = &__dst;
      if (!v11)
      {
LABEL_20:
        p_dst->__r_.__value_.__s.__data_[v12] = 0;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v64, "kKeyTraceDumpStatePath");
        ctu::cf::map_adapter::getString();
        MEMORY[0x1A858F29C](&v64);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__dst.__r_.__value_.__l.__data_);
        v16 = abm::trace::kLogDirPrefix[0];
        v17 = strlen(abm::trace::kLogDirPrefix[0]);
        if (v17 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v18 = v17;
        if (v17 >= 0x17)
        {
          v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v17 | 7) != 0x17)
            v20 = v17 | 7;
          v21 = v20 + 1;
          v19 = operator new(v20 + 1);
          v62.__r_.__value_.__l.__size_ = v18;
          v62.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
          v62.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
        }
        else
        {
          *((_BYTE *)&v62.__r_.__value_.__s + 23) = v17;
          v19 = &v62;
          if (!v17)
          {
LABEL_30:
            v19[v18] = 0;
            if (SHIBYTE(v66[2]) >= 0)
              v22 = v66;
            else
              v22 = (void **)v66[0];
            if (SHIBYTE(v66[2]) >= 0)
              v23 = HIBYTE(v66[2]);
            else
              v23 = (std::string::size_type)v66[1];
            v24 = std::string::insert(&v62, 0, (const std::string::value_type *)v22, v23);
            v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
            v63.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v63.__r_.__value_.__l.__data_ = v25;
            v24->__r_.__value_.__l.__size_ = 0;
            v24->__r_.__value_.__r.__words[2] = 0;
            v24->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(__p[2]) >= 0)
              v26 = __p;
            else
              v26 = (void **)__p[0];
            if (SHIBYTE(__p[2]) >= 0)
              v27 = HIBYTE(__p[2]);
            else
              v27 = (std::string::size_type)__p[1];
            v28 = std::string::append(&v63, (const std::string::value_type *)v26, v27);
            v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
            v64.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v29;
            v28->__r_.__value_.__l.__size_ = 0;
            v28->__r_.__value_.__r.__words[2] = 0;
            v28->__r_.__value_.__r.__words[0] = 0;
            v30 = std::string::append(&v64, "-", 1uLL);
            v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v31;
            v30->__r_.__value_.__l.__size_ = 0;
            v30->__r_.__value_.__r.__words[2] = 0;
            v30->__r_.__value_.__r.__words[0] = 0;
            v61 = 7;
            strcpy((char *)v60, "pci-bin");
            v32 = std::string::append(&__dst, (const std::string::value_type *)v60, 7uLL);
            v33 = v32->__r_.__value_.__r.__words[0];
            v69[0] = v32->__r_.__value_.__l.__size_;
            *(_QWORD *)((char *)v69 + 7) = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
            v34 = HIBYTE(v32->__r_.__value_.__r.__words[2]);
            v32->__r_.__value_.__l.__size_ = 0;
            v32->__r_.__value_.__r.__words[2] = 0;
            v32->__r_.__value_.__r.__words[0] = 0;
            if (*(char *)(a1 + 255) < 0)
              operator delete(*(void **)(a1 + 232));
            v35 = v69[0];
            *(_QWORD *)(a1 + 232) = v33;
            *(_QWORD *)(a1 + 240) = v35;
            *(_QWORD *)(a1 + 247) = *(_QWORD *)((char *)v69 + 7);
            *(_BYTE *)(a1 + 255) = v34;
            if (v61 < 0)
            {
              operator delete(v60[0]);
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_46:
                if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_47;
                goto LABEL_100;
              }
            }
            else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_46;
            }
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_47:
              if ((SHIBYTE(v63.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_48;
              goto LABEL_101;
            }
LABEL_100:
            operator delete(v64.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v63.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_48:
              if ((SHIBYTE(v62.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_49;
LABEL_102:
              operator delete(v62.__r_.__value_.__l.__data_);
LABEL_49:
              v36 = buf[23];
              if ((buf[23] & 0x80u) != 0)
                v36 = *(_QWORD *)&buf[8];
              if (v36 == 17)
              {
                v37 = buf;
                if ((buf[23] & 0x80u) != 0)
                  v37 = *(uint8_t **)buf;
                v38 = *(_QWORD *)v37;
                v39 = *((_QWORD *)v37 + 1);
                v40 = v37[16];
                v41 = v38 == *(_QWORD *)"kShutdownAllTrace" && v39 == *(_QWORD *)"nAllTrace";
                if (v41 && v40 == str_71[16])
                {
                  v43 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
                    _os_log_impl(&dword_1A343C000, v43, OS_LOG_TYPE_DEFAULT, "#I Snapshot requested as part of shutdown", (uint8_t *)&__dst, 2u);
                  }
                  *(_BYTE *)(a1 + 153) = 0;
                }
              }
              v44 = *a2;
              if (v44)
              {
                dispatch_retain(v44);
                dispatch_group_enter(v44);
              }
              v45 = *(NSObject **)(a1 + 256);
              *(_QWORD *)(a1 + 256) = v44;
              if (v45)
              {
                dispatch_group_leave(v45);
                dispatch_release(v45);
              }
              v46 = *(_QWORD **)(a1 + 192);
              if (v46 != (_QWORD *)(a1 + 200))
              {
                do
                {
                  v48 = v46[4];
                  v47 = (std::__shared_weak_count *)v46[5];
                  __dst.__r_.__value_.__r.__words[0] = v48;
                  __dst.__r_.__value_.__l.__size_ = (std::string::size_type)v47;
                  if (v47)
                  {
                    p_shared_owners = (unint64_t *)&v47->__shared_owners_;
                    do
                      v50 = __ldxr(p_shared_owners);
                    while (__stxr(v50 + 1, p_shared_owners));
                  }
                  BuffContext_sync = KernelPCIABPTrace::createBuffContext_sync(a1, 0, (uint64_t *)&__dst);
                  v52 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, void (*)(_QWORD *, int, uint64_t), _QWORD *))(**(_QWORD **)(a1 + 216) + 80))(*(_QWORD *)(a1 + 216), *(unsigned int *)(v48 + 24), 1, flushLogsCompletionCB, BuffContext_sync);
                  v53 = *(NSObject **)(a1 + 40);
                  v54 = os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
                  if (v52)
                  {
                    if (v54)
                    {
                      LOWORD(v64.__r_.__value_.__l.__data_) = 0;
                      _os_log_impl(&dword_1A343C000, v53, OS_LOG_TYPE_DEFAULT, "#E Failed assigning null-buffer to trigger snapshot", (uint8_t *)&v64, 2u);
                    }
                    KernelPCIABPTrace::deleteBuffContext_sync((_QWORD *)a1, (unint64_t)BuffContext_sync);
                    v55 = *(NSObject **)(a1 + 256);
                    *(_QWORD *)(a1 + 256) = 0;
                    if (v55)
                    {
                      dispatch_group_leave(v55);
                      dispatch_release(v55);
                    }
                  }
                  else if (v54)
                  {
                    LOWORD(v64.__r_.__value_.__l.__data_) = 0;
                    _os_log_impl(&dword_1A343C000, v53, OS_LOG_TYPE_DEFAULT, "#I Assign null-buffer to trigger snapshot", (uint8_t *)&v64, 2u);
                  }
                  if (!v47)
                    goto LABEL_86;
                  v56 = (unint64_t *)&v47->__shared_owners_;
                  do
                    v57 = __ldaxr(v56);
                  while (__stlxr(v57 - 1, v56));
                  if (!v57)
                  {
                    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                    std::__shared_weak_count::__release_weak(v47);
                    v58 = (_QWORD *)v46[1];
                    if (!v58)
                    {
                      do
                      {
LABEL_90:
                        v59 = (_QWORD *)v46[2];
                        v41 = *v59 == (_QWORD)v46;
                        v46 = v59;
                      }
                      while (!v41);
                      goto LABEL_71;
                    }
                  }
                  else
                  {
LABEL_86:
                    v58 = (_QWORD *)v46[1];
                    if (!v58)
                      goto LABEL_90;
                  }
                  do
                  {
                    v59 = v58;
                    v58 = (_QWORD *)*v58;
                  }
                  while (v58);
LABEL_71:
                  v46 = v59;
                }
                while (v59 != (_QWORD *)(a1 + 200));
              }
              if (SHIBYTE(v66[2]) < 0)
              {
                operator delete(v66[0]);
                if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                {
LABEL_95:
                  if (((char)buf[23] & 0x80000000) == 0)
                  {
LABEL_96:
                    MEMORY[0x1A858F2D8](v68);
                    return;
                  }
LABEL_105:
                  operator delete(*(void **)buf);
                  goto LABEL_96;
                }
              }
              else if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
              {
                goto LABEL_95;
              }
              operator delete(__p[0]);
              if (((char)buf[23] & 0x80000000) == 0)
                goto LABEL_96;
              goto LABEL_105;
            }
LABEL_101:
            operator delete(v63.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v62.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_49;
            goto LABEL_102;
          }
        }
        memmove(v19, v16, v18);
        goto LABEL_30;
      }
    }
    memmove(p_dst, v10, v12);
    goto LABEL_20;
  }
  *(_DWORD *)buf = 136315138;
  *(_QWORD *)&buf[4] = "snapshot_sync";
  _os_log_debug_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  if (*(_QWORD *)(a1 + 216))
    goto LABEL_3;
}

void sub_1A34C9AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  uint64_t v53;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((a40 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a33 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else if ((a40 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a35);
  if ((a33 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a26 & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  operator delete(a28);
  if ((a26 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a20 & 0x80000000) == 0)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a21);
  if ((a20 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a47 & 0x80000000) == 0)
    {
LABEL_14:
      if (a53 < 0)
        operator delete(a48);
      if (*(char *)(v53 - 105) < 0)
        operator delete(*(void **)(v53 - 128));
      MEMORY[0x1A858F2D8](v53 - 160);
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a42);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a15);
  if ((a47 & 0x80000000) == 0)
    goto LABEL_14;
  goto LABEL_13;
}

void ___ZN17KernelPCIABPTrace9stopTraceERKN8dispatch13group_sessionE_block_invoke(uint64_t a1)
{
  KernelPCIABPTrace *v1;
  _QWORD *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  std::__shared_weak_count *v18;

  v1 = *(KernelPCIABPTrace **)(a1 + 32);
  KernelPCIABPTrace::deregisterWithKernel_sync(v1);
  v2 = (_QWORD *)*((_QWORD *)v1 + 24);
  v3 = (_QWORD *)((char *)v1 + 200);
  if (v2 != (_QWORD *)((char *)v1 + 200))
  {
    do
    {
      v5 = v2[4];
      v4 = (std::__shared_weak_count *)v2[5];
      v18 = v4;
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }
      v8 = *(_QWORD *)(v5 + 32);
      if (!v8)
        goto LABEL_12;
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
      (*(void (**)(_QWORD))(**(_QWORD **)(v5 + 32) + 64))(*(_QWORD *)(v5 + 32));
      v9 = *(std::__shared_weak_count **)(v5 + 40);
      *(_QWORD *)(v5 + 32) = 0;
      *(_QWORD *)(v5 + 40) = 0;
      if (!v9)
        goto LABEL_12;
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
        v12 = v18;
        if (v18)
        {
LABEL_13:
          v13 = (unint64_t *)&v12->__shared_owners_;
          do
            v14 = __ldaxr(v13);
          while (__stlxr(v14 - 1, v13));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
      }
      else
      {
LABEL_12:
        v12 = v18;
        if (v18)
          goto LABEL_13;
      }
      v15 = (_QWORD *)v2[1];
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (_QWORD *)v2[2];
          v17 = *v16 == (_QWORD)v2;
          v2 = v16;
        }
        while (!v17);
      }
      v2 = v16;
    }
    while (v16 != v3);
  }
}

void sub_1A34C9DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::deregisterWithKernel_sync(KernelPCIABPTrace *this)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v9 = 136315138;
    v10 = "deregisterWithKernel_sync";
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v9, 0xCu);
    v3 = *((_QWORD *)this + 27);
    if (!v3)
      return;
  }
  else
  {
    v3 = *((_QWORD *)this + 27);
    if (!v3)
      return;
  }
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Stop Kernel Trace interface", (uint8_t *)&v9, 2u);
    v3 = *((_QWORD *)this + 27);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
  v5 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Destroy Kernel Trace object", (uint8_t *)&v9, 2u);
  }
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 28);
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = 0;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (*((_BYTE *)this + 264))
  {
    dispatch_group_leave(*((dispatch_group_t *)this + 18));
    *((_BYTE *)this + 264) = 0;
  }
}

void KernelPCIABPTrace::start(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[10];
  if (!v4 || (v5 = a1[9], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(0x10uLL);
  *v8 = a1;
  v8[1] = v3;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[11];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t KernelPCIABPTrace::registerWithKernel_sync(KernelPCIABPTrace *this)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t **v7;
  pci::transport::kernelTrace *v8;
  uint64_t v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v28;
  unint64_t v29;
  char v30;
  NSObject *v31;
  _BOOL4 v32;
  char v33;
  unsigned int v34;
  char v35;
  NSObject *v36;
  unsigned int v37;
  NSObject *v38;
  NSObject *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  int v45;
  _QWORD *v46;
  unint64_t *v47;
  char *v48;
  size_t v49;
  size_t v50;
  void *v51;
  int v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t **v56;
  uint64_t **v57;
  uint64_t *v58;
  unint64_t v59;
  uint64_t *v60;
  uint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  char BufferQueue_sync;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  __CFRunLoop *RunLoop;
  int v69;
  int v70;
  unsigned int v71;
  uint8_t v72[8];
  std::__shared_weak_count *v73;
  __int128 buf;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "registerWithKernel_sync";
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&buf, 0xCu);
    if (*((_BYTE *)this + 264))
      goto LABEL_5;
  }
  else if (*((_BYTE *)this + 264))
  {
    goto LABEL_5;
  }
  v3 = *((_QWORD *)this + 18);
  if (v3)
  {
    dispatch_group_enter(v3);
    *((_BYTE *)this + 264) = 1;
  }
LABEL_5:
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 28);
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = 0;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v7 = (uint64_t **)((char *)this + 200);
  std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(*((_QWORD **)this + 25));
  *((_QWORD *)this + 24) = (char *)this + 200;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  pci::transport::kernelTrace::create(v8);
  v9 = buf;
  if ((_QWORD)buf)
  {
    v10 = operator new(0x20uLL);
    *v10 = off_1E4A0A7A0;
    v10[1] = 0;
    v10[2] = 0;
    v10[3] = v9;
    *(_QWORD *)&buf = 0;
    v11 = (std::__shared_weak_count *)*((_QWORD *)this + 28);
    *((_QWORD *)this + 27) = v9;
    *((_QWORD *)this + 28) = v10;
    if (v11)
    {
LABEL_12:
      v12 = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      v14 = buf;
      *(_QWORD *)&buf = 0;
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
      if (!*((_QWORD *)this + 27))
        goto LABEL_19;
      goto LABEL_23;
    }
  }
  else
  {
    *(_QWORD *)&buf = 0;
    v11 = (std::__shared_weak_count *)*((_QWORD *)this + 28);
    *((_QWORD *)this + 27) = 0;
    *((_QWORD *)this + 28) = 0;
    if (v11)
      goto LABEL_12;
  }
  if (!v9)
  {
LABEL_19:
    v15 = *((_QWORD *)this + 5);
    v16 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      return v16;
    LOWORD(buf) = 0;
    _os_log_impl(&dword_1A343C000, v15, OS_LOG_TYPE_DEFAULT, "#E ABP Trace object creation failed", (uint8_t *)&buf, 2u);
    return 0;
  }
LABEL_23:
  v17 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  if (!v17)
    return 0;
  v18 = std::__shared_weak_count::lock(v17);
  *((_QWORD *)&buf + 1) = v18;
  if (!v18)
    return 0;
  v19 = v18;
  v20 = *((_QWORD *)this + 16);
  *(_QWORD *)&buf = v20;
  if (!v20)
  {
LABEL_55:
    v16 = 0;
    goto LABEL_60;
  }
  v21 = *((_QWORD *)this + 27);
  v22 = *(std::__shared_weak_count **)(v20 + 128);
  if (v22 && (v23 = std::__shared_weak_count::lock(v22)) != 0)
  {
    v24 = v23;
    v25 = *(_QWORD *)(v20 + 120);
    if (v25)
      v26 = *(_QWORD *)(v25 + 168);
    else
      v26 = 0;
    v28 = (unint64_t *)&v23->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  else
  {
    v26 = 0;
  }
  v30 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v21 + 16))(v21, v26);
  v31 = *((_QWORD *)this + 5);
  v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
  if ((v30 & 1) == 0)
  {
    if (v32)
    {
      *(_WORD *)v72 = 0;
      _os_log_impl(&dword_1A343C000, v31, OS_LOG_TYPE_DEFAULT, "#E Kernel Trace start failed", v72, 2u);
    }
    goto LABEL_55;
  }
  if (v32)
  {
    *(_WORD *)v72 = 0;
    _os_log_impl(&dword_1A343C000, v31, OS_LOG_TYPE_DEFAULT, "#I Started Kernel Trace interface", v72, 2u);
  }
  v71 = 0;
  v33 = (*(uint64_t (**)(_QWORD, unsigned int *))(**((_QWORD **)this + 27) + 112))(*((_QWORD *)this + 27), &v71);
  v34 = v71;
  if (v71)
    v35 = v33;
  else
    v35 = 0;
  if ((v35 & 1) == 0)
  {
    v39 = *((_QWORD *)this + 5);
    v16 = 0;
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      goto LABEL_59;
    *(_WORD *)v72 = 0;
    _os_log_impl(&dword_1A343C000, v39, OS_LOG_TYPE_DEFAULT, "#E Failed to get buffer constraints from kernel", v72, 2u);
LABEL_58:
    v16 = 0;
LABEL_59:
    v19 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
      goto LABEL_60;
    return v16;
  }
  *((_DWORD *)this + 41) = v71;
  v36 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v72 = 67109120;
    *(_DWORD *)&v72[4] = v34 >> 10;
    _os_log_impl(&dword_1A343C000, v36, OS_LOG_TYPE_DEFAULT, "#I Set buffer size to '%d KB'", v72, 8u);
  }
  if (!(*(unsigned int (**)(_QWORD, unsigned int *))(**((_QWORD **)this + 27) + 136))(*((_QWORD *)this + 27), &v71)|| (v37 = v71, v37 < *((_DWORD *)this + 40)* (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 27) + 40))(*((_QWORD *)this + 27))))
  {
    v38 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v72 = 0;
      _os_log_error_impl(&dword_1A343C000, v38, OS_LOG_TYPE_ERROR, "Buffer count exceeded kernel limits", v72, 2u);
    }
    goto LABEL_58;
  }
  v42 = 0;
  v43 = &KernelPCIABPTrace::registerWithKernel_sync(void)::name;
  while (v42 < (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 27) + 40))(*((_QWORD *)this + 27)))
  {
    v70 = -1431655766;
    if (((*(uint64_t (**)(_QWORD, uint64_t, int *, uint64_t *, uint64_t))(**((_QWORD **)this + 27) + 48))(*((_QWORD *)this + 27), v42, &v70, v43, 256) & 1) == 0)goto LABEL_66;
    *((_BYTE *)v43 + 255) = 0;
    if (*v43 == 0x76655F7374617473 && *((_DWORD *)v43 + 2) == 7630437)
      goto LABEL_66;
    v45 = v70;
    v46 = operator new(0x48uLL);
    v46[1] = 0;
    v47 = v46 + 1;
    v46[2] = 0;
    *v46 = off_1E4A0A7F0;
    v48 = (char *)(v46 + 3);
    v49 = strlen((const char *)v43);
    if (v49 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v50 = v49;
    if (v49 >= 0x17)
    {
      v69 = v42;
      v52 = v45;
      v53 = v43;
      v54 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v49 | 7) != 0x17)
        v54 = v49 | 7;
      v55 = v54 + 1;
      v51 = operator new(v54 + 1);
      v46[4] = v50;
      v46[5] = v55 | 0x8000000000000000;
      v46[3] = v51;
      v43 = v53;
      v45 = v52;
      LODWORD(v42) = v69;
LABEL_80:
      memcpy(v51, v43, v50);
      goto LABEL_81;
    }
    *((_BYTE *)v46 + 47) = v49;
    v51 = v46 + 3;
    if (v49)
      goto LABEL_80;
LABEL_81:
    *((_BYTE *)v51 + v50) = 0;
    *((_DWORD *)v46 + 12) = v45;
    v46[7] = 0;
    v46[8] = 0;
    *(_QWORD *)v72 = v46 + 3;
    v73 = (std::__shared_weak_count *)v46;
    v56 = (uint64_t **)((char *)this + 200);
    v57 = (uint64_t **)((char *)this + 200);
    v58 = *v7;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          v57 = (uint64_t **)v58;
          v59 = v58[4];
          if ((unint64_t)v48 >= v59)
            break;
          v58 = *v57;
          v56 = v57;
          if (!*v57)
            goto LABEL_88;
        }
        if (v59 >= (unint64_t)v48)
          break;
        v58 = v57[1];
        if (!v58)
        {
          v56 = v57 + 1;
          goto LABEL_88;
        }
      }
    }
    else
    {
LABEL_88:
      v60 = (uint64_t *)operator new(0x30uLL);
      v61 = v60;
      v60[4] = (uint64_t)v48;
      v60[5] = (uint64_t)v46;
      do
        v62 = __ldxr(v47);
      while (__stxr(v62 + 1, v47));
      *v60 = 0;
      v60[1] = 0;
      v60[2] = (uint64_t)v57;
      *v56 = v60;
      v63 = **((_QWORD **)this + 24);
      if (v63)
      {
        *((_QWORD *)this + 24) = v63;
        v61 = *v56;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 25), v61);
      ++*((_QWORD *)this + 26);
    }
    BufferQueue_sync = KernelPCIABPTrace::allocateBufferQueue_sync((uint64_t)this, (uint64_t *)v72);
    v65 = v73;
    if (v73)
    {
      v66 = (unint64_t *)&v73->__shared_owners_;
      do
        v67 = __ldaxr(v66);
      while (__stlxr(v67 - 1, v66));
      if (!v67)
      {
        ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
        std::__shared_weak_count::__release_weak(v65);
      }
    }
    if ((BufferQueue_sync & 1) == 0)
      goto LABEL_58;
LABEL_66:
    v42 = (v42 + 1);
  }
  RunLoop = (__CFRunLoop *)abm::BasebandTracingTask::getRunLoop((abm::BasebandTracingTask *)buf);
  CFRunLoopWakeUp(RunLoop);
  v16 = 1;
  v19 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (!*((_QWORD *)&buf + 1))
    return v16;
LABEL_60:
  v40 = (unint64_t *)&v19->__shared_owners_;
  do
    v41 = __ldaxr(v40);
  while (__stlxr(v41 - 1, v40));
  if (!v41)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  return v16;
}

void sub_1A34CA75C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  std::__shared_weak_count *v13;
  void *v15;

  std::__shared_weak_count::~__shared_weak_count(v13);
  operator delete(v15);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_1A34CA780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34CA794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A34CA7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34CA7C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34CA7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34CA7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A34CA800(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::flushLogsCompletion(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  NSObject *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  _QWORD *v13;
  unint64_t *p_shared_owners;
  NSObject *v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  int v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v19 = 136315138;
    v20 = "flushLogsCompletion";
    _os_log_debug_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v19, 0xCu);
    v9 = (std::__shared_weak_count *)a1[10];
    if (!v9)
LABEL_12:
      std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  else
  {
    v9 = (std::__shared_weak_count *)a1[10];
    if (!v9)
      goto LABEL_12;
  }
  v10 = a1[9];
  v11 = std::__shared_weak_count::lock(v9);
  if (!v11)
    goto LABEL_12;
  v12 = v11;
  v13 = operator new(0x20uLL);
  *v13 = a1;
  v13[1] = a2;
  *((_DWORD *)v13 + 4) = a4;
  v13[3] = a3;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v15 = a1[11];
  do
    v16 = __ldxr(p_shared_owners);
  while (__stxr(v16 + 1, p_shared_owners));
  v17 = operator new(0x18uLL);
  *v17 = v13;
  v17[1] = v10;
  v17[2] = v12;
  dispatch_async_f(v15, v17, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A34CA990(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::fileSnapshot_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  timespec v5;
  DIR *v6;
  const char *v7;
  DIR *v8;
  dirent *v9;
  NSObject *v10;
  std::__fs::filesystem::path *v11;
  std::error_code *v12;
  std::__fs::filesystem::path *v13;
  stat *p_block;
  int v15;
  int v16;
  NSObject *v17;
  _BOOL4 v18;
  stat *v19;
  const char *v20;
  stat *v21;
  uint64_t v22;
  NSObject *v23;
  timespec v24;
  const char *v25;
  NSObject *v26;
  _OWORD v27[4];
  std::string v28;
  _BYTE *v29;
  _BYTE __p[24];
  void *v31;
  uint64_t v32;
  stat block;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)a2)
    return;
  v4 = *(_QWORD *)(*(_QWORD *)a2 + 32);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  if (*(_BYTE *)(a1 + 153))
  {
    *(_QWORD *)__p = operator new(0x48uLL);
    *(_OWORD *)&__p[8] = xmmword_1A357F810;
    strcpy(*(char **)__p, "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/");
    qmemcpy(v27, "pci-bin.scratch/BasebandManager/brary/Logs/Apple/var/wireless/Li", sizeof(v27));
    v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&block.st_blksize = v5;
    *(timespec *)block.st_qspare = v5;
    block.st_birthtimespec = v5;
    *(timespec *)&block.st_size = v5;
    block.st_mtimespec = v5;
    block.st_ctimespec = v5;
    *(timespec *)&block.st_uid = v5;
    block.st_atimespec = v5;
    *(timespec *)&block.st_dev = v5;
    if (stat(*(const char **)__p, &block))
    {
      LODWORD(v6) = 0;
    }
    else
    {
      if (__p[23] >= 0)
        v7 = __p;
      else
        v7 = *(const char **)__p;
      v8 = opendir(v7);
      v6 = v8;
      if (v8)
      {
        v9 = readdir(v8);
        closedir(v6);
        LODWORD(v6) = v9 != 0;
      }
    }
    if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
      if ((_DWORD)v6)
      {
LABEL_14:
        support::fs::getBasePath((const std::string::value_type **)(a1 + 232), (uint64_t)&block);
        support::fs::createDir((const char *)&block, 0x1EDu, 1);
        if (SHIBYTE(block.st_gid) < 0)
        {
          operator delete(*(void **)&block.st_dev);
          memset(&block, 170, 24);
          if ((*(char *)(a1 + 255) & 0x80000000) == 0)
            goto LABEL_16;
        }
        else
        {
          memset(&block, 170, 24);
          if ((*(char *)(a1 + 255) & 0x80000000) == 0)
          {
LABEL_16:
            v28 = *(std::string *)(a1 + 232);
            goto LABEL_22;
          }
        }
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(a1 + 232), *(_QWORD *)(a1 + 240));
LABEL_22:
        support::fs::createUniquePath((const char *)&v28, (std::string *)&block);
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v28.__r_.__value_.__l.__data_);
        v11 = (std::__fs::filesystem::path *)operator new(0x48uLL);
        v13 = v11;
        *(_OWORD *)&v11->__pn_.__r_.__value_.__l.__data_ = v27[3];
        *(_OWORD *)&v11->__pn_.__r_.__value_.__r.__words[2] = v27[2];
        *(_OWORD *)&v11[1].__pn_.__r_.__value_.__r.__words[1] = v27[1];
        *(_OWORD *)&v11[2].__pn_.__r_.__value_.__l.__data_ = v27[0];
        v11[2].__pn_.__r_.__value_.__s.__data_[16] = 0;
        if ((block.st_gid & 0x80000000) == 0)
          p_block = &block;
        else
          p_block = *(stat **)&block.st_dev;
        rename(v11, (const std::__fs::filesystem::path *)p_block, v12);
        v16 = v15;
        operator delete(v13);
        v17 = *(NSObject **)(a1 + 40);
        v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
        if (v16)
        {
          if (!v18)
            goto LABEL_37;
          v19 = &block;
          if ((block.st_gid & 0x80000000) != 0)
            v19 = *(stat **)&block.st_dev;
          *(_DWORD *)__p = 136315138;
          *(_QWORD *)&__p[4] = v19;
          v20 = "#E Failed to move scratch logs to snapshot path [%s]";
        }
        else
        {
          if (!v18)
            goto LABEL_37;
          v21 = &block;
          if ((block.st_gid & 0x80000000) != 0)
            v21 = *(stat **)&block.st_dev;
          *(_DWORD *)__p = 136315138;
          *(_QWORD *)&__p[4] = v21;
          v20 = "#I Snapshot files are in path [%s]";
        }
        _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, v20, __p, 0xCu);
LABEL_37:
        if (SHIBYTE(block.st_gid) < 0)
          operator delete(*(void **)&block.st_dev);
LABEL_39:
        v22 = *(_QWORD *)(*(_QWORD *)a2 + 32);
        if (v22)
        {
          *(_QWORD *)&__p[8] = 0x40000000;
          *(_QWORD *)&__p[16] = ___ZN21CircularFileLogWriter4openEv_block_invoke;
          v31 = &__block_descriptor_tmp_0;
          v32 = v22;
          v29 = __p;
          *(_QWORD *)__p = MEMORY[0x1E0C809B0];
          *(_QWORD *)&block.st_dev = MEMORY[0x1E0C809B0];
          block.st_ino = 0x40000000;
          *(_QWORD *)&block.st_uid = ___ZNK3ctu20SharedSynchronizableI21CircularFileLogWriterE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
          *(_QWORD *)&block.st_rdev = &__block_descriptor_tmp_16_0;
          block.st_atimespec.tv_sec = v22 + 8;
          block.st_atimespec.tv_nsec = (uint64_t)&v29;
          v23 = *(NSObject **)(v22 + 24);
          if (*(_QWORD *)(v22 + 32))
            dispatch_async_and_wait(v23, &block);
          else
            dispatch_sync(v23, &block);
        }
        goto LABEL_43;
      }
    }
    else if ((_DWORD)v6)
    {
      goto LABEL_14;
    }
    v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      block.st_dev = 136315138;
      *(_QWORD *)&block.st_mode = "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/";
      _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#E Couldn't find scratch path [%s]", (uint8_t *)&block, 0xCu);
    }
    goto LABEL_39;
  }
LABEL_43:
  v24.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v24.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&block.st_blksize = v24;
  *(timespec *)block.st_qspare = v24;
  block.st_birthtimespec = v24;
  *(timespec *)&block.st_size = v24;
  block.st_mtimespec = v24;
  block.st_ctimespec = v24;
  *(timespec *)&block.st_uid = v24;
  block.st_atimespec = v24;
  *(timespec *)&block.st_dev = v24;
  if (byte_1ED114A60[23] >= 0)
    v25 = byte_1ED114A60;
  else
    v25 = *(const char **)byte_1ED114A60;
  if (stat(v25, &block))
    KernelPCIABPTrace::dumpCodeRegistry_sync((KernelPCIABPTrace *)a1);
  if (*(char *)(a1 + 255) < 0)
  {
    **(_BYTE **)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 240) = 0;
    v26 = *(NSObject **)(a1 + 256);
    *(_QWORD *)(a1 + 256) = 0;
    if (!v26)
      return;
  }
  else
  {
    *(_BYTE *)(a1 + 232) = 0;
    *(_BYTE *)(a1 + 255) = 0;
    v26 = *(NSObject **)(a1 + 256);
    *(_QWORD *)(a1 + 256) = 0;
    if (!v26)
      return;
  }
  dispatch_group_leave(v26);
  dispatch_release(v26);
}

void sub_1A34CADC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::readLogsCompletion(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  NSObject *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  _QWORD *v13;
  unint64_t *p_shared_owners;
  NSObject *v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  int v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v19 = 136315138;
    v20 = "readLogsCompletion";
    _os_log_debug_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v19, 0xCu);
    v9 = (std::__shared_weak_count *)a1[10];
    if (!v9)
LABEL_12:
      std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  else
  {
    v9 = (std::__shared_weak_count *)a1[10];
    if (!v9)
      goto LABEL_12;
  }
  v10 = a1[9];
  v11 = std::__shared_weak_count::lock(v9);
  if (!v11)
    goto LABEL_12;
  v12 = v11;
  v13 = operator new(0x20uLL);
  *v13 = a1;
  v13[1] = a2;
  *((_DWORD *)v13 + 4) = a4;
  v13[3] = a3;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v15 = a1[11];
  do
    v16 = __ldxr(p_shared_owners);
  while (__stxr(v16 + 1, p_shared_owners));
  v17 = operator new(0x18uLL);
  *v17 = v13;
  v17[1] = v10;
  v17[2] = v12;
  dispatch_async_f(v15, v17, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A34CAFB0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::allocateBufferQueue_sync(uint64_t a1, uint64_t *a2)
{
  unsigned int v4;
  _QWORD *BuffContext_sync;
  int v6;
  NSObject *v7;
  int v8;
  int v10;
  int v11;
  uint8_t buf[4];
  unsigned int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    if (!*(_DWORD *)(a1 + 160))
      return 1;
    v4 = 0;
    while (1)
    {
      BuffContext_sync = KernelPCIABPTrace::createBuffContext_sync(a1, *(unsigned int *)(a1 + 164), a2);
      v6 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, void (*)(_QWORD *, int, uint64_t), _QWORD *))(**(_QWORD **)(a1 + 216) + 72))(*(_QWORD *)(a1 + 216), *(unsigned int *)(*a2 + 24), *BuffContext_sync, *((unsigned int *)BuffContext_sync + 2), 0, readLogsCompletionCB, BuffContext_sync);
      v7 = *(NSObject **)(a1 + 40);
      if (v6)
        break;
      ++v4;
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_DWORD *)(a1 + 164) >> 10;
        *(_DWORD *)buf = 67109376;
        v13 = v4;
        v14 = 1024;
        v15 = v8;
        _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I Pre-assign buffer # %d of size '%d KB' to fetch logs", buf, 0xEu);
      }
      if (v4 >= *(_DWORD *)(a1 + 160))
        return 1;
    }
    v10 = v6;
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      v11 = *(_DWORD *)(a1 + 164) >> 10;
      *(_DWORD *)buf = 67109632;
      v13 = v4 + 1;
      v14 = 1024;
      v15 = v11;
      v16 = 1024;
      v17 = v10;
      _os_log_error_impl(&dword_1A343C000, v7, OS_LOG_TYPE_ERROR, "Failed pre-assigning buffer # %d of size '%d KB' to fetch logs. Status [0x%x]", buf, 0x14u);
    }
    KernelPCIABPTrace::deleteBuffContext_sync((_QWORD *)a1, (unint64_t)BuffContext_sync);
  }
  return 0;
}

void sub_1A34CB264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::historyAsString@<X0>(uint64_t this@<X0>, char *a2@<X8>)
{
  char *v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  _QWORD *v10;
  size_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  void *__p[2];
  __int128 v23;
  unint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;

  v2 = a2;
  if (!*(_DWORD *)(this + 156))
  {
    a2[23] = 8;
    strcpy(a2, "Infinite");
    return this;
  }
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24 = 0xAAAAAAAAAAAAAAAALL;
  v26 = v3;
  v34 = v3;
  v33 = v3;
  v32 = v3;
  v31 = v3;
  v30 = v3;
  v29 = v3;
  v28 = v3;
  v27 = v3;
  *(_OWORD *)__p = v3;
  v23 = v3;
  v20 = v3;
  v21 = v3;
  v18 = v3;
  v19 = v3;
  v4 = MEMORY[0x1E0DE4FE0];
  v5 = MEMORY[0x1E0DE4FE0] + 64;
  v25 = MEMORY[0x1E0DE4FE0] + 64;
  v6 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v17 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  *(uint64_t *)((char *)&v17 + *(_QWORD *)(v17 - 24)) = v7;
  v8 = (std::ios_base *)((char *)&v17 + *(_QWORD *)(v17 - 24));
  std::ios_base::init(v8, &v18);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v17 = v4 + 24;
  v25 = v5;
  std::streambuf::basic_streambuf();
  v9 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v18 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v23 = 0u;
  LODWORD(v24) = 16;
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" MB", 3);
  if ((v24 & 0x10) != 0)
  {
    v12 = *((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1) < (unint64_t)v21)
    {
      *((_QWORD *)&v23 + 1) = v21;
      v12 = v21;
    }
    v13 = (const void *)*((_QWORD *)&v20 + 1);
    v11 = v12 - *((_QWORD *)&v20 + 1);
    if ((unint64_t)(v12 - *((_QWORD *)&v20 + 1)) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_20;
  }
  else
  {
    if ((v24 & 8) == 0)
    {
      v11 = 0;
      v2[23] = 0;
      goto LABEL_16;
    }
    v13 = (const void *)v19;
    v11 = v20 - v19;
    if ((_QWORD)v20 - (_QWORD)v19 >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_20:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v11 >= 0x17)
  {
    v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v14 = v11 | 7;
    v15 = v14 + 1;
    v16 = (char *)operator new(v14 + 1);
    *((_QWORD *)v2 + 1) = v11;
    *((_QWORD *)v2 + 2) = v15 | 0x8000000000000000;
    *(_QWORD *)v2 = v16;
    v2 = v16;
  }
  else
  {
    v2[23] = v11;
    if (!v11)
      goto LABEL_16;
  }
  memmove(v2, v13, v11);
LABEL_16:
  v2[v11] = 0;
  v17 = *v6;
  *(uint64_t *)((char *)&v17 + *(_QWORD *)(v17 - 24)) = v6[3];
  *(_QWORD *)&v18 = v9 + 16;
  if (SBYTE7(v23) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A858F92C](&v25);
}

void sub_1A34CB4E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1A858F92C](v1);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::shutdown(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[10];
  if (!v4 || (v5 = a1[9], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(0x10uLL);
  *v8 = a1;
  v8[1] = v3;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[11];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void KernelPCIABPTrace::snapshot(_QWORD *a1, dispatch_object_t *a2, const void **a3)
{
  NSObject *v5;
  NSObject *v7;
  const void *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  _QWORD *v13;
  unint64_t *p_shared_owners;
  NSObject *v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;

  v5 = *a2;
  if (!*a2)
  {
    v7 = 0;
    v8 = *a3;
    if (!*a3)
      goto LABEL_8;
LABEL_7:
    CFRetain(v8);
    goto LABEL_8;
  }
  dispatch_retain(*a2);
  dispatch_group_enter(v5);
  v7 = *a2;
  if (v7)
    dispatch_retain(v7);
  v8 = *a3;
  if (*a3)
    goto LABEL_7;
LABEL_8:
  v9 = (std::__shared_weak_count *)a1[10];
  if (!v9 || (v10 = a1[9], (v11 = std::__shared_weak_count::lock(v9)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v12 = v11;
  v13 = operator new(0x20uLL);
  *v13 = a1;
  v13[1] = v5;
  v13[2] = v7;
  v13[3] = v8;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v15 = a1[11];
  do
    v16 = __ldxr(p_shared_owners);
  while (__stxr(v16 + 1, p_shared_owners));
  v17 = operator new(0x18uLL);
  *v17 = v13;
  v17[1] = v10;
  v17[2] = v12;
  dispatch_async_f(v15, v17, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A34CB824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::dumpState(NSObject *a1, NSObject **a2, uint64_t a3)
{
  NSObject *v5;
  std::__shared_weak_count *isa;
  Class v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  char *v10;
  std::string *v11;
  NSObject *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  dispatch_group_t group[2];
  std::string __p;

  v5 = *a2;
  group[0] = a1;
  group[1] = *a2;
  if (*a2)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    __p = *(std::string *)a3;
  isa = (std::__shared_weak_count *)a1[10].isa;
  if (!isa || (v7 = a1[9].isa, (v8 = std::__shared_weak_count::lock(isa)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = (char *)operator new(0x28uLL);
  *(_OWORD *)v10 = *(_OWORD *)group;
  v11 = (std::string *)(v10 + 16);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v11, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *((_QWORD *)v10 + 4) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
  }
  v12 = a1[11].isa;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  v15 = operator new(0x18uLL);
  *v15 = v10;
  v15[1] = v7;
  v15[2] = v9;
  dispatch_async_f(v12, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>(KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (v16)
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_19:
    operator delete(__p.__r_.__value_.__l.__data_);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_19;
}

void sub_1A34CB9D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  uint64_t v10;
  NSObject *v12;
  NSObject *v13;

  v12 = *(NSObject **)(v10 + 8);
  if (v12)
  {
    dispatch_group_leave(v12);
    v13 = *(NSObject **)(v10 + 8);
    if (v13)
    {
      dispatch_release(v13);
      __clang_call_terminate(a1);
    }
  }
  __clang_call_terminate(a1);
}

uint64_t KernelPCIABPTrace::dumpState_sync@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, _BYTE *a5@<X8>)
{
  unsigned __int8 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  std::ios_base *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  void **v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  int v30;
  _QWORD *v31;
  _QWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  uint64_t v37;
  const void *v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE *v41;
  void *__p[2];
  unsigned __int8 v44;
  uint64_t v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  void *v50[2];
  __int128 v51;
  unint64_t v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _BYTE v63[9];

  v10 = atomic_load((unsigned __int8 *)&qword_1ED114A58);
  if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1ED114A58))
  {
    std::string::basic_string[abi:ne180100]<0>(&qword_1ED114A78, "\n----- KernelPCI Trace Dump State -----\n");
    __cxa_atexit(MEMORY[0x1E0DE44D0], &qword_1ED114A78, &dword_1A343C000);
    __cxa_guard_release(&qword_1ED114A58);
  }
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v52 = 0xAAAAAAAAAAAAAAAALL;
  v62 = v11;
  v61 = v11;
  v60 = v11;
  v59 = v11;
  v58 = v11;
  v57 = v11;
  v56 = v11;
  v55 = v11;
  v54 = v11;
  *(_OWORD *)v50 = v11;
  v51 = v11;
  v48 = v11;
  v49 = v11;
  v46 = v11;
  v47 = v11;
  v12 = MEMORY[0x1E0DE4FE0];
  v13 = MEMORY[0x1E0DE4FE0] + 64;
  v53 = MEMORY[0x1E0DE4FE0] + 64;
  v14 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v15 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v45 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  *(uint64_t *)((char *)&v45 + *(_QWORD *)(v45 - 24)) = v15;
  v16 = (std::ios_base *)((char *)&v45 + *(_QWORD *)(v45 - 24));
  std::ios_base::init(v16, &v46);
  v16[1].__vftable = 0;
  v16[1].__fmtflags_ = -1;
  v45 = v12 + 24;
  v53 = v13;
  std::streambuf::basic_streambuf();
  v17 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v46 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)v50 = 0u;
  v51 = 0u;
  LODWORD(v52) = 16;
  if (a3)
  {
    if (byte_1ED114A8F >= 0)
      v18 = &qword_1ED114A78;
    else
      v18 = (uint64_t *)qword_1ED114A78;
    if (byte_1ED114A8F >= 0)
      v19 = byte_1ED114A8F;
    else
      v19 = unk_1ED114A80;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v45, (uint64_t)v18, v19);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v45, (uint64_t)"Enabled: ", 9);
  v20 = (_QWORD *)std::ostream::operator<<();
  LOBYTE(__p[0]) = a4;
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)__p, 1);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"History: ", 9);
  KernelPCIABPTrace::historyAsString(a1, (char *)__p);
  if ((v44 & 0x80u) == 0)
    v23 = __p;
  else
    v23 = (void **)__p[0];
  if ((v44 & 0x80u) == 0)
    v24 = v44;
  else
    v24 = (uint64_t)__p[1];
  v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v23, v24);
  v63[0] = a4;
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)v63, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"Buffer size: ", 13);
  v27 = (_QWORD *)std::ostream::operator<<();
  v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)" bytes", 6);
  v63[0] = a4;
  v29 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)v63, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)"Buffer count: ", 14);
  std::ostream::operator<<();
  if ((char)v44 < 0)
  {
    operator delete(__p[0]);
    v30 = *(char *)(a2 + 23);
    if ((v30 & 0x80000000) == 0)
    {
LABEL_18:
      if (!(_BYTE)v30)
        goto LABEL_29;
      goto LABEL_22;
    }
  }
  else
  {
    v30 = *(char *)(a2 + 23);
    if ((v30 & 0x80000000) == 0)
      goto LABEL_18;
  }
  if (!*(_QWORD *)(a2 + 8))
    goto LABEL_29;
LABEL_22:
  LOBYTE(__p[0]) = a4;
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v45, (uint64_t)__p, 1);
  v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"Reason: ", 8);
  v33 = *(char *)(a2 + 23);
  if (v33 >= 0)
    v34 = a2;
  else
    v34 = *(_QWORD *)a2;
  if (v33 >= 0)
    v35 = *(unsigned __int8 *)(a2 + 23);
  else
    v35 = *(_QWORD *)(a2 + 8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, v34, v35);
LABEL_29:
  if (a3)
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v45, (uint64_t)"\n--------------------------------------\n", 40);
  if ((v52 & 0x10) != 0)
  {
    v37 = *((_QWORD *)&v51 + 1);
    if (*((_QWORD *)&v51 + 1) < (unint64_t)v49)
    {
      *((_QWORD *)&v51 + 1) = v49;
      v37 = v49;
    }
    v38 = (const void *)*((_QWORD *)&v48 + 1);
    v36 = v37 - *((_QWORD *)&v48 + 1);
    if ((unint64_t)(v37 - *((_QWORD *)&v48 + 1)) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_48;
  }
  else
  {
    if ((v52 & 8) == 0)
    {
      v36 = 0;
      a5[23] = 0;
      goto LABEL_44;
    }
    v38 = (const void *)v47;
    v36 = v48 - v47;
    if ((_QWORD)v48 - (_QWORD)v47 >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_48:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17)
      v39 = v36 | 7;
    v40 = v39 + 1;
    v41 = operator new(v39 + 1);
    *((_QWORD *)a5 + 1) = v36;
    *((_QWORD *)a5 + 2) = v40 | 0x8000000000000000;
    *(_QWORD *)a5 = v41;
    a5 = v41;
    goto LABEL_43;
  }
  a5[23] = v36;
  if (v36)
LABEL_43:
    memmove(a5, v38, v36);
LABEL_44:
  a5[v36] = 0;
  v45 = *v14;
  *(uint64_t *)((char *)&v45 + *(_QWORD *)(v45 - 24)) = v14[3];
  *(_QWORD *)&v46 = v17 + 16;
  if (SBYTE7(v51) < 0)
    operator delete(v50[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A858F92C](&v53);
}

void sub_1A34CBE40(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED114A58);
  _Unwind_Resume(a1);
}

void sub_1A34CBE58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  std::ostringstream::~ostringstream((uint64_t)&a17);
  _Unwind_Resume(a1);
}

BOOL KernelPCIABPTrace::setProperty(uint64_t a1, NSObject **a2, uint64_t a3, uint64_t a4)
{
  char isSupported;
  char v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v14;
  dispatch_group_t group;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  void *__p[2];
  char v20;
  char v21;
  _QWORD block[6];

  v21 = 0;
  v20 = 9;
  strcpy((char *)__p, "KernelPCI");
  isSupported = abm::trace::isSupported((uint64_t)__p);
  v9 = isSupported;
  if ((v20 & 0x80000000) == 0)
  {
    if ((isSupported & 1) != 0)
      goto LABEL_3;
    return 0;
  }
  operator delete(__p[0]);
  if ((v9 & 1) == 0)
    return 0;
LABEL_3:
  v10 = *a2;
  v14 = a1;
  group = v10;
  if (v10)
  {
    dispatch_retain(v10);
    dispatch_group_enter(v10);
  }
  v16 = a3;
  v17 = a4;
  v18 = &v21;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke;
  block[3] = &__block_descriptor_tmp_52_0;
  block[4] = a1 + 72;
  block[5] = &v14;
  v11 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(a1 + 96))
  {
    dispatch_async_and_wait(v11, block);
    v12 = group;
    if (!group)
      return v21 != 0;
LABEL_11:
    dispatch_group_leave(v12);
    if (group)
      dispatch_release(group);
    return v21 != 0;
  }
  dispatch_sync(v11, block);
  v12 = group;
  if (group)
    goto LABEL_11;
  return v21 != 0;
}

void sub_1A34CC014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t KernelPCIABPTrace::setProperty_sync(uint64_t a1, NSObject **a2, char *a3, char *a4)
{
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  NSObject *v17;
  NSObject *v18;
  _QWORD *v19;
  std::string::size_type v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  BOOL v31;
  std::string::size_type v32;
  std::string::size_type v33;
  std::string::size_type v34;
  int v35;
  dispatch_object_t object;
  std::string v37;
  void *v38[2];
  char v39;
  std::string v40;
  std::string __p;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setProperty_sync";
    _os_log_debug_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&__p, 0xCu);
  }
  if ((prop::ipc::set(a3, a4) & 1) != 0)
  {
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&__p, "Enabled");
    if (a3[23] >= 0)
      v9 = a3;
    else
      v9 = *(const char **)a3;
    if (strcasecmp(v9, (const char *)&__p))
    {
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&__p, "History");
      if (strcasecmp(v9, (const char *)&__p))
      {
        *((_BYTE *)&__p.__r_.__value_.__s + 23) = 11;
        strcpy((char *)&__p, "BufferCount");
        if (strcasecmp(v9, (const char *)&__p))
        {
          v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            if (a4[23] >= 0)
              v34 = (std::string::size_type)a4;
            else
              v34 = *(_QWORD *)a4;
            LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
            WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v34;
            _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Unrecognized Set property request. Key=%s, Value=%s", (uint8_t *)&__p, 0x16u);
          }
          return 1;
        }
        memset(&v37, 0, sizeof(v37));
        v39 = 3;
        LOWORD(v38[0]) = *(_WORD *)"IPC";
        WORD1(v38[0]) = str_41[2];
        memset(&__p, 0, sizeof(__p));
        v16 = defaults::get((char *)v38, a3, &__p);
        if (v16)
        {
          prop::file::get<std::string>((const void **)v38, (uint64_t)a3, (uint64_t)&__p, &v40);
          v37 = v40;
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if ((v39 & 0x80000000) == 0)
          {
LABEL_33:
            if (v16)
              goto LABEL_34;
            goto LABEL_82;
          }
        }
        else if ((v39 & 0x80000000) == 0)
        {
          goto LABEL_33;
        }
        operator delete(v38[0]);
        if (v16)
        {
LABEL_34:
          v11 = util::convert<unsigned int>(&v37, (_DWORD *)(a1 + 160), 0);
          if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            return v11;
LABEL_83:
          operator delete(v37.__r_.__value_.__l.__data_);
          return v11;
        }
LABEL_82:
        v11 = 0;
        if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          return v11;
        goto LABEL_83;
      }
      v35 = -1431655766;
      memset(&v37, 0, sizeof(v37));
      v39 = 3;
      LOWORD(v38[0]) = *(_WORD *)"IPC";
      WORD1(v38[0]) = str_41[2];
      memset(&__p, 0, sizeof(__p));
      v15 = defaults::get((char *)v38, a3, &__p);
      if (v15)
      {
        prop::file::get<std::string>((const void **)v38, (uint64_t)a3, (uint64_t)&__p, &v40);
        v37 = v40;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((v39 & 0x80000000) == 0)
        {
LABEL_26:
          if (v15)
            goto LABEL_27;
          goto LABEL_50;
        }
      }
      else if ((v39 & 0x80000000) == 0)
      {
        goto LABEL_26;
      }
      operator delete(v38[0]);
      if (v15)
      {
LABEL_27:
        v11 = util::convert<int>(&v37, &v35, 0);
        if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_52;
LABEL_51:
        operator delete(v37.__r_.__value_.__l.__data_);
LABEL_52:
        if (!(_DWORD)v11)
          return v11;
        if (*(_DWORD *)(a1 + 156) == v35)
          return v11;
        *(_DWORD *)(a1 + 156) = v35;
        v19 = *(_QWORD **)(a1 + 192);
        if (v19 == (_QWORD *)(a1 + 200))
          return v11;
        v20 = MEMORY[0x1E0C809B0];
        while (1)
        {
          v21 = v19[4];
          v22 = (std::__shared_weak_count *)v19[5];
          if (v22)
          {
            p_shared_owners = (unint64_t *)&v22->__shared_owners_;
            do
              v24 = __ldxr(p_shared_owners);
            while (__stxr(v24 + 1, p_shared_owners));
          }
          v25 = *(_QWORD *)(v21 + 32);
          if (v25)
          {
            v26 = (uint64_t)*(int *)(a1 + 156) << 20;
            __p.__r_.__value_.__r.__words[0] = v20;
            __p.__r_.__value_.__l.__size_ = 0x40000000;
            __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN21CircularFileLogWriter11setCapacityEm_block_invoke;
            v42 = &__block_descriptor_tmp_8_0;
            v43 = v25;
            v44 = v26;
            ctu::SharedSynchronizable<CircularFileLogWriter>::execute_wrapped((uint64_t *)(v25 + 8), (uint64_t)&__p);
          }
          if (!v22)
            goto LABEL_66;
          v27 = (unint64_t *)&v22->__shared_owners_;
          do
            v28 = __ldaxr(v27);
          while (__stlxr(v28 - 1, v27));
          if (!v28)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
            v29 = (_QWORD *)v19[1];
            if (!v29)
            {
              do
              {
LABEL_70:
                v30 = (_QWORD *)v19[2];
                v31 = *v30 == (_QWORD)v19;
                v19 = v30;
              }
              while (!v31);
              goto LABEL_56;
            }
          }
          else
          {
LABEL_66:
            v29 = (_QWORD *)v19[1];
            if (!v29)
              goto LABEL_70;
          }
          do
          {
            v30 = v29;
            v29 = (_QWORD *)*v29;
          }
          while (v29);
LABEL_56:
          v19 = v30;
          if (v30 == (_QWORD *)(a1 + 200))
            return v11;
        }
      }
LABEL_50:
      v11 = 0;
      if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_52;
      goto LABEL_51;
    }
    LOBYTE(v35) = -86;
    memset(&v37, 0, sizeof(v37));
    v39 = 3;
    LOWORD(v38[0]) = *(_WORD *)"IPC";
    WORD1(v38[0]) = str_41[2];
    memset(&__p, 0, sizeof(__p));
    v14 = defaults::get((char *)v38, a3, &__p);
    if (v14)
    {
      prop::file::get<std::string>((const void **)v38, (uint64_t)a3, (uint64_t)&__p, &v40);
      v37 = v40;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v39 & 0x80000000) == 0)
      {
LABEL_19:
        if (v14)
          goto LABEL_20;
        goto LABEL_38;
      }
    }
    else if ((v39 & 0x80000000) == 0)
    {
      goto LABEL_19;
    }
    operator delete(v38[0]);
    if (v14)
    {
LABEL_20:
      v11 = util::convert<BOOL>(&v37, (BOOL *)&v35, 0);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_39;
      goto LABEL_40;
    }
LABEL_38:
    v11 = 0;
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
      operator delete(v37.__r_.__value_.__l.__data_);
LABEL_40:
    if (!(_DWORD)v11 || v35 == *(unsigned __int8 *)(a1 + 152))
      return v11;
    *(_BYTE *)(a1 + 152) = v35;
    v17 = *a2;
    object = v17;
    if (v17)
    {
      dispatch_retain(v17);
      dispatch_group_enter(v17);
    }
    v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateTraceState_sync";
      _os_log_debug_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&__p, 0xCu);
      if (*(_BYTE *)(a1 + 152))
      {
LABEL_46:
        if (!*(_BYTE *)(a1 + 153))
          KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)a1);
        goto LABEL_90;
      }
    }
    else if (*(_BYTE *)(a1 + 152))
    {
      goto LABEL_46;
    }
    KernelPCIABPTrace::stopTrace(a1, (uint64_t)&object);
    v17 = object;
LABEL_90:
    if (v17)
    {
      dispatch_group_leave(v17);
      if (object)
        dispatch_release(object);
    }
    return v11;
  }
  v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    if (a3[23] >= 0)
      v32 = (std::string::size_type)a3;
    else
      v32 = *(_QWORD *)a3;
    if (a4[23] >= 0)
      v33 = (std::string::size_type)a4;
    else
      v33 = *(_QWORD *)a4;
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v32;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v33;
    _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "Set property to file failed; key=%s value=%s",
      (uint8_t *)&__p,
      0x16u);
  }
  return 0;
}

void sub_1A34CC72C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t KernelPCIABPTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v6[4];
  unsigned __int8 v7;
  _QWORD block[6];

  v7 = 0;
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = &v7;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke;
  block[3] = &__block_descriptor_tmp_54_1;
  block[4] = a1 + 72;
  block[5] = v6;
  v4 = a1 + 88;
  v3 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(v4 + 8))
    dispatch_async_and_wait(v3, block);
  else
    dispatch_sync(v3, block);
  return v7;
}

uint64_t KernelPCIABPTrace::getProperty_sync(uint64_t a1, char *a2, uint64_t a3)
{
  NSObject *v6;
  const char *v7;
  _BOOL8 v8;
  void **v9;
  size_t v10;
  void *v12;
  char v13;
  void *__p[2];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = "getProperty_sync";
    _os_log_debug_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)__p, 0xCu);
  }
  HIBYTE(v15) = 5;
  LODWORD(__p[0]) = *(_DWORD *)"State";
  WORD2(__p[0]) = str_22_0[4];
  if (a2[23] >= 0)
    v7 = a2;
  else
    v7 = *(const char **)a2;
  if (!strcasecmp(v7, (const char *)__p))
  {
    v13 = 0;
    LOBYTE(v12) = 0;
    KernelPCIABPTrace::dumpState_sync(a1, (uint64_t)&v12, 0, 10, __p);
    if (__p != (void **)a3)
    {
      if (*(char *)(a3 + 23) < 0)
      {
        if (v15 >= 0)
          v9 = __p;
        else
          v9 = (void **)__p[0];
        if (v15 >= 0)
          v10 = HIBYTE(v15);
        else
          v10 = (size_t)__p[1];
        std::string::__assign_no_alias<false>((void **)a3, v9, v10);
      }
      else if (v15 < 0)
      {
        std::string::__assign_no_alias<true>((_QWORD *)a3, __p[0], (size_t)__p[1]);
      }
      else
      {
        *(_OWORD *)a3 = *(_OWORD *)__p;
        *(_QWORD *)(a3 + 16) = v15;
      }
    }
    if (SHIBYTE(v15) < 0)
    {
      operator delete(__p[0]);
      if ((v13 & 0x80000000) == 0)
        return 1;
    }
    else if ((v13 & 0x80000000) == 0)
    {
      return 1;
    }
    operator delete(v12);
    return 1;
  }
  HIBYTE(v15) = 3;
  LOWORD(__p[0]) = *(_WORD *)"IPC";
  WORD1(__p[0]) = str_41[2];
  v8 = prop::get_from_file((char *)__p, a2, a3);
  if (SHIBYTE(v15) < 0)
    operator delete(__p[0]);
  return v8;
}

void sub_1A34CCA3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::getSettingPrefix(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 8) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)(a1 + 16) = 0xAAAAAAAAAAAAAAAALL;
  *(_BYTE *)(a1 + 23) = 11;
  strcpy((char *)a1, "KernelPCI::");
}

void std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (a1)
  {
    std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(*a1);
    std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(a1[1]);
    v2 = (std::__shared_weak_count *)a1[5];
    if (!v2)
      goto LABEL_6;
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      operator delete(a1);
    }
    else
    {
LABEL_6:
      operator delete(a1);
    }
  }
}

_QWORD *std::shared_ptr<KernelPCIABPTrace>::shared_ptr[abi:ne180100]<KernelPCIABPTrace,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1},void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A730;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2)
    return a1;
  v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      return a1;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A34CCC58(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1}::operator() const(KernelPCIABPTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A34CCC78(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<KernelPCIABPTrace *,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace *)#1},std::allocator<KernelPCIABPTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<KernelPCIABPTrace *,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace *)#1},std::allocator<KernelPCIABPTrace>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1}::operator() const(KernelPCIABPTrace*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<KernelPCIABPTrace *,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace *)#1},std::allocator<KernelPCIABPTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shar"
                                "ed_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1}::operator() const(KernelPCIABPTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  dispatch_group_t group;
  uint8_t buf[4];
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = **(_QWORD **)(a1 + 40);
  KernelPCIABPTrace::initProperty_sync((KernelPCIABPTrace *)v1);
  group = 0;
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315138;
    v5 = "updateTraceState_sync";
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
    if (*(_BYTE *)(v1 + 152))
    {
LABEL_3:
      if (!*(_BYTE *)(v1 + 153))
        KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)v1);
      return;
    }
  }
  else if (*(_BYTE *)(v1 + 152))
  {
    goto LABEL_3;
  }
  KernelPCIABPTrace::stopTrace(v1, (uint64_t)&group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
}

void sub_1A34CCE34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>(KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke(xpc_object_t **a1)
{
  xpc_object_t *v2;
  xpc_object_t v3;
  xpc_object_t v4;
  BOOL v5;
  NSObject *v6;
  const char *v7;
  char *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::string __p;
  xpc_object_t object;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v4 = **a1;
  v3 = (*a1)[1];
  object = v3;
  if (v3)
  {
    xpc_retain(v3);
    if ((byte_1ED114A60[23] & 0x80000000) == 0)
    {
LABEL_3:
      __p = *(std::string *)byte_1ED114A60;
      goto LABEL_6;
    }
  }
  else
  {
    object = xpc_null_create();
    if ((byte_1ED114A60[23] & 0x80000000) == 0)
      goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)byte_1ED114A60, *(std::string::size_type *)&byte_1ED114A60[8]);
LABEL_6:
  v5 = util::writeJSON((ctu **)&object, (uint64_t *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  xpc_release(object);
  object = 0;
  v6 = *((_QWORD *)v4 + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (MEMORY[0x1A85902BC](v2[1]) == MEMORY[0x1E0C812F8] && v5)
      v7 = "Succeeded";
    else
      v7 = "Failed";
    if (byte_1ED114A60[23] >= 0)
      v8 = byte_1ED114A60;
    else
      v8 = *(char **)byte_1ED114A60;
    *(_DWORD *)buf = 136315394;
    v15 = v7;
    v16 = 2080;
    v17 = v8;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I %s to dump CodeRegistry: %s", buf, 0x16u);
  }
  xpc_release(v2[1]);
  operator delete(v2);
  v9 = (std::__shared_weak_count *)a1[2];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  operator delete(a1);
}

void sub_1A34CD02C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t object)
{
  _QWORD *v15;
  xpc_object_t *v16;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;

  xpc_release(object);
  xpc_release(v16[1]);
  operator delete(v16);
  v18 = (std::__shared_weak_count *)v15[2];
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_1A34CD0C0(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t *v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  dispatch_object_t object;
  uint8_t buf[4];
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t **)a1;
  v4 = **(_QWORD **)a1;
  v3 = *(NSObject **)(*(_QWORD *)a1 + 8);
  object = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  v5 = *(NSObject **)(v4 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    if (*(_BYTE *)(v4 + 152))
      goto LABEL_5;
LABEL_8:
    KernelPCIABPTrace::stopTrace(v4, (uint64_t)&object);
    v3 = object;
    goto LABEL_9;
  }
  *(_DWORD *)buf = 136315138;
  v13 = "updateTraceState_sync";
  _os_log_debug_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  if (!*(_BYTE *)(v4 + 152))
    goto LABEL_8;
LABEL_5:
  if (!*(_BYTE *)(v4 + 153))
    KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)v4);
LABEL_9:
  if (v3)
  {
    dispatch_group_leave(v3);
    if (object)
      dispatch_release(object);
  }
  v6 = v2[1];
  if (v6)
  {
    dispatch_group_leave(v6);
    v7 = v2[1];
    if (v7)
      dispatch_release(v7);
  }
  operator delete(v2);
  v8 = (std::__shared_weak_count *)*((_QWORD *)a1 + 2);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  operator delete(a1);
}

void sub_1A34CD254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  _QWORD *v10;
  _QWORD *v11;
  NSObject *v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;

  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  v13 = v11[1];
  if (v13)
  {
    dispatch_group_leave(v13);
    v14 = v11[1];
    if (v14)
      dispatch_release(v14);
  }
  operator delete(v11);
  v15 = (std::__shared_weak_count *)v10[2];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  unint64_t *v5;
  _QWORD *v6;
  int v7;
  NSObject *v8;
  _BOOL4 v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t **)a1;
  v3 = **(_QWORD **)a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(_BYTE *)(v3 + 152))
  {
    v5 = (unint64_t *)(v2 + 1);
    v6 = (_QWORD *)v2[1];
    if (*v6)
    {
      v7 = *((_DWORD *)v2 + 4);
      v8 = *(NSObject **)(v3 + 40);
      v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (v7)
      {
        if (v9)
        {
          v18 = 67109120;
          LODWORD(v19) = v7;
          _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#E Flush logs completion returned error. Error [0x%x]", (uint8_t *)&v18, 8u);
        }
      }
      else
      {
        if (v9)
        {
          v13 = v2[3];
          v18 = 134217984;
          v19 = v13;
          _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I Flush logs completion of size '%ld' bytes", (uint8_t *)&v18, 0xCu);
          v6 = (_QWORD *)v2[1];
        }
        v14 = *(_QWORD *)(v6[4] + 32);
        if (v14)
          (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v14 + 72))(v14, *v6, v2[3]);
      }
    }
    else
    {
      v12 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v18) = 0;
        _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Snapshot received (flush completion with null-log)", (uint8_t *)&v18, 2u);
        v6 = (_QWORD *)*v5;
      }
      KernelPCIABPTrace::fileSnapshot_sync(v3, (uint64_t)(v6 + 4));
    }
  }
  else
  {
    v10 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Flush logs completion for Disabled case", (uint8_t *)&v18, 2u);
    }
    v11 = *(NSObject **)(v3 + 256);
    *(_QWORD *)(v3 + 256) = 0;
    if (v11)
    {
      dispatch_group_leave(v11);
      dispatch_release(v11);
    }
    v5 = (unint64_t *)(v2 + 1);
  }
  KernelPCIABPTrace::deleteBuffContext_sync((_QWORD *)v3, *v5);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  operator delete(v2);
  v15 = (std::__shared_weak_count *)*((_QWORD *)a1 + 2);
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(a1);
}

void sub_1A34CD544(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  NSObject *v3;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  operator delete(v2);
  v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  unint64_t v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD *v12;
  NSObject *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = **a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (!*(_BYTE *)(v3 + 152))
  {
    v11 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I Read log completion for Disabled case", (uint8_t *)&v20, 2u);
    }
    goto LABEL_14;
  }
  v5 = *((_DWORD *)v2 + 4);
  if (v5 || (v12 = (_QWORD *)v2[1], !*v12))
  {
    v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v20 = 67109120;
      LODWORD(v21) = v5;
      _os_log_error_impl(&dword_1A343C000, v6, OS_LOG_TYPE_ERROR, "Read logs completion has some failure. Error [0x%x]", (uint8_t *)&v20, 8u);
    }
  }
  else
  {
    v13 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v14 = *(_QWORD *)(v12[4] + 32);
      if (!v14)
        goto LABEL_7;
      goto LABEL_18;
    }
    v18 = v2[3];
    v20 = 134217984;
    v21 = v18;
    _os_log_debug_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEBUG, "#D Read logs completion of size '%ld' bytes", (uint8_t *)&v20, 0xCu);
    v12 = (_QWORD *)v2[1];
    v14 = *(_QWORD *)(v12[4] + 32);
    if (v14)
LABEL_18:
      (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v14 + 72))(v14, *v12, v2[3]);
  }
LABEL_7:
  v7 = v2[1];
  if (!*(_BYTE *)(v3 + 153))
  {
LABEL_14:
    KernelPCIABPTrace::deleteBuffContext_sync((_QWORD *)v3, v2[1]);
    goto LABEL_21;
  }
  v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t (*)(void *, int, void *), uint64_t))(**(_QWORD **)(v3 + 216) + 72))(*(_QWORD *)(v3 + 216), *(unsigned int *)(*(_QWORD *)(v7 + 32) + 24), *(_QWORD *)v7, *(unsigned int *)(v7 + 8), 0, readLogsCompletionCB, v2[1]);
  v9 = *(NSObject **)(v3 + 40);
  if (v8)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_QWORD *)(v7 + 8) >> 10;
      v20 = 134218240;
      v21 = v10;
      v22 = 1024;
      v23 = v8;
      _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#E Failed re-assigning new buffer of size '%ld KB' to fetch logs. Error [0x%x]", (uint8_t *)&v20, 0x12u);
    }
    KernelPCIABPTrace::deleteBuffContext_sync((_QWORD *)v3, v7);
  }
  else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    v19 = *(_QWORD *)(v7 + 8) >> 10;
    v20 = 134217984;
    v21 = v19;
    _os_log_debug_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEBUG, "#D Assign new buffer of size '%ld KB' to fetch logs", (uint8_t *)&v20, 0xCu);
    if (!v4)
      goto LABEL_23;
    goto LABEL_22;
  }
LABEL_21:
  if (v4)
  {
LABEL_22:
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
LABEL_23:
  operator delete(v2);
  v15 = (std::__shared_weak_count *)a1[2];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(a1);
}

void sub_1A34CD8D8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  NSObject *v3;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  operator delete(v2);
  v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<pci::transport::kernelTrace  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<pci::transport::kernelTrace  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<pci::transport::kernelTrace  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001A35819D3)
    return a1 + 24;
  if (((v3 & 0x80000001A35819D3 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A35819D3))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A35819D3 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

void std::__shared_ptr_emplace<KernelPCIABPTrace::PipeContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A7F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KernelPCIABPTrace::PipeContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0A7F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<KernelPCIABPTrace::PipeContext>::__on_zero_shared(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (v4)
  {
LABEL_5:
    if ((*(char *)(a1 + 47) & 0x80000000) == 0)
      return;
LABEL_8:
    operator delete(*(void **)(a1 + 24));
    return;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if (*(char *)(a1 + 47) < 0)
    goto LABEL_8;
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v2 = *a1;
  v3 = **a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(_BYTE *)(v3 + 152))
    KernelPCIABPTrace::deregisterWithKernel_sync((KernelPCIABPTrace *)v3);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  v5 = v2[1];
  if (v5)
  {
    dispatch_group_leave(v5);
    v6 = v2[1];
    if (v6)
      dispatch_release(v6);
  }
  operator delete(v2);
  v7 = (std::__shared_weak_count *)a1[2];
  if (!v7)
    goto LABEL_14;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    operator delete(a1);
  }
  else
  {
LABEL_14:
    operator delete(a1);
  }
}

void sub_1A34CDB78(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  v4 = v3;
  if (v4)
  {
    v6 = v4;
    dispatch_group_leave(v4);
    dispatch_release(v6);
  }
  v7 = v2[1];
  if (v7)
  {
    dispatch_group_leave(v7);
    v8 = v2[1];
    if (v8)
      dispatch_release(v8);
  }
  operator delete(v2);
  v9 = (std::__shared_weak_count *)v1[2];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  void *v5;
  int v6;
  void **v7;
  void *v8;
  void *v9;
  uint64_t v10;
  BOOL v11;
  NSObject *v13;
  void **v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  const __CFDictionary *v21;
  _QWORD *v22;
  void *v23[3];
  _QWORD v24[2];
  const __CFDictionary *v25;
  char __p[23];
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v22 = (_QWORD *)v2;
  v3 = *(_QWORD *)v2;
  v4 = *(NSObject **)(*(_QWORD *)v2 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(*(_QWORD *)v2 + 144));
    dispatch_group_enter(v4);
  }
  v24[0] = 0xAAAAAAAAAAAAAAAALL;
  v24[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v24, *(const __CFDictionary **)(v2 + 24));
  memset(v23, 170, sizeof(v23));
  strcpy(__p, "kTraceFilterActionNone");
  v27 = 22;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v25, "kKeyTraceFilterAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](&v25);
  if (v27 < 0)
    operator delete(*(void **)__p);
  v5 = (void *)HIBYTE(v23[2]);
  v6 = SHIBYTE(v23[2]);
  if (SHIBYTE(v23[2]) < 0)
    v5 = v23[1];
  if (v5 != (void *)22)
    goto LABEL_17;
  v7 = (void **)v23[0];
  if (SHIBYTE(v23[2]) >= 0)
    v7 = v23;
  v8 = *v7;
  v9 = v7[1];
  v10 = *(uint64_t *)((char *)v7 + 14);
  v11 = v8 == *(void **)"kTraceFilterActionNone" && v9 == *(void **)"lterActionNone";
  if (v11 && v10 == *(_QWORD *)"tionNone")
  {
    v18 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(unsigned __int8 *)(v3 + 152);
      *(_DWORD *)__p = 67109120;
      *(_DWORD *)&__p[4] = v19;
      _os_log_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEFAULT, "#I Snapshot requested. Enabled = %d", (uint8_t *)__p, 8u);
    }
    if (*(_BYTE *)(v3 + 152))
    {
      v20 = *(NSObject **)(v2 + 8);
      *(_QWORD *)__p = v20;
      if (v20)
      {
        dispatch_retain(v20);
        dispatch_group_enter(v20);
      }
      v21 = *(const __CFDictionary **)(v2 + 24);
      v25 = v21;
      if (v21)
        CFRetain(v21);
      KernelPCIABPTrace::snapshot_sync(v3, (NSObject **)__p, &v25);
      if (v21)
        CFRelease(v21);
      if (v20)
      {
        dispatch_group_leave(v20);
        dispatch_release(v20);
      }
    }
  }
  else
  {
LABEL_17:
    v13 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = (void **)v23[0];
      if (v6 >= 0)
        v14 = v23;
      *(_DWORD *)__p = 136315138;
      *(_QWORD *)&__p[4] = v14;
      _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I Skipping snapshot as trace filter is '%s'", (uint8_t *)__p, 0xCu);
    }
  }
  if (SHIBYTE(v23[2]) < 0)
    operator delete(v23[0]);
  MEMORY[0x1A858F2D8](v24);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](&v22);
  v15 = (std::__shared_weak_count *)a1[2];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(a1);
}

void sub_1A34CDED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void sub_1A34CDFB0()
{
  uint64_t v0;

  if (!v0)
    JUMPOUT(0x1A34CDF60);
  JUMPOUT(0x1A34CDF50);
}

_QWORD **std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](_QWORD **a1)
{
  _QWORD *v2;
  const void *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = (const void *)v2[3];
    if (v3)
      CFRelease(v3);
    v4 = v2[2];
    if (v4)
      dispatch_release(v4);
    v5 = v2[1];
    if (v5)
    {
      dispatch_group_leave(v5);
      v6 = v2[1];
      if (v6)
        dispatch_release(v6);
    }
    operator delete(v2);
  }
  return a1;
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>(KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  void **v6;
  NSObject *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::string v12;
  void *__p[2];
  char v14;
  uint8_t buf[4];
  void **v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t **)a1;
  v3 = **(_QWORD **)a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  v5 = *(NSObject **)(v3 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    goto LABEL_12;
  if (*((char *)v2 + 39) < 0)
    std::string::__init_copy_ctor_external(&v12, (const std::string::value_type *)v2[2], v2[3]);
  else
    v12 = *(std::string *)(v2 + 2);
  KernelPCIABPTrace::dumpState_sync(v3, (uint64_t)&v12, 1, 10, __p);
  if (v14 >= 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  *(_DWORD *)buf = 136315138;
  v16 = v6;
  _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
  if (v14 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_26;
LABEL_12:
    if (!v4)
      goto LABEL_14;
    goto LABEL_13;
  }
  if ((SHIBYTE(v12.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_12;
LABEL_26:
  operator delete(v12.__r_.__value_.__l.__data_);
  if (v4)
  {
LABEL_13:
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
LABEL_14:
  if (*((char *)v2 + 39) < 0)
    operator delete((void *)v2[2]);
  v7 = v2[1];
  if (v7)
  {
    dispatch_group_leave(v7);
    v8 = v2[1];
    if (v8)
      dispatch_release(v8);
  }
  operator delete(v2);
  v9 = (std::__shared_weak_count *)*((_QWORD *)a1 + 2);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  operator delete(a1);
}

void sub_1A34CE200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _QWORD *v14;
  uint64_t v15;
  NSObject *v16;
  void **v17;
  NSObject *v19;
  NSObject *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;

  if (v16)
  {
    dispatch_group_leave(v16);
    dispatch_release(v16);
    if ((*(char *)(v15 + 39) & 0x80000000) == 0)
    {
LABEL_3:
      v19 = *(NSObject **)(v15 + 8);
      if (!v19)
        goto LABEL_9;
      goto LABEL_7;
    }
  }
  else if ((*(char *)(v15 + 39) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v17);
  v19 = *(NSObject **)(v15 + 8);
  if (!v19)
    goto LABEL_9;
LABEL_7:
  dispatch_group_leave(v19);
  v20 = *(NSObject **)(v15 + 8);
  if (v20)
    dispatch_release(v20);
LABEL_9:
  operator delete((void *)v15);
  v21 = (std::__shared_weak_count *)v14[2];
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  operator delete(v14);
  _Unwind_Resume(a1);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  const char *v5;
  size_t v6;
  NSObject *v7;
  void **v8;
  uint64_t *v9;
  uint64_t *v10;
  void *__p[2];
  int64_t v12;
  NSObject *v13;
  uint8_t buf[4];
  void **v15;
  __int16 v16;
  uint64_t *v17;
  __int16 v18;
  uint64_t *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)v1;
  v3 = *(NSObject **)(v1 + 8);
  v13 = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  v4 = KernelPCIABPTrace::setProperty_sync(v2, &v13, *(char **)(v1 + 16), *(char **)(v1 + 24));
  **(_BYTE **)(v1 + 32) = v4;
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
    v4 = **(unsigned __int8 **)(v1 + 32);
  }
  if (v4)
    v5 = "Success";
  else
    v5 = "Failed";
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  if (v4)
    v6 = 7;
  else
    v6 = 6;
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(v12) = v6;
  memcpy(__p, v5, v6);
  *(_BYTE *)((unint64_t)__p | v6) = 0;
  v7 = *(NSObject **)(v2 + 40);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((SHIBYTE(v12) & 0x80000000) == 0)
      return;
LABEL_19:
    operator delete(__p[0]);
    return;
  }
  v8 = (void **)__p[0];
  if (v12 >= 0)
    v8 = __p;
  v9 = *(uint64_t **)(v1 + 16);
  if (*((char *)v9 + 23) < 0)
  {
    v9 = (uint64_t *)*v9;
    v10 = *(uint64_t **)(v1 + 24);
    if ((*((char *)v10 + 23) & 0x80000000) == 0)
      goto LABEL_18;
  }
  else
  {
    v10 = *(uint64_t **)(v1 + 24);
    if ((*((char *)v10 + 23) & 0x80000000) == 0)
      goto LABEL_18;
  }
  v10 = (uint64_t *)*v10;
LABEL_18:
  *(_DWORD *)buf = 136315650;
  v15 = v8;
  v16 = 2080;
  v17 = v9;
  v18 = 2080;
  v19 = v10;
  _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I Set property [%s], Key=%s, Value=%s", buf, 0x20u);
  if (SHIBYTE(v12) < 0)
    goto LABEL_19;
}

void sub_1A34CE480(_Unwind_Exception *exception_object)
{
  NSObject *v1;

  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int Property_sync;
  const char *v4;
  size_t v5;
  NSObject *v6;
  void **v7;
  uint64_t *v8;
  uint64_t *v9;
  void *__dst[2];
  int64_t v11;
  uint8_t buf[4];
  void **v13;
  __int16 v14;
  uint64_t *v15;
  __int16 v16;
  uint64_t *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)v1;
  Property_sync = KernelPCIABPTrace::getProperty_sync(*(_QWORD *)v1, *(char **)(v1 + 8), *(_QWORD *)(v1 + 16));
  **(_BYTE **)(v1 + 24) = Property_sync;
  if (Property_sync)
    v4 = "Success";
  else
    v4 = "Failed";
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v11 = 0xAAAAAAAAAAAAAAAALL;
  if (Property_sync)
    v5 = 7;
  else
    v5 = 6;
  __dst[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(v11) = v5;
  memcpy(__dst, v4, v5);
  *(_BYTE *)((unint64_t)__dst | v5) = 0;
  v6 = *(NSObject **)(v2 + 40);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((SHIBYTE(v11) & 0x80000000) == 0)
      return;
LABEL_15:
    operator delete(__dst[0]);
    return;
  }
  v7 = (void **)__dst[0];
  if (v11 >= 0)
    v7 = __dst;
  v8 = *(uint64_t **)(v1 + 8);
  if (*((char *)v8 + 23) < 0)
  {
    v8 = (uint64_t *)*v8;
    v9 = *(uint64_t **)(v1 + 16);
    if ((*((char *)v9 + 23) & 0x80000000) == 0)
      goto LABEL_14;
  }
  else
  {
    v9 = *(uint64_t **)(v1 + 16);
    if ((*((char *)v9 + 23) & 0x80000000) == 0)
      goto LABEL_14;
  }
  v9 = (uint64_t *)*v9;
LABEL_14:
  *(_DWORD *)buf = 136315650;
  v13 = v7;
  v14 = 2080;
  v15 = v8;
  v16 = 2080;
  v17 = v9;
  _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Get property [%s], Key=%s, Value=%s", buf, 0x20u);
  if (SHIBYTE(v11) < 0)
    goto LABEL_15;
}

uint64_t _GLOBAL__sub_I_KernelPCIABPTrace_cpp()
{
  std::string *v0;
  __int128 v1;
  std::string v3;

  v3.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
  *(_OWORD *)&v3.__r_.__value_.__r.__words[1] = xmmword_1A357F810;
  strcpy(v3.__r_.__value_.__l.__data_, "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/");
  v0 = std::string::append(&v3, "code-registry.json", 0x12uLL);
  v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  *(_QWORD *)&byte_1ED114A60[16] = *((_QWORD *)&v0->__r_.__value_.__l + 2);
  *(_OWORD *)byte_1ED114A60 = v1;
  v0->__r_.__value_.__l.__size_ = 0;
  v0->__r_.__value_.__r.__words[2] = 0;
  v0->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v3.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v3.__r_.__value_.__l.__data_);
  return __cxa_atexit(MEMORY[0x1E0DE44D0], byte_1ED114A60, &dword_1A343C000);
}

void sub_1A34CE6D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *abm::LogManagementTask::LogManagementTask(_QWORD *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  v5 = (std::__shared_weak_count *)a3[1];
  v18 = *a3;
  v19 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a4[1];
  v16 = *a4;
  v17 = v8;
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  abm::HelperTask::HelperTask((uint64_t)a1, a2, &v18, &v16);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  *a1 = off_1E4A0A880;
  v14 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  a1[17] = dispatch_queue_create("log.mgr.task.queue", v14);
  ctu::LoggerCommonBase::setLogLevel();
  return a1;
}

void sub_1A34CE7EC(_Unwind_Exception *a1)
{
  abm::HelperTask *v1;
  NSObject *v3;

  v3 = *((_QWORD *)v1 + 17);
  if (v3)
    dispatch_release(v3);
  abm::HelperTask::~HelperTask(v1);
  _Unwind_Resume(a1);
}

void sub_1A34CE80C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void abm::HelperTask::~HelperTask(abm::HelperTask *this)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;

  *(_QWORD *)this = off_1E4A0F3B8;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = *((_QWORD *)this + 14);
  if (v3)
    dispatch_release(v3);
  *(_QWORD *)this = &unk_1E4A06FA8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v4 = *((_QWORD *)this + 12);
  if (v4)
    dispatch_release(v4);
  v5 = *((_QWORD *)this + 11);
  if (v5)
    dispatch_release(v5);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void abm::LogManagementTask::~LogManagementTask(abm::LogManagementTask *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;

  *(_QWORD *)this = off_1E4A0A880;
  v2 = *((_QWORD *)this + 17);
  if (v2)
    dispatch_release(v2);
  *(_QWORD *)this = off_1E4A0F3B8;
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  v4 = *((_QWORD *)this + 14);
  if (v4)
    dispatch_release(v4);
  *(_QWORD *)this = &unk_1E4A06FA8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v5 = *((_QWORD *)this + 12);
  if (v5)
    dispatch_release(v5);
  v6 = *((_QWORD *)this + 11);
  if (v6)
    dispatch_release(v6);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
}

{
  void *v1;

  abm::LogManagementTask::~LogManagementTask(this);
  operator delete(v1);
}

_QWORD *abm::LogManagementTask::getName(abm::LogManagementTask *this)
{
  unsigned __int8 v1;
  unsigned int v4;
  char *v5;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_12);
  if ((v1 & 1) != 0 || !__cxa_guard_acquire(&_MergedGlobals_12))
    return qword_1ED114AA8;
  v4 = *((_DWORD *)this + 26) - 1;
  if (v4 > 9)
    v5 = "invalid";
  else
    v5 = off_1E4A0A9F8[v4];
  std::string::basic_string[abi:ne180100]<0>(qword_1ED114AA8, v5);
  __cxa_atexit(MEMORY[0x1E0DE44D0], qword_1ED114AA8, &dword_1A343C000);
  __cxa_guard_release(&_MergedGlobals_12);
  return qword_1ED114AA8;
}

void sub_1A34CEA18(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&_MergedGlobals_12);
  _Unwind_Resume(a1);
}

void abm::LogManagementTask::init_sync(abm::LogManagementTask *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  NSObject *v16;
  char *v17;
  unint64_t v18;
  void *v19;
  NSObject *v20;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  NSObject *v24;
  unint64_t v25;
  void *v26;
  NSObject *v27;
  char *v28;
  void *v29;
  NSObject *v30;
  void *v31;
  NSObject *v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD v35[5];
  _QWORD v36[2];
  char v37[24];
  _QWORD v38[5];
  _QWORD v39[2];
  char *v40;
  __int128 v41;
  _QWORD v42[6];
  std::__shared_weak_count *v43;
  _QWORD v44[2];
  char v45[32];
  _QWORD v46[6];
  std::__shared_weak_count *v47;
  _QWORD v48[2];
  char v49[24];
  _QWORD aBlock[6];
  std::__shared_weak_count *v51;
  _QWORD v52[2];
  char *v53;
  __int128 v54;
  uint8_t buf[8];
  _QWORD v56[6];
  std::__shared_weak_count *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2 || (v3 = *((_QWORD *)this + 9), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v7 = __ldxr(p_shared_weak_owners);
  while (__stxr(v7 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (v9)
  {
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
      goto LABEL_65;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
      goto LABEL_65;
  }
  v11 = std::__shared_weak_count::lock(v10);
  v59 = v11;
  if (v11)
  {
    v12 = v11;
    v13 = *((_QWORD *)this + 15);
    v58 = v13;
    if (v13)
    {
      v14 = MEMORY[0x1E0C809B0];
      v56[0] = MEMORY[0x1E0C809B0];
      v56[1] = 3321888768;
      v56[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke;
      v56[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e45_____CFDictionary__20__0i8____CFDictionary__12l;
      v56[4] = this;
      v56[5] = v3;
      v57 = v5;
      do
        v15 = __ldxr(p_shared_weak_owners);
      while (__stxr(v15 + 1, p_shared_weak_owners));
      +[ABMCacheDelete RegisterCallback:::::](ABMCacheDelete, "RegisterCallback:::::", CFSTR("com.apple.abm.cache-delete"), 0, 0, 0, v56);
      v16 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#I CacheDelete Call back is registered. Check if there are purgeable log files.", buf, 2u);
      }
      abm::LogManagementTask::markPurgeableLogs(this);
      v17 = (char *)operator new(0x20uLL);
      v53 = v17;
      v54 = xmmword_1A35802C0;
      strcpy(v17, "CommandGetBasebandSnapshotLogs");
      aBlock[0] = v14;
      aBlock[1] = 3321888768;
      aBlock[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_4;
      aBlock[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      aBlock[4] = this;
      aBlock[5] = v3;
      v51 = v5;
      do
        v18 = __ldxr(p_shared_weak_owners);
      while (__stxr(v18 + 1, p_shared_weak_owners));
      v19 = _Block_copy(aBlock);
      v20 = *((_QWORD *)this + 11);
      if (v20)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v52[0] = v19;
      v52[1] = v20;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v53, (uint64_t)v52);
      if (v20)
        dispatch_release(v20);
      if (v19)
        _Block_release(v19);
      operator delete(v17);
      v49[23] = 14;
      strcpy(v49, "CommandLogMove");
      v21 = MEMORY[0x1E0C809B0];
      v46[0] = MEMORY[0x1E0C809B0];
      v46[1] = 3321888768;
      v46[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_9;
      v46[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v46[4] = this;
      v46[5] = v3;
      v47 = v5;
      do
        v22 = __ldxr(p_shared_weak_owners);
      while (__stxr(v22 + 1, p_shared_weak_owners));
      v23 = _Block_copy(v46);
      v24 = *((_QWORD *)this + 11);
      if (v24)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v48[0] = v23;
      v48[1] = v24;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)v49, (uint64_t)v48);
      if (v24)
        dispatch_release(v24);
      if (v23)
        _Block_release(v23);
      v45[23] = 16;
      strcpy(v45, "CommandLogDelete");
      v42[0] = v21;
      v42[1] = 3321888768;
      v42[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_18;
      v42[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v42[4] = this;
      v42[5] = v3;
      v43 = v5;
      do
        v25 = __ldxr(p_shared_weak_owners);
      while (__stxr(v25 + 1, p_shared_weak_owners));
      v26 = _Block_copy(v42);
      v27 = *((_QWORD *)this + 11);
      if (v27)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v44[0] = v26;
      v44[1] = v27;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)v45, (uint64_t)v44);
      if (v27)
        dispatch_release(v27);
      if (v26)
        _Block_release(v26);
      v28 = (char *)operator new(0x20uLL);
      v40 = v28;
      v41 = xmmword_1A357F830;
      strcpy(v28, "CommandMobileLogHouseKeeping");
      v38[0] = v21;
      v38[1] = 3221225472;
      v38[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_27;
      v38[3] = &__block_descriptor_40_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v38[4] = this;
      v29 = _Block_copy(v38);
      v30 = *((_QWORD *)this + 11);
      if (v30)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v39[0] = v29;
      v39[1] = v30;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v40, (uint64_t)v39);
      if (v30)
        dispatch_release(v30);
      if (v29)
        _Block_release(v29);
      operator delete(v28);
      v37[23] = 17;
      strcpy(v37, "CommandLogPrepare");
      v35[0] = MEMORY[0x1E0C809B0];
      v35[1] = 3221225472;
      v35[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_28;
      v35[3] = &__block_descriptor_40_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v35[4] = this;
      v31 = _Block_copy(v35);
      v32 = *((_QWORD *)this + 11);
      if (v32)
        dispatch_retain(v32);
      v36[0] = v31;
      v36[1] = v32;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)v37, (uint64_t)v36);
      if (v32)
        dispatch_release(v32);
      if (v31)
        _Block_release(v31);
      if (v43)
        std::__shared_weak_count::__release_weak(v43);
      if (v47)
        std::__shared_weak_count::__release_weak(v47);
      if (v51)
        std::__shared_weak_count::__release_weak(v51);
      if (v57)
        std::__shared_weak_count::__release_weak(v57);
    }
    v33 = (unint64_t *)&v12->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
LABEL_65:
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A34CEF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,std::__shared_weak_count *a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,std::__shared_weak_count *a61)
{
  std::__shared_weak_count *v61;
  uint64_t v62;
  std::__shared_weak_count *v64;
  std::__shared_weak_count *v65;
  std::__shared_weak_count *v66;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a15);
  if (a36)
  {
    std::__shared_weak_count::__release_weak(a36);
    v64 = a49;
    if (!a49)
    {
LABEL_3:
      v65 = a61;
      if (!a61)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else
  {
    v64 = a49;
    if (!a49)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v64);
  v65 = a61;
  if (!a61)
  {
LABEL_4:
    v66 = *(std::__shared_weak_count **)(v62 - 136);
    if (!v66)
      goto LABEL_5;
    goto LABEL_9;
  }
LABEL_8:
  std::__shared_weak_count::__release_weak(v65);
  v66 = *(std::__shared_weak_count **)(v62 - 136);
  if (!v66)
  {
LABEL_5:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v62 - 128);
    std::__shared_weak_count::__release_weak(v61);
    _Unwind_Resume(a1);
  }
LABEL_9:
  std::__shared_weak_count::__release_weak(v66);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v62 - 128);
  std::__shared_weak_count::__release_weak(v61);
  _Unwind_Resume(a1);
}

uint64_t ___ZN3abm17LogManagementTask9init_syncEv_block_invoke(_QWORD *a1, int a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  _QWORD *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _DWORD v14[2];
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    v7 = (_QWORD *)a1[4];
    v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      v9 = v8;
      if (a1[5])
      {
        v10 = v7[5];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v14[0] = 67109378;
          v14[1] = a2;
          v15 = 2112;
          v16 = a3;
          _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I CacheDelete Purge Periodic Callback: urgency: %d, info: %@", (uint8_t *)v14, 0x12u);
        }
        abm::LogManagementTask::markPurgeableLogs(v7);
      }
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  return 0;
}

uint64_t abm::LogManagementTask::markPurgeableLogs(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;

  v2 = (std::__shared_weak_count *)a1[10];
  if (!v2 || (v3 = a1[9], (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  v6 = operator new(8uLL);
  *v6 = a1;
  v7 = a1[11];
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  v10 = operator new(0x18uLL);
  *v10 = v6;
  v10[1] = v3;
  v10[2] = v5;
  dispatch_async_f(v7, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<abm::HelperTask>::execute_wrapped<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>(abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0,dispatch_queue_s *::default_delete<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return 0;
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_4(_QWORD *a1, TelephonyXPC::ServerClientState *a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  NSObject *v10;
  int st_gid_high;
  void *v12;
  const char *p_block;
  int v14;
  int v15;
  NSObject *v16;
  stat *v17;
  xpc_object_t v18;
  void *v19;
  xpc_object_t value;
  NSObject *v21;
  void *v22;
  xpc_object_t v23;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  xpc_object_t v27;
  const void *v28;
  size_t v29;
  std::string::size_type v30;
  std::string *p_dst;
  uint64_t v32;
  uint64_t v33;
  xpc_object_t v34;
  void *v35;
  size_t i;
  xpc_object_t v37;
  xpc_object_t v38;
  size_t count;
  xpc_object_t v40;
  xpc_object_t v41;
  std::string::size_type v42;
  char v43;
  __darwin_ino64_t st_ino;
  __darwin_ino64_t v45;
  std::string::size_type size;
  const std::string::value_type *v47;
  std::string::size_type v48;
  xpc_object_t v49;
  xpc_object_t v50;
  xpc_object_t v51;
  xpc_object_t v52;
  __int128 v53;
  unint64_t *v54;
  unint64_t v55;
  _BOOL4 FilteredFiles;
  std::__shared_weak_count *v57;
  unint64_t *p_shared_owners;
  unint64_t v59;
  const void **v60;
  int v61;
  size_t v62;
  int v63;
  size_t v64;
  unint64_t v65;
  char *v66;
  std::string *v67;
  const void *v68;
  int v69;
  _BYTE *v70;
  char *v71;
  char *v72;
  size_t v73;
  char *v74;
  void **v76;
  uint64_t v77;
  uint64_t v78;
  size_t v80;
  NSObject *v82;
  _BOOL4 v83;
  void **v84;
  timespec v85;
  void **v86;
  const char *v87;
  DIR *v88;
  DIR *v89;
  void **v90;
  xpc_object_t v91;
  NSObject *v92;
  std::string *v93;
  xpc_object_t v94;
  const void *v95;
  void *v96;
  xpc_object_t v97;
  NSObject *v98;
  void *v99;
  xpc_object_t v100;
  void *v101;
  NSObject *v102;
  void *v103;
  std::__shared_weak_count *v104;
  unint64_t *v105;
  unint64_t v106;
  void **v107;
  void **v108;
  void *v109;
  std::__shared_weak_count *v110;
  unint64_t *v111;
  unint64_t v112;
  NSObject *v113;
  uint64_t v114;
  uint64_t v115;
  xpc_object_t v116;
  int v117;
  void *__p[3];
  std::locale v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  std::__shared_weak_count *v123;
  uint64_t v124;
  std::string v125;
  void *v126;
  void **v127;
  uint64_t v128;
  std::string v129;
  std::string __dst;
  uint64_t v131;
  std::__shared_weak_count *v132;
  _BYTE buf[48];
  __int128 v134;
  stat block;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  v5 = a1[4];
  v131 = 0;
  v132 = 0;
  v6 = (std::__shared_weak_count *)a1[6];
  if (!v6)
    goto LABEL_260;
  v132 = std::__shared_weak_count::lock(v6);
  if (!v132)
    return;
  v131 = a1[5];
  if (!v131)
    goto LABEL_260;
  v114 = v5;
  v115 = a4;
  v10 = *(NSObject **)(v5 + 112);
  if (v10)
  {
    dispatch_retain(*(dispatch_object_t *)(v5 + 112));
    dispatch_group_enter(v10);
  }
  TelephonyXPC::ServerClientState::getName(a2);
  st_gid_high = SHIBYTE(block.st_gid);
  v12 = *(void **)&block.st_dev;
  if ((block.st_gid & 0x80000000) == 0)
    p_block = (const char *)&block;
  else
    p_block = *(const char **)&block.st_dev;
  v14 = strncasecmp(p_block, "BasebandLog.DEHelper", 0x14uLL);
  v15 = v14;
  if (st_gid_high < 0)
  {
    operator delete(v12);
    if (v15)
      goto LABEL_11;
  }
  else if (v14)
  {
LABEL_11:
    v16 = *(NSObject **)(v114 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      TelephonyXPC::ServerClientState::getName(a2);
      v17 = (block.st_gid & 0x80000000) == 0 ? &block : *(stat **)&block.st_dev;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v17;
      _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#I Getting baseband snapshot logs is not allowed for %s", buf, 0xCu);
      if (SHIBYTE(block.st_gid) < 0)
        operator delete(*(void **)&block.st_dev);
    }
    v18 = xpc_null_create();
    if (*(_QWORD *)a4)
      v19 = _Block_copy(*(const void **)a4);
    else
      v19 = 0;
    v21 = *(NSObject **)(a4 + 8);
    *(_QWORD *)&block.st_dev = MEMORY[0x1E0C809B0];
    block.st_ino = 3321888768;
    *(_QWORD *)&block.st_uid = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    *(_QWORD *)&block.st_rdev = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v19)
    {
      v22 = _Block_copy(v19);
      LODWORD(block.st_mtimespec.tv_sec) = -534716414;
      block.st_atimespec.tv_sec = (__darwin_time_t)v22;
      block.st_atimespec.tv_nsec = (uint64_t)v18;
      if (v18)
      {
LABEL_25:
        xpc_retain(v18);
LABEL_28:
        dispatch_async(v21, &block);
        xpc_release((xpc_object_t)block.st_atimespec.tv_nsec);
        block.st_atimespec.tv_nsec = 0;
        if (block.st_atimespec.tv_sec)
          _Block_release((const void *)block.st_atimespec.tv_sec);
        if (v19)
          _Block_release(v19);
        xpc_release(v18);
        goto LABEL_258;
      }
    }
    else
    {
      LODWORD(block.st_mtimespec.tv_sec) = -534716414;
      block.st_atimespec.tv_sec = 0;
      block.st_atimespec.tv_nsec = (uint64_t)v18;
      if (v18)
        goto LABEL_25;
    }
    block.st_atimespec.tv_nsec = (uint64_t)xpc_null_create();
    goto LABEL_28;
  }
  v113 = v10;
  value = xpc_dictionary_get_value(*a3, "AllowToDelete");
  *(_QWORD *)&block.st_dev = value;
  if (value)
    xpc_retain(value);
  else
    *(_QWORD *)&block.st_dev = xpc_null_create();
  v117 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)&block.st_dev);
  v23 = xpc_dictionary_get_value(*a3, "MatchingPattern");
  v24 = v23;
  if (v23)
    xpc_retain(v23);
  else
    v24 = xpc_null_create();
  v25 = xpc_null_create();
  if (v24 && MEMORY[0x1A85902BC](v24) == MEMORY[0x1E0C812C8])
  {
    xpc_retain(v24);
    v26 = v24;
  }
  else
  {
    v26 = xpc_null_create();
  }
  if (MEMORY[0x1A85902BC](v26) != MEMORY[0x1E0C812C8])
  {
    if (v25)
    {
      xpc_retain(v25);
      v27 = v25;
    }
    else
    {
      v27 = xpc_null_create();
    }
    xpc_release(v26);
    v26 = v27;
  }
  xpc_release(v25);
  xpc_release(v24);
  memset(&__dst, 170, sizeof(__dst));
  v28 = (const void *)qword_1ED114D90;
  v29 = strlen((const char *)qword_1ED114D90);
  if (v29 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v30 = v29;
  if (v29 >= 0x17)
  {
    v32 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17)
      v32 = v29 | 7;
    v33 = v32 + 1;
    p_dst = (std::string *)operator new(v32 + 1);
    __dst.__r_.__value_.__l.__size_ = v30;
    __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_53;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v29;
  p_dst = &__dst;
  if (v29)
LABEL_53:
    memmove(p_dst, v28, v30);
  p_dst->__r_.__value_.__s.__data_[v30] = 0;
  v129.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v129.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
  v129.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
  if (v26)
  {
    xpc_retain(v26);
    v34 = v26;
  }
  else
  {
    v34 = xpc_null_create();
    if (!v34)
    {
      v34 = xpc_null_create();
      v35 = 0;
      goto LABEL_58;
    }
  }
  xpc_retain(v34);
  v35 = v34;
LABEL_58:
  xpc_release(v35);
  for (i = 0; ; ++i)
  {
    if (v26)
    {
      xpc_retain(v26);
      v38 = v26;
    }
    else
    {
      v38 = xpc_null_create();
    }
    if (MEMORY[0x1A85902BC](v26) == MEMORY[0x1E0C812C8])
    {
      count = xpc_array_get_count(v26);
      if (!v38)
      {
LABEL_68:
        v40 = xpc_null_create();
        goto LABEL_69;
      }
    }
    else
    {
      count = 0;
      if (!v38)
        goto LABEL_68;
    }
    xpc_retain(v38);
    v40 = v38;
LABEL_69:
    xpc_release(v38);
    xpc_release(v40);
    if (i == count && v34 == v40)
      break;
    memset(&block, 170, 24);
    v41 = xpc_array_get_value(v34, i);
    *(_QWORD *)buf = v41;
    if (v41)
      xpc_retain(v41);
    else
      *(_QWORD *)buf = xpc_null_create();
    xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)buf);
    v42 = HIBYTE(block.st_gid);
    v43 = HIBYTE(block.st_gid);
    st_ino = block.st_ino;
    if ((block.st_gid & 0x80000000) == 0)
      v45 = HIBYTE(block.st_gid);
    else
      v45 = block.st_ino;
    if (v45)
    {
      size = HIBYTE(v129.__r_.__value_.__r.__words[2]);
      if ((v129.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v129.__r_.__value_.__l.__size_;
      if (size)
      {
        std::string::append(&v129, "|", 1uLL);
        v42 = HIBYTE(block.st_gid);
        st_ino = block.st_ino;
        v43 = HIBYTE(block.st_gid);
      }
      if (v43 >= 0)
        v47 = (const std::string::value_type *)&block;
      else
        v47 = *(const std::string::value_type **)&block.st_dev;
      if (v43 >= 0)
        v48 = v42;
      else
        v48 = st_ino;
      std::string::append(&v129, v47, v48);
      v43 = HIBYTE(block.st_gid);
    }
    if (v43 < 0)
    {
      operator delete(*(void **)&block.st_dev);
      if (!v34)
      {
LABEL_59:
        v37 = xpc_null_create();
        goto LABEL_60;
      }
    }
    else if (!v34)
    {
      goto LABEL_59;
    }
    xpc_retain(v34);
    v37 = v34;
LABEL_60:
    xpc_release(v37);
  }
  xpc_release(v34);
  v49 = xpc_dictionary_create(0, 0, 0);
  if (v49 || (v49 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v49) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(v49);
      v50 = v49;
    }
    else
    {
      v50 = xpc_null_create();
    }
  }
  else
  {
    v50 = xpc_null_create();
    v49 = 0;
  }
  xpc_release(v49);
  v51 = xpc_array_create(0, 0);
  if (v51 || (v51 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v51) == MEMORY[0x1E0C812C8])
    {
      xpc_retain(v51);
      v52 = v51;
    }
    else
    {
      v52 = xpc_null_create();
    }
  }
  else
  {
    v52 = xpc_null_create();
    v51 = 0;
  }
  xpc_release(v51);
  v126 = 0;
  v127 = 0;
  v128 = 0;
  *(_QWORD *)&v53 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&buf[32] = v53;
  v134 = v53;
  *(_OWORD *)buf = v53;
  *(_OWORD *)&buf[16] = v53;
  v116 = v52;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)buf, (uint64_t)&v129, 0);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v125, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  else
    v125 = __dst;
  std::locale::locale(&v119, (const std::locale *)buf);
  v120 = *(_OWORD *)&buf[8];
  v121 = *(_OWORD *)&buf[24];
  v122 = *(_QWORD *)&buf[40];
  v123 = (std::__shared_weak_count *)v134;
  if ((_QWORD)v134)
  {
    v54 = (unint64_t *)(v134 + 8);
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  v124 = *((_QWORD *)&v134 + 1);
  FilteredFiles = support::fs::getFilteredFiles((const char *)&v125, (uint64_t)&v119, (uint64_t)&v126, 0);
  v57 = v123;
  if (v123)
  {
    p_shared_owners = (unint64_t *)&v123->__shared_owners_;
    do
      v59 = __ldaxr(p_shared_owners);
    while (__stlxr(v59 - 1, p_shared_owners));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  std::locale::~locale(&v119);
  if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v125.__r_.__value_.__l.__data_);
    if (FilteredFiles)
      goto LABEL_122;
  }
  else
  {
    if (!FilteredFiles)
      goto LABEL_198;
LABEL_122:
    v60 = (const void **)v126;
    if (v126 != v127)
    {
      while (2)
      {
        memset(__p, 170, sizeof(__p));
        v61 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v62 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          v62 = __dst.__r_.__value_.__l.__size_;
        v63 = *((char *)v60 + 23);
        if (v63 >= 0)
          v64 = *((unsigned __int8 *)v60 + 23);
        else
          v64 = (size_t)v60[1];
        v65 = v64 + v62;
        if (v64 + v62 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        if (v65 > 0x16)
        {
          v77 = (v65 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v65 | 7) != 0x17)
            v77 = v65 | 7;
          v78 = v77 + 1;
          v66 = (char *)operator new(v77 + 1);
          __p[1] = (void *)(v64 + v62);
          __p[2] = (void *)(v78 | 0x8000000000000000);
          __p[0] = v66;
          if (v62)
          {
LABEL_134:
            if (v61 >= 0)
              v67 = &__dst;
            else
              v67 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            memmove(v66, v67, v62);
          }
        }
        else
        {
          memset(__p, 0, sizeof(__p));
          v66 = (char *)__p;
          HIBYTE(__p[2]) = v64 + v62;
          if (v62)
            goto LABEL_134;
        }
        if (v64)
        {
          if (v63 >= 0)
            v68 = v60;
          else
            v68 = *v60;
          memmove(&v66[v62], v68, v64);
        }
        v66[v62 + v64] = 0;
        v69 = SHIBYTE(__p[2]);
        if (v117)
        {
          if (SHIBYTE(__p[2]) >= 0)
            v70 = (_BYTE *)HIBYTE(__p[2]);
          else
            v70 = __p[1];
          v71 = (char *)strlen(abm::trace::kLogArchiveSuffix[0]);
          v72 = (char *)(v70 - v71);
          v73 = strlen(abm::trace::kLogArchiveSuffix[0]);
          v74 = (char *)v73;
          if (SHIBYTE(__p[2]) < 0)
          {
            if (v73 == -1 || __p[1] < v72)
LABEL_267:
              std::string::__throw_out_of_range[abi:ne180100]();
            if ((char *)((char *)__p[1] - (char *)v72) < v71)
              v71 = (char *)((char *)__p[1] - (char *)v72);
            v76 = (void **)__p[0];
          }
          else
          {
            if (v73 == -1 || HIBYTE(__p[2]) < (unint64_t)v72)
              goto LABEL_267;
            if (HIBYTE(__p[2]) - (unint64_t)v72 < (unint64_t)v71)
              v71 = (char *)(HIBYTE(__p[2]) - (_QWORD)v72);
            v76 = __p;
          }
          v52 = v116;
          if ((unint64_t)v71 >= v73)
            v80 = v73;
          else
            v80 = (size_t)v71;
          if (memcmp(&v72[(_QWORD)v76], abm::trace::kLogArchiveSuffix[0], v80) || v71 != v74)
          {
            v82 = *(NSObject **)(v114 + 40);
            v83 = os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
            v84 = (void **)__p[0];
            if (v83)
            {
              if (v69 >= 0)
                v84 = __p;
              block.st_dev = 136315138;
              *(_QWORD *)&block.st_mode = v84;
              _os_log_impl(&dword_1A343C000, v82, OS_LOG_TYPE_DEFAULT, "#I Updating mode: %s", (uint8_t *)&block, 0xCu);
              LOBYTE(v69) = HIBYTE(__p[2]);
              v84 = (void **)__p[0];
            }
            v85.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v85.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&block.st_blksize = v85;
            *(timespec *)block.st_qspare = v85;
            block.st_birthtimespec = v85;
            *(timespec *)&block.st_size = v85;
            block.st_mtimespec = v85;
            block.st_ctimespec = v85;
            *(timespec *)&block.st_uid = v85;
            block.st_atimespec = v85;
            if ((v69 & 0x80u) == 0)
              v86 = __p;
            else
              v86 = v84;
            *(timespec *)&block.st_dev = v85;
            if (!stat((const char *)v86, &block))
            {
              v87 = SHIBYTE(__p[2]) >= 0 ? (const char *)__p : (const char *)__p[0];
              v88 = opendir(v87);
              v89 = v88;
              if (v88)
              {
                readdir(v88);
                closedir(v89);
              }
            }
            ctu::fs::chmod();
            LOBYTE(v69) = HIBYTE(__p[2]);
          }
        }
        else
        {
          v52 = v116;
        }
        if ((v69 & 0x80u) == 0)
          v90 = __p;
        else
          v90 = (void **)__p[0];
        v91 = xpc_string_create((const char *)v90);
        if (!v91)
          v91 = xpc_null_create();
        xpc_array_append_value(v52, v91);
        xpc_release(v91);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        v60 += 3;
        if (v60 == (const void **)v127)
          break;
        continue;
      }
    }
  }
LABEL_198:
  v10 = v113;
  if (MEMORY[0x1A85902BC](v52) == MEMORY[0x1E0C812C8] && xpc_array_get_count(v52))
  {
    if (v117)
      ctu::fs::chmod();
    if (v52)
    {
      xpc_retain(v52);
      v97 = v52;
    }
    else
    {
      v97 = xpc_null_create();
    }
    xpc_dictionary_set_value(v50, "FoundList", v97);
    v100 = xpc_null_create();
    xpc_release(v97);
    xpc_release(v100);
    if (v50)
    {
      xpc_retain(v50);
      v94 = v50;
    }
    else
    {
      v94 = xpc_null_create();
    }
    if (*(_QWORD *)v115)
      v101 = _Block_copy(*(const void **)v115);
    else
      v101 = 0;
    v102 = *(NSObject **)(v115 + 8);
    *(_QWORD *)&block.st_dev = MEMORY[0x1E0C809B0];
    block.st_ino = 3321888768;
    *(_QWORD *)&block.st_uid = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    *(_QWORD *)&block.st_rdev = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v101)
      v103 = _Block_copy(v101);
    else
      v103 = 0;
    LODWORD(block.st_mtimespec.tv_sec) = 0;
    block.st_atimespec.tv_sec = (__darwin_time_t)v103;
    block.st_atimespec.tv_nsec = (uint64_t)v94;
    if (v94)
      xpc_retain(v94);
    else
      block.st_atimespec.tv_nsec = (uint64_t)xpc_null_create();
    dispatch_async(v102, &block);
    xpc_release((xpc_object_t)block.st_atimespec.tv_nsec);
    block.st_atimespec.tv_nsec = 0;
    if (block.st_atimespec.tv_sec)
      _Block_release((const void *)block.st_atimespec.tv_sec);
    if (v101)
      _Block_release(v101);
    goto LABEL_240;
  }
  v92 = *(NSObject **)(v114 + 40);
  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
  {
    v93 = &v129;
    if ((v129.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v93 = (std::string *)v129.__r_.__value_.__r.__words[0];
    block.st_dev = 136315138;
    *(_QWORD *)&block.st_mode = v93;
    _os_log_impl(&dword_1A343C000, v92, OS_LOG_TYPE_DEFAULT, "#I Snapshot for pattern %s not found", (uint8_t *)&block, 0xCu);
  }
  if (v50)
  {
    xpc_retain(v50);
    v94 = v50;
    v95 = *(const void **)v115;
    if (*(_QWORD *)v115)
      goto LABEL_205;
LABEL_212:
    v96 = 0;
  }
  else
  {
    v94 = xpc_null_create();
    v95 = *(const void **)v115;
    if (!*(_QWORD *)v115)
      goto LABEL_212;
LABEL_205:
    v96 = _Block_copy(v95);
  }
  v98 = *(NSObject **)(v115 + 8);
  *(_QWORD *)&block.st_dev = MEMORY[0x1E0C809B0];
  block.st_ino = 3321888768;
  *(_QWORD *)&block.st_uid = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
  *(_QWORD *)&block.st_rdev = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (v96)
  {
    v99 = _Block_copy(v96);
    LODWORD(block.st_mtimespec.tv_sec) = -534716416;
    block.st_atimespec.tv_sec = (__darwin_time_t)v99;
    block.st_atimespec.tv_nsec = (uint64_t)v94;
    if (v94)
      goto LABEL_215;
LABEL_217:
    block.st_atimespec.tv_nsec = (uint64_t)xpc_null_create();
  }
  else
  {
    LODWORD(block.st_mtimespec.tv_sec) = -534716416;
    block.st_atimespec.tv_sec = 0;
    block.st_atimespec.tv_nsec = (uint64_t)v94;
    if (!v94)
      goto LABEL_217;
LABEL_215:
    xpc_retain(v94);
  }
  dispatch_async(v98, &block);
  xpc_release((xpc_object_t)block.st_atimespec.tv_nsec);
  block.st_atimespec.tv_nsec = 0;
  if (block.st_atimespec.tv_sec)
    _Block_release((const void *)block.st_atimespec.tv_sec);
  if (v96)
    _Block_release(v96);
LABEL_240:
  xpc_release(v94);
  v104 = (std::__shared_weak_count *)v134;
  if ((_QWORD)v134)
  {
    v105 = (unint64_t *)(v134 + 8);
    do
      v106 = __ldaxr(v105);
    while (__stlxr(v106 - 1, v105));
    if (!v106)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }
  std::locale::~locale((std::locale *)buf);
  v107 = (void **)v126;
  if (v126)
  {
    v108 = v127;
    v109 = v126;
    if (v127 != v126)
    {
      do
      {
        if (*((char *)v108 - 1) < 0)
          operator delete(*(v108 - 3));
        v108 -= 3;
      }
      while (v108 != v107);
      v109 = v126;
    }
    v127 = v107;
    operator delete(v109);
  }
  xpc_release(v52);
  xpc_release(v50);
  if (SHIBYTE(v129.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v129.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  xpc_release(v26);
LABEL_258:
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
LABEL_260:
  v110 = v132;
  if (v132)
  {
    v111 = (unint64_t *)&v132->__shared_owners_;
    do
      v112 = __ldaxr(v111);
    while (__stlxr(v112 - 1, v111));
    if (!v112)
    {
      ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
      std::__shared_weak_count::__release_weak(v110);
    }
  }
}

void sub_1A34D0178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, dispatch_group_t group, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,std::locale a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,char a53,uint64_t a54,xpc_object_t a55)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_9(_QWORD *a1, uint64_t a2, void **a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  void *v17;
  void *v18;
  NSObject *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  _QWORD v22[6];
  std::__shared_weak_count *v23;
  xpc_object_t v24;
  void *aBlock;
  dispatch_object_t object;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v8 = a1[4];
    v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      v10 = v9;
      v11 = a1[5];
      if (!v11)
      {
LABEL_20:
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      v12 = *(NSObject **)(v8 + 112);
      v13 = *(NSObject **)(v8 + 88);
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3321888768;
      v22[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2;
      v22[3] = &__block_descriptor_80_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
      v22[4] = v8;
      v22[5] = v11;
      v14 = (std::__shared_weak_count *)a1[6];
      v23 = v14;
      if (v14)
      {
        p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
        do
          v16 = __ldxr(p_shared_weak_owners);
        while (__stxr(v16 + 1, p_shared_weak_owners));
      }
      v17 = *a3;
      v24 = v17;
      if (v17)
      {
        xpc_retain(v17);
        v18 = *(void **)a4;
        if (!*(_QWORD *)a4)
          goto LABEL_12;
      }
      else
      {
        v24 = xpc_null_create();
        v18 = *(void **)a4;
        if (!*(_QWORD *)a4)
        {
LABEL_12:
          v19 = *(NSObject **)(a4 + 8);
          aBlock = v18;
          object = v19;
          if (v19)
            dispatch_retain(v19);
          dispatch_group_notify(v12, v13, v22);
          if (object)
            dispatch_release(object);
          if (aBlock)
            _Block_release(aBlock);
          xpc_release(v24);
          v24 = 0;
          if (v23)
            std::__shared_weak_count::__release_weak(v23);
          goto LABEL_20;
        }
      }
      v18 = _Block_copy(v18);
      goto LABEL_12;
    }
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  NSObject *v4;
  char *v5;
  size_t v6;
  size_t v7;
  _BYTE *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  xpc_object_t value;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  xpc_object_t v18;
  int v19;
  xpc_object_t v20;
  NSObject *v21;
  xpc_object_t v22;
  void *v23;
  size_t i;
  xpc_object_t v25;
  xpc_object_t v26;
  size_t count;
  xpc_object_t v28;
  xpc_object_t v29;
  std::string::size_type v30;
  char v31;
  std::string::size_type v32;
  uint64_t v33;
  std::string::size_type size;
  const std::string::value_type *v35;
  std::string::size_type v36;
  std::string *v37;
  __int128 v38;
  std::string *v39;
  __int128 v40;
  const std::string::value_type *v41;
  std::string::size_type v42;
  NSObject *v43;
  ctu::XpcJetsamAssertion *v44;
  uint64_t v45;
  __int128 v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  uint64_t v62;
  unint64_t *p_shared_weak_owners;
  unint64_t v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  std::__shared_weak_count *v68;
  uint64_t v69;
  unint64_t *v70;
  unint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  void *v74;
  NSObject *v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void *v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  unint64_t *p_shared_owners;
  unint64_t v89;
  NSObject **v90;
  _QWORD v91[6];
  std::__shared_weak_count *v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  void *aBlock;
  dispatch_object_t object;
  _QWORD block[6];
  std::__shared_weak_count *v98;
  dispatch_group_t group;
  uint64_t v100;
  std::string v101;
  std::string v102;
  void *__p[2];
  char v104;
  std::string::value_type __s[8];
  char v106;
  std::string v107;
  std::string v108;
  _BYTE v109[24];
  std::string v110;
  std::__shared_weak_count *v112;
  _BYTE __dst[32];
  int v114;
  std::string buf;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2)
    return;
  v90 = *(NSObject ***)(a1 + 32);
  v3 = std::__shared_weak_count::lock(v2);
  v112 = v3;
  if (!v3)
    return;
  if (!*(_QWORD *)(a1 + 40))
  {
    v9 = v3;
LABEL_191:
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v89 = __ldaxr(p_shared_owners);
    while (__stlxr(v89 - 1, p_shared_owners));
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return;
  }
  v4 = v90[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (char *)MEMORY[0x1A8590268](*(_QWORD *)(a1 + 56));
    memset(__dst, 170, 24);
    v6 = strlen(v5);
    if (v6 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v7 = v6;
    if (v6 >= 0x17)
    {
      v10 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17)
        v10 = v6 | 7;
      v11 = v10 + 1;
      v8 = operator new(v10 + 1);
      *(_QWORD *)&__dst[8] = v7;
      *(_QWORD *)&__dst[16] = v11 | 0x8000000000000000;
      *(_QWORD *)__dst = v8;
    }
    else
    {
      __dst[23] = v6;
      v8 = __dst;
      if (!v6)
        goto LABEL_14;
    }
    memcpy(v8, v5, v7);
LABEL_14:
    v8[v7] = 0;
    free(v5);
    v12 = __dst;
    if (__dst[23] < 0)
      v12 = *(_BYTE **)__dst;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I LogMove requested: %s", (uint8_t *)&buf, 0xCu);
    if ((__dst[23] & 0x80000000) != 0)
      operator delete(*(void **)__dst);
  }
  value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "MatchingPattern");
  v14 = value;
  if (value)
    xpc_retain(value);
  else
    v14 = xpc_null_create();
  v15 = xpc_null_create();
  if (v14 && MEMORY[0x1A85902BC](v14) == MEMORY[0x1E0C812C8])
  {
    xpc_retain(v14);
    v16 = v14;
  }
  else
  {
    v16 = xpc_null_create();
  }
  if (MEMORY[0x1A85902BC](v16) != MEMORY[0x1E0C812C8])
  {
    if (v15)
    {
      xpc_retain(v15);
      v17 = v15;
    }
    else
    {
      v17 = xpc_null_create();
    }
    xpc_release(v16);
    v16 = v17;
  }
  xpc_release(v15);
  xpc_release(v14);
  v18 = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "SrcBaseDirectoryIndex");
  *(_QWORD *)__dst = v18;
  if (v18)
    xpc_retain(v18);
  else
    *(_QWORD *)__dst = xpc_null_create();
  v19 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)__dst);
  memset(&buf, 170, sizeof(buf));
  v20 = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "DstDirectory");
  *(_QWORD *)__dst = v20;
  if (v20)
    xpc_retain(v20);
  else
    *(_QWORD *)__dst = xpc_null_create();
  xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)__dst);
  if (v19 >= 8)
  {
    v21 = v90[5];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 67109120;
      *(_DWORD *)&__dst[4] = v19;
      _os_log_error_impl(&dword_1A343C000, v21, OS_LOG_TYPE_ERROR, "Invalid BaseDir [%d]. Cannot process it", __dst, 8u);
    }
    goto LABEL_188;
  }
  v110.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v110.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
  v110.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
  if (v16)
  {
    xpc_retain(v16);
    v22 = v16;
  }
  else
  {
    v22 = xpc_null_create();
    if (!v22)
    {
      v22 = xpc_null_create();
      v23 = 0;
      goto LABEL_43;
    }
  }
  xpc_retain(v22);
  v23 = v22;
LABEL_43:
  xpc_release(v23);
  for (i = 0; ; ++i)
  {
    if (v16)
    {
      xpc_retain(v16);
      v26 = v16;
    }
    else
    {
      v26 = xpc_null_create();
    }
    if (MEMORY[0x1A85902BC](v16) == MEMORY[0x1E0C812C8])
    {
      count = xpc_array_get_count(v16);
      if (!v26)
      {
LABEL_53:
        v28 = xpc_null_create();
        goto LABEL_54;
      }
    }
    else
    {
      count = 0;
      if (!v26)
        goto LABEL_53;
    }
    xpc_retain(v26);
    v28 = v26;
LABEL_54:
    xpc_release(v26);
    xpc_release(v28);
    if (i == count && v22 == v28)
      break;
    memset(__dst, 170, 24);
    v29 = xpc_array_get_value(v22, i);
    *(_QWORD *)v109 = v29;
    if (v29)
      xpc_retain(v29);
    else
      *(_QWORD *)v109 = xpc_null_create();
    xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)v109);
    v30 = __dst[23];
    v31 = __dst[23];
    v32 = *(_QWORD *)&__dst[8];
    if (__dst[23] >= 0)
      v33 = __dst[23];
    else
      v33 = *(_QWORD *)&__dst[8];
    if (v33)
    {
      size = HIBYTE(v110.__r_.__value_.__r.__words[2]);
      if ((v110.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v110.__r_.__value_.__l.__size_;
      if (size)
      {
        std::string::append(&v110, "|", 1uLL);
        v30 = __dst[23];
        v32 = *(_QWORD *)&__dst[8];
        v31 = __dst[23];
      }
      *((_BYTE *)&v107.__r_.__value_.__s + 23) = 2;
      strcpy((char *)&v107, ".*");
      if (v31 >= 0)
        v35 = __dst;
      else
        v35 = *(const std::string::value_type **)__dst;
      if (v31 >= 0)
        v36 = v30;
      else
        v36 = v32;
      v37 = std::string::append(&v107, v35, v36);
      v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v108.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v108.__r_.__value_.__l.__data_ = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      v106 = 2;
      strcpy(__s, ".*");
      v39 = std::string::append(&v108, __s, 2uLL);
      v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      *(_QWORD *)&v109[16] = *((_QWORD *)&v39->__r_.__value_.__l + 2);
      *(_OWORD *)v109 = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      if (v109[23] >= 0)
        v41 = v109;
      else
        v41 = *(const std::string::value_type **)v109;
      if (v109[23] >= 0)
        v42 = v109[23];
      else
        v42 = *(_QWORD *)&v109[8];
      std::string::append(&v110, v41, v42);
      if ((v109[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)v109);
        if (v106 < 0)
          goto LABEL_90;
LABEL_81:
        if ((SHIBYTE(v108.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_82;
LABEL_91:
        operator delete(v108.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v107.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_83:
          v31 = __dst[23];
          goto LABEL_84;
        }
      }
      else
      {
        if ((v106 & 0x80000000) == 0)
          goto LABEL_81;
LABEL_90:
        operator delete(*(void **)__s);
        if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_91;
LABEL_82:
        if ((SHIBYTE(v107.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_83;
      }
      operator delete(v107.__r_.__value_.__l.__data_);
      goto LABEL_83;
    }
LABEL_84:
    if (v31 < 0)
    {
      operator delete(*(void **)__dst);
      if (!v22)
      {
LABEL_44:
        v25 = xpc_null_create();
        goto LABEL_45;
      }
    }
    else if (!v22)
    {
      goto LABEL_44;
    }
    xpc_retain(v22);
    v25 = v22;
LABEL_45:
    xpc_release(v25);
  }
  xpc_release(v22);
  v43 = v90[14];
  if (v43)
  {
    dispatch_retain(v90[14]);
    dispatch_group_enter(v43);
  }
  v108.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v108.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v44 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  v45 = xmmword_1ED1146C0;
  if (!(_QWORD)xmmword_1ED1146C0)
  {
    ctu::XpcJetsamAssertion::create_default_global(v44);
    v46 = *(_OWORD *)__dst;
    *(_QWORD *)__dst = 0;
    *(_QWORD *)&__dst[8] = 0;
    v47 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1146C0 + 1);
    xmmword_1ED1146C0 = v46;
    if (v47)
    {
      v48 = (unint64_t *)&v47->__shared_owners_;
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    v50 = *(std::__shared_weak_count **)&__dst[8];
    if (*(_QWORD *)&__dst[8])
    {
      v51 = (unint64_t *)(*(_QWORD *)&__dst[8] + 8);
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v45 = xmmword_1ED1146C0;
  }
  v53 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1146C0 + 1);
  *(_QWORD *)v109 = v45;
  *(_QWORD *)&v109[8] = *((_QWORD *)&xmmword_1ED1146C0 + 1);
  if (*((_QWORD *)&xmmword_1ED1146C0 + 1))
  {
    v54 = (unint64_t *)(*((_QWORD *)&xmmword_1ED1146C0 + 1) + 8);
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  v104 = 8;
  strcpy((char *)__p, "Log Move");
  ctu::XpcJetsamAssertion::createActivity();
  if (v53)
  {
    v56 = (unint64_t *)&v53->__shared_owners_;
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  memset(v109, 170, sizeof(v109));
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v102, v110.__r_.__value_.__l.__data_, v110.__r_.__value_.__l.__size_);
  else
    v102 = v110;
  *(_DWORD *)__dst = v19;
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external((std::string *)&__dst[8], v102.__r_.__value_.__l.__data_, v102.__r_.__value_.__l.__size_);
  else
    *(std::string *)&__dst[8] = v102;
  v114 = 0;
  std::vector<abm::DirectoryQuery>::vector[abi:ne180100](v109, (uint64_t)__dst, 1uLL);
  if ((__dst[31] & 0x80000000) != 0)
    operator delete(*(void **)&__dst[8]);
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v102.__r_.__value_.__l.__data_);
  memset(__dst, 170, 16);
  abm::findFiles((unsigned int **)v109, 1u, (char ***)__dst);
  v58 = *(_QWORD *)__dst;
  v59 = **(_QWORD **)__dst;
  v60 = MEMORY[0x1E0C809B0];
  while (v59 != *(_QWORD *)(*(_QWORD *)__dst + 8))
  {
    block[0] = v60;
    block[1] = 3321888768;
    block[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_12;
    block[3] = &__block_descriptor_96_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE72c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE_e5_v8__0l;
    v62 = *(_QWORD *)(a1 + 40);
    v61 = *(std::__shared_weak_count **)(a1 + 48);
    block[4] = v90;
    block[5] = v62;
    v98 = v61;
    if (v61)
    {
      p_shared_weak_owners = (unint64_t *)&v61->__shared_weak_owners_;
      do
        v64 = __ldxr(p_shared_weak_owners);
      while (__stxr(v64 + 1, p_shared_weak_owners));
    }
    group = v43;
    if (v43)
    {
      dispatch_retain(v43);
      if (group)
        dispatch_group_enter(group);
    }
    v100 = v59;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v101, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    else
      v101 = buf;
    dispatch_async(v90[17], block);
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v101.__r_.__value_.__l.__data_);
      v65 = group;
      if (group)
      {
LABEL_141:
        dispatch_group_leave(v65);
        if (group)
          dispatch_release(group);
      }
    }
    else
    {
      v65 = group;
      if (group)
        goto LABEL_141;
    }
    if (v98)
      std::__shared_weak_count::__release_weak(v98);
    v59 += 16;
    v58 = *(_QWORD *)__dst;
  }
  v66 = v90[14];
  v67 = v90[11];
  v91[0] = v60;
  v91[1] = 3321888768;
  v91[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_15;
  v91[3] = &__block_descriptor_88_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
  v69 = *(_QWORD *)(a1 + 40);
  v68 = *(std::__shared_weak_count **)(a1 + 48);
  v91[4] = v90;
  v91[5] = v69;
  v92 = v68;
  if (v68)
  {
    v70 = (unint64_t *)&v68->__shared_weak_owners_;
    do
      v71 = __ldxr(v70);
    while (__stxr(v71 + 1, v70));
  }
  v93 = v58;
  v94 = *(std::__shared_weak_count **)&__dst[8];
  if (*(_QWORD *)&__dst[8])
  {
    v72 = (unint64_t *)(*(_QWORD *)&__dst[8] + 8);
    do
      v73 = __ldxr(v72);
    while (__stxr(v73 + 1, v72));
  }
  v74 = *(void **)(a1 + 64);
  if (v74)
    v74 = _Block_copy(v74);
  v75 = *(NSObject **)(a1 + 72);
  aBlock = v74;
  object = v75;
  if (v75)
    dispatch_retain(v75);
  dispatch_group_notify(v66, v67, v91);
  if (object)
    dispatch_release(object);
  if (aBlock)
    _Block_release(aBlock);
  v76 = v94;
  if (v94)
  {
    v77 = (unint64_t *)&v94->__shared_owners_;
    do
      v78 = __ldaxr(v77);
    while (__stlxr(v78 - 1, v77));
    if (!v78)
    {
      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
      std::__shared_weak_count::__release_weak(v76);
    }
  }
  if (v92)
    std::__shared_weak_count::__release_weak(v92);
  v79 = *(std::__shared_weak_count **)&__dst[8];
  if (*(_QWORD *)&__dst[8])
  {
    v80 = (unint64_t *)(*(_QWORD *)&__dst[8] + 8);
    do
      v81 = __ldaxr(v80);
    while (__stlxr(v81 - 1, v80));
    if (!v81)
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
  }
  v82 = *(_QWORD *)v109;
  if (*(_QWORD *)v109)
  {
    v83 = *(_QWORD *)&v109[8];
    v84 = *(void **)v109;
    if (*(_QWORD *)&v109[8] != *(_QWORD *)v109)
    {
      do
      {
        if (*(char *)(v83 - 9) < 0)
          operator delete(*(void **)(v83 - 32));
        v83 -= 40;
      }
      while (v83 != v82);
      v84 = *(void **)v109;
    }
    *(_QWORD *)&v109[8] = v82;
    operator delete(v84);
  }
  v85 = (std::__shared_weak_count *)v108.__r_.__value_.__l.__size_;
  if (v108.__r_.__value_.__l.__size_)
  {
    v86 = (unint64_t *)(v108.__r_.__value_.__l.__size_ + 8);
    do
      v87 = __ldaxr(v86);
    while (__stlxr(v87 - 1, v86));
    if (!v87)
    {
      ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
      std::__shared_weak_count::__release_weak(v85);
    }
  }
  if (v43)
  {
    dispatch_group_leave(v43);
    dispatch_release(v43);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v110.__r_.__value_.__l.__data_);
LABEL_188:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  xpc_release(v16);
  v9 = v112;
  if (v112)
    goto LABEL_191;
}

void sub_1A34D113C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,dispatch_group_t group,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,void *a50)
{
  void *v50;
  NSObject *v51;
  uint64_t v52;

  if (a40 < 0)
    operator delete(__p);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a50);
  if (v51)
  {
    dispatch_group_leave(v51);
    dispatch_release(v51);
  }
  if (*(char *)(v52 - 209) < 0)
    operator delete(*(void **)(v52 - 232));
  if (*(char *)(v52 - 121) < 0)
    operator delete(*(void **)(v52 - 144));
  xpc_release(v50);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v52 - 208);
  _Unwind_Resume(a1);
}

void sub_1A34D1414(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_12(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  abm::FileProperties **v6;
  uint64_t *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;
  int v13;
  size_t v14;
  int v15;
  size_t size;
  unint64_t v17;
  std::string *v18;
  const void *v19;
  std::string *v20;
  unint64_t *v21;
  unint64_t v22;
  NSObject *v23;
  std::string *v24;
  std::string *p_dst;
  std::string::size_type v26;
  std::string *v27;
  std::string::size_type v28;
  std::string *v29;
  NSObject *v30;
  int v31;
  std::string::size_type v32;
  int v33;
  std::string::size_type v34;
  std::string *v35;
  std::string *v36;
  std::__fs::filesystem::path *p_to;
  uint64_t v38;
  uint64_t v39;
  int updated;
  char v41;
  unsigned int v42;
  std::string *v43;
  mode_t v44;
  NSObject *v45;
  std::string *v46;
  NSObject *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  std::string __p;
  gid_t v51;
  std::__fs::filesystem::path __to;
  std::error_code __ec;
  uint64_t v54;
  std::__shared_weak_count *v55;
  std::string __dst;
  std::string v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  std::string v60;
  std::__fs::filesystem::path *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = std::__shared_weak_count::lock(v2);
    v59 = v4;
    if (v4)
    {
      v5 = v4;
      v58 = *(_QWORD *)(a1 + 40);
      if (!v58 || (v6 = *(abm::FileProperties ***)(a1 + 64), !*v6))
      {
LABEL_97:
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v49 = __ldaxr(p_shared_owners);
        while (__stlxr(v49 - 1, p_shared_owners));
        if (!v49)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        return;
      }
      memset(&v57, 170, sizeof(v57));
      abm::FileProperties::getPath(*v6, &v57);
      memset(&__dst, 170, sizeof(__dst));
      v7 = *(uint64_t **)(a1 + 64);
      v8 = *v7;
      v9 = (std::__shared_weak_count *)v7[1];
      v54 = *v7;
      v55 = v9;
      if (v9)
      {
        v10 = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v60, *(const std::string::value_type **)(v8 + 8), *(_QWORD *)(v8 + 16));
      }
      else
      {
        v12 = *(_OWORD *)(v8 + 8);
        v60.__r_.__value_.__r.__words[2] = *(_QWORD *)(v8 + 24);
        *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v12;
      }
      v13 = *(char *)(a1 + 95);
      if (v13 >= 0)
        v14 = *(unsigned __int8 *)(a1 + 95);
      else
        v14 = *(_QWORD *)(a1 + 80);
      v15 = SHIBYTE(v60.__r_.__value_.__r.__words[2]);
      if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v60.__r_.__value_.__r.__words[2]);
      else
        size = v60.__r_.__value_.__l.__size_;
      v17 = size + v14;
      memset(&__dst, 170, sizeof(__dst));
      if (size + v14 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      if (v17 > 0x16)
      {
        v38 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v17 | 7) != 0x17)
          v38 = v17 | 7;
        v39 = v38 + 1;
        v18 = (std::string *)operator new(v38 + 1);
        __dst.__r_.__value_.__l.__size_ = size + v14;
        __dst.__r_.__value_.__r.__words[2] = v39 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
        if (!v14)
        {
LABEL_24:
          if (size)
          {
            if (v15 >= 0)
              v20 = &v60;
            else
              v20 = (std::string *)v60.__r_.__value_.__r.__words[0];
            memmove((char *)v18 + v14, v20, size);
          }
          v18->__r_.__value_.__s.__data_[v14 + size] = 0;
          if (v15 < 0)
            operator delete(v60.__r_.__value_.__l.__data_);
          if (v9)
          {
            v21 = (unint64_t *)&v9->__shared_owners_;
            do
              v22 = __ldaxr(v21);
            while (__stlxr(v22 - 1, v21));
            if (!v22)
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
          }
          v23 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            v24 = &v57;
            if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v24 = (std::string *)v57.__r_.__value_.__r.__words[0];
            p_dst = &__dst;
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
            LODWORD(v60.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v60.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
            WORD2(v60.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v60.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_dst;
            _os_log_impl(&dword_1A343C000, v23, OS_LOG_TYPE_DEFAULT, "#I Move %s to %s", (uint8_t *)&v60, 0x16u);
          }
          *(&__ec.__val_ + 1) = -1431655766;
          __ec.__val_ = 0;
          __ec.__cat_ = std::system_category();
          memset(&v60, 0, sizeof(v60));
          v26 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v27 = &v57;
          else
            v27 = (std::string *)v57.__r_.__value_.__r.__words[0];
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v26 = v57.__r_.__value_.__l.__size_;
          std::string::append[abi:ne180100]<char const*,0>((unint64_t)&v60, (char *)v27, (char *)v27 + v26);
          memset(&__to, 0, sizeof(__to));
          v28 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v29 = &__dst;
          else
            v29 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v28 = __dst.__r_.__value_.__l.__size_;
          std::string::append[abi:ne180100]<char const*,0>((unint64_t)&__to, (char *)v29, (char *)v29 + v28);
          std::__fs::filesystem::__copy((const std::__fs::filesystem::path *)&v60, &__to, recursive|update_existing, &__ec);
          if (SHIBYTE(__to.__pn_.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__to.__pn_.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_54:
              if (__ec.__val_)
                goto LABEL_55;
              goto LABEL_71;
            }
          }
          else if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_54;
          }
          operator delete(v60.__r_.__value_.__l.__data_);
          if (__ec.__val_)
          {
LABEL_55:
            v30 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              v31 = SHIBYTE(v57.__r_.__value_.__r.__words[2]);
              v32 = v57.__r_.__value_.__r.__words[0];
              v33 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
              v34 = __dst.__r_.__value_.__r.__words[0];
              std::error_code::message(&__to.__pn_, &__ec);
              v35 = &__dst;
              if (v33 < 0)
                v35 = (std::string *)v34;
              v36 = &v57;
              if (v31 < 0)
                v36 = (std::string *)v32;
              LODWORD(v60.__r_.__value_.__l.__data_) = 136315650;
              if ((__to.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                p_to = &__to;
              else
                p_to = (std::__fs::filesystem::path *)__to.__pn_.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v60.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
              WORD2(v60.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v60.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
              HIWORD(v60.__r_.__value_.__r.__words[2]) = 2080;
              v61 = p_to;
              _os_log_error_impl(&dword_1A343C000, v30, OS_LOG_TYPE_ERROR, "Failed to copy from %s to %s: %s\n", (uint8_t *)&v60, 0x20u);
              if (SHIBYTE(__to.__pn_.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__to.__pn_.__r_.__value_.__l.__data_);
            }
            goto LABEL_91;
          }
LABEL_71:
          v51 = -1431655766;
          LODWORD(__to.__pn_.__r_.__value_.__l.__data_) = -1431655766;
          if (support::fs::getUidGid(1, (uid_t *)&__to, &v51))
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            else
              __p = __dst;
            updated = support::fs::updateOwner((const char *)&__p, LODWORD(__to.__pn_.__r_.__value_.__l.__data_), v51);
            v41 = updated;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__p.__r_.__value_.__l.__data_);
              if ((v41 & 1) != 0)
              {
LABEL_77:
                v42 = support::fs::isDir((const char *)&__dst);
                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v43 = &__dst;
                else
                  v43 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                if (v42)
                  v44 = 495;
                else
                  v44 = 422;
                if (chmod((const char *)v43, v44))
                {
                  v45 = *(NSObject **)(v3 + 40);
                  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
                  {
                    v46 = &__dst;
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                      v46 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                    LODWORD(v60.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)v60.__r_.__value_.__r.__words + 4) = (std::string::size_type)v46;
                    _os_log_error_impl(&dword_1A343C000, v45, OS_LOG_TYPE_ERROR, "Failed to change file permission: %s", (uint8_t *)&v60, 0xCu);
                  }
                }
                goto LABEL_91;
              }
            }
            else if (updated)
            {
              goto LABEL_77;
            }
          }
          v47 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v60.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl(&dword_1A343C000, v47, OS_LOG_TYPE_ERROR, "Failed to update owner", (uint8_t *)&v60, 2u);
          }
LABEL_91:
          abm::LogManagementTask::remove_sync(v3, (std::string::size_type)&v57);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v57.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_93:
              v5 = v59;
              if (!v59)
                return;
              goto LABEL_97;
            }
          }
          else if ((SHIBYTE(v57.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_93;
          }
          operator delete(v57.__r_.__value_.__l.__data_);
          v5 = v59;
          if (!v59)
            return;
          goto LABEL_97;
        }
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        v18 = &__dst;
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = size + v14;
        if (!v14)
          goto LABEL_24;
      }
      if (v13 >= 0)
        v19 = (const void *)(a1 + 72);
      else
        v19 = *(const void **)(a1 + 72);
      memmove(v18, v19, v14);
      goto LABEL_24;
    }
  }
}

void sub_1A34D1A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  if (a32 < 0)
  {
    operator delete(__p);
    if ((a38 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a38 & 0x80000000) == 0)
  {
LABEL_3:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a39);
    _Unwind_Resume(a1);
  }
  operator delete(a33);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a39);
  _Unwind_Resume(a1);
}

void sub_1A34D1AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_1A34D1AD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v29;

  if (*(char *)(v29 - 121) < 0)
    operator delete(*(void **)(v29 - 144));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a29 < 0)
    JUMPOUT(0x1A34D1AA8);
  JUMPOUT(0x1A34D1A90);
}

BOOL abm::LogManagementTask::remove_sync(uint64_t a1, std::string::size_type a2)
{
  uint64_t v4;
  char *v5;
  int val;
  NSObject *v7;
  NSObject *v8;
  std::__fs::filesystem::path *v9;
  std::string::size_type v10;
  std::error_code v12;
  uint8_t buf[4];
  std::string::size_type v14;
  __int16 v15;
  std::__fs::filesystem::path *v16;
  std::__fs::filesystem::path v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v12.__val_ = 0xAAAAAAAA00000000;
  v12.__cat_ = std::system_category();
  memset(&v17, 0, sizeof(v17));
  v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) == 0)
    v5 = (char *)a2;
  else
    v5 = *(char **)a2;
  if ((v4 & 0x80u) != 0)
    v4 = *(_QWORD *)(a2 + 8);
  std::string::append[abi:ne180100]<char const*,0>((unint64_t)&v17, v5, &v5[v4]);
  std::__fs::filesystem::__remove_all(&v17, &v12);
  if (SHIBYTE(v17.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v17.__pn_.__r_.__value_.__l.__data_);
    val = v12.__val_;
    v7 = *(NSObject **)(a1 + 40);
    v8 = v7;
    if (v12.__val_)
    {
LABEL_8:
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) < 0)
          a2 = *(_QWORD *)a2;
        std::error_code::message(&v17.__pn_, &v12);
        if ((v17.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v9 = &v17;
        else
          v9 = (std::__fs::filesystem::path *)v17.__pn_.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 136315394;
        v14 = a2;
        v15 = 2080;
        v16 = v9;
        _os_log_error_impl(&dword_1A343C000, v7, OS_LOG_TYPE_ERROR, "Failed to remove %s: %s\n", buf, 0x16u);
        if (SHIBYTE(v17.__pn_.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v17.__pn_.__r_.__value_.__l.__data_);
      }
      return val == 0;
    }
  }
  else
  {
    val = v12.__val_;
    v7 = *(NSObject **)(a1 + 40);
    v8 = v7;
    if (v12.__val_)
      goto LABEL_8;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0)
      v10 = a2;
    else
      v10 = *(_QWORD *)a2;
    LODWORD(v17.__pn_.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v17.__pn_.__r_.__value_.__r.__words + 4) = v10;
    _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I File removed: %s\n", (uint8_t *)&v17, 0xCu);
  }
  return val == 0;
}

void sub_1A34D1CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE72c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(std::string *a1, uint64_t a2)
{
  std::string::size_type v4;
  unint64_t *v5;
  unint64_t v6;
  NSObject *v7;
  NSObject *size;
  std::string *v9;
  __int128 v10;

  v4 = *(_QWORD *)(a2 + 48);
  a1[1].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 40);
  a1[2].__r_.__value_.__r.__words[0] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(NSObject **)(a2 + 56);
  a1[2].__r_.__value_.__l.__size_ = (std::string::size_type)v7;
  if (v7)
  {
    dispatch_retain(v7);
    size = a1[2].__r_.__value_.__l.__size_;
    if (size)
      dispatch_group_enter(size);
  }
  v9 = a1 + 3;
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a2 + 72), *(_QWORD *)(a2 + 80));
  }
  else
  {
    v10 = *(_OWORD *)(a2 + 72);
    a1[3].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 88);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
}

void sub_1A34D1D70(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;

  v3 = *(NSObject **)(v1 + 56);
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = *(NSObject **)(v1 + 56);
    if (v4)
      dispatch_release(v4);
  }
  v5 = *(std::__shared_weak_count **)(v1 + 48);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE72c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  if (*(char *)(a1 + 95) < 0)
  {
    operator delete(*(void **)(a1 + 72));
    v2 = *(NSObject **)(a1 + 56);
    if (!v2)
      goto LABEL_7;
  }
  else
  {
    v2 = *(NSObject **)(a1 + 56);
    if (!v2)
      goto LABEL_7;
  }
  dispatch_group_leave(v2);
  v3 = *(NSObject **)(a1 + 56);
  if (v3)
    dispatch_release(v3);
LABEL_7:
  v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_15(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t i;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  NSObject *v12;
  xpc_object_t v13;
  const void *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD v20[4];
  void *aBlock;
  xpc_object_t object;
  int v23;

  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return;
  v5 = v4;
  if (a1[5])
  {
    v6 = (uint64_t *)a1[7];
    if (v6)
    {
      v7 = *v6;
      for (i = v6[1]; i != v7; i -= 16)
      {
        v9 = *(std::__shared_weak_count **)(i - 8);
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }
      v6[1] = v7;
    }
    v12 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20[0]) = 0;
      _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Moving Done", (uint8_t *)v20, 2u);
    }
    v13 = xpc_null_create();
    v14 = (const void *)a1[9];
    if (v14)
      v15 = _Block_copy(v14);
    else
      v15 = 0;
    v16 = a1[10];
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3321888768;
    v20[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    v20[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v15)
    {
      v17 = _Block_copy(v15);
      v23 = 0;
      aBlock = v17;
      object = v13;
      if (v13)
      {
LABEL_21:
        xpc_retain(v13);
LABEL_24:
        dispatch_async(v16, v20);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v15)
          _Block_release(v15);
        xpc_release(v13);
        goto LABEL_29;
      }
    }
    else
    {
      v23 = 0;
      aBlock = 0;
      object = v13;
      if (v13)
        goto LABEL_21;
    }
    object = xpc_null_create();
    goto LABEL_24;
  }
LABEL_29:
  v18 = (unint64_t *)&v5->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  void *v10;
  NSObject *v11;

  v4 = a2[6];
  a1[5] = a2[5];
  a1[6] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = a2[8];
  a1[7] = a2[7];
  a1[8] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = (void *)a2[9];
  if (v10)
    v10 = _Block_copy(v10);
  v11 = a2[10];
  a1[9] = v10;
  a1[10] = v11;
  if (v11)
    dispatch_retain(v11);
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(_QWORD *a1)
{
  NSObject *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;

  v2 = a1[10];
  if (v2)
    dispatch_release(v2);
  v3 = (const void *)a1[9];
  if (v3)
    _Block_release(v3);
  v4 = (std::__shared_weak_count *)a1[8];
  if (!v4)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (v6)
  {
LABEL_9:
    v7 = (std::__shared_weak_count *)a1[6];
    if (!v7)
      return;
    goto LABEL_10;
  }
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  v7 = (std::__shared_weak_count *)a1[6];
  if (v7)
LABEL_10:
    std::__shared_weak_count::__release_weak(v7);
}

void **std::vector<abm::DirectoryQuery>::~vector[abi:ne180100](void **a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = (void **)*a1;
  if (*a1)
  {
    v3 = (void **)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 9) < 0)
          operator delete(*(v3 - 4));
        v3 -= 5;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  void *v7;
  void *v8;
  NSObject *v9;

  v4 = a2[6];
  a1[5] = a2[5];
  a1[6] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (void *)a2[7];
  a1[7] = v7;
  if (!v7)
  {
    a1[7] = xpc_null_create();
    v8 = (void *)a2[8];
    if (!v8)
      goto LABEL_9;
    goto LABEL_8;
  }
  xpc_retain(v7);
  v8 = (void *)a2[8];
  if (v8)
LABEL_8:
    v8 = _Block_copy(v8);
LABEL_9:
  v9 = a2[9];
  a1[8] = v8;
  a1[9] = v9;
  if (v9)
    dispatch_retain(v9);
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(uint64_t a1)
{
  NSObject *v2;
  const void *v3;
  std::__shared_weak_count *v4;

  v2 = *(NSObject **)(a1 + 72);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 64);
  if (v3)
    _Block_release(v3);
  xpc_release(*(xpc_object_t *)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_18(_QWORD *a1, uint64_t a2, void **a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  void *v17;
  void *v18;
  NSObject *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  _QWORD v22[6];
  std::__shared_weak_count *v23;
  xpc_object_t v24;
  void *aBlock;
  dispatch_object_t object;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v8 = a1[4];
    v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      v10 = v9;
      v11 = a1[5];
      if (!v11)
      {
LABEL_20:
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      v12 = *(NSObject **)(v8 + 112);
      v13 = *(NSObject **)(v8 + 88);
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3321888768;
      v22[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2_19;
      v22[3] = &__block_descriptor_80_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
      v22[4] = v8;
      v22[5] = v11;
      v14 = (std::__shared_weak_count *)a1[6];
      v23 = v14;
      if (v14)
      {
        p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
        do
          v16 = __ldxr(p_shared_weak_owners);
        while (__stxr(v16 + 1, p_shared_weak_owners));
      }
      v17 = *a3;
      v24 = v17;
      if (v17)
      {
        xpc_retain(v17);
        v18 = *(void **)a4;
        if (!*(_QWORD *)a4)
          goto LABEL_12;
      }
      else
      {
        v24 = xpc_null_create();
        v18 = *(void **)a4;
        if (!*(_QWORD *)a4)
        {
LABEL_12:
          v19 = *(NSObject **)(a4 + 8);
          aBlock = v18;
          object = v19;
          if (v19)
            dispatch_retain(v19);
          dispatch_group_notify(v12, v13, v22);
          if (object)
            dispatch_release(object);
          if (aBlock)
            _Block_release(aBlock);
          xpc_release(v24);
          v24 = 0;
          if (v23)
            std::__shared_weak_count::__release_weak(v23);
          goto LABEL_20;
        }
      }
      v18 = _Block_copy(v18);
      goto LABEL_12;
    }
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2_19(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  xpc_object_t value;
  xpc_object_t v5;
  std::__shared_weak_count *v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  __int128 v10;
  xpc_object_t v11;
  void *v12;
  size_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  size_t count;
  xpc_object_t v17;
  xpc_object_t v18;
  char *v19;
  std::sub_match<const char *> *v20;
  std::sub_match<std::__wrap_iter<const char *>> *v21;
  __int128 v22;
  int v23;
  int v24;
  unint64_t v25;
  std::__wrap_iter<const char *> v26;
  std::__wrap_iter<const char *> v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::string::size_type size;
  char *v32;
  size_t v33;
  int v34;
  size_t v35;
  unint64_t v36;
  size_t v37;
  _BYTE *v38;
  _BYTE *v39;
  void **v40;
  std::string *v41;
  __int128 v42;
  const std::string::value_type *v43;
  std::string::size_type v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  ctu::XpcJetsamAssertion *v48;
  uint64_t v49;
  __int128 v50;
  std::__shared_weak_count *v51;
  unint64_t *p_shared_owners;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  NSObject *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  uint64_t v67;
  unint64_t *p_shared_weak_owners;
  unint64_t v69;
  NSObject *v70;
  NSObject *v71;
  std::__shared_weak_count *v72;
  uint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  void *v78;
  NSObject *v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  unint64_t *v95;
  unint64_t v96;
  xpc_object_t v97;
  uint64_t v98;
  NSObject **v99;
  _QWORD v100[6];
  std::__shared_weak_count *v101;
  uint64_t v102;
  std::__shared_weak_count *v103;
  void *aBlock;
  dispatch_object_t v105;
  _QWORD block[6];
  std::__shared_weak_count *v107;
  dispatch_group_t group;
  uint64_t v109;
  std::string v110;
  std::string v111;
  std::string v112;
  std::string v113;
  char v114[24];
  std::string::value_type __s[8];
  char v116;
  void *v117[3];
  std::string v118;
  std::locale v119[2];
  __int128 v120;
  __int128 v121;
  __int128 v122;
  std::__shared_weak_count *v124;
  _BYTE __p[48];
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  __int128 v131;
  uint64_t v132;
  _BYTE object[48];
  std::string v134;
  uint64_t v135;
  uint64_t v136;
  std::string v137;
  int v138;
  int v139;
  std::string v140;
  int v141;
  uint64_t v142;

  v1 = a1;
  v142 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2)
    return;
  v99 = *(NSObject ***)(v1 + 32);
  v3 = std::__shared_weak_count::lock(v2);
  v124 = v3;
  if (!v3)
    return;
  if (!*(_QWORD *)(v1 + 40))
  {
    v6 = v3;
    goto LABEL_219;
  }
  value = xpc_dictionary_get_value(*(xpc_object_t *)(v1 + 56), "MatchingPattern");
  v5 = value;
  if (value)
    xpc_retain(value);
  else
    v5 = xpc_null_create();
  v7 = xpc_null_create();
  if (v5 && MEMORY[0x1A85902BC](v5) == MEMORY[0x1E0C812C8])
  {
    xpc_retain(v5);
    v8 = v5;
  }
  else
  {
    v8 = xpc_null_create();
  }
  if (MEMORY[0x1A85902BC](v8) != MEMORY[0x1E0C812C8])
  {
    if (v7)
    {
      xpc_retain(v7);
      v9 = v7;
    }
    else
    {
      v9 = xpc_null_create();
    }
    xpc_release(v8);
    v8 = v9;
  }
  xpc_release(v7);
  xpc_release(v5);
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v121 = v10;
  v122 = v10;
  *(_OWORD *)&v119[0].__locale_ = v10;
  v120 = v10;
  v97 = v8;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)v119, "[0-9]{4}.[0-9]{2}.[0-9]{2}.[0-9]{2}.[0-9]{2}.[0-9]{2}", 0);
  v118.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v118.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
  v118.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
  if (v8)
  {
    xpc_retain(v8);
    v11 = v8;
  }
  else
  {
    v11 = xpc_null_create();
    if (!v11)
    {
      v11 = xpc_null_create();
      v12 = 0;
      goto LABEL_21;
    }
  }
  xpc_retain(v11);
  v12 = v11;
LABEL_21:
  xpc_release(v12);
  v13 = 0;
  v98 = v1;
  while (1)
  {
    if (v8)
    {
      xpc_retain(v8);
      v15 = v8;
    }
    else
    {
      v15 = xpc_null_create();
    }
    if (MEMORY[0x1A85902BC](v8) == MEMORY[0x1E0C812C8])
    {
      count = xpc_array_get_count(v8);
      if (!v15)
      {
LABEL_31:
        v17 = xpc_null_create();
        goto LABEL_32;
      }
    }
    else
    {
      count = 0;
      if (!v15)
        goto LABEL_31;
    }
    xpc_retain(v15);
    v17 = v15;
LABEL_32:
    xpc_release(v15);
    xpc_release(v17);
    if (v13 == count && v11 == v17)
      break;
    memset(v117, 170, sizeof(v117));
    v18 = xpc_array_get_value(v11, v13);
    *(_QWORD *)object = v18;
    if (v18)
      xpc_retain(v18);
    else
      *(_QWORD *)object = xpc_null_create();
    xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)object);
    v19 = (char *)HIBYTE(v117[2]);
    if (SHIBYTE(v117[2]) < 0)
      v19 = (char *)v117[1];
    if (!v19)
      goto LABEL_88;
    if (SHIBYTE(v117[2]) >= 0)
      v20 = (std::sub_match<const char *> *)v117;
    else
      v20 = (std::sub_match<const char *> *)v117[0];
    v21 = (std::sub_match<std::__wrap_iter<const char *>> *)&v19[(_QWORD)v20];
    *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v131 = v22;
    v128 = 0xAAAAAAAAAAAAAA00;
    *(_QWORD *)&__p[40] = 0xAAAAAAAAAAAAAAAALL;
    v126 = 0;
    v127 = 0;
    v129 = 0;
    v130 = 0;
    LOBYTE(v131) = 0;
    BYTE8(v131) = 0;
    v132 = 0;
    memset(__p, 0, 41);
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v22;
    v134.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&object[40] = 0xAAAAAAAAAAAAAAAALL;
    memset(&v134, 0, 17);
    v135 = 0;
    v136 = 0;
    v137.__r_.__value_.__s.__data_[0] = 0;
    v137.__r_.__value_.__s.__data_[8] = 0;
    v137.__r_.__value_.__r.__words[2] = 0;
    memset(object, 0, 41);
    v23 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)v119, v20, (std::sub_match<const char *> *)&v19[(_QWORD)v20], (std::vector<std::csub_match> *)object, 4160);
    std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)__p, (uint64_t)v20, v21, (uint64_t *)object, 0);
    if (*(_QWORD *)object)
    {
      *(_QWORD *)&object[8] = *(_QWORD *)object;
      operator delete(*(void **)object);
    }
    if ((_BYTE)v131)
      v24 = v23 ^ 1;
    else
      v24 = 1;
    if (*(_QWORD *)__p)
    {
      *(_QWORD *)&__p[8] = *(_QWORD *)__p;
      operator delete(*(void **)__p);
    }
    if ((v23 & v24 & 1) == 0)
    {
LABEL_88:
      if ((SHIBYTE(v117[2]) & 0x80000000) == 0)
        goto LABEL_89;
      goto LABEL_98;
    }
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)object, "-|_", 0);
    memset(__p, 0, 24);
    v25 = HIBYTE(v117[2]);
    if (SHIBYTE(v117[2]) >= 0)
      v26.__i_ = (std::__wrap_iter<const char *>::iterator_type)v117;
    else
      v26.__i_ = (std::__wrap_iter<const char *>::iterator_type)v117[0];
    if (SHIBYTE(v117[2]) < 0)
      v25 = (unint64_t)v117[1];
    v27.__i_ = &v26.__i_[v25];
    std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>((std::string *)__p, v26, v27, (const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *)object, ".", 0);
    if (SHIBYTE(v117[2]) < 0)
      operator delete(v117[0]);
    *(_OWORD *)v117 = *(_OWORD *)__p;
    v117[2] = *(void **)&__p[16];
    __p[23] = 0;
    __p[0] = 0;
    v28 = (std::__shared_weak_count *)v134.__r_.__value_.__r.__words[0];
    if (v134.__r_.__value_.__r.__words[0])
    {
      v29 = (unint64_t *)(v134.__r_.__value_.__r.__words[0] + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    std::locale::~locale((std::locale *)object);
    size = HIBYTE(v118.__r_.__value_.__r.__words[2]);
    if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v118.__r_.__value_.__l.__size_;
    if (size)
      std::string::append(&v118, "|", 1uLL);
    v32 = abm::trace::kLogDirPrefix[0];
    v33 = strlen(abm::trace::kLogDirPrefix[0]);
    v34 = SHIBYTE(v117[2]);
    if (SHIBYTE(v117[2]) >= 0)
      v35 = HIBYTE(v117[2]);
    else
      v35 = (size_t)v117[1];
    v36 = v35 + v33;
    memset(__p, 170, 24);
    if (v35 + v33 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v37 = v33;
    if (v36 <= 0x16)
    {
      memset(__p, 0, 24);
      v38 = __p;
      __p[23] = v35 + v33;
      if (!v33)
        goto LABEL_74;
LABEL_73:
      memcpy(v38, v32, v37);
      goto LABEL_74;
    }
    v45 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17)
      v45 = v36 | 7;
    v46 = v45 + 1;
    v38 = operator new(v45 + 1);
    *(_QWORD *)&__p[16] = v46 | 0x8000000000000000;
    *(_QWORD *)__p = v38;
    *(_QWORD *)&__p[8] = v36;
    v8 = v97;
    if (v37)
      goto LABEL_73;
LABEL_74:
    v39 = &v38[v37];
    if (v35)
    {
      if (v34 >= 0)
        v40 = v117;
      else
        v40 = (void **)v117[0];
      memmove(v39, v40, v35);
    }
    v39[v35] = 0;
    v116 = 2;
    strcpy(__s, ".*");
    v41 = std::string::append((std::string *)__p, __s, 2uLL);
    v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
    *(_QWORD *)&object[16] = *((_QWORD *)&v41->__r_.__value_.__l + 2);
    *(_OWORD *)object = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    if (object[23] >= 0)
      v43 = object;
    else
      v43 = *(const std::string::value_type **)object;
    if (object[23] >= 0)
      v44 = object[23];
    else
      v44 = *(_QWORD *)&object[8];
    std::string::append(&v118, v43, v44);
    v1 = v98;
    if ((object[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)object);
      if ((v116 & 0x80000000) == 0)
      {
LABEL_87:
        if ((__p[23] & 0x80000000) == 0)
          goto LABEL_88;
        goto LABEL_97;
      }
    }
    else if ((v116 & 0x80000000) == 0)
    {
      goto LABEL_87;
    }
    operator delete(*(void **)__s);
    if ((__p[23] & 0x80000000) == 0)
      goto LABEL_88;
LABEL_97:
    operator delete(*(void **)__p);
    if ((SHIBYTE(v117[2]) & 0x80000000) == 0)
    {
LABEL_89:
      if (!v11)
        goto LABEL_22;
      goto LABEL_99;
    }
LABEL_98:
    operator delete(v117[0]);
    if (!v11)
    {
LABEL_22:
      v14 = xpc_null_create();
      goto LABEL_23;
    }
LABEL_99:
    xpc_retain(v11);
    v14 = v11;
LABEL_23:
    ++v13;
    xpc_release(v14);
  }
  xpc_release(v11);
  v47 = v99[14];
  if (v47)
  {
    dispatch_retain(v99[14]);
    dispatch_group_enter(v47);
  }
  v117[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  v117[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v48 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  v49 = xmmword_1ED1146C0;
  if (!(_QWORD)xmmword_1ED1146C0)
  {
    ctu::XpcJetsamAssertion::create_default_global(v48);
    v50 = *(_OWORD *)object;
    *(_QWORD *)&object[8] = 0;
    *(_QWORD *)object = 0;
    v51 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1146C0 + 1);
    xmmword_1ED1146C0 = v50;
    if (v51)
    {
      p_shared_owners = (unint64_t *)&v51->__shared_owners_;
      do
        v53 = __ldaxr(p_shared_owners);
      while (__stlxr(v53 - 1, p_shared_owners));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
    v54 = *(std::__shared_weak_count **)&object[8];
    if (*(_QWORD *)&object[8])
    {
      v55 = (unint64_t *)(*(_QWORD *)&object[8] + 8);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      if (!v56)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
    v49 = xmmword_1ED1146C0;
  }
  v57 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1146C0 + 1);
  *(_QWORD *)__p = v49;
  *(_QWORD *)&__p[8] = *((_QWORD *)&xmmword_1ED1146C0 + 1);
  if (*((_QWORD *)&xmmword_1ED1146C0 + 1))
  {
    v58 = (unint64_t *)(*((_QWORD *)&xmmword_1ED1146C0 + 1) + 8);
    do
      v59 = __ldxr(v58);
    while (__stxr(v59 + 1, v58));
  }
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  v114[23] = 10;
  strcpy(v114, "Log Delete");
  ctu::XpcJetsamAssertion::createActivity();
  if (v57)
  {
    v60 = (unint64_t *)&v57->__shared_owners_;
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  v62 = v99[5];
  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)object = 0;
    _os_log_impl(&dword_1A343C000, v62, OS_LOG_TYPE_DEFAULT, "#I Deleting Telephony and Baseband logs", object, 2u);
  }
  memset(__p, 170, 24);
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v113, v118.__r_.__value_.__l.__data_, v118.__r_.__value_.__l.__size_);
  else
    v113 = v118;
  *(_DWORD *)object = 4;
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external((std::string *)&object[8], v113.__r_.__value_.__l.__data_, v113.__r_.__value_.__l.__size_);
  else
    *(std::string *)&object[8] = v113;
  *(_DWORD *)&object[32] = 0;
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v112, v118.__r_.__value_.__l.__data_, v118.__r_.__value_.__l.__size_);
  else
    v112 = v118;
  *(_DWORD *)&object[40] = 3;
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v134, v112.__r_.__value_.__l.__data_, v112.__r_.__value_.__l.__size_);
  else
    v134 = v112;
  LODWORD(v135) = 0;
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v111, v118.__r_.__value_.__l.__data_, v118.__r_.__value_.__l.__size_);
  else
    v111 = v118;
  LODWORD(v136) = 5;
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v137, v111.__r_.__value_.__l.__data_, v111.__r_.__value_.__l.__size_);
  else
    v137 = v111;
  v138 = 0;
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v110, v118.__r_.__value_.__l.__data_, v118.__r_.__value_.__l.__size_);
  else
    v110 = v118;
  v139 = 6;
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v140, v110.__r_.__value_.__l.__data_, v110.__r_.__value_.__l.__size_);
  else
    v140 = v110;
  v141 = 0;
  std::vector<abm::DirectoryQuery>::vector[abi:ne180100](__p, (uint64_t)object, 4uLL);
  if ((SHIBYTE(v140.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v137.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_150;
LABEL_225:
    operator delete(v137.__r_.__value_.__l.__data_);
    if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_226;
LABEL_151:
    if ((object[31] & 0x80000000) == 0)
      goto LABEL_152;
LABEL_227:
    operator delete(*(void **)&object[8]);
    if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_228;
LABEL_153:
    if ((SHIBYTE(v111.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_154;
LABEL_229:
    operator delete(v111.__r_.__value_.__l.__data_);
    if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_230;
LABEL_155:
    if ((SHIBYTE(v113.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_156;
LABEL_231:
    operator delete(v113.__r_.__value_.__l.__data_);
    goto LABEL_156;
  }
  operator delete(v140.__r_.__value_.__l.__data_);
  if (SHIBYTE(v137.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_225;
LABEL_150:
  if ((SHIBYTE(v134.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_151;
LABEL_226:
  operator delete(v134.__r_.__value_.__l.__data_);
  if ((object[31] & 0x80000000) != 0)
    goto LABEL_227;
LABEL_152:
  if ((SHIBYTE(v110.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_153;
LABEL_228:
  operator delete(v110.__r_.__value_.__l.__data_);
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_229;
LABEL_154:
  if ((SHIBYTE(v112.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_155;
LABEL_230:
  operator delete(v112.__r_.__value_.__l.__data_);
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_231;
LABEL_156:
  memset(object, 170, 16);
  abm::findFiles((unsigned int **)__p, 1u, (char ***)object);
  v63 = *(_QWORD *)object;
  v64 = **(_QWORD **)object;
  if (**(_QWORD **)object != *(_QWORD *)(*(_QWORD *)object + 8))
  {
    v65 = MEMORY[0x1E0C809B0];
    do
    {
      block[0] = v65;
      block[1] = 3321888768;
      block[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_24;
      block[3] = &__block_descriptor_72_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE_e5_v8__0l;
      v67 = *(_QWORD *)(v1 + 40);
      v66 = *(std::__shared_weak_count **)(v1 + 48);
      block[4] = v99;
      block[5] = v67;
      v107 = v66;
      if (v66)
      {
        p_shared_weak_owners = (unint64_t *)&v66->__shared_weak_owners_;
        do
          v69 = __ldxr(p_shared_weak_owners);
        while (__stxr(v69 + 1, p_shared_weak_owners));
      }
      group = v47;
      if (v47)
      {
        dispatch_retain(v47);
        if (group)
          dispatch_group_enter(group);
      }
      v109 = v64;
      dispatch_async(v99[17], block);
      if (group)
      {
        dispatch_group_leave(group);
        if (group)
          dispatch_release(group);
      }
      if (v107)
        std::__shared_weak_count::__release_weak(v107);
      v64 += 16;
      v63 = *(_QWORD *)object;
    }
    while (v64 != *(_QWORD *)(*(_QWORD *)object + 8));
  }
  v70 = v99[14];
  v71 = v99[11];
  v100[0] = MEMORY[0x1E0C809B0];
  v100[1] = 3321888768;
  v100[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_26;
  v100[3] = &__block_descriptor_88_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
  v73 = *(_QWORD *)(v1 + 40);
  v72 = *(std::__shared_weak_count **)(v1 + 48);
  v100[4] = v99;
  v100[5] = v73;
  v101 = v72;
  if (v72)
  {
    v74 = (unint64_t *)&v72->__shared_weak_owners_;
    do
      v75 = __ldxr(v74);
    while (__stxr(v75 + 1, v74));
  }
  v102 = v63;
  v103 = *(std::__shared_weak_count **)&object[8];
  if (*(_QWORD *)&object[8])
  {
    v76 = (unint64_t *)(*(_QWORD *)&object[8] + 8);
    do
      v77 = __ldxr(v76);
    while (__stxr(v77 + 1, v76));
  }
  v78 = *(void **)(v1 + 64);
  if (v78)
    v78 = _Block_copy(v78);
  v79 = *(NSObject **)(v1 + 72);
  aBlock = v78;
  v105 = v79;
  if (v79)
    dispatch_retain(v79);
  dispatch_group_notify(v70, v71, v100);
  if (v105)
    dispatch_release(v105);
  if (aBlock)
    _Block_release(aBlock);
  v80 = v103;
  if (v103)
  {
    v81 = (unint64_t *)&v103->__shared_owners_;
    do
      v82 = __ldaxr(v81);
    while (__stlxr(v82 - 1, v81));
    if (!v82)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }
  if (v101)
    std::__shared_weak_count::__release_weak(v101);
  v83 = *(std::__shared_weak_count **)&object[8];
  if (*(_QWORD *)&object[8])
  {
    v84 = (unint64_t *)(*(_QWORD *)&object[8] + 8);
    do
      v85 = __ldaxr(v84);
    while (__stlxr(v85 - 1, v84));
    if (!v85)
    {
      ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
      std::__shared_weak_count::__release_weak(v83);
    }
  }
  v86 = *(_QWORD *)__p;
  if (*(_QWORD *)__p)
  {
    v87 = *(_QWORD *)&__p[8];
    v88 = *(void **)__p;
    if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
    {
      do
      {
        if (*(char *)(v87 - 9) < 0)
          operator delete(*(void **)(v87 - 32));
        v87 -= 40;
      }
      while (v87 != v86);
      v88 = *(void **)__p;
    }
    *(_QWORD *)&__p[8] = v86;
    operator delete(v88);
  }
  v89 = (std::__shared_weak_count *)v117[1];
  if (v117[1])
  {
    v90 = (unint64_t *)((char *)v117[1] + 8);
    do
      v91 = __ldaxr(v90);
    while (__stlxr(v91 - 1, v90));
    if (!v91)
    {
      ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
      std::__shared_weak_count::__release_weak(v89);
    }
  }
  if (v47)
  {
    dispatch_group_leave(v47);
    dispatch_release(v47);
  }
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v118.__r_.__value_.__l.__data_);
  v92 = (std::__shared_weak_count *)v122;
  if ((_QWORD)v122)
  {
    v93 = (unint64_t *)(v122 + 8);
    do
      v94 = __ldaxr(v93);
    while (__stlxr(v94 - 1, v93));
    if (!v94)
    {
      ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
      std::__shared_weak_count::__release_weak(v92);
    }
  }
  std::locale::~locale(v119);
  xpc_release(v8);
  v6 = v124;
  if (v124)
  {
LABEL_219:
    v95 = (unint64_t *)&v6->__shared_owners_;
    do
      v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1A34D323C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  void *a71;
  void *a72;
  char a73;
  std::locale a74;
  unint64_t *v74;
  NSObject *v75;

  if (a42 < 0)
  {
    operator delete(__p);
    if ((a49 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a56 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_9;
    }
  }
  else if ((a49 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a44);
  if ((a56 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a63 & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_10;
  }
LABEL_9:
  operator delete(a51);
  if ((a63 & 0x80000000) == 0)
  {
LABEL_5:
    if (&STACK[0x280] == v74)
      goto LABEL_11;
    goto LABEL_14;
  }
LABEL_10:
  operator delete(a58);
  if (&STACK[0x280] == v74)
    goto LABEL_11;
  do
  {
LABEL_14:
    if (*((char *)v74 - 9) < 0)
      operator delete((void *)*(v74 - 4));
    v74 -= 5;
  }
  while (v74 != &STACK[0x280]);
LABEL_11:
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a71);
  if (v75)
  {
    dispatch_group_leave(v75);
    dispatch_release(v75);
  }
  if (a73 < 0)
    operator delete(a72);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a74);
  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void sub_1A34D35DC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_24(_QWORD *a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t *v4;
  uint64_t v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  __int128 v10;
  std::string *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  std::string v22;
  uint8_t buf[4];
  std::string *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = a1[4];
  v21 = 0;
  v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    v21 = std::__shared_weak_count::lock(v3);
    if (!v21)
      return;
    if (a1[5])
    {
      v4 = (uint64_t *)a1[8];
      v5 = *v4;
      if (*v4)
      {
        v6 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v7 = (std::__shared_weak_count *)v4[1];
          if (v7)
          {
            p_shared_owners = (unint64_t *)&v7->__shared_owners_;
            do
              v9 = __ldxr(p_shared_owners);
            while (__stxr(v9 + 1, p_shared_owners));
          }
          if (*(char *)(v5 + 31) < 0)
          {
            std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)(v5 + 8), *(_QWORD *)(v5 + 16));
          }
          else
          {
            v10 = *(_OWORD *)(v5 + 8);
            v22.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 24);
            *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v10;
          }
          v11 = &v22;
          if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v11 = (std::string *)v22.__r_.__value_.__r.__words[0];
          *(_DWORD *)buf = 136315138;
          v24 = v11;
          _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Deleting: %s", buf, 0xCu);
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v22.__r_.__value_.__l.__data_);
          if (v7)
          {
            v12 = (unint64_t *)&v7->__shared_owners_;
            do
              v13 = __ldaxr(v12);
            while (__stlxr(v13 - 1, v12));
            if (!v13)
            {
              ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
              std::__shared_weak_count::__release_weak(v7);
            }
          }
          v4 = (uint64_t *)a1[8];
          v5 = *v4;
        }
        v14 = (std::__shared_weak_count *)v4[1];
        if (v14)
        {
          v15 = (unint64_t *)&v14->__shared_owners_;
          do
            v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
        }
        if (v5)
        {
          abm::FileProperties::getPath((abm::FileProperties *)v5, &v22);
          abm::LogManagementTask::remove_sync(v2, (std::string::size_type)&v22);
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v22.__r_.__value_.__l.__data_);
        }
        if (v14)
        {
          v17 = (unint64_t *)&v14->__shared_owners_;
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 - 1, v17));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
      }
    }
  }
  if (v21)
  {
    v19 = (unint64_t *)&v21->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_1A34D3834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A34D3850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

BOOL abm::LogManagementTask::remove_sync(uint64_t a1, abm::FileProperties **a2)
{
  _BOOL8 result;
  _BOOL8 v4;
  std::string __p;

  if (!*a2)
    return 0;
  abm::FileProperties::getPath(*a2, &__p);
  result = abm::LogManagementTask::remove_sync(a1, (std::string::size_type)&__p);
  v4 = result;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    return v4;
  }
  return result;
}

void sub_1A34D391C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;

  v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = a2[7];
  a1[7] = v6;
  if (v6)
  {
    dispatch_retain(v6);
    v7 = a1[7];
    if (v7)
      dispatch_group_enter(v7);
  }
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 56);
    if (v3)
      dispatch_release(v3);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_26(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t i;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  NSObject *v12;
  xpc_object_t v13;
  const void *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD v20[4];
  void *aBlock;
  xpc_object_t object;
  int v23;

  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return;
  v5 = v4;
  if (a1[5])
  {
    v6 = (uint64_t *)a1[7];
    if (v6)
    {
      v7 = *v6;
      for (i = v6[1]; i != v7; i -= 16)
      {
        v9 = *(std::__shared_weak_count **)(i - 8);
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }
      v6[1] = v7;
    }
    v12 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20[0]) = 0;
      _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Deleting Done", (uint8_t *)v20, 2u);
    }
    v13 = xpc_null_create();
    v14 = (const void *)a1[9];
    if (v14)
      v15 = _Block_copy(v14);
    else
      v15 = 0;
    v16 = a1[10];
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3321888768;
    v20[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    v20[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v15)
    {
      v17 = _Block_copy(v15);
      v23 = 0;
      aBlock = v17;
      object = v13;
      if (v13)
      {
LABEL_21:
        xpc_retain(v13);
LABEL_24:
        dispatch_async(v16, v20);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v15)
          _Block_release(v15);
        xpc_release(v13);
        goto LABEL_29;
      }
    }
    else
    {
      v23 = 0;
      aBlock = 0;
      object = v13;
      if (v13)
        goto LABEL_21;
    }
    object = xpc_null_create();
    goto LABEL_24;
  }
LABEL_29:
  v18 = (unint64_t *)&v5->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_27(uint64_t a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v5;
  xpc_object_t value;
  NSObject *v7;
  std::string *v8;
  std::string::size_type size;
  char *v10;
  size_t v11;
  void *v12;
  void **v13;
  xpc_object_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  xpc_object_t v18;
  void *v19;
  NSObject *v20;
  void *v21;
  NSObject *v22;
  void *v23;
  std::string __p;
  void *__dst[2];
  unint64_t v26;
  std::string v27;
  __int128 object;
  void (*v29)(uint64_t);
  void *v30;
  void *aBlock;
  xpc_object_t v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 32);
  memset(&v27, 170, sizeof(v27));
  value = xpc_dictionary_get_value(*a3, "TimestampString");
  *(_QWORD *)&object = value;
  if (value)
    xpc_retain(value);
  else
    *(_QWORD *)&object = xpc_null_create();
  xpc::dyn_cast_or_default();
  xpc_release((xpc_object_t)object);
  v7 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = &v27;
    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v8 = (std::string *)v27.__r_.__value_.__r.__words[0];
    LODWORD(object) = 136315138;
    *(_QWORD *)((char *)&object + 4) = v8;
    _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I Log HouseKeeping requested - timestamp %s", (uint8_t *)&object, 0xCu);
  }
  size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
  if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v27.__r_.__value_.__l.__size_;
  if (size)
  {
    v10 = abm::trace::kMobileBasebandServicesFolder[0];
    v11 = strlen(abm::trace::kMobileBasebandServicesFolder[0]);
    if (v11 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v12 = (void *)v11;
    if (v11 >= 0x17)
    {
      v16 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17)
        v16 = v11 | 7;
      v17 = v16 + 1;
      v13 = (void **)operator new(v16 + 1);
      __dst[1] = v12;
      v26 = v17 | 0x8000000000000000;
      __dst[0] = v13;
    }
    else
    {
      HIBYTE(v26) = v11;
      v13 = __dst;
      if (!v11)
      {
        LOBYTE(__dst[0]) = 0;
        if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_15:
          __p = v27;
          goto LABEL_23;
        }
LABEL_22:
        std::string::__init_copy_ctor_external(&__p, v27.__r_.__value_.__l.__data_, v27.__r_.__value_.__l.__size_);
LABEL_23:
        abm::LogManagementTask::cleanUpLogs(v5, (uint64_t)__dst, (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v26) & 0x80000000) == 0)
            goto LABEL_25;
        }
        else if ((SHIBYTE(v26) & 0x80000000) == 0)
        {
          goto LABEL_25;
        }
        operator delete(__dst[0]);
LABEL_25:
        v18 = xpc_null_create();
        if (*(_QWORD *)a4)
          v19 = _Block_copy(*(const void **)a4);
        else
          v19 = 0;
        v20 = *(NSObject **)(a4 + 8);
        *(_QWORD *)&object = MEMORY[0x1E0C809B0];
        *((_QWORD *)&object + 1) = 3321888768;
        v29 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
        v30 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v19)
        {
          v21 = _Block_copy(v19);
          v33 = 0;
          aBlock = v21;
          v32 = v18;
          if (v18)
          {
LABEL_32:
            xpc_retain(v18);
LABEL_35:
            dispatch_async(v20, &object);
            xpc_release(v32);
            v32 = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v19)
              _Block_release(v19);
            xpc_release(v18);
            goto LABEL_51;
          }
        }
        else
        {
          v33 = 0;
          aBlock = 0;
          v32 = v18;
          if (v18)
            goto LABEL_32;
        }
        v32 = xpc_null_create();
        goto LABEL_35;
      }
    }
    memmove(v13, v10, (size_t)v12);
    *((_BYTE *)v12 + (_QWORD)v13) = 0;
    if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_15;
    goto LABEL_22;
  }
  v14 = xpc_null_create();
  if (*(_QWORD *)a4)
    v15 = _Block_copy(*(const void **)a4);
  else
    v15 = 0;
  v22 = *(NSObject **)(a4 + 8);
  *(_QWORD *)&object = MEMORY[0x1E0C809B0];
  *((_QWORD *)&object + 1) = 3321888768;
  v29 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
  v30 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v15)
  {
    v33 = -534716414;
    aBlock = 0;
    v32 = v14;
    if (v14)
      goto LABEL_43;
LABEL_45:
    v32 = xpc_null_create();
    goto LABEL_46;
  }
  v23 = _Block_copy(v15);
  v33 = -534716414;
  aBlock = v23;
  v32 = v14;
  if (!v14)
    goto LABEL_45;
LABEL_43:
  xpc_retain(v14);
LABEL_46:
  dispatch_async(v22, &object);
  xpc_release(v32);
  v32 = 0;
  if (aBlock)
    _Block_release(aBlock);
  if (v15)
    _Block_release(v15);
  xpc_release(v14);
LABEL_51:
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v27.__r_.__value_.__l.__data_);
}

void sub_1A34D3FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t object)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void abm::LogManagementTask::cleanUpLogs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v6;
  __int128 v7;
  unsigned __int8 v8;
  uint64_t v9;
  std::sub_match<const char *> *v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unsigned __int8 *v17;
  const void *v18;
  uint64_t v19;
  size_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unsigned __int8 *v25;
  _WORD *v26;
  __int128 v27;
  __int128 v28;
  unsigned __int8 v29;
  uint64_t v30;
  std::sub_match<const char *> *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _BYTE *v37;
  BOOL v38;
  uint64_t *v39;
  uint64_t v40;
  char **v41;
  char *v42;
  unint64_t v43;
  _BYTE *v44;
  _BYTE *v45;
  char *v46;
  __int128 *v47;
  _OWORD *v48;
  unint64_t v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  int v54;
  unint64_t v55;
  char *v56;
  BOOL v57;
  char *v58;
  uint64_t v59;
  char *v60;
  char *v61;
  std::string::size_type v62;
  _BYTE *p_str;
  _BYTE *v64;
  char *v65;
  __int128 *v66;
  _OWORD *v67;
  unint64_t v68;
  __int128 v69;
  uint64_t v70;
  uint64_t v71;
  char v72;
  int v73;
  BOOL v74;
  int v75;
  size_t size;
  unint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  std::string *v82;
  int v83;
  const std::string::value_type *v84;
  std::string::size_type v85;
  std::string *v86;
  __int128 v87;
  NSObject *v88;
  unsigned __int8 *v89;
  int v90;
  void *v91;
  int v92;
  void **v93;
  void **v94;
  void *v95;
  int v96;
  unsigned __int8 *v97;
  uint64_t v98;
  char *v99;
  char *v100;
  __int128 v101;
  _OWORD v102[4];
  uint64_t v103;
  uint64_t v104;
  std::string v105;
  std::locale v106;
  std::__shared_weak_count *v107;
  _BYTE v108[56];
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  void *v113;
  void **v114;
  uint64_t v115;
  std::string __str;
  void *__p[2];
  _QWORD v118[9];
  __int128 v119;
  uint64_t v120;
  uint8_t buf[16];
  _OWORD v122[2];
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  __int128 v128;
  uint64_t v129;
  uint64_t v130;

  v130 = *MEMORY[0x1E0C80C00];
  v113 = 0;
  v114 = 0;
  v115 = 0;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v109 + 1) = 0xAAAAAAAAAAAAAA00;
  *(_QWORD *)&v108[40] = 0xAAAAAAAAAAAAAAAALL;
  v111 = v6;
  *(_QWORD *)&v108[48] = 0;
  *(_QWORD *)&v109 = 0;
  v110 = 0uLL;
  LOBYTE(v111) = 0;
  BYTE8(v111) = 0;
  v112 = 0;
  v7 = 0uLL;
  memset(v108, 0, 41);
  v8 = atomic_load((unsigned __int8 *)&qword_1ED114A98);
  if ((v8 & 1) == 0)
  {
    v96 = __cxa_guard_acquire(&qword_1ED114A98);
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7 = 0uLL;
    if (v96)
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1ED114AC0, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
      __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1ED114AC0, &dword_1A343C000);
      __cxa_guard_release(&qword_1ED114A98);
      v7 = 0uLL;
      *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    }
  }
  v125 = 0xAAAAAAAAAAAAAA00;
  *((_QWORD *)&v122[1] + 1) = 0xAAAAAAAAAAAAAAAALL;
  v128 = v6;
  v123 = 0;
  v124 = 0;
  v126 = 0;
  v127 = 0;
  LOBYTE(v128) = 0;
  BYTE8(v128) = 0;
  v129 = 0;
  *(_OWORD *)buf = v7;
  v122[0] = v7;
  v9 = *(unsigned __int8 *)(a3 + 23);
  if ((v9 & 0x80u) == 0)
    v10 = (std::sub_match<const char *> *)a3;
  else
    v10 = *(std::sub_match<const char *> **)a3;
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a3 + 8);
  *(_OWORD *)((char *)v122 + 9) = v7;
  v11 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&unk_1ED114AC0, v10, (std::sub_match<const char *> *)((char *)v10 + v9), (std::vector<std::csub_match> *)buf, 0);
  v12 = *(unsigned __int8 *)(a3 + 23);
  if ((v12 & 0x80u) == 0)
    v13 = a3;
  else
    v13 = *(_QWORD *)a3;
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a3 + 8);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)v108, v13, (std::sub_match<std::__wrap_iter<const char *>> *)(v13 + v12), (uint64_t *)buf, 0);
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  if ((v11 & 1) != 0)
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v106, ".*", 0);
    ctu::fs::get_filtered_files();
    v14 = v107;
    if (v107)
    {
      p_shared_owners = (unint64_t *)&v107->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    std::locale::~locale(&v106);
    v17 = (unsigned __int8 *)v113;
    v97 = (unsigned __int8 *)v114;
    v100 = 0;
    v99 = 0;
    v18 = *(const void **)v108;
    v19 = *(_QWORD *)&v108[8] - *(_QWORD *)v108;
    if (*(_QWORD *)&v108[8] != *(_QWORD *)v108)
    {
      if (0xAAAAAAAAAAAAAAABLL * (v19 >> 3) >= 0xAAAAAAAAAAAAAABLL)
        std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
      v99 = (char *)operator new(*(_QWORD *)&v108[8] - *(_QWORD *)v108);
      v20 = 24 * ((v19 - 24) / 0x18uLL) + 24;
      memcpy(v99, v18, v20);
      v100 = &v99[v20];
    }
    v102[1] = v109;
    v102[2] = v110;
    v102[3] = v111;
    v101 = *(_OWORD *)&v108[24];
    v102[0] = *(_OWORD *)&v108[40];
    v103 = v112;
    v104 = a1;
    if (*(char *)(a2 + 23) < 0)
      std::string::__init_copy_ctor_external(&v105, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    else
      v105 = *(std::string *)a2;
    while (v17 != v97)
    {
      v22 = v104;
      v23 = v17[23];
      v24 = (char)v23;
      if ((v23 & 0x80u) != 0)
        v23 = *((_QWORD *)v17 + 1);
      if (v23 == 2)
      {
        if (v24 >= 0)
          v26 = v17;
        else
          v26 = *(_WORD **)v17;
        if (*v26 != 11822)
        {
LABEL_46:
          *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v119 = v27;
          v118[6] = 0xAAAAAAAAAAAAAA00;
          v118[3] = 0xAAAAAAAAAAAAAAAALL;
          v118[4] = 0;
          v118[5] = 0;
          v118[7] = 0;
          v118[8] = 0;
          LOBYTE(v119) = 0;
          BYTE8(v119) = 0;
          v120 = 0;
          v28 = 0uLL;
          *(_OWORD *)__p = 0u;
          memset(v118, 0, 25);
          v29 = atomic_load((unsigned __int8 *)&qword_1ED114A98);
          if ((v29 & 1) == 0)
          {
            v90 = __cxa_guard_acquire(&qword_1ED114A98);
            v28 = 0uLL;
            *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
            if (v90)
            {
              std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1ED114AC0, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
              __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1ED114AC0, &dword_1A343C000);
              __cxa_guard_release(&qword_1ED114A98);
              *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v28 = 0uLL;
            }
          }
          v128 = v27;
          v125 = *((_QWORD *)&v27 + 1);
          *((_QWORD *)&v122[1] + 1) = v27;
          v123 = 0;
          v124 = 0;
          LOBYTE(v125) = 0;
          v126 = 0;
          v127 = 0;
          LOBYTE(v128) = 0;
          BYTE8(v128) = 0;
          v129 = 0;
          *(_OWORD *)buf = v28;
          v122[0] = v28;
          *(_OWORD *)((char *)v122 + 9) = v28;
          v30 = v17[23];
          if ((v30 & 0x80u) == 0)
            v31 = (std::sub_match<const char *> *)v17;
          else
            v31 = *(std::sub_match<const char *> **)v17;
          if ((v30 & 0x80u) != 0)
            v30 = *((_QWORD *)v17 + 1);
          v32 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&unk_1ED114AC0, v31, (std::sub_match<const char *> *)((char *)v31 + v30), (std::vector<std::csub_match> *)buf, 0);
          v33 = v17[23];
          if ((v33 & 0x80u) == 0)
            v34 = (uint64_t)v17;
          else
            v34 = *(_QWORD *)v17;
          if ((v33 & 0x80u) != 0)
            v33 = *((_QWORD *)v17 + 1);
          std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)__p, v34, (std::sub_match<std::__wrap_iter<const char *>> *)(v34 + v33), (uint64_t *)buf, 0);
          v98 = v22;
          if (*(_QWORD *)buf)
          {
            *(_QWORD *)&buf[8] = *(_QWORD *)buf;
            operator delete(*(void **)buf);
          }
          if (v32)
          {
            v35 = 1;
            while (1)
            {
              v36 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
              v37 = (char *)__p[0] + 24 * v35 + 16;
              if (v36 <= v35)
                v37 = &v118[3];
              if (!*v37)
              {
                memset(buf, 0, sizeof(buf));
                *(_QWORD *)&v122[0] = 0;
                goto LABEL_85;
              }
              v38 = v36 > v35;
              v39 = &v118[1];
              if (v38)
                v39 = (uint64_t *)((char *)__p[0] + 24 * v35);
              v40 = *v39;
              v41 = (char **)((char *)__p[0] + 24 * v35 + 8);
              if (!v38)
                v41 = (char **)&v118[2];
              v42 = *v41;
              v43 = (unint64_t)&(*v41)[-v40];
              if (v43 > 0x7FFFFFFFFFFFFFF7)
                std::string::__throw_length_error[abi:ne180100]();
              if (v43 > 0x16)
              {
                v51 = (v43 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v43 | 7) != 0x17)
                  v51 = v43 | 7;
                v52 = v51 + 1;
                v44 = operator new(v51 + 1);
                *(_QWORD *)&buf[8] = v43;
                *(_QWORD *)&v122[0] = v52 | 0x8000000000000000;
                *(_QWORD *)buf = v44;
                if ((char *)v40 == v42)
                {
LABEL_81:
                  *v44 = 0;
                  goto LABEL_85;
                }
              }
              else
              {
                BYTE7(v122[0]) = *(_BYTE *)v41 - v40;
                v44 = buf;
                if ((char *)v40 == v42)
                  goto LABEL_81;
              }
              if (v43 < 0x20 || (unint64_t)&v44[-v40] < 0x20)
              {
                v45 = v44;
                v46 = (char *)v40;
              }
              else
              {
                v45 = &v44[v43 & 0xFFFFFFFFFFFFFFE0];
                v46 = (char *)(v40 + (v43 & 0xFFFFFFFFFFFFFFE0));
                v47 = (__int128 *)(v40 + 16);
                v48 = v44 + 16;
                v49 = v43 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  v50 = *v47;
                  *(v48 - 1) = *(v47 - 1);
                  *v48 = v50;
                  v47 += 2;
                  v48 += 2;
                  v49 -= 32;
                }
                while (v49);
                if (v43 == (v43 & 0x7FFFFFFFFFFFFFE0))
                  goto LABEL_84;
              }
              do
              {
                v53 = *v46++;
                *v45++ = v53;
              }
              while (v46 != v42);
LABEL_84:
              *v45 = 0;
LABEL_85:
              v54 = std::stoi((const std::string *)buf, 0, 10);
              v55 = 0xAAAAAAAAAAAAAAABLL * ((v100 - v99) >> 3);
              v56 = &v99[24 * v35 + 16];
              if (v55 <= v35)
                v56 = (char *)v102;
              if (!*v56)
              {
                memset(&__str, 0, sizeof(__str));
                goto LABEL_109;
              }
              v57 = v55 > v35;
              v58 = (char *)&v101;
              if (v57)
                v58 = &v99[24 * v35];
              v59 = *(_QWORD *)v58;
              v60 = &v99[24 * v35 + 8];
              if (!v57)
                v60 = (char *)&v101 + 8;
              v61 = *(char **)v60;
              v62 = *(_QWORD *)v60 - v59;
              if (v62 > 0x7FFFFFFFFFFFFFF7)
                std::string::__throw_length_error[abi:ne180100]();
              if (v62 > 0x16)
              {
                v70 = (v62 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v62 | 7) != 0x17)
                  v70 = v62 | 7;
                v71 = v70 + 1;
                p_str = operator new(v70 + 1);
                __str.__r_.__value_.__l.__size_ = v62;
                __str.__r_.__value_.__r.__words[2] = v71 | 0x8000000000000000;
                __str.__r_.__value_.__r.__words[0] = (std::string::size_type)p_str;
                if ((char *)v59 == v61)
                {
LABEL_105:
                  *p_str = 0;
                  goto LABEL_109;
                }
              }
              else
              {
                *((_BYTE *)&__str.__r_.__value_.__s + 23) = *v60 - v59;
                p_str = &__str;
                if ((char *)v59 == v61)
                  goto LABEL_105;
              }
              if (v62 < 0x20 || (unint64_t)&p_str[-v59] < 0x20)
              {
                v64 = p_str;
                v65 = (char *)v59;
              }
              else
              {
                v64 = &p_str[v62 & 0xFFFFFFFFFFFFFFE0];
                v65 = (char *)(v59 + (v62 & 0xFFFFFFFFFFFFFFE0));
                v66 = (__int128 *)(v59 + 16);
                v67 = p_str + 16;
                v68 = v62 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  v69 = *v66;
                  *(v67 - 1) = *(v66 - 1);
                  *v67 = v69;
                  v66 += 2;
                  v67 += 2;
                  v68 -= 32;
                }
                while (v68);
                if (v62 == (v62 & 0x7FFFFFFFFFFFFFE0))
                  goto LABEL_108;
              }
              do
              {
                v72 = *v65++;
                *v64++ = v72;
              }
              while (v65 != v61);
LABEL_108:
              *v64 = 0;
LABEL_109:
              v73 = std::stoi(&__str, 0, 10);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(__str.__r_.__value_.__l.__data_);
                if ((SBYTE7(v122[0]) & 0x80000000) == 0)
                {
LABEL_111:
                  v74 = v54 == v73;
                  if (v54 > v73)
                    goto LABEL_142;
                  goto LABEL_115;
                }
              }
              else if ((SBYTE7(v122[0]) & 0x80000000) == 0)
              {
                goto LABEL_111;
              }
              operator delete(*(void **)buf);
              v74 = v54 == v73;
              if (v54 > v73)
              {
LABEL_142:
                v88 = *(NSObject **)(v98 + 40);
                if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                {
                  if ((v17[23] & 0x80u) == 0)
                    v89 = v17;
                  else
                    v89 = *(unsigned __int8 **)v17;
                  *(_DWORD *)buf = 136315138;
                  *(_QWORD *)&buf[4] = v89;
                  _os_log_impl(&dword_1A343C000, v88, OS_LOG_TYPE_DEFAULT, "#I Not remove: %s", buf, 0xCu);
                }
                goto LABEL_147;
              }
LABEL_115:
              if (v74 && ++v35 != 7)
                continue;
              break;
            }
          }
          v75 = SHIBYTE(v105.__r_.__value_.__r.__words[2]);
          if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v105.__r_.__value_.__r.__words[2]);
          else
            size = v105.__r_.__value_.__l.__size_;
          v77 = size + 1;
          memset(&__str, 170, sizeof(__str));
          if (size + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v77 >= 0x17)
          {
            v80 = (v77 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v77 | 7) != 0x17)
              v80 = v77 | 7;
            v81 = v80 + 1;
            v78 = (char *)operator new(v80 + 1);
            __str.__r_.__value_.__l.__size_ = size + 1;
            __str.__r_.__value_.__r.__words[2] = v81 | 0x8000000000000000;
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v78;
            v79 = v98;
          }
          else
          {
            memset(&__str, 0, sizeof(__str));
            v78 = (char *)&__str;
            *((_BYTE *)&__str.__r_.__value_.__s + 23) = size + 1;
            v79 = v98;
            if (!size)
              goto LABEL_132;
          }
          if (v75 >= 0)
            v82 = &v105;
          else
            v82 = (std::string *)v105.__r_.__value_.__r.__words[0];
          memmove(v78, v82, size);
LABEL_132:
          *(_WORD *)&v78[size] = 47;
          v83 = (char)v17[23];
          if (v83 >= 0)
            v84 = (const std::string::value_type *)v17;
          else
            v84 = *(const std::string::value_type **)v17;
          if (v83 >= 0)
            v85 = v17[23];
          else
            v85 = *((_QWORD *)v17 + 1);
          v86 = std::string::append(&__str, v84, v85);
          v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
          *(_QWORD *)&v122[0] = *((_QWORD *)&v86->__r_.__value_.__l + 2);
          *(_OWORD *)buf = v87;
          v86->__r_.__value_.__l.__size_ = 0;
          v86->__r_.__value_.__r.__words[2] = 0;
          v86->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__str.__r_.__value_.__l.__data_);
          abm::LogManagementTask::remove_sync(v79, (std::string::size_type)buf);
          if (SBYTE7(v122[0]) < 0)
            operator delete(*(void **)buf);
LABEL_147:
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
      }
      else
      {
        if (v23 != 1)
          goto LABEL_46;
        v25 = v24 >= 0 ? v17 : *(unsigned __int8 **)v17;
        if (*v25 != 46)
          goto LABEL_46;
      }
      v17 += 24;
    }
    v91 = (void *)v105.__r_.__value_.__r.__words[0];
    v92 = SHIBYTE(v105.__r_.__value_.__r.__words[2]);
    memset(&v105, 0, sizeof(v105));
    if (v92 < 0)
      operator delete(v91);
    if (v99)
      operator delete(v99);
    if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v105.__r_.__value_.__l.__data_);
  }
  else
  {
    v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) < 0)
        a3 = *(_QWORD *)a3;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = a3;
      _os_log_error_impl(&dword_1A343C000, v21, OS_LOG_TYPE_ERROR, "Timestamp not provided: %s", buf, 0xCu);
    }
  }
  if (*(_QWORD *)v108)
  {
    *(_QWORD *)&v108[8] = *(_QWORD *)v108;
    operator delete(*(void **)v108);
  }
  v93 = (void **)v113;
  if (v113)
  {
    v94 = v114;
    v95 = v113;
    if (v114 != v113)
    {
      do
      {
        if (*((char *)v94 - 1) < 0)
          operator delete(*(v94 - 3));
        v94 -= 3;
      }
      while (v94 != v93);
      v95 = v113;
    }
    v114 = v93;
    operator delete(v95);
  }
}

void sub_1A34D4BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,std::locale a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a65;

  __cxa_guard_abort(&qword_1ED114A98);
  if (__p)
    operator delete(__p);
  std::vector<std::string>::~vector[abi:ne180100](&a65);
  _Unwind_Resume(a1);
}

void sub_1A34D4CCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  char a73;

  if (a73 < 0)
    operator delete(__p);
  JUMPOUT(0x1A34D4C84);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  int directory;
  NSObject *v7;
  char *v8;
  xpc_object_t v10;
  void *v11;
  void *v12;
  NSObject *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  std::__fs::filesystem::path __p;
  void *v18;
  void *aBlock;
  xpc_object_t object;
  int v21;

  v5 = *(_QWORD *)(a1 + 32);
  strlen(abm::trace::kMobileBasebandServicesFolder[0]);
  directory = ctu::fs::create_directory();
  v7 = *(NSObject **)(v5 + 40);
  if (directory)
  {
    if (os_log_type_enabled(*(os_log_t *)(v5 + 40), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__pn_.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I BasebandServices folder created", (uint8_t *)&__p, 2u);
    }
    memset(&__p, 0, sizeof(__p));
    v8 = abm::trace::kMobileBasebandServicesFolder[0] - 1;
    while (*++v8)
      ;
    std::string::append[abi:ne180100]<char const*,0>((unint64_t)&__p, abm::trace::kMobileBasebandServicesFolder[0], v8);
    std::__fs::filesystem::__permissions(&__p, all, add, 0);
    if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__pn_.__r_.__value_.__l.__data_);
    v10 = xpc_null_create();
    if (*(_QWORD *)a4)
      v11 = _Block_copy(*(const void **)a4);
    else
      v11 = 0;
    v15 = *(NSObject **)(a4 + 8);
    __p.__pn_.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
    __p.__pn_.__r_.__value_.__l.__size_ = 3321888768;
    __p.__pn_.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    v18 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v11)
    {
      v16 = _Block_copy(v11);
      v21 = 0;
      aBlock = v16;
      object = v10;
      if (v10)
      {
LABEL_28:
        xpc_retain(v10);
LABEL_31:
        dispatch_async(v15, &__p);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v11)
          _Block_release(v11);
        goto LABEL_35;
      }
    }
    else
    {
      v21 = 0;
      aBlock = 0;
      object = v10;
      if (v10)
        goto LABEL_28;
    }
    object = xpc_null_create();
    goto LABEL_31;
  }
  if (os_log_type_enabled(*(os_log_t *)(v5 + 40), OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p.__pn_.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v7, OS_LOG_TYPE_ERROR, "Failed to create BasebandServices folder", (uint8_t *)&__p, 2u);
  }
  v10 = xpc_null_create();
  if (*(_QWORD *)a4)
    v12 = _Block_copy(*(const void **)a4);
  else
    v12 = 0;
  v13 = *(NSObject **)(a4 + 8);
  __p.__pn_.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
  __p.__pn_.__r_.__value_.__l.__size_ = 3321888768;
  __p.__pn_.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
  v18 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v12)
  {
    v21 = -534716416;
    aBlock = 0;
    object = v10;
    if (v10)
      goto LABEL_17;
LABEL_19:
    object = xpc_null_create();
    goto LABEL_20;
  }
  v14 = _Block_copy(v12);
  v21 = -534716416;
  aBlock = v14;
  object = v10;
  if (!v10)
    goto LABEL_19;
LABEL_17:
  xpc_retain(v10);
LABEL_20:
  dispatch_async(v13, &__p);
  xpc_release(object);
  object = 0;
  if (aBlock)
    _Block_release(aBlock);
  if (v12)
    _Block_release(v12);
LABEL_35:
  xpc_release(v10);
}

void sub_1A34D4FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t abm::LogManagementTask::cleanUpLogs(std::string,std::string)::$_0::~$_0(uint64_t a1)
{
  void *v2;

  if (*(char *)(a1 + 143) < 0)
  {
    operator delete(*(void **)(a1 + 120));
    v2 = *(void **)a1;
    if (!*(_QWORD *)a1)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
LABEL_3:
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *std::vector<abm::DirectoryQuery>::vector[abi:ne180100](_QWORD *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  std::string *v11;
  const std::string::value_type **v12;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >= 0x666666666666667)
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    v5 = 40 * a3;
    v6 = (char *)operator new(40 * a3);
    v7 = 0;
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[v5];
    v8 = a2 + v5;
    do
    {
      v10 = a2 + v7;
      *(_DWORD *)&v6[v7] = *(_DWORD *)(a2 + v7);
      v11 = (std::string *)&v6[v7 + 8];
      v12 = (const std::string::value_type **)(a2 + v7 + 8);
      if (*(char *)(a2 + v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v11, *v12, *(_QWORD *)(v10 + 16));
      }
      else
      {
        v9 = *(_OWORD *)v12;
        *(_QWORD *)&v6[v7 + 24] = *(_QWORD *)(a2 + v7 + 24);
        *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v9;
      }
      *(_DWORD *)&v6[v7 + 32] = *(_DWORD *)(v10 + 32);
      v7 += 40;
    }
    while (v10 + 40 != v8);
    a1[1] = &v6[v7];
  }
  return a1;
}

void sub_1A34D5140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::__exception_guard_exceptions<std::vector<abm::DirectoryQuery>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void sub_1A34D5154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  for (; v11; v11 -= 40)
  {
    if (*(char *)(v10 + v11 - 9) < 0)
      operator delete(*(void **)(v10 + v11 - 32));
  }
  *(_QWORD *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<abm::DirectoryQuery>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ***std::__exception_guard_exceptions<std::vector<abm::DirectoryQuery>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](void ***result)
{
  void ***v1;
  void **v2;
  void **v3;
  void **v4;
  void *v5;

  v1 = result;
  if (!*((_BYTE *)result + 8))
  {
    v2 = *result;
    v3 = (void **)**result;
    if (v3)
    {
      v4 = (void **)v2[1];
      v5 = **result;
      if (v4 != v3)
      {
        do
        {
          if (*((char *)v4 - 9) < 0)
            operator delete(*(v4 - 4));
          v4 -= 5;
        }
        while (v4 != v3);
        v5 = **v1;
      }
      v2[1] = v3;
      operator delete(v5);
      return v1;
    }
  }
  return result;
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  xpc_object_t object;

  v1 = *(unsigned int *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  object = v2;
  if (v2)
    xpc_retain(v2);
  else
    object = xpc_null_create();
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A34D5284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

unint64_t std::string::append[abi:ne180100]<char const*,0>(unint64_t a1, char *__src, char *a3)
{
  int v6;
  size_t v7;
  size_t v8;
  unint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  void **v13;
  size_t v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  const std::string::value_type *v21;
  std::string::size_type v22;
  _OWORD *v23;
  __int128 *v24;
  unint64_t v25;
  __int128 v26;
  char v27;
  size_t v28;
  unint64_t v30;
  uint64_t v31;
  void *__dst[3];

  v6 = *(char *)(a1 + 23);
  v7 = a3 - __src;
  if (v6 < 0)
  {
    if (a3 == __src)
      return a1;
    v8 = *(_QWORD *)(a1 + 8);
    v12 = *(_QWORD *)(a1 + 16);
    v9 = (v12 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    v11 = *(_BYTE **)a1;
    v10 = HIBYTE(v12);
    if (*(_QWORD *)a1 > (unint64_t)__src)
      goto LABEL_11;
  }
  else
  {
    if (a3 == __src)
      return a1;
    v8 = *(unsigned __int8 *)(a1 + 23);
    v9 = 22;
    LOBYTE(v10) = *(_BYTE *)(a1 + 23);
    v11 = (_BYTE *)a1;
    if (a1 > (unint64_t)__src)
    {
LABEL_11:
      if (v9 - v8 >= v7)
      {
        v16 = (_BYTE *)a1;
        if ((v10 & 0x80) != 0)
        {
          v16 = *(_BYTE **)a1;
          v17 = (_BYTE *)(*(_QWORD *)a1 + v8);
          if (v7 >= 0x20)
            goto LABEL_36;
        }
        else
        {
          v17 = (_BYTE *)(a1 + v8);
          if (v7 >= 0x20)
            goto LABEL_36;
        }
        goto LABEL_23;
      }
      v14 = 0x7FFFFFFFFFFFFFF7;
      if (0x7FFFFFFFFFFFFFF7 - v9 < v8 + v7 - v9)
        std::string::__throw_length_error[abi:ne180100]();
      v15 = (_BYTE *)a1;
      if (v6 < 0)
      {
        v15 = *(_BYTE **)a1;
        if (v9 > 0x3FFFFFFFFFFFFFF2)
        {
LABEL_15:
          v16 = operator new(0x7FFFFFFFFFFFFFF7uLL);
          if (!v8)
            goto LABEL_17;
          goto LABEL_16;
        }
      }
      else if (v9 > 0x3FFFFFFFFFFFFFF2)
      {
        goto LABEL_15;
      }
      v30 = 2 * v9;
      if (v8 + v7 > 2 * v9)
        v30 = v8 + v7;
      v31 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v30 | 7) != 0x17)
        v31 = v30 | 7;
      if (v30 >= 0x17)
        v14 = v31 + 1;
      else
        v14 = 23;
      v16 = operator new(v14);
      if (!v8)
      {
LABEL_17:
        if (v9 != 22)
          operator delete(v15);
        *(_QWORD *)(a1 + 8) = v8;
        *(_QWORD *)(a1 + 16) = v14 | 0x8000000000000000;
        *(_QWORD *)a1 = v16;
        v17 = &v16[v8];
        if (v7 >= 0x20)
        {
LABEL_36:
          if ((unint64_t)(&v16[v8] - __src) >= 0x20)
          {
            v18 = &__src[v7 & 0xFFFFFFFFFFFFFFE0];
            v17 += v7 & 0xFFFFFFFFFFFFFFE0;
            v23 = &v16[v8 + 16];
            v24 = (__int128 *)(__src + 16);
            v25 = v7 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              v26 = *v24;
              *(v23 - 1) = *(v24 - 1);
              *v23 = v26;
              v23 += 2;
              v24 += 2;
              v25 -= 32;
            }
            while (v25);
            if (v7 == (v7 & 0xFFFFFFFFFFFFFFE0))
              goto LABEL_42;
          }
          else
          {
            v18 = __src;
          }
          do
          {
LABEL_41:
            v27 = *v18++;
            *v17++ = v27;
          }
          while (v18 != a3);
LABEL_42:
          *v17 = 0;
          v28 = v8 + v7;
          if (*(char *)(a1 + 23) < 0)
            *(_QWORD *)(a1 + 8) = v28;
          else
            *(_BYTE *)(a1 + 23) = v28 & 0x7F;
          return a1;
        }
LABEL_23:
        v18 = __src;
        goto LABEL_41;
      }
LABEL_16:
      memmove(v16, v15, v8);
      goto LABEL_17;
    }
  }
  if (&v11[v8 + 1] <= __src)
    goto LABEL_11;
  memset(__dst, 170, sizeof(__dst));
  if (v7 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v7 > 0x16)
  {
    v19 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v19 = v7 | 7;
    v20 = v19 + 1;
    v13 = (void **)operator new(v19 + 1);
    __dst[1] = (void *)v7;
    __dst[2] = (void *)(v20 | 0x8000000000000000);
    __dst[0] = v13;
  }
  else
  {
    HIBYTE(__dst[2]) = (_BYTE)a3 - (_BYTE)__src;
    v13 = __dst;
  }
  memcpy(v13, __src, v7);
  *((_BYTE *)v13 + v7) = 0;
  if (SHIBYTE(__dst[2]) >= 0)
    v21 = (const std::string::value_type *)__dst;
  else
    v21 = (const std::string::value_type *)__dst[0];
  if (SHIBYTE(__dst[2]) >= 0)
    v22 = HIBYTE(__dst[2]);
  else
    v22 = (std::string::size_type)__dst[1];
  std::string::append((std::string *)a1, v21, v22);
  if (SHIBYTE(__dst[2]) < 0)
    operator delete(__dst[0]);
  return a1;
}

void sub_1A34D5594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<abm::HelperTask>::execute_wrapped<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>(abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0,dispatch_queue_s *::default_delete<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t *v1;
  char *v2;
  int v3;
  __darwin_time_t tv_sec;
  _DWORD *v5;
  int64_t v6;
  NSObject *v7;
  int v8;
  std::string::size_type v9;
  std::string *v10;
  std::string *v11;
  int IsCarrierBuild;
  const char **v13;
  unsigned __int8 v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  __int128 *v21;
  __int128 *v22;
  std::string *v23;
  __int128 v24;
  unsigned __int8 v25;
  unint64_t *v26;
  unint64_t v27;
  _BOOL4 v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  char *v32;
  size_t v33;
  int v34;
  size_t v35;
  std::string::size_type v36;
  size_t v37;
  std::string *p_dst;
  char *v39;
  const std::string::value_type *v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  NSObject *v44;
  NSObject *v45;
  std::string *v46;
  unsigned __int8 v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  const char *v53;
  size_t v54;
  int v55;
  size_t v56;
  std::string::size_type v57;
  size_t v58;
  char *v59;
  char *v60;
  const std::string::value_type *v61;
  __int128 v62;
  int64_t v63;
  const char **v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 v67;
  unint64_t *v68;
  unint64_t v69;
  _BOOL4 v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  NSObject *v74;
  std::string *v75;
  __int128 *v76;
  __int128 *v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  __int128 *v82;
  int64_t v83;
  uint64_t v84;
  std::string __dst;
  std::string v86;
  __int128 v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  std::string v91;
  std::string v92;
  __int128 v93;
  uint64_t v94;
  std::__shared_weak_count *v95;
  uint64_t v96;
  timeval v97;
  void *__p;
  _QWORD *v99;
  uint64_t v100;
  std::string v101;
  int v102;
  const void *v103[2];
  uint64_t v104;
  uint8_t v105[4];
  std::string *v106;
  std::string v107;
  uint8_t buf[24];
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v1 = *(uint64_t **)a1;
  v84 = **(_QWORD **)a1;
  v102 = 0;
  memset(&v101, 0, sizeof(v101));
  HIBYTE(v100) = 4;
  strcpy((char *)&__p, "Time");
  HIBYTE(v104) = 8;
  strcpy((char *)v103, "Settings");
  memset(&v92, 0, sizeof(v92));
  if (defaults::get((char *)v103, (char *)&__p, &v92))
  {
    prop::file::get<std::string>(v103, (uint64_t)&__p, (uint64_t)&v92, &v86);
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v101.__r_.__value_.__l.__data_);
    v101 = v86;
  }
  if ((SHIBYTE(v92.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v104) & 0x80000000) == 0)
      goto LABEL_7;
LABEL_83:
    operator delete((void *)v103[0]);
    if ((SHIBYTE(v100) & 0x80000000) == 0)
      goto LABEL_8;
    goto LABEL_84;
  }
  operator delete(v92.__r_.__value_.__l.__data_);
  if (SHIBYTE(v104) < 0)
    goto LABEL_83;
LABEL_7:
  if ((SHIBYTE(v100) & 0x80000000) == 0)
    goto LABEL_8;
LABEL_84:
  operator delete(__p);
LABEL_8:
  util::convert<unsigned int>(&v101, &v102, 0);
  v97.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v97.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v97, 0);
  v2 = (char *)operator new(0x38uLL);
  *((_DWORD *)v2 + 8) = 0;
  *(_QWORD *)v2 = 0;
  *((_QWORD *)v2 + 1) = 0;
  *((_QWORD *)v2 + 2) = &v103[1];
  v103[0] = v2;
  v103[1] = v2;
  v2[24] = 1;
  v104 = 1;
  *(timeval *)(v2 + 40) = v97;
  v3 = v102;
  tv_sec = v97.tv_sec;
  v5 = operator new(0x38uLL);
  v6 = (86400 * v3);
  v5[8] = 0;
  *(_QWORD *)v5 = 0;
  *((_QWORD *)v5 + 1) = 0;
  *((_QWORD *)v5 + 2) = &v99;
  __p = v5;
  v99 = v5;
  *((_BYTE *)v5 + 24) = 1;
  v100 = 1;
  *((_QWORD *)v5 + 5) = tv_sec - v6;
  *((_QWORD *)v5 + 6) = 0xAAAAAAAAAAAAAAAALL;
  v7 = *(NSObject **)(v84 + 40);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    goto LABEL_16;
  Timestamp::asString((uint64_t)v103, 0, 9, &v92);
  v8 = SHIBYTE(v92.__r_.__value_.__r.__words[2]);
  v9 = v92.__r_.__value_.__r.__words[0];
  Timestamp::asString((uint64_t)&__p, 0, 9, &v86);
  v10 = &v92;
  if (v8 < 0)
    v10 = (std::string *)v9;
  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v86;
  else
    v11 = (std::string *)v86.__r_.__value_.__r.__words[0];
  *(_DWORD *)buf = 136315394;
  *(_QWORD *)&buf[4] = v10;
  *(_WORD *)&buf[12] = 2080;
  *(_QWORD *)&buf[14] = v11;
  _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I Now: %s. Searching files older than %s", buf, 0x16u);
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v86.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v92.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((SHIBYTE(v92.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v92.__r_.__value_.__l.__data_);
LABEL_16:
  memset(buf, 0, sizeof(buf));
  v83 = (86400 * v3);
  if (TelephonyUtilIsInternalBuild())
  {
    strlen(abm::trace::kSnapshotFolder[0]);
    goto LABEL_19;
  }
  IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  v13 = (const char **)abm::trace::kSnapshotFolder;
  strlen(abm::trace::kSnapshotFolder[0]);
  if (IsCarrierBuild)
  {
LABEL_19:
    v14 = atomic_load((unsigned __int8 *)&qword_1ED114AA0);
    if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_1ED114AA0))
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1ED114B00, "[^\\.].*([[:digit:]]{4})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2}).*\\.(?!json).*", 0);
      __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1ED114B00, &dword_1A343C000);
      __cxa_guard_release(&qword_1ED114AA0);
      v6 = (86400 * v3);
    }
    std::locale::locale((std::locale *)&v92, (const std::locale *)&unk_1ED114B00);
    *(_OWORD *)&v92.__r_.__value_.__r.__words[1] = unk_1ED114B08;
    v93 = unk_1ED114B18;
    v94 = qword_1ED114B28;
    v95 = (std::__shared_weak_count *)unk_1ED114B30;
    if (unk_1ED114B30)
    {
      v15 = (unint64_t *)(unk_1ED114B30 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v17 = 0x1ED114000uLL;
    v96 = qword_1ED114B38;
    ctu::fs::get_filtered_files();
    v18 = v95;
    if (!v95)
      goto LABEL_27;
    p_shared_owners = (unint64_t *)&v95->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (v20)
    {
LABEL_27:
      std::locale::~locale((std::locale *)&v92);
      v21 = *(__int128 **)buf;
      v22 = *(__int128 **)&buf[8];
      if (*(_QWORD *)buf != *(_QWORD *)&buf[8])
        goto LABEL_33;
      goto LABEL_139;
    }
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    std::locale::~locale((std::locale *)&v92);
    v21 = *(__int128 **)buf;
    v22 = *(__int128 **)&buf[8];
    if (*(_QWORD *)buf == *(_QWORD *)&buf[8])
      goto LABEL_139;
    while (1)
    {
LABEL_33:
      if (*((char *)v21 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v91, *(const std::string::value_type **)v21, *((_QWORD *)v21 + 1));
      }
      else
      {
        v24 = *v21;
        v91.__r_.__value_.__r.__words[2] = *((_QWORD *)v21 + 2);
        *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v24;
      }
      v25 = atomic_load((unsigned __int8 *)&qword_1ED114AA0);
      if ((v25 & 1) == 0 && __cxa_guard_acquire(&qword_1ED114AA0))
      {
        std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1ED114B00, "[^\\.].*([[:digit:]]{4})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2}).*\\.(?!json).*", 0);
        __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1ED114B00, &dword_1A343C000);
        __cxa_guard_release(&qword_1ED114AA0);
        v6 = v83;
        v17 = 0x1ED114000;
      }
      std::locale::locale((std::locale *)&v86, (const std::locale *)&unk_1ED114B00);
      *(_OWORD *)&v86.__r_.__value_.__r.__words[1] = unk_1ED114B08;
      v87 = unk_1ED114B18;
      v88 = qword_1ED114B28;
      v89 = (std::__shared_weak_count *)unk_1ED114B30;
      if (unk_1ED114B30)
      {
        v26 = (unint64_t *)(unk_1ED114B30 + 8);
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
      }
      v90 = *(_QWORD *)(v17 + 2872);
      v28 = util::checkLogFileAge((uint64_t)&v91, v6, (uint64_t)&v86);
      v29 = v89;
      if (!v89)
        goto LABEL_44;
      v30 = (unint64_t *)&v89->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
        std::locale::~locale((std::locale *)&v86);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
        {
LABEL_48:
          operator delete(v91.__r_.__value_.__l.__data_);
          if (!v28)
            goto LABEL_32;
          goto LABEL_49;
        }
      }
      else
      {
LABEL_44:
        std::locale::~locale((std::locale *)&v86);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_48;
      }
      if (!v28)
        goto LABEL_32;
LABEL_49:
      memset(&__dst, 170, sizeof(__dst));
      v32 = abm::trace::kSnapshotFolder[0];
      v33 = strlen(abm::trace::kSnapshotFolder[0]);
      v34 = *((char *)v21 + 23);
      if (v34 >= 0)
        v35 = *((unsigned __int8 *)v21 + 23);
      else
        v35 = *((_QWORD *)v21 + 1);
      v36 = v35 + v33;
      if (v35 + v33 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      v37 = v33;
      if (v36 <= 0x16)
      {
        memset(&__dst, 0, sizeof(__dst));
        p_dst = &__dst;
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v35 + v33;
        if (!v33)
          goto LABEL_56;
LABEL_55:
        memcpy(p_dst, v32, v37);
        goto LABEL_56;
      }
      v41 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v36 | 7) != 0x17)
        v41 = v36 | 7;
      v42 = v41 + 1;
      p_dst = (std::string *)operator new(v41 + 1);
      __dst.__r_.__value_.__l.__size_ = v36;
      __dst.__r_.__value_.__r.__words[2] = v42 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      v6 = v83;
      if (v37)
        goto LABEL_55;
LABEL_56:
      v39 = (char *)p_dst + v37;
      if (v35)
      {
        if (v34 >= 0)
          v40 = (const std::string::value_type *)v21;
        else
          v40 = *(const std::string::value_type **)v21;
        memmove(v39, v40, v35);
      }
      v39[v35] = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v107, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        v17 = 0x1ED114000uLL;
      }
      else
      {
        v107 = __dst;
        v17 = 0x1ED114000;
      }
      v43 = util::markPurgeableFile((uint64_t *)&v107);
      if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v107.__r_.__value_.__l.__data_);
        v44 = *(NSObject **)(v84 + 40);
        v45 = v44;
        if (!v43)
        {
LABEL_73:
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            v46 = &__dst;
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v46 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            *(_DWORD *)v105 = 136315138;
            v106 = v46;
            _os_log_error_impl(&dword_1A343C000, v44, OS_LOG_TYPE_ERROR, "Failed to mark %s to be purgeable", v105, 0xCu);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_32;
LABEL_75:
            operator delete(__dst.__r_.__value_.__l.__data_);
            goto LABEL_32;
          }
          goto LABEL_74;
        }
      }
      else
      {
        v44 = *(NSObject **)(v84 + 40);
        v45 = v44;
        if (!v43)
          goto LABEL_73;
      }
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        v23 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v23 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        *(_DWORD *)v105 = 136315138;
        v106 = v23;
        _os_log_impl(&dword_1A343C000, v44, OS_LOG_TYPE_DEFAULT, "#I %s is marked to be purgeable", v105, 0xCu);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_32;
        goto LABEL_75;
      }
LABEL_74:
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_75;
LABEL_32:
      v21 = (__int128 *)((char *)v21 + 24);
      if (v21 == v22)
        goto LABEL_138;
    }
  }
  v47 = atomic_load((unsigned __int8 *)&qword_1ED114A98);
  if ((v47 & 1) == 0 && __cxa_guard_acquire(&qword_1ED114A98))
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1ED114AC0, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
    __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1ED114AC0, &dword_1A343C000);
    __cxa_guard_release(&qword_1ED114A98);
  }
  std::locale::locale((std::locale *)&v92, (const std::locale *)&unk_1ED114AC0);
  *(_OWORD *)&v92.__r_.__value_.__r.__words[1] = unk_1ED114AC8;
  v93 = unk_1ED114AD8;
  v94 = qword_1ED114AE8;
  v95 = (std::__shared_weak_count *)unk_1ED114AF0;
  if (unk_1ED114AF0)
  {
    v48 = (unint64_t *)(unk_1ED114AF0 + 8);
    do
      v49 = __ldxr(v48);
    while (__stxr(v49 + 1, v48));
  }
  v96 = qword_1ED114AF8;
  ctu::fs::get_filtered_files();
  v50 = v95;
  if (v95)
  {
    v51 = (unint64_t *)&v95->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
      std::locale::~locale((std::locale *)&v92);
      v21 = *(__int128 **)buf;
      v82 = *(__int128 **)&buf[8];
      if (*(_QWORD *)buf == *(_QWORD *)&buf[8])
        goto LABEL_139;
      while (1)
      {
LABEL_98:
        memset(&v91, 170, sizeof(v91));
        v53 = *v13;
        v54 = strlen(*v13);
        v55 = *((char *)v21 + 23);
        if (v55 >= 0)
          v56 = *((unsigned __int8 *)v21 + 23);
        else
          v56 = *((_QWORD *)v21 + 1);
        v57 = v56 + v54;
        if (v56 + v54 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v58 = v54;
        if (v57 <= 0x16)
          break;
        v64 = v13;
        v65 = (v57 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v57 | 7) != 0x17)
          v65 = v57 | 7;
        v66 = v65 + 1;
        v59 = (char *)operator new(v65 + 1);
        v91.__r_.__value_.__l.__size_ = v57;
        v91.__r_.__value_.__r.__words[2] = v66 | 0x8000000000000000;
        v91.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
        v13 = v64;
        if (v58)
          goto LABEL_104;
LABEL_105:
        v60 = &v59[v58];
        if (v56)
        {
          if (v55 >= 0)
            v61 = (const std::string::value_type *)v21;
          else
            v61 = *(const std::string::value_type **)v21;
          memmove(v60, v61, v56);
        }
        v60[v56] = 0;
        if (*((char *)v21 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)v21, *((_QWORD *)v21 + 1));
        }
        else
        {
          v62 = *v21;
          __dst.__r_.__value_.__r.__words[2] = *((_QWORD *)v21 + 2);
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v62;
        }
        v63 = v83;
        v67 = atomic_load((unsigned __int8 *)&qword_1ED114A98);
        if ((v67 & 1) == 0 && __cxa_guard_acquire(&qword_1ED114A98))
        {
          std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1ED114AC0, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
          __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1ED114AC0, &dword_1A343C000);
          __cxa_guard_release(&qword_1ED114A98);
          v63 = v83;
        }
        std::locale::locale((std::locale *)&v86, (const std::locale *)&unk_1ED114AC0);
        *(_OWORD *)&v86.__r_.__value_.__r.__words[1] = unk_1ED114AC8;
        v87 = unk_1ED114AD8;
        v88 = qword_1ED114AE8;
        v89 = (std::__shared_weak_count *)unk_1ED114AF0;
        if (unk_1ED114AF0)
        {
          v68 = (unint64_t *)(unk_1ED114AF0 + 8);
          do
            v69 = __ldxr(v68);
          while (__stxr(v69 + 1, v68));
        }
        v90 = qword_1ED114AF8;
        v70 = util::checkLogFileAge((uint64_t)&__dst, v63, (uint64_t)&v86);
        v71 = v89;
        if (!v89)
          goto LABEL_125;
        v72 = (unint64_t *)&v89->__shared_owners_;
        do
          v73 = __ldaxr(v72);
        while (__stlxr(v73 - 1, v72));
        if (!v73)
        {
          ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
          std::__shared_weak_count::__release_weak(v71);
          std::locale::~locale((std::locale *)&v86);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_126:
            if (v70)
              goto LABEL_132;
            goto LABEL_96;
          }
        }
        else
        {
LABEL_125:
          std::locale::~locale((std::locale *)&v86);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_126;
        }
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (v70)
        {
LABEL_132:
          v74 = *(NSObject **)(v84 + 40);
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            v75 = &v91;
            if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v75 = (std::string *)v91.__r_.__value_.__r.__words[0];
            LODWORD(v107.__r_.__value_.__l.__data_) = 67109378;
            HIDWORD(v107.__r_.__value_.__r.__words[0]) = v102;
            LOWORD(v107.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v107.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v75;
            _os_log_impl(&dword_1A343C000, v74, OS_LOG_TYPE_DEFAULT, "#I Removing log files older than %u days: %s ", (uint8_t *)&v107, 0x12u);
          }
          abm::LogManagementTask::remove_sync(v84, (std::string::size_type)&v91);
        }
LABEL_96:
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v91.__r_.__value_.__l.__data_);
          v21 = (__int128 *)((char *)v21 + 24);
          if (v21 == v82)
          {
LABEL_138:
            v21 = *(__int128 **)buf;
            goto LABEL_139;
          }
        }
        else
        {
          v21 = (__int128 *)((char *)v21 + 24);
          if (v21 == v82)
            goto LABEL_138;
        }
      }
      memset(&v91, 0, sizeof(v91));
      v59 = (char *)&v91;
      *((_BYTE *)&v91.__r_.__value_.__s + 23) = v56 + v54;
      if (!v54)
        goto LABEL_105;
LABEL_104:
      memcpy(v59, v53, v58);
      goto LABEL_105;
    }
  }
  std::locale::~locale((std::locale *)&v92);
  v21 = *(__int128 **)buf;
  v82 = *(__int128 **)&buf[8];
  if (*(_QWORD *)buf != *(_QWORD *)&buf[8])
    goto LABEL_98;
LABEL_139:
  if (v21)
  {
    v76 = *(__int128 **)&buf[8];
    v77 = v21;
    if (*(__int128 **)&buf[8] != v21)
    {
      do
      {
        if (*((char *)v76 - 1) < 0)
          operator delete(*((void **)v76 - 3));
        v76 = (__int128 *)((char *)v76 - 24);
      }
      while (v76 != v21);
      v77 = *(__int128 **)buf;
    }
    *(_QWORD *)&buf[8] = v21;
    operator delete(v77);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&__p, v99);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v103, (_QWORD *)v103[1]);
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v101.__r_.__value_.__l.__data_);
  operator delete(v1);
  v78 = (std::__shared_weak_count *)*((_QWORD *)a1 + 2);
  if (v78)
  {
    v79 = (unint64_t *)&v78->__shared_owners_;
    do
      v80 = __ldaxr(v79);
    while (__stlxr(v80 - 1, v79));
    if (!v80)
    {
      ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
      std::__shared_weak_count::__release_weak(v78);
    }
  }
  operator delete(a1);
}

void sub_1A34D62C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, _QWORD *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,std::locale a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,std::locale a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,_QWORD *a54,int a55,__int16 a56,char a57,char a58)
{
  uint64_t v58;
  void *v60;
  std::__shared_weak_count *v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  unint64_t *p_shared_owners;
  unint64_t v66;

  __cxa_guard_abort(&qword_1ED114A98);
  v62 = *(_QWORD *)(v58 - 128);
  if (v62)
  {
    v63 = *(_QWORD *)(v58 - 120);
    v64 = *(void **)(v58 - 128);
    if (v63 != v62)
    {
      do
      {
        if (*(char *)(v63 - 1) < 0)
          operator delete(*(void **)(v63 - 24));
        v63 -= 24;
      }
      while (v63 != v62);
      v64 = *(void **)(v58 - 128);
    }
    *(_QWORD *)(v58 - 120) = v62;
    operator delete(v64);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a53, a54);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v58 - 200, *(_QWORD **)(v58 - 192));
  if (*(char *)(v58 - 217) < 0)
  {
    operator delete(*(void **)(v58 - 240));
    operator delete(__p);
    v60 = a12;
    v61 = (std::__shared_weak_count *)a12[2];
    if (!v61)
      goto LABEL_18;
  }
  else
  {
    operator delete(__p);
    v60 = a12;
    v61 = (std::__shared_weak_count *)a12[2];
    if (!v61)
      goto LABEL_18;
  }
  p_shared_owners = (unint64_t *)&v61->__shared_owners_;
  do
    v66 = __ldaxr(p_shared_owners);
  while (__stlxr(v66 - 1, p_shared_owners));
  v60 = a12;
  if (!v66)
  {
    ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
    std::__shared_weak_count::__release_weak(v61);
  }
LABEL_18:
  operator delete(v60);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_29()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t abm::asString@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  switch((int)result)
  {
    case 0:
      a2[23] = 2;
      strcpy(a2, "UI");
      break;
    case 1:
      a2[23] = 7;
      strcpy(a2, "ABMtool");
      break;
    case 2:
      a2[23] = 7;
      strcpy(a2, "Profile");
      break;
    case 3:
      a2[23] = 10;
      strcpy(a2, "24hr_Timer");
      break;
    default:
      a2[23] = 11;
      strcpy(a2, "UnSpecified");
      break;
  }
  return result;
}

{
  if ((_DWORD)result == 1)
  {
    a2[23] = 4;
    strcpy(a2, "lite");
  }
  else if ((_DWORD)result)
  {
    a2[23] = 3;
    *(_DWORD *)a2 = 4144959;
  }
  else
  {
    a2[23] = 4;
    strcpy(a2, "main");
  }
  return result;
}

void INTTrace::createInternal(INTTrace **a1@<X8>)
{
  INTTrace *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;

  v3 = (INTTrace *)operator new(0x188uLL);
  INTTrace::INTTrace(v3);
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0AEA0;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  v6 = (std::__shared_weak_count *)*((_QWORD *)v3 + 10);
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      goto LABEL_14;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v9 = __ldxr(p_shared_weak_owners);
    while (__stxr(v9 + 1, p_shared_weak_owners));
    *((_QWORD *)v3 + 9) = v3;
    *((_QWORD *)v3 + 10) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    v11 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    *((_QWORD *)v3 + 9) = v3;
    *((_QWORD *)v3 + 10) = v4;
  }
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_14:
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v3);
  *a1 = v3;
  a1[1] = (INTTrace *)v4;
}

void sub_1A34D6840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A34D6854(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace*)#1}::operator() const(INTTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A34D6874(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A34D6888(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void INTTrace::INTTrace(INTTrace *this)
{
  capabilities::trace *v2;
  capabilities::trace *v3;
  capabilities::radio *v4;
  capabilities::abs *v5;
  capabilities::radio *shouldUseMinBasebandTransportIOReadSize;
  int v7;
  capabilities::abs *v8;
  int v9;
  uint64_t shouldUseMinBasebandTransportIOReadCount;
  int v11;
  void *__p[2];
  char v13;

  v13 = 8;
  strcpy((char *)__p, "trace.bb");
  v2 = (capabilities::trace *)Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v13 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_1E4A0AD10;
  *((_DWORD *)this + 38) = 0;
  *((_BYTE *)this + 156) = 0;
  v3 = (capabilities::trace *)capabilities::trace::defaultHistorySizeMB(v2);
  *((_DWORD *)this + 41) = (_DWORD)v3;
  v4 = (capabilities::radio *)capabilities::trace::defaultFileSizeBytes(v3);
  *(_QWORD *)((char *)this + 207) = 0;
  *(_QWORD *)((char *)this + 172) = v4;
  *((_BYTE *)this + 184) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *(_QWORD *)((char *)this + 215) = 0;
  *(_QWORD *)((char *)this + 223) = 0;
  *((_BYTE *)this + 231) = 0;
  *((_BYTE *)this + 272) = 0;
  v5 = (capabilities::abs *)capabilities::radio::vendor(v4);
  shouldUseMinBasebandTransportIOReadSize = (capabilities::radio *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v5);
  if ((_DWORD)shouldUseMinBasebandTransportIOReadSize)
    v7 = 0x4000;
  else
    v7 = 0x8000;
  *((_DWORD *)this + 69) = v7;
  v8 = (capabilities::abs *)capabilities::radio::vendor(shouldUseMinBasebandTransportIOReadSize);
  if (((_DWORD)v8 - 1) > 2)
    v9 = 23;
  else
    v9 = dword_1A3581C78[(int)v8 - 1];
  shouldUseMinBasebandTransportIOReadCount = capabilities::abs::shouldUseMinBasebandTransportIOReadCount(v8);
  if ((shouldUseMinBasebandTransportIOReadCount & 1) != 0)
    goto LABEL_10;
  if (v9 == 2)
  {
    v11 = 16;
    goto LABEL_16;
  }
  if (v9 == 16 || v9 == 15)
    v11 = 36;
  else
LABEL_10:
    v11 = 4;
LABEL_16:
  *((_DWORD *)this + 70) = v11;
  *((_BYTE *)this + 284) = 0;
  *((_DWORD *)this + 72) = capabilities::trace::defaultSleepTraceMode((capabilities::trace *)shouldUseMinBasebandTransportIOReadCount);
  *(_WORD *)((char *)this + 319) = 0;
  *((_BYTE *)this + 296) = 0;
  *((_BYTE *)this + 376) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_DWORD *)this + 95) = 1;
  *((_BYTE *)this + 384) = 0;
}

void sub_1A34D6A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::init(_QWORD *a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  _QWORD *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  _QWORD *v18;
  NSObject *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[2];
  std::string __p;
  uint64_t v27;
  std::__shared_weak_count *v28;
  dispatch_object_t object;
  unsigned __int8 v30;
  _QWORD block[6];

  v30 = 0;
  v25[0] = &v30;
  v25[1] = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    v7 = a1 + 9;
    v8 = (std::__shared_weak_count *)a3[1];
    v27 = *a3;
    v28 = v8;
    if (!v8)
      goto LABEL_7;
  }
  else
  {
    __p = *(std::string *)a2;
    v7 = a1 + 9;
    v8 = (std::__shared_weak_count *)a3[1];
    v27 = *a3;
    v28 = v8;
    if (!v8)
      goto LABEL_7;
  }
  p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
  do
    v10 = __ldxr(p_shared_weak_owners);
  while (__stxr(v10 + 1, p_shared_weak_owners));
LABEL_7:
  v11 = *a4;
  object = v11;
  if (v11)
    dispatch_retain(v11);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke;
  block[3] = &__block_descriptor_tmp_63_0;
  block[4] = v7;
  block[5] = v25;
  v12 = a1[11];
  if (a1[12])
  {
    dispatch_async_and_wait(v12, block);
    v13 = object;
    if (!object)
      goto LABEL_12;
    goto LABEL_11;
  }
  dispatch_sync(v12, block);
  v13 = object;
  if (object)
LABEL_11:
    dispatch_release(v13);
LABEL_12:
  if (v28)
    std::__shared_weak_count::__release_weak(v28);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v14 = (std::__shared_weak_count *)a1[10];
  if (!v14 || (v15 = a1[9], (v16 = std::__shared_weak_count::lock(v14)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v17 = v16;
  v18 = operator new(8uLL);
  *v18 = a1;
  v19 = a1[11];
  p_shared_owners = (unint64_t *)&v17->__shared_owners_;
  do
    v21 = __ldxr(p_shared_owners);
  while (__stxr(v21 + 1, p_shared_owners));
  v22 = operator new(0x18uLL);
  *v22 = v18;
  v22[1] = v15;
  v22[2] = v17;
  dispatch_async_f(v19, v22, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>(INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1,std::default_delete<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>>)::{lambda(void *)#1}::__invoke);
  do
    v23 = __ldaxr(p_shared_owners);
  while (__stlxr(v23 - 1, p_shared_owners));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  return v30;
}

void INTTrace::~INTTrace(INTTrace *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  dispatch_time_t v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint8_t v22[16];
  group v23;

  *(_QWORD *)this = off_1E4A0AD10;
  v2 = (char *)dispatch_group_create();
  v3 = v2;
  v4 = *((_QWORD *)this + 32);
  if (v4)
  {
    v23.gr_passwd = v2;
    if (v2)
      dispatch_retain((dispatch_object_t)v2);
    (*(void (**)(uint64_t, char **))(*(_QWORD *)v4 + 144))(v4, &v23.gr_passwd);
    if (v23.gr_passwd)
      dispatch_release((dispatch_object_t)v23.gr_passwd);
  }
  v23.gr_name = v3;
  if (v3)
    dispatch_retain((dispatch_object_t)v3);
  INTTrace::stop_sync(this, &v23);
  if (v3)
    dispatch_release((dispatch_object_t)v3);
  v5 = dispatch_time(0, 1000000000);
  if (dispatch_group_wait((dispatch_group_t)v3, v5))
  {
    v6 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v22 = 0;
      _os_log_error_impl(&dword_1A343C000, v6, OS_LOG_TYPE_ERROR, "Timeout for stopping trace service!", v22, 2u);
      *((_BYTE *)this + 156) = 0;
      if (!v3)
        goto LABEL_14;
      goto LABEL_13;
    }
  }
  *((_BYTE *)this + 156) = 0;
  if (v3)
LABEL_13:
    dispatch_release((dispatch_object_t)v3);
LABEL_14:
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 46);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = (std::__shared_weak_count *)*((_QWORD *)this + 44);
  if (v10)
  {
    v11 = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 42);
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      if ((*((char *)this + 319) & 0x80000000) == 0)
        goto LABEL_30;
      goto LABEL_29;
    }
  }
  if (*((char *)this + 319) < 0)
LABEL_29:
    operator delete(*((void **)this + 37));
LABEL_30:
  v16 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = (std::__shared_weak_count *)*((_QWORD *)this + 31);
  if (!v19)
    goto LABEL_39;
  v20 = (unint64_t *)&v19->__shared_owners_;
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 - 1, v20));
  if (v21)
  {
LABEL_39:
    if ((*((char *)this + 231) & 0x80000000) == 0)
      goto LABEL_40;
LABEL_45:
    operator delete(*((void **)this + 26));
    if ((*((char *)this + 207) & 0x80000000) == 0)
      goto LABEL_41;
LABEL_46:
    operator delete(*((void **)this + 23));
    goto LABEL_41;
  }
  ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
  std::__shared_weak_count::__release_weak(v19);
  if (*((char *)this + 231) < 0)
    goto LABEL_45;
LABEL_40:
  if (*((char *)this + 207) < 0)
    goto LABEL_46;
LABEL_41:
  Trace::~Trace(this);
}

{
  void *v1;

  INTTrace::~INTTrace(this);
  operator delete(v1);
}

void INTTrace::stop_sync(INTTrace *this, group *a2)
{
  NSObject *v4;
  uint64_t v5;
  char *gr_name;
  char v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  _BYTE v16[8];
  _QWORD *v17;
  void *v18;
  char v19;
  void *v20;
  char v21;
  void *v22;
  char v23;
  _BYTE v24[8];
  _QWORD *v25;
  void *v26;
  char v27;
  void *v28[2];
  char v29;
  char *v30;
  void *__p;
  char v32;
  void *v33;
  char v34;
  _BYTE v35[8];
  _QWORD *v36;
  void *v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  _BYTE v42[8];
  _QWORD *v43;
  void *v44;
  char v45;
  uint8_t buf[4];
  const char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping BB Trace", buf, 2u);
  }
  if (!*((_QWORD *)this + 41))
    goto LABEL_5;
  v45 = 0;
  LOBYTE(v44) = 0;
  Timestamp::Timestamp((Timestamp *)v42);
  v41 = 0;
  LOWORD(v40) = 0;
  LOBYTE(v39) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v42, v43);
  if (v45 < 0)
  {
    operator delete(v44);
    if (!*((_QWORD *)this + 43))
      goto LABEL_9;
  }
  else
  {
LABEL_5:
    if (!*((_QWORD *)this + 43))
      goto LABEL_9;
  }
  v38 = 0;
  LOBYTE(v37) = 0;
  Timestamp::Timestamp((Timestamp *)v35);
  v34 = 0;
  LOBYTE(v33) = 0;
  v32 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v35, v36);
  if (v38 < 0)
    operator delete(v37);
LABEL_9:
  if (*((char *)this + 207) < 0)
  {
    if (!*((_QWORD *)this + 24))
      goto LABEL_24;
  }
  else if (!*((_BYTE *)this + 207))
  {
    goto LABEL_24;
  }
  v5 = *((_QWORD *)this + 32);
  if (!v5 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 152))(v5))
  {
LABEL_24:
    v12 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v9 = "#I Skip the configuration for the trace";
      v10 = v12;
      v11 = 2;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  gr_name = a2->gr_name;
  v30 = gr_name;
  if (gr_name)
    dispatch_retain((dispatch_object_t)gr_name);
  v29 = 4;
  strcpy((char *)v28, "Stop");
  v7 = INTTrace::sendConfig_sync((uint64_t)this, (dispatch_object_t *)&v30, (const std::string::value_type *)v28, 0, 0, 1);
  if (v29 < 0)
    operator delete(v28[0]);
  if (gr_name)
    dispatch_release((dispatch_object_t)gr_name);
  v8 = *((_QWORD *)this + 5);
  if ((v7 & 1) != 0)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v47 = "Stop";
      v9 = "#I Succeeded sending config: %s";
      v10 = v8;
      v11 = 12;
LABEL_26:
      _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
    }
  }
  else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    v47 = "Stop";
    _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to send config: %s", buf, 0xCu);
  }
LABEL_27:
  INTTrace::stopReader_sync(this);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  if (!v13)
    goto LABEL_31;
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    *((_BYTE *)this + 284) = 0;
    if (!*((_QWORD *)this + 41))
      goto LABEL_35;
  }
  else
  {
LABEL_31:
    *((_BYTE *)this + 284) = 0;
    if (!*((_QWORD *)this + 41))
      goto LABEL_35;
  }
  v27 = 0;
  LOBYTE(v26) = 0;
  Timestamp::Timestamp((Timestamp *)v24);
  v23 = 0;
  LOBYTE(v22) = 0;
  v21 = 0;
  LOBYTE(v20) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v24, v25);
  if (v27 < 0)
    operator delete(v26);
LABEL_35:
  if (*((_QWORD *)this + 43))
  {
    v19 = 0;
    LOBYTE(v18) = 0;
    Timestamp::Timestamp((Timestamp *)v16);
    abm::trace::TraceInfo::push();
    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v16, v17);
    if (v19 < 0)
      operator delete(v18);
  }
}

void sub_1A34D73F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  NSObject *v38;

  if (a38 < 0)
    operator delete(__p);
  if (v38)
  {
    dispatch_release(v38);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

const char *INTTrace::getName(INTTrace *this)
{
  return "trace.bb";
}

void INTTrace::getSettingPrefix(char *a1@<X8>)
{
  a1[23] = 15;
  strcpy(a1, "BasebandTrace::");
}

void INTTrace::reinit(uint64_t a1)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl(&dword_1A343C000, v1, OS_LOG_TYPE_DEFAULT, "#I Not implemented yet: reinit", v2, 2u);
  }
}

void INTTrace::prepare(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[10];
  if (!v4 || (v5 = a1[9], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(0x10uLL);
  *v8 = v3;
  v8[1] = a1;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[11];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
  {
    if (v3)
    {
LABEL_11:
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (v3)
      goto LABEL_11;
  }
}

void INTTrace::start(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  dispatch_object_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  NSObject *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    v5 = *a2;
    if (*a2)
      dispatch_retain(*a2);
  }
  else
  {
    v5 = 0;
  }
  v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = operator new(0x10uLL);
  *v10 = a1;
  v10[1] = v5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v12 = a1[11];
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v14 = operator new(0x18uLL);
  *v14 = v10;
  v14[1] = v7;
  v14[2] = v9;
  dispatch_async_f(v12, v14, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (v15)
  {
    if (v3)
    {
LABEL_13:
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (v3)
      goto LABEL_13;
  }
}

void INTTrace::stop(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  dispatch_object_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  NSObject *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    v5 = *a2;
    if (*a2)
      dispatch_retain(*a2);
  }
  else
  {
    v5 = 0;
  }
  v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = operator new(0x10uLL);
  *v10 = a1;
  v10[1] = v5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v12 = a1[11];
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v14 = operator new(0x18uLL);
  *v14 = v10;
  v14[1] = v7;
  v14[2] = v9;
  dispatch_async_f(v12, v14, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (v15)
  {
    if (v3)
    {
LABEL_13:
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (v3)
      goto LABEL_13;
  }
}

void INTTrace::abort(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  dispatch_object_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  NSObject *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    v5 = *a2;
    if (*a2)
      dispatch_retain(*a2);
  }
  else
  {
    v5 = 0;
  }
  v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = operator new(0x10uLL);
  *v10 = a1;
  v10[1] = v5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v12 = a1[11];
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v14 = operator new(0x18uLL);
  *v14 = v10;
  v14[1] = v7;
  v14[2] = v9;
  dispatch_async_f(v12, v14, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (v15)
  {
    if (v3)
    {
LABEL_13:
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (v3)
      goto LABEL_13;
  }
}

void INTTrace::shutdown(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  dispatch_object_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  NSObject *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_retain(v3);
    dispatch_group_enter(v3);
    v5 = *a2;
    if (*a2)
      dispatch_retain(*a2);
  }
  else
  {
    v5 = 0;
  }
  v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = operator new(0x18uLL);
  *v10 = v3;
  v10[1] = a1;
  v10[2] = v5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v12 = a1[11];
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v14 = operator new(0x18uLL);
  *v14 = v10;
  v14[1] = v7;
  v14[2] = v9;
  dispatch_async_f(v12, v14, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (v15)
  {
    if (v3)
    {
LABEL_13:
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (v3)
      goto LABEL_13;
  }
}

void INTTrace::enterLowPower(INTTrace *this, group *a2)
{
  char *gr_name;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  gr_name = a2->gr_name;
  if (a2->gr_name)
  {
    dispatch_retain((dispatch_object_t)a2->gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
    dispatch_retain((dispatch_object_t)gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
  }
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v4 || (v5 = *((_QWORD *)this + 9), (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(0x10uLL);
  *v8 = gr_name;
  v8[1] = this;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = *((_QWORD *)this + 11);
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::enterLowPower(dispatch::group)::$_0>(INTTrace::enterLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::enterLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::enterLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
  {
    if (gr_name)
    {
LABEL_11:
      dispatch_group_leave((dispatch_group_t)gr_name);
      dispatch_release((dispatch_object_t)gr_name);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (gr_name)
      goto LABEL_11;
  }
}

void INTTrace::exitLowPower(INTTrace *this, group *a2)
{
  char *gr_name;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  gr_name = a2->gr_name;
  if (a2->gr_name)
  {
    dispatch_retain((dispatch_object_t)a2->gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
    dispatch_retain((dispatch_object_t)gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
  }
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v4 || (v5 = *((_QWORD *)this + 9), (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new(0x10uLL);
  *v8 = gr_name;
  v8[1] = this;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = *((_QWORD *)this + 11);
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = operator new(0x18uLL);
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::exitLowPower(dispatch::group)::$_0>(INTTrace::exitLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::exitLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::exitLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
  {
    if (gr_name)
    {
LABEL_11:
      dispatch_group_leave((dispatch_group_t)gr_name);
      dispatch_release((dispatch_object_t)gr_name);
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (gr_name)
      goto LABEL_11;
  }
}

uint64_t INTTrace::snapshot(NSObject *a1, NSObject **a2, const __CFDictionary **a3)
{
  NSObject *isa;
  NSObject *v7;
  const __CFDictionary *v8;
  std::__shared_weak_count *v9;
  Class v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  _OWORD *v13;
  __int128 v14;
  std::string::size_type v15;
  CFTypeRef v16;
  unint64_t *p_shared_owners;
  NSObject *v18;
  unint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  CFTypeRef v22;
  dispatch_group_t group[2];
  std::string __p;
  CFTypeRef cf;
  std::string v27;
  _QWORD v28[2];
  uint64_t v29;

  isa = a1[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl(&dword_1A343C000, isa, OS_LOG_TYPE_DEFAULT, "#I Snapshotting!", (uint8_t *)group, 2u);
  }
  v28[0] = 0xAAAAAAAAAAAAAAAALL;
  v28[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v28, *a3);
  memset(&v27, 170, sizeof(v27));
  group[0] = 0;
  group[1] = 0;
  __p.__r_.__value_.__r.__words[0] = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v29, "kKeyTraceDumpStateReason");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](&v29);
  if (__p.__r_.__value_.__s.__data_[7] < 0)
  {
    operator delete(group[0]);
    v7 = *a2;
    if (v7)
    {
LABEL_5:
      dispatch_retain(v7);
      dispatch_group_enter(v7);
      group[0] = v7;
      dispatch_retain(v7);
      if (group[0])
        dispatch_group_enter(group[0]);
      group[1] = a1;
      if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_8;
      goto LABEL_11;
    }
  }
  else
  {
    v7 = *a2;
    if (v7)
      goto LABEL_5;
  }
  group[0] = 0;
  group[1] = a1;
  if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_8:
    __p = v27;
    goto LABEL_12;
  }
LABEL_11:
  std::string::__init_copy_ctor_external(&__p, v27.__r_.__value_.__l.__data_, v27.__r_.__value_.__l.__size_);
LABEL_12:
  v8 = *a3;
  cf = v8;
  if (v8)
    CFRetain(v8);
  v9 = (std::__shared_weak_count *)a1[10].isa;
  if (!v9 || (v10 = a1[9].isa, (v11 = std::__shared_weak_count::lock(v9)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v12 = v11;
  v13 = operator new(0x30uLL);
  v14 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *v13 = *(_OWORD *)group;
  v13[1] = v14;
  v15 = __p.__r_.__value_.__r.__words[2];
  memset(&__p, 0, sizeof(__p));
  v16 = cf;
  *((_QWORD *)v13 + 4) = v15;
  *((_QWORD *)v13 + 5) = v16;
  group[0] = 0;
  cf = 0;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v18 = a1[11].isa;
  do
    v19 = __ldxr(p_shared_owners);
  while (__stxr(v19 + 1, p_shared_owners));
  v20 = operator new(0x18uLL);
  *v20 = v13;
  v20[1] = v10;
  v20[2] = v12;
  dispatch_async_f(v18, v20, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    v22 = cf;
    if (!cf)
      goto LABEL_25;
    goto LABEL_24;
  }
  v22 = cf;
  if (cf)
LABEL_24:
    CFRelease(v22);
LABEL_25:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (group[0])
  {
    dispatch_group_leave(group[0]);
    if (group[0])
      dispatch_release(group[0]);
  }
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v27.__r_.__value_.__l.__data_);
  return MEMORY[0x1A858F2D8](v28);
}

void sub_1A34D80D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  NSObject *v24;

  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (v24)
  {
    dispatch_group_leave(v24);
    dispatch_release(v24);
  }
  if (a23 < 0)
    operator delete(__p);
  MEMORY[0x1A858F2D8](&a24);
  _Unwind_Resume(a1);
}

void INTTrace::dumpState(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  std::string *v9;
  NSObject *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  std::string __p;

  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    v4 = (std::__shared_weak_count *)a1[10];
    if (!v4)
      goto LABEL_18;
  }
  else
  {
    __p = *(std::string *)a3;
    v4 = (std::__shared_weak_count *)a1[10];
    if (!v4)
LABEL_18:
      std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  v5 = a1[9];
  v6 = std::__shared_weak_count::lock(v4);
  if (!v6)
    goto LABEL_18;
  v7 = v6;
  v8 = operator new(0x20uLL);
  *v8 = a1;
  v9 = (std::string *)(v8 + 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v9, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v8[3] = *((_QWORD *)&__p.__r_.__value_.__l + 2);
  }
  v10 = a1[11];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  v13 = operator new(0x18uLL);
  *v13 = v8;
  v13[1] = v5;
  v13[2] = v7;
  dispatch_async_f(v10, v13, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::dumpState(dispatch::group,std::string)::$_0>(INTTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<INTTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke);
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_17:
    operator delete(__p.__r_.__value_.__l.__data_);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_17;
}

BOOL INTTrace::setProperty(_QWORD *a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  const std::string::value_type *v14;
  const std::string::value_type *v15;
  unsigned __int8 v16;
  _QWORD block[6];
  _BYTE buf[32];
  uint64_t v19;
  _QWORD *v20;
  dispatch_object_t object;
  std::string __p;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v8 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v8);
    v16 = 0;
    *(_QWORD *)buf = &v16;
    *(_QWORD *)&buf[8] = v8;
    dispatch_retain(v8);
    if (*(_QWORD *)&buf[8])
      dispatch_group_enter(*(dispatch_group_t *)&buf[8]);
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
      goto LABEL_5;
  }
  else
  {
    v16 = 0;
    *(_QWORD *)buf = &v16;
    *(_QWORD *)&buf[8] = 0;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
    {
LABEL_5:
      *(_OWORD *)&buf[16] = *(_OWORD *)a3;
      v19 = *(_QWORD *)(a3 + 16);
      goto LABEL_8;
    }
  }
  std::string::__init_copy_ctor_external((std::string *)&buf[16], *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
LABEL_8:
  v9 = *a2;
  v20 = a1;
  object = v9;
  if (v9)
    dispatch_retain(v9);
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke;
  block[3] = &__block_descriptor_tmp_66_0;
  block[4] = a1 + 9;
  block[5] = buf;
  v10 = a1[11];
  if (a1[12])
  {
    dispatch_async_and_wait(v10, block);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_16;
    goto LABEL_15;
  }
  dispatch_sync(v10, block);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_15:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_16:
  if (object)
    dispatch_release(object);
  if (SHIBYTE(v19) < 0)
    operator delete(*(void **)&buf[16]);
  if (*(_QWORD *)&buf[8])
  {
    dispatch_group_leave(*(dispatch_group_t *)&buf[8]);
    if (*(_QWORD *)&buf[8])
      dispatch_release(*(dispatch_object_t *)&buf[8]);
  }
  if (v16)
  {
    v11 = 1;
    if (!v8)
      return v11 != 0;
    goto LABEL_30;
  }
  v12 = a1[5];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a3 + 23) >= 0)
      v14 = (const std::string::value_type *)a3;
    else
      v14 = *(const std::string::value_type **)a3;
    if (*(char *)(a4 + 23) >= 0)
      v15 = (const std::string::value_type *)a4;
    else
      v15 = *(const std::string::value_type **)a4;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v14;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v15;
    _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "Setting %s to %s failed", buf, 0x16u);
    v11 = v16;
    if (v8)
      goto LABEL_30;
  }
  else
  {
    v11 = 0;
    if (v8)
    {
LABEL_30:
      dispatch_group_leave(v8);
      dispatch_release(v8);
    }
  }
  return v11 != 0;
}

void sub_1A34D853C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_group_t group, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,dispatch_object_t object)
{
  NSObject *v26;
  NSObject *v28;

  if (object)
  {
    dispatch_release(object);
    if ((a24 & 0x80000000) == 0)
    {
LABEL_3:
      v28 = group;
      if (!group)
      {
LABEL_8:
        if (v26)
        {
          dispatch_group_leave(v26);
          dispatch_release(v26);
        }
        _Unwind_Resume(exception_object);
      }
LABEL_7:
      dispatch_group_leave(v28);
      dispatch_release(group);
      goto LABEL_8;
    }
  }
  else if ((a24 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(__p);
  v28 = group;
  if (!group)
    goto LABEL_8;
  goto LABEL_7;
}

uint64_t INTTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  NSObject *v5;
  _QWORD v7[2];
  std::string __p;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD block[6];

  v10 = 1;
  v4 = a1 + 72;
  v7[0] = &v10;
  v7[1] = a3;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  v9 = a1;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke;
  block[3] = &__block_descriptor_tmp_68_0;
  block[4] = v4;
  block[5] = v7;
  v5 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(a1 + 96))
  {
    dispatch_async_and_wait(v5, block);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v10;
  }
  else
  {
    dispatch_sync(v5, block);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v10;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  return v10;
}

void INTTrace::initBootSessionPrefs_sync(INTTrace *this)
{
  _BOOL4 v2;
  BOOL v3;
  NSObject *v4;
  NSObject *v5;
  std::string *p_p;
  void **v7;
  char v8;
  void *v9;
  std::string::size_type size;
  std::string *v11;
  void **v12;
  uint64_t v13;
  NSObject *v14;
  void **v15;
  char v16;
  char v17;
  NSObject *v18;
  void **v19;
  _BOOL4 v20;
  void **v21;
  size_t v22;
  int v23;
  NSObject *v24;
  _BOOL4 v25;
  int v26;
  NSObject *v27;
  _BOOL4 v28;
  void **v29;
  char v30;
  NSObject *v31;
  char v32;
  NSObject *v33;
  char v34;
  NSObject *v35;
  std::string *v36;
  size_t v37;
  std::string *v38;
  void **v39;
  void *v40[4];
  std::string __p;
  void *__s1[3];
  std::string v43;
  std::string v44;
  std::string v45;
  std::string buf;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  memset(__s1, 170, sizeof(__s1));
  Trace::getCurrentBootSessionUUID(__s1);
  memset(&__p, 0, sizeof(__p));
  *((_BYTE *)&v43.__r_.__value_.__s + 23) = 15;
  strcpy((char *)&v43, "BootSessionUUID");
  *((_BYTE *)&v44.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v44, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v2 = defaults::get((char *)&v44, (char *)&v43, &buf);
  v3 = v2;
  if (v2)
  {
    prop::file::get<std::string>((const void **)&v44.__r_.__value_.__l.__data_, (uint64_t)&v43, (uint64_t)&buf, &v45);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v45;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_8;
      goto LABEL_12;
    }
  }
  else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(v44.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_8:
    if (v3)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_12:
  operator delete(v43.__r_.__value_.__l.__data_);
  if (v3)
    goto LABEL_14;
LABEL_13:
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Failed to get boot session uuid from preferences", (uint8_t *)&buf, 2u);
    v5 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
    goto LABEL_15;
  }
LABEL_14:
  v5 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    goto LABEL_20;
LABEL_15:
  p_p = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v7 = __s1;
  if (SHIBYTE(__s1[2]) < 0)
    v7 = (void **)__s1[0];
  LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v7;
  _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#N prefs boot session uuid: %s, current boot session uuid: %s", (uint8_t *)&buf, 0x16u);
LABEL_20:
  v8 = HIBYTE(__s1[2]);
  if (SHIBYTE(__s1[2]) >= 0)
    v9 = (void *)HIBYTE(__s1[2]);
  else
    v9 = __s1[1];
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v9 != (void *)size)
  {
LABEL_35:
    v14 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_40;
    if (v8 >= 0)
      v15 = __s1;
    else
      v15 = (void **)__s1[0];
    goto LABEL_39;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &__p;
  else
    v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((HIBYTE(__s1[2]) & 0x80) != 0)
  {
    v15 = (void **)__s1[0];
    if (memcmp(__s1[0], v11, (size_t)__s1[1]))
    {
      v14 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
LABEL_40:
        *((_BYTE *)&buf.__r_.__value_.__s + 23) = 15;
        strcpy((char *)&buf, "BootSessionUUID");
        v16 = prop::bbtrace::set((char *)&buf, (const char *)__s1);
        v17 = v16;
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(buf.__r_.__value_.__l.__data_);
          if ((v17 & 1) != 0)
            goto LABEL_45;
        }
        else if ((v16 & 1) != 0)
        {
          goto LABEL_45;
        }
        v18 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v38 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
          v39 = __s1;
          if (SHIBYTE(__s1[2]) < 0)
            v39 = (void **)__s1[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v39;
          _os_log_error_impl(&dword_1A343C000, v18, OS_LOG_TYPE_ERROR, "Failed to set boot session uuid in pref from %s -> %s", (uint8_t *)&buf, 0x16u);
          v19 = (void **)((char *)this + 208);
          if ((void **)((char *)this + 208) == __s1)
          {
LABEL_120:
            *((_BYTE *)&v45.__r_.__value_.__s + 23) = 4;
            strcpy((char *)&v45, "Mode");
            memset(&v44, 0, sizeof(v44));
            std::to_string(&buf, 0);
            v44 = buf;
            v30 = prop::bbtrace::set((char *)&v45, (const char *)&v44);
            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v44.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_122:
                if ((v30 & 1) != 0)
                  goto LABEL_128;
                goto LABEL_126;
              }
            }
            else if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_122;
            }
            operator delete(v45.__r_.__value_.__l.__data_);
            if ((v30 & 1) != 0)
              goto LABEL_128;
LABEL_126:
            v31 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl(&dword_1A343C000, v31, OS_LOG_TYPE_ERROR, "Failed to reset trace mode for new boot instance", (uint8_t *)&buf, 2u);
            }
LABEL_128:
            *((_DWORD *)this + 38) = 0;
            *((_BYTE *)&v45.__r_.__value_.__s + 23) = 14;
            strcpy((char *)&v45, "TraceOwnership");
            memset(&v44, 0, sizeof(v44));
            std::to_string(&buf, 0);
            v44 = buf;
            v32 = prop::bbtrace::set((char *)&v45, (const char *)&v44);
            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v44.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_130:
                if ((v32 & 1) != 0)
                  goto LABEL_136;
                goto LABEL_134;
              }
            }
            else if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_130;
            }
            operator delete(v45.__r_.__value_.__l.__data_);
            if ((v32 & 1) != 0)
              goto LABEL_136;
LABEL_134:
            v33 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl(&dword_1A343C000, v33, OS_LOG_TYPE_ERROR, "Failed to reset trace transport owner id for new boot instance", (uint8_t *)&buf, 2u);
            }
LABEL_136:
            *((_DWORD *)this + 58) = 0;
            *((_BYTE *)&v45.__r_.__value_.__s + 23) = 19;
            strcpy((char *)&v45, "Live_Filter_Setting");
            memset(&v44, 0, sizeof(v44));
            std::to_string(&buf, 0);
            v44 = buf;
            v34 = prop::bbtrace::set((char *)&v45, (const char *)&v44);
            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v44.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_138:
                if ((v34 & 1) != 0)
                  goto LABEL_144;
                goto LABEL_142;
              }
            }
            else if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_138;
            }
            operator delete(v45.__r_.__value_.__l.__data_);
            if ((v34 & 1) != 0)
            {
LABEL_144:
              *((_DWORD *)this + 42) = 0;
              goto LABEL_145;
            }
LABEL_142:
            v35 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl(&dword_1A343C000, v35, OS_LOG_TYPE_ERROR, "Failed to reset trace live filter setting for new boot instance", (uint8_t *)&buf, 2u);
            }
            goto LABEL_144;
          }
LABEL_46:
          if (*((char *)this + 231) < 0)
          {
            if (SHIBYTE(__s1[2]) >= 0)
              v21 = __s1;
            else
              v21 = (void **)__s1[0];
            if (SHIBYTE(__s1[2]) >= 0)
              v22 = HIBYTE(__s1[2]);
            else
              v22 = (size_t)__s1[1];
            std::string::__assign_no_alias<false>(v19, v21, v22);
          }
          else if ((HIBYTE(__s1[2]) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>(v19, __s1[0], (size_t)__s1[1]);
          }
          else
          {
            *(_OWORD *)v19 = *(_OWORD *)__s1;
            v19[2] = __s1[2];
          }
          goto LABEL_120;
        }
LABEL_45:
        v19 = (void **)((char *)this + 208);
        if ((void **)((char *)this + 208) == __s1)
          goto LABEL_120;
        goto LABEL_46;
      }
LABEL_39:
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#N New boot instance (%s) for INT Trace", (uint8_t *)&buf, 0xCu);
      goto LABEL_40;
    }
  }
  else if (HIBYTE(__s1[2]))
  {
    v12 = __s1;
    v13 = HIBYTE(__s1[2]);
    while (*(unsigned __int8 *)v12 == v11->__r_.__value_.__s.__data_[0])
    {
      v12 = (void **)((char *)v12 + 1);
      v11 = (std::string *)((char *)v11 + 1);
      if (!--v13)
        goto LABEL_52;
    }
    goto LABEL_35;
  }
LABEL_52:
  HIBYTE(v40[2]) = 4;
  strcpy((char *)v40, "Mode");
  memset(&v43, 0, sizeof(v43));
  *((_BYTE *)&v44.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v44, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v20 = defaults::get((char *)&v44, (char *)v40, &buf);
  if (v20)
  {
    prop::file::get<std::string>((const void **)&v44.__r_.__value_.__l.__data_, (uint64_t)v40, (uint64_t)&buf, &v45);
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v43.__r_.__value_.__l.__data_);
    v43 = v45;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_58:
      if (!v20)
        goto LABEL_71;
      goto LABEL_69;
    }
  }
  else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_58;
  }
  operator delete(v44.__r_.__value_.__l.__data_);
  if (!v20)
    goto LABEL_71;
LABEL_69:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v23 = util::convert<int>(&v43, &buf, 0);
  LOBYTE(v20) = v23;
  if (v23)
    *((_DWORD *)this + 38) = buf.__r_.__value_.__l.__data_;
LABEL_71:
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v40[2]) & 0x80000000) == 0)
    {
LABEL_73:
      if (v20)
        goto LABEL_79;
      goto LABEL_77;
    }
  }
  else if ((SHIBYTE(v40[2]) & 0x80000000) == 0)
  {
    goto LABEL_73;
  }
  operator delete(v40[0]);
  if (v20)
    goto LABEL_79;
LABEL_77:
  v24 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v24, OS_LOG_TYPE_ERROR, "Failed to get trace mode from preferences for same boot instance", (uint8_t *)&buf, 2u);
  }
LABEL_79:
  HIBYTE(v40[2]) = 14;
  strcpy((char *)v40, "TraceOwnership");
  memset(&v43, 0, sizeof(v43));
  *((_BYTE *)&v44.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v44, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v25 = defaults::get((char *)&v44, (char *)v40, &buf);
  if (v25)
  {
    prop::file::get<std::string>((const void **)&v44.__r_.__value_.__l.__data_, (uint64_t)v40, (uint64_t)&buf, &v45);
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v43.__r_.__value_.__l.__data_);
    v43 = v45;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_85:
      if (!v25)
        goto LABEL_91;
      goto LABEL_89;
    }
  }
  else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_85;
  }
  operator delete(v44.__r_.__value_.__l.__data_);
  if (!v25)
    goto LABEL_91;
LABEL_89:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v26 = util::convert<int>(&v43, &buf, 0);
  LOBYTE(v25) = v26;
  if (v26)
    *((_DWORD *)this + 58) = buf.__r_.__value_.__l.__data_;
LABEL_91:
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v40[2]) & 0x80000000) == 0)
    {
LABEL_93:
      if (v25)
        goto LABEL_99;
      goto LABEL_97;
    }
  }
  else if ((SHIBYTE(v40[2]) & 0x80000000) == 0)
  {
    goto LABEL_93;
  }
  operator delete(v40[0]);
  if (v25)
    goto LABEL_99;
LABEL_97:
  v27 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v27, OS_LOG_TYPE_ERROR, "Failed to get transport owner id from preferences for same boot instance", (uint8_t *)&buf, 2u);
  }
LABEL_99:
  HIBYTE(v40[2]) = 19;
  strcpy((char *)v40, "Live_Filter_Setting");
  memset(&v43, 0, sizeof(v43));
  *((_BYTE *)&v44.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v44, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v28 = defaults::get((char *)&v44, (char *)v40, &buf);
  if (v28)
  {
    prop::file::get<std::string>((const void **)&v44.__r_.__value_.__l.__data_, (uint64_t)v40, (uint64_t)&buf, &v45);
    v43 = v45;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_103:
      if (!v28)
        goto LABEL_109;
      goto LABEL_107;
    }
  }
  else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_103;
  }
  operator delete(v44.__r_.__value_.__l.__data_);
  if (!v28)
    goto LABEL_109;
LABEL_107:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&v43, &buf, 0))
    *((_DWORD *)this + 42) = buf.__r_.__value_.__l.__data_;
LABEL_109:
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v40[2]) & 0x80000000) == 0)
    {
LABEL_111:
      v29 = (void **)((char *)this + 208);
      if ((std::string *)((char *)this + 208) == &__p)
        goto LABEL_145;
      goto LABEL_115;
    }
  }
  else if ((SHIBYTE(v40[2]) & 0x80000000) == 0)
  {
    goto LABEL_111;
  }
  operator delete(v40[0]);
  v29 = (void **)((char *)this + 208);
  if ((std::string *)((char *)this + 208) == &__p)
    goto LABEL_145;
LABEL_115:
  if (*((char *)this + 231) < 0)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v36 = &__p;
    else
      v36 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      v37 = __p.__r_.__value_.__l.__size_;
    std::string::__assign_no_alias<false>(v29, v36, v37);
  }
  else
  {
    if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
    {
      *(std::string *)v29 = __p;
      if ((SHIBYTE(__s1[2]) & 0x80000000) == 0)
        return;
      goto LABEL_149;
    }
    std::string::__assign_no_alias<true>(v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
LABEL_145:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__s1[2]) & 0x80000000) == 0)
      return;
LABEL_149:
    operator delete(__s1[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__s1[2]) < 0)
    goto LABEL_149;
}

void sub_1A34D91E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
  {
    operator delete(a22);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void INTTrace::prepare_sync(INTTrace *this)
{
  NSObject *v2;
  uint64_t v3;
  const char *v4;
  NSObject *v5;
  unsigned int v6;
  char *v7;
  size_t v8;
  std::string::size_type v9;
  std::string *v10;
  char v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  std::string *v20;
  __int128 v21;
  char *v22;
  size_t v23;
  std::string::size_type v24;
  std::string *v25;
  uint64_t v26;
  uint64_t v27;
  std::string *v28;
  __int128 v29;
  std::string::size_type v30;
  _QWORD *v31;
  __int128 v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  os_unfair_lock_s *v41;
  std::string *v42;
  BOOL *v43;
  BOOL *v44;
  CFTypeID v45;
  const __CFBoolean *v46;
  std::__shared_weak_count *v47;
  char *v48;
  size_t v49;
  std::string::size_type v50;
  std::string *p_buf;
  unint64_t *v52;
  unint64_t v53;
  NSObject *v54;
  std::string *v55;
  NSObject *v56;
  void **v57;
  std::string::size_type v58;
  _QWORD *v59;
  __int128 v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t *v67;
  unint64_t v68;
  void *v69;
  std::string *v70;
  void *v71;
  const __CFString *v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  NSObject *v76;
  std::string *v77;
  NSObject *v78;
  void **v79;
  char started;
  NSObject *v81;
  char *v82;
  size_t v83;
  std::string::size_type v84;
  std::string *v85;
  char *v86;
  size_t v87;
  std::string::size_type v88;
  std::string *v89;
  char *v90;
  size_t v91;
  std::string::size_type v92;
  std::string *v93;
  uint64_t v94;
  uint64_t v95;
  std::string *v96;
  void *v97;
  char v98;
  char *v99;
  size_t v100;
  std::string::size_type v101;
  std::string *v102;
  uint64_t v103;
  uint64_t v104;
  std::string *v105;
  void *v106;
  char v107;
  char *v108;
  size_t v109;
  std::string::size_type v110;
  std::string *v111;
  uint64_t v112;
  uint64_t v113;
  std::string *v114;
  void *v115;
  char v116;
  NSObject *v117;
  void **v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  std::string *v122;
  void *v123;
  char v124;
  void **v125;
  NSObject *v126;
  uint32_t v127;
  uint64_t v128;
  uint64_t v129;
  std::string *v130;
  const __CFString *v131;
  char v132;
  NSObject *v133;
  void **v134;
  CFStringRef *v135;
  uint64_t v136;
  uint64_t v137;
  std::string *v138;
  const __CFString *v139;
  char v140;
  void **v141;
  CFStringRef *v142;
  _BOOL4 v143;
  char *v144;
  char *v145;
  int v146;
  int v147;
  unsigned __int8 v148;
  uint64_t v149;
  unint64_t *v150;
  unint64_t v151;
  __int128 v152;
  std::__shared_weak_count *v153;
  unint64_t *p_shared_owners;
  unint64_t v155;
  std::__shared_weak_count *size;
  unint64_t *v157;
  unint64_t v158;
  unint64_t *v159;
  unint64_t v160;
  NSObject *v161;
  void *v162;
  void *v163;
  _BYTE v164[64];
  __int128 v165;
  void *v166[4];
  CFStringRef key[3];
  void *v168[3];
  std::string v169;
  void *__p[6];
  std::string v171;
  __int128 v172;
  void *v173[2];
  void *v174[5];
  __int128 v175;
  unint64_t v176;
  std::string buf;
  __int128 v178;
  __int128 v179;
  void *v180[6];
  __int128 v181;
  uint64_t v182;

  v182 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((int *)this + 38);
    if (v3 > 6)
      v4 = "Unknown";
    else
      v4 = off_1E4A0B008[v3];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Preparing BB Trace with mode: %s", (uint8_t *)&buf, 0xCu);
  }
  if (!*((_QWORD *)this + 30) && !*((_DWORD *)this + 38))
  {
    memset(v168, 0, sizeof(v168));
    memset(key, 0, sizeof(key));
    switch(*((_DWORD *)this + 42))
    {
      case 0:
        v48 = abm::trace::kScratchFolder[0];
        v49 = strlen(abm::trace::kScratchFolder[0]);
        if (v49 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v50 = v49;
        if (v49 >= 0x17)
        {
          v112 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v49 | 7) != 0x17)
            v112 = v49 | 7;
          v113 = v112 + 1;
          p_buf = (std::string *)operator new(v112 + 1);
          buf.__r_.__value_.__l.__size_ = v50;
          buf.__r_.__value_.__r.__words[2] = v113 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
        }
        else
        {
          *((_BYTE *)&buf.__r_.__value_.__s + 23) = v49;
          p_buf = &buf;
          if (!v49)
          {
LABEL_178:
            p_buf->__r_.__value_.__s.__data_[v50] = 0;
            v114 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
            v115 = (void *)v114->__r_.__value_.__r.__words[0];
            v171.__r_.__value_.__r.__words[0] = v114->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v171.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v114->__r_.__value_.__r.__words[1] + 7);
            v116 = HIBYTE(v114->__r_.__value_.__r.__words[2]);
            v114->__r_.__value_.__l.__size_ = 0;
            v114->__r_.__value_.__r.__words[2] = 0;
            v114->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v168[2]) < 0)
              operator delete(v168[0]);
            v168[0] = v115;
            v168[1] = v171.__r_.__value_.__l.__data_;
            *(void **)((char *)&v168[1] + 7) = *(void **)((char *)v171.__r_.__value_.__r.__words + 7);
            HIBYTE(v168[2]) = v116;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              operator delete(buf.__r_.__value_.__l.__data_);
            v117 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
            {
              v118 = v168;
              if (SHIBYTE(v168[2]) < 0)
                v118 = (void **)v168[0];
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v118;
              v119 = "#I Live filtering is disabled; primaryScratchPath is %s";
              goto LABEL_198;
            }
            goto LABEL_229;
          }
        }
        memmove(p_buf, v48, v50);
        goto LABEL_178;
      case 1:
        v90 = abm::trace::kScratchFolder[0];
        v91 = strlen(abm::trace::kScratchFolder[0]);
        if (v91 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v92 = v91;
        if (v91 >= 0x17)
        {
          v120 = (v91 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v91 | 7) != 0x17)
            v120 = v91 | 7;
          v121 = v120 + 1;
          v93 = (std::string *)operator new(v120 + 1);
          buf.__r_.__value_.__l.__size_ = v92;
          buf.__r_.__value_.__r.__words[2] = v121 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v93;
        }
        else
        {
          *((_BYTE *)&buf.__r_.__value_.__s + 23) = v91;
          v93 = &buf;
          if (!v91)
          {
LABEL_190:
            v93->__r_.__value_.__s.__data_[v92] = 0;
            v122 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
            v123 = (void *)v122->__r_.__value_.__r.__words[0];
            v171.__r_.__value_.__r.__words[0] = v122->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v171.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v122->__r_.__value_.__r.__words[1] + 7);
            v124 = HIBYTE(v122->__r_.__value_.__r.__words[2]);
            v122->__r_.__value_.__l.__size_ = 0;
            v122->__r_.__value_.__r.__words[2] = 0;
            v122->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v168[2]) < 0)
              operator delete(v168[0]);
            v168[0] = v123;
            v168[1] = v171.__r_.__value_.__l.__data_;
            *(void **)((char *)&v168[1] + 7) = *(void **)((char *)v171.__r_.__value_.__r.__words + 7);
            HIBYTE(v168[2]) = v124;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              operator delete(buf.__r_.__value_.__l.__data_);
            v117 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
            {
              v125 = v168;
              if (SHIBYTE(v168[2]) < 0)
                v125 = (void **)v168[0];
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v125;
              v119 = "#I Live filtering is enabled; primaryScratchPath is %s";
LABEL_198:
              v126 = v117;
              v127 = 12;
              goto LABEL_228;
            }
            goto LABEL_229;
          }
        }
        memmove(v93, v90, v92);
        goto LABEL_190;
      case 2:
        v82 = abm::trace::kScratchFolder[0];
        v83 = strlen(abm::trace::kScratchFolder[0]);
        if (v83 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v84 = v83;
        if (v83 >= 0x17)
        {
          v94 = (v83 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v83 | 7) != 0x17)
            v94 = v83 | 7;
          v95 = v94 + 1;
          v85 = (std::string *)operator new(v94 + 1);
          buf.__r_.__value_.__l.__size_ = v84;
          buf.__r_.__value_.__r.__words[2] = v95 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v85;
        }
        else
        {
          *((_BYTE *)&buf.__r_.__value_.__s + 23) = v83;
          v85 = &buf;
          if (!v83)
          {
LABEL_154:
            v85->__r_.__value_.__s.__data_[v84] = 0;
            v96 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
            v97 = (void *)v96->__r_.__value_.__r.__words[0];
            v171.__r_.__value_.__r.__words[0] = v96->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v171.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v96->__r_.__value_.__r.__words[1] + 7);
            v98 = HIBYTE(v96->__r_.__value_.__r.__words[2]);
            v96->__r_.__value_.__l.__size_ = 0;
            v96->__r_.__value_.__r.__words[2] = 0;
            v96->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v168[2]) < 0)
              operator delete(v168[0]);
            v168[0] = v97;
            v168[1] = v171.__r_.__value_.__l.__data_;
            *(void **)((char *)&v168[1] + 7) = *(void **)((char *)v171.__r_.__value_.__r.__words + 7);
            HIBYTE(v168[2]) = v98;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              operator delete(buf.__r_.__value_.__l.__data_);
            v99 = abm::trace::kScratchFolder[0];
            v100 = strlen(abm::trace::kScratchFolder[0]);
            if (v100 > 0x7FFFFFFFFFFFFFF7)
              std::string::__throw_length_error[abi:ne180100]();
            v101 = v100;
            if (v100 >= 0x17)
            {
              v128 = (v100 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v100 | 7) != 0x17)
                v128 = v100 | 7;
              v129 = v128 + 1;
              v102 = (std::string *)operator new(v128 + 1);
              buf.__r_.__value_.__l.__size_ = v101;
              buf.__r_.__value_.__r.__words[2] = v129 | 0x8000000000000000;
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v102;
            }
            else
            {
              *((_BYTE *)&buf.__r_.__value_.__s + 23) = v100;
              v102 = &buf;
              if (!v100)
              {
LABEL_203:
                v102->__r_.__value_.__s.__data_[v101] = 0;
                v130 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
                v131 = (const __CFString *)v130->__r_.__value_.__r.__words[0];
                v171.__r_.__value_.__r.__words[0] = v130->__r_.__value_.__l.__size_;
                *(std::string::size_type *)((char *)v171.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v130->__r_.__value_.__r.__words[1] + 7);
                v132 = HIBYTE(v130->__r_.__value_.__r.__words[2]);
                v130->__r_.__value_.__l.__size_ = 0;
                v130->__r_.__value_.__r.__words[2] = 0;
                v130->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(key[2]) < 0)
                  operator delete((void *)key[0]);
                key[0] = v131;
                key[1] = (CFStringRef)v171.__r_.__value_.__l.__data_;
                *(CFStringRef *)((char *)&key[1] + 7) = *(CFStringRef *)((char *)v171.__r_.__value_.__r.__words + 7);
                HIBYTE(key[2]) = v132;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(buf.__r_.__value_.__l.__data_);
                v133 = *((_QWORD *)this + 5);
                if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
                {
                  v134 = v168;
                  if (SHIBYTE(v168[2]) < 0)
                    v134 = (void **)v168[0];
                  v135 = key;
                  if (SHIBYTE(key[2]) < 0)
                    v135 = (CFStringRef *)key[0];
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v134;
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v135;
                  v119 = "#I Hybrid trace collection is active; primaryScratchPath is %s, secondaryScratchPath is %s";
                  goto LABEL_227;
                }
                goto LABEL_229;
              }
            }
            memmove(v102, v99, v101);
            goto LABEL_203;
          }
        }
        memmove(v85, v82, v84);
        goto LABEL_154;
      case 3:
        v86 = abm::trace::kScratchFolder[0];
        v87 = strlen(abm::trace::kScratchFolder[0]);
        if (v87 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v88 = v87;
        if (v87 >= 0x17)
        {
          v103 = (v87 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v87 | 7) != 0x17)
            v103 = v87 | 7;
          v104 = v103 + 1;
          v89 = (std::string *)operator new(v103 + 1);
          buf.__r_.__value_.__l.__size_ = v88;
          buf.__r_.__value_.__r.__words[2] = v104 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v89;
        }
        else
        {
          *((_BYTE *)&buf.__r_.__value_.__s + 23) = v87;
          v89 = &buf;
          if (!v87)
          {
LABEL_166:
            v89->__r_.__value_.__s.__data_[v88] = 0;
            v105 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
            v106 = (void *)v105->__r_.__value_.__r.__words[0];
            v171.__r_.__value_.__r.__words[0] = v105->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v171.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v105->__r_.__value_.__r.__words[1] + 7);
            v107 = HIBYTE(v105->__r_.__value_.__r.__words[2]);
            v105->__r_.__value_.__l.__size_ = 0;
            v105->__r_.__value_.__r.__words[2] = 0;
            v105->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v168[2]) < 0)
              operator delete(v168[0]);
            v168[0] = v106;
            v168[1] = v171.__r_.__value_.__l.__data_;
            *(void **)((char *)&v168[1] + 7) = *(void **)((char *)v171.__r_.__value_.__r.__words + 7);
            HIBYTE(v168[2]) = v107;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              operator delete(buf.__r_.__value_.__l.__data_);
            v108 = abm::trace::kScratchFolder[0];
            v109 = strlen(abm::trace::kScratchFolder[0]);
            if (v109 > 0x7FFFFFFFFFFFFFF7)
              std::string::__throw_length_error[abi:ne180100]();
            v110 = v109;
            if (v109 >= 0x17)
            {
              v136 = (v109 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v109 | 7) != 0x17)
                v136 = v109 | 7;
              v137 = v136 + 1;
              v111 = (std::string *)operator new(v136 + 1);
              buf.__r_.__value_.__l.__size_ = v110;
              buf.__r_.__value_.__r.__words[2] = v137 | 0x8000000000000000;
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v111;
            }
            else
            {
              *((_BYTE *)&buf.__r_.__value_.__s + 23) = v109;
              v111 = &buf;
              if (!v109)
              {
LABEL_217:
                v111->__r_.__value_.__s.__data_[v110] = 0;
                v138 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
                v139 = (const __CFString *)v138->__r_.__value_.__r.__words[0];
                v171.__r_.__value_.__r.__words[0] = v138->__r_.__value_.__l.__size_;
                *(std::string::size_type *)((char *)v171.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v138->__r_.__value_.__r.__words[1] + 7);
                v140 = HIBYTE(v138->__r_.__value_.__r.__words[2]);
                v138->__r_.__value_.__l.__size_ = 0;
                v138->__r_.__value_.__r.__words[2] = 0;
                v138->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(key[2]) < 0)
                  operator delete((void *)key[0]);
                key[0] = v139;
                key[1] = (CFStringRef)v171.__r_.__value_.__l.__data_;
                *(CFStringRef *)((char *)&key[1] + 7) = *(CFStringRef *)((char *)v171.__r_.__value_.__r.__words + 7);
                HIBYTE(key[2]) = v140;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(buf.__r_.__value_.__l.__data_);
                v133 = *((_QWORD *)this + 5);
                if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
                {
                  v141 = v168;
                  if (SHIBYTE(v168[2]) < 0)
                    v141 = (void **)v168[0];
                  v142 = key;
                  if (SHIBYTE(key[2]) < 0)
                    v142 = (CFStringRef *)key[0];
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v141;
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v142;
                  v119 = "#I Streaming Mode is enabled; primaryScratchPath is %s,  secondaryScratchPath is %s";
LABEL_227:
                  v126 = v133;
                  v127 = 22;
LABEL_228:
                  _os_log_impl(&dword_1A343C000, v126, OS_LOG_TYPE_DEFAULT, v119, (uint8_t *)&buf, v127);
                }
LABEL_229:
                HIBYTE(v166[2]) = 18;
                strcpy((char *)v166, "MaxMemoryFileCount");
                memset(&v169, 0, sizeof(v169));
                HIBYTE(__p[2]) = 7;
                strcpy((char *)__p, "BBTrace");
                memset(&buf, 0, sizeof(buf));
                v143 = defaults::get((char *)__p, (char *)v166, &buf);
                if (v143)
                {
                  prop::file::get<std::string>((const void **)__p, (uint64_t)v166, (uint64_t)&buf, &v171);
                  if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v169.__r_.__value_.__l.__data_);
                  v169 = v171;
                }
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(buf.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                  {
LABEL_235:
                    if (!v143)
                    {
LABEL_240:
                      if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v169.__r_.__value_.__l.__data_);
                      if (SHIBYTE(v166[2]) < 0)
                        operator delete(v166[0]);
                      buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAA0000;
                      *(_QWORD *)&v181 = 0;
                      *((_QWORD *)&v181 + 1) = 0xAAAAAAAA00100000;
                      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0u;
                      v178 = 0u;
                      v179 = 0u;
                      memset(v180, 0, sizeof(v180));
                      if (SHIBYTE(v168[2]) < 0)
                      {
                        std::string::__assign_no_alias<true>(&v180[3], v168[0], (size_t)v168[1]);
                        if (SHIBYTE(v180[2]) < 0)
                        {
                          v180[1] = (void *)4;
                          v144 = (char *)v180[0];
LABEL_248:
                          strcpy(v144, ".acp");
                          LODWORD(v181) = *((_DWORD *)this + 41);
                          *(int32x2_t *)((char *)&v181 + 4) = vrev64_s32(*(int32x2_t *)((char *)this + 172));
                          v171.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAA0000;
                          v175 = 0xAAAAAAAAAAAAAAAALL;
                          *(_OWORD *)&v171.__r_.__value_.__r.__words[1] = 0u;
                          v172 = 0u;
                          *(_OWORD *)v173 = 0u;
                          memset(v174, 0, sizeof(v174));
                          v176 = 0xAAAAAAAA00100000;
                          if (SHIBYTE(key[2]) < 0)
                          {
                            std::string::__assign_no_alias<true>(&v174[3], (void *)key[0], (size_t)key[1]);
                            if (SHIBYTE(v174[2]) < 0)
                            {
                              v174[1] = (void *)4;
                              v145 = (char *)v174[0];
                              goto LABEL_252;
                            }
                          }
                          else
                          {
                            *(_OWORD *)&v174[3] = *(_OWORD *)key;
                            *(CFStringRef *)&v175 = key[2];
                          }
                          v145 = (char *)v174;
                          HIBYTE(v174[2]) = 4;
LABEL_252:
                          strcpy(v145, ".acp");
                          v146 = *((_DWORD *)this + 43);
                          v147 = *((_DWORD *)this + 44) >> 2;
                          DWORD2(v175) = *((_DWORD *)this + 41) / 16;
                          HIDWORD(v175) = v147;
                          LODWORD(v176) = v146;
                          if ((v148 & 1) == 0
                          {
                            __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
                          }
                          __p[0] = (void *)MEMORY[0x1E0C809B0];
                          __p[1] = (void *)0x40000000;
                          __p[2] = ___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
                          __p[3] = &__block_descriptor_tmp_13_6;
                          __p[4] = &GetABMLogServer(void)::sLogServer;
                          if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
                          {
                            v149 = *((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
                            v165 = GetABMLogServer(void)::sLogServer;
                            if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
                              goto LABEL_257;
                          }
                          else
                          {
                            dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, __p);
                            v149 = *((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
                            v165 = GetABMLogServer(void)::sLogServer;
                            if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
                              goto LABEL_257;
                          }
                          v150 = (unint64_t *)(v149 + 8);
                          do
                            v151 = __ldxr(v150);
                          while (__stxr(v151 + 1, v150));
LABEL_257:
                          (*(void (**)(INTTrace *))(*(_QWORD *)this + 160))(this);
                          abm::trace::TraceReader::create();
                          v152 = *(_OWORD *)&v169.__r_.__value_.__l.__data_;
                          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = 0uLL;
                          v153 = (std::__shared_weak_count *)*((_QWORD *)this + 31);
                          *((_OWORD *)this + 15) = v152;
                          if (v153)
                          {
                            p_shared_owners = (unint64_t *)&v153->__shared_owners_;
                            do
                              v155 = __ldaxr(p_shared_owners);
                            while (__stlxr(v155 - 1, p_shared_owners));
                            if (!v155)
                            {
                              ((void (*)(std::__shared_weak_count *))v153->__on_zero_shared)(v153);
                              std::__shared_weak_count::__release_weak(v153);
                            }
                          }
                          size = (std::__shared_weak_count *)v169.__r_.__value_.__l.__size_;
                          if (v169.__r_.__value_.__l.__size_)
                          {
                            v157 = (unint64_t *)(v169.__r_.__value_.__l.__size_ + 8);
                            do
                              v158 = __ldaxr(v157);
                            while (__stlxr(v158 - 1, v157));
                            if (!v158)
                            {
                              ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
                              std::__shared_weak_count::__release_weak(size);
                            }
                          }
                          if (*((_QWORD *)&v165 + 1))
                          {
                            v159 = (unint64_t *)(*((_QWORD *)&v165 + 1) + 8);
                            do
                              v160 = __ldaxr(v159);
                            while (__stlxr(v160 - 1, v159));
                            if (!v160)
                            {
                              (*(void (**)(_QWORD))(**((_QWORD **)&v165 + 1) + 16))(*((_QWORD *)&v165 + 1));
                              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v165 + 1));
                            }
                          }
                          v161 = *((_QWORD *)this + 5);
                          if (*((_QWORD *)this + 30))
                          {
                            if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
                            {
                              LOWORD(__p[0]) = 0;
                              _os_log_debug_impl(&dword_1A343C000, v161, OS_LOG_TYPE_DEBUG, "#D Created file reader!", (uint8_t *)__p, 2u);
                              if (SBYTE7(v175) < 0)
                                goto LABEL_275;
LABEL_280:
                              if (SHIBYTE(v174[2]) < 0)
                              {
LABEL_276:
                                operator delete(v174[0]);
                                v162 = (void *)*((_QWORD *)&v172 + 1);
                                if (!*((_QWORD *)&v172 + 1))
                                {
LABEL_283:
                                  if (SBYTE7(v172) < 0)
                                  {
                                    operator delete((void *)v171.__r_.__value_.__l.__size_);
                                    if ((SHIBYTE(v180[5]) & 0x80000000) == 0)
                                    {
LABEL_285:
                                      if ((SHIBYTE(v180[2]) & 0x80000000) == 0)
                                        goto LABEL_286;
                                      goto LABEL_294;
                                    }
                                  }
                                  else if ((SHIBYTE(v180[5]) & 0x80000000) == 0)
                                  {
                                    goto LABEL_285;
                                  }
                                  operator delete(v180[3]);
                                  if ((SHIBYTE(v180[2]) & 0x80000000) == 0)
                                  {
LABEL_286:
                                    v163 = (void *)*((_QWORD *)&v178 + 1);
                                    if (!*((_QWORD *)&v178 + 1))
                                      goto LABEL_288;
                                    goto LABEL_287;
                                  }
LABEL_294:
                                  operator delete(v180[0]);
                                  v163 = (void *)*((_QWORD *)&v178 + 1);
                                  if (!*((_QWORD *)&v178 + 1))
                                  {
LABEL_288:
                                    if (SBYTE7(v178) < 0)
                                    {
                                      operator delete((void *)buf.__r_.__value_.__l.__size_);
                                      if ((SHIBYTE(key[2]) & 0x80000000) == 0)
                                      {
LABEL_290:
                                        if ((SHIBYTE(v168[2]) & 0x80000000) == 0)
                                          goto LABEL_10;
LABEL_298:
                                        operator delete(v168[0]);
                                        goto LABEL_10;
                                      }
                                    }
                                    else if ((SHIBYTE(key[2]) & 0x80000000) == 0)
                                    {
                                      goto LABEL_290;
                                    }
                                    operator delete((void *)key[0]);
                                    if ((SHIBYTE(v168[2]) & 0x80000000) == 0)
                                      goto LABEL_10;
                                    goto LABEL_298;
                                  }
LABEL_287:
                                  *(_QWORD *)&v179 = v163;
                                  operator delete(v163);
                                  goto LABEL_288;
                                }
LABEL_282:
                                v173[0] = v162;
                                operator delete(v162);
                                goto LABEL_283;
                              }
LABEL_281:
                              v162 = (void *)*((_QWORD *)&v172 + 1);
                              if (!*((_QWORD *)&v172 + 1))
                                goto LABEL_283;
                              goto LABEL_282;
                            }
                          }
                          else if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(__p[0]) = 0;
                            _os_log_error_impl(&dword_1A343C000, v161, OS_LOG_TYPE_ERROR, "Failed to create file reader", (uint8_t *)__p, 2u);
                            if ((SBYTE7(v175) & 0x80000000) == 0)
                              goto LABEL_280;
LABEL_275:
                            operator delete(v174[3]);
                            if (SHIBYTE(v174[2]) < 0)
                              goto LABEL_276;
                            goto LABEL_281;
                          }
                          if ((SBYTE7(v175) & 0x80000000) == 0)
                            goto LABEL_280;
                          goto LABEL_275;
                        }
                      }
                      else
                      {
                        *(_OWORD *)&v180[3] = *(_OWORD *)v168;
                        v180[5] = v168[2];
                      }
                      v144 = (char *)v180;
                      HIBYTE(v180[2]) = 4;
                      goto LABEL_248;
                    }
LABEL_239:
                    util::convert<unsigned int>(&v169, (_DWORD *)this + 44, 0);
                    goto LABEL_240;
                  }
                }
                else if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                {
                  goto LABEL_235;
                }
                operator delete(__p[0]);
                if (!v143)
                  goto LABEL_240;
                goto LABEL_239;
              }
            }
            memmove(v111, v108, v110);
            goto LABEL_217;
          }
        }
        memmove(v89, v86, v88);
        goto LABEL_166;
      default:
        goto LABEL_229;
    }
  }
  v5 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_debug_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEBUG, "#D Skipped creating new file reader instance", (uint8_t *)&buf, 2u);
  }
LABEL_10:
  v6 = *((_DWORD *)this + 38);
  if (v6 != 2)
  {
    if (!v6)
    {
      memset(&v171, 170, sizeof(v171));
      v7 = abm::trace::kScratchFolder[0];
      v8 = strlen(abm::trace::kScratchFolder[0]);
      if (v8 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      v9 = v8;
      if (v8 >= 0x17)
      {
        v18 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v8 | 7) != 0x17)
          v18 = v8 | 7;
        v19 = v18 + 1;
        v10 = (std::string *)operator new(v18 + 1);
        buf.__r_.__value_.__l.__size_ = v9;
        buf.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
      }
      else
      {
        *((_BYTE *)&buf.__r_.__value_.__s + 23) = v8;
        v10 = &buf;
        if (!v8)
        {
LABEL_26:
          v10->__r_.__value_.__s.__data_[v9] = 0;
          v20 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
          v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
          v171.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v21;
          v20->__r_.__value_.__l.__size_ = 0;
          v20->__r_.__value_.__r.__words[2] = 0;
          v20->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            operator delete(buf.__r_.__value_.__l.__data_);
          memset(__p, 170, 24);
          v22 = abm::trace::kScratchFolder[0];
          v23 = strlen(abm::trace::kScratchFolder[0]);
          if (v23 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          v24 = v23;
          if (v23 >= 0x17)
          {
            v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v23 | 7) != 0x17)
              v26 = v23 | 7;
            v27 = v26 + 1;
            v25 = (std::string *)operator new(v26 + 1);
            buf.__r_.__value_.__l.__size_ = v24;
            buf.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
          }
          else
          {
            *((_BYTE *)&buf.__r_.__value_.__s + 23) = v23;
            v25 = &buf;
            if (!v23)
            {
LABEL_38:
              v25->__r_.__value_.__s.__data_[v24] = 0;
              v28 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
              v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
              __p[2] = (void *)v28->__r_.__value_.__r.__words[2];
              *(_OWORD *)__p = v29;
              v28->__r_.__value_.__l.__size_ = 0;
              v28->__r_.__value_.__r.__words[2] = 0;
              v28->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                operator delete(buf.__r_.__value_.__l.__data_);
              LOBYTE(key[0]) = 0;
              pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
              v30 = off_1ED114620;
              if (!off_1ED114620)
              {
                v31 = operator new(0x30uLL);
                MEMORY[0x1A858F2E4](v31, CFSTR("com.apple.AppleBasebandManager.data"), *MEMORY[0x1E0C9B260]);
                v31[3] = 0;
                v31[4] = 0;
                *((_DWORD *)v31 + 10) = 0;
                std::shared_ptr<SharedData>::shared_ptr[abi:ne180100]<SharedData,void>(&buf, (uint64_t)v31);
                v32 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
                v33 = (std::__shared_weak_count *)*(&off_1ED114620 + 1);
                off_1ED114620 = v32;
                if (v33)
                {
                  v34 = (unint64_t *)&v33->__shared_owners_;
                  do
                    v35 = __ldaxr(v34);
                  while (__stlxr(v35 - 1, v34));
                  if (!v35)
                  {
                    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
                    std::__shared_weak_count::__release_weak(v33);
                  }
                }
                v36 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
                if (buf.__r_.__value_.__l.__size_)
                {
                  v37 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
                  do
                    v38 = __ldaxr(v37);
                  while (__stlxr(v38 - 1, v37));
                  if (!v38)
                  {
                    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                    std::__shared_weak_count::__release_weak(v36);
                  }
                }
                v30 = off_1ED114620;
              }
              v169.__r_.__value_.__r.__words[0] = v30;
              v169.__r_.__value_.__l.__size_ = *(&off_1ED114620 + 1);
              if (*(&off_1ED114620 + 1))
              {
                v39 = (unint64_t *)(*(&off_1ED114620 + 1) + 8);
                do
                  v40 = __ldxr(v39);
                while (__stxr(v40 + 1, v39));
              }
              pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x38uLL);
              *(_WORD *)&v164[50] = 0;
              *(_DWORD *)&v164[52] = 0;
              *(_QWORD *)&v164[56] = 0x8000000000000038;
              *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = xmmword_1A3581A80;
              strcpy(buf.__r_.__value_.__l.__data_, "Firmware version changed since last commcenter launch");
              strcpy(v164, "ast commcenter l changed since lFirmware version5");
              v41 = (os_unfair_lock_s *)(v30 + 40);
              os_unfair_lock_lock((os_unfair_lock_t)(v30 + 40));
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v42 = &buf;
              else
                v42 = (std::string *)buf.__r_.__value_.__r.__words[0];
              ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v168, (const char *)v42);
              v43 = (BOOL *)(**(uint64_t (***)(std::string::size_type, void *))v30)(v30, v168[0]);
              v44 = v43;
              if (v43)
              {
                v45 = CFGetTypeID(v43);
                if (v45 == CFBooleanGetTypeID())
                  ctu::cf::assign((ctu::cf *)key, v44, v46);
                CFRelease(v44);
              }
              MEMORY[0x1A858F29C](v168);
              os_unfair_lock_unlock(v41);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(buf.__r_.__value_.__l.__data_);
                v47 = (std::__shared_weak_count *)v169.__r_.__value_.__l.__size_;
                if (!v169.__r_.__value_.__l.__size_)
                  goto LABEL_74;
              }
              else
              {
                v47 = (std::__shared_weak_count *)v169.__r_.__value_.__l.__size_;
                if (!v169.__r_.__value_.__l.__size_)
                  goto LABEL_74;
              }
              v52 = (unint64_t *)&v47->__shared_owners_;
              do
                v53 = __ldaxr(v52);
              while (__stlxr(v53 - 1, v52));
              if (!v53)
              {
                ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                std::__shared_weak_count::__release_weak(v47);
                if (LOBYTE(key[0]))
                  goto LABEL_75;
                goto LABEL_115;
              }
LABEL_74:
              if (LOBYTE(key[0]))
              {
LABEL_75:
                v54 = *((_QWORD *)this + 5);
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                {
                  v55 = &v171;
                  if ((v171.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    v55 = (std::string *)v171.__r_.__value_.__r.__words[0];
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v55;
                  _os_log_impl(&dword_1A343C000, v54, OS_LOG_TYPE_DEFAULT, "#I Removing scratch folder %s because firmware version change detected", (uint8_t *)&buf, 0xCu);
                }
                if ((*((_DWORD *)this + 42) & 0xFFFFFFFE) == 2)
                {
                  v56 = *((_QWORD *)this + 5);
                  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
                  {
                    v57 = __p;
                    if (SHIBYTE(__p[2]) < 0)
                      v57 = (void **)__p[0];
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v57;
                    _os_log_impl(&dword_1A343C000, v56, OS_LOG_TYPE_DEFAULT, "#I Removing filtered scratch folder %s because firmware version change detected", (uint8_t *)&buf, 0xCu);
                  }
                }
                abm::trace::TraceReader::clearFiles(*((abm::trace::TraceReader **)this + 30));
                pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
                v58 = off_1ED114620;
                if (!off_1ED114620)
                {
                  v59 = operator new(0x30uLL);
                  MEMORY[0x1A858F2E4](v59, CFSTR("com.apple.AppleBasebandManager.data"), *MEMORY[0x1E0C9B260]);
                  v59[3] = 0;
                  v59[4] = 0;
                  *((_DWORD *)v59 + 10) = 0;
                  std::shared_ptr<SharedData>::shared_ptr[abi:ne180100]<SharedData,void>(&buf, (uint64_t)v59);
                  v60 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                  *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
                  v61 = (std::__shared_weak_count *)*(&off_1ED114620 + 1);
                  off_1ED114620 = v60;
                  if (v61)
                  {
                    v62 = (unint64_t *)&v61->__shared_owners_;
                    do
                      v63 = __ldaxr(v62);
                    while (__stlxr(v63 - 1, v62));
                    if (!v63)
                    {
                      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                      std::__shared_weak_count::__release_weak(v61);
                    }
                  }
                  v64 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
                  if (buf.__r_.__value_.__l.__size_)
                  {
                    v65 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
                    do
                      v66 = __ldaxr(v65);
                    while (__stlxr(v66 - 1, v65));
                    if (!v66)
                    {
                      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
                      std::__shared_weak_count::__release_weak(v64);
                    }
                  }
                  v58 = off_1ED114620;
                }
                v169.__r_.__value_.__r.__words[0] = v58;
                v169.__r_.__value_.__l.__size_ = *(&off_1ED114620 + 1);
                if (*(&off_1ED114620 + 1))
                {
                  v67 = (unint64_t *)(*(&off_1ED114620 + 1) + 8);
                  do
                    v68 = __ldxr(v67);
                  while (__stxr(v68 + 1, v67));
                }
                pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
                v69 = operator new(0x38uLL);
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v69;
                *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = *(_OWORD *)&v164[48];
                *(_OWORD *)v69 = *(_OWORD *)&v164[32];
                *((_OWORD *)v69 + 1) = *(_OWORD *)&v164[16];
                *((_OWORD *)v69 + 2) = *(_OWORD *)v164;
                strcpy((char *)v69 + 45, "r launch");
                os_unfair_lock_lock((os_unfair_lock_t)(v58 + 40));
                if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v70 = &buf;
                else
                  v70 = (std::string *)buf.__r_.__value_.__r.__words[0];
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, (const char *)v70);
                v71 = (void *)*MEMORY[0x1E0C9AE40];
                v168[0] = v71;
                if (v71)
                {
                  v72 = (const __CFString *)*MEMORY[0x1E0C9B250];
                  CFPreferencesSetValue(key[0], v71, *(CFStringRef *)(v58 + 8), *(CFStringRef *)(v58 + 16), (CFStringRef)*MEMORY[0x1E0C9B250]);
                  CFPreferencesSynchronize(*(CFStringRef *)(v58 + 8), *(CFStringRef *)(v58 + 16), v72);
                  CFRelease(v71);
                }
                MEMORY[0x1A858F29C](key);
                os_unfair_lock_unlock((os_unfair_lock_t)(v58 + 40));
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(buf.__r_.__value_.__l.__data_);
                v73 = (std::__shared_weak_count *)v169.__r_.__value_.__l.__size_;
                if (v169.__r_.__value_.__l.__size_)
                {
                  v74 = (unint64_t *)(v169.__r_.__value_.__l.__size_ + 8);
                  do
                    v75 = __ldaxr(v74);
                  while (__stlxr(v75 - 1, v74));
                  if (!v75)
                  {
                    ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
                    std::__shared_weak_count::__release_weak(v73);
                  }
                }
                goto LABEL_126;
              }
LABEL_115:
              if (!*((_BYTE *)this + 384))
              {
                v76 = *((_QWORD *)this + 5);
                if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                {
                  v77 = &v171;
                  if ((v171.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    v77 = (std::string *)v171.__r_.__value_.__r.__words[0];
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v77;
                  _os_log_impl(&dword_1A343C000, v76, OS_LOG_TYPE_DEFAULT, "#I Removing scratch folder %s because retain previous trace property is set to false", (uint8_t *)&buf, 0xCu);
                }
                if ((*((_DWORD *)this + 42) & 0xFFFFFFFE) == 2)
                {
                  v78 = *((_QWORD *)this + 5);
                  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                  {
                    v79 = __p;
                    if (SHIBYTE(__p[2]) < 0)
                      v79 = (void **)__p[0];
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v79;
                    _os_log_impl(&dword_1A343C000, v78, OS_LOG_TYPE_DEFAULT, "#I Removing filtered scratch folder %s because retain previous trace property is set to false", (uint8_t *)&buf, 0xCu);
                  }
                }
                abm::trace::TraceReader::clearFiles(*((abm::trace::TraceReader **)this + 30));
              }
LABEL_126:
              started = INTTrace::startReader_sync(this);
              v81 = *((_QWORD *)this + 5);
              if ((started & 1) != 0)
              {
                if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl(&dword_1A343C000, v81, OS_LOG_TYPE_DEFAULT, "#I Succeeded opening trace transport", (uint8_t *)&buf, 2u);
                  if (SHIBYTE(__p[2]) < 0)
                    goto LABEL_129;
LABEL_134:
                  if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_130:
                    operator delete(v171.__r_.__value_.__l.__data_);
                    if ((started & 1) == 0)
                      return;
                    goto LABEL_136;
                  }
LABEL_135:
                  if ((started & 1) == 0)
                    return;
                  goto LABEL_136;
                }
              }
              else if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl(&dword_1A343C000, v81, OS_LOG_TYPE_ERROR, "Failed to open TRACE transport during prepare stage; ignore this failure and proceed",
                  (uint8_t *)&buf,
                  2u);
                if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                  goto LABEL_134;
LABEL_129:
                operator delete(__p[0]);
                if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
                  goto LABEL_130;
                goto LABEL_135;
              }
              if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                goto LABEL_134;
              goto LABEL_129;
            }
          }
          memmove(v25, v22, v24);
          goto LABEL_38;
        }
      }
      memmove(v10, v7, v9);
      goto LABEL_26;
    }
    v16 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      if (v6 > 6)
        v17 = "Unknown";
      else
        v17 = off_1E4A0AF90[v6];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      v13 = "#I trace mode (%s)";
      v14 = v16;
      v15 = 12;
      goto LABEL_113;
    }
    goto LABEL_136;
  }
  v11 = INTTrace::startTraceWithUSBBridgeInterface(this);
  v12 = *((_QWORD *)this + 5);
  if ((v11 & 1) != 0)
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v13 = "#I Succeeded in starting trace via usb bridge";
      v14 = v12;
      v15 = 2;
LABEL_113:
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&buf, v15);
    }
LABEL_136:
    *((_BYTE *)this + 284) = 1;
    return;
  }
  if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, "Failed to start trace via usb bridge", (uint8_t *)&buf, 2u);
  }
}

void sub_1A34DABBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  uint64_t v59;

  if (*(char *)(v59 - 201) < 0)
    operator delete(*(void **)(v59 - 224));
  if (a31 < 0)
    operator delete(__p);
  if (a37 < 0)
  {
    operator delete(a32);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100](uint64_t result, __int128 *a2)
{
  uint64_t v2;
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v2 = result;
  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(result + 8);
  *(_OWORD *)result = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      return v2;
    }
  }
  return result;
}

uint64_t INTTrace::startReader_sync(INTTrace *this)
{
  NSObject *v2;
  const char *v3;
  std::__shared_weak_count *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  capabilities::abs *shouldUseMinBasebandTransportIOReadSize;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  std::__shared_weak_count *v18;
  NSObject *v19;
  uint8_t v20[16];
  void *v21;
  _QWORD aBlock[6];
  std::__shared_weak_count *v23;
  uint8_t buf[16];
  __int128 v25;
  unint64_t v26;

  if (*((_DWORD *)this + 38))
  {
    v2 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      return 1;
    *(_WORD *)buf = 0;
    v3 = "#I Trace Mode is not set to AP. Skip starting trace reader";
LABEL_4:
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, v3, buf, 2u);
    return 1;
  }
  if (!*((_BYTE *)this + 156))
  {
    v2 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      return 1;
    *(_WORD *)buf = 0;
    v3 = "#I Trace is not enabled. Skip starting trace reader";
    goto LABEL_4;
  }
  if (*((_QWORD *)this + 30))
  {
    v5 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
    if (!v5 || (v6 = *((_QWORD *)this + 9), (v7 = std::__shared_weak_count::lock(v5)) == 0))
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v8 = v7;
    p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v8);
    }
    *(_DWORD *)&buf[4] = -1431655936;
    v25 = 0xAAAAAAAAAAAAAAAALL;
    *(_DWORD *)buf = 17;
    v26 = 0xAAAAAAAAAAAAAA00;
    *(_QWORD *)&buf[8] = 10;
    shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v7);
    capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize);
    *(_QWORD *)&v25 = *(_QWORD *)((char *)this + 276);
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN8INTTrace16startReader_syncEv_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_14;
    aBlock[4] = this;
    aBlock[5] = v6;
    v23 = v8;
    do
      v14 = __ldxr(p_shared_weak_owners);
    while (__stxr(v14 + 1, p_shared_weak_owners));
    v21 = _Block_copy(aBlock);
    v15 = abm::trace::TraceReader::start();
    if (v21)
      _Block_release(v21);
    if ((_DWORD)v15
      && !*((_BYTE *)this + 272)
      && (v16 = *((_QWORD *)this + 18)) != 0
      && (dispatch_group_enter(v16),
          *((_BYTE *)this + 272) = 1,
          v17 = *((_QWORD *)this + 5),
          os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)))
    {
      *(_WORD *)v20 = 0;
      _os_log_debug_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEBUG, "#D Holding task group", v20, 2u);
      v18 = v23;
      if (!v23)
        goto LABEL_26;
    }
    else
    {
      v18 = v23;
      if (!v23)
      {
LABEL_26:
        std::__shared_weak_count::__release_weak(v8);
        return v15;
      }
    }
    std::__shared_weak_count::__release_weak(v18);
    goto LABEL_26;
  }
  v19 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to start Trace reader. Object does not exist", buf, 2u);
  }
  return 0;
}

void sub_1A34DB14C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *aBlock, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  std::__shared_weak_count *v18;

  if (aBlock)
    _Block_release(aBlock);
  if (a18)
  {
    std::__shared_weak_count::__release_weak(a18);
    std::__shared_weak_count::__release_weak(v18);
    _Unwind_Resume(a1);
  }
  std::__shared_weak_count::__release_weak(v18);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::startTraceWithUSBBridgeInterface(INTTrace *this)
{
  uint64_t v2;
  SoftwareBypassShim **v3;
  SoftwareBypassShim *v4;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  _BYTE v22[18];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = *((int *)this + 38);
  if ((_DWORD)v2 != 2)
  {
    v15 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      if (v2 > 6)
        v16 = "Unknown";
      else
        v16 = off_1E4A0AF90[v2];
      *(_DWORD *)v22 = 136315138;
      *(_QWORD *)&v22[4] = v16;
      v18 = "Invalid trace mode (%s) to start trace via USB interface";
      v19 = v15;
      v20 = 12;
      goto LABEL_27;
    }
    return 0;
  }
  v3 = (SoftwareBypassShim **)((char *)this + 360);
  v4 = (SoftwareBypassShim *)*((_QWORD *)this + 45);
  if (!v4)
  {
    SoftwareBypassShim::create((std::__shared_weak_count **)v22);
    v5 = *(_OWORD *)v22;
    *(_OWORD *)v22 = 0uLL;
    v6 = (std::__shared_weak_count *)*((_QWORD *)this + 46);
    *(_OWORD *)v3 = v5;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    v9 = *(std::__shared_weak_count **)&v22[8];
    if (*(_QWORD *)&v22[8])
    {
      v10 = (unint64_t *)(*(_QWORD *)&v22[8] + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v4 = *v3;
    if (!*v3)
    {
      v17 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v22 = 0;
        v18 = "Failed to create bypass control object";
        goto LABEL_24;
      }
      return 0;
    }
  }
  if (!*((_QWORD *)v4 + 2))
  {
    v17 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v22 = 0;
      v18 = "expected to use software bypass, but it is not supported";
LABEL_24:
      v19 = v17;
      v20 = 2;
LABEL_27:
      _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, v18, v22, v20);
      return 0;
    }
    return 0;
  }
  v12 = SoftwareBypassShim::bypassCtl(v4, 41);
  v13 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = SoftwareBypassShim::bypassInterfaceMaskAsString(*v3, 41);
    *(_DWORD *)v22 = 136315394;
    *(_QWORD *)&v22[4] = v14;
    *(_WORD *)&v22[12] = 1024;
    *(_DWORD *)&v22[14] = v12;
    _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I bypassCtl( %s): success: %d", v22, 0x12u);
  }
  return v12;
}

void ___ZN8INTTrace16startReader_syncEv_block_invoke(_QWORD *a1, _DWORD *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  __int128 v9;
  const void *v10;
  size_t v11;
  size_t v12;
  __int128 *p_dst;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  size_t v18;
  size_t v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::string v26;
  void *v27;
  char v28;
  void *v29;
  char v30;
  void *v31;
  char v32;
  __int128 v33;
  char v34;
  _BYTE v35[8];
  _QWORD *v36;
  void *__p[2];
  char v38;
  _BYTE v39[24];
  __int128 v40;
  unint64_t v41;
  __int128 __dst;
  unint64_t v43;
  __int128 buf;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  std::__shared_weak_count *v52;

  v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    v5 = a1[4];
    v6 = std::__shared_weak_count::lock(v3);
    v52 = v6;
    if (v6)
    {
      v7 = v6;
      if (a1[5])
      {
        if (*a2 == 3)
        {
          v14 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#E No Logging Traffic detected (Stalled?)", (uint8_t *)&buf, 2u);
          }
        }
        else if (*a2 == 2)
        {
          v8 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#E TRACE transport error", (uint8_t *)&buf, 2u);
          }
          *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v49 = v9;
          v50 = v9;
          v47 = v9;
          v48 = v9;
          v45 = v9;
          v46 = v9;
          buf = v9;
          v10 = (const void *)*MEMORY[0x1E0CFB590];
          v11 = strlen((const char *)*MEMORY[0x1E0CFB590]);
          if (v11 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          v12 = v11;
          if (v11 >= 0x17)
          {
            v15 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v11 | 7) != 0x17)
              v15 = v11 | 7;
            v16 = v15 + 1;
            p_dst = (__int128 *)operator new(v15 + 1);
            *((_QWORD *)&__dst + 1) = v12;
            v43 = v16 | 0x8000000000000000;
            *(_QWORD *)&__dst = p_dst;
          }
          else
          {
            HIBYTE(v43) = v11;
            p_dst = &__dst;
            if (!v11)
            {
LABEL_18:
              *((_BYTE *)p_dst + v12) = 0;
              v17 = (const void *)*MEMORY[0x1E0CFC000];
              v18 = strlen((const char *)*MEMORY[0x1E0CFC000]);
              if (v18 > 0x7FFFFFFFFFFFFFF7)
                std::string::__throw_length_error[abi:ne180100]();
              v19 = v18;
              if (v18 >= 0x17)
              {
                v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v18 | 7) != 0x17)
                  v21 = v18 | 7;
                v22 = v21 + 1;
                v20 = operator new(v21 + 1);
                *((_QWORD *)&v40 + 1) = v19;
                v41 = v22 | 0x8000000000000000;
                *(_QWORD *)&v40 = v20;
              }
              else
              {
                HIBYTE(v41) = v18;
                v20 = &v40;
                if (!v18)
                {
LABEL_26:
                  v20[v19] = 0;
                  v39[23] = 21;
                  strcpy(v39, "TRACE transport error");
                  Timestamp::Timestamp((Timestamp *)v35);
                  Timestamp::asString((uint64_t)v35, 0, 9, __p);
                  v34 = 0;
                  LOBYTE(v33) = 0;
                  ResetInfo::ResetInfo((std::string *)&buf, &__dst, &v40, (__int128 *)v39, (uint64_t)__p, 7, &v33);
                  if (v38 < 0)
                  {
                    operator delete(__p[0]);
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v35, v36);
                    if ((SHIBYTE(v41) & 0x80000000) == 0)
                    {
LABEL_28:
                      if ((SHIBYTE(v43) & 0x80000000) == 0)
                        goto LABEL_29;
                      goto LABEL_33;
                    }
                  }
                  else
                  {
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v35, v36);
                    if ((SHIBYTE(v41) & 0x80000000) == 0)
                      goto LABEL_28;
                  }
                  operator delete((void *)v40);
                  if ((SHIBYTE(v43) & 0x80000000) == 0)
                  {
LABEL_29:
                    if (*(_DWORD *)(v5 + 380) != 2)
                    {
LABEL_40:
                      if ((SHIBYTE(v50) & 0x80000000) == 0)
                        goto LABEL_41;
                      goto LABEL_50;
                    }
LABEL_34:
                    v23 = *(NSObject **)(v5 + 40);
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(__dst) = 0;
                      _os_log_impl(&dword_1A343C000, v23, OS_LOG_TYPE_DEFAULT, "#I Triggering modem reset for Trace transport error", (uint8_t *)&__dst, 2u);
                    }
                    ResetInfo::ResetInfo(&v26, &buf);
                    INTTrace::commandResetModem_sync(v5, (__int128 *)&v26);
                    if (v32 < 0)
                    {
                      operator delete(v31);
                      if ((v30 & 0x80000000) == 0)
                      {
LABEL_38:
                        if ((v28 & 0x80000000) == 0)
                          goto LABEL_39;
                        goto LABEL_48;
                      }
                    }
                    else if ((v30 & 0x80000000) == 0)
                    {
                      goto LABEL_38;
                    }
                    operator delete(v29);
                    if ((v28 & 0x80000000) == 0)
                    {
LABEL_39:
                      if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                        goto LABEL_40;
                      goto LABEL_49;
                    }
LABEL_48:
                    operator delete(v27);
                    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_40;
LABEL_49:
                    operator delete(v26.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v50) & 0x80000000) == 0)
                    {
LABEL_41:
                      if ((SBYTE7(v48) & 0x80000000) == 0)
                        goto LABEL_42;
                      goto LABEL_51;
                    }
LABEL_50:
                    operator delete(*((void **)&v49 + 1));
                    if ((SBYTE7(v48) & 0x80000000) == 0)
                    {
LABEL_42:
                      if ((SHIBYTE(v46) & 0x80000000) == 0)
                        goto LABEL_43;
                      goto LABEL_52;
                    }
LABEL_51:
                    operator delete((void *)v47);
                    if ((SHIBYTE(v46) & 0x80000000) == 0)
                    {
LABEL_43:
                      if ((SBYTE7(v45) & 0x80000000) == 0)
                        goto LABEL_44;
                      goto LABEL_53;
                    }
LABEL_52:
                    operator delete(*((void **)&v45 + 1));
                    if ((SBYTE7(v45) & 0x80000000) == 0)
                    {
LABEL_44:
                      v7 = v52;
                      if (!v52)
                        return;
                      goto LABEL_54;
                    }
LABEL_53:
                    operator delete((void *)buf);
                    v7 = v52;
                    if (!v52)
                      return;
                    goto LABEL_54;
                  }
LABEL_33:
                  operator delete((void *)__dst);
                  if (*(_DWORD *)(v5 + 380) != 2)
                    goto LABEL_40;
                  goto LABEL_34;
                }
              }
              memmove(v20, v17, v19);
              goto LABEL_26;
            }
          }
          memmove(p_dst, v10, v12);
          goto LABEL_18;
        }
      }
LABEL_54:
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v25 = __ldaxr(p_shared_owners);
      while (__stlxr(v25 - 1, p_shared_owners));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A34DB834(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  ResetInfo::~ResetInfo((void **)va);
  ResetInfo::~ResetInfo((void **)(v2 - 192));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 80);
  _Unwind_Resume(a1);
}

void sub_1A34DB860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,_QWORD *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  uint64_t v44;

  if (a35 < 0)
    operator delete(__p);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a27, a28);
  if (a44 < 0)
  {
    operator delete(a39);
    if ((*(char *)(v44 - 201) & 0x80000000) == 0)
    {
LABEL_5:
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v44 - 80);
      _Unwind_Resume(a1);
    }
  }
  else if ((*(char *)(v44 - 201) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*(void **)(v44 - 224));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v44 - 80);
  _Unwind_Resume(a1);
}

void sub_1A34DB8E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 80);
  _Unwind_Resume(a1);
}

void INTTrace::commandResetModem_sync(uint64_t a1, __int128 *a2)
{
  NSObject *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::string v11;
  void *v12;
  char v13;
  void *v14;
  char v15;
  void *v16;
  char v17;
  void *__p;
  char v19;
  void *v20;
  char v21;
  _BYTE v22[8];
  _QWORD *v23;
  void *v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  _BYTE v29[8];
  _QWORD *v30;
  void *v31;
  char v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  v4 = *(NSObject **)(a1 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 144));
    dispatch_group_enter(v4);
  }
  v5 = *(std::__shared_weak_count **)(a1 + 136);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    v34 = v6;
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)(a1 + 128);
      v33 = v8;
      if (!v8)
      {
LABEL_16:
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v10 = __ldaxr(p_shared_owners);
        while (__stlxr(v10 - 1, p_shared_owners));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        goto LABEL_20;
      }
      if (!*(_QWORD *)(a1 + 328))
        goto LABEL_8;
      v32 = 0;
      LOBYTE(v31) = 0;
      Timestamp::Timestamp((Timestamp *)v29);
      v28 = 0;
      LOWORD(v27) = 0;
      LOBYTE(v26) = 0;
      abm::trace::TraceInfo::push();
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v29, v30);
      if (v32 < 0)
      {
        operator delete(v31);
        if (!*(_QWORD *)(a1 + 344))
          goto LABEL_12;
      }
      else
      {
LABEL_8:
        if (!*(_QWORD *)(a1 + 344))
          goto LABEL_12;
      }
      v25 = 0;
      LOBYTE(v24) = 0;
      Timestamp::Timestamp((Timestamp *)v22);
      v21 = 0;
      LOBYTE(v20) = 0;
      v19 = 0;
      LOBYTE(__p) = 0;
      abm::trace::TraceInfo::push();
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v22, v23);
      if (v25 < 0)
        operator delete(v24);
LABEL_12:
      ResetInfo::ResetInfo(&v11, a2);
      abm::BasebandTracingTask::commandResetModem(v8, (ResetInfo *)&v11);
      if (v17 < 0)
      {
        operator delete(v16);
        if ((v15 & 0x80000000) == 0)
        {
LABEL_14:
          if ((v13 & 0x80000000) == 0)
            goto LABEL_15;
          goto LABEL_25;
        }
      }
      else if ((v15 & 0x80000000) == 0)
      {
        goto LABEL_14;
      }
      operator delete(v14);
      if ((v13 & 0x80000000) == 0)
      {
LABEL_15:
        if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_16;
LABEL_26:
        operator delete(v11.__r_.__value_.__l.__data_);
        goto LABEL_16;
      }
LABEL_25:
      operator delete(v12);
      if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_16;
      goto LABEL_26;
    }
  }
LABEL_20:
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
}

void sub_1A34DBB74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,_QWORD *a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  NSObject *v43;
  uint64_t v44;

  if (a28 < 0)
  {
    operator delete(__p);
    if ((a34 & 0x80000000) == 0)
    {
LABEL_3:
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a35, a36);
      if ((a43 & 0x80000000) == 0)
      {
LABEL_8:
        std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v44 - 80);
        if (v43)
        {
          dispatch_group_leave(v43);
          dispatch_release(v43);
        }
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(a38);
      goto LABEL_8;
    }
  }
  else if ((a34 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a29);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a35, a36);
  if ((a43 & 0x80000000) == 0)
    goto LABEL_8;
  goto LABEL_7;
}

void INTTrace::stopReader_sync(INTTrace *this)
{
  abm::trace::TraceReader *v2;
  char v3;
  NSObject *v4;
  uint8_t v5[16];
  uint8_t buf[16];

  v2 = (abm::trace::TraceReader *)*((_QWORD *)this + 30);
  if (!v2)
    goto LABEL_7;
  v3 = abm::trace::TraceReader::stop(v2);
  v4 = *((_QWORD *)this + 5);
  if ((v3 & 1) != 0)
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Succeeded stopping reader.", v5, 2u);
      if (!*((_BYTE *)this + 272))
        return;
      goto LABEL_8;
    }
LABEL_7:
    if (!*((_BYTE *)this + 272))
      return;
    goto LABEL_8;
  }
  if (!os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
    goto LABEL_7;
  *(_WORD *)buf = 0;
  _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Failed to stop reader", buf, 2u);
  if (!*((_BYTE *)this + 272))
    return;
LABEL_8:
  dispatch_group_leave(*((dispatch_group_t *)this + 18));
  *((_BYTE *)this + 272) = 0;
}

void INTTrace::start_sync(INTTrace *this, group *a2)
{
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  CommandDriverFactory *v10;
  uint64_t v11;
  __int128 v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  __int128 v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_weak_owners;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *gr_name;
  void *v41;
  NSObject *v42;
  unint64_t v43;
  void *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  _OWORD *v50;
  NSObject *v51;
  char v52;
  NSObject *v53;
  NSObject *v54;
  NSObject *v55;
  _BYTE v56[8];
  _QWORD *v57;
  void *v58;
  char v59;
  void *v60;
  char v61;
  void *v62;
  char v63;
  _BYTE v64[8];
  _QWORD *v65;
  void *v66;
  char v67;
  std::string v68;
  char *v69;
  void *v70;
  dispatch_object_t v71;
  void *v72;
  dispatch_object_t object;
  _QWORD v74[6];
  std::__shared_weak_count *v75;
  _QWORD aBlock[6];
  std::__shared_weak_count *v77;
  dispatch_object_t v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  __int128 v81;
  void *__p;
  char v83;
  void *v84;
  char v85;
  _BYTE v86[8];
  _QWORD *v87;
  void *v88;
  char v89;
  uint64_t v90;
  uint64_t v91;
  char v92;
  _BYTE v93[8];
  _QWORD *v94;
  void *v95;
  char v96;
  _BYTE buf[22];
  __int16 v98;
  const char *v99;
  __int16 v100;
  int v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *((int *)this + 38);
    if (v5 > 6)
      v6 = "Unknown";
    else
      v6 = off_1E4A0B008[v5];
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v6;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Starting BB Trace with mode: %s", buf, 0xCu);
  }
  if (!*((_BYTE *)this + 284))
    INTTrace::prepare_sync(this);
  if (!*((_QWORD *)this + 41))
    goto LABEL_10;
  v96 = 0;
  LOBYTE(v95) = 0;
  Timestamp::Timestamp((Timestamp *)v93);
  v92 = 0;
  LOWORD(v91) = 0;
  LOBYTE(v90) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v93, v94);
  if (v96 < 0)
  {
    operator delete(v95);
    if (!*((_QWORD *)this + 43))
      goto LABEL_14;
  }
  else
  {
LABEL_10:
    if (!*((_QWORD *)this + 43))
      goto LABEL_14;
  }
  v89 = 0;
  LOBYTE(v88) = 0;
  Timestamp::Timestamp((Timestamp *)v86);
  v85 = 0;
  LOBYTE(v84) = 0;
  v83 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v86, v87);
  if (v89 < 0)
    operator delete(v88);
LABEL_14:
  v7 = *((_QWORD *)this + 32);
  if (!v7)
  {
    v9 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#I Trace Command Driver is creating!", buf, 2u);
    }
    v10 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    v11 = off_1ED114670;
    if (!off_1ED114670)
    {
      CommandDriverFactory::create_default_global(v10);
      v12 = *(_OWORD *)buf;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v13 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
      off_1ED114670 = v12;
      if (v13)
      {
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          v15 = __ldaxr(p_shared_owners);
        while (__stlxr(v15 - 1, p_shared_owners));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      v16 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v17 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v11 = off_1ED114670;
    }
    v79 = v11;
    v80 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
    if (*(&off_1ED114670 + 1))
    {
      v19 = (unint64_t *)(*(&off_1ED114670 + 1) + 8);
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    (*(void (**)(__int128 *__return_ptr, uint64_t))(*(_QWORD *)v11 + 136))(&v81, v11);
    v21 = v81;
    v81 = 0uLL;
    v22 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
    *((_OWORD *)this + 16) = v21;
    if (v22)
    {
      v23 = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v25 = (std::__shared_weak_count *)*((_QWORD *)&v81 + 1);
    if (*((_QWORD *)&v81 + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&v81 + 1) + 8);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    if (v80)
    {
      v28 = &v80->__shared_owners_;
      do
        v29 = __ldaxr((unint64_t *)v28);
      while (__stlxr(v29 - 1, (unint64_t *)v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
        std::__shared_weak_count::__release_weak(v80);
      }
    }
    if (!*((_QWORD *)this + 32))
    {
      v54 = GetOsLogContext()[1];
      if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_1A343C000, v54, OS_LOG_TYPE_FAULT, "Trace command driver must be present!", buf, 2u);
      }
      v55 = GetOsLogContext()[1];
      if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "ABM ASSERT";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "fTraceCommandDriver";
        v98 = 2080;
        v99 = "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHelper/Server/"
              "Tasks/Wireless/Trace/INTTrace/INTTrace.cpp";
        v100 = 1024;
        v101 = 840;
        _os_log_fault_impl(&dword_1A343C000, v55, OS_LOG_TYPE_FAULT, "%s (%s): File: %s Line: %d", buf, 0x26u);
      }
      __break(1u);
      return;
    }
    v30 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
    if (!v30 || (v31 = *((_QWORD *)this + 9), (v32 = std::__shared_weak_count::lock(v30)) == 0))
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v33 = v32;
    p_shared_weak_owners = (unint64_t *)&v32->__shared_weak_owners_;
    do
      v35 = __ldxr(p_shared_weak_owners);
    while (__stxr(v35 + 1, p_shared_weak_owners));
    v36 = (unint64_t *)&v32->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v33);
    }
    memset(buf, 170, 16);
    v38 = MEMORY[0x1E0C809B0];
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_15;
    aBlock[4] = this;
    aBlock[5] = v31;
    v77 = v33;
    do
      v39 = __ldxr(p_shared_weak_owners);
    while (__stxr(v39 + 1, p_shared_weak_owners));
    gr_name = a2->gr_name;
    v78 = (dispatch_object_t)gr_name;
    if (gr_name)
      dispatch_retain((dispatch_object_t)gr_name);
    v41 = _Block_copy(aBlock);
    v42 = *((_QWORD *)this + 11);
    if (v42)
      dispatch_retain(*((dispatch_object_t *)this + 11));
    *(_QWORD *)buf = v41;
    *(_QWORD *)&buf[8] = v42;
    *(_QWORD *)&v81 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v81 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v74[0] = v38;
    v74[1] = 1174405120;
    v74[2] = ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke_16;
    v74[3] = &__block_descriptor_tmp_19_2;
    v74[4] = this;
    v74[5] = v31;
    v75 = v33;
    do
      v43 = __ldxr(p_shared_weak_owners);
    while (__stxr(v43 + 1, p_shared_weak_owners));
    v44 = _Block_copy(v74);
    v45 = *((_QWORD *)this + 11);
    if (v45)
      dispatch_retain(*((dispatch_object_t *)this + 11));
    *(_QWORD *)&v81 = v44;
    *((_QWORD *)&v81 + 1) = v45;
    v46 = *((_QWORD *)this + 32);
    if (v41)
    {
      v72 = _Block_copy(v41);
      object = v42;
      if (!v42)
        goto LABEL_72;
    }
    else
    {
      v72 = 0;
      object = v42;
      if (!v42)
      {
LABEL_72:
        (*(void (**)(uint64_t, void **))(*(_QWORD *)v46 + 112))(v46, &v72);
        if (object)
          dispatch_release(object);
        if (v72)
          _Block_release(v72);
        v47 = *((_QWORD *)this + 32);
        if (v44)
        {
          v70 = _Block_copy(v44);
          v71 = v45;
          if (!v45)
          {
LABEL_79:
            (*(void (**)(uint64_t, void **))(*(_QWORD *)v47 + 120))(v47, &v70);
            if (v71)
              dispatch_release(v71);
            if (v70)
              _Block_release(v70);
            if (v45)
              dispatch_release(v45);
            if (v44)
              _Block_release(v44);
            if (v75)
              std::__shared_weak_count::__release_weak(v75);
            if (v42)
              dispatch_release(v42);
            if (v41)
              _Block_release(v41);
            if (v78)
              dispatch_release(v78);
            if (v77)
              std::__shared_weak_count::__release_weak(v77);
            std::__shared_weak_count::__release_weak(v33);
            goto LABEL_98;
          }
        }
        else
        {
          v70 = 0;
          v71 = v45;
          if (!v45)
            goto LABEL_79;
        }
        dispatch_retain(v45);
        goto LABEL_79;
      }
    }
    dispatch_retain(v42);
    goto LABEL_72;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 152))(v7) & 1) == 0)
  {
    v8 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I Trace Command Driver has not been started!", buf, 2u);
    }
    return;
  }
LABEL_98:
  if (*((char *)this + 207) < 0)
  {
    if (*((_QWORD *)this + 24))
      goto LABEL_100;
  }
  else if (*((_BYTE *)this + 207))
  {
LABEL_100:
    v48 = *((_QWORD *)this + 32);
    if (v48 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v48 + 152))(v48) & 1) == 0)
      (*(void (**)(_QWORD))(**((_QWORD **)this + 32) + 136))(*((_QWORD *)this + 32));
    v49 = a2->gr_name;
    v69 = v49;
    if (v49)
      dispatch_retain((dispatch_object_t)v49);
    v50 = (_OWORD *)((char *)this + 184);
    if (*((char *)this + 207) < 0)
    {
      std::string::__init_copy_ctor_external(&v68, *((const std::string::value_type **)this + 23), *((_QWORD *)this + 24));
    }
    else
    {
      *(_OWORD *)&v68.__r_.__value_.__l.__data_ = *v50;
      v68.__r_.__value_.__r.__words[2] = *((_QWORD *)this + 25);
    }
    v52 = INTTrace::sendConfig_sync((uint64_t)this, (dispatch_object_t *)&v69, (const std::string::value_type *)&v68, 0, 0, 0);
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v68.__r_.__value_.__l.__data_);
    if (v49)
      dispatch_release((dispatch_object_t)v49);
    if ((v52 & 1) == 0)
    {
      v53 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)this + 207) < 0)
          v50 = *(_OWORD **)v50;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v50;
        _os_log_error_impl(&dword_1A343C000, v53, OS_LOG_TYPE_ERROR, "Failed to send config: %s", buf, 0xCu);
      }
      return;
    }
    goto LABEL_116;
  }
  v51 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v51, OS_LOG_TYPE_DEFAULT, "#I No config is given. Skip to send the configuration", buf, 2u);
  }
  if (!*((_QWORD *)this + 41))
    goto LABEL_118;
LABEL_116:
  v67 = 0;
  LOBYTE(v66) = 0;
  Timestamp::Timestamp((Timestamp *)v64);
  v63 = 0;
  LOBYTE(v62) = 0;
  v61 = 0;
  LOBYTE(v60) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v64, v65);
  if (v67 < 0)
  {
    operator delete(v66);
    if (!*((_QWORD *)this + 43))
      return;
  }
  else
  {
LABEL_118:
    if (!*((_QWORD *)this + 43))
      return;
  }
  v59 = 0;
  LOBYTE(v58) = 0;
  Timestamp::Timestamp((Timestamp *)v56);
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v56, v57);
  if (v59 < 0)
    operator delete(v58);
}

void sub_1A34DC760(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  _Unwind_Resume(a1);
}

void ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke(_QWORD *a1, NSObject **a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  uint8_t *v14;
  NSObject *v15;
  NSObject *v16;
  char *v17;
  int v18;
  NSObject *v19;
  uint8_t *v20;
  char v21;
  void *v22;
  size_t v23;
  uint8_t *v24;
  void *v25[2];
  char v26;
  dispatch_object_t v27;
  std::string v28;
  dispatch_object_t v29;
  void *v30;
  char v31;
  void *v32;
  char v33;
  _BYTE v34[8];
  _QWORD *v35;
  void *v36;
  char v37;
  void *__p;
  char v39;
  void *v40;
  char v41;
  _BYTE v42[8];
  _QWORD *v43;
  void *v44;
  char v45;
  uint8_t buf[16];
  uint64_t v47;
  uint8_t v48[4];
  uint8_t *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v3 = (std::__shared_weak_count *)a1[6];
  if (!v3)
    return;
  v5 = a1[4];
  v6 = std::__shared_weak_count::lock(v3);
  if (!v6)
    return;
  v7 = v6;
  v8 = a1[5];
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (v10)
  {
    if (!v8)
      return;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
    if (!v8)
      return;
  }
  v11 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I ARI Low Power enter event received", buf, 2u);
  }
  *(_QWORD *)&buf[8] = 0xAAAAAAAAAAAAAAAALL;
  v47 = 0xAAAAAAAAAAAAAALL;
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAA00;
  if (!*(_QWORD *)(v5 + 328))
    goto LABEL_13;
  v45 = 0;
  LOBYTE(v44) = 0;
  Timestamp::Timestamp((Timestamp *)v42);
  v41 = 0;
  LOBYTE(v40) = 0;
  v39 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v42, v43);
  if (v45 < 0)
  {
    operator delete(v44);
    if (!*(_QWORD *)(v5 + 344))
      goto LABEL_17;
  }
  else
  {
LABEL_13:
    if (!*(_QWORD *)(v5 + 344))
      goto LABEL_17;
  }
  v37 = 0;
  LOBYTE(v36) = 0;
  Timestamp::Timestamp((Timestamp *)v34);
  v33 = 0;
  LOBYTE(v32) = 0;
  v31 = 0;
  LOBYTE(v30) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v34, v35);
  if (v37 < 0)
    operator delete(v36);
LABEL_17:
  *(_BYTE *)(v5 + 320) = 1;
  v12 = *(_DWORD *)(v5 + 288);
  if (v12)
  {
    v13 = *(char *)(v5 + 319);
    if (v13 < 0)
    {
      if (*(_QWORD *)(v5 + 304))
        goto LABEL_20;
    }
    else if (*(_BYTE *)(v5 + 319))
    {
LABEL_20:
      v14 = (uint8_t *)(v5 + 296);
      v15 = *a2;
      v29 = v15;
      if (v15)
      {
        dispatch_retain(v15);
        LOBYTE(v13) = *(_BYTE *)(v5 + 319);
      }
      if ((v13 & 0x80) != 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v5 + 296), *(_QWORD *)(v5 + 304));
      }
      else
      {
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = *(_OWORD *)v14;
        v28.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 312);
      }
      *(_BYTE *)(v5 + 320) = INTTrace::sendConfig_sync(v5, &v29, (const std::string::value_type *)&v28, v12 == 2, 1u, 0);
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v28.__r_.__value_.__l.__data_);
      if (v15)
        dispatch_release(v15);
      if (buf != v14)
      {
        v21 = *(_BYTE *)(v5 + 319);
        if (SHIBYTE(v47) < 0)
        {
          if (v21 >= 0)
            v22 = (void *)(v5 + 296);
          else
            v22 = *(void **)(v5 + 296);
          if (v21 >= 0)
            v23 = *(unsigned __int8 *)(v5 + 319);
          else
            v23 = *(_QWORD *)(v5 + 304);
          std::string::__assign_no_alias<false>((void **)buf, v22, v23);
        }
        else if ((*(_BYTE *)(v5 + 319) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(buf, *(void **)(v5 + 296), *(_QWORD *)(v5 + 304));
        }
        else
        {
          *(_OWORD *)buf = *(_OWORD *)v14;
          v47 = *(_QWORD *)(v5 + 312);
        }
      }
      goto LABEL_35;
    }
  }
  v16 = a1[7];
  v27 = v16;
  if (v16)
    dispatch_retain(v16);
  v26 = 4;
  strcpy((char *)v25, "Stop");
  *(_BYTE *)(v5 + 320) = INTTrace::sendConfig_sync(v5, &v27, (const std::string::value_type *)v25, 0, 1u, 0);
  if (v26 < 0)
    operator delete(v25[0]);
  if (v16)
    dispatch_release(v16);
  if (SHIBYTE(v47) < 0)
  {
    *(_QWORD *)&buf[8] = 4;
    v17 = *(char **)buf;
  }
  else
  {
    HIBYTE(v47) = 4;
    v17 = (char *)buf;
  }
  strcpy(v17, "Stop");
  INTTrace::stopReader_sync((INTTrace *)v5);
LABEL_35:
  v18 = *(unsigned __int8 *)(v5 + 320);
  v19 = *(NSObject **)(v5 + 40);
  if (!v18)
  {
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v24 = buf;
      if (v47 < 0)
        v24 = *(uint8_t **)buf;
      *(_DWORD *)v48 = 136315138;
      v49 = v24;
      _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to send config: %s", v48, 0xCu);
      if (SHIBYTE(v47) < 0)
        goto LABEL_43;
      return;
    }
LABEL_42:
    if ((SHIBYTE(v47) & 0x80000000) == 0)
      return;
    goto LABEL_43;
  }
  if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    goto LABEL_42;
  v20 = buf;
  if (v47 < 0)
    v20 = *(uint8_t **)buf;
  *(_DWORD *)v48 = 136315138;
  v49 = v20;
  _os_log_debug_impl(&dword_1A343C000, v19, OS_LOG_TYPE_DEBUG, "#D Succeeded sending config: %s", v48, 0xCu);
  if (SHIBYTE(v47) < 0)
LABEL_43:
    operator delete(*(void **)buf);
}

void sub_1A34DCED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  uint64_t v55;

  if (*(char *)(v55 - 105) < 0)
    operator delete(*(void **)(v55 - 128));
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::sendConfig_sync(uint64_t a1, dispatch_object_t *a2, const std::string::value_type *a3, unsigned int a4, unsigned int a5, int a6)
{
  const char *v9;
  int v10;
  size_t v11;
  int v12;
  size_t v13;
  unint64_t v14;
  void **v15;
  void **v16;
  __int128 *v17;
  unint64_t v18;
  char *v19;
  int v20;
  NSObject *v22;
  int v23;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  unint64_t v30;
  _OWORD *v31;
  _BYTE *v32;
  char *v33;
  __int128 *v34;
  _OWORD *v35;
  unint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  void **v41;
  void **v42;
  NSObject *v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_weak_owners;
  unint64_t v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  uint64_t v52;
  NSObject *v53;
  const void *v54;
  size_t v55;
  NSObject *v56;
  unint64_t v57;
  void *v58;
  NSObject *v59;
  dispatch_time_t v60;
  NSObject *v61;
  std::__shared_weak_count *v62;
  char *v63;
  void **v65;
  dispatch_object_t *v66;
  unsigned int v67;
  _QWORD aBlock[5];
  dispatch_group_t group;
  uint64_t v73;
  std::__shared_weak_count *v74;
  std::string v75;
  void *v76;
  dispatch_object_t object;
  dispatch_object_t v78;
  void *v79;
  char *v80;
  char *v81;
  void *__p[2];
  int64_t v83;
  void *__dst[3];
  __int128 v85;
  uint64_t v86;
  void **v87;
  size_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  uint64_t v92;
  _BYTE buf[24];
  unsigned int v94;
  __int16 v95;
  unsigned int v96;
  __int16 v97;
  unsigned int v98;
  uint64_t v99;

  v99 = *MEMORY[0x1E0C80C00];
  v67 = *(_DWORD *)(a1 + 160);
  v90 = 0;
  v91 = 0;
  v92 = 0;
  v87 = 0;
  v88 = 0;
  buf[23] = 19;
  v89 = 0;
  strcpy(buf, "kKeyTraceConfigPath");
  defaults::bbtrace::get(buf, (std::string::size_type *)&v87);
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    v9 = a3;
    if ((a3[23] & 0x80000000) == 0)
      goto LABEL_3;
  }
  else
  {
    v9 = a3;
    if ((a3[23] & 0x80000000) == 0)
      goto LABEL_3;
  }
  v9 = *(const char **)a3;
LABEL_3:
  KTLGetTraceConfigFilename(v9);
  v10 = SHIBYTE(v89);
  v86 = *(_QWORD *)&buf[16];
  v85 = *(_OWORD *)buf;
  if (v89 >= 0)
    v11 = HIBYTE(v89);
  else
    v11 = v88;
  v12 = SHIBYTE(v86);
  if (v86 >= 0)
    v13 = HIBYTE(v86);
  else
    v13 = *((_QWORD *)&v85 + 1);
  v14 = v13 + v11;
  memset(__dst, 170, sizeof(__dst));
  if (v13 + v11 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v66 = a2;
  if (v14 <= 0x16)
  {
    memset(__dst, 0, sizeof(__dst));
    v15 = __dst;
    HIBYTE(__dst[2]) = v13 + v11;
    if (!v11)
      goto LABEL_16;
    goto LABEL_12;
  }
  v25 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v14 | 7) != 0x17)
    v25 = v14 | 7;
  v26 = v25 + 1;
  v15 = (void **)operator new(v25 + 1);
  __dst[1] = (void *)(v13 + v11);
  __dst[2] = (void *)(v26 | 0x8000000000000000);
  __dst[0] = v15;
  if (v11)
  {
LABEL_12:
    if (v10 >= 0)
      v16 = (void **)&v87;
    else
      v16 = v87;
    memmove(v15, v16, v11);
  }
LABEL_16:
  if (v13)
  {
    if (v12 >= 0)
      v17 = &v85;
    else
      v17 = (__int128 *)v85;
    memmove((char *)v15 + v11, v17, v13);
  }
  *((_BYTE *)v15 + v11 + v13) = 0;
  if ((ctu::fs::load_file() & 1) == 0)
  {
    v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v65 = __dst;
      if (SHIBYTE(__dst[2]) < 0)
        v65 = (void **)__dst[0];
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v65;
      _os_log_error_impl(&dword_1A343C000, v27, OS_LOG_TYPE_ERROR, "Failed to load from %s", buf, 0xCu);
    }
    v28 = 0;
    goto LABEL_130;
  }
  v18 = v90;
  v19 = v91;
  if (v91 == (char *)v90)
  {
    v18 = (unint64_t)v91;
    v29 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_69;
LABEL_48:
    v30 = (unint64_t)&v19[-v18];
    if ((unint64_t)&v19[-v18] > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    if (v30 > 0x16)
    {
      v38 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v30 | 7) != 0x17)
        v38 = v30 | 7;
      v39 = v38 + 1;
      v31 = operator new(v38 + 1);
      __p[1] = &v19[-v18];
      v83 = v39 | 0x8000000000000000;
      __p[0] = v31;
      if ((char *)v18 != v19)
        goto LABEL_51;
    }
    else
    {
      HIBYTE(v83) = (_BYTE)v19 - v18;
      v31 = __p;
      if ((char *)v18 != v19)
      {
LABEL_51:
        if (v30 < 0x20 || (unint64_t)v31 - v18 < 0x20)
        {
          v32 = v31;
          v33 = (char *)v18;
        }
        else
        {
          v32 = (char *)v31 + (v30 & 0xFFFFFFFFFFFFFFE0);
          v33 = (char *)(v18 + (v30 & 0xFFFFFFFFFFFFFFE0));
          v34 = (__int128 *)(v18 + 16);
          v35 = v31 + 1;
          v36 = v30 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v37 = *v34;
            *(v35 - 1) = *(v34 - 1);
            *v35 = v37;
            v34 += 2;
            v35 += 2;
            v36 -= 32;
          }
          while (v36);
          if (v30 == (v30 & 0xFFFFFFFFFFFFFFE0))
            goto LABEL_63;
        }
        do
        {
          v40 = *v33++;
          *v32++ = v40;
        }
        while (v33 != v19);
LABEL_63:
        *v32 = 0;
        v41 = __p;
        if (v83 < 0)
          v41 = (void **)__p[0];
        v42 = __dst;
        if (SHIBYTE(__dst[2]) < 0)
          v42 = (void **)__dst[0];
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v41;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v42;
        *(_WORD *)&buf[22] = 1024;
        v94 = a4;
        v95 = 1024;
        v96 = a5;
        v97 = 1024;
        v98 = v67;
        _os_log_impl(&dword_1A343C000, v29, OS_LOG_TYPE_DEFAULT, "#I Sending trace config to BB: %s (%s), background tracing: %d, wait for idle indication: %d, privacy level: %d", buf, 0x28u);
        if (SHIBYTE(v83) < 0)
          operator delete(__p[0]);
        goto LABEL_69;
      }
    }
    v32 = v31;
    goto LABEL_63;
  }
  v20 = v91[v90 + ~v90];
  if (v20 == 13 || v20 == 10)
  {
    while (1)
    {
      v91 = --v19;
      v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v22, OS_LOG_TYPE_DEFAULT, "#I Trailing EOL character removed", buf, 2u);
        v18 = v90;
        v19 = v91;
      }
      if (v19 == (char *)v18)
        break;
      v23 = v19[v18 + ~v18];
      if (v23 != 13 && v23 != 10)
        goto LABEL_45;
    }
    v19 = (char *)v18;
  }
LABEL_45:
  v29 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    goto LABEL_48;
LABEL_69:
  v43 = *v66;
  if (*v66)
  {
    dispatch_retain(*v66);
    dispatch_group_enter(v43);
  }
  v44 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v44 || (v45 = *(_QWORD *)(a1 + 72), (v46 = std::__shared_weak_count::lock(v44)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v47 = v46;
  p_shared_weak_owners = (unint64_t *)&v46->__shared_weak_owners_;
  do
    v49 = __ldxr(p_shared_weak_owners);
  while (__stxr(v49 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v46->__shared_owners_;
  do
    v51 = __ldaxr(p_shared_owners);
  while (__stlxr(v51 - 1, p_shared_owners));
  if (v51)
  {
    v52 = *(_QWORD *)(a1 + 256);
    if (v52)
      goto LABEL_79;
LABEL_83:
    v56 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v56, OS_LOG_TYPE_ERROR, "Trace command driver is not ready!", buf, 2u);
    }
LABEL_118:
    v28 = 0;
    std::__shared_weak_count::__release_weak(v47);
    if (!v43)
      goto LABEL_130;
    goto LABEL_129;
  }
  ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
  std::__shared_weak_count::__release_weak(v47);
  v52 = *(_QWORD *)(a1 + 256);
  if (!v52)
    goto LABEL_83;
LABEL_79:
  if (a6)
  {
    v53 = dispatch_group_create();
    dispatch_group_enter(v53);
    v52 = *(_QWORD *)(a1 + 256);
    v79 = 0;
    v80 = 0;
    v81 = 0;
    v54 = (const void *)v90;
    v55 = (size_t)&v91[-v90];
    if (v91 == (char *)v90)
      goto LABEL_88;
LABEL_86:
    if ((v55 & 0x8000000000000000) != 0)
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    v79 = operator new(v55);
    v81 = (char *)v79 + v55;
    memcpy(v79, v54, v55);
    v80 = (char *)v79 + v55;
    goto LABEL_88;
  }
  v53 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v54 = (const void *)v90;
  v55 = (size_t)&v91[-v90];
  if (v91 != (char *)v90)
    goto LABEL_86;
LABEL_88:
  v78 = v53;
  if (v53)
    dispatch_retain(v53);
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 1174405120;
  aBlock[2] = ___ZN8INTTrace15sendConfig_syncEN8dispatch5groupENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEbbb_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_22_0;
  aBlock[4] = a1;
  group = v43;
  if (v43)
  {
    dispatch_retain(v43);
    dispatch_group_enter(group);
  }
  v73 = v45;
  v74 = v47;
  do
    v57 = __ldxr(p_shared_weak_owners);
  while (__stxr(v57 + 1, p_shared_weak_owners));
  if (a3[23] < 0)
    std::string::__init_copy_ctor_external(&v75, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  else
    v75 = *(std::string *)a3;
  v58 = _Block_copy(aBlock);
  v59 = *(NSObject **)(a1 + 88);
  if (v59)
    dispatch_retain(*(dispatch_object_t *)(a1 + 88));
  v76 = v58;
  object = v59;
  (*(void (**)(uint64_t, void **, dispatch_object_t *, _QWORD, _QWORD, _QWORD, void **))(*(_QWORD *)v52 + 160))(v52, &v79, &v78, a4, a5, v67, &v76);
  if (object)
    dispatch_release(object);
  if (v76)
    _Block_release(v76);
  if (v78)
    dispatch_release(v78);
  if (v79)
  {
    v80 = (char *)v79;
    operator delete(v79);
  }
  if (a6)
  {
    v60 = dispatch_time(0, 5000000000);
    if (dispatch_group_wait(v53, v60))
    {
      v61 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        if (a3[23] < 0)
          a3 = *(const std::string::value_type **)a3;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = a3;
        _os_log_error_impl(&dword_1A343C000, v61, OS_LOG_TYPE_ERROR, "Timeout waiting for confirmation while sending %s config", buf, 0xCu);
        if ((SHIBYTE(v75.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_111:
          v62 = v74;
          if (!v74)
            goto LABEL_113;
          goto LABEL_112;
        }
      }
      else if ((SHIBYTE(v75.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_111;
      }
      operator delete(v75.__r_.__value_.__l.__data_);
      v62 = v74;
      if (!v74)
      {
LABEL_113:
        if (group)
        {
          dispatch_group_leave(group);
          if (group)
            dispatch_release(group);
        }
        if (v53)
          dispatch_release(v53);
        goto LABEL_118;
      }
LABEL_112:
      std::__shared_weak_count::__release_weak(v62);
      goto LABEL_113;
    }
  }
  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v75.__r_.__value_.__l.__data_);
  if (v74)
    std::__shared_weak_count::__release_weak(v74);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  if (v53)
  {
    dispatch_release(v53);
    v28 = 1;
    std::__shared_weak_count::__release_weak(v47);
    if (!v43)
      goto LABEL_130;
    goto LABEL_129;
  }
  v28 = 1;
  std::__shared_weak_count::__release_weak(v47);
  if (v43)
  {
LABEL_129:
    dispatch_group_leave(v43);
    dispatch_release(v43);
  }
LABEL_130:
  if (SHIBYTE(__dst[2]) < 0)
  {
    operator delete(__dst[0]);
    if ((SHIBYTE(v86) & 0x80000000) == 0)
    {
LABEL_132:
      if ((SHIBYTE(v89) & 0x80000000) == 0)
        goto LABEL_133;
LABEL_138:
      operator delete(v87);
      v63 = (char *)v90;
      if (!v90)
        return v28;
      goto LABEL_134;
    }
  }
  else if ((SHIBYTE(v86) & 0x80000000) == 0)
  {
    goto LABEL_132;
  }
  operator delete((void *)v85);
  if (SHIBYTE(v89) < 0)
    goto LABEL_138;
LABEL_133:
  v63 = (char *)v90;
  if (v90)
  {
LABEL_134:
    v91 = v63;
    operator delete(v63);
  }
  return v28;
}

void sub_1A34DD8D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t group, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,dispatch_object_t object,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  NSObject *v46;
  std::__shared_weak_count *v47;
  NSObject *v48;
  uint64_t v49;
  NSObject *v51;
  void *v52;
  void *v53;

  if (a19)
  {
    std::__shared_weak_count::__release_weak(a19);
    v51 = group;
    if (!group)
      goto LABEL_6;
  }
  else
  {
    v51 = group;
    if (!group)
    {
LABEL_6:
      if (object)
      {
        dispatch_release(object);
        v52 = __p;
        if (!__p)
        {
LABEL_8:
          if (!v48)
            goto LABEL_9;
          goto LABEL_13;
        }
      }
      else
      {
        v52 = __p;
        if (!__p)
          goto LABEL_8;
      }
      operator delete(v52);
      if (!v48)
      {
LABEL_9:
        std::__shared_weak_count::__release_weak(v47);
        if (!v46)
        {
LABEL_15:
          if (a40 < 0)
            operator delete(a35);
          if (a46 < 0)
            operator delete(a41);
          if (*(char *)(v49 - 169) < 0)
            operator delete(*(void **)(v49 - 192));
          v53 = *(void **)(v49 - 168);
          if (v53)
          {
            *(_QWORD *)(v49 - 160) = v53;
            operator delete(v53);
          }
          _Unwind_Resume(a1);
        }
LABEL_14:
        dispatch_group_leave(v46);
        dispatch_release(v46);
        goto LABEL_15;
      }
LABEL_13:
      dispatch_release(v48);
      std::__shared_weak_count::__release_weak(v47);
      if (!v46)
        goto LABEL_15;
      goto LABEL_14;
    }
  }
  dispatch_group_leave(v51);
  dispatch_release(group);
  goto LABEL_6;
}

void __copy_helper_block_e8_40c29_ZTSNSt3__18weak_ptrI5TraceEE56c21_ZTSN8dispatch5groupE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  NSObject *v5;

  v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  a1[7] = v5;
  if (v5)
    dispatch_retain(v5);
}

void __destroy_helper_block_e8_40c29_ZTSNSt3__18weak_ptrI5TraceEE56c21_ZTSN8dispatch5groupE(uint64_t a1)
{
  NSObject *v2;
  std::__shared_weak_count *v3;

  v2 = *(NSObject **)(a1 + 56);
  if (v2)
    dispatch_release(v2);
  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke_16(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  NSObject *v10;
  NSObject *v11;
  __int128 v12;
  const void *v13;
  size_t v14;
  size_t v15;
  __int128 *p_dst;
  NSObject *v17;
  _OWORD *v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  size_t v22;
  size_t v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char v28;
  NSObject *v29;
  NSObject *v30;
  std::string v31;
  dispatch_object_t v32;
  std::string v33;
  void *v34;
  char v35;
  void *v36;
  char v37;
  void *v38;
  char v39;
  __int128 v40;
  char v41;
  _BYTE v42[8];
  _QWORD *v43;
  void *v44[2];
  char v45;
  char *v46;
  __int128 v47;
  __int128 v48;
  unint64_t v49;
  __int128 __dst;
  unint64_t v51;
  void *v52;
  char v53;
  void *v54;
  char v55;
  _BYTE v56[8];
  _QWORD *v57;
  void *v58;
  char v59;
  void *__p;
  char v61;
  void *v62;
  char v63;
  _BYTE v64[8];
  _QWORD *v65;
  void *v66;
  char v67;
  uint8_t buf[16];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return;
  v5 = v4;
  v6 = a1[5];
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (v8)
  {
    if (!v6)
      return;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    if (!v6)
      return;
  }
  if (!*(_QWORD *)(v3 + 328))
    goto LABEL_11;
  v67 = 0;
  LOBYTE(v66) = 0;
  Timestamp::Timestamp((Timestamp *)v64);
  v63 = 0;
  LOBYTE(v62) = 0;
  v61 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v64, v65);
  if (v67 < 0)
  {
    operator delete(v66);
    if (!*(_QWORD *)(v3 + 344))
      goto LABEL_15;
  }
  else
  {
LABEL_11:
    if (!*(_QWORD *)(v3 + 344))
      goto LABEL_15;
  }
  v59 = 0;
  LOBYTE(v58) = 0;
  Timestamp::Timestamp((Timestamp *)v56);
  v55 = 0;
  LOBYTE(v54) = 0;
  v53 = 0;
  LOBYTE(v52) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v56, v57);
  if (v59 < 0)
    operator delete(v58);
LABEL_15:
  if ((INTTrace::startReader_sync((INTTrace *)v3) & 1) == 0)
  {
    v10 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Failed to open TRACE transport during sleep exit", buf, 2u);
    }
    return;
  }
  if (!*(_BYTE *)(v3 + 320))
  {
    v11 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Detected failure on last LPM entry", buf, 2u);
    }
    *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v73 = v12;
    v74 = v12;
    v71 = v12;
    v72 = v12;
    v69 = v12;
    v70 = v12;
    *(_OWORD *)buf = v12;
    v13 = (const void *)*MEMORY[0x1E0CFB590];
    v14 = strlen((const char *)*MEMORY[0x1E0CFB590]);
    if (v14 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v15 = v14;
    if (v14 >= 0x17)
    {
      v19 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17)
        v19 = v14 | 7;
      v20 = v19 + 1;
      p_dst = (__int128 *)operator new(v19 + 1);
      *((_QWORD *)&__dst + 1) = v15;
      v51 = v20 | 0x8000000000000000;
      *(_QWORD *)&__dst = p_dst;
    }
    else
    {
      HIBYTE(v51) = v14;
      p_dst = &__dst;
      if (!v14)
      {
LABEL_38:
        *((_BYTE *)p_dst + v15) = 0;
        v21 = (const void *)*MEMORY[0x1E0CFBEA8];
        v22 = strlen((const char *)*MEMORY[0x1E0CFBEA8]);
        if (v22 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v23 = v22;
        if (v22 >= 0x17)
        {
          v25 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v22 | 7) != 0x17)
            v25 = v22 | 7;
          v26 = v25 + 1;
          v24 = operator new(v25 + 1);
          *((_QWORD *)&v48 + 1) = v23;
          v49 = v26 | 0x8000000000000000;
          *(_QWORD *)&v48 = v24;
        }
        else
        {
          HIBYTE(v49) = v22;
          v24 = &v48;
          if (!v22)
          {
LABEL_46:
            v24[v23] = 0;
            v27 = (char *)operator new(0x28uLL);
            v46 = v27;
            v47 = xmmword_1A35802D0;
            strcpy(v27, "Detected failure on last LPM entry");
            Timestamp::Timestamp((Timestamp *)v42);
            Timestamp::asString((uint64_t)v42, 0, 9, v44);
            v41 = 0;
            LOBYTE(v40) = 0;
            ResetInfo::ResetInfo((std::string *)buf, &__dst, &v48, (__int128 *)&v46, (uint64_t)v44, 7, &v40);
            if (v45 < 0)
              operator delete(v44[0]);
            std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v42, v43);
            operator delete(v27);
            if (SHIBYTE(v49) < 0)
            {
              operator delete((void *)v48);
              if ((SHIBYTE(v51) & 0x80000000) == 0)
              {
LABEL_50:
                if (*(_DWORD *)(v3 + 380) != 2)
                {
LABEL_74:
                  if ((SHIBYTE(v74) & 0x80000000) == 0)
                    goto LABEL_75;
                  goto LABEL_83;
                }
LABEL_68:
                v30 = *(NSObject **)(v3 + 40);
                if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__dst) = 0;
                  _os_log_impl(&dword_1A343C000, v30, OS_LOG_TYPE_DEFAULT, "#I Triggering modem reset for LPM Entry Failure", (uint8_t *)&__dst, 2u);
                }
                ResetInfo::ResetInfo(&v33, (__int128 *)buf);
                INTTrace::commandResetModem_sync(v3, (__int128 *)&v33);
                if (v39 < 0)
                {
                  operator delete(v38);
                  if ((v37 & 0x80000000) == 0)
                  {
LABEL_72:
                    if ((v35 & 0x80000000) == 0)
                      goto LABEL_73;
                    goto LABEL_81;
                  }
                }
                else if ((v37 & 0x80000000) == 0)
                {
                  goto LABEL_72;
                }
                operator delete(v36);
                if ((v35 & 0x80000000) == 0)
                {
LABEL_73:
                  if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    goto LABEL_74;
                  goto LABEL_82;
                }
LABEL_81:
                operator delete(v34);
                if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_74;
LABEL_82:
                operator delete(v33.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v74) & 0x80000000) == 0)
                {
LABEL_75:
                  if ((SBYTE7(v72) & 0x80000000) == 0)
                    goto LABEL_76;
                  goto LABEL_84;
                }
LABEL_83:
                operator delete(*((void **)&v73 + 1));
                if ((SBYTE7(v72) & 0x80000000) == 0)
                {
LABEL_76:
                  if ((SHIBYTE(v70) & 0x80000000) == 0)
                    goto LABEL_77;
                  goto LABEL_85;
                }
LABEL_84:
                operator delete((void *)v71);
                if ((SHIBYTE(v70) & 0x80000000) == 0)
                {
LABEL_77:
                  if ((SBYTE7(v69) & 0x80000000) == 0)
                    return;
                  goto LABEL_86;
                }
LABEL_85:
                operator delete(*((void **)&v69 + 1));
                if ((SBYTE7(v69) & 0x80000000) == 0)
                  return;
LABEL_86:
                operator delete(*(void **)buf);
                return;
              }
            }
            else if ((SHIBYTE(v51) & 0x80000000) == 0)
            {
              goto LABEL_50;
            }
            operator delete((void *)__dst);
            if (*(_DWORD *)(v3 + 380) != 2)
              goto LABEL_74;
            goto LABEL_68;
          }
        }
        memmove(v24, v21, v23);
        goto LABEL_46;
      }
    }
    memmove(p_dst, v13, v15);
    goto LABEL_38;
  }
  v9 = *(char *)(v3 + 207);
  if (v9 < 0)
  {
    if (!*(_QWORD *)(v3 + 192))
      return;
  }
  else if (!*(_BYTE *)(v3 + 207))
  {
    return;
  }
  v17 = *(NSObject **)(v3 + 144);
  v32 = v17;
  if (v17)
  {
    dispatch_retain(v17);
    LOBYTE(v9) = *(_BYTE *)(v3 + 207);
  }
  v18 = (_OWORD *)(v3 + 184);
  if ((v9 & 0x80) != 0)
  {
    std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v3 + 184), *(_QWORD *)(v3 + 192));
  }
  else
  {
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *v18;
    v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v3 + 200);
  }
  v28 = INTTrace::sendConfig_sync(v3, &v32, (const std::string::value_type *)&v31, 0, 0, 0);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if (v17)
    dispatch_release(v17);
  v29 = *(NSObject **)(v3 + 40);
  if ((v28 & 1) != 0)
  {
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(v3 + 207) < 0)
        v18 = *(_OWORD **)v18;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v18;
      _os_log_debug_impl(&dword_1A343C000, v29, OS_LOG_TYPE_DEBUG, "#D Succeeded sending config: %s", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(v3 + 207) < 0)
      v18 = *(_OWORD **)v18;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v18;
    _os_log_error_impl(&dword_1A343C000, v29, OS_LOG_TYPE_ERROR, "Failed to send config: %s", buf, 0xCu);
  }
}

void sub_1A34DE1D0(_Unwind_Exception *a1)
{
  NSObject *v1;

  if (v1)
  {
    dispatch_release(v1);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void ___ZN8INTTrace15sendConfig_syncEN8dispatch5groupENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEbbb_block_invoke(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  NSObject *v10;
  __int128 v11;
  const void *v12;
  size_t v13;
  size_t v14;
  __int128 *p_dst;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  size_t v20;
  size_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  std::string v28;
  void *v29;
  char v30;
  void *v31;
  char v32;
  void *v33;
  char v34;
  __int128 v35;
  char v36;
  _BYTE v37[8];
  _QWORD *v38;
  void *__p[2];
  char v40;
  _BYTE v41[24];
  __int128 v42;
  unint64_t v43;
  __int128 __dst;
  unint64_t v45;
  std::__shared_weak_count *v47;
  __int128 buf;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = std::__shared_weak_count::lock(v3);
    v47 = v6;
    if (v6)
    {
      v7 = v6;
      if (*(_QWORD *)(a1 + 48))
      {
        v8 = *a2;
        v9 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
        if (!*a2)
          v9 = 0;
        v10 = *(NSObject **)(v5 + 40);
        if (v9)
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v8;
            _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Failed to send config: %@", (uint8_t *)&buf, 0xCu);
          }
          *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v53 = v11;
          v54 = v11;
          v51 = v11;
          v52 = v11;
          v49 = v11;
          v50 = v11;
          buf = v11;
          v12 = (const void *)*MEMORY[0x1E0CFB590];
          v13 = strlen((const char *)*MEMORY[0x1E0CFB590]);
          if (v13 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          v14 = v13;
          if (v13 >= 0x17)
          {
            v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v13 | 7) != 0x17)
              v17 = v13 | 7;
            v18 = v17 + 1;
            p_dst = (__int128 *)operator new(v17 + 1);
            *((_QWORD *)&__dst + 1) = v14;
            v45 = v18 | 0x8000000000000000;
            *(_QWORD *)&__dst = p_dst;
          }
          else
          {
            HIBYTE(v45) = v13;
            p_dst = &__dst;
            if (!v13)
            {
LABEL_21:
              *((_BYTE *)p_dst + v14) = 0;
              v19 = (const void *)*MEMORY[0x1E0CFBEA8];
              v20 = strlen((const char *)*MEMORY[0x1E0CFBEA8]);
              if (v20 > 0x7FFFFFFFFFFFFFF7)
                std::string::__throw_length_error[abi:ne180100]();
              v21 = v20;
              if (v20 >= 0x17)
              {
                v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v20 | 7) != 0x17)
                  v23 = v20 | 7;
                v24 = v23 + 1;
                v22 = operator new(v23 + 1);
                *((_QWORD *)&v42 + 1) = v21;
                v43 = v24 | 0x8000000000000000;
                *(_QWORD *)&v42 = v22;
              }
              else
              {
                HIBYTE(v43) = v20;
                v22 = &v42;
                if (!v20)
                {
LABEL_29:
                  v22[v21] = 0;
                  v41[23] = 21;
                  strcpy(v41, "Failed to send config");
                  Timestamp::Timestamp((Timestamp *)v37);
                  Timestamp::asString((uint64_t)v37, 0, 9, __p);
                  v36 = 0;
                  LOBYTE(v35) = 0;
                  ResetInfo::ResetInfo((std::string *)&buf, &__dst, &v42, (__int128 *)v41, (uint64_t)__p, 7, &v35);
                  if (v40 < 0)
                  {
                    operator delete(__p[0]);
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v37, v38);
                    if ((SHIBYTE(v43) & 0x80000000) == 0)
                    {
LABEL_31:
                      if ((SHIBYTE(v45) & 0x80000000) == 0)
                        goto LABEL_32;
                      goto LABEL_36;
                    }
                  }
                  else
                  {
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v37, v38);
                    if ((SHIBYTE(v43) & 0x80000000) == 0)
                      goto LABEL_31;
                  }
                  operator delete((void *)v42);
                  if ((SHIBYTE(v45) & 0x80000000) == 0)
                  {
LABEL_32:
                    if ((*(_DWORD *)(v5 + 380) - 1) > 1)
                    {
LABEL_43:
                      if ((SHIBYTE(v54) & 0x80000000) == 0)
                        goto LABEL_44;
                      goto LABEL_53;
                    }
LABEL_37:
                    v25 = *(NSObject **)(v5 + 40);
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(__dst) = 0;
                      _os_log_impl(&dword_1A343C000, v25, OS_LOG_TYPE_DEFAULT, "#I Triggering modem reset for failure to send config", (uint8_t *)&__dst, 2u);
                    }
                    ResetInfo::ResetInfo(&v28, &buf);
                    INTTrace::commandResetModem_sync(v5, (__int128 *)&v28);
                    if (v34 < 0)
                    {
                      operator delete(v33);
                      if ((v32 & 0x80000000) == 0)
                      {
LABEL_41:
                        if ((v30 & 0x80000000) == 0)
                          goto LABEL_42;
                        goto LABEL_51;
                      }
                    }
                    else if ((v32 & 0x80000000) == 0)
                    {
                      goto LABEL_41;
                    }
                    operator delete(v31);
                    if ((v30 & 0x80000000) == 0)
                    {
LABEL_42:
                      if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                        goto LABEL_43;
                      goto LABEL_52;
                    }
LABEL_51:
                    operator delete(v29);
                    if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_43;
LABEL_52:
                    operator delete(v28.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v54) & 0x80000000) == 0)
                    {
LABEL_44:
                      if ((SBYTE7(v52) & 0x80000000) == 0)
                        goto LABEL_45;
                      goto LABEL_54;
                    }
LABEL_53:
                    operator delete(*((void **)&v53 + 1));
                    if ((SBYTE7(v52) & 0x80000000) == 0)
                    {
LABEL_45:
                      if ((SHIBYTE(v50) & 0x80000000) == 0)
                        goto LABEL_46;
                      goto LABEL_55;
                    }
LABEL_54:
                    operator delete((void *)v51);
                    if ((SHIBYTE(v50) & 0x80000000) == 0)
                    {
LABEL_46:
                      if ((SBYTE7(v49) & 0x80000000) == 0)
                        goto LABEL_47;
                      goto LABEL_56;
                    }
LABEL_55:
                    operator delete(*((void **)&v49 + 1));
                    if ((SBYTE7(v49) & 0x80000000) == 0)
                    {
LABEL_47:
                      v7 = v47;
                      if (!v47)
                        return;
                      goto LABEL_57;
                    }
LABEL_56:
                    operator delete((void *)buf);
                    v7 = v47;
                    if (!v47)
                      return;
                    goto LABEL_57;
                  }
LABEL_36:
                  operator delete((void *)__dst);
                  if ((*(_DWORD *)(v5 + 380) - 1) > 1)
                    goto LABEL_43;
                  goto LABEL_37;
                }
              }
              memmove(v22, v19, v21);
              goto LABEL_29;
            }
          }
          memmove(p_dst, v12, v14);
          goto LABEL_21;
        }
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v16 = (_QWORD *)(a1 + 64);
          if (*(char *)(a1 + 87) < 0)
            v16 = (_QWORD *)*v16;
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = v16;
          _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Succeeded to send config - %s", (uint8_t *)&buf, 0xCu);
        }
      }
LABEL_57:
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v27 = __ldaxr(p_shared_owners);
      while (__stlxr(v27 - 1, p_shared_owners));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A34DE7FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  ResetInfo::~ResetInfo((void **)va);
  ResetInfo::~ResetInfo((void **)(v2 - 192));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 208);
  _Unwind_Resume(a1);
}

void sub_1A34DE828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,_QWORD *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  uint64_t v50;

  if (a35 < 0)
    operator delete(__p);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a27, a28);
  if (a44 < 0)
  {
    operator delete(a39);
    if ((a50 & 0x80000000) == 0)
    {
LABEL_5:
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v50 - 208);
      _Unwind_Resume(a1);
    }
  }
  else if ((a50 & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(a45);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v50 - 208);
  _Unwind_Resume(a1);
}

void sub_1A34DE8B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 208);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c29_ZTSNSt3__18weak_ptrI5TraceEE64c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::string *v9;
  __int128 v10;

  v4 = *(NSObject **)(a2 + 40);
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = a1[5];
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = *(_QWORD *)(a2 + 56);
  a1[6] = *(_QWORD *)(a2 + 48);
  a1[7] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 16);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = (std::string *)(a1 + 8);
  if (*(char *)(a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a2 + 64), *(_QWORD *)(a2 + 72));
  }
  else
  {
    v10 = *(_OWORD *)(a2 + 64);
    a1[10] = *(_QWORD *)(a2 + 80);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
}

void sub_1A34DE954(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;
  NSObject *v4;
  NSObject *v5;

  v3 = *(std::__shared_weak_count **)(v1 + 56);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  v4 = *(NSObject **)(v1 + 40);
  if (v4)
  {
    dispatch_group_leave(v4);
    v5 = *(NSObject **)(v1 + 40);
    if (v5)
      dispatch_release(v5);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c29_ZTSNSt3__18weak_ptrI5TraceEE64c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  NSObject *v4;

  if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    v2 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v2)
      goto LABEL_4;
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 64));
  v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2)
LABEL_3:
    std::__shared_weak_count::__release_weak(v2);
LABEL_4:
  v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = *(NSObject **)(a1 + 40);
    if (v4)
      dispatch_release(v4);
  }
}

void INTTrace::getStateAsDict_sync(uint64_t a1@<X0>, uint64_t a2@<X1>, xpc_object_t *a3@<X8>)
{
  xpc_object_t v6;
  xpc_object_t v7;
  uint64_t v8;
  xpc_object_t v9;
  xpc_object_t v10;
  NSObject *v11;
  const char *v12;
  xpc_object_t v13;
  xpc_object_t v14;
  uint64_t v15;
  const char *v16;
  xpc_object_t v17;
  xpc_object_t v18;
  uint64_t v19;
  const char *v20;
  xpc_object_t v21;
  xpc_object_t v22;
  std::string *p_p;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  std::string *p_buf;
  xpc_object_t v28;
  xpc_object_t v29;
  const char *v30;
  xpc_object_t v31;
  xpc_object_t v32;
  unsigned int v33;
  std::string *v34;
  xpc_object_t v35;
  xpc_object_t v36;
  xpc_object_t v37;
  std::string *v38;
  xpc_object_t v39;
  xpc_object_t v40;
  const char *v41;
  xpc_object_t v42;
  xpc_object_t v43;
  uint64_t v44;
  const char *v45;
  xpc_object_t v46;
  xpc_object_t v47;
  const char *v48;
  xpc_object_t v49;
  xpc_object_t v50;
  const char *v51;
  xpc_object_t v52;
  xpc_object_t v53;
  std::string __p;
  std::string buf;

  *a3 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  v8 = MEMORY[0x1E0C812F8];
  if (v6)
  {
    *a3 = v6;
  }
  else
  {
    v7 = xpc_null_create();
    *a3 = v7;
    if (!v7)
    {
      v9 = xpc_null_create();
      v7 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A85902BC](v7) == v8)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  v9 = xpc_null_create();
LABEL_8:
  *a3 = v9;
LABEL_9:
  xpc_release(v7);
  v10 = *a3;
  if (MEMORY[0x1A85902BC](*a3) != v8)
  {
    v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to create state dump dictionary", (uint8_t *)&buf, 2u);
    }
    return;
  }
  if (*(_BYTE *)(a1 + 156))
    v12 = "true";
  else
    v12 = "false";
  v13 = xpc_string_create(v12);
  if (!v13)
    v13 = xpc_null_create();
  xpc_dictionary_set_value(v10, "Enabled", v13);
  v14 = xpc_null_create();
  xpc_release(v13);
  xpc_release(v14);
  v15 = *(int *)(a1 + 168);
  if (v15 > 3)
    v16 = "unknown";
  else
    v16 = off_1E4A0AFE8[v15];
  v17 = xpc_string_create(v16);
  if (!v17)
    v17 = xpc_null_create();
  xpc_dictionary_set_value(v10, "Live_Filter_Setting", v17);
  v18 = xpc_null_create();
  xpc_release(v17);
  xpc_release(v18);
  v19 = *(int *)(a1 + 152);
  if (v19 > 6)
    v20 = "Unknown";
  else
    v20 = off_1E4A0B008[v19];
  v21 = xpc_string_create(v20);
  if (!v21)
    v21 = xpc_null_create();
  xpc_dictionary_set_value(v10, "Mode", v21);
  v22 = xpc_null_create();
  xpc_release(v21);
  xpc_release(v22);
  std::to_string(&buf, *(_DWORD *)(a1 + 232));
  __p = buf;
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v24 = xpc_string_create((const char *)p_p);
  if (!v24)
    v24 = xpc_null_create();
  v25 = *a3;
  xpc_dictionary_set_value(*a3, "TraceOwnership", v24);
  v26 = xpc_null_create();
  xpc_release(v24);
  xpc_release(v26);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  INTTrace::historyAsString_sync(a1, (char *)&buf);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_buf = &buf;
  else
    p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
  v28 = xpc_string_create((const char *)p_buf);
  if (!v28)
    v28 = xpc_null_create();
  xpc_dictionary_set_value(v25, "History", v28);
  v29 = xpc_null_create();
  xpc_release(v28);
  xpc_release(v29);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    v30 = (const char *)(a1 + 184);
    if ((*(char *)(a1 + 207) & 0x80000000) == 0)
      goto LABEL_41;
  }
  else
  {
    v30 = (const char *)(a1 + 184);
    if ((*(char *)(a1 + 207) & 0x80000000) == 0)
      goto LABEL_41;
  }
  v30 = *(const char **)v30;
LABEL_41:
  v31 = xpc_string_create(v30);
  if (!v31)
    v31 = xpc_null_create();
  xpc_dictionary_set_value(v25, "File", v31);
  v32 = xpc_null_create();
  xpc_release(v31);
  xpc_release(v32);
  v33 = *(_DWORD *)(a1 + 172);
  memset(&__p, 0, sizeof(__p));
  std::to_string(&buf, v33);
  __p = buf;
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v34 = &__p;
  else
    v34 = (std::string *)__p.__r_.__value_.__r.__words[0];
  v35 = xpc_string_create((const char *)v34);
  if (!v35)
    v35 = xpc_null_create();
  v36 = *a3;
  xpc_dictionary_set_value(*a3, "FileSize", v35);
  v37 = xpc_null_create();
  xpc_release(v35);
  xpc_release(v37);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  capabilities::trace::asString();
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v38 = &buf;
  else
    v38 = (std::string *)buf.__r_.__value_.__r.__words[0];
  v39 = xpc_string_create((const char *)v38);
  if (!v39)
    v39 = xpc_null_create();
  xpc_dictionary_set_value(v36, "Enabled_During_Sleep", v39);
  v40 = xpc_null_create();
  xpc_release(v39);
  xpc_release(v40);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    v41 = (const char *)(a1 + 296);
    if ((*(char *)(a1 + 319) & 0x80000000) == 0)
      goto LABEL_57;
LABEL_79:
    v41 = *(const char **)v41;
    goto LABEL_57;
  }
  v41 = (const char *)(a1 + 296);
  if (*(char *)(a1 + 319) < 0)
    goto LABEL_79;
LABEL_57:
  v42 = xpc_string_create(v41);
  if (!v42)
    v42 = xpc_null_create();
  xpc_dictionary_set_value(v36, "File_Sleep", v42);
  v43 = xpc_null_create();
  xpc_release(v42);
  xpc_release(v43);
  v44 = *(int *)(a1 + 380);
  if (v44 > 2)
    v45 = "Unknown";
  else
    v45 = off_1E4A0B078[v44];
  v46 = xpc_string_create(v45);
  if (!v46)
    v46 = xpc_null_create();
  xpc_dictionary_set_value(v36, "Error_Handling", v46);
  v47 = xpc_null_create();
  xpc_release(v46);
  xpc_release(v47);
  if (*(_BYTE *)(a1 + 384))
    v48 = "true";
  else
    v48 = "false";
  v49 = xpc_string_create(v48);
  if (!v49)
    v49 = xpc_null_create();
  xpc_dictionary_set_value(v36, "Retain_Previous_Trace", v49);
  v50 = xpc_null_create();
  xpc_release(v49);
  xpc_release(v50);
  if (*(char *)(a2 + 23) >= 0)
    v51 = (const char *)a2;
  else
    v51 = *(const char **)a2;
  v52 = xpc_string_create(v51);
  if (!v52)
    v52 = xpc_null_create();
  xpc_dictionary_set_value(v36, (const char *)*MEMORY[0x1E0CFB928], v52);
  v53 = xpc_null_create();
  xpc_release(v52);
  xpc_release(v53);
}

void sub_1A34DF06C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  xpc_object_t *v14;

  xpc::dict::~dict(v14);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::historyAsString_sync@<X0>(uint64_t this@<X0>, char *a2@<X8>)
{
  char *v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  std::ios_base *v9;
  uint64_t v10;
  std::string *p_p;
  std::string::size_type size;
  _QWORD *v13;
  char v14;
  size_t v15;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  std::string __p;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  void *v27[2];
  __int128 v28;
  unint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  std::string v40;

  v2 = a2;
  if (!*(_DWORD *)(this + 164))
  {
    a2[23] = 8;
    strcpy(a2, "Infinite");
    return this;
  }
  v3 = this;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v29 = 0xAAAAAAAAAAAAAAAALL;
  v39 = v4;
  v38 = v4;
  v37 = v4;
  v36 = v4;
  v35 = v4;
  v34 = v4;
  v33 = v4;
  v32 = v4;
  v31 = v4;
  v28 = v4;
  *(_OWORD *)v27 = v4;
  v26 = v4;
  v25 = v4;
  v24 = v4;
  v23 = v4;
  v5 = MEMORY[0x1E0DE4FE0];
  v6 = MEMORY[0x1E0DE4FE0] + 64;
  v30 = MEMORY[0x1E0DE4FE0] + 64;
  v7 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v22 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  *(uint64_t *)((char *)&v22 + *(_QWORD *)(v22 - 24)) = v8;
  v9 = (std::ios_base *)((char *)&v22 + *(_QWORD *)(v22 - 24));
  std::ios_base::init(v9, &v23);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v22 = v5 + 24;
  v30 = v6;
  std::streambuf::basic_streambuf();
  v10 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v23 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)v27 = 0u;
  v28 = 0u;
  LODWORD(v29) = 16;
  std::to_string(&v40, *(_DWORD *)(v3 + 164));
  __p = v40;
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)p_p, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" MB", 3);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v14 = v29;
    if ((v29 & 0x10) == 0)
      goto LABEL_10;
LABEL_14:
    v16 = *((_QWORD *)&v28 + 1);
    if (*((_QWORD *)&v28 + 1) < (unint64_t)v26)
    {
      *((_QWORD *)&v28 + 1) = v26;
      v16 = v26;
    }
    v17 = (const void *)*((_QWORD *)&v25 + 1);
    v15 = v16 - *((_QWORD *)&v25 + 1);
    if ((unint64_t)(v16 - *((_QWORD *)&v25 + 1)) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_28;
    goto LABEL_17;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  v14 = v29;
  if ((v29 & 0x10) != 0)
    goto LABEL_14;
LABEL_10:
  if ((v14 & 8) == 0)
  {
    v15 = 0;
    v2[23] = 0;
    goto LABEL_24;
  }
  v17 = (const void *)v24;
  v15 = v25 - v24;
  if ((_QWORD)v25 - (_QWORD)v24 >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_28:
    std::string::__throw_length_error[abi:ne180100]();
LABEL_17:
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    v20 = (char *)operator new(v18 + 1);
    *((_QWORD *)v2 + 1) = v15;
    *((_QWORD *)v2 + 2) = v19 | 0x8000000000000000;
    *(_QWORD *)v2 = v20;
    v2 = v20;
  }
  else
  {
    v2[23] = v15;
    if (!v15)
      goto LABEL_24;
  }
  memmove(v2, v17, v15);
LABEL_24:
  v2[v15] = 0;
  v22 = *v7;
  *(uint64_t *)((char *)&v22 + *(_QWORD *)(v22 - 24)) = v7[3];
  *(_QWORD *)&v23 = v10 + 16;
  if (SBYTE7(v28) < 0)
    operator delete(v27[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A858F92C](&v30);
}

void sub_1A34DF434(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A34DF28CLL);
}

void sub_1A34DF440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  if (a14 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::dumpState_sync@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  std::ios_base *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  const char *v18;
  size_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  const char *v24;
  size_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  std::string *v29;
  std::string::size_type size;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  void **v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  const char *v40;
  size_t v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  unsigned int v51;
  std::string *p_p;
  std::string::size_type v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD *v62;
  std::string *v63;
  std::string::size_type v64;
  _QWORD *v65;
  _QWORD *v66;
  _QWORD *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  const char *v75;
  size_t v76;
  _QWORD *v77;
  _QWORD *v78;
  _QWORD *v79;
  _QWORD *v80;
  _QWORD *v81;
  _QWORD *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  size_t v86;
  uint64_t v87;
  const void *v88;
  uint64_t v89;
  uint64_t v90;
  _BYTE *v91;
  std::string __p;
  void *v94[2];
  unsigned __int8 v95;
  std::string v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  unint64_t v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  std::string v115;
  _BYTE v116[17];

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v104 = 0xAAAAAAAAAAAAAAAALL;
  v114 = v6;
  v113 = v6;
  v112 = v6;
  v111 = v6;
  v110 = v6;
  v109 = v6;
  v108 = v6;
  v107 = v6;
  v106 = v6;
  v103 = v6;
  v102 = v6;
  v101 = v6;
  v99 = v6;
  v100 = v6;
  v98 = v6;
  v7 = MEMORY[0x1E0DE4FE0];
  v8 = MEMORY[0x1E0DE4FE0] + 64;
  v105 = MEMORY[0x1E0DE4FE0] + 64;
  v9 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v97 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  *(uint64_t *)((char *)&v97 + *(_QWORD *)(v97 - 24)) = v10;
  v11 = (std::ios_base *)((char *)&v97 + *(_QWORD *)(v97 - 24));
  std::ios_base::init(v11, &v98);
  v11[1].__vftable = 0;
  v11[1].__fmtflags_ = -1;
  v97 = v7 + 24;
  v105 = v8;
  std::streambuf::basic_streambuf();
  v12 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v98 = MEMORY[0x1E0DE4FB8] + 16;
  v102 = 0u;
  v103 = 0u;
  LODWORD(v104) = 16;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v97, (uint64_t)"\n----- BB Trace Dump State -----\n", 33);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v97, (uint64_t)"Trace Enabled         : ", 24);
  *(_DWORD *)((char *)v13 + *(_QWORD *)(*v13 - 24) + 8) |= 1u;
  v14 = (_QWORD *)std::ostream::operator<<();
  v115.__r_.__value_.__s.__data_[0] = 10;
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)&v115, 1);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"Live Enabled Setting  : ", 24);
  v17 = *(int *)(a1 + 168);
  if (v17 > 3)
    v18 = "unknown";
  else
    v18 = off_1E4A0AFE8[v17];
  v19 = strlen(v18);
  v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v18, v19);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)&v115, 1);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"Mode                  : ", 24);
  v23 = *(int *)(a1 + 152);
  if (v23 > 6)
    v24 = "Unknown";
  else
    v24 = off_1E4A0B008[v23];
  v25 = strlen(v24);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v24, v25);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)&v115, 1);
  v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"Trace Ownership       : ", 24);
  std::to_string(&v115, *(_DWORD *)(a1 + 232));
  v96 = v115;
  if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v29 = &v96;
  else
    v29 = (std::string *)v96.__r_.__value_.__r.__words[0];
  if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v96.__r_.__value_.__r.__words[2]);
  else
    size = v96.__r_.__value_.__l.__size_;
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)v29, size);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)&v115, 1);
  v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"History (MB)          : ", 24);
  INTTrace::historyAsString_sync(a1, (char *)v94);
  if ((v95 & 0x80u) == 0)
    v34 = v94;
  else
    v34 = (void **)v94[0];
  if ((v95 & 0x80u) == 0)
    v35 = v95;
  else
    v35 = (uint64_t)v94[1];
  v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)v34, v35);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)&v115, 1);
  v38 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"Privacy Level         : ", 24);
  v39 = *(int *)(a1 + 160);
  if (v39 > 3)
    v40 = "Unknown";
  else
    v40 = off_1E4A0AFC8[v39];
  v41 = strlen(v40);
  v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)v40, v41);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)&v115, 1);
  v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)"Config File           : ", 24);
  v45 = *(char *)(a1 + 207);
  if (v45 >= 0)
    v46 = a1 + 184;
  else
    v46 = *(_QWORD *)(a1 + 184);
  if (v45 >= 0)
    v47 = *(unsigned __int8 *)(a1 + 207);
  else
    v47 = *(_QWORD *)(a1 + 192);
  v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, v46, v47);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v49 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)&v115, 1);
  v50 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, (uint64_t)"Max memory file count : ", 24);
  v51 = *(_DWORD *)(a1 + 176);
  if (v51)
  {
    std::to_string(&v115, v51);
    __p = v115;
  }
  else
  {
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&__p, "No limit");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v53 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v53 = __p.__r_.__value_.__l.__size_;
  v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)p_p, v53);
  v115.__r_.__value_.__s.__data_[0] = 10;
  v55 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)&v115, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)"File Size (Bytes)     : ", 24);
  v56 = (_QWORD *)std::ostream::operator<<();
  v115.__r_.__value_.__s.__data_[0] = 10;
  v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)&v115, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"Transport Read Size   : ", 24);
  v58 = (_QWORD *)std::ostream::operator<<();
  v115.__r_.__value_.__s.__data_[0] = 10;
  v59 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)&v115, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Transport Read Count  : ", 24);
  v60 = (_QWORD *)std::ostream::operator<<();
  v115.__r_.__value_.__s.__data_[0] = 10;
  v61 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)&v115, 1);
  v62 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v61, (uint64_t)"Sleep Trace Mode      : ", 24);
  capabilities::trace::asString();
  if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v63 = &v115;
  else
    v63 = (std::string *)v115.__r_.__value_.__r.__words[0];
  if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v64 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
  else
    v64 = v115.__r_.__value_.__l.__size_;
  v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v62, (uint64_t)v63, v64);
  v116[0] = 10;
  v66 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)v116, 1);
  v67 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v66, (uint64_t)"Sleep Config File     : ", 24);
  v68 = *(char *)(a1 + 319);
  if (v68 >= 0)
    v69 = a1 + 296;
  else
    v69 = *(_QWORD *)(a1 + 296);
  if (v68 >= 0)
    v70 = *(unsigned __int8 *)(a1 + 319);
  else
    v70 = *(_QWORD *)(a1 + 304);
  v71 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v67, v69, v70);
  v116[0] = 10;
  v72 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v71, (uint64_t)v116, 1);
  v73 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v72, (uint64_t)"Trace Error Handling  : ", 24);
  v74 = *(int *)(a1 + 380);
  if (v74 > 2)
    v75 = "Unknown";
  else
    v75 = off_1E4A0B078[v74];
  v76 = strlen(v75);
  v77 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)v75, v76);
  v116[0] = 10;
  v78 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)v116, 1);
  v79 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v78, (uint64_t)"Retain Previous Trace : ", 24);
  *(_DWORD *)((char *)v79 + *(_QWORD *)(*v79 - 24) + 8) |= 1u;
  v80 = (_QWORD *)std::ostream::operator<<();
  v116[0] = 10;
  v81 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v80, (uint64_t)v116, 1);
  v82 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v81, (uint64_t)"Reason                : ", 24);
  v83 = *(char *)(a2 + 23);
  if (v83 >= 0)
    v84 = a2;
  else
    v84 = *(_QWORD *)a2;
  if (v83 >= 0)
    v85 = *(unsigned __int8 *)(a2 + 23);
  else
    v85 = *(_QWORD *)(a2 + 8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v82, v84, v85);
  if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v115.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_60:
      if (((char)v95 & 0x80000000) == 0)
        goto LABEL_61;
LABEL_73:
      operator delete(v94[0]);
      if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_62;
      goto LABEL_74;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_60;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v95 < 0)
    goto LABEL_73;
LABEL_61:
  if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_62;
LABEL_74:
  operator delete(v96.__r_.__value_.__l.__data_);
LABEL_62:
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v97, (uint64_t)"\n---------------------------------\n", 35);
  if ((v104 & 0x10) != 0)
  {
    v87 = *((_QWORD *)&v103 + 1);
    if (*((_QWORD *)&v103 + 1) < (unint64_t)v101)
    {
      *((_QWORD *)&v103 + 1) = v101;
      v87 = v101;
    }
    v88 = (const void *)*((_QWORD *)&v100 + 1);
    v86 = v87 - *((_QWORD *)&v100 + 1);
    if ((unint64_t)(v87 - *((_QWORD *)&v100 + 1)) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_83;
  }
  else
  {
    if ((v104 & 8) == 0)
    {
      v86 = 0;
      a3[23] = 0;
      goto LABEL_79;
    }
    v88 = (const void *)v99;
    v86 = v100 - v99;
    if ((_QWORD)v100 - (_QWORD)v99 >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_83:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v86 >= 0x17)
  {
    v89 = (v86 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v86 | 7) != 0x17)
      v89 = v86 | 7;
    v90 = v89 + 1;
    v91 = operator new(v89 + 1);
    *((_QWORD *)a3 + 1) = v86;
    *((_QWORD *)a3 + 2) = v90 | 0x8000000000000000;
    *(_QWORD *)a3 = v91;
    a3 = v91;
    goto LABEL_78;
  }
  a3[23] = v86;
  if (v86)
LABEL_78:
    memmove(a3, v88, v86);
LABEL_79:
  a3[v86] = 0;
  v97 = *v9;
  *(uint64_t *)((char *)&v97 + *(_QWORD *)(v97 - 24)) = v9[3];
  *(_QWORD *)&v98 = v12 + 16;
  if (SBYTE7(v103) < 0)
    operator delete((void *)v102);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A858F92C](&v105);
}

void sub_1A34DFC78(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A34DF8A4);
}

void sub_1A34DFC84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a26 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a20 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a15);
  if ((a26 & 0x80000000) == 0)
  {
LABEL_4:
    std::ostringstream::~ostringstream((uint64_t)&a27);
    _Unwind_Resume(a1);
  }
LABEL_7:
  operator delete(a21);
  std::ostringstream::~ostringstream((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_1A34DFDB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::setPropEnabled_sync(uint64_t a1, NSObject **a2, char *a3, const char *a4)
{
  uint64_t v7;
  int v8;
  int v9;
  NSObject *v10;
  _BOOL4 v11;
  const char *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v16;
  NSObject *v17;
  abm::trace::TraceReader *v18;
  NSObject *v19;
  NSObject *v20;
  _DWORD v21[9];
  void *v22[2];
  char v23;
  std::string v24;
  std::string buf;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((prop::bbtrace::set(a3, a4) & 1) != 0)
  {
    memset(v21, 0, 28);
    v23 = 7;
    strcpy((char *)v22, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v7 = defaults::get((char *)v22, a3, &buf);
    if ((_DWORD)v7)
    {
      prop::file::get<std::string>((const void **)v22, (uint64_t)a3, (uint64_t)&buf, &v24);
      if (SHIBYTE(v21[6]) < 0)
        operator delete(*(void **)&v21[1]);
      *(std::string *)&v21[1] = v24;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v23 & 0x80000000) == 0)
      {
LABEL_8:
        if (!(_DWORD)v7)
          goto LABEL_9;
        goto LABEL_21;
      }
    }
    else if ((v23 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(v22[0]);
    if (!(_DWORD)v7)
    {
LABEL_9:
      if ((SHIBYTE(v21[6]) & 0x80000000) == 0)
        goto LABEL_10;
      goto LABEL_22;
    }
LABEL_21:
    v7 = util::convert<int>((const std::string *)&v21[1], v21, 0);
    if ((SHIBYTE(v21[6]) & 0x80000000) == 0)
    {
LABEL_10:
      if ((v7 & 1) != 0)
        goto LABEL_11;
LABEL_23:
      v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "Failed to get enabled property!", (uint8_t *)&buf, 2u);
      }
      return v7;
    }
LABEL_22:
    operator delete(*(void **)&v21[1]);
    if ((v7 & 1) != 0)
    {
LABEL_11:
      v8 = v21[0];
      v9 = *(unsigned __int8 *)(a1 + 156);
      v10 = *(NSObject **)(a1 + 40);
      v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v8 == v9)
      {
        if (v11)
        {
          v12 = "enabled";
          if (!v9)
            v12 = "disabled";
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
          _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I It is already %s", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        if (v11)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v9;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v8;
          _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Setting enable from %d to %d", (uint8_t *)&buf, 0xEu);
          v8 = v21[0];
        }
        *(_BYTE *)(a1 + 156) = v8 != 0;
        if (v8)
        {
          v16 = *a2;
          v20 = v16;
          if (v16)
            dispatch_retain(v16);
          INTTrace::start_sync((INTTrace *)a1, (group *)&v20);
          if (v16)
            dispatch_release(v16);
        }
        else if (*(_QWORD *)(a1 + 256))
        {
          v17 = *a2;
          v19 = v17;
          if (v17)
            dispatch_retain(v17);
          INTTrace::stop_sync((INTTrace *)a1, (group *)&v19);
          if (v17)
            dispatch_release(v17);
          v18 = *(abm::trace::TraceReader **)(a1 + 240);
          if (v18)
          {
            if (*(_DWORD *)(a1 + 168) != 3)
              abm::trace::TraceReader::clearFiles(v18);
            std::shared_ptr<TraceFileCollection>::reset[abi:ne180100]((_QWORD *)(a1 + 240));
            *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
            std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100](a1 + 240, (__int128 *)&buf);
            std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
          }
        }
      }
      return v7;
    }
    goto LABEL_23;
  }
  v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Failed to set enabled property!", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A34E012C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  NSObject *v25;

  if (v25)
  {
    dispatch_release(v25);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropLiveFilterSetting_sync(uint64_t a1, char **a2, char *a3, const char *a4)
{
  _BOOL4 v7;
  int v8;
  unsigned int v9;
  NSObject *v10;
  _BOOL8 result;
  const char *v12;
  unsigned int v13;
  NSObject *v14;
  _BOOL4 v15;
  const char *v16;
  const char *v17;
  const char *v18;
  abm::trace::TraceReader *v19;
  NSObject *v20;
  char *v21;
  abm::trace::TraceReader *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _QWORD *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  int v37;
  char *v38;
  size_t v39;
  std::string::size_type v40;
  std::string *p_dst;
  uint64_t v42;
  uint64_t v43;
  std::string *v44;
  __int128 v45;
  __int128 v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  char *v53;
  size_t v54;
  std::string::size_type v55;
  std::string *v56;
  uint64_t v57;
  uint64_t v58;
  std::string *v59;
  __int128 v60;
  __int128 v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  NSObject *v68;
  NSObject *v69;
  group v70;
  void *v71[2];
  char v72;
  std::string __dst;
  _BYTE buf[28];
  __int16 v75;
  unsigned int v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if ((prop::bbtrace::set(a3, a4) & 1) != 0)
  {
    memset(&v70.gr_passwd, 0, 24);
    v72 = 7;
    strcpy((char *)v71, "BBTrace");
    memset(buf, 0, 24);
    v7 = defaults::get((char *)v71, a3, (std::string *)buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)v71, (uint64_t)a3, (uint64_t)buf, &__dst);
      if (SHIBYTE(v70.gr_mem) < 0)
        operator delete(v70.gr_passwd);
      *(std::string *)&v70.gr_passwd = __dst;
    }
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if ((v72 & 0x80000000) == 0)
      {
LABEL_8:
        if (v7)
          goto LABEL_9;
        goto LABEL_21;
      }
    }
    else if ((v72 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(v71[0]);
    if (v7)
    {
LABEL_9:
      *(_DWORD *)buf = -1431655766;
      v8 = util::convert<int>((const std::string *)&v70.gr_passwd, buf, 0);
      LOBYTE(v7) = v8;
      if (v8)
        v9 = *(_DWORD *)buf;
      else
        v9 = 0;
      if (SHIBYTE(v70.gr_mem) < 0)
      {
LABEL_13:
        operator delete(v70.gr_passwd);
        if (!v7)
          goto LABEL_14;
        goto LABEL_23;
      }
LABEL_22:
      if (!v7)
      {
LABEL_14:
        v10 = *(NSObject **)(a1 + 40);
        result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        if (result)
        {
          *(_WORD *)buf = 0;
          v12 = "Failed to get trace live filter enable property!";
LABEL_18:
          _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, v12, buf, 2u);
          return 0;
        }
        return result;
      }
LABEL_23:
      v13 = *(_DWORD *)(a1 + 168);
      v14 = *(NSObject **)(a1 + 40);
      v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (v9 == v13)
      {
        if (v15)
        {
          if (v9 > 3)
            v16 = "unknown";
          else
            v16 = off_1E4A0AFE8[v9];
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v16;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v9;
          _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Live filter setting is already %s (%d)", buf, 0x12u);
          v9 = *(_DWORD *)(a1 + 168);
        }
        if (v9 == 3)
        {
          v19 = *(abm::trace::TraceReader **)(a1 + 240);
          if (v19)
          {
            abm::trace::TraceReader::notifyCellularLoggingPortNumber(v19);
            v20 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1A343C000, v20, OS_LOG_TYPE_DEFAULT, "#I Notifying streaming port number", buf, 2u);
            }
          }
        }
        return 1;
      }
      if (!v15)
      {
LABEL_40:
        *(_DWORD *)(a1 + 168) = v9;
        if (!*(_BYTE *)(a1 + 156))
          return 1;
        v21 = *a2;
        v70.gr_name = v21;
        if (v21)
          dispatch_retain((dispatch_object_t)v21);
        INTTrace::stop_sync((INTTrace *)a1, &v70);
        if (v21)
          dispatch_release((dispatch_object_t)v21);
        v23 = (_QWORD *)(a1 + 240);
        v22 = *(abm::trace::TraceReader **)(a1 + 240);
        if (v22)
        {
          abm::trace::TraceReader::clearFiles(v22);
          v24 = *(std::__shared_weak_count **)(a1 + 248);
          *(_QWORD *)(a1 + 240) = 0;
          *(_QWORD *)(a1 + 248) = 0;
          if (v24)
          {
            p_shared_owners = (unint64_t *)&v24->__shared_owners_;
            do
              v26 = __ldaxr(p_shared_owners);
            while (__stlxr(v26 - 1, p_shared_owners));
            if (!v26)
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }
            v27 = *(std::__shared_weak_count **)(a1 + 248);
            *v23 = 0;
            *(_QWORD *)(a1 + 248) = 0;
            if (v27)
            {
              v28 = (unint64_t *)&v27->__shared_owners_;
              do
                v29 = __ldaxr(v28);
              while (__stlxr(v29 - 1, v28));
              if (!v29)
              {
                ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                std::__shared_weak_count::__release_weak(v27);
              }
            }
          }
          else
          {
            *v23 = 0;
            *(_QWORD *)(a1 + 248) = 0;
          }
        }
        v30 = (_QWORD *)(a1 + 328);
        if (*(_QWORD *)(a1 + 328))
        {
          v31 = *(std::__shared_weak_count **)(a1 + 336);
          *v30 = 0;
          *(_QWORD *)(a1 + 336) = 0;
          if (v31)
          {
            v32 = (unint64_t *)&v31->__shared_owners_;
            do
              v33 = __ldaxr(v32);
            while (__stlxr(v33 - 1, v32));
            if (!v33)
            {
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
            }
          }
        }
        if (*(_QWORD *)(a1 + 344))
        {
          v34 = *(std::__shared_weak_count **)(a1 + 352);
          *(_QWORD *)(a1 + 344) = 0;
          *(_QWORD *)(a1 + 352) = 0;
          if (v34)
          {
            v35 = (unint64_t *)&v34->__shared_owners_;
            do
              v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
          }
        }
        v37 = *(_DWORD *)(a1 + 168);
        if ((v37 - 2) >= 2)
        {
          if (v37 == 1)
          {
            std::string::basic_string[abi:ne180100]<0>(&__dst, abm::trace::kScratchFolder[0]);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("BBTrace.scratch.filtered/", &__dst, (std::string *)buf);
            abm::trace::TraceInfo::create();
          }
          else
          {
            if (v37)
            {
LABEL_117:
              v68 = *a2;
              v69 = v68;
              if (v68)
                dispatch_retain(v68);
              INTTrace::start_sync((INTTrace *)a1, (group *)&v69);
              if (v68)
                dispatch_release(v68);
              return 1;
            }
            std::string::basic_string[abi:ne180100]<0>(&__dst, abm::trace::kScratchFolder[0]);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("BBTrace.scratch/", &__dst, (std::string *)buf);
            abm::trace::TraceInfo::create();
          }
          std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100](a1 + 328, (__int128 *)v71);
          std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)v71);
LABEL_113:
          if ((buf[23] & 0x80000000) != 0)
            operator delete(*(void **)buf);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__dst.__r_.__value_.__l.__data_);
          goto LABEL_117;
        }
        v38 = abm::trace::kScratchFolder[0];
        v39 = strlen(abm::trace::kScratchFolder[0]);
        if (v39 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v40 = v39;
        if (v39 >= 0x17)
        {
          v42 = (v39 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v39 | 7) != 0x17)
            v42 = v39 | 7;
          v43 = v42 + 1;
          p_dst = (std::string *)operator new(v42 + 1);
          __dst.__r_.__value_.__l.__size_ = v40;
          __dst.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v39;
          p_dst = &__dst;
          if (!v39)
            goto LABEL_83;
        }
        memmove(p_dst, v38, v40);
LABEL_83:
        p_dst->__r_.__value_.__s.__data_[v40] = 0;
        v44 = std::string::append(&__dst, "BBTrace.scratch/", 0x10uLL);
        v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
        *(_QWORD *)&buf[16] = *((_QWORD *)&v44->__r_.__value_.__l + 2);
        *(_OWORD *)buf = v45;
        v44->__r_.__value_.__l.__size_ = 0;
        v44->__r_.__value_.__r.__words[2] = 0;
        v44->__r_.__value_.__r.__words[0] = 0;
        abm::trace::TraceInfo::create();
        v46 = *(_OWORD *)v71;
        v71[0] = 0;
        v71[1] = 0;
        v47 = *(std::__shared_weak_count **)(a1 + 336);
        *(_OWORD *)v30 = v46;
        if (v47)
        {
          v48 = (unint64_t *)&v47->__shared_owners_;
          do
            v49 = __ldaxr(v48);
          while (__stlxr(v49 - 1, v48));
          if (!v49)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }
        v50 = (std::__shared_weak_count *)v71[1];
        if (v71[1])
        {
          v51 = (unint64_t *)((char *)v71[1] + 8);
          do
            v52 = __ldaxr(v51);
          while (__stlxr(v52 - 1, v51));
          if (!v52)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }
        if ((buf[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)buf);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_95:
            v53 = abm::trace::kScratchFolder[0];
            v54 = strlen(abm::trace::kScratchFolder[0]);
            if (v54 <= 0x7FFFFFFFFFFFFFF7)
              goto LABEL_96;
            goto LABEL_125;
          }
        }
        else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_95;
        }
        operator delete(__dst.__r_.__value_.__l.__data_);
        v53 = abm::trace::kScratchFolder[0];
        v54 = strlen(abm::trace::kScratchFolder[0]);
        if (v54 <= 0x7FFFFFFFFFFFFFF7)
        {
LABEL_96:
          v55 = v54;
          if (v54 >= 0x17)
          {
            v57 = (v54 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v54 | 7) != 0x17)
              v57 = v54 | 7;
            v58 = v57 + 1;
            v56 = (std::string *)operator new(v57 + 1);
            __dst.__r_.__value_.__l.__size_ = v55;
            __dst.__r_.__value_.__r.__words[2] = v58 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
          }
          else
          {
            *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v54;
            v56 = &__dst;
            if (!v54)
            {
LABEL_103:
              v56->__r_.__value_.__s.__data_[v55] = 0;
              v59 = std::string::append(&__dst, "BBTrace.scratch.filtered/", 0x19uLL);
              v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
              *(_QWORD *)&buf[16] = *((_QWORD *)&v59->__r_.__value_.__l + 2);
              *(_OWORD *)buf = v60;
              v59->__r_.__value_.__l.__size_ = 0;
              v59->__r_.__value_.__r.__words[2] = 0;
              v59->__r_.__value_.__r.__words[0] = 0;
              abm::trace::TraceInfo::create();
              v61 = *(_OWORD *)v71;
              v71[0] = 0;
              v71[1] = 0;
              v62 = *(std::__shared_weak_count **)(a1 + 352);
              *(_OWORD *)(a1 + 344) = v61;
              if (v62)
              {
                v63 = (unint64_t *)&v62->__shared_owners_;
                do
                  v64 = __ldaxr(v63);
                while (__stlxr(v64 - 1, v63));
                if (!v64)
                {
                  ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
                  std::__shared_weak_count::__release_weak(v62);
                }
              }
              v65 = (std::__shared_weak_count *)v71[1];
              if (v71[1])
              {
                v66 = (unint64_t *)((char *)v71[1] + 8);
                do
                  v67 = __ldaxr(v66);
                while (__stlxr(v67 - 1, v66));
                if (!v67)
                {
                  ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
                  std::__shared_weak_count::__release_weak(v65);
                }
              }
              goto LABEL_113;
            }
          }
          memmove(v56, v53, v55);
          goto LABEL_103;
        }
LABEL_125:
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v13 > 3)
      {
        v17 = "unknown";
        if (v9 > 3)
          goto LABEL_30;
      }
      else
      {
        v17 = off_1E4A0AFE8[v13];
        if (v9 > 3)
        {
LABEL_30:
          v18 = "unknown";
LABEL_39:
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v17;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v13;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v18;
          v75 = 1024;
          v76 = v9;
          _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Setting trace live filter setting from %s (%d) to %s (%d)", buf, 0x22u);
          goto LABEL_40;
        }
      }
      v18 = off_1E4A0AFE8[v9];
      goto LABEL_39;
    }
LABEL_21:
    v9 = 0;
    if (SHIBYTE(v70.gr_mem) < 0)
      goto LABEL_13;
    goto LABEL_22;
  }
  v10 = *(NSObject **)(a1 + 40);
  result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)buf = 0;
    v12 = "Failed to set trace live filter enable property!";
    goto LABEL_18;
  }
  return result;
}

void sub_1A34E0A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a29 < 0)
  {
    operator delete(a24);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropPrivacyLevel_sync(uint64_t a1, NSObject **a2, char *a3, const std::string *a4)
{
  char *v4;
  int data;
  _BOOL4 v9;
  int v10;
  char v11;
  NSObject *v12;
  _BOOL8 result;
  NSObject *v14;
  const char *v15;
  int v16;
  NSObject *v17;
  _BOOL4 v18;
  NSObject *v19;
  uint32_t v20;
  NSObject *v21;
  char v22;
  NSObject *v23;
  std::string v24;
  dispatch_object_t v25;
  std::string __p;
  void *v27[2];
  char v28;
  std::string v29;
  std::string buf;
  uint64_t v31;

  v4 = (char *)a4;
  v31 = *MEMORY[0x1E0C80C00];
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if ((util::convert<int>(a4, &buf, 0) & 1) == 0)
  {
    data = -1;
    goto LABEL_16;
  }
  data = (int)buf.__r_.__value_.__l.__data_;
  if (LODWORD(buf.__r_.__value_.__l.__data_) >= 4)
  {
LABEL_16:
    v12 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
    v15 = "Invalid input privacy level value: %d ";
    v19 = v12;
    v20 = 8;
LABEL_32:
    _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&buf, v20);
    return 0;
  }
  if ((prop::bbtrace::set(a3, v4) & 1) == 0)
  {
    v14 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v15 = "Failed to set privacy level!";
LABEL_30:
    v19 = v14;
    v20 = 2;
    goto LABEL_32;
  }
  memset(&__p, 0, sizeof(__p));
  v28 = 7;
  strcpy((char *)v27, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v9 = defaults::get((char *)v27, a3, &buf);
  if (v9)
  {
    prop::file::get<std::string>((const void **)v27, (uint64_t)a3, (uint64_t)&buf, &v29);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v29;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_10:
      if (v9)
        goto LABEL_11;
LABEL_22:
      v11 = 0;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_10;
  }
  operator delete(v27[0]);
  if (!v9)
    goto LABEL_22;
LABEL_11:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v10 = util::convert<int>(&__p, &buf, 0);
  v11 = v10;
  if (v10)
    data = (int)buf.__r_.__value_.__l.__data_;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_23:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_24:
  if ((v11 & 1) == 0)
  {
    v14 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v15 = "Failed to get privacy level!";
    goto LABEL_30;
  }
  v16 = *(_DWORD *)(a1 + 160);
  v17 = *(NSObject **)(a1 + 40);
  v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (data == v16)
  {
    if (v18)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
      _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, "#I It is setting same privacy level: %d", (uint8_t *)&buf, 8u);
    }
    return 1;
  }
  if (v18)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = data;
    _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, "#I Setting privacy level from %d to %d", (uint8_t *)&buf, 0xEu);
  }
  *(_DWORD *)(a1 + 160) = data;
  v21 = *a2;
  v25 = v21;
  if (v21)
    dispatch_retain(v21);
  if (*(char *)(a1 + 207) < 0)
    std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(a1 + 184), *(_QWORD *)(a1 + 192));
  else
    v24 = *(std::string *)(a1 + 184);
  v22 = INTTrace::sendConfig_sync(a1, &v25, (const std::string::value_type *)&v24, 0, 0, 0);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (v21)
    dispatch_release(v21);
  if ((v22 & 1) != 0)
    return 1;
  v23 = *(NSObject **)(a1 + 40);
  result = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  if (result)
  {
    if (v4[23] < 0)
      v4 = *(char **)v4;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    v15 = "Failed to send trace config %s";
    v19 = v23;
    v20 = 12;
    goto LABEL_32;
  }
  return result;
}

void sub_1A34E0ED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  NSObject *v28;

  if (v28)
  {
    dispatch_release(v28);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropHistory_sync(uint64_t a1, int a2, char *a3, const std::string *a4)
{
  int v7;
  int v8;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  _BOOL4 v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v19;
  int v20;
  NSObject *v21;
  _BOOL4 v22;
  abm::trace::TraceReader *v23;
  int v24;
  int v25;
  std::string __p;
  void *v27[2];
  char v28;
  std::string v29;
  std::string buf;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  util::convert<int>(a4, &v25, 0);
  v7 = v25;
  if (v25)
  {
    v8 = *(_DWORD *)(a1 + 172) >> 20;
    if (v25 > 0x10000 || v25 < v8)
    {
      v10 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        return 0;
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v7;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v8;
      v11 = "Invalid input history size - %d MB (for trace file size - %d MB)";
      v12 = v10;
      v13 = 14;
LABEL_34:
      _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, v13);
      return 0;
    }
  }
  if ((prop::bbtrace::set(a3, (const char *)a4) & 1) == 0)
  {
    v17 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v11 = "Failed to set history property!";
    v12 = v17;
    v13 = 2;
    goto LABEL_34;
  }
  v24 = 0;
  memset(&__p, 0, sizeof(__p));
  v28 = 7;
  strcpy((char *)v27, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v14 = defaults::get((char *)v27, a3, &buf);
  if (v14)
  {
    prop::file::get<std::string>((const void **)v27, (uint64_t)a3, (uint64_t)&buf, &v29);
    __p = v29;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_14:
      if (v14)
        goto LABEL_15;
      goto LABEL_24;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v27[0]);
  if (v14)
  {
LABEL_15:
    v15 = util::convert<int>(&__p, &v24, 0);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_16;
    goto LABEL_25;
  }
LABEL_24:
  v15 = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_16:
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v15 & 1) == 0)
      goto LABEL_17;
    goto LABEL_26;
  }
LABEL_25:
  if ((v15 & 1) == 0)
  {
LABEL_17:
    v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v16, OS_LOG_TYPE_ERROR, "Failed to get history property!", (uint8_t *)&buf, 2u);
    }
    return v15;
  }
LABEL_26:
  v19 = v24;
  v20 = *(_DWORD *)(a1 + 164);
  v21 = *(NSObject **)(a1 + 40);
  v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (v19 == v20)
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v19;
      _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I It is setting same history size: %d", (uint8_t *)&buf, 8u);
    }
  }
  else
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v20;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v19;
      _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I Setting history from %d MB to %d MB", (uint8_t *)&buf, 0xEu);
      v19 = v24;
    }
    *(_DWORD *)(a1 + 164) = v19;
    v23 = *(abm::trace::TraceReader **)(a1 + 240);
    if (v23)
      abm::trace::TraceReader::updateHistorySize(v23);
  }
  return v15;
}

void sub_1A34E1294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropTraceOwnership_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  NSObject *v5;
  _BOOL8 result;
  const char *v7;
  _BOOL4 v9;
  int data;
  int v11;
  char v12;
  int v13;
  NSObject *v14;
  _BOOL4 v15;
  std::string v16;
  void *__p[2];
  char v18;
  std::string v19;
  std::string buf;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 156))
  {
    v5 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v7 = "Setting trace ownership, enabled must be set to false";
LABEL_27:
    _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&buf, 2u);
    return 0;
  }
  if ((prop::bbtrace::set(a3, a4) & 1) == 0)
  {
    v5 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v7 = "Failed to set trace ownership property!";
    goto LABEL_27;
  }
  memset(&v16, 0, sizeof(v16));
  v18 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v9 = defaults::get((char *)__p, a3, &buf);
  if (v9)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v19);
    v16 = v19;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v18 & 0x80000000) == 0)
    {
LABEL_9:
      data = -1431655766;
      if (v9)
        goto LABEL_10;
LABEL_19:
      v12 = 0;
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_24;
      goto LABEL_20;
    }
  }
  else if ((v18 & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(__p[0]);
  data = -1431655766;
  if (!v9)
    goto LABEL_19;
LABEL_10:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v11 = util::convert<int>(&v16, &buf, 0);
  v12 = v11;
  if (v11)
    data = (int)buf.__r_.__value_.__l.__data_;
  else
    data = -1431655766;
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_24:
    operator delete(v16.__r_.__value_.__l.__data_);
    if ((v12 & 1) == 0)
      goto LABEL_25;
    goto LABEL_21;
  }
LABEL_20:
  if ((v12 & 1) == 0)
  {
LABEL_25:
    v5 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v7 = "Failed to get trace ownership";
    goto LABEL_27;
  }
LABEL_21:
  v13 = *(_DWORD *)(a1 + 232);
  v14 = *(NSObject **)(a1 + 40);
  v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (data == v13)
  {
    if (v15)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Trace ownership is already set to %d", (uint8_t *)&buf, 8u);
    }
  }
  else
  {
    if (v15)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v13;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = data;
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Setting trace ownership from %d to %d", (uint8_t *)&buf, 0xEu);
    }
    *(_DWORD *)(a1 + 232) = data;
  }
  return 1;
}

void sub_1A34E1594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropTraceMode_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const std::string *a4)
{
  NSObject *v7;
  unsigned int v8;
  unsigned int data;
  unsigned int *v10;
  unsigned int v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  const char *v20;
  _BOOL4 v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  unsigned int v27;
  const char *v28;
  const char *v29;
  std::string __p;
  void *v31[2];
  char v32;
  std::string v33;
  std::string buf;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  v8 = -1431655766;
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(a4, &buf, 0))
  {
    data = buf.__r_.__value_.__l.__data_;
    v10 = (unsigned int *)(a1 + 152);
    v11 = *(_DWORD *)(a1 + 152);
    if (v11 == LODWORD(buf.__r_.__value_.__l.__data_))
    {
      v8 = buf.__r_.__value_.__l.__data_;
      goto LABEL_7;
    }
    if (LODWORD(buf.__r_.__value_.__l.__data_) == 4)
    {
      if (*(_BYTE *)(a1 + 156))
      {
        v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          if (v11 > 6)
            v15 = "Unknown";
          else
            v15 = off_1E4A0B008[v11];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"Passive With Logging Configuration";
          goto LABEL_70;
        }
        goto LABEL_47;
      }
      if (*(_DWORD *)(a1 + 232))
        goto LABEL_30;
      v19 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_47;
      if (v11 > 6)
        v28 = "Unknown";
      else
        v28 = off_1E4A0B008[v11];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"Passive With Logging Configuration";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      v35 = 0;
      v29 = "Mode transitioning %s -> %s, trace channel owner (%d) not set properly";
LABEL_76:
      _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&buf, 0x1Cu);
      v17 = 0;
      if (!v7)
        return v17;
      goto LABEL_48;
    }
  }
  else
  {
    v10 = (unsigned int *)(a1 + 152);
    v11 = *(_DWORD *)(a1 + 152);
    if (v11 == -1431655766)
    {
LABEL_7:
      v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        if (v8 > 6)
          v13 = "Unknown";
        else
          v13 = off_1E4A0B008[v8];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
        _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Mode is already set to %s", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_23;
    }
    data = -1431655766;
  }
  if (v11 == 4)
  {
    if (*(_BYTE *)(a1 + 156))
    {
      v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        if (data > 6)
          v16 = "Unknown";
        else
          v16 = off_1E4A0B040[data];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"Passive With Logging Configuration";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v16;
LABEL_70:
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "Mode transitioning %s -> %s, enabled must be set to false", (uint8_t *)&buf, 0x16u);
        v17 = 0;
        if (!v7)
          return v17;
        goto LABEL_48;
      }
      goto LABEL_47;
    }
    v18 = *(_DWORD *)(a1 + 232);
    if (v18)
    {
      v19 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_47;
      if (data > 6)
        v20 = "Unknown";
      else
        v20 = off_1E4A0B040[data];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"Passive With Logging Configuration";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v20;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      v35 = v18;
      v29 = "Mode transitioning %s -> %s and trace transport owner can't be %d";
      goto LABEL_76;
    }
  }
LABEL_30:
  if ((prop::bbtrace::set(a3, (const char *)a4) & 1) == 0)
  {
    v25 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] < 0)
        a3 = *(char **)a3;
      if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0)
        a4 = (const std::string *)a4->__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a4;
      _os_log_error_impl(&dword_1A343C000, v25, OS_LOG_TYPE_ERROR, "Failed to set %s property to %s", (uint8_t *)&buf, 0x16u);
      v17 = 0;
      if (v7)
        goto LABEL_48;
      return v17;
    }
    goto LABEL_47;
  }
  memset(&__p, 0, sizeof(__p));
  v32 = 7;
  strcpy((char *)v31, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v21 = defaults::get((char *)v31, a3, &buf);
  if (v21)
  {
    prop::file::get<std::string>((const void **)v31, (uint64_t)a3, (uint64_t)&buf, &v33);
    __p = v33;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v32 & 0x80000000) == 0)
    {
LABEL_35:
      if (v21)
        goto LABEL_36;
LABEL_52:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_40;
      goto LABEL_53;
    }
  }
  else if ((v32 & 0x80000000) == 0)
  {
    goto LABEL_35;
  }
  operator delete(v31[0]);
  if (!v21)
    goto LABEL_52;
LABEL_36:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v22 = util::convert<int>(&__p, &buf, 0);
  LOBYTE(v21) = v22;
  if (v22)
    v8 = buf.__r_.__value_.__l.__data_;
  else
    v8 = -1431655766;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_40:
    operator delete(__p.__r_.__value_.__l.__data_);
    v23 = *(NSObject **)(a1 + 40);
    v24 = v23;
    if (!v21)
      goto LABEL_41;
LABEL_54:
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *v10;
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v27;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v8;
      _os_log_impl(&dword_1A343C000, v23, OS_LOG_TYPE_DEFAULT, "#I Setting trace transport mode from %d to %d", (uint8_t *)&buf, 0xEu);
    }
    *v10 = v8;
LABEL_23:
    v17 = 1;
    if (!v7)
      return v17;
    goto LABEL_48;
  }
LABEL_53:
  v23 = *(NSObject **)(a1 + 40);
  v24 = v23;
  if (v21)
    goto LABEL_54;
LABEL_41:
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    if (a3[23] < 0)
      a3 = *(char **)a3;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
    _os_log_error_impl(&dword_1A343C000, v23, OS_LOG_TYPE_ERROR, "Failed to get %s property", (uint8_t *)&buf, 0xCu);
    v17 = 0;
    if (v7)
      goto LABEL_48;
    return v17;
  }
LABEL_47:
  v17 = 0;
  if (v7)
  {
LABEL_48:
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v17;
}

void sub_1A34E1B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  NSObject *v30;

  if (a14 < 0)
    operator delete(__p);
  if (v30)
  {
    dispatch_group_leave(v30);
    dispatch_release(v30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropConfig_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  NSObject *v8;
  _BOOL4 v9;
  BOOL v10;
  std::string *v11;
  const char *v12;
  std::string *p_p;
  int v14;
  NSObject *v15;
  _BOOL4 v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  char v21;
  NSObject *v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  std::string *v27;
  size_t size;
  std::string *v30;
  std::string v31;
  dispatch_object_t v32;
  std::string __p;
  void *v34[2];
  char v35;
  std::string v36;
  std::string buf;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v8);
  }
  if ((prop::bbtrace::set(a3, a4) & 1) != 0)
  {
    __p.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    __p.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
    __p.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
    v35 = 7;
    strcpy((char *)v34, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v9 = defaults::get((char *)v34, a3, &buf);
    v10 = v9;
    if (v9)
    {
      prop::file::get<std::string>((const void **)v34, (uint64_t)a3, (uint64_t)&buf, &v36);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      __p = v36;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v35 & 0x80000000) == 0)
      {
LABEL_10:
        if (v10)
          goto LABEL_11;
        goto LABEL_29;
      }
    }
    else if ((v35 & 0x80000000) == 0)
    {
      goto LABEL_10;
    }
    operator delete(v34[0]);
    if (v10)
    {
LABEL_11:
      v11 = (std::string *)(a1 + 184);
      if (*(char *)(a1 + 207) >= 0)
        v12 = (const char *)(a1 + 184);
      else
        v12 = *(const char **)(a1 + 184);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      v14 = strcasecmp(v12, (const char *)p_p);
      v15 = *(NSObject **)(a1 + 40);
      v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      if (!v14)
      {
        if (v16)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
          _os_log_impl(&dword_1A343C000, v15, OS_LOG_TYPE_DEFAULT, "#I The config (%s) is already set!", (uint8_t *)&buf, 0xCu);
        }
LABEL_59:
        v19 = 1;
LABEL_60:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        goto LABEL_62;
      }
      if (v16)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
        _os_log_impl(&dword_1A343C000, v15, OS_LOG_TYPE_DEFAULT, "#I Setting trace config from %s to %s", (uint8_t *)&buf, 0x16u);
      }
      v17 = *a2;
      v32 = v17;
      if (v17)
        dispatch_retain(v17);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v31, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      else
        v31 = __p;
      v21 = INTTrace::sendConfig_sync(a1, &v32, (const std::string::value_type *)&v31, 0, 0, 0);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
      if (v17)
        dispatch_release(v17);
      if ((v21 & 1) != 0)
      {
        if (v11 != &__p)
        {
          if (*(char *)(a1 + 207) < 0)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v27 = &__p;
            else
              v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            else
              size = __p.__r_.__value_.__l.__size_;
            std::string::__assign_no_alias<false>((void **)(a1 + 184), v27, size);
          }
          else
          {
            if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
            {
              *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *(_QWORD *)(a1 + 200) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
              v19 = 1;
              goto LABEL_62;
            }
            std::string::__assign_no_alias<true>((_QWORD *)(a1 + 184), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
        }
        goto LABEL_59;
      }
      v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v30 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
        _os_log_error_impl(&dword_1A343C000, v22, OS_LOG_TYPE_ERROR, "Failed to send trace config %s", (uint8_t *)&buf, 0xCu);
      }
      if ((prop::bbtrace::set(a3, (const char *)(a1 + 184)) & 1) == 0)
      {
        v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          if (*(char *)(a1 + 207) < 0)
            v11 = (std::string *)v11->__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
          v24 = "Failed to reset trace config to %s";
          v25 = v23;
          v26 = 12;
          goto LABEL_57;
        }
      }
      goto LABEL_30;
    }
LABEL_29:
    v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v24 = "Failed to get trace config";
      v25 = v20;
      v26 = 2;
LABEL_57:
      _os_log_error_impl(&dword_1A343C000, v25, OS_LOG_TYPE_ERROR, v24, (uint8_t *)&buf, v26);
      v19 = 0;
      goto LABEL_60;
    }
LABEL_30:
    v19 = 0;
    goto LABEL_60;
  }
  v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v18, OS_LOG_TYPE_ERROR, "Failed to set trace config", (uint8_t *)&buf, 2u);
  }
  v19 = 0;
LABEL_62:
  if (v8)
  {
    dispatch_group_leave(v8);
    dispatch_release(v8);
  }
  return v19;
}

void sub_1A34E2094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  NSObject *v37;
  NSObject *v38;

  if (v38)
    dispatch_release(v38);
  if (a21 < 0)
    operator delete(__p);
  if (v37)
  {
    dispatch_group_leave(v37);
    dispatch_release(v37);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A34E211C()
{
  uint64_t v0;

  if (!v0)
    JUMPOUT(0x1A34E2114);
  JUMPOUT(0x1A34E2104);
}

uint64_t INTTrace::setPropMaxMemoryFileCount_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  NSObject *v7;
  _BOOL4 v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  NSObject *v13;
  _BOOL4 v14;
  NSObject *v15;
  abm::trace::TraceReader *v16;
  int v18;
  std::string v19;
  void *__p[2];
  char v21;
  std::string v22;
  std::string buf;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if ((prop::bbtrace::set(a3, a4) & 1) != 0)
  {
    v18 = 0;
    memset(&v19, 0, sizeof(v19));
    v21 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v8 = defaults::get((char *)__p, a3, &buf);
    if (v8)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v22);
      v19 = v22;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v21 & 0x80000000) == 0)
      {
LABEL_8:
        if (v8)
          goto LABEL_9;
        goto LABEL_16;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(__p[0]);
    if (v8)
    {
LABEL_9:
      v9 = util::convert<unsigned int>(&v19, &v18, 0);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      {
LABEL_21:
        operator delete(v19.__r_.__value_.__l.__data_);
        if ((v9 & 1) == 0)
        {
LABEL_22:
          v15 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl(&dword_1A343C000, v15, OS_LOG_TYPE_ERROR, "Failed to get max memory file count property!", (uint8_t *)&buf, 2u);
          }
          goto LABEL_28;
        }
        goto LABEL_18;
      }
LABEL_17:
      if ((v9 & 1) == 0)
        goto LABEL_22;
LABEL_18:
      v11 = v18;
      v12 = *(_DWORD *)(a1 + 176);
      v13 = *(NSObject **)(a1 + 40);
      v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v11 == v12)
      {
        if (v14)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11;
          _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I Max memory file count is already set to %u", (uint8_t *)&buf, 8u);
        }
      }
      else
      {
        if (v14)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v12;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v11;
          _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I Setting max memory file count from %u to %u", (uint8_t *)&buf, 0xEu);
          v11 = v18;
        }
        *(_DWORD *)(a1 + 176) = v11;
        v16 = *(abm::trace::TraceReader **)(a1 + 240);
        if (v16)
          abm::trace::TraceReader::updateMaxMemoryFileCount(v16);
      }
      goto LABEL_28;
    }
LABEL_16:
    v9 = 0;
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_21;
    goto LABEL_17;
  }
  v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Failed to set max memory file count property!", (uint8_t *)&buf, 2u);
  }
  v9 = 0;
LABEL_28:
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v9;
}

void sub_1A34E23F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  NSObject *v23;

  if (v23)
  {
    dispatch_group_leave(v23);
    dispatch_release(v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropFileSize_sync(uint64_t a1, int a2, char *a3, const std::string *a4)
{
  int v7;
  int v8;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  _BOOL4 v14;
  uint64_t v15;
  unsigned int v16;
  NSObject *v17;
  NSObject *v18;
  unsigned int v20;
  NSObject *v21;
  _BOOL4 v22;
  abm::trace::TraceReader *v23;
  unsigned int v24;
  int v25;
  std::string __p;
  void *v27[2];
  char v28;
  std::string v29;
  std::string buf;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  util::convert<int>(a4, &v25, 0);
  v7 = *(_DWORD *)(a1 + 164);
  if (v7)
  {
    v8 = v25 / 0x100000;
    if (!v25 || v7 < v8)
    {
      v10 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        return 0;
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v8;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v7;
      v11 = "Invalid input trace file size - %d MB (for history %d MB)";
      v12 = v10;
      v13 = 14;
LABEL_40:
      _os_log_error_impl(&dword_1A343C000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, v13);
      return 0;
    }
  }
  if ((prop::bbtrace::set(a3, (const char *)a4) & 1) == 0)
  {
    v18 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v11 = "Failed to set file size property!";
    v12 = v18;
    v13 = 2;
    goto LABEL_40;
  }
  v24 = 0;
  memset(&__p, 0, sizeof(__p));
  v28 = 7;
  strcpy((char *)v27, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v14 = defaults::get((char *)v27, a3, &buf);
  if (v14)
  {
    prop::file::get<std::string>((const void **)v27, (uint64_t)a3, (uint64_t)&buf, &v29);
    __p = v29;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_14:
      if (v14)
        goto LABEL_15;
      goto LABEL_27;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v27[0]);
  if (v14)
  {
LABEL_15:
    LODWORD(v15) = util::convert<unsigned int>(&__p, &v24, 0);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_16;
LABEL_28:
    v16 = v24;
    if (v24)
      v15 = v15;
    else
      v15 = 0;
    if ((v15 & 1) == 0)
      goto LABEL_20;
    goto LABEL_32;
  }
LABEL_27:
  LODWORD(v15) = 0;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_28;
LABEL_16:
  operator delete(__p.__r_.__value_.__l.__data_);
  v16 = v24;
  if (v24)
    v15 = v15;
  else
    v15 = 0;
  if ((v15 & 1) == 0)
  {
LABEL_20:
    v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, "Failed to get file size property!", (uint8_t *)&buf, 2u);
    }
    return v15;
  }
LABEL_32:
  v20 = *(_DWORD *)(a1 + 172);
  v21 = *(NSObject **)(a1 + 40);
  v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (v16 == v20)
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16;
      _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I It is setting file size: %u", (uint8_t *)&buf, 8u);
    }
  }
  else
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v20 >> 10;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v16 >> 10;
      _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I Changing file size from %d KB to %d KB", (uint8_t *)&buf, 0xEu);
      v16 = v24;
    }
    *(_DWORD *)(a1 + 172) = v16;
    v23 = *(abm::trace::TraceReader **)(a1 + 240);
    if (v23)
      abm::trace::TraceReader::updateFileSize(v23);
  }
  return v15;
}

void sub_1A34E279C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropTransportReadSize_sync(uint64_t a1, NSObject **a2, char *a3, const char *a4)
{
  _BOOL4 v7;
  uint64_t v8;
  NSObject *v9;
  unsigned int v10;
  unsigned int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v16;
  NSObject *v17;
  _DWORD v18[9];
  void *__p[2];
  char v20;
  std::string v21;
  std::string buf;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (prop::bbtrace::set(a3, a4))
  {
    memset(v18, 0, 28);
    v20 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v7 = defaults::get((char *)__p, a3, &buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v21);
      *(std::string *)&v18[1] = v21;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v20 & 0x80000000) == 0)
      {
LABEL_6:
        if (v7)
          goto LABEL_7;
        goto LABEL_14;
      }
    }
    else if ((v20 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(__p[0]);
    if (v7)
    {
LABEL_7:
      v8 = util::convert<unsigned int>((const std::string *)&v18[1], v18, 0);
      if (SHIBYTE(v18[6]) < 0)
      {
LABEL_17:
        operator delete(*(void **)&v18[1]);
        if (!(_DWORD)v8)
          return v8;
        goto LABEL_18;
      }
LABEL_15:
      if (!(_DWORD)v8)
        return v8;
LABEL_18:
      v10 = v18[0];
      v11 = *(_DWORD *)(a1 + 276);
      if (v18[0] != v11)
      {
        v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11 >> 10;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v10 >> 10;
          _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Updating trace transport read-size from %u KB to %u KB", (uint8_t *)&buf, 0xEu);
          v10 = v18[0];
        }
        *(_DWORD *)(a1 + 276) = v10;
        if (*(_BYTE *)(a1 + 156))
        {
          v13 = *a2;
          v17 = v13;
          if (v13)
            dispatch_retain(v13);
          INTTrace::stop_sync((INTTrace *)a1, (group *)&v17);
          if (v13)
            dispatch_release(v13);
          v14 = *a2;
          v16 = v14;
          if (v14)
            dispatch_retain(v14);
          INTTrace::start_sync((INTTrace *)a1, (group *)&v16);
          if (v14)
            dispatch_release(v14);
        }
      }
      return v8;
    }
LABEL_14:
    v8 = 0;
    if (SHIBYTE(v18[6]) < 0)
      goto LABEL_17;
    goto LABEL_15;
  }
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Failed to set trace transport read-size", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A34E2A70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  NSObject *v25;

  if (v25)
  {
    dispatch_release(v25);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropTransportReadCount_sync(uint64_t a1, NSObject **a2, char *a3, const char *a4)
{
  _BOOL4 v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v16;
  NSObject *v17;
  _DWORD v18[9];
  void *__p[2];
  char v20;
  std::string v21;
  std::string buf;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (prop::bbtrace::set(a3, a4))
  {
    memset(v18, 0, 28);
    v20 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v7 = defaults::get((char *)__p, a3, &buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v21);
      *(std::string *)&v18[1] = v21;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v20 & 0x80000000) == 0)
      {
LABEL_6:
        if (v7)
          goto LABEL_7;
        goto LABEL_14;
      }
    }
    else if ((v20 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(__p[0]);
    if (v7)
    {
LABEL_7:
      v8 = util::convert<unsigned int>((const std::string *)&v18[1], v18, 0);
      if (SHIBYTE(v18[6]) < 0)
      {
LABEL_17:
        operator delete(*(void **)&v18[1]);
        if (!(_DWORD)v8)
          return v8;
        goto LABEL_18;
      }
LABEL_15:
      if (!(_DWORD)v8)
        return v8;
LABEL_18:
      v10 = v18[0];
      v11 = *(_DWORD *)(a1 + 280);
      if (v18[0] != v11)
      {
        v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v10;
          _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Updating trace transport read-count from %d to %d", (uint8_t *)&buf, 0xEu);
          v10 = v18[0];
        }
        *(_DWORD *)(a1 + 280) = v10;
        if (*(_BYTE *)(a1 + 156))
        {
          v13 = *a2;
          v17 = v13;
          if (v13)
            dispatch_retain(v13);
          INTTrace::stop_sync((INTTrace *)a1, (group *)&v17);
          if (v13)
            dispatch_release(v13);
          v14 = *a2;
          v16 = v14;
          if (v14)
            dispatch_retain(v14);
          INTTrace::start_sync((INTTrace *)a1, (group *)&v16);
          if (v14)
            dispatch_release(v14);
        }
      }
      return v8;
    }
LABEL_14:
    v8 = 0;
    if (SHIBYTE(v18[6]) < 0)
      goto LABEL_17;
    goto LABEL_15;
  }
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Failed to set trace transport read-count", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A34E2D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  NSObject *v25;

  if (v25)
  {
    dispatch_release(v25);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropSleepTraceMode_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  NSObject *v7;
  _BOOL4 v8;
  int data;
  int v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  NSObject *v15;
  std::string v16;
  void *__p[2];
  char v18;
  std::string v19;
  std::string buf;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if (!prop::bbtrace::set(a3, a4))
  {
    v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to set sleep trace enabled", (uint8_t *)&buf, 2u);
      v12 = 0;
      if (!v7)
        return v12;
      goto LABEL_26;
    }
LABEL_25:
    v12 = 0;
    if (v7)
      goto LABEL_26;
    return v12;
  }
  memset(&v16, 0, sizeof(v16));
  v18 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v8 = defaults::get((char *)__p, a3, &buf);
  if (v8)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v19);
    v16 = v19;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v18 & 0x80000000) == 0)
    {
LABEL_8:
      data = -1431655766;
      if (v8)
        goto LABEL_9;
LABEL_19:
      v10 = 0;
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_24;
LABEL_20:
      if (!v10)
        goto LABEL_25;
      goto LABEL_21;
    }
  }
  else if ((v18 & 0x80000000) == 0)
  {
    goto LABEL_8;
  }
  operator delete(__p[0]);
  data = -1431655766;
  if (!v8)
    goto LABEL_19;
LABEL_9:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v10 = util::convert<int>(&v16, &buf, 0);
  if (v10)
    data = (int)buf.__r_.__value_.__l.__data_;
  else
    data = -1431655766;
  if ((SHIBYTE(v16.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_20;
LABEL_24:
  operator delete(v16.__r_.__value_.__l.__data_);
  if (!v10)
    goto LABEL_25;
LABEL_21:
  v13 = *(_DWORD *)(a1 + 288);
  if (data == v13)
  {
    v12 = 1;
    if (!v7)
      return v12;
    goto LABEL_26;
  }
  v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v13;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = data;
    _os_log_impl(&dword_1A343C000, v15, OS_LOG_TYPE_DEFAULT, "#I Setting sleep trace mode from %d to %d", (uint8_t *)&buf, 0xEu);
  }
  *(_DWORD *)(a1 + 288) = data;
  v12 = 1;
  if (v7)
  {
LABEL_26:
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v12;
}

void sub_1A34E3008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  NSObject *v30;

  if (a14 < 0)
    operator delete(__p);
  if (v30)
  {
    dispatch_group_leave(v30);
    dispatch_release(v30);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropSleepConfig_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  NSObject *v7;
  _BOOL8 v8;
  std::string *v9;
  const char *v10;
  std::string *v11;
  int v12;
  NSObject *v13;
  _BOOL4 v14;
  NSObject *v15;
  NSObject *v16;
  std::string *v18;
  size_t size;
  std::string v20;
  void *__p[2];
  char v22;
  std::string v23;
  std::string buf;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if ((prop::bbtrace::set(a3, a4) & 1) != 0)
  {
    v20.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    v20.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
    v20.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
    v22 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v8 = defaults::get((char *)__p, a3, &buf);
    if (v8)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v23);
      v20 = v23;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v22 & 0x80000000) == 0)
      {
LABEL_8:
        if (v8)
          goto LABEL_9;
        goto LABEL_27;
      }
    }
    else if ((v22 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(__p[0]);
    if (v8)
    {
LABEL_9:
      v9 = (std::string *)(a1 + 296);
      if (*(char *)(a1 + 319) >= 0)
        v10 = (const char *)(a1 + 296);
      else
        v10 = *(const char **)(a1 + 296);
      if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v11 = &v20;
      else
        v11 = (std::string *)v20.__r_.__value_.__r.__words[0];
      v12 = strcasecmp(v10, (const char *)v11);
      v13 = *(NSObject **)(a1 + 40);
      v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        if (v14)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
          _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I Setting sleep trace config from %s to %s", (uint8_t *)&buf, 0x16u);
        }
        if (v9 != &v20)
        {
          if (*(char *)(a1 + 319) < 0)
          {
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v18 = &v20;
            else
              v18 = (std::string *)v20.__r_.__value_.__r.__words[0];
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
            else
              size = v20.__r_.__value_.__l.__size_;
            std::string::__assign_no_alias<false>((void **)(a1 + 296), v18, size);
          }
          else
          {
            if ((*((_BYTE *)&v20.__r_.__value_.__s + 23) & 0x80) == 0)
            {
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)&v20.__r_.__value_.__l.__data_;
              *(_QWORD *)(a1 + 312) = *((_QWORD *)&v20.__r_.__value_.__l + 2);
              goto LABEL_31;
            }
            std::string::__assign_no_alias<true>((_QWORD *)(a1 + 296), v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
          }
        }
      }
      else if (v14)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
        _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I The config (%s) is already set!", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_29;
    }
LABEL_27:
    v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v16, OS_LOG_TYPE_ERROR, "Failed to get sleep trace config", (uint8_t *)&buf, 2u);
    }
LABEL_29:
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v20.__r_.__value_.__l.__data_);
    goto LABEL_31;
  }
  v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v15, OS_LOG_TYPE_ERROR, "Failed to set sleep trace config", (uint8_t *)&buf, 2u);
  }
  v8 = 0;
LABEL_31:
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v8;
}

void sub_1A34E3394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  NSObject *v30;

  if (a14 < 0)
    operator delete(__p);
  if (v30)
  {
    dispatch_group_leave(v30);
    dispatch_release(v30);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropErrorHandling_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  _BOOL4 v6;
  int v7;
  char v8;
  unsigned int data;
  NSObject *v10;
  _BOOL8 result;
  const char *v12;
  uint64_t v13;
  NSObject *v14;
  _BOOL4 v15;
  const char *v16;
  const char *v17;
  const char *v18;
  std::string v19;
  void *__p[2];
  char v21;
  std::string v22;
  std::string buf;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if ((prop::bbtrace::set(a3, a4) & 1) == 0)
  {
    v10 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v12 = "Failed to set trace error handling property!";
LABEL_25:
    _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&buf, 2u);
    return 0;
  }
  memset(&v19, 0, sizeof(v19));
  v21 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  v6 = defaults::get((char *)__p, a3, &buf);
  if (v6)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v22);
    v19 = v22;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v21 & 0x80000000) == 0)
    {
LABEL_6:
      if (v6)
        goto LABEL_7;
LABEL_16:
      v8 = 0;
      data = 1;
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_22;
      goto LABEL_17;
    }
  }
  else if ((v21 & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(__p[0]);
  if (!v6)
    goto LABEL_16;
LABEL_7:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  v7 = util::convert<int>(&v19, &buf, 0);
  v8 = v7;
  if (v7)
    data = buf.__r_.__value_.__l.__data_;
  else
    data = 1;
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_22:
    operator delete(v19.__r_.__value_.__l.__data_);
    if ((v8 & 1) == 0)
      goto LABEL_23;
    goto LABEL_18;
  }
LABEL_17:
  if ((v8 & 1) == 0)
  {
LABEL_23:
    v10 = *(NSObject **)(a1 + 40);
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    v12 = "Failed to get trace error handling property!";
    goto LABEL_25;
  }
LABEL_18:
  v13 = *(int *)(a1 + 380);
  v14 = *(NSObject **)(a1 + 40);
  v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (data == (_DWORD)v13)
  {
    if (v15)
    {
      if (data > 2)
        v16 = "Unknown";
      else
        v16 = off_1E4A0B078[data];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Trace error handling is already set to %s", (uint8_t *)&buf, 0xCu);
    }
    return 1;
  }
  if (v15)
  {
    if (v13 > 2)
    {
      v17 = "Unknown";
      if (data > 2)
        goto LABEL_29;
    }
    else
    {
      v17 = off_1E4A0B078[v13];
      if (data > 2)
      {
LABEL_29:
        v18 = "Unknown";
LABEL_34:
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
        _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Setting trace error handling from %s to %s", (uint8_t *)&buf, 0x16u);
        goto LABEL_35;
      }
    }
    v18 = off_1E4A0B078[data];
    goto LABEL_34;
  }
LABEL_35:
  *(_DWORD *)(a1 + 380) = data;
  return 1;
}

void sub_1A34E36D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropRetainPreviousTrace_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  _BOOL4 v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  const char *v14;
  const char *v15;
  const char *v16;
  char v18;
  std::string __p;
  void *v20[2];
  char v21;
  std::string v22;
  std::string buf;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if ((prop::bbtrace::set(a3, a4) & 1) != 0)
  {
    v18 = 1;
    memset(&__p, 0, sizeof(__p));
    v21 = 7;
    strcpy((char *)v20, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    v6 = defaults::get((char *)v20, a3, &buf);
    if (v6)
    {
      prop::file::get<std::string>((const void **)v20, (uint64_t)a3, (uint64_t)&buf, &v22);
      __p = v22;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v21 & 0x80000000) == 0)
      {
LABEL_6:
        if (v6)
          goto LABEL_7;
        goto LABEL_16;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(v20[0]);
    if (v6)
    {
LABEL_7:
      v7 = util::convert<BOOL>(&__p, (BOOL *)&v18, 0);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_8;
      goto LABEL_17;
    }
LABEL_16:
    v7 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_8:
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v7 & 1) == 0)
        goto LABEL_9;
LABEL_18:
      v10 = v18;
      v11 = *(unsigned __int8 *)(a1 + 384);
      v12 = *(NSObject **)(a1 + 40);
      v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      if (v10 == v11)
      {
        if (v13)
        {
          v14 = "true";
          if (!v10)
            v14 = "false";
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
          _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Retain previous trace property is already set to %s", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        if (v13)
        {
          v15 = "true";
          if (v11)
            v16 = "true";
          else
            v16 = "false";
          if (!v10)
            v15 = "false";
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v15;
          _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Setting retain previous trace property from %s to %s", (uint8_t *)&buf, 0x16u);
          LOBYTE(v10) = v18;
        }
        *(_BYTE *)(a1 + 384) = v10;
      }
      return v7;
    }
LABEL_17:
    if ((v7 & 1) == 0)
    {
LABEL_9:
      v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to get retain previous trace property", (uint8_t *)&buf, 2u);
      }
      return v7;
    }
    goto LABEL_18;
  }
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Failed to set retain previous trace property", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A34E3A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<INTTrace *,std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace *)#1},std::allocator<INTTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<INTTrace *,std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace *)#1},std::allocator<INTTrace>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace*)#1}::operator() const(INTTrace*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<INTTrace *,std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace *)#1},std::allocator<INTTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace*)#1}::operator() const(INTTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  NSObject *v6;
  _BOOL4 v7;
  NSObject *v8;
  _BOOL4 v9;
  _BOOL4 v10;
  _BOOL4 v11;
  _BOOL4 v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  void *v18[3];
  dispatch_object_t object;
  uint64_t v20;
  std::__shared_weak_count *v21;
  std::string v22;
  std::string __p;
  void *v24[2];
  char v25;
  std::string v26[2];

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(v1 + 8);
  if (*(char *)(v1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)(v1 + 16), *(_QWORD *)(v1 + 24));
    v3 = *(std::__shared_weak_count **)(v1 + 48);
    v20 = *(_QWORD *)(v1 + 40);
    v21 = v3;
    if (!v3)
      goto LABEL_7;
  }
  else
  {
    v22 = *(std::string *)(v1 + 16);
    v3 = *(std::__shared_weak_count **)(v1 + 48);
    v20 = *(_QWORD *)(v1 + 40);
    v21 = v3;
    if (!v3)
      goto LABEL_7;
  }
  p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
  do
    v5 = __ldxr(p_shared_weak_owners);
  while (__stxr(v5 + 1, p_shared_weak_owners));
LABEL_7:
  v6 = *(NSObject **)(v1 + 56);
  object = v6;
  if (v6)
    dispatch_retain(v6);
  **(_BYTE **)v1 = Trace::init(v2, (void **)&v22.__r_.__value_.__l.__data_, &v20, &object);
  if (object)
    dispatch_release(object);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (**(_BYTE **)v1)
      goto LABEL_15;
LABEL_24:
    v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26[1].__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to initialize Trace!", (uint8_t *)&v26[1], 2u);
    }
    return;
  }
  operator delete(v22.__r_.__value_.__l.__data_);
  if (!**(_BYTE **)v1)
    goto LABEL_24;
LABEL_15:
  HIBYTE(v18[2]) = 7;
  strcpy((char *)v18, "Enabled");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v7 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v7)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if ((SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_21;
LABEL_27:
    operator delete(v24[0]);
    if (!v7)
      goto LABEL_29;
    goto LABEL_28;
  }
  operator delete(v26[1].__r_.__value_.__l.__data_);
  if (v25 < 0)
    goto LABEL_27;
LABEL_21:
  if (v7)
LABEL_28:
    util::convert<BOOL>(&__p, (BOOL *)(v2 + 156), 0);
LABEL_29:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_31;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v18[0]);
LABEL_31:
  INTTrace::initBootSessionPrefs_sync((INTTrace *)v2);
  HIBYTE(v18[2]) = 12;
  strcpy((char *)v18, "PrivacyLevel");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v9 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v9)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if (SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26[1].__r_.__value_.__l.__data_);
    if ((v25 & 0x80000000) == 0)
    {
LABEL_37:
      if (!v9)
        goto LABEL_45;
      goto LABEL_43;
    }
  }
  else if ((v25 & 0x80000000) == 0)
  {
    goto LABEL_37;
  }
  operator delete(v24[0]);
  if (!v9)
    goto LABEL_45;
LABEL_43:
  LODWORD(v26[1].__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &v26[1], 0))
    *(_DWORD *)(v2 + 160) = v26[1].__r_.__value_.__l.__data_;
LABEL_45:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_47;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_47;
  }
  operator delete(v18[0]);
LABEL_47:
  HIBYTE(v18[2]) = 7;
  strcpy((char *)v18, "History");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v10 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v10)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if ((SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_53;
LABEL_58:
    operator delete(v24[0]);
    if (!v10)
      goto LABEL_60;
    goto LABEL_59;
  }
  operator delete(v26[1].__r_.__value_.__l.__data_);
  if (v25 < 0)
    goto LABEL_58;
LABEL_53:
  if (v10)
LABEL_59:
    util::convert<int>(&__p, (_DWORD *)(v2 + 164), 0);
LABEL_60:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_62;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_62;
  }
  operator delete(v18[0]);
LABEL_62:
  *((_BYTE *)&v26[0].__r_.__value_.__s + 23) = 4;
  strcpy((char *)v26, "File");
  *((_BYTE *)&v26[1].__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v26[1], "BBTrace");
  prop::get_from_file((char *)&v26[1], (char *)v26, v2 + 184);
  if (SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(v26[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_64;
  }
  else if ((SHIBYTE(v26[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_64;
  }
  operator delete(v26[0].__r_.__value_.__l.__data_);
LABEL_64:
  HIBYTE(v18[2]) = 8;
  strcpy((char *)v18, "FileSize");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v11 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v11)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if ((SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_70;
LABEL_77:
    operator delete(v24[0]);
    if (!v11)
      goto LABEL_79;
    goto LABEL_78;
  }
  operator delete(v26[1].__r_.__value_.__l.__data_);
  if (v25 < 0)
    goto LABEL_77;
LABEL_70:
  if (v11)
LABEL_78:
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 172), 0);
LABEL_79:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_81;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_81;
  }
  operator delete(v18[0]);
LABEL_81:
  HIBYTE(v18[2]) = 18;
  strcpy((char *)v18, "MaxMemoryFileCount");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v12 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v12)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if ((SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_87;
LABEL_92:
    operator delete(v24[0]);
    if (!v12)
      goto LABEL_94;
    goto LABEL_93;
  }
  operator delete(v26[1].__r_.__value_.__l.__data_);
  if (v25 < 0)
    goto LABEL_92;
LABEL_87:
  if (v12)
LABEL_93:
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 176), 0);
LABEL_94:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_96;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_96;
  }
  operator delete(v18[0]);
LABEL_96:
  HIBYTE(v18[2]) = 6;
  strcpy((char *)v18, "SizeIO");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v13 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v13)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if ((SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_102;
LABEL_107:
    operator delete(v24[0]);
    if (!v13)
      goto LABEL_109;
    goto LABEL_108;
  }
  operator delete(v26[1].__r_.__value_.__l.__data_);
  if (v25 < 0)
    goto LABEL_107;
LABEL_102:
  if (v13)
LABEL_108:
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 276), 0);
LABEL_109:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_111;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_111;
  }
  operator delete(v18[0]);
LABEL_111:
  HIBYTE(v18[2]) = 14;
  strcpy((char *)v18, "NumberOfReadIO");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v14 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v14)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if ((SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_117;
LABEL_122:
    operator delete(v24[0]);
    if (!v14)
      goto LABEL_124;
    goto LABEL_123;
  }
  operator delete(v26[1].__r_.__value_.__l.__data_);
  if (v25 < 0)
    goto LABEL_122;
LABEL_117:
  if (v14)
LABEL_123:
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 280), 0);
LABEL_124:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_126;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_126;
  }
  operator delete(v18[0]);
LABEL_126:
  HIBYTE(v18[2]) = 20;
  strcpy((char *)v18, "Enabled_During_Sleep");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v15 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v15)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if (SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26[1].__r_.__value_.__l.__data_);
    if ((v25 & 0x80000000) == 0)
    {
LABEL_132:
      if (!v15)
        goto LABEL_140;
      goto LABEL_138;
    }
  }
  else if ((v25 & 0x80000000) == 0)
  {
    goto LABEL_132;
  }
  operator delete(v24[0]);
  if (!v15)
    goto LABEL_140;
LABEL_138:
  LODWORD(v26[1].__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &v26[1], 0))
    *(_DWORD *)(v2 + 288) = v26[1].__r_.__value_.__l.__data_;
LABEL_140:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_142;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_142;
  }
  operator delete(v18[0]);
LABEL_142:
  strcpy((char *)&v26[0].__r_.__value_.__r.__words[2] + 7, "\nBBTrace");
  strcpy((char *)v26, "File_Sleep");
  *((_BYTE *)&v26[1].__r_.__value_.__s + 23) = 7;
  prop::get_from_file((char *)&v26[1], (char *)v26, v2 + 296);
  if (SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(v26[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_144;
  }
  else if ((SHIBYTE(v26[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_144;
  }
  operator delete(v26[0].__r_.__value_.__l.__data_);
LABEL_144:
  HIBYTE(v18[2]) = 14;
  strcpy((char *)v18, "Error_Handling");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v16 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v16)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v26[0];
  }
  if (SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26[1].__r_.__value_.__l.__data_);
    if ((v25 & 0x80000000) == 0)
    {
LABEL_150:
      if (!v16)
        goto LABEL_160;
      goto LABEL_158;
    }
  }
  else if ((v25 & 0x80000000) == 0)
  {
    goto LABEL_150;
  }
  operator delete(v24[0]);
  if (!v16)
    goto LABEL_160;
LABEL_158:
  LODWORD(v26[1].__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &v26[1], 0))
    *(_DWORD *)(v2 + 380) = v26[1].__r_.__value_.__l.__data_;
LABEL_160:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      goto LABEL_162;
  }
  else if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
  {
    goto LABEL_162;
  }
  operator delete(v18[0]);
LABEL_162:
  HIBYTE(v18[2]) = 21;
  strcpy((char *)v18, "Retain_Previous_Trace");
  memset(&__p, 0, sizeof(__p));
  v25 = 7;
  strcpy((char *)v24, "BBTrace");
  memset(&v26[1], 0, sizeof(std::string));
  v17 = defaults::get((char *)v24, (char *)v18, &v26[1]);
  if (v17)
  {
    prop::file::get<std::string>((const void **)v24, (uint64_t)v18, (uint64_t)&v26[1], v26);
    __p = v26[0];
  }
  if (SHIBYTE(v26[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26[1].__r_.__value_.__l.__data_);
    if ((v25 & 0x80000000) == 0)
    {
LABEL_166:
      if (!v17)
        goto LABEL_173;
      goto LABEL_172;
    }
  }
  else if ((v25 & 0x80000000) == 0)
  {
    goto LABEL_166;
  }
  operator delete(v24[0]);
  if (v17)
LABEL_172:
    util::convert<BOOL>(&__p, (BOOL *)(v2 + 384), 0);
LABEL_173:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v18[2]) & 0x80000000) == 0)
      return;
LABEL_177:
    operator delete(v18[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v18[2]) < 0)
    goto LABEL_177;
}

void sub_1A34E4790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a27 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

void sub_1A34E48B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  std::__shared_weak_count *v20;

  if (object)
  {
    dispatch_release(object);
    v20 = a14;
    if (!a14)
    {
LABEL_3:
      if (a20 < 0)
        goto LABEL_10;
      goto LABEL_11;
    }
  }
  else
  {
    v20 = a14;
    if (!a14)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v20);
  if (a20 < 0)
LABEL_10:
    JUMPOUT(0x1A34E48ACLL);
LABEL_11:
  JUMPOUT(0x1A34E48B0);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>(INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1,std::default_delete<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  _OWORD *v4;
  int v5;
  char *v6;
  size_t v7;
  std::string::size_type v8;
  std::string *p_dst;
  char *v10;
  size_t v11;
  std::string::size_type v12;
  std::string *v13;
  char *v14;
  size_t v15;
  std::string::size_type v16;
  std::string *v17;
  uint64_t v18;
  uint64_t v19;
  std::string *v20;
  __int128 v21;
  __int128 v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  char *v29;
  size_t v30;
  std::string::size_type v31;
  std::string *v32;
  uint64_t v33;
  uint64_t v34;
  std::string *v35;
  __int128 v36;
  __int128 v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  std::string *v46;
  __int128 v47;
  __int128 v48;
  std::__shared_weak_count *v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  unint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  std::string *v55;
  __int128 v56;
  __int128 v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::string __dst;
  void *__p[2];
  std::string::size_type v67;
  __int128 v68;

  v2 = *a1;
  v3 = **a1;
  v4 = (_OWORD *)(v3 + 328);
  v5 = *(_DWORD *)(v3 + 168);
  if ((v5 - 2) >= 2)
  {
    if (v5 != 1)
    {
      if (v5)
        goto LABEL_75;
      v6 = abm::trace::kScratchFolder[0];
      v7 = strlen(abm::trace::kScratchFolder[0]);
      if (v7 <= 0x7FFFFFFFFFFFFFF7)
      {
        v8 = v7;
        if (v7 >= 0x17)
        {
          v44 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v7 | 7) != 0x17)
            v44 = v7 | 7;
          v45 = v44 + 1;
          p_dst = (std::string *)operator new(v44 + 1);
          __dst.__r_.__value_.__l.__size_ = v8;
          __dst.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v7;
          p_dst = &__dst;
          if (!v7)
            goto LABEL_51;
        }
        memmove(p_dst, v6, v8);
LABEL_51:
        p_dst->__r_.__value_.__s.__data_[v8] = 0;
        v46 = std::string::append(&__dst, "BBTrace.scratch/", 0x10uLL);
        v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
        v67 = v46->__r_.__value_.__r.__words[2];
        *(_OWORD *)__p = v47;
        v46->__r_.__value_.__l.__size_ = 0;
        v46->__r_.__value_.__r.__words[2] = 0;
        v46->__r_.__value_.__r.__words[0] = 0;
        abm::trace::TraceInfo::create();
        v48 = v68;
        v68 = 0uLL;
        v49 = *(std::__shared_weak_count **)(v3 + 336);
        *v4 = v48;
        if (v49)
        {
          p_shared_owners = (unint64_t *)&v49->__shared_owners_;
          do
            v51 = __ldaxr(p_shared_owners);
          while (__stlxr(v51 - 1, p_shared_owners));
          if (!v51)
          {
            ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
            std::__shared_weak_count::__release_weak(v49);
          }
        }
        v41 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
        if (*((_QWORD *)&v68 + 1))
        {
          v52 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
          do
            v43 = __ldaxr(v52);
          while (__stlxr(v43 - 1, v52));
          goto LABEL_72;
        }
LABEL_73:
        if ((SHIBYTE(v67) & 0x80000000) == 0)
          goto LABEL_74;
        goto LABEL_78;
      }
LABEL_90:
      std::string::__throw_length_error[abi:ne180100]();
    }
    v14 = abm::trace::kScratchFolder[0];
    v15 = strlen(abm::trace::kScratchFolder[0]);
    if (v15 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_90;
    v16 = v15;
    if (v15 >= 0x17)
    {
      v53 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v53 = v15 | 7;
      v54 = v53 + 1;
      v17 = (std::string *)operator new(v53 + 1);
      __dst.__r_.__value_.__l.__size_ = v16;
      __dst.__r_.__value_.__r.__words[2] = v54 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v15;
      v17 = &__dst;
      if (!v15)
      {
LABEL_64:
        v17->__r_.__value_.__s.__data_[v16] = 0;
        v55 = std::string::append(&__dst, "BBTrace.scratch.filtered/", 0x19uLL);
        v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
        v67 = v55->__r_.__value_.__r.__words[2];
        *(_OWORD *)__p = v56;
        v55->__r_.__value_.__l.__size_ = 0;
        v55->__r_.__value_.__r.__words[2] = 0;
        v55->__r_.__value_.__r.__words[0] = 0;
        abm::trace::TraceInfo::create();
        v57 = v68;
        v68 = 0uLL;
        v58 = *(std::__shared_weak_count **)(v3 + 336);
        *v4 = v57;
        if (v58)
        {
          v59 = (unint64_t *)&v58->__shared_owners_;
          do
            v60 = __ldaxr(v59);
          while (__stlxr(v60 - 1, v59));
          if (!v60)
          {
            ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
            std::__shared_weak_count::__release_weak(v58);
          }
        }
        v41 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
        if (!*((_QWORD *)&v68 + 1))
          goto LABEL_73;
        v61 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
        do
          v43 = __ldaxr(v61);
        while (__stlxr(v43 - 1, v61));
        goto LABEL_72;
      }
    }
    memmove(v17, v14, v16);
    goto LABEL_64;
  }
  v10 = abm::trace::kScratchFolder[0];
  v11 = strlen(abm::trace::kScratchFolder[0]);
  if (v11 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_90;
  v12 = v11;
  if (v11 >= 0x17)
  {
    v18 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v18 = v11 | 7;
    v19 = v18 + 1;
    v13 = (std::string *)operator new(v18 + 1);
    __dst.__r_.__value_.__l.__size_ = v12;
    __dst.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
  }
  else
  {
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v11;
    v13 = &__dst;
    if (!v11)
      goto LABEL_20;
  }
  memmove(v13, v10, v12);
LABEL_20:
  v13->__r_.__value_.__s.__data_[v12] = 0;
  v20 = std::string::append(&__dst, "BBTrace.scratch/", 0x10uLL);
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v67 = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  abm::trace::TraceInfo::create();
  v22 = v68;
  v68 = 0uLL;
  v23 = *(std::__shared_weak_count **)(v3 + 336);
  *v4 = v22;
  if (!v23)
    goto LABEL_24;
  v24 = (unint64_t *)&v23->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
    if (!*((_QWORD *)&v68 + 1))
      goto LABEL_28;
  }
  else
  {
LABEL_24:
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
    if (!*((_QWORD *)&v68 + 1))
      goto LABEL_28;
  }
  v27 = (unint64_t *)&v26->__shared_owners_;
  do
    v28 = __ldaxr(v27);
  while (__stlxr(v28 - 1, v27));
  if (v28)
  {
LABEL_28:
    if ((SHIBYTE(v67) & 0x80000000) == 0)
      goto LABEL_29;
    goto LABEL_88;
  }
  ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
  std::__shared_weak_count::__release_weak(v26);
  if ((SHIBYTE(v67) & 0x80000000) == 0)
  {
LABEL_29:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_30;
    goto LABEL_89;
  }
LABEL_88:
  operator delete(__p[0]);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_30:
    v29 = abm::trace::kScratchFolder[0];
    v30 = strlen(abm::trace::kScratchFolder[0]);
    if (v30 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_90;
    goto LABEL_31;
  }
LABEL_89:
  operator delete(__dst.__r_.__value_.__l.__data_);
  v29 = abm::trace::kScratchFolder[0];
  v30 = strlen(abm::trace::kScratchFolder[0]);
  if (v30 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_90;
LABEL_31:
  v31 = v30;
  if (v30 >= 0x17)
  {
    v33 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v30 | 7) != 0x17)
      v33 = v30 | 7;
    v34 = v33 + 1;
    v32 = (std::string *)operator new(v33 + 1);
    __dst.__r_.__value_.__l.__size_ = v31;
    __dst.__r_.__value_.__r.__words[2] = v34 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
    goto LABEL_37;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v30;
  v32 = &__dst;
  if (v30)
LABEL_37:
    memmove(v32, v29, v31);
  v32->__r_.__value_.__s.__data_[v31] = 0;
  v35 = std::string::append(&__dst, "BBTrace.scratch.filtered/", 0x19uLL);
  v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v67 = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  abm::trace::TraceInfo::create();
  v37 = v68;
  v68 = 0uLL;
  v38 = *(std::__shared_weak_count **)(v3 + 352);
  *(_OWORD *)(v3 + 344) = v37;
  if (v38)
  {
    v39 = (unint64_t *)&v38->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v41 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
  if (!*((_QWORD *)&v68 + 1))
    goto LABEL_73;
  v42 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
  do
    v43 = __ldaxr(v42);
  while (__stlxr(v43 - 1, v42));
LABEL_72:
  if (v43)
    goto LABEL_73;
  ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
  std::__shared_weak_count::__release_weak(v41);
  if ((SHIBYTE(v67) & 0x80000000) == 0)
  {
LABEL_74:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_75;
LABEL_79:
    operator delete(__dst.__r_.__value_.__l.__data_);
    operator delete(v2);
    v62 = (std::__shared_weak_count *)a1[2];
    if (!v62)
      goto LABEL_84;
    goto LABEL_80;
  }
LABEL_78:
  operator delete(__p[0]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_79;
LABEL_75:
  operator delete(v2);
  v62 = (std::__shared_weak_count *)a1[2];
  if (!v62)
    goto LABEL_84;
LABEL_80:
  v63 = (unint64_t *)&v62->__shared_owners_;
  do
    v64 = __ldaxr(v63);
  while (__stlxr(v64 - 1, v63));
  if (!v64)
  {
    ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
    std::__shared_weak_count::__release_weak(v62);
  }
LABEL_84:
  operator delete(a1);
}

void sub_1A34E4EEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  _QWORD *v21;
  void *v22;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;

  if (a21 < 0)
  {
    operator delete(__p);
    if ((a15 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a15 & 0x80000000) == 0)
  {
LABEL_3:
    operator delete(v22);
    v24 = (std::__shared_weak_count *)v21[2];
    if (!v24)
      goto LABEL_11;
    goto LABEL_7;
  }
  operator delete(a10);
  operator delete(v22);
  v24 = (std::__shared_weak_count *)v21[2];
  if (!v24)
    goto LABEL_11;
LABEL_7:
  p_shared_owners = (unint64_t *)&v24->__shared_owners_;
  do
    v26 = __ldaxr(p_shared_owners);
  while (__stlxr(v26 - 1, p_shared_owners));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
LABEL_11:
  operator delete(v21);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<SharedData>::shared_ptr[abi:ne180100]<SharedData,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E4A0AF50;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (a2)
  {
    v6 = *(std::__shared_weak_count **)(a2 + 32);
    if (v6)
    {
      if (v6->__shared_owners_ != -1)
        return a1;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
      do
        v9 = __ldxr(p_shared_weak_owners);
      while (__stxr(v9 + 1, p_shared_weak_owners));
      *(_QWORD *)(a2 + 24) = a2;
      *(_QWORD *)(a2 + 32) = v4;
      std::__shared_weak_count::__release_weak(v6);
    }
    else
    {
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      v11 = (unint64_t *)&v4->__shared_weak_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      *(_QWORD *)(a2 + 24) = a2;
      *(_QWORD *)(a2 + 32) = v4;
    }
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1A34E5108(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<SharedData>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<SharedData>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  void *v4;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(std::__shared_weak_count **)(v2 + 32);
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
    v4 = (void *)MEMORY[0x1A858F2F0](v2);
    operator delete(v4);
  }
  return a1;
}

void std::__shared_ptr_pointer<SharedData *,std::shared_ptr<SharedData>::__shared_ptr_default_delete<SharedData,SharedData>,std::allocator<SharedData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<SharedData *,std::shared_ptr<SharedData>::__shared_ptr_default_delete<SharedData,SharedData>,std::allocator<SharedData>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  void *v3;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2)
      std::__shared_weak_count::__release_weak(v2);
    v3 = (void *)MEMORY[0x1A858F2F0](v1);
    operator delete(v3);
  }
}

uint64_t std::__shared_ptr_pointer<SharedData *,std::shared_ptr<SharedData>::__shared_ptr_default_delete<SharedData,SharedData>,std::allocator<SharedData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001A3581C2DLL)
    return a1 + 24;
  if (((v3 & 0x80000001A3581C2DLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A3581C2DLL))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A3581C2DLL & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

uint64_t ctu::PthreadMutexGuardPolicy<SharedData>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  pthread_mutex_lock((pthread_mutex_t *)a1);
  v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v5)
    return a1;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  dispatch_group_t *v2;
  dispatch_group_t v3;
  NSObject *isa;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  __int16 v9[8];

  v2 = *a1;
  v3 = (*a1)[1];
  isa = v3[18].isa;
  if (isa)
  {
    dispatch_retain((dispatch_object_t)v3[18].isa);
    dispatch_group_enter(isa);
  }
  if (BYTE4(v3[19].isa))
  {
    INTTrace::prepare_sync((INTTrace *)v3);
  }
  else
  {
    v5 = v3[5].isa;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 0;
      _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Trace is not enabled. Skip to prepare processing", (uint8_t *)v9, 2u);
    }
  }
  if (isa)
  {
    dispatch_group_leave(isa);
    dispatch_release(isa);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2)
      dispatch_release(*v2);
  }
  operator delete(v2);
  v6 = (std::__shared_weak_count *)a1[2];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  operator delete(a1);
}

void sub_1A34E5400(_Unwind_Exception *a1)
{
  _QWORD *v1;
  dispatch_group_t *v2;
  NSObject *v3;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2)
      dispatch_release(*v2);
  }
  operator delete(v2);
  v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  CommandDriverFactory *v7;
  uint64_t v8;
  __int128 v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  char *gr_passwd;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  NSObject *v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  NSObject *v32;
  NSObject *v33;
  __int128 v34;
  group buf;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = **a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(_BYTE *)(v3 + 156))
  {
    v5 = (char *)v2[1];
    buf.gr_name = v5;
    if (v5)
      dispatch_retain((dispatch_object_t)v5);
    INTTrace::start_sync((INTTrace *)v3, &buf);
LABEL_44:
    if (v5)
      dispatch_release((dispatch_object_t)v5);
    if (v4)
    {
      dispatch_group_leave(v4);
      dispatch_release(v4);
    }
    v28 = v2[1];
    if (v28)
      dispatch_release(v28);
    operator delete(v2);
    v29 = (std::__shared_weak_count *)a1[2];
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        v31 = __ldaxr(p_shared_owners);
      while (__stlxr(v31 - 1, p_shared_owners));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    operator delete(a1);
    return;
  }
  if (*(_QWORD *)(v3 + 256))
    goto LABEL_41;
  v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.gr_name) = 0;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Creating Trace CommandDriver", (uint8_t *)&buf, 2u);
  }
  v7 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  v8 = off_1ED114670;
  if (!off_1ED114670)
  {
    CommandDriverFactory::create_default_global(v7);
    v9 = *(_OWORD *)&buf.gr_name;
    buf.gr_name = 0;
    buf.gr_passwd = 0;
    v10 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
    off_1ED114670 = v9;
    if (v10)
    {
      v11 = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    gr_passwd = buf.gr_passwd;
    if (buf.gr_passwd)
    {
      v14 = (unint64_t *)(buf.gr_passwd + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        (*(void (**)(char *))(*(_QWORD *)gr_passwd + 16))(gr_passwd);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)gr_passwd);
      }
    }
    v8 = off_1ED114670;
  }
  v16 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
  if (*(&off_1ED114670 + 1))
  {
    v17 = (unint64_t *)(*(&off_1ED114670 + 1) + 8);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  (*(void (**)(__int128 *__return_ptr, uint64_t))(*(_QWORD *)v8 + 136))(&v34, v8);
  v19 = v34;
  v34 = 0uLL;
  v20 = *(std::__shared_weak_count **)(v3 + 264);
  *(_OWORD *)(v3 + 256) = v19;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = (std::__shared_weak_count *)*((_QWORD *)&v34 + 1);
  if (*((_QWORD *)&v34 + 1))
  {
    v24 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v16)
  {
    v26 = (unint64_t *)&v16->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (*(_QWORD *)(v3 + 256))
  {
LABEL_41:
    v5 = (char *)v2[1];
    buf.gr_name = v5;
    if (v5)
      dispatch_retain((dispatch_object_t)v5);
    INTTrace::stop_sync((INTTrace *)v3, &buf);
    goto LABEL_44;
  }
  v32 = GetOsLogContext()[1];
  if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.gr_name) = 0;
    _os_log_fault_impl(&dword_1A343C000, v32, OS_LOG_TYPE_FAULT, "Trace command driver must be present!", (uint8_t *)&buf, 2u);
  }
  v33 = GetOsLogContext()[1];
  if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf.gr_name) = 136315906;
    *(char **)((char *)&buf.gr_name + 4) = "ABM ASSERT";
    WORD2(buf.gr_passwd) = 2080;
    *(char **)((char *)&buf.gr_passwd + 6) = "fTraceCommandDriver";
    *((_WORD *)&buf.gr_gid + 3) = 2080;
    buf.gr_mem = (char **)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHe"
                          "lper/Server/Tasks/Wireless/Trace/INTTrace/INTTrace.cpp";
    v36 = 1024;
    v37 = 194;
    _os_log_fault_impl(&dword_1A343C000, v33, OS_LOG_TYPE_FAULT, "%s (%s): File: %s Line: %d", (uint8_t *)&buf, 0x26u);
  }
  __break(1u);
}

void sub_1A34E5864(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  NSObject *v3;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  v5 = v2[1];
  if (v5)
    dispatch_release(v5);
  operator delete(v2);
  v6 = (std::__shared_weak_count *)v1[2];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  group v11;

  v2 = *a1;
  v3 = **a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(_BYTE *)(v3 + 156))
  {
    v5 = (char *)v2[1];
    v11.gr_name = v5;
    if (v5)
      dispatch_retain((dispatch_object_t)v5);
    INTTrace::stop_sync((INTTrace *)v3, &v11);
    if (v5)
      dispatch_release((dispatch_object_t)v5);
  }
  else
  {
    v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11.gr_passwd) = 0;
      _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Trace is not enabled. Skip processing trace stop", (uint8_t *)&v11.gr_passwd, 2u);
    }
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  v7 = v2[1];
  if (v7)
    dispatch_release(v7);
  operator delete(v2);
  v8 = (std::__shared_weak_count *)a1[2];
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  operator delete(a1);
}

void sub_1A34E5A98(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  if (v4)
  {
    dispatch_release(v4);
    if (!v3)
    {
LABEL_3:
      v6 = v2[1];
      if (!v6)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if (!v3)
  {
    goto LABEL_3;
  }
  dispatch_group_leave(v3);
  dispatch_release(v3);
  v6 = v2[1];
  if (!v6)
  {
LABEL_4:
    operator delete(v2);
    v7 = (std::__shared_weak_count *)v1[2];
    if (!v7)
      goto LABEL_13;
    goto LABEL_9;
  }
LABEL_8:
  dispatch_release(v6);
  operator delete(v2);
  v7 = (std::__shared_weak_count *)v1[2];
  if (!v7)
    goto LABEL_13;
LABEL_9:
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_13:
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  dispatch_object_t object;
  void *v13;
  char v14;
  void *v15;
  char v16;
  _BYTE v17[8];
  _QWORD *v18;
  void *v19;
  char v20;
  void *__p;
  char v22;
  void *v23;
  char v24;
  _BYTE v25[8];
  _QWORD *v26;
  uint8_t buf[8];
  char v28;

  v2 = *a1;
  v3 = **a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  v5 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Abort received", buf, 2u);
  }
  if (!*(_QWORD *)(v3 + 328))
    goto LABEL_7;
  v28 = 0;
  buf[0] = 0;
  Timestamp::Timestamp((Timestamp *)v25);
  v24 = 0;
  LOBYTE(v23) = 0;
  v22 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v25, v26);
  if (v28 < 0)
  {
    operator delete(*(void **)buf);
    if (!*(_QWORD *)(v3 + 344))
      goto LABEL_11;
  }
  else
  {
LABEL_7:
    if (!*(_QWORD *)(v3 + 344))
      goto LABEL_11;
  }
  v20 = 0;
  LOBYTE(v19) = 0;
  Timestamp::Timestamp((Timestamp *)v17);
  v16 = 0;
  LOBYTE(v15) = 0;
  v14 = 0;
  LOBYTE(v13) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v17, v18);
  if (v20 < 0)
    operator delete(v19);
LABEL_11:
  v6 = *(_QWORD *)(v3 + 256);
  if (v6)
  {
    v7 = v2[1];
    object = v7;
    if (v7)
      dispatch_retain(v7);
    (*(void (**)(uint64_t, dispatch_object_t *))(*(_QWORD *)v6 + 144))(v6, &object);
    if (object)
      dispatch_release(object);
  }
  INTTrace::stopReader_sync((INTTrace *)v3);
  *(_BYTE *)(v3 + 284) = 0;
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  v8 = v2[1];
  if (v8)
    dispatch_release(v8);
  operator delete(v2);
  v9 = (std::__shared_weak_count *)a1[2];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  operator delete(a1);
}

void sub_1A34E5DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  _QWORD *v42;
  _QWORD *v43;
  NSObject *v44;
  NSObject *v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;

  if (object)
  {
    dispatch_release(object);
    if (!v44)
    {
LABEL_6:
      v46 = v43[1];
      if (v46)
        dispatch_release(v46);
      operator delete(v43);
      v47 = (std::__shared_weak_count *)v42[2];
      if (v47)
      {
        p_shared_owners = (unint64_t *)&v47->__shared_owners_;
        do
          v49 = __ldaxr(p_shared_owners);
        while (__stlxr(v49 - 1, p_shared_owners));
        if (!v49)
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
      }
      operator delete(v42);
      _Unwind_Resume(a1);
    }
  }
  else if (!v44)
  {
    goto LABEL_6;
  }
  dispatch_group_leave(v44);
  dispatch_release(v44);
  goto LABEL_6;
}

void sub_1A34E5EF4()
{
  uint64_t v0;

  if (!v0)
    JUMPOUT(0x1A34E5E98);
  JUMPOUT(0x1A34E5E88);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  dispatch_group_t *v2;
  dispatch_group_t v3;
  NSObject *isa;
  Class v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  dispatch_object_t object;
  uint8_t buf[16];

  v2 = *a1;
  v3 = (*a1)[1];
  isa = v3[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, isa, OS_LOG_TYPE_DEFAULT, "#I Shutdown received", buf, 2u);
  }
  v5 = v3[32].isa;
  if (v5)
  {
    v6 = v2[2];
    object = v6;
    if (v6)
      dispatch_retain(v6);
    (*(void (**)(Class, dispatch_object_t *))(*(_QWORD *)v5 + 144))(v5, &object);
    if (object)
      dispatch_release(object);
  }
  INTTrace::stopReader_sync((INTTrace *)v3);
  v7 = (std::__shared_weak_count *)v3[33].isa;
  v3[32].isa = 0;
  v3[33].isa = 0;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = (std::__shared_weak_count *)v3[31].isa;
  v3[30].isa = 0;
  v3[31].isa = 0;
  if (v10)
  {
    v11 = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  BYTE4(v3[35].isa) = 0;
  v13 = v2[2];
  if (v13)
    dispatch_release(v13);
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2)
      dispatch_release(*v2);
  }
  operator delete(v2);
  v14 = (std::__shared_weak_count *)a1[2];
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  operator delete(a1);
}

void sub_1A34E6098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  _QWORD *v10;
  NSObject **v11;
  NSObject *v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;

  if (object)
  {
    dispatch_release(object);
    v13 = v11[2];
    if (!v13)
    {
LABEL_3:
      v14 = *v11;
      if (!*v11)
        goto LABEL_9;
      goto LABEL_7;
    }
  }
  else
  {
    v13 = v11[2];
    if (!v13)
      goto LABEL_3;
  }
  dispatch_release(v13);
  v14 = *v11;
  if (!*v11)
    goto LABEL_9;
LABEL_7:
  dispatch_group_leave(v14);
  if (*v11)
    dispatch_release(*v11);
LABEL_9:
  operator delete(v11);
  v15 = (std::__shared_weak_count *)v10[2];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::enterLowPower(dispatch::group)::$_0>(INTTrace::enterLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::enterLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::enterLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  dispatch_group_t *v2;
  NSObject *isa;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint8_t v7[16];

  v2 = *a1;
  isa = (*a1)[1][5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_1A343C000, isa, OS_LOG_TYPE_DEFAULT, "#I EnterLowPower received", v7, 2u);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2)
      dispatch_release(*v2);
  }
  operator delete(v2);
  v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  operator delete(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::exitLowPower(dispatch::group)::$_0>(INTTrace::exitLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::exitLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::exitLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  dispatch_group_t *v2;
  NSObject *isa;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint8_t v7[16];

  v2 = *a1;
  isa = (*a1)[1][5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_1A343C000, isa, OS_LOG_TYPE_DEFAULT, "#I ExitLowPower received", v7, 2u);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2)
      dispatch_release(*v2);
  }
  operator delete(v2);
  v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  operator delete(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const void *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  CFTypeRef v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21[2];
  std::__shared_weak_count *v22;
  CFTypeRef cf;
  xpc_object_t v24;
  xpc_object_t object;
  void *__p;
  __int128 v27;

  v2 = *a1;
  v21[0] = v2;
  v3 = *(_QWORD *)(v2 + 8);
  if (!*(_BYTE *)(v3 + 156))
  {
    v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Trace is disabled. Skip snapshot processing!", (uint8_t *)&__p, 2u);
    }
    goto LABEL_29;
  }
  if (*(_QWORD *)(v3 + 328)
    && (__p = operator new(0x20uLL),
        v27 = xmmword_1A357F950,
        strcpy((char *)__p, "Trace State Configuration"),
        INTTrace::getStateAsDict_sync(v3, v2 + 16, &object),
        abm::trace::TraceInfo::push(),
        xpc_release(object),
        object = 0,
        SHIBYTE(v27) < 0))
  {
    operator delete(__p);
    if (!*(_QWORD *)(v3 + 344))
      goto LABEL_10;
  }
  else if (!*(_QWORD *)(v3 + 344))
  {
    goto LABEL_10;
  }
  __p = operator new(0x20uLL);
  v27 = xmmword_1A357F950;
  strcpy((char *)__p, "Trace State Configuration");
  INTTrace::getStateAsDict_sync(v3, v2 + 16, &v24);
  abm::trace::TraceInfo::push();
  xpc_release(v24);
  v24 = 0;
  if (SHIBYTE(v27) < 0)
    operator delete(__p);
LABEL_10:
  if (!*(_QWORD *)(v3 + 240))
    goto LABEL_29;
  capabilities::debug::environment((capabilities::debug *)a1);
  capabilities::debug::operator&();
  v5 = *(const void **)(v2 + 40);
  cf = v5;
  if (v5)
    CFRetain(v5);
  v6 = *(_QWORD *)(v3 + 336);
  __p = *(void **)(v3 + 328);
  *(_QWORD *)&v27 = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *(std::__shared_weak_count **)(v3 + 352);
  v21[1] = *(_QWORD *)(v3 + 344);
  v22 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  abm::trace::TraceReader::snapshot();
  if (!v22)
    goto LABEL_23;
  v12 = &v22->__shared_owners_;
  do
    v13 = __ldaxr((unint64_t *)v12);
  while (__stlxr(v13 - 1, (unint64_t *)v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
    v14 = (std::__shared_weak_count *)v27;
    if ((_QWORD)v27)
      goto LABEL_24;
  }
  else
  {
LABEL_23:
    v14 = (std::__shared_weak_count *)v27;
    if ((_QWORD)v27)
    {
LABEL_24:
      v15 = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
        v17 = cf;
        if (!cf)
          goto LABEL_29;
        goto LABEL_28;
      }
    }
  }
  v17 = cf;
  if (cf)
LABEL_28:
    CFRelease(v17);
LABEL_29:
  std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](v21);
  v18 = (std::__shared_weak_count *)a1[2];
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  operator delete(a1);
}

void sub_1A34E65C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, CFTypeRef cf, xpc_object_t object, xpc_object_t a14, void *__p, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20)
{
  _QWORD *v20;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;

  v22 = a11;
  if (a11)
  {
    p_shared_owners = (unint64_t *)&a11->__shared_owners_;
    do
      v24 = __ldaxr(p_shared_owners);
    while (__stlxr(v24 - 1, p_shared_owners));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = a16;
  if (a16)
  {
    v26 = (unint64_t *)&a16->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if (cf)
    CFRelease(cf);
  std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](&a9);
  v28 = (std::__shared_weak_count *)v20[2];
  if (v28)
  {
    v29 = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  operator delete(v20);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(const void **)(v2 + 40);
    if (v3)
      CFRelease(v3);
    if (*(char *)(v2 + 39) < 0)
      operator delete(*(void **)(v2 + 16));
    if (*(_QWORD *)v2)
    {
      dispatch_group_leave(*(dispatch_group_t *)v2);
      if (*(_QWORD *)v2)
        dispatch_release(*(dispatch_object_t *)v2);
    }
    operator delete((void *)v2);
  }
  return a1;
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::dumpState(dispatch::group,std::string)::$_0>(INTTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<INTTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  __int128 v6;
  void **v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::string v11;
  void *__p[2];
  char v13;
  uint8_t buf[4];
  void **v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t **)a1;
  v3 = **(_QWORD **)a1;
  v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  v5 = *(NSObject **)(v3 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    goto LABEL_12;
  if (*((char *)v2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v11, (const std::string::value_type *)v2[1], v2[2]);
  }
  else
  {
    v6 = *(_OWORD *)(v2 + 1);
    v11.__r_.__value_.__r.__words[2] = v2[3];
    *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v6;
  }
  INTTrace::dumpState_sync(v3, (uint64_t)&v11, __p);
  if (v13 >= 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  *(_DWORD *)buf = 136315138;
  v15 = v7;
  _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_23;
LABEL_12:
    if (!v4)
      goto LABEL_14;
    goto LABEL_13;
  }
  if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_12;
LABEL_23:
  operator delete(v11.__r_.__value_.__l.__data_);
  if (v4)
  {
LABEL_13:
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
LABEL_14:
  if (*((char *)v2 + 31) < 0)
    operator delete((void *)v2[1]);
  operator delete(v2);
  v8 = (std::__shared_weak_count *)*((_QWORD *)a1 + 2);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  operator delete(a1);
}

void sub_1A34E691C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _QWORD *v14;
  char *v15;
  NSObject *v16;
  void **v17;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;

  if (v16)
  {
    dispatch_group_leave(v16);
    dispatch_release(v16);
    if ((v15[31] & 0x80000000) == 0)
    {
LABEL_3:
      operator delete(v15);
      v19 = (std::__shared_weak_count *)v14[2];
      if (!v19)
        goto LABEL_11;
      goto LABEL_7;
    }
  }
  else if ((v15[31] & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v17);
  operator delete(v15);
  v19 = (std::__shared_weak_count *)v14[2];
  if (!v19)
    goto LABEL_11;
LABEL_7:
  p_shared_owners = (unint64_t *)&v19->__shared_owners_;
  do
    v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_11:
  operator delete(v14);
  _Unwind_Resume(a1);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const char **v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;
  int v10;
  _BYTE *v11;
  char v12;
  char *v13;
  char Size_sync;
  const char *v15;
  uint64_t v16;
  NSObject *v17;
  const char *v18;
  int v19;
  size_t v20;
  unint64_t v21;
  std::string *p_dst;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  int v26;
  const std::string::value_type *v27;
  std::string::size_type v28;
  std::string *v29;
  __int128 v30;
  int v31;
  size_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  const std::string::value_type *v38;
  uint64_t v39;
  const std::string::value_type *v40;
  int v41;
  const std::string::value_type *v42;
  std::string::size_type v43;
  std::string *v44;
  __int128 v45;
  char v46[8];
  _QWORD *v47;
  std::string v48;
  void *__p;
  char v50;
  void *v51;
  char v52;
  char v53[8];
  _QWORD *v54;
  std::string __dst;
  __int128 v56;
  std::string::size_type v57;
  std::string v58;
  char *v59;
  std::string buf;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(v1 + 40);
  v3 = (const char **)(v1 + 16);
  v4 = *(char *)(v1 + 39);
  if ((v4 & 0x80000000) == 0)
  {
    if (strcasecmp((const char *)(v1 + 16), "Enabled"))
    {
      if (strcasecmp((const char *)(v1 + 16), "Live_Filter_Setting"))
      {
        if (strcasecmp((const char *)(v1 + 16), "PrivacyLevel"))
        {
          if (strcasecmp((const char *)(v1 + 16), "History"))
          {
            if (strcasecmp((const char *)(v1 + 16), "Mode"))
            {
              if (strcasecmp((const char *)(v1 + 16), "TraceOwnership"))
              {
                if (strcasecmp((const char *)(v1 + 16), "File"))
                {
                  if (strcasecmp((const char *)(v1 + 16), "MaxMemoryFileCount"))
                  {
                    if (strcasecmp((const char *)(v1 + 16), "FileSize"))
                    {
                      if (strcasecmp((const char *)(v1 + 16), "SizeIO"))
                      {
                        if (strcasecmp((const char *)(v1 + 16), "NumberOfReadIO"))
                        {
                          if (strcasecmp((const char *)(v1 + 16), "Enabled_During_Sleep"))
                          {
                            v8 = (const char *)(v1 + 16);
                            if (strcasecmp((const char *)(v1 + 16), "File_Sleep"))
                              goto LABEL_15;
                            goto LABEL_33;
                          }
                          goto LABEL_99;
                        }
                        goto LABEL_93;
                      }
                      goto LABEL_87;
                    }
                    goto LABEL_81;
                  }
                  goto LABEL_75;
                }
                goto LABEL_69;
              }
              goto LABEL_63;
            }
            goto LABEL_57;
          }
          goto LABEL_51;
        }
        goto LABEL_45;
      }
      goto LABEL_41;
    }
LABEL_37:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&buf, "Enabled");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropEnabled_sync(v2, (NSObject **)&v59, (char *)&buf, (const char *)&v58);
LABEL_138:
    **(_BYTE **)v1 = Size_sync;
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v58.__r_.__value_.__l.__data_);
      if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_140:
        if (!v13)
          goto LABEL_142;
        goto LABEL_141;
      }
    }
    else if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_140;
    }
    operator delete(buf.__r_.__value_.__l.__data_);
    if (!v13)
      goto LABEL_142;
LABEL_141:
    dispatch_release((dispatch_object_t)v13);
    goto LABEL_142;
  }
  v8 = *v3;
  if (!strcasecmp(*v3, "Enabled"))
    goto LABEL_37;
  if (!strcasecmp(v8, "Live_Filter_Setting"))
  {
LABEL_41:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 19;
    strcpy((char *)&buf, "Live_Filter_Setting");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropLiveFilterSetting_sync(v2, &v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "PrivacyLevel"))
  {
LABEL_45:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&buf, "PrivacyLevel");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropPrivacyLevel_sync(v2, (NSObject **)&v59, (char *)&buf, &v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "History"))
  {
LABEL_51:
    v13 = *(char **)(v1 + 48);
    if (v13)
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&buf, "History");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropHistory_sync(v2, v5, (char *)&buf, &v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "Mode"))
  {
LABEL_57:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&buf, "Mode");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropTraceMode_sync(v2, (dispatch_object_t *)&v59, (char *)&buf, &v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "TraceOwnership"))
  {
LABEL_63:
    v13 = *(char **)(v1 + 48);
    if (v13)
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&buf, "TraceOwnership");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropTraceOwnership_sync(v2, v6, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "File"))
  {
LABEL_69:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&buf, "File");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropConfig_sync(v2, (dispatch_object_t *)&v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "MaxMemoryFileCount"))
  {
LABEL_75:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 18;
    strcpy((char *)&buf, "MaxMemoryFileCount");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropMaxMemoryFileCount_sync(v2, (dispatch_object_t *)&v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "FileSize"))
  {
LABEL_81:
    v13 = *(char **)(v1 + 48);
    if (v13)
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&buf, "FileSize");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropFileSize_sync(v2, v7, (char *)&buf, &v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "SizeIO"))
  {
LABEL_87:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&buf, "SizeIO");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropTransportReadSize_sync(v2, (NSObject **)&v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "NumberOfReadIO"))
  {
LABEL_93:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&buf, "NumberOfReadIO");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropTransportReadCount_sync(v2, (NSObject **)&v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "Enabled_During_Sleep"))
  {
LABEL_99:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 20;
    strcpy((char *)&buf, "Enabled_During_Sleep");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropSleepTraceMode_sync(v2, (dispatch_object_t *)&v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  if (!strcasecmp(v8, "File_Sleep"))
  {
LABEL_33:
    v13 = *(char **)(v1 + 48);
    v59 = v13;
    if (v13)
      dispatch_retain((dispatch_object_t)v13);
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 10;
    strcpy((char *)&buf, "File_Sleep");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropSleepConfig_sync(v2, (dispatch_object_t *)&v59, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
LABEL_15:
  if (!strcasecmp(v8, "Error_Handling"))
  {
    v13 = *(char **)(v1 + 48);
    if (v13)
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&buf, "Error_Handling");
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropErrorHandling_sync(v2, v9, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  strcpy((char *)&buf, "CellularLoggingAllowed");
  *((_BYTE *)&buf.__r_.__value_.__s + 23) = 22;
  if (util::equal_nocase((const char *)(v1 + 16), (const char *)&buf))
  {
    v10 = prop::bbtrace::set((char *)(v1 + 16), (const char *)(v1 + 56));
    v11 = *(_BYTE **)v1;
    **(_BYTE **)v1 = v10;
    if (v10)
    {
      memset(&buf, 0, sizeof(buf));
      if (prop::bbtrace::get((char *)(v1 + 16), (uint64_t)&buf))
        v12 = util::convert<BOOL>(&buf, (BOOL *)(v2 + 376), 0);
      else
        v12 = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
      **(_BYTE **)v1 = v12;
    }
    else
    {
      *v11 = 0;
    }
    goto LABEL_142;
  }
  v15 = (const char *)(v1 + 16);
  if (v4 < 0)
    v15 = *v3;
  if (!strcasecmp(v15, "Retain_Previous_Trace"))
  {
    v13 = *(char **)(v1 + 48);
    if (v13)
    {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
      LOBYTE(v4) = *(_BYTE *)(v1 + 39);
    }
    if ((v4 & 0x80) != 0)
    {
      std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)(v1 + 16), *(_QWORD *)(v1 + 24));
    }
    else
    {
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)v3;
      buf.__r_.__value_.__r.__words[2] = *(_QWORD *)(v1 + 32);
    }
    if (*(char *)(v1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v1 + 56), *(_QWORD *)(v1 + 64));
    else
      v58 = *(std::string *)(v1 + 56);
    Size_sync = INTTrace::setPropRetainPreviousTrace_sync(v2, v16, (char *)&buf, (const char *)&v58);
    goto LABEL_138;
  }
  v17 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v18 = (const char *)(v1 + 16);
    if (v4 < 0)
      v18 = *v3;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, "Key not handled: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_142:
  if (!*(_QWORD *)(v2 + 328))
    goto LABEL_168;
  v19 = *(char *)(v1 + 39);
  if (v19 >= 0)
    v20 = *(unsigned __int8 *)(v1 + 39);
  else
    v20 = *(_QWORD *)(v1 + 24);
  v21 = v20 + 3;
  memset(&__dst, 170, sizeof(__dst));
  if (v20 + 3 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v21 >= 0x17)
  {
    v23 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v21 | 7) != 0x17)
      v23 = v21 | 7;
    v24 = v23 + 1;
    p_dst = (std::string *)operator new(v23 + 1);
    __dst.__r_.__value_.__l.__size_ = v20 + 3;
    __dst.__r_.__value_.__r.__words[2] = v24 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v20 + 3;
    if (!v20)
      goto LABEL_160;
  }
  if (v19 >= 0)
    v25 = (const char *)(v1 + 16);
  else
    v25 = *v3;
  memmove(p_dst, v25, v20);
LABEL_160:
  *(_DWORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v20) = 2112800;
  v26 = *(char *)(v1 + 79);
  if (v26 >= 0)
    v27 = (const std::string::value_type *)(v1 + 56);
  else
    v27 = *(const std::string::value_type **)(v1 + 56);
  if (v26 >= 0)
    v28 = *(unsigned __int8 *)(v1 + 79);
  else
    v28 = *(_QWORD *)(v1 + 64);
  v29 = std::string::append(&__dst, v27, v28);
  v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v57 = v29->__r_.__value_.__r.__words[2];
  v56 = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  Timestamp::Timestamp((Timestamp *)v53);
  v52 = 0;
  LOBYTE(v51) = 0;
  v50 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v53, v54);
  if ((SHIBYTE(v57) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_168;
LABEL_193:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (!*(_QWORD *)(v2 + 344))
      return;
    goto LABEL_169;
  }
  operator delete((void *)v56);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_193;
LABEL_168:
  if (!*(_QWORD *)(v2 + 344))
    return;
LABEL_169:
  v31 = *(char *)(v1 + 39);
  if (v31 >= 0)
    v32 = *(unsigned __int8 *)(v1 + 39);
  else
    v32 = *(_QWORD *)(v1 + 24);
  v33 = v32 + 3;
  memset(&v48, 170, sizeof(v48));
  if (v32 + 3 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v33 >= 0x17)
  {
    v35 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v33 | 7) != 0x17)
      v35 = v33 | 7;
    v36 = v35 + 1;
    v34 = (char *)operator new(v35 + 1);
    v48.__r_.__value_.__l.__size_ = v32 + 3;
    v48.__r_.__value_.__r.__words[2] = v36 | 0x8000000000000000;
    v48.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
  }
  else
  {
    memset(&v48, 0, sizeof(v48));
    v34 = (char *)&v48;
    *((_BYTE *)&v48.__r_.__value_.__s + 23) = v32 + 3;
    if (!v32)
      goto LABEL_183;
  }
  if (v31 >= 0)
    v37 = (const char *)(v1 + 16);
  else
    v37 = *v3;
  memmove(v34, v37, v32);
LABEL_183:
  *(_DWORD *)&v34[v32] = 2112800;
  v40 = *(const std::string::value_type **)(v1 + 56);
  v39 = v1 + 56;
  v38 = v40;
  v41 = *(char *)(v39 + 23);
  if (v41 >= 0)
    v42 = (const std::string::value_type *)v39;
  else
    v42 = v38;
  if (v41 >= 0)
    v43 = *(unsigned __int8 *)(v39 + 23);
  else
    v43 = *(_QWORD *)(v39 + 8);
  v44 = std::string::append(&v48, v42, v43);
  v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  Timestamp::Timestamp((Timestamp *)v46);
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v46, v47);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  else if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    return;
  }
  operator delete(v48.__r_.__value_.__l.__data_);
}

void sub_1A34E7820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  NSObject *v51;
  uint64_t v52;

  if (*(char *)(v52 - 105) < 0)
  {
    operator delete(*(void **)(v52 - 128));
    if (v51)
    {
LABEL_5:
      dispatch_release(v51);
      _Unwind_Resume(a1);
    }
  }
  else if (v51)
  {
    goto LABEL_5;
  }
  _Unwind_Resume(a1);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const char **v3;
  const char *v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  std::string::size_type v12;
  char v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  size_t v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  void *v24;
  size_t v25;
  void *v26;
  size_t v27;
  unsigned int v28;
  void *v29;
  size_t v30;
  std::string *v31;
  size_t v32;
  unsigned int v33;
  uint64_t v34;
  __int128 v35;
  int v36;
  std::string *p_buf;
  size_t size;
  int v39;
  void *__p[2];
  char v41;
  std::string buf;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(v1 + 40);
  v3 = (const char **)(v1 + 16);
  if ((*(char *)(v1 + 39) & 0x80000000) == 0)
  {
    if (strcasecmp((const char *)(v1 + 16), "Enabled"))
    {
      if (strcasecmp((const char *)(v1 + 16), "Live_Filter_Setting"))
      {
        if (strcasecmp((const char *)(v1 + 16), "History"))
        {
          if (strcasecmp((const char *)(v1 + 16), "Mode"))
          {
            if (strcasecmp((const char *)(v1 + 16), "TraceOwnership"))
            {
              if (strcasecmp((const char *)(v1 + 16), "File"))
              {
                if (strcasecmp((const char *)(v1 + 16), "State"))
                {
                  if (strcasecmp((const char *)(v1 + 16), "MaxMemoryFileCount"))
                  {
                    if (strcasecmp((const char *)(v1 + 16), "FileSize"))
                    {
                      if (strcasecmp((const char *)(v1 + 16), "SizeIO"))
                      {
                        if (strcasecmp((const char *)(v1 + 16), "NumberOfReadIO"))
                        {
                          if (strcasecmp((const char *)(v1 + 16), "Enabled_During_Sleep"))
                          {
                            if (strcasecmp((const char *)(v1 + 16), "File_Sleep"))
                            {
                              if (strcasecmp((const char *)(v1 + 16), "Error_Handling"))
                              {
                                v4 = (const char *)(v1 + 16);
                                if (strcasecmp((const char *)(v1 + 16), "CellularLoggingAllowed"))
                                {
LABEL_17:
                                  if (strcasecmp(v4, "Retain_Previous_Trace"))
                                  {
                                    **(_BYTE **)v1 = 0;
                                    v5 = *(NSObject **)(v2 + 40);
                                    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
                                    {
                                      if (*(char *)(v1 + 39) < 0)
                                        v3 = (const char **)*v3;
                                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
                                      _os_log_error_impl(&dword_1A343C000, v5, OS_LOG_TYPE_ERROR, "Key not handled: %s", (uint8_t *)&buf, 0xCu);
                                    }
                                    return;
                                  }
                                  v39 = *(unsigned __int8 *)(v2 + 384);
                                  __p[0] = 0;
                                  *(void **)((char *)__p + 7) = 0;
                                  std::to_string(&buf, v39);
                                  goto LABEL_43;
                                }
                                goto LABEL_37;
                              }
                              goto LABEL_89;
                            }
LABEL_85:
                            v15 = (_QWORD *)(v2 + 296);
                            v16 = *(_QWORD *)(v1 + 8);
                            if (v16 == v2 + 296)
                              return;
                            v17 = *(unsigned __int8 *)(v2 + 319);
                            if ((*(char *)(v16 + 23) & 0x80000000) == 0)
                            {
                              if ((v17 & 0x80) != 0)
                              {
                                v29 = *(void **)(v2 + 296);
                                v30 = *(_QWORD *)(v2 + 304);
                                goto LABEL_67;
                              }
                              goto LABEL_50;
                            }
                            v23 = (char)v17;
                            v24 = *(void **)(v2 + 296);
                            v25 = *(_QWORD *)(v2 + 304);
                            goto LABEL_58;
                          }
LABEL_81:
                          capabilities::trace::asString();
                          v34 = *(_QWORD *)(v1 + 8);
                          if ((std::string *)v34 != &buf)
                          {
                            if (*(char *)(v34 + 23) < 0)
                            {
                              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                p_buf = &buf;
                              else
                                p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                              else
                                size = buf.__r_.__value_.__l.__size_;
                              std::string::__assign_no_alias<false>((void **)v34, p_buf, size);
                            }
                            else if ((*((_BYTE *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
                            {
                              std::string::__assign_no_alias<true>((_QWORD *)v34, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                            }
                            else
                            {
                              v35 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                              *(_QWORD *)(v34 + 16) = *((_QWORD *)&buf.__r_.__value_.__l + 2);
                              *(_OWORD *)v34 = v35;
                            }
                          }
                          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(buf.__r_.__value_.__l.__data_);
                          return;
                        }
                        goto LABEL_75;
                      }
                      goto LABEL_65;
                    }
                    goto LABEL_56;
                  }
                  goto LABEL_55;
                }
                goto LABEL_51;
              }
LABEL_47:
              v15 = (_QWORD *)(v2 + 184);
              v16 = *(_QWORD *)(v1 + 8);
              if (v16 == v2 + 184)
                return;
              v17 = *(unsigned __int8 *)(v2 + 207);
              if ((*(char *)(v16 + 23) & 0x80000000) == 0)
              {
                if ((v17 & 0x80) != 0)
                {
                  v29 = *(void **)(v2 + 184);
                  v30 = *(_QWORD *)(v2 + 192);
LABEL_67:
                  std::string::__assign_no_alias<true>((_QWORD *)v16, v29, v30);
                  return;
                }
LABEL_50:
                v18 = *(_OWORD *)v15;
                *(_QWORD *)(v16 + 16) = v15[2];
                *(_OWORD *)v16 = v18;
                return;
              }
              v23 = (char)v17;
              v24 = *(void **)(v2 + 184);
              v25 = *(_QWORD *)(v2 + 192);
LABEL_58:
              if (v23 >= 0)
                v26 = v15;
              else
                v26 = v24;
              if (v23 >= 0)
                v27 = v17;
              else
                v27 = v25;
              std::string::__assign_no_alias<false>((void **)v16, v26, v27);
              return;
            }
LABEL_42:
            v11 = *(_DWORD *)(v2 + 232);
            __p[0] = 0;
            *(void **)((char *)__p + 7) = 0;
            std::to_string(&buf, v11);
            goto LABEL_43;
          }
LABEL_41:
          v10 = *(_DWORD *)(v2 + 152);
          __p[0] = 0;
          *(void **)((char *)__p + 7) = 0;
          std::to_string(&buf, v10);
          goto LABEL_43;
        }
LABEL_40:
        v9 = *(_DWORD *)(v2 + 164);
        __p[0] = 0;
        *(void **)((char *)__p + 7) = 0;
        std::to_string(&buf, v9);
        goto LABEL_43;
      }
LABEL_39:
      v8 = *(_DWORD *)(v2 + 168);
      __p[0] = 0;
      *(void **)((char *)__p + 7) = 0;
      std::to_string(&buf, v8);
      goto LABEL_43;
    }
LABEL_38:
    v7 = *(unsigned __int8 *)(v2 + 156);
    __p[0] = 0;
    *(void **)((char *)__p + 7) = 0;
    std::to_string(&buf, v7);
    goto LABEL_43;
  }
  v4 = *v3;
  if (!strcasecmp(*v3, "Enabled"))
    goto LABEL_38;
  if (!strcasecmp(v4, "Live_Filter_Setting"))
    goto LABEL_39;
  if (!strcasecmp(v4, "History"))
    goto LABEL_40;
  if (!strcasecmp(v4, "Mode"))
    goto LABEL_41;
  if (!strcasecmp(v4, "TraceOwnership"))
    goto LABEL_42;
  if (!strcasecmp(v4, "File"))
    goto LABEL_47;
  if (strcasecmp(v4, "State"))
  {
    if (strcasecmp(v4, "MaxMemoryFileCount"))
    {
      if (strcasecmp(v4, "FileSize"))
      {
        if (strcasecmp(v4, "SizeIO"))
        {
          if (strcasecmp(v4, "NumberOfReadIO"))
          {
            if (strcasecmp(v4, "Enabled_During_Sleep"))
            {
              if (strcasecmp(v4, "File_Sleep"))
              {
                if (strcasecmp(v4, "Error_Handling"))
                {
                  if (strcasecmp(v4, "CellularLoggingAllowed"))
                    goto LABEL_17;
LABEL_37:
                  v6 = *(unsigned __int8 *)(v2 + 376);
                  __p[0] = 0;
                  *(void **)((char *)__p + 7) = 0;
                  std::to_string(&buf, v6);
LABEL_43:
                  __p[0] = (void *)buf.__r_.__value_.__l.__size_;
                  v12 = buf.__r_.__value_.__r.__words[0];
                  *(void **)((char *)__p + 7) = *(void **)((char *)&buf.__r_.__value_.__r.__words[1] + 7);
                  v13 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  v14 = *(_QWORD *)(v1 + 8);
                  if (*(char *)(v14 + 23) < 0)
                    operator delete(*(void **)v14);
                  *(_QWORD *)v14 = v12;
                  *(void **)(v14 + 8) = __p[0];
                  *(void **)(v14 + 15) = *(void **)((char *)__p + 7);
                  *(_BYTE *)(v14 + 23) = v13;
                  return;
                }
LABEL_89:
                v36 = *(_DWORD *)(v2 + 380);
                __p[0] = 0;
                *(void **)((char *)__p + 7) = 0;
                std::to_string(&buf, v36);
                goto LABEL_43;
              }
              goto LABEL_85;
            }
            goto LABEL_81;
          }
LABEL_75:
          v33 = *(_DWORD *)(v2 + 280);
          __p[0] = 0;
          *(void **)((char *)__p + 7) = 0;
          std::to_string(&buf, v33);
          goto LABEL_43;
        }
LABEL_65:
        v28 = *(_DWORD *)(v2 + 276);
        __p[0] = 0;
        *(void **)((char *)__p + 7) = 0;
        std::to_string(&buf, v28);
        goto LABEL_43;
      }
LABEL_56:
      v22 = *(_DWORD *)(v2 + 172);
      __p[0] = 0;
      *(void **)((char *)__p + 7) = 0;
      std::to_string(&buf, v22);
      goto LABEL_43;
    }
LABEL_55:
    v21 = *(_DWORD *)(v2 + 176);
    __p[0] = 0;
    *(void **)((char *)__p + 7) = 0;
    std::to_string(&buf, v21);
    goto LABEL_43;
  }
LABEL_51:
  v41 = 14;
  strcpy((char *)__p, "Get dump state");
  INTTrace::dumpState_sync(v2, (uint64_t)__p, &buf);
  v19 = *(_QWORD *)(v1 + 8);
  if ((std::string *)v19 != &buf)
  {
    if (*(char *)(v19 + 23) < 0)
    {
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v31 = &buf;
      else
        v31 = (std::string *)buf.__r_.__value_.__r.__words[0];
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v32 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      else
        v32 = buf.__r_.__value_.__l.__size_;
      std::string::__assign_no_alias<false>((void **)v19, v31, v32);
    }
    else if ((*((_BYTE *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((_QWORD *)v19, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else
    {
      v20 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(_QWORD *)(v19 + 16) = *((_QWORD *)&buf.__r_.__value_.__l + 2);
      *(_OWORD *)v19 = v20;
    }
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  if (v41 < 0)
    operator delete(__p[0]);
}

void sub_1A34E81EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    if (*(char *)(*(_QWORD *)(v21 + 8) + 23) < 0)
      JUMPOUT(0x1A34E7EF0);
    JUMPOUT(0x1A34E7EF8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __cxx_global_var_init_50()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t __cxx_global_var_init_51()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<SharedData>::~PthreadMutexGuardPolicy, &ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t __cxx_global_var_init_52()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<CommandDriverFactory>::~PthreadMutexGuardPolicy, &ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance, &dword_1A343C000);
  }
  return result;
}

double BasebandIPCTrace::createInternal@<D0>(_OWORD *a1@<X8>)
{
  BasebandIPCTrace *v3;
  double result;
  __int128 v5;

  v3 = (BasebandIPCTrace *)operator new(0xB8uLL);
  BasebandIPCTrace::BasebandIPCTrace(v3);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<BasebandIPCTrace>::shared_ptr[abi:ne180100]<BasebandIPCTrace,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  result = *(double *)&v5;
  *a1 = v5;
  return result;
}

void sub_1A34E847C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A34E8490(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void BasebandIPCTrace::BasebandIPCTrace(BasebandIPCTrace *this)
{
  char isSupported;
  void *v3[2];
  char v4;
  void *__p[2];
  char v6;

  v6 = 11;
  strcpy((char *)__p, "trace.bbipc");
  Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_1E4A0B0A0;
  v4 = 11;
  strcpy((char *)v3, "BasebandIPC");
  isSupported = abm::trace::isSupported((uint64_t)v3);
  if (v4 < 0)
    operator delete(v3[0]);
  *((_BYTE *)this + 152) = isSupported;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 20) = 0;
}

void sub_1A34E8568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  Trace *v14;

  if (a14 < 0)
    operator delete(__p);
  Trace::~Trace(v14);
  _Unwind_Resume(a1);
}

void sub_1A34E858C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t BasebandIPCTrace::init(uint64_t a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  NSObject *v10;
  int v11;
  _BOOL4 v12;
  uint64_t v13;
  void *v15[2];
  char v16;
  dispatch_object_t object;
  uint64_t v18;
  std::__shared_weak_count *v19;
  std::string v20;
  std::string v21;
  void *__p[2];
  char v23;
  std::string v24;
  std::string v25;

  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    v7 = (std::__shared_weak_count *)a3[1];
    v18 = *a3;
    v19 = v7;
    if (!v7)
      goto LABEL_7;
  }
  else
  {
    v20 = *(std::string *)a2;
    v7 = (std::__shared_weak_count *)a3[1];
    v18 = *a3;
    v19 = v7;
    if (!v7)
      goto LABEL_7;
  }
  p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
  do
    v9 = __ldxr(p_shared_weak_owners);
  while (__stxr(v9 + 1, p_shared_weak_owners));
LABEL_7:
  v10 = *a4;
  object = v10;
  if (v10)
    dispatch_retain(v10);
  v11 = Trace::init(a1, (void **)&v20.__r_.__value_.__l.__data_, &v18, &object);
  if (object)
    dispatch_release(object);
  if (v19)
    std::__shared_weak_count::__release_weak(v19);
  if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v11)
      goto LABEL_15;
    return 0;
  }
  operator delete(v20.__r_.__value_.__l.__data_);
  if (!v11)
    return 0;
LABEL_15:
  v16 = 7;
  strcpy((char *)v15, "Enabled");
  memset(&v21, 0, sizeof(v21));
  v23 = 11;
  strcpy((char *)__p, "BasebandIPC");
  memset(&v25, 0, sizeof(v25));
  v12 = defaults::get((char *)__p, (char *)v15, &v25);
  if (v12)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)v15, (uint64_t)&v25, &v24);
    v21 = v24;
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v25.__r_.__value_.__l.__data_);
    if ((v23 & 0x80000000) == 0)
    {
LABEL_19:
      if (v12)
        goto LABEL_20;
LABEL_27:
      v13 = 0;
      if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_29;
      goto LABEL_28;
    }
  }
  else if ((v23 & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(__p[0]);
  if (!v12)
    goto LABEL_27;
LABEL_20:
  v13 = util::convert<BOOL>(&v21, (BOOL *)(a1 + 152), 0);
  if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_29;
LABEL_28:
  operator delete(v21.__r_.__value_.__l.__data_);
LABEL_29:
  if ((v16 & 0x80000000) == 0)
    return v13;
  operator delete(v15[0]);
  return v13;
}

void sub_1A34E87B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a30 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

void BasebandIPCTrace::~BasebandIPCTrace(BasebandIPCTrace *this)
{
  const void *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  *(_QWORD *)this = off_1E4A0B0A0;
  v2 = (const void *)*((_QWORD *)this + 22);
  if (v2)
    CFRelease(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  if (!v3)
    goto LABEL_7;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    Trace::~Trace(this);
  }
  else
  {
LABEL_7:
    Trace::~Trace(this);
  }
}

{
  const void *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  *(_QWORD *)this = off_1E4A0B0A0;
  v2 = (const void *)*((_QWORD *)this + 22);
  if (v2)
    CFRelease(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  if (!v3)
    goto LABEL_7;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    Trace::~Trace(this);
  }
  else
  {
LABEL_7:
    Trace::~Trace(this);
  }
}

{
  const void *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  void *v6;

  *(_QWORD *)this = off_1E4A0B0A0;
  v2 = (const void *)*((_QWORD *)this + 22);
  if (v2)
    CFRelease(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  if (!v3)
    goto LABEL_7;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    Trace::~Trace(this);
  }
  else
  {
LABEL_7:
    Trace::~Trace(this);
  }
  operator delete(v6);
}

void BasebandIPCTrace::start(uint64_t a1, dispatch_object_t *a2)
{
  NSObject *v4;
  NSObject *v5;
  _QWORD v6[5];
  dispatch_group_t group;
  dispatch_object_t object;

  v4 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v4);
  }
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 1174405120;
  v6[2] = ___ZN16BasebandIPCTrace5startEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
  v6[3] = &__block_descriptor_tmp_15;
  v6[4] = a1;
  group = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  v5 = *a2;
  object = v5;
  if (v5)
    dispatch_retain(v5);
  ctu::SharedSynchronizable<Trace>::execute_wrapped((uint64_t *)(a1 + 72), (uint64_t)v6);
  if (object)
    dispatch_release(object);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
}

void ___ZN16BasebandIPCTrace5startEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  char *v5;
  group v6;

  *(_QWORD *)&v6.gr_gid = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(unsigned __int8 *)(v2 + 152);
    LODWORD(v6.gr_passwd) = 67109120;
    HIDWORD(v6.gr_passwd) = v4;
    _os_log_impl(&dword_1A343C000, v3, OS_LOG_TYPE_DEFAULT, "#I Starting with enable = %d", (uint8_t *)&v6.gr_passwd, 8u);
  }
  if (*(_BYTE *)(v2 + 152))
  {
    v5 = *(char **)(a1 + 48);
    v6.gr_name = v5;
    if (v5)
      dispatch_retain((dispatch_object_t)v5);
    BasebandIPCTrace::start_sync((BasebandIPCTrace *)v2, &v6);
    if (v5)
      dispatch_release((dispatch_object_t)v5);
  }
}

void sub_1A34E8BA0(_Unwind_Exception *exception_object)
{
  NSObject *v1;

  if (v1)
    dispatch_release(v1);
  _Unwind_Resume(exception_object);
}

void BasebandIPCTrace::start_sync(BasebandIPCTrace *this, group *a2)
{
  char *gr_name;
  NSObject *v4;
  std::string::size_type v5;
  NSObject *v6;
  CommandDriverFactory *v7;
  const void *v8;
  __int128 v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *size;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unsigned __int8 v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  capabilities::radio *v22;
  __int128 v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  _BOOL4 v36;
  std::string::size_type v37;
  char v38;
  uint64_t v39;
  NSObject *v40;
  _BOOL4 v41;
  std::string::value_type *v42;
  std::string::size_type v43;
  char v44;
  uint64_t v45;
  NSObject *v46;
  char *v47;
  std::string::size_type v48;
  std::string::size_type v49;
  uint64_t *v50;
  std::string::size_type p_size;
  uint64_t **v52;
  uint64_t *v53;
  uint64_t **v54;
  BOOL v55;
  int v56;
  uint64_t *v57;
  size_t v58;
  int v59;
  const void *v60;
  size_t v61;
  size_t v62;
  int v63;
  uint64_t **v64;
  uint64_t **v65;
  size_t v66;
  uint64_t v67;
  const void *v68;
  size_t v69;
  size_t v70;
  int v71;
  int v72;
  uint64_t ***v73;
  std::string *v74;
  uint64_t *v75;
  std::string *v76;
  __int128 v77;
  std::string *v78;
  dispatch_time_t v79;
  void *v80;
  NSObject *v81;
  uint64_t v82;
  NSObject *v83;
  NSObject *v84;
  std::string::value_type *__s;
  std::string::value_type *__sa;
  void *v87;
  dispatch_object_t object;
  uint64_t **v89;
  uint64_t *v90;
  uint64_t v91;
  _QWORD aBlock[5];
  dispatch_group_t group;
  dispatch_group_t v94;
  std::string v95;
  void *v96[2];
  char v97;
  std::string v98;
  void *v99[2];
  char v100;
  void *__p[2];
  char v102;
  _DWORD v103[2];
  _DWORD v104[2];
  __int128 v105;
  std::string buf;
  void *v107;
  __int128 *v108;
  const void *v109[2];
  char v110;
  std::string v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  gr_name = a2->gr_name;
  if (a2->gr_name)
  {
    dispatch_retain((dispatch_object_t)a2->gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
  }
  v4 = *((_QWORD *)this + 18);
  if (v4)
  {
    dispatch_retain(*((dispatch_object_t *)this + 18));
    dispatch_group_enter(v4);
  }
  v5 = MEMORY[0x1E0C809B0];
  v83 = v4;
  v84 = gr_name;
  if (*((_QWORD *)this + 20))
    goto LABEL_89;
  v6 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Create command driver", (uint8_t *)&buf, 2u);
  }
  v7 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  v8 = (const void *)off_1ED114670;
  if (!off_1ED114670)
  {
    CommandDriverFactory::create_default_global(v7);
    v9 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
    v10 = (std::__shared_weak_count *)*(&off_1ED114670 + 1);
    off_1ED114670 = v9;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_)
    {
      v14 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    v8 = (const void *)off_1ED114670;
  }
  v109[0] = v8;
  v109[1] = *((const void **)&off_1ED114670 + 1);
  if (*(&off_1ED114670 + 1))
  {
    v16 = (unint64_t *)(*(&off_1ED114670 + 1) + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
  }
  buf.__r_.__value_.__r.__words[0] = v5;
  buf.__r_.__value_.__l.__size_ = 0x40000000;
  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  v107 = &__block_descriptor_tmp_13_6;
  v108 = &GetABMLogServer(void)::sLogServer;
  if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
  {
    v19 = *((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
    v105 = GetABMLogServer(void)::sLogServer;
    if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
      goto LABEL_28;
  }
  else
  {
    dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, &buf);
    v19 = *((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
    v105 = GetABMLogServer(void)::sLogServer;
    if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
      goto LABEL_28;
  }
  v20 = (unint64_t *)(v19 + 8);
  do
    v21 = __ldxr(v20);
  while (__stxr(v21 + 1, v20));
LABEL_28:
  v22 = (capabilities::radio *)(*(_QWORD *(**)(std::string *__return_ptr, const void *, __int128 *))(*(_QWORD *)v8 + 120))(&v111, v8, &v105);
  v23 = *(_OWORD *)&v111.__r_.__value_.__l.__data_;
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = 0uLL;
  v24 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  *((_OWORD *)this + 10) = v23;
  if (v24)
  {
    v25 = (unint64_t *)&v24->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = (std::__shared_weak_count *)v111.__r_.__value_.__l.__size_;
  if (v111.__r_.__value_.__l.__size_)
  {
    v28 = (unint64_t *)(v111.__r_.__value_.__l.__size_ + 8);
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = (std::__shared_weak_count *)*((_QWORD *)&v105 + 1);
  if (*((_QWORD *)&v105 + 1))
  {
    v31 = (unint64_t *)(*((_QWORD *)&v105 + 1) + 8);
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = (std::__shared_weak_count *)v109[1];
  if (v109[1])
  {
    v34 = (unint64_t *)((char *)v109[1] + 8);
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  if (!capabilities::radio::mav20Plus(v22))
    goto LABEL_89;
  *(_DWORD *)((char *)v104 + 3) = 0;
  v104[0] = 0;
  *(_DWORD *)((char *)v103 + 3) = 0;
  v103[0] = 0;
  v102 = 8;
  strcpy((char *)__p, "LogLevel");
  v110 = 11;
  strcpy((char *)v109, "BasebandIPC");
  memset(&buf, 0, sizeof(buf));
  v36 = defaults::get((char *)v109, (char *)__p, &buf);
  if (v36)
  {
    prop::file::get<std::string>(v109, (uint64_t)__p, (uint64_t)&buf, &v111);
    v37 = v111.__r_.__value_.__l.__size_;
    __s = (std::string::value_type *)v111.__r_.__value_.__r.__words[0];
    v104[0] = v111.__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v104 + 3) = *(_DWORD *)((char *)&v111.__r_.__value_.__r.__words[2] + 3);
    v38 = HIBYTE(v111.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_54;
  }
  else
  {
    __s = 0;
    v37 = 0;
    v38 = 0;
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_54;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_54:
  if ((v110 & 0x80000000) == 0)
  {
    if ((v102 & 0x80000000) == 0)
      goto LABEL_56;
LABEL_60:
    operator delete(__p[0]);
    if (v36)
      goto LABEL_57;
    goto LABEL_61;
  }
  operator delete((void *)v109[0]);
  if (v102 < 0)
    goto LABEL_60;
LABEL_56:
  if (v36)
  {
LABEL_57:
    v39 = *((_QWORD *)this + 20);
    v100 = 8;
    strcpy((char *)v99, "LogLevel");
    if (v38 < 0)
    {
      std::string::__init_copy_ctor_external(&v98, __s, v37);
    }
    else
    {
      v98.__r_.__value_.__r.__words[0] = (std::string::size_type)__s;
      v98.__r_.__value_.__l.__size_ = v37;
      LODWORD(v98.__r_.__value_.__r.__words[2]) = v104[0];
      *(_DWORD *)((char *)&v98.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v104 + 3);
      *((_BYTE *)&v98.__r_.__value_.__s + 23) = v38;
    }
    (*(void (**)(uint64_t, void **, std::string *))(*(_QWORD *)v39 + 72))(v39, v99, &v98);
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v98.__r_.__value_.__l.__data_);
    if (v100 < 0)
      operator delete(v99[0]);
    goto LABEL_68;
  }
LABEL_61:
  v40 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A343C000, v40, OS_LOG_TYPE_ERROR, "Failed to get LogLevel", (uint8_t *)&buf, 2u);
  }
LABEL_68:
  v102 = 11;
  strcpy((char *)__p, "PayloadSize");
  v110 = 11;
  strcpy((char *)v109, "BasebandIPC");
  memset(&buf, 0, sizeof(buf));
  v41 = defaults::get((char *)v109, (char *)__p, &buf);
  if (v41)
  {
    prop::file::get<std::string>(v109, (uint64_t)__p, (uint64_t)&buf, &v111);
    v43 = v111.__r_.__value_.__l.__size_;
    v42 = (std::string::value_type *)v111.__r_.__value_.__r.__words[0];
    v103[0] = v111.__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v103 + 3) = *(_DWORD *)((char *)&v111.__r_.__value_.__r.__words[2] + 3);
    v44 = HIBYTE(v111.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_73;
  }
  else
  {
    v42 = 0;
    v43 = 0;
    v44 = 0;
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_73;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_73:
  if ((v110 & 0x80000000) == 0)
  {
    if ((v102 & 0x80000000) == 0)
      goto LABEL_75;
LABEL_79:
    operator delete(__p[0]);
    if (v41)
      goto LABEL_76;
LABEL_80:
    v46 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A343C000, v46, OS_LOG_TYPE_ERROR, "Failed to get MHI PayloadSize", (uint8_t *)&buf, 2u);
    }
    goto LABEL_87;
  }
  operator delete((void *)v109[0]);
  if (v102 < 0)
    goto LABEL_79;
LABEL_75:
  if (!v41)
    goto LABEL_80;
LABEL_76:
  v45 = *((_QWORD *)this + 20);
  v97 = 11;
  strcpy((char *)v96, "PayloadSize");
  if (v44 < 0)
  {
    std::string::__init_copy_ctor_external(&v95, v42, v43);
  }
  else
  {
    v95.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
    v95.__r_.__value_.__l.__size_ = v43;
    LODWORD(v95.__r_.__value_.__r.__words[2]) = v103[0];
    *(_DWORD *)((char *)&v95.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v103 + 3);
    *((_BYTE *)&v95.__r_.__value_.__s + 23) = v44;
  }
  (*(void (**)(uint64_t, void **, std::string *))(*(_QWORD *)v45 + 72))(v45, v96, &v95);
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v95.__r_.__value_.__l.__data_);
  if (v97 < 0)
    operator delete(v96[0]);
LABEL_87:
  if (v44 < 0)
  {
    operator delete(v42);
    v4 = v83;
    if ((v38 & 0x80) == 0)
      goto LABEL_89;
  }
  else
  {
    v4 = v83;
    if ((v38 & 0x80) == 0)
      goto LABEL_89;
  }
  operator delete(__s);
LABEL_89:
  *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf.__r_.__value_.__l.__size_;
  v47 = (char *)operator new(0x38uLL);
  *((_WORD *)v47 + 16) = 42;
  *(_OWORD *)(v47 + 34) = *(_OWORD *)&v111.__r_.__value_.__l.__data_;
  *(_QWORD *)(v47 + 47) = *(std::string::size_type *)((char *)&v111.__r_.__value_.__r.__words[1] + 5);
  v47[55] = 1;
  *(_QWORD *)v47 = 0;
  *((_QWORD *)v47 + 1) = 0;
  *((_QWORD *)v47 + 2) = &buf.__r_.__value_.__l.__size_;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v47;
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v47, (uint64_t *)v47);
  ++buf.__r_.__value_.__r.__words[2];
  v111.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v111.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  aBlock[0] = v5;
  aBlock[1] = 1174405120;
  aBlock[2] = ___ZN16BasebandIPCTrace10start_syncEN8dispatch5groupE_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_5_2;
  aBlock[4] = this;
  group = (dispatch_group_t)gr_name;
  if (gr_name)
  {
    dispatch_retain((dispatch_object_t)gr_name);
    dispatch_group_enter(group);
  }
  v94 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v94);
  }
  __sa = (std::string::value_type *)_Block_copy(aBlock);
  v48 = *((_QWORD *)this + 11);
  if (v48)
    dispatch_retain(*((dispatch_object_t *)this + 11));
  v111.__r_.__value_.__r.__words[0] = (std::string::size_type)__sa;
  v111.__r_.__value_.__l.__size_ = v48;
  v82 = *((_QWORD *)this + 20);
  v90 = 0;
  v91 = 0;
  v89 = &v90;
  v49 = buf.__r_.__value_.__r.__words[0];
  if ((std::string::size_type *)buf.__r_.__value_.__l.__data_ != &buf.__r_.__value_.__r.__words[1])
  {
    v50 = 0;
    p_size = buf.__r_.__value_.__r.__words[0] + 32;
    v52 = &v90;
LABEL_141:
    if (v50)
      v65 = v52;
    else
      v65 = &v90;
    v73 = &v89;
    if (v50)
    {
      v73 = (uint64_t ***)v52;
      v64 = v52 + 1;
    }
    else
    {
      v64 = &v90;
    }
    if (v73[1])
    {
LABEL_148:
      v74 = *(std::string **)(v49 + 8);
      if (v74)
        goto LABEL_156;
      do
      {
LABEL_158:
        v78 = *(std::string **)(v49 + 16);
        v55 = v78->__r_.__value_.__r.__words[0] == v49;
        v49 = (std::string::size_type)v78;
      }
      while (!v55);
      goto LABEL_160;
    }
    while (1)
    {
LABEL_150:
      v75 = (uint64_t *)operator new(0x38uLL);
      v76 = (std::string *)(v75 + 4);
      if (*(char *)(v49 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v76, *(const std::string::value_type **)(v49 + 32), *(_QWORD *)(v49 + 40));
      }
      else
      {
        v77 = *(_OWORD *)p_size;
        v75[6] = *(_QWORD *)(p_size + 16);
        *(_OWORD *)&v76->__r_.__value_.__l.__data_ = v77;
      }
      *v75 = 0;
      v75[1] = 0;
      v75[2] = (uint64_t)v65;
      *v64 = v75;
      if (*v89)
      {
        v89 = (uint64_t **)*v89;
        v75 = *v64;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v90, v75);
      ++v91;
      v74 = *(std::string **)(v49 + 8);
      if (!v74)
        goto LABEL_158;
      do
      {
LABEL_156:
        v78 = v74;
        v74 = (std::string *)v74->__r_.__value_.__r.__words[0];
      }
      while (v74);
LABEL_160:
      if (v78 == (std::string *)&buf.__r_.__value_.__r.__words[1])
        break;
      v50 = v90;
      v49 = (std::string::size_type)v78;
      p_size = (std::string::size_type)&v78[1].__r_.__value_.__l.__size_;
      v52 = &v90;
      if (v89 == &v90)
        goto LABEL_141;
      v53 = v90;
      v54 = &v90;
      if (v90)
      {
        do
        {
          v52 = (uint64_t **)v53;
          v53 = (uint64_t *)v53[1];
        }
        while (v53);
      }
      else
      {
        do
        {
          v52 = (uint64_t **)v54[2];
          v55 = *v52 == (uint64_t *)v54;
          v54 = v52;
        }
        while (v55);
      }
      v56 = *((char *)v52 + 55);
      if (v56 >= 0)
        v57 = (uint64_t *)(v52 + 4);
      else
        v57 = v52[4];
      if (v56 >= 0)
        v58 = *((unsigned __int8 *)v52 + 55);
      else
        v58 = (size_t)v52[5];
      v59 = *(char *)(v49 + 55);
      if (v59 >= 0)
        v60 = (const void *)p_size;
      else
        v60 = *(const void **)(v49 + 32);
      if (v59 >= 0)
        v61 = *(unsigned __int8 *)(v49 + 55);
      else
        v61 = *(_QWORD *)(v49 + 40);
      if (v61 >= v58)
        v62 = v58;
      else
        v62 = v61;
      v63 = memcmp(v57, v60, v62);
      if (v63)
      {
        if (v63 < 0)
          goto LABEL_141;
      }
      else if (v58 < v61)
      {
        goto LABEL_141;
      }
      v64 = &v90;
      v65 = &v90;
      if (v50)
      {
        while (1)
        {
          v65 = (uint64_t **)v50;
          v66 = *((unsigned __int8 *)v50 + 55);
          v67 = v50[5];
          if ((v66 & 0x80u) == 0)
            v68 = v50 + 4;
          else
            v68 = (const void *)v50[4];
          if ((v66 & 0x80u) == 0)
            v69 = v66;
          else
            v69 = v67;
          if (v69 >= v61)
            v70 = v61;
          else
            v70 = v69;
          v71 = memcmp(v60, v68, v70);
          if (v71)
          {
            if (v71 < 0)
              goto LABEL_120;
LABEL_134:
            v72 = memcmp(v68, v60, v70);
            if (v72)
            {
              if ((v72 & 0x80000000) == 0)
                goto LABEL_148;
            }
            else if (v69 >= v61)
            {
              goto LABEL_148;
            }
            v50 = v65[1];
            if (!v50)
            {
              v64 = v65 + 1;
              goto LABEL_150;
            }
          }
          else
          {
            if (v61 >= v69)
              goto LABEL_134;
LABEL_120:
            v50 = *v65;
            v64 = v65;
            if (!*v65)
              goto LABEL_150;
          }
        }
      }
    }
  }
  v79 = dispatch_time(0, 8000000000);
  if (__sa)
  {
    v80 = _Block_copy(__sa);
    v81 = v111.__r_.__value_.__l.__size_;
    v87 = v80;
    object = (dispatch_object_t)v111.__r_.__value_.__l.__size_;
    if (!v111.__r_.__value_.__l.__size_)
      goto LABEL_166;
    goto LABEL_165;
  }
  v81 = v111.__r_.__value_.__l.__size_;
  v87 = 0;
  object = (dispatch_object_t)v111.__r_.__value_.__l.__size_;
  if (v111.__r_.__value_.__l.__size_)
LABEL_165:
    dispatch_retain(v81);
LABEL_166:
  (*(void (**)(uint64_t, uint64_t ***, dispatch_time_t, void **))(*(_QWORD *)v82 + 48))(v82, &v89, v79, &v87);
  if (object)
    dispatch_release(object);
  if (v87)
    _Block_release(v87);
  std::__tree<std::string>::destroy((char *)v90);
  if (v81)
    dispatch_release(v81);
  if (__sa)
    _Block_release(__sa);
  if (v94)
  {
    dispatch_group_leave(v94);
    if (v94)
      dispatch_release(v94);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  std::__tree<std::string>::destroy((char *)buf.__r_.__value_.__l.__size_);
  if (v83)
  {
    dispatch_group_leave(v83);
    dispatch_release(v83);
  }
  if (v84)
  {
    dispatch_group_leave(v84);
    dispatch_release(v84);
  }
}

void sub_1A34E9700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, dispatch_group_t a12, void *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,dispatch_group_t a24,dispatch_group_t object,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  char v55;
  void *v56;
  char v57;

  if (a37 < 0)
  {
    operator delete(__p);
    if ((v55 & 0x80) == 0)
      goto LABEL_6;
  }
  else if ((v55 & 0x80) == 0)
  {
LABEL_6:
    if (v57 < 0)
      operator delete(a13);
    if (group)
    {
      dispatch_group_leave(group);
      dispatch_release(group);
    }
    if (a12)
    {
      dispatch_group_leave(a12);
      dispatch_release(a12);
    }
    _Unwind_Resume(exception_object);
  }
  operator delete(v56);
  goto LABEL_6;
}

void ___ZN16BasebandIPCTrace10start_syncEN8dispatch5groupE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t);
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
  if (!*a2)
    v3 = 0;
  if (v3)
  {
    v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 138412290;
      v6 = v2;
      _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#E Enabling failed: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

void __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;

  v4 = *(NSObject **)(a2 + 40);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = *(NSObject **)(a1 + 40);
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = *(NSObject **)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v6;
  if (v6)
  {
    dispatch_retain(v6);
    v7 = *(NSObject **)(a1 + 48);
    if (v7)
      dispatch_group_enter(v7);
  }
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;

  v2 = *(NSObject **)(a1 + 48);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 48);
    if (v3)
      dispatch_release(v3);
  }
  v4 = *(NSObject **)(a1 + 40);
  if (v4)
  {
    dispatch_group_leave(v4);
    v5 = *(NSObject **)(a1 + 40);
    if (v5)
      dispatch_release(v5);
  }
}

void BasebandIPCTrace::abort(uint64_t a1, dispatch_object_t *a2)
{
  NSObject *v3;
  NSObject *v4;
  _QWORD v5[5];
  dispatch_group_t object;
  dispatch_group_t group;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = *(NSObject **)(a1 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 144));
    dispatch_group_enter(v4);
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 1174405120;
  v5[2] = ___ZN16BasebandIPCTrace5abortEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
  v5[3] = &__block_descriptor_tmp_6_5;
  v5[4] = a1;
  object = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  group = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  ctu::SharedSynchronizable<Trace>::execute_wrapped((uint64_t *)(a1 + 72), (uint64_t)v5);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object)
      dispatch_release(object);
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
}

void ___ZN16BasebandIPCTrace5abortEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  const void *v7;
  uint8_t v8[16];

  v1 = *(_QWORD **)(a1 + 32);
  v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v8 = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Aborting", v8, 2u);
  }
  v3 = v1[20];
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
  v4 = (std::__shared_weak_count *)v1[21];
  v1[20] = 0;
  v1[21] = 0;
  if (!v4)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    v7 = (const void *)v1[22];
    v1[22] = 0;
    if (!v7)
      return;
  }
  else
  {
LABEL_9:
    v7 = (const void *)v1[22];
    v1[22] = 0;
    if (!v7)
      return;
  }
  CFRelease(v7);
}

uint64_t BasebandIPCTrace::snapshot(uint64_t a1, NSObject **a2, const __CFDictionary **a3)
{
  void *v6;
  int v7;
  void **v8;
  void *v9;
  void *v10;
  uint64_t v11;
  BOOL v12;
  NSObject *v14;
  void **v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  void *v20;
  void **v21;
  void *v22;
  void *v23;
  uint64_t v24;
  BOOL v25;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  const __CFDictionary *v30;
  uint64_t *v31;
  _QWORD v32[5];
  dispatch_group_t object;
  CFTypeRef cf;
  dispatch_group_t group;
  void *__p[3];
  void *v37[3];
  _QWORD v38[2];
  uint64_t v39;
  uint8_t buf[23];
  char v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v38[0] = 0xAAAAAAAAAAAAAAAALL;
  v38[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v38, *a3);
  memset(v37, 170, sizeof(v37));
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)buf, "kKeyTraceAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](buf);
  memset(__p, 170, sizeof(__p));
  strcpy((char *)buf, "kTraceFilterActionNone");
  v41 = 22;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v39, "kKeyTraceFilterAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A858F29C](&v39);
  if (v41 < 0)
    operator delete(*(void **)buf);
  v6 = (void *)HIBYTE(__p[2]);
  v7 = SHIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) < 0)
    v6 = __p[1];
  if (v6 != (void *)22)
    goto LABEL_15;
  v8 = (void **)__p[0];
  if (SHIBYTE(__p[2]) >= 0)
    v8 = __p;
  v9 = *v8;
  v10 = v8[1];
  v11 = *(uint64_t *)((char *)v8 + 14);
  v12 = v9 == *(void **)"kTraceFilterActionNone" && v10 == *(void **)"lterActionNone";
  if (!v12 || v11 != *(_QWORD *)"tionNone")
  {
LABEL_15:
    v14 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
    v15 = (void **)__p[0];
    if (v7 >= 0)
      v15 = __p;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v15;
    v16 = "#I Skipping snapshot as trace filter is '%s'";
    v17 = v14;
    v18 = 12;
    goto LABEL_19;
  }
  v20 = (void *)HIBYTE(v37[2]);
  if (SHIBYTE(v37[2]) < 0)
    v20 = v37[1];
  if (v20 != (void *)21)
    goto LABEL_37;
  v21 = v37;
  if (SHIBYTE(v37[2]) < 0)
    v21 = (void **)v37[0];
  v22 = *v21;
  v23 = v21[1];
  v24 = *(uint64_t *)((char *)v21 + 13);
  v25 = v22 == *(void **)"kCollectTelephonyLogs" && v23 == *(void **)"TelephonyLogs";
  if (v25 && v24 == *(_QWORD *)"honyLogs")
  {
    v28 = *a2;
    if (v28)
    {
      dispatch_retain(v28);
      dispatch_group_enter(v28);
    }
    v29 = *(NSObject **)(a1 + 144);
    if (v29)
    {
      dispatch_retain(*(dispatch_object_t *)(a1 + 144));
      dispatch_group_enter(v29);
    }
    v32[0] = MEMORY[0x1E0C809B0];
    v32[1] = 1174405120;
    v32[2] = ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
    v32[3] = &__block_descriptor_tmp_8_5;
    v32[4] = a1;
    object = v28;
    if (v28)
    {
      dispatch_retain(v28);
      dispatch_group_enter(v28);
    }
    v30 = *a3;
    cf = v30;
    if (v30)
      CFRetain(v30);
    v31 = (uint64_t *)(a1 + 72);
    group = v29;
    if (v29)
    {
      dispatch_retain(v29);
      dispatch_group_enter(v29);
    }
    ctu::SharedSynchronizable<Trace>::execute_wrapped(v31, (uint64_t)v32);
    if (group)
    {
      dispatch_group_leave(group);
      if (group)
        dispatch_release(group);
    }
    if (cf)
      CFRelease(cf);
    if (object)
    {
      dispatch_group_leave(object);
      if (object)
        dispatch_release(object);
    }
    if (v29)
    {
      dispatch_group_leave(v29);
      dispatch_release(v29);
    }
    if (v28)
    {
      dispatch_group_leave(v28);
      dispatch_release(v28);
    }
  }
  else
  {
LABEL_37:
    v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "#I Skipping";
      v17 = v27;
      v18 = 2;
LABEL_19:
      _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    }
  }
LABEL_20:
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v37[2]) & 0x80000000) == 0)
      return MEMORY[0x1A858F2D8](v38);
LABEL_24:
    operator delete(v37[0]);
    return MEMORY[0x1A858F2D8](v38);
  }
  if (SHIBYTE(v37[2]) < 0)
    goto LABEL_24;
  return MEMORY[0x1A858F2D8](v38);
}

void sub_1A34EA064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  NSObject *v6;
  NSObject *v7;
  const void *v8;
  _QWORD v9[5];
  dispatch_group_t object;
  dispatch_group_t group;
  CFTypeRef cf;
  const void *v13;
  NSObject *v14;

  v1 = a1[4];
  if (*(_BYTE *)(v1 + 152))
  {
    v3 = dispatch_group_create();
    v4 = v3;
    v14 = v3;
    if (v3)
      dispatch_retain(v3);
    v5 = (const void *)a1[6];
    v13 = v5;
    if (v5)
      CFRetain(v5);
    BasebandIPCTrace::collect_sync(v1, &v14);
    if (v5)
      CFRelease(v5);
    if (v4)
      dispatch_release(v4);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 1174405120;
    v9[2] = ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_2;
    v9[3] = &__block_descriptor_tmp_7_4;
    v6 = a1[5];
    v9[4] = v1;
    object = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    v7 = a1[7];
    group = v7;
    if (v7)
    {
      dispatch_retain(v7);
      dispatch_group_enter(v7);
    }
    v8 = (const void *)a1[6];
    cf = v8;
    if (v8)
      CFRetain(v8);
    dispatch_group_notify(v4, *(dispatch_queue_t *)(v1 + 88), v9);
    if (cf)
      CFRelease(cf);
    if (group)
    {
      dispatch_group_leave(group);
      if (group)
        dispatch_release(group);
    }
    if (object)
    {
      dispatch_group_leave(object);
      if (object)
        dispatch_release(object);
    }
    if (v4)
      dispatch_release(v4);
  }
}

void sub_1A34EA25C(_Unwind_Exception *a1)
{
  NSObject *v1;
  uint64_t v2;

  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)(v2 - 48));
  if (v1)
  {
    dispatch_release(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void BasebandIPCTrace::collect_sync(uint64_t a1, NSObject **a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  config::hw *v7;
  config::hw *v8;
  NSObject *v9;
  uint64_t v10;
  int64_t v11;
  dispatch_time_t v12;
  void *v13;
  dispatch_object_t object;
  _QWORD aBlock[5];
  dispatch_group_t group;
  dispatch_group_t v17;
  uint8_t buf[16];

  v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Collecting", buf, 2u);
  }
  if (*(_QWORD *)(a1 + 160))
  {
    v5 = *a2;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    v6 = *(NSObject **)(a1 + 144);
    if (v6)
    {
      dispatch_retain(*(dispatch_object_t *)(a1 + 144));
      dispatch_group_enter(v6);
    }
    memset(buf, 170, sizeof(buf));
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN16BasebandIPCTrace12collect_syncEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_12_0;
    aBlock[4] = a1;
    group = v5;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(group);
    }
    v17 = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v17);
    }
    v7 = (config::hw *)_Block_copy(aBlock);
    v8 = v7;
    v9 = *(NSObject **)(a1 + 88);
    if (v9)
      dispatch_retain(*(dispatch_object_t *)(a1 + 88));
    *(_QWORD *)buf = v8;
    *(_QWORD *)&buf[8] = v9;
    v10 = *(_QWORD *)(a1 + 160);
    if (config::hw::watch(v7))
      v11 = 12000000000;
    else
      v11 = 10000000000;
    v12 = dispatch_time(0, v11);
    if (v8)
    {
      v13 = _Block_copy(v8);
      object = v9;
      if (!v9)
      {
LABEL_20:
        (*(void (**)(uint64_t, dispatch_time_t, void **))(*(_QWORD *)v10 + 56))(v10, v12, &v13);
        if (object)
          dispatch_release(object);
        if (v13)
          _Block_release(v13);
        if (v9)
          dispatch_release(v9);
        if (v8)
          _Block_release(v8);
        if (v17)
        {
          dispatch_group_leave(v17);
          if (v17)
            dispatch_release(v17);
        }
        if (group)
        {
          dispatch_group_leave(group);
          if (group)
            dispatch_release(group);
        }
        if (v6)
        {
          dispatch_group_leave(v6);
          dispatch_release(v6);
        }
        if (v5)
        {
          dispatch_group_leave(v5);
          dispatch_release(v5);
        }
        return;
      }
    }
    else
    {
      v13 = 0;
      object = v9;
      if (!v9)
        goto LABEL_20;
    }
    dispatch_retain(v9);
    goto LABEL_20;
  }
}

void sub_1A34EA4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t object, dispatch_group_t group)
{
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;

  dispatch::callback<void({block_pointer})(ctu::cf::CFSharedRef<__CFError>,ctu::cf::CFSharedRef<__CFDictionary const>)>::~callback((uint64_t)&a10);
  dispatch::callback<void({block_pointer})(ctu::cf::CFSharedRef<__CFError>,ctu::cf::CFSharedRef<__CFDictionary const>)>::~callback(v20 - 64);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object)
      dispatch_release(object);
  }
  if (v19)
  {
    dispatch_group_leave(v19);
    dispatch_release(v19);
    if (!v18)
LABEL_9:
      _Unwind_Resume(a1);
  }
  else if (!v18)
  {
    goto LABEL_9;
  }
  dispatch_group_leave(v18);
  dispatch_release(v18);
  _Unwind_Resume(a1);
}

void ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_2(uint64_t a1)
{
  BasebandIPCTrace *v1;
  char *v2;
  group v3;

  v1 = *(BasebandIPCTrace **)(a1 + 32);
  v2 = *(char **)(a1 + 56);
  v3.gr_passwd = v2;
  if (v2)
    CFRetain(v2);
  BasebandIPCTrace::write_sync((uint64_t)v1, (const __CFDictionary **)&v3.gr_passwd);
  if (v2)
    CFRelease(v2);
  v3.gr_name = 0;
  BasebandIPCTrace::start_sync(v1, &v3);
}

void sub_1A34EA5BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t BasebandIPCTrace::write_sync(uint64_t result, const __CFDictionary **a2)
{
  uint64_t (*v2)(uint64_t);
  uint64_t v4;
  NSObject *v5;
  const void *v6;
  size_t v7;
  std::string::size_type v8;
  std::string *p_buf;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  char *v13;
  size_t v14;
  std::string::size_type v15;
  std::string *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  size_t v20;
  std::string::size_type v21;
  std::string *p_dst;
  uint64_t v23;
  uint64_t v24;
  void **v25;
  std::string::size_type v26;
  std::string *v27;
  __int128 v28;
  const std::string::value_type *v29;
  std::string::size_type v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  __int128 v34;
  char *v35;
  size_t v36;
  std::string::size_type v37;
  std::string *v38;
  uint64_t v39;
  uint64_t v40;
  std::string *v41;
  __int128 v42;
  const __CFDictionary *v43;
  std::string::size_type v44;
  std::error_code *v45;
  const std::__fs::filesystem::path *v46;
  const std::__fs::filesystem::path *v47;
  int v48;
  NSObject *v49;
  const void *v50;
  std::string *v51;
  void **v52;
  _QWORD v53[4];
  std::string v54;
  std::string __dst;
  std::string v56;
  void *__p[2];
  int64_t v58;
  void *v59[3];
  void *v60[3];
  _QWORD v61[2];
  std::string buf;
  void *v63;
  _QWORD *v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 176))
    v2 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  else
    v2 = 0;
  if (v2)
  {
    v4 = result;
    v5 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Captured cached data", (uint8_t *)&buf, 2u);
    }
    v61[0] = 0xAAAAAAAAAAAAAAAALL;
    v61[1] = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v61, *a2);
    memset(v60, 170, sizeof(v60));
    v6 = (const void *)*MEMORY[0x1E0CFB250];
    v7 = strlen((const char *)*MEMORY[0x1E0CFB250]);
    if (v7 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v8 = v7;
    if (v7 >= 0x17)
    {
      v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17)
        v10 = v7 | 7;
      v11 = v10 + 1;
      p_buf = (std::string *)operator new(v10 + 1);
      buf.__r_.__value_.__l.__size_ = v8;
      buf.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    }
    else
    {
      *((_BYTE *)&buf.__r_.__value_.__s + 23) = v7;
      p_buf = &buf;
      if (!v7)
      {
LABEL_15:
        v12 = (const char *)*MEMORY[0x1E0CFB370];
        p_buf->__r_.__value_.__s.__data_[v8] = 0;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v59, v12);
        ctu::cf::map_adapter::getString();
        MEMORY[0x1A858F29C](v59);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          operator delete(buf.__r_.__value_.__l.__data_);
        memset(v59, 170, sizeof(v59));
        v13 = abm::trace::kSnapshotFolder[0];
        v14 = strlen(abm::trace::kSnapshotFolder[0]);
        if (v14 > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v15 = v14;
        if (v14 >= 0x17)
        {
          v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v14 | 7) != 0x17)
            v17 = v14 | 7;
          v18 = v17 + 1;
          v16 = (std::string *)operator new(v17 + 1);
          buf.__r_.__value_.__l.__size_ = v15;
          buf.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
        }
        else
        {
          *((_BYTE *)&buf.__r_.__value_.__s + 23) = v14;
          v16 = &buf;
          if (!v14)
          {
LABEL_25:
            v16->__r_.__value_.__s.__data_[v15] = 0;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)__p, "kKeyTraceDumpStatePath");
            ctu::cf::map_adapter::getString();
            MEMORY[0x1A858F29C](__p);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              operator delete(buf.__r_.__value_.__l.__data_);
            v19 = abm::trace::kLogDirPrefix[0];
            v20 = strlen(abm::trace::kLogDirPrefix[0]);
            if (v20 > 0x7FFFFFFFFFFFFFF7)
              std::string::__throw_length_error[abi:ne180100]();
            v21 = v20;
            if (v20 >= 0x17)
            {
              v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v20 | 7) != 0x17)
                v23 = v20 | 7;
              v24 = v23 + 1;
              p_dst = (std::string *)operator new(v23 + 1);
              __dst.__r_.__value_.__l.__size_ = v21;
              __dst.__r_.__value_.__r.__words[2] = v24 | 0x8000000000000000;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
            }
            else
            {
              *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v20;
              p_dst = &__dst;
              if (!v20)
              {
LABEL_35:
                p_dst->__r_.__value_.__s.__data_[v21] = 0;
                if (SHIBYTE(v59[2]) >= 0)
                  v25 = v59;
                else
                  v25 = (void **)v59[0];
                if (SHIBYTE(v59[2]) >= 0)
                  v26 = HIBYTE(v59[2]);
                else
                  v26 = (std::string::size_type)v59[1];
                v27 = std::string::insert(&__dst, 0, (const std::string::value_type *)v25, v26);
                v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
                v56.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v28;
                v27->__r_.__value_.__l.__size_ = 0;
                v27->__r_.__value_.__r.__words[2] = 0;
                v27->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(v60[2]) >= 0)
                  v29 = (const std::string::value_type *)v60;
                else
                  v29 = (const std::string::value_type *)v60[0];
                if (SHIBYTE(v60[2]) >= 0)
                  v30 = HIBYTE(v60[2]);
                else
                  v30 = (std::string::size_type)v60[1];
                v31 = std::string::append(&v56, v29, v30);
                v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
                buf.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
                *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v32;
                v31->__r_.__value_.__l.__size_ = 0;
                v31->__r_.__value_.__r.__words[2] = 0;
                v31->__r_.__value_.__r.__words[0] = 0;
                v33 = std::string::append(&buf, "-bbipc", 6uLL);
                v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
                v58 = v33->__r_.__value_.__r.__words[2];
                *(_OWORD *)__p = v34;
                v33->__r_.__value_.__l.__size_ = 0;
                v33->__r_.__value_.__r.__words[2] = 0;
                v33->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(buf.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
LABEL_49:
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_50;
LABEL_65:
                    operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_50:
                    memset(&v56, 170, sizeof(v56));
                    v35 = abm::trace::kScratchFolder[0];
                    v36 = strlen(abm::trace::kScratchFolder[0]);
                    if (v36 > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v37 = v36;
                    if (v36 >= 0x17)
                    {
                      v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v36 | 7) != 0x17)
                        v39 = v36 | 7;
                      v40 = v39 + 1;
                      v38 = (std::string *)operator new(v39 + 1);
                      buf.__r_.__value_.__l.__size_ = v37;
                      buf.__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
                      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
                    }
                    else
                    {
                      *((_BYTE *)&buf.__r_.__value_.__s + 23) = v36;
                      v38 = &buf;
                      if (!v36)
                      {
LABEL_58:
                        v38->__r_.__value_.__s.__data_[v37] = 0;
                        v41 = std::string::append(&buf, "BBIPCScratch", 0xCuLL);
                        v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
                        v56.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v42;
                        v41->__r_.__value_.__l.__size_ = 0;
                        v41->__r_.__value_.__r.__words[2] = 0;
                        v41->__r_.__value_.__r.__words[0] = 0;
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(buf.__r_.__value_.__l.__data_);
                        if (support::fs::createDir((const char *)&v56, 0x1EDu, 1))
                        {
                          v43 = *(const __CFDictionary **)(v4 + 176);
                          v44 = MEMORY[0x1E0C809B0];
                          v53[0] = MEMORY[0x1E0C809B0];
                          v53[1] = 1174405120;
                          v53[2] = ___ZN16BasebandIPCTrace10write_syncEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
                          v53[3] = &__block_descriptor_tmp_15_0;
                          if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
                            std::string::__init_copy_ctor_external(&v54, v56.__r_.__value_.__l.__data_, v56.__r_.__value_.__l.__size_);
                          else
                            v54 = v56;
                          buf.__r_.__value_.__r.__words[0] = v44;
                          buf.__r_.__value_.__l.__size_ = 0x40000000;
                          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN3ctu2cf8for_eachINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEPK8__CFDataEEvPK14__CFDictionaryU13block_pointerFvRKT_RKT0_E_block_invoke;
                          v63 = &unk_1E4A0B388;
                          v64 = v53;
                          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
                          CFDictionaryApplyFunction(v43, (CFDictionaryApplierFunction)ctu::cf::DictApplyFunction, &__dst);
                          if (support::fs::createDir((const char *)__p, 0x1EDu, 1)
                            && ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                              ? (v46 = (const std::__fs::filesystem::path *)&v56)
                              : (v46 = (const std::__fs::filesystem::path *)v56.__r_.__value_.__r.__words[0]),
                                v58 >= 0
                              ? (v47 = (const std::__fs::filesystem::path *)__p)
                              : (v47 = (const std::__fs::filesystem::path *)__p[0]),
                                rename(v46, v47, v45),
                                !v48)
                            || (v49 = *(NSObject **)(v4 + 40), !os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)))
                          {
                            if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                              goto LABEL_77;
LABEL_94:
                            operator delete(v54.__r_.__value_.__l.__data_);
                            v50 = *(const void **)(v4 + 176);
                            *(_QWORD *)(v4 + 176) = 0;
                            if (!v50)
                            {
LABEL_79:
                              if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
                              {
                                operator delete(v56.__r_.__value_.__l.__data_);
                                if ((SHIBYTE(v58) & 0x80000000) == 0)
                                {
LABEL_81:
                                  if ((SHIBYTE(v59[2]) & 0x80000000) == 0)
                                    goto LABEL_82;
                                  goto LABEL_87;
                                }
                              }
                              else if ((SHIBYTE(v58) & 0x80000000) == 0)
                              {
                                goto LABEL_81;
                              }
                              operator delete(__p[0]);
                              if ((SHIBYTE(v59[2]) & 0x80000000) == 0)
                              {
LABEL_82:
                                if ((SHIBYTE(v60[2]) & 0x80000000) == 0)
                                  return MEMORY[0x1A858F2D8](v61);
LABEL_88:
                                operator delete(v60[0]);
                                return MEMORY[0x1A858F2D8](v61);
                              }
LABEL_87:
                              operator delete(v59[0]);
                              if ((SHIBYTE(v60[2]) & 0x80000000) == 0)
                                return MEMORY[0x1A858F2D8](v61);
                              goto LABEL_88;
                            }
LABEL_78:
                            CFRelease(v50);
                            goto LABEL_79;
                          }
                          v51 = &v56;
                          if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                            v51 = (std::string *)v56.__r_.__value_.__r.__words[0];
                          v52 = __p;
                          if (v58 < 0)
                            v52 = (void **)__p[0];
                          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v51;
                          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v52;
                          _os_log_error_impl(&dword_1A343C000, v49, OS_LOG_TYPE_ERROR, "Failed to move %s to %s", (uint8_t *)&buf, 0x16u);
                          if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
                            goto LABEL_94;
                        }
LABEL_77:
                        v50 = *(const void **)(v4 + 176);
                        *(_QWORD *)(v4 + 176) = 0;
                        if (!v50)
                          goto LABEL_79;
                        goto LABEL_78;
                      }
                    }
                    memmove(v38, v35, v37);
                    goto LABEL_58;
                  }
                }
                else if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_49;
                }
                operator delete(v56.__r_.__value_.__l.__data_);
                if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_50;
                goto LABEL_65;
              }
            }
            memmove(p_dst, v19, v21);
            goto LABEL_35;
          }
        }
        memmove(v16, v13, v15);
        goto LABEL_25;
      }
    }
    memmove(p_buf, v6, v8);
    goto LABEL_15;
  }
  return result;
}

void sub_1A34EACAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  uint64_t v44;

  if (a18 < 0)
    operator delete(__p);
  if (a30 < 0)
    operator delete(a25);
  if (a37 < 0)
    operator delete(a32);
  if (a44 < 0)
    operator delete(a39);
  if (*(char *)(v44 - 129) < 0)
    operator delete(*(void **)(v44 - 152));
  MEMORY[0x1A858F2D8](v44 - 128);
  _Unwind_Resume(a1);
}

CFTypeRef __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(_QWORD *a1, _QWORD *a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  CFTypeRef result;

  v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = a1[5];
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = a2[6];
  a1[6] = v6;
  if (v6)
  {
    dispatch_retain(v6);
    v7 = a1[6];
    if (v7)
      dispatch_group_enter(v7);
  }
  result = (CFTypeRef)a2[7];
  a1[7] = result;
  if (result)
    return CFRetain(result);
  return result;
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(_QWORD *a1)
{
  const void *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  v2 = (const void *)a1[7];
  if (v2)
    CFRelease(v2);
  v3 = a1[6];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = a1[6];
    if (v4)
      dispatch_release(v4);
  }
  v5 = a1[5];
  if (v5)
  {
    dispatch_group_leave(v5);
    v6 = a1[5];
    if (v6)
      dispatch_release(v6);
  }
}

void __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE56c30_ZTSN8dispatch13group_sessionE(_QWORD *a1, _QWORD *a2)
{
  NSObject *v4;
  NSObject *v5;
  const void *v6;
  NSObject *v7;
  NSObject *v8;

  v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = a1[5];
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = (const void *)a2[6];
  a1[6] = v6;
  if (v6)
    CFRetain(v6);
  v7 = a2[7];
  a1[7] = v7;
  if (v7)
  {
    dispatch_retain(v7);
    v8 = a1[7];
    if (v8)
      dispatch_group_enter(v8);
  }
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE56c30_ZTSN8dispatch13group_sessionE(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  const void *v4;
  NSObject *v5;
  NSObject *v6;

  v2 = a1[7];
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = a1[7];
    if (v3)
      dispatch_release(v3);
  }
  v4 = (const void *)a1[6];
  if (v4)
    CFRelease(v4);
  v5 = a1[5];
  if (v5)
  {
    dispatch_group_leave(v5);
    v6 = a1[5];
    if (v6)
      dispatch_release(v6);
  }
}

void BasebandIPCTrace::dumpState(uint64_t a1)
{
  NSObject *v2;
  int v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(unsigned __int8 *)(a1 + 152);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Enabled %d", (uint8_t *)v4, 8u);
  }
}

BOOL BasebandIPCTrace::setProperty(uint64_t a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  _QWORD v13[6];
  dispatch_group_t group;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;
  _QWORD *v21;
  _QWORD block[6];

  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v8 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 1174405120;
  v13[2] = ___ZN16BasebandIPCTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke;
  v13[3] = &unk_1E4A0B240;
  v13[5] = a1;
  group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }
  v13[4] = &v17;
  v15 = a3;
  v16 = a4;
  v21 = v13;
  block[0] = v8;
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_3;
  block[3] = &__block_descriptor_tmp_32_0;
  block[4] = a1 + 72;
  block[5] = &v21;
  v9 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(a1 + 96))
  {
    dispatch_async_and_wait(v9, block);
    v10 = *((unsigned __int8 *)v18 + 24);
    v11 = group;
    if (!group)
      goto LABEL_11;
  }
  else
  {
    dispatch_sync(v9, block);
    v10 = *((unsigned __int8 *)v18 + 24);
    v11 = group;
    if (!group)
      goto LABEL_11;
  }
  dispatch_group_leave(v11);
  if (group)
    dispatch_release(group);
LABEL_11:
  _Block_object_dispose(&v17, 8);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v10 != 0;
}

void ___ZN16BasebandIPCTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  capabilities::radio *v4;
  uint64_t v5;
  __int128 *v6;
  __int128 v7;
  NSObject *v8;
  _BOOL4 v9;
  char v10;
  int v11;
  NSObject *v12;
  __int128 *v13;
  __int128 v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  const void *v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string v21;
  std::string v22;
  NSObject *v23;
  char v24;
  std::string v25;
  void *__p[2];
  char v27;
  std::string v28;
  std::string buf;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = prop::bbipc::set(*(char **)(a1 + 56), *(char **)(a1 + 64));
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v3 = *(_QWORD *)(a1 + 56);
    if (*(char *)(v3 + 23) < 0)
    {
      v4 = (capabilities::radio *)strcasecmp(*(const char **)v3, "Enabled");
      if ((_DWORD)v4)
        goto LABEL_4;
    }
    else
    {
      v4 = (capabilities::radio *)strcasecmp((const char *)v3, "Enabled");
      if ((_DWORD)v4)
      {
LABEL_4:
        if (capabilities::radio::mav20Plus(v4))
        {
          v5 = *(_QWORD *)(v2 + 160);
          if (v5)
          {
            v6 = *(__int128 **)(a1 + 56);
            if (*((char *)v6 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
            }
            else
            {
              v7 = *v6;
              v22.__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
              *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
            }
            v13 = *(__int128 **)(a1 + 64);
            if (*((char *)v13 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)v13, *((_QWORD *)v13 + 1));
            }
            else
            {
              v14 = *v13;
              v21.__r_.__value_.__r.__words[2] = *((_QWORD *)v13 + 2);
              *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v14;
            }
            (*(void (**)(uint64_t, std::string *, std::string *))(*(_QWORD *)v5 + 72))(v5, &v22, &v21);
            if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v21.__r_.__value_.__l.__data_);
            if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v22.__r_.__value_.__l.__data_);
          }
        }
        return;
      }
    }
    v24 = -86;
    memset(&v25, 0, sizeof(v25));
    v27 = 11;
    strcpy((char *)__p, "BasebandIPC");
    memset(&buf, 0, sizeof(buf));
    v9 = defaults::get((char *)__p, (char *)v3, &buf);
    if (v9)
    {
      prop::file::get<std::string>((const void **)__p, v3, (uint64_t)&buf, &v28);
      v25 = v28;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v27 & 0x80000000) == 0)
      {
LABEL_15:
        if (v9)
          goto LABEL_16;
        goto LABEL_20;
      }
    }
    else if ((v27 & 0x80000000) == 0)
    {
      goto LABEL_15;
    }
    operator delete(__p[0]);
    if (v9)
    {
LABEL_16:
      v10 = util::convert<BOOL>(&v25, (BOOL *)&v24, 0);
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_21;
      goto LABEL_22;
    }
LABEL_20:
    v10 = 0;
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
LABEL_21:
      operator delete(v25.__r_.__value_.__l.__data_);
LABEL_22:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v10;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      v11 = v24;
      if (v24 != *(_BYTE *)(v2 + 152))
      {
        *(_BYTE *)(v2 + 152) = v24;
        if (v11)
        {
          v12 = dispatch_group_create();
          v23 = v12;
          BasebandIPCTrace::start_sync((BasebandIPCTrace *)v2, (group *)&v23);
          if (v12)
            dispatch_release(v12);
        }
        else
        {
          v15 = *(std::__shared_weak_count **)(v2 + 168);
          *(_QWORD *)(v2 + 160) = 0;
          *(_QWORD *)(v2 + 168) = 0;
          if (v15)
          {
            p_shared_owners = (unint64_t *)&v15->__shared_owners_;
            do
              v17 = __ldaxr(p_shared_owners);
            while (__stlxr(v17 - 1, p_shared_owners));
            if (!v17)
            {
              ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
              std::__shared_weak_count::__release_weak(v15);
            }
          }
          v18 = *(const void **)(v2 + 176);
          *(_QWORD *)(v2 + 176) = 0;
          if (v18)
            CFRelease(v18);
        }
      }
    }
    return;
  }
  v8 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v19 = *(_QWORD *)(a1 + 56);
    if (*(char *)(v19 + 23) < 0)
      v19 = *(_QWORD *)v19;
    v20 = *(_QWORD *)(a1 + 64);
    if (*(char *)(v20 + 23) < 0)
      v20 = *(_QWORD *)v20;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v19;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v20;
    _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Set property to file failed; key=%s value=%s",
      (uint8_t *)&buf,
      0x16u);
  }
}

void sub_1A34EB538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t BasebandIPCTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  _QWORD *v12;
  _QWORD block[6];

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = ___ZN16BasebandIPCTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke;
  v7[3] = &unk_1E4A0B278;
  v7[4] = &v8;
  v7[5] = a2;
  v7[6] = a3;
  v12 = v7;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_3;
  block[3] = &__block_descriptor_tmp_32_0;
  block[4] = a1 + 72;
  block[5] = &v12;
  v4 = a1 + 88;
  v3 = *(NSObject **)(a1 + 88);
  if (*(_QWORD *)(v4 + 8))
    dispatch_async_and_wait(v3, block);
  else
    dispatch_sync(v3, block);
  v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void ___ZN16BasebandIPCTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke(_QWORD *a1)
{
  char *v2;
  uint64_t v3;
  BOOL v4;
  void *__p[2];
  char v6;

  v2 = (char *)a1[5];
  v3 = a1[6];
  v6 = 11;
  strcpy((char *)__p, "BasebandIPC");
  v4 = prop::get_from_file((char *)__p, v2, v3);
  if (v6 < 0)
    operator delete(__p[0]);
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = v4;
}

void sub_1A34EB720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN16BasebandIPCTrace12collect_syncEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1, uint64_t *a2, CFTypeRef *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  NSObject *v6;
  const void **v7;
  CFTypeRef v8;
  const void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *a2;
  v5 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
  if (!*a2)
    v5 = 0;
  if (v5)
  {
    v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v10 = 138412290;
      v11 = v4;
      _os_log_error_impl(&dword_1A343C000, v6, OS_LOG_TYPE_ERROR, "Query failed: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    v7 = (const void **)(v3 + 176);
    if ((CFTypeRef *)(v3 + 176) != a3)
    {
      v8 = *a3;
      if (*a3)
        CFRetain(*a3);
      v9 = *v7;
      *v7 = v8;
      if (v9)
        CFRelease(v9);
    }
  }
}

void sub_1A34EB820(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t dispatch::callback<void({block_pointer})(ctu::cf::CFSharedRef<__CFError>,ctu::cf::CFSharedRef<__CFDictionary const>)>::~callback(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 8);
  if (v2)
    dispatch_release(v2);
  if (*(_QWORD *)a1)
    _Block_release(*(const void **)a1);
  return a1;
}

void ___ZN16BasebandIPCTrace10write_syncEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1, uint64_t a2, CFDataRef *a3)
{
  int v3;
  size_t v4;
  unint64_t v5;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  int v13;
  const std::string::value_type *v14;
  std::string::size_type v15;
  std::string *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  std::ios_base *v22;
  std::string __p;
  _BYTE __dst[568];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = *(char *)(a1 + 55);
  if (v3 >= 0)
    v4 = *(unsigned __int8 *)(a1 + 55);
  else
    v4 = *(_QWORD *)(a1 + 40);
  v5 = v4 + 1;
  memset(__dst, 170, 24);
  if (v4 + 1 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v5 >= 0x17)
  {
    v10 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v10 = v5 | 7;
    v11 = v10 + 1;
    v9 = operator new(v10 + 1);
    *(_QWORD *)&__dst[8] = v4 + 1;
    *(_QWORD *)&__dst[16] = v11 | 0x8000000000000000;
    *(_QWORD *)__dst = v9;
  }
  else
  {
    memset(__dst, 0, 24);
    v9 = __dst;
    __dst[23] = v4 + 1;
    if (!v4)
      goto LABEL_15;
  }
  if (v3 >= 0)
    v12 = (const void *)(a1 + 32);
  else
    v12 = *(const void **)(a1 + 32);
  memmove(v9, v12, v4);
LABEL_15:
  *(_WORD *)&v9[v4] = 47;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = (const std::string::value_type *)a2;
  else
    v14 = *(const std::string::value_type **)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::string::append((std::string *)__dst, v14, v15);
  __p = *v16;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if ((__dst[23] & 0x80000000) != 0)
    operator delete(*(void **)__dst);
  memset(&__dst[8], 170, 0x230uLL);
  v17 = MEMORY[0x1E0DE4FB0];
  v18 = MEMORY[0x1E0DE4FB0] + 64;
  v19 = (_QWORD *)MEMORY[0x1E0DE4F48];
  v20 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 8);
  v21 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 16);
  *(_QWORD *)&__dst[416] = MEMORY[0x1E0DE4FB0] + 64;
  *(_QWORD *)__dst = v20;
  *(_QWORD *)&__dst[*(_QWORD *)(v20 - 24)] = v21;
  v22 = (std::ios_base *)&__dst[*(_QWORD *)(*(_QWORD *)__dst - 24)];
  std::ios_base::init(v22, &__dst[8]);
  v22[1].__vftable = 0;
  v22[1].__fmtflags_ = -1;
  *(_QWORD *)__dst = v17 + 24;
  *(_QWORD *)&__dst[416] = v18;
  MEMORY[0x1A858F6EC](&__dst[8]);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)&__dst[*(_QWORD *)(*(_QWORD *)__dst - 24)], *(_DWORD *)&__dst[*(_QWORD *)(*(_QWORD *)__dst - 24) + 32] | 4);
  if (!*(_DWORD *)&__dst[*(_QWORD *)(*(_QWORD *)__dst - 24) + 32] && *a3)
  {
    CFDataGetBytePtr(*a3);
    CFDataGetLength(*a3);
    std::ostream::write();
  }
  *(_QWORD *)__dst = *v19;
  *(_QWORD *)&__dst[*(_QWORD *)(*(_QWORD *)__dst - 24)] = v19[3];
  MEMORY[0x1A858F6F8](&__dst[8]);
  std::ostream::~ostream();
  MEMORY[0x1A858F92C](&__dst[416]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1A34EBB18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  std::ofstream::~ofstream(&a16);
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *std::ofstream::~ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F48];
  v3 = *MEMORY[0x1E0DE4F48];
  *a1 = *MEMORY[0x1E0DE4F48];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x1A858F6F8](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1A858F92C](a1 + 52);
  return a1;
}

void __copy_helper_block_e8_32c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(_QWORD *)(a2 + 40));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_32c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
}

void BasebandIPCTrace::getSettingPrefix(char *a1@<X8>)
{
  a1[23] = 13;
  strcpy(a1, "BasebandIPC::");
}

const char *BasebandIPCTrace::getName(BasebandIPCTrace *this)
{
  return "trace.bbipc";
}

_QWORD *std::shared_ptr<BasebandIPCTrace>::shared_ptr[abi:ne180100]<BasebandIPCTrace,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1},void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0B320;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2)
    return a1;
  v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      return a1;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A34EBD6C(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1}::operator() const(BasebandIPCTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A34EBD8C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BasebandIPCTrace *,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace *)#1},std::allocator<BasebandIPCTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandIPCTrace *,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace *)#1},std::allocator<BasebandIPCTrace>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1}::operator() const(BasebandIPCTrace*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<BasebandIPCTrace *,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace *)#1},std::allocator<BasebandIPCTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110share"
                                "d_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1}::operator() const(BasebandIPCTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ___ZN3ctu2cf8for_eachINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEPK8__CFDataEEvPK14__CFDictionaryU13block_pointerFvRKT_RKT0_E_block_invoke(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v4;
  CFTypeID v5;
  const void *v6;
  void *__p[2];
  uint64_t v8;
  __int128 v9;
  uint64_t v10;

  v4 = *(_QWORD *)(a1 + 32);
  v9 = 0uLL;
  v10 = 0;
  ctu::cf::assign();
  *(_OWORD *)__p = 0uLL;
  v8 = 0;
  if (a3)
  {
    v5 = CFGetTypeID(a3);
    if (v5 == CFDataGetTypeID())
      v6 = a3;
    else
      v6 = 0;
  }
  else
  {
    v6 = 0;
  }
  *(_QWORD *)&v9 = v6;
  (*(void (**)(uint64_t, void **, __int128 *))(v4 + 16))(v4, __p, &v9);
  if (SHIBYTE(v8) < 0)
    operator delete(__p[0]);
}

void sub_1A34EBF10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ctu::cf::DictApplyFunction(ctu::cf *this, const void *a2, const void *a3, void *a4)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
}

uint64_t __cxx_global_var_init_16()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<CommandDriverFactory>::~PthreadMutexGuardPolicy, &ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance, &dword_1A343C000);
  }
  return result;
}

void abm::CellularLoggingTask::~CellularLoggingTask(abm::CellularLoggingTask *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  NSObject *v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  std::__shared_weak_count *v14;

  *(_QWORD *)this = off_1E4A0B3B8;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 24);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = (std::__shared_weak_count *)*((_QWORD *)this + 22);
    if (!v5)
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v5 = (std::__shared_weak_count *)*((_QWORD *)this + 22);
    if (!v5)
      goto LABEL_11;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  v8 = *((_QWORD *)this + 20);
  if (v8)
  {
    dispatch_group_leave(v8);
    v9 = *((_QWORD *)this + 20);
    if (v9)
      dispatch_release(v9);
  }
  if ((*((char *)this + 159) & 0x80000000) == 0)
  {
    *(_QWORD *)this = off_1E4A0F3B8;
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
      goto LABEL_17;
    goto LABEL_16;
  }
  operator delete(*((void **)this + 17));
  *(_QWORD *)this = off_1E4A0F3B8;
  v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v10)
LABEL_16:
    std::__shared_weak_count::__release_weak(v10);
LABEL_17:
  v11 = *((_QWORD *)this + 14);
  if (v11)
    dispatch_release(v11);
  *(_QWORD *)this = &unk_1E4A06FA8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v12 = *((_QWORD *)this + 12);
  if (v12)
    dispatch_release(v12);
  v13 = *((_QWORD *)this + 11);
  if (v13)
    dispatch_release(v13);
  v14 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
}

{
  void *v1;

  abm::CellularLoggingTask::~CellularLoggingTask(this);
  operator delete(v1);
}

uint64_t abm::CellularLoggingTask::getName(abm::CellularLoggingTask *this)
{
  return (uint64_t)this + 136;
}

uint64_t abm::CellularLoggingTask::CellularLoggingTask(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  const char *v18;
  size_t v19;
  size_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  void **v25;
  _QWORD *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  NSObject *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  dispatch_object_t object;
  uint64_t v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  void *__p[2];
  char v44;
  _BYTE v45[16];
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;

  v8 = (std::__shared_weak_count *)a3[1];
  v48 = *a3;
  v49 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (std::__shared_weak_count *)a4[1];
  v46 = *a4;
  v47 = v11;
  if (v11)
  {
    p_shared_weak_owners = (unint64_t *)&v11->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
  }
  abm::HelperTask::HelperTask(a1, a2, &v48, &v46);
  if (v47)
    std::__shared_weak_count::__release_weak(v47);
  v14 = v49;
  if (v49)
  {
    v15 = (unint64_t *)&v49->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  *(_QWORD *)a1 = off_1E4A0B3B8;
  v17 = *(_DWORD *)(a1 + 104) - 1;
  if (v17 > 9)
    v18 = "invalid";
  else
    v18 = off_1E4A0B5B0[v17];
  v19 = strlen(v18);
  if (v19 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v20 = v19;
  if (v19 >= 0x17)
  {
    v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v22 = v19 | 7;
    v23 = v22 + 1;
    v21 = operator new(v22 + 1);
    *(_QWORD *)(a1 + 144) = v20;
    *(_QWORD *)(a1 + 152) = v23 | 0x8000000000000000;
    *(_QWORD *)(a1 + 136) = v21;
    goto LABEL_24;
  }
  *(_BYTE *)(a1 + 159) = v19;
  v21 = (void *)(a1 + 136);
  if (v19)
LABEL_24:
    memmove(v21, v18, v20);
  *((_BYTE *)v21 + v20) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  abm::helper::getLoggingDomain(a2, __p);
  if ((a2 - 1) > 9)
    v24 = "invalid";
  else
    v24 = off_1E4A0B5B0[a2 - 1];
  if (v44 >= 0)
    v25 = __p;
  else
    v25 = (void **)__p[0];
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v45, (const char *)v25, v24);
  *(_QWORD *)(a1 + 168) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)(a1 + 176) = 0xAAAAAAAAAAAAAAAALL;
  v26 = operator new(0x28uLL);
  std::__shared_ptr_emplace<abm::AppMonitor>::__shared_ptr_emplace[abi:ne180100]<ctu::OsLogContext &,std::allocator<abm::AppMonitor>,0>(v26, (const ctu::OsLogContext *)v45);
  *(_QWORD *)(a1 + 168) = v26 + 3;
  *(_QWORD *)(a1 + 176) = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v45);
  if (v44 < 0)
    operator delete(__p[0]);
  v27 = (std::__shared_weak_count *)a3[1];
  v41 = *a3;
  v42 = v27;
  if (v27)
  {
    v28 = (unint64_t *)&v27->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  v30 = (std::__shared_weak_count *)a4[1];
  v39 = *a4;
  v40 = v30;
  if (v30)
  {
    v31 = (unint64_t *)&v30->__shared_weak_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  v33 = *(NSObject **)(a1 + 88);
  object = v33;
  if (v33)
    dispatch_retain(v33);
  abm::CellularLoggingCommon::create(&v41, &v39, &object, (_QWORD *)(a1 + 184));
  if (object)
    dispatch_release(object);
  if (v40)
    std::__shared_weak_count::__release_weak(v40);
  v34 = v42;
  if (v42)
  {
    v35 = (unint64_t *)&v42->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  return a1;
}

void sub_1A34EC3EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, std::__shared_weak_count *a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,char a24)
{
  uint64_t v24;
  void **v25;
  uint64_t v26;
  NSObject *v28;
  NSObject *v29;

  if (object)
    dispatch_release(object);
  if (a11)
    std::__shared_weak_count::__release_weak(a11);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v26);
  v28 = *(NSObject **)(v24 + 160);
  if (v28)
  {
    dispatch_group_leave(v28);
    v29 = *(NSObject **)(v24 + 160);
    if (v29)
      dispatch_release(v29);
  }
  if (*(char *)(v24 + 159) < 0)
  {
    operator delete(*v25);
    abm::HelperTask::~HelperTask((abm::HelperTask *)v24);
    _Unwind_Resume(a1);
  }
  abm::HelperTask::~HelperTask((abm::HelperTask *)v24);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingTask::init_sync(abm::CellularLoggingTask *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  void *v16;
  NSObject *v17;
  char *v18;
  unint64_t v19;
  void *v20;
  NSObject *v21;
  char *v22;
  unint64_t v23;
  void *v24;
  NSObject *v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  void *v29;
  NSObject *v30;
  char *v31;
  unint64_t v32;
  void *v33;
  NSObject *v34;
  char *v35;
  unint64_t v36;
  void *v37;
  NSObject *v38;
  char *v39;
  unint64_t v40;
  void *v41;
  NSObject *v42;
  char *v43;
  unint64_t v44;
  void *v45;
  NSObject *v46;
  unint64_t *v47;
  unint64_t v48;
  _QWORD v49[6];
  std::__shared_weak_count *v50;
  _QWORD v51[2];
  char *v52;
  __int128 v53;
  _QWORD v54[6];
  std::__shared_weak_count *v55;
  _QWORD v56[2];
  char *v57;
  __int128 v58;
  _QWORD v59[6];
  std::__shared_weak_count *v60;
  _QWORD v61[2];
  char *v62;
  __int128 v63;
  _QWORD v64[6];
  std::__shared_weak_count *v65;
  _QWORD v66[2];
  char *v67;
  __int128 v68;
  _QWORD v69[6];
  std::__shared_weak_count *v70;
  _QWORD v71[2];
  char *v72;
  __int128 v73;
  _QWORD v74[6];
  std::__shared_weak_count *v75;
  _QWORD v76[2];
  char *v77;
  __int128 v78;
  _QWORD v79[6];
  std::__shared_weak_count *v80;
  _QWORD v81[2];
  char *v82;
  __int128 v83;
  _QWORD aBlock[6];
  std::__shared_weak_count *v85;
  _QWORD v86[2];
  char *v87;
  __int128 v88;
  uint64_t v89;
  std::__shared_weak_count *v90;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2 || (v3 = *((_QWORD *)this + 9), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v7 = __ldxr(p_shared_weak_owners);
  while (__stxr(v7 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (v9)
  {
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
      goto LABEL_97;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
      goto LABEL_97;
  }
  v11 = std::__shared_weak_count::lock(v10);
  v90 = v11;
  if (v11)
  {
    v12 = v11;
    v13 = *((_QWORD *)this + 15);
    v89 = v13;
    if (v13)
    {
      v14 = (char *)operator new(0x20uLL);
      v87 = v14;
      v88 = xmmword_1A357F830;
      strcpy(v14, "kCommandCellularLoggingStart");
      aBlock[0] = MEMORY[0x1E0C809B0];
      aBlock[1] = 3321888768;
      aBlock[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke;
      aBlock[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      aBlock[4] = this;
      aBlock[5] = v3;
      v85 = v5;
      do
        v15 = __ldxr(p_shared_weak_owners);
      while (__stxr(v15 + 1, p_shared_weak_owners));
      v16 = _Block_copy(aBlock);
      v17 = *((_QWORD *)this + 11);
      if (v17)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v86[0] = v16;
      v86[1] = v17;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v87, (uint64_t)v86);
      if (v17)
        dispatch_release(v17);
      if (v16)
        _Block_release(v16);
      operator delete(v14);
      v18 = (char *)operator new(0x20uLL);
      v82 = v18;
      v83 = xmmword_1A357F820;
      strcpy(v18, "kCommandCellularLoggingStop");
      v79[0] = MEMORY[0x1E0C809B0];
      v79[1] = 3321888768;
      v79[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_5;
      v79[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v79[4] = this;
      v79[5] = v3;
      v80 = v5;
      do
        v19 = __ldxr(p_shared_weak_owners);
      while (__stxr(v19 + 1, p_shared_weak_owners));
      v20 = _Block_copy(v79);
      v21 = *((_QWORD *)this + 11);
      if (v21)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v81[0] = v20;
      v81[1] = v21;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v82, (uint64_t)v81);
      if (v21)
        dispatch_release(v21);
      if (v20)
        _Block_release(v20);
      operator delete(v18);
      v22 = (char *)operator new(0x28uLL);
      v77 = v22;
      v78 = xmmword_1A3581DD0;
      strcpy(v22, "kCommandCellularLoggingGetCurrentIndex");
      v74[0] = MEMORY[0x1E0C809B0];
      v74[1] = 3321888768;
      v74[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_6;
      v74[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v74[4] = this;
      v74[5] = v3;
      v75 = v5;
      do
        v23 = __ldxr(p_shared_weak_owners);
      while (__stxr(v23 + 1, p_shared_weak_owners));
      v24 = _Block_copy(v74);
      v25 = *((_QWORD *)this + 11);
      if (v25)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v76[0] = v24;
      v76[1] = v25;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v77, (uint64_t)v76);
      if (v25)
        dispatch_release(v25);
      if (v24)
        _Block_release(v24);
      operator delete(v22);
      v26 = (char *)operator new(0x28uLL);
      v72 = v26;
      v73 = xmmword_1A35802F0;
      strcpy(v26, "kCommandCellularLoggingGetConfigLists");
      v27 = MEMORY[0x1E0C809B0];
      v69[0] = MEMORY[0x1E0C809B0];
      v69[1] = 3321888768;
      v69[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_7;
      v69[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v69[4] = this;
      v69[5] = v3;
      v70 = v5;
      do
        v28 = __ldxr(p_shared_weak_owners);
      while (__stxr(v28 + 1, p_shared_weak_owners));
      v29 = _Block_copy(v69);
      v30 = *((_QWORD *)this + 11);
      if (v30)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v71[0] = v29;
      v71[1] = v30;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v72, (uint64_t)v71);
      if (v30)
        dispatch_release(v30);
      if (v29)
        _Block_release(v29);
      operator delete(v26);
      v31 = (char *)operator new(0x20uLL);
      v67 = v31;
      v68 = xmmword_1A357F830;
      strcpy(v31, "kCommandCellularLoggingPause");
      v64[0] = v27;
      v64[1] = 3321888768;
      v64[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_8;
      v64[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v64[4] = this;
      v64[5] = v3;
      v65 = v5;
      do
        v32 = __ldxr(p_shared_weak_owners);
      while (__stxr(v32 + 1, p_shared_weak_owners));
      v33 = _Block_copy(v64);
      v34 = *((_QWORD *)this + 11);
      if (v34)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v66[0] = v33;
      v66[1] = v34;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v67, (uint64_t)v66);
      if (v34)
        dispatch_release(v34);
      if (v33)
        _Block_release(v33);
      operator delete(v31);
      v35 = (char *)operator new(0x20uLL);
      v62 = v35;
      v63 = xmmword_1A3581DE0;
      strcpy(v35, "kCommandCellularLoggingResume");
      v59[0] = v27;
      v59[1] = 3321888768;
      v59[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_9;
      v59[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v59[4] = this;
      v59[5] = v3;
      v60 = v5;
      do
        v36 = __ldxr(p_shared_weak_owners);
      while (__stxr(v36 + 1, p_shared_weak_owners));
      v37 = _Block_copy(v59);
      v38 = *((_QWORD *)this + 11);
      if (v38)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v61[0] = v37;
      v61[1] = v38;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v62, (uint64_t)v61);
      if (v38)
        dispatch_release(v38);
      if (v37)
        _Block_release(v37);
      operator delete(v35);
      v39 = (char *)operator new(0x28uLL);
      v57 = v39;
      v58 = xmmword_1A35802F0;
      strcpy(v39, "kCommandCellularLoggingSetAppBundleID");
      v54[0] = v27;
      v54[1] = 3321888768;
      v54[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_10;
      v54[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v54[4] = this;
      v54[5] = v3;
      v55 = v5;
      do
        v40 = __ldxr(p_shared_weak_owners);
      while (__stxr(v40 + 1, p_shared_weak_owners));
      v41 = _Block_copy(v54);
      v42 = *((_QWORD *)this + 11);
      if (v42)
        dispatch_retain(*((dispatch_object_t *)this + 11));
      v56[0] = v41;
      v56[1] = v42;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v57, (uint64_t)v56);
      if (v42)
        dispatch_release(v42);
      if (v41)
        _Block_release(v41);
      operator delete(v39);
      v43 = (char *)operator new(0x20uLL);
      v52 = v43;
      v53 = xmmword_1A3580320;
      strcpy(v43, "kCommandCellularLoggingSnapshot");
      v49[0] = v27;
      v49[1] = 3321888768;
      v49[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_12;
      v49[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v49[4] = this;
      v49[5] = v3;
      v50 = v5;
      do
        v44 = __ldxr(p_shared_weak_owners);
      while (__stxr(v44 + 1, p_shared_weak_owners));
      v45 = _Block_copy(v49);
      v46 = *((_QWORD *)this + 11);
      if (v46)
        dispatch_retain(v46);
      v51[0] = v45;
      v51[1] = v46;
      abm::HelperServerInternal::setCommandHandler(v13, (uint64_t)&v52, (uint64_t)v51);
      if (v46)
        dispatch_release(v46);
      if (v45)
        _Block_release(v45);
      operator delete(v43);
      if (v50)
        std::__shared_weak_count::__release_weak(v50);
      if (v55)
        std::__shared_weak_count::__release_weak(v55);
      if (v60)
        std::__shared_weak_count::__release_weak(v60);
      if (v65)
        std::__shared_weak_count::__release_weak(v65);
      if (v70)
        std::__shared_weak_count::__release_weak(v70);
      if (v75)
        std::__shared_weak_count::__release_weak(v75);
      if (v80)
        std::__shared_weak_count::__release_weak(v80);
      if (v85)
        std::__shared_weak_count::__release_weak(v85);
    }
    v47 = (unint64_t *)&v12->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
LABEL_97:
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A34ECC88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,std::__shared_weak_count *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,std::__shared_weak_count *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::__shared_weak_count *a68;
  std::__shared_weak_count *v68;
  void *v69;
  uint64_t v70;
  std::__shared_weak_count *v72;
  std::__shared_weak_count *v73;
  std::__shared_weak_count *v74;
  std::__shared_weak_count *v75;
  std::__shared_weak_count *v76;
  std::__shared_weak_count *v77;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a21);
  if (a20)
    std::__shared_weak_count::__release_weak(a20);
  operator delete(v69);
  if (a32)
  {
    std::__shared_weak_count::__release_weak(a32);
    v72 = a44;
    if (!a44)
    {
LABEL_5:
      v73 = a56;
      if (!a56)
        goto LABEL_6;
      goto LABEL_13;
    }
  }
  else
  {
    v72 = a44;
    if (!a44)
      goto LABEL_5;
  }
  std::__shared_weak_count::__release_weak(v72);
  v73 = a56;
  if (!a56)
  {
LABEL_6:
    v74 = a68;
    if (!a68)
      goto LABEL_7;
    goto LABEL_14;
  }
LABEL_13:
  std::__shared_weak_count::__release_weak(v73);
  v74 = a68;
  if (!a68)
  {
LABEL_7:
    v75 = (std::__shared_weak_count *)STACK[0x238];
    if (!STACK[0x238])
      goto LABEL_8;
    goto LABEL_15;
  }
LABEL_14:
  std::__shared_weak_count::__release_weak(v74);
  v75 = (std::__shared_weak_count *)STACK[0x238];
  if (!STACK[0x238])
  {
LABEL_8:
    v76 = (std::__shared_weak_count *)STACK[0x298];
    if (!STACK[0x298])
      goto LABEL_9;
    goto LABEL_16;
  }
LABEL_15:
  std::__shared_weak_count::__release_weak(v75);
  v76 = (std::__shared_weak_count *)STACK[0x298];
  if (!STACK[0x298])
  {
LABEL_9:
    v77 = *(std::__shared_weak_count **)(v70 - 168);
    if (!v77)
      goto LABEL_10;
    goto LABEL_17;
  }
LABEL_16:
  std::__shared_weak_count::__release_weak(v76);
  v77 = *(std::__shared_weak_count **)(v70 - 168);
  if (!v77)
  {
LABEL_10:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v70 - 120);
    std::__shared_weak_count::__release_weak(v68);
    _Unwind_Resume(a1);
  }
LABEL_17:
  std::__shared_weak_count::__release_weak(v77);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v70 - 120);
  std::__shared_weak_count::__release_weak(v68);
  _Unwind_Resume(a1);
}

void sub_1A34ECE68()
{
  void *v0;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&STACK[0x240]);
  if (STACK[0x238])
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)STACK[0x238]);
  operator delete(v0);
  if (STACK[0x298])
    JUMPOUT(0x1A34ECE40);
  JUMPOUT(0x1A34ECCE4);
}

void sub_1A34ECE98()
{
  if (STACK[0x298])
    JUMPOUT(0x1A34ECE40);
  JUMPOUT(0x1A34ECCE4);
}

void sub_1A34ECEA8()
{
  void *v0;
  uint64_t v1;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback(v1 - 256);
  if (STACK[0x298])
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)STACK[0x298]);
  operator delete(v0);
  if (*(_QWORD *)(v1 - 168))
    JUMPOUT(0x1A34ECE4CLL);
  JUMPOUT(0x1A34ECCECLL);
}

void sub_1A34ECED8()
{
  uint64_t v0;

  if (*(_QWORD *)(v0 - 168))
    JUMPOUT(0x1A34ECE4CLL);
  JUMPOUT(0x1A34ECCECLL);
}

void sub_1A34ECEE8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback(v3 - 160);
  v5 = *(std::__shared_weak_count **)(v3 - 168);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  operator delete(v2);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v3 - 120);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void sub_1A34ECF24(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 120);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke(_QWORD *a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  xpc_object_t v12;
  void *v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  char isClientEntitled;
  uint64_t *p_shared_owners;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  void *v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  void *v30;
  char v31;
  xpc_object_t v32;
  xpc_object_t v33;
  NSObject *v34;
  xpc_object_t v35;
  void *v36;
  NSObject *v37;
  void *v38;
  NSObject *v39;
  void *v40;
  NSObject *v41;
  void *v42;
  size_t v43;
  size_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  xpc_object_t v49;
  xpc_object_t v50;
  const char *v51;
  xpc_object_t v52;
  xpc_object_t v53;
  unsigned int v54;
  xpc_object_t v55;
  xpc_object_t v56;
  char *v57;
  xpc_object_t v58;
  xpc_object_t v59;
  const char *v60;
  xpc_object_t v61;
  xpc_object_t v62;
  unsigned int v63;
  xpc_object_t v64;
  xpc_object_t v65;
  unsigned int v66;
  xpc_object_t v67;
  xpc_object_t v68;
  xpc_object_t v69;
  xpc_object_t v70;
  NSObject *v71;
  NSObject *v72;
  xpc_object_t v73;
  void *v74;
  NSObject *v75;
  void *v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  xpc_object_t v80;
  xpc_object_t value;
  xpc_object_t v82;
  std::__shared_weak_count *v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  uint8_t buf[8];
  __int128 v87;
  void *v88;
  void *aBlock;
  xpc_object_t object;
  int v91;

  v5 = a1[4];
  v84 = 0;
  v85 = 0;
  v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    v85 = std::__shared_weak_count::lock(v6);
    if (!v85)
      return;
    v84 = a1[5];
    if (v84)
    {
      v9 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging Start", buf, 2u);
      }
      v10 = *(_QWORD *)(v5 + 184);
      if (v10)
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 176))(v10))
        {
          v11 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has been already started!", buf, 2u);
          }
          v12 = xpc_null_create();
          if (*(_QWORD *)a4)
            v13 = _Block_copy(*(const void **)a4);
          else
            v13 = 0;
          v25 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&v87 = 3321888768;
          *((_QWORD *)&v87 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v88 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v13)
          {
            v26 = _Block_copy(v13);
            v91 = 0;
            aBlock = v26;
            object = v12;
            if (v12)
            {
LABEL_44:
              xpc_retain(v12);
LABEL_47:
              dispatch_async(v25, buf);
              xpc_release(object);
              object = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v13)
                _Block_release(v13);
LABEL_93:
              xpc_release(v12);
              goto LABEL_168;
            }
          }
          else
          {
            v91 = 0;
            aBlock = 0;
            object = v12;
            if (v12)
              goto LABEL_44;
          }
          object = xpc_null_create();
          goto LABEL_47;
        }
        if ((abm::CellularLoggingTask::isCarrierBundleKeyExist((abm::CellularLoggingTask *)v5) & 1) == 0)
        {
          v16 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle Key doesn't exist, checking for internal entitlement", buf, 2u);
          }
          TelephonyXPC::ServerClientState::ServerClientState();
          *(_QWORD *)buf = operator new(0x28uLL);
          v87 = xmmword_1A3580C30;
          strcpy(*(char **)buf, "com.apple.cellular-logging.internal");
          isClientEntitled = TelephonyXPC::ServerClientState::isClientEntitled();
          if (SHIBYTE(v87) < 0)
            operator delete(*(void **)buf);
          if (v83)
          {
            p_shared_owners = &v83->__shared_owners_;
            do
              v19 = __ldaxr((unint64_t *)p_shared_owners);
            while (__stlxr(v19 - 1, (unint64_t *)p_shared_owners));
            if (!v19)
            {
              ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
              std::__shared_weak_count::__release_weak(v83);
            }
          }
          if ((isClientEntitled & 1) == 0)
          {
            v29 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_1A343C000, v29, OS_LOG_TYPE_ERROR, "Couldn't find internal app entitlement, cannot start cellular logging", buf, 2u);
            }
            v12 = xpc_null_create();
            if (*(_QWORD *)a4)
              v30 = _Block_copy(*(const void **)a4);
            else
              v30 = 0;
            v39 = *(NSObject **)(a4 + 8);
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&v87 = 3321888768;
            *((_QWORD *)&v87 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            v88 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v30)
              v40 = _Block_copy(v30);
            else
              v40 = 0;
            v91 = -534716416;
            aBlock = v40;
            object = v12;
            if (v12)
              xpc_retain(v12);
            else
              object = xpc_null_create();
            dispatch_async(v39, buf);
            xpc_release(object);
            object = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v30)
              _Block_release(v30);
            goto LABEL_93;
          }
        }
        if (!abm::CellularLoggingTask::isUserAgreeLegalInfo((abm::CellularLoggingTask *)v5))
        {
          v27 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v27, OS_LOG_TYPE_ERROR, "The User disagree to proceed!", buf, 2u);
          }
          v12 = xpc_null_create();
          if (*(_QWORD *)a4)
            v28 = _Block_copy(*(const void **)a4);
          else
            v28 = 0;
          v37 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&v87 = 3321888768;
          *((_QWORD *)&v87 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v88 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v28)
            v38 = _Block_copy(v28);
          else
            v38 = 0;
          v91 = -534716414;
          aBlock = v38;
          object = v12;
          if (v12)
            xpc_retain(v12);
          else
            object = xpc_null_create();
          dispatch_async(v37, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v28)
            _Block_release(v28);
          goto LABEL_93;
        }
        v20 = (char *)sandbox_extension_issue_file();
        v21 = *(_QWORD *)(v5 + 184);
        v22 = *a3;
        v82 = v22;
        if (v22)
          xpc_retain(v22);
        else
          v82 = xpc_null_create();
        v31 = (*(uint64_t (**)(uint64_t, xpc_object_t *))(*(_QWORD *)v21 + 48))(v21, &v82);
        xpc_release(v82);
        v82 = 0;
        if ((v31 & 1) == 0)
        {
          v34 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v34, OS_LOG_TYPE_ERROR, "Failed to start CellularLoggingCommon object!", buf, 2u);
          }
          (*(void (**)(_QWORD))(**(_QWORD **)(v5 + 184) + 56))(*(_QWORD *)(v5 + 184));
          v35 = xpc_null_create();
          if (*(_QWORD *)a4)
            v36 = _Block_copy(*(const void **)a4);
          else
            v36 = 0;
          v41 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&v87 = 3321888768;
          *((_QWORD *)&v87 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v88 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v36)
            v42 = _Block_copy(v36);
          else
            v42 = 0;
          v91 = -534716416;
          aBlock = v42;
          object = v35;
          if (v35)
            xpc_retain(v35);
          else
            object = xpc_null_create();
          dispatch_async(v41, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v36)
            _Block_release(v36);
          xpc_release(v35);
          goto LABEL_168;
        }
        v32 = xpc_dictionary_create(0, 0, 0);
        if (v32 || (v32 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v32) == MEMORY[0x1E0C812F8])
          {
            xpc_retain(v32);
            v33 = v32;
          }
          else
          {
            v33 = xpc_null_create();
          }
        }
        else
        {
          v33 = xpc_null_create();
          v32 = 0;
        }
        xpc_release(v32);
        v43 = strlen(v20);
        if (v43 >= 0x7FFFFFFFFFFFFFF8)
          std::string::__throw_length_error[abi:ne180100]();
        v44 = v43;
        if (v43 >= 0x17)
        {
          v46 = (v43 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v43 | 7) != 0x17)
            v46 = v43 | 7;
          v47 = v46 + 1;
          v45 = operator new(v46 + 1);
          *(_QWORD *)&v87 = v44;
          *((_QWORD *)&v87 + 1) = v47 | 0x8000000000000000;
          *(_QWORD *)buf = v45;
        }
        else
        {
          HIBYTE(v87) = v43;
          v45 = buf;
          if (!v43)
            goto LABEL_116;
        }
        memmove(v45, v20, v44);
LABEL_116:
        *((_BYTE *)v45 + v44) = 0;
        if (v87 >= 0)
          v48 = (const char *)buf;
        else
          v48 = *(const char **)buf;
        v49 = xpc_string_create(v48);
        if (!v49)
          v49 = xpc_null_create();
        xpc_dictionary_set_value(v33, "kKeySE", v49);
        v50 = xpc_null_create();
        xpc_release(v49);
        xpc_release(v50);
        if (SHIBYTE(v87) < 0)
          operator delete(*(void **)buf);
        (*(void (**)(uint8_t *__return_ptr))(**(_QWORD **)(v5 + 184) + 104))(buf);
        if (v87 >= 0)
          v51 = (const char *)buf;
        else
          v51 = *(const char **)buf;
        v52 = xpc_string_create(v51);
        if (!v52)
          v52 = xpc_null_create();
        xpc_dictionary_set_value(v33, "kKeyConfigName", v52);
        v53 = xpc_null_create();
        xpc_release(v52);
        xpc_release(v53);
        if (SHIBYTE(v87) < 0)
          operator delete(*(void **)buf);
        v54 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 184) + 112))(*(_QWORD *)(v5 + 184));
        v55 = xpc_int64_create(v54);
        if (!v55)
          v55 = xpc_null_create();
        xpc_dictionary_set_value(v33, "kKeyConfigHistory", v55);
        v56 = xpc_null_create();
        xpc_release(v55);
        xpc_release(v56);
        v57 = (char *)operator new(0x38uLL);
        strcpy(v57, "/private/var/mobile/Library/Logs/CellularLogging");
        v58 = xpc_string_create(v57);
        if (!v58)
          v58 = xpc_null_create();
        xpc_dictionary_set_value(v33, "LogPath", v58);
        v59 = xpc_null_create();
        xpc_release(v58);
        xpc_release(v59);
        operator delete(v57);
        (*(void (**)(uint8_t *__return_ptr))(**(_QWORD **)(v5 + 184) + 120))(buf);
        if (v87 >= 0)
          v60 = (const char *)buf;
        else
          v60 = *(const char **)buf;
        v61 = xpc_string_create(v60);
        if (!v61)
          v61 = xpc_null_create();
        xpc_dictionary_set_value(v33, "kKeyLogExt", v61);
        v62 = xpc_null_create();
        xpc_release(v61);
        xpc_release(v62);
        if (SHIBYTE(v87) < 0)
          operator delete(*(void **)buf);
        v63 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 184) + 112))(*(_QWORD *)(v5 + 184));
        v64 = xpc_int64_create(v63);
        if (!v64)
          v64 = xpc_null_create();
        xpc_dictionary_set_value(v33, "kKeyMaxNumberOfFiles", v64);
        v65 = xpc_null_create();
        xpc_release(v64);
        xpc_release(v65);
        v66 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 184) + 136))(*(_QWORD *)(v5 + 184));
        v67 = xpc_int64_create(v66);
        if (!v67)
          v67 = xpc_null_create();
        xpc_dictionary_set_value(v33, "kKeyFileSize", v67);
        v68 = xpc_null_create();
        xpc_release(v67);
        xpc_release(v68);
        (*(void (**)(xpc_object_t *__return_ptr))(**(_QWORD **)(v5 + 184) + 144))(&value);
        xpc_dictionary_set_value(v33, "kKeyGUIDLists", value);
        v69 = value;
        value = xpc_null_create();
        xpc_release(v69);
        xpc_release(value);
        value = 0;
        (*(void (**)(xpc_object_t *__return_ptr))(**(_QWORD **)(v5 + 184) + 152))(&v80);
        xpc_dictionary_set_value(v33, "kKeyDIAGIDLists", v80);
        v70 = v80;
        v80 = xpc_null_create();
        xpc_release(v70);
        xpc_release(v80);
        v80 = 0;
        if (v20)
          free(v20);
        v71 = *(NSObject **)(v5 + 112);
        if (v71)
        {
          dispatch_retain(*(dispatch_object_t *)(v5 + 112));
          dispatch_group_enter(v71);
        }
        v72 = *(NSObject **)(v5 + 160);
        *(_QWORD *)(v5 + 160) = v71;
        if (v72)
        {
          dispatch_group_leave(v72);
          dispatch_release(v72);
        }
        if (v33)
        {
          xpc_retain(v33);
          v73 = v33;
        }
        else
        {
          v73 = xpc_null_create();
        }
        if (*(_QWORD *)a4)
          v74 = _Block_copy(*(const void **)a4);
        else
          v74 = 0;
        v75 = *(NSObject **)(a4 + 8);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&v87 = 3321888768;
        *((_QWORD *)&v87 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        v88 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v74)
          v76 = _Block_copy(v74);
        else
          v76 = 0;
        v91 = 0;
        aBlock = v76;
        object = v73;
        if (v73)
          xpc_retain(v73);
        else
          object = xpc_null_create();
        dispatch_async(v75, buf);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v74)
          _Block_release(v74);
        xpc_release(v73);
        xpc_release(v33);
        goto LABEL_168;
      }
      v14 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object has not been created!", buf, 2u);
      }
      v12 = xpc_null_create();
      if (*(_QWORD *)a4)
        v15 = _Block_copy(*(const void **)a4);
      else
        v15 = 0;
      v23 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&v87 = 3321888768;
      *((_QWORD *)&v87 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v88 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v15)
      {
        v24 = _Block_copy(v15);
        v91 = -534716414;
        aBlock = v24;
        object = v12;
        if (v12)
        {
LABEL_33:
          xpc_retain(v12);
LABEL_36:
          dispatch_async(v23, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v15)
            _Block_release(v15);
          goto LABEL_93;
        }
      }
      else
      {
        v91 = -534716414;
        aBlock = 0;
        object = v12;
        if (v12)
          goto LABEL_33;
      }
      object = xpc_null_create();
      goto LABEL_36;
    }
  }
LABEL_168:
  v77 = v85;
  if (v85)
  {
    v78 = (unint64_t *)&v85->__shared_owners_;
    do
      v79 = __ldaxr(v78);
    while (__stlxr(v79 - 1, v78));
    if (!v79)
    {
      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
      std::__shared_weak_count::__release_weak(v77);
    }
  }
}

void sub_1A34EDCF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  xpc_release(v22);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t abm::CellularLoggingTask::isCarrierBundleKeyExist(abm::CellularLoggingTask *this)
{
  uint64_t result;
  char __p[23];
  char v3;
  std::string v4;
  BOOL v5;

  v5 = 0;
  result = *((_QWORD *)this + 23);
  if (result)
  {
    memset(&v4, 170, sizeof(v4));
    strcpy(__p, "CellularLoggingAllowed");
    v3 = 22;
    abm::CellularLoggingCommon::getProperty(result, __p, &v4);
    if (v3 < 0)
      operator delete(*(void **)__p);
    util::convert<BOOL>(&v4, &v5, 0);
    if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v4.__r_.__value_.__l.__data_);
    return v5;
  }
  return result;
}

void sub_1A34EDF10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingTask::isAppEntitled()
{
  return TelephonyXPC::ServerClientState::isClientEntitled();
}

BOOL abm::CellularLoggingTask::isUserAgreeLegalInfo(abm::CellularLoggingTask *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  std::string::size_type v5;
  std::string::size_type size;
  std::string *p_sz;
  int v8;
  size_t v9;
  int v10;
  std::string::size_type v11;
  unint64_t v12;
  std::string *p_dst;
  uint64_t v14;
  uint64_t v15;
  std::string *v16;
  std::string *v17;
  std::string *v18;
  std::string::size_type v19;
  char v20;
  const __CFAllocator *v21;
  __CFBundle *v22;
  const __CFURL *v23;
  __CFBundle *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  std::string::size_type v30;
  std::string v32;
  __CFBundle *v33;
  std::string v34;
  void *v35[2];
  char v36;
  std::string __sz;
  void *__p[2];
  char v39;
  std::string v40;
  const __CFString *v41;
  std::string __dst;
  __CFBundle *v43;
  std::string v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  memset(&v40, 170, sizeof(v40));
  v2 = *((_QWORD *)this + 23);
  v39 = 12;
  strcpy((char *)__p, "CarrierName1");
  abm::CellularLoggingCommon::getProperty(v2, (const std::string::value_type *)__p, &v40);
  if (v39 < 0)
    operator delete(__p[0]);
  memset(&__sz, 170, sizeof(__sz));
  v3 = *((_QWORD *)this + 23);
  v36 = 12;
  strcpy((char *)v35, "CarrierName2");
  abm::CellularLoggingCommon::getProperty(v3, (const std::string::value_type *)v35, &__sz);
  if (v36 < 0)
  {
    operator delete(v35[0]);
    memset(&v34, 170, sizeof(v34));
    v4 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      if (v4)
      {
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v40.__r_.__value_.__l.__data_;
        v5 = v40.__r_.__value_.__r.__words[2];
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    memset(&v34, 170, sizeof(v34));
    v4 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_5;
  }
  size = v40.__r_.__value_.__l.__size_;
  if (v40.__r_.__value_.__l.__size_)
  {
    p_sz = &v40;
    goto LABEL_20;
  }
LABEL_10:
  if (SHIBYTE(__sz.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __sz.__r_.__value_.__l.__size_;
    if (!__sz.__r_.__value_.__l.__size_)
    {
LABEL_25:
      *((_BYTE *)&v34.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v34, "Carrier");
      v8 = (char)v4;
      if ((v4 & 0x80u) == 0)
        v9 = v4;
      else
        v9 = v40.__r_.__value_.__l.__size_;
      if (!v9)
        goto LABEL_48;
      goto LABEL_29;
    }
    p_sz = &__sz;
LABEL_20:
    std::string::__init_copy_ctor_external(&v34, p_sz->__r_.__value_.__l.__data_, size);
    v8 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
    else
      v9 = v40.__r_.__value_.__l.__size_;
    if (!v9)
      goto LABEL_48;
    goto LABEL_29;
  }
  if (!*((_BYTE *)&__sz.__r_.__value_.__s + 23))
    goto LABEL_25;
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&__sz.__r_.__value_.__l.__data_;
  v5 = __sz.__r_.__value_.__r.__words[2];
LABEL_13:
  v34.__r_.__value_.__r.__words[2] = v5;
  v8 = (char)v4;
  if ((v4 & 0x80u) == 0)
    v9 = v4;
  else
    v9 = v40.__r_.__value_.__l.__size_;
  if (!v9)
    goto LABEL_48;
LABEL_29:
  v10 = SHIBYTE(__sz.__r_.__value_.__r.__words[2]);
  if ((__sz.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = HIBYTE(__sz.__r_.__value_.__r.__words[2]);
  else
    v11 = __sz.__r_.__value_.__l.__size_;
  if (v11)
  {
    v12 = v9 + 5;
    memset(&__dst, 170, sizeof(__dst));
    if (v9 + 5 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v12 > 0x16)
    {
      v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17)
        v14 = v12 | 7;
      v15 = v14 + 1;
      p_dst = (std::string *)operator new(v14 + 1);
      __dst.__r_.__value_.__l.__size_ = v9 + 5;
      __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v9 + 5;
    }
    if (v8 >= 0)
      v16 = &v40;
    else
      v16 = (std::string *)v40.__r_.__value_.__r.__words[0];
    memmove(p_dst, v16, v9);
    strcpy((char *)p_dst + v9, " and ");
    if (v10 >= 0)
      v17 = &__sz;
    else
      v17 = (std::string *)__sz.__r_.__value_.__r.__words[0];
    v18 = std::string::append(&__dst, (const std::string::value_type *)v17, v11);
    v19 = v18->__r_.__value_.__r.__words[0];
    v44.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v44.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v34.__r_.__value_.__l.__data_);
    v34.__r_.__value_.__r.__words[0] = v19;
    v34.__r_.__value_.__l.__size_ = v44.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&v34.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v44.__r_.__value_.__r.__words + 7);
    *((_BYTE *)&v34.__r_.__value_.__s + 23) = v20;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_49;
      goto LABEL_51;
    }
  }
LABEL_48:
  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_49:
    v32 = v34;
    goto LABEL_52;
  }
LABEL_51:
  std::string::__init_copy_ctor_external(&v32, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
LABEL_52:
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v44, v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
  else
    v44 = v32;
  v41 = 0;
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__dst, v44.__r_.__value_.__l.__data_, v44.__r_.__value_.__l.__size_);
  else
    __dst = v44;
  v43 = 0;
  v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (ctu::cf::convert_copy())
    v22 = v43;
  else
    v22 = 0;
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v33 = v22;
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_63;
LABEL_83:
    operator delete(v44.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_64;
    goto LABEL_84;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  v33 = v22;
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_83;
LABEL_63:
  if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_64;
LABEL_84:
  operator delete(v32.__r_.__value_.__l.__data_);
LABEL_64:
  __dst.__r_.__value_.__r.__words[0] = 0;
  v23 = CFURLCreateWithFileSystemPath(v21, CFSTR("/System/Library/PrivateFrameworks/ABMHelper.framework"), kCFURLPOSIXPathStyle, 0);
  v44.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
  v24 = CFBundleCreate(v21, v23);
  v43 = v24;
  v25 = CFBundleCopyLocalizedString(v24, CFSTR("USERCONFIRM_MESSAGE"), CFSTR("USERCONFIRM_MESSAGE"), CFSTR("CellularLoggingTask"));
  v26 = CFStringCreateWithFormat(v21, 0, v25, v22);
  v41 = v26;
  v27 = CFBundleCopyLocalizedString(v24, CFSTR("USERCONFIRM_TITLE"), CFSTR("USERCONFIRM_TITLE"), CFSTR("CellularLoggingTask"));
  v28 = CFBundleCopyLocalizedString(v24, CFSTR("USERCONFIRM_ALLOW"), CFSTR("USERCONFIRM_ALLOW"), CFSTR("CellularLoggingTask"));
  v29 = CFBundleCopyLocalizedString(v24, CFSTR("USERCONFIRM_DENY"), CFSTR("USERCONFIRM_DENY"), CFSTR("CellularLoggingTask"));
  CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, v27, v26, v28, v29, 0, (CFOptionFlags *)&__dst);
  CFRelease(v25);
  v30 = __dst.__r_.__value_.__r.__words[0];
  if (v29)
    CFRelease(v29);
  if (v28)
    CFRelease(v28);
  if (v27)
    CFRelease(v27);
  if (v26)
    CFRelease(v26);
  if (v24)
    CFRelease(v24);
  if (v23)
    CFRelease(v23);
  if (v22)
    CFRelease(v22);
  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__sz.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_80;
LABEL_86:
    operator delete(__sz.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return v30 == 0;
LABEL_87:
    operator delete(v40.__r_.__value_.__l.__data_);
    return v30 == 0;
  }
  operator delete(v34.__r_.__value_.__l.__data_);
  if (SHIBYTE(__sz.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_86;
LABEL_80:
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_87;
  return v30 == 0;
}

void sub_1A34EE554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a45 < 0)
    operator delete(a40);
  if (a57 < 0)
    operator delete(a52);
  _Unwind_Resume(exception_object);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_5(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  xpc_object_t v11;
  uint64_t v12;
  xpc_object_t v13;
  NSObject *v14;
  xpc_object_t v15;
  void *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  xpc_object_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  NSObject *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *p_shared_weak_owners;
  unint64_t v32;
  _QWORD *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  NSObject *v42;
  void *v43;
  NSObject *v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  std::__shared_weak_count *v47;
  uint8_t buf[8];
  uint64_t v49;
  void (*v50)(uint64_t);
  void *v51;
  void *aBlock;
  xpc_object_t object;
  int v54;
  _BYTE v55[24];
  _BYTE *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v47 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
      {
LABEL_82:
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v46 = __ldaxr(p_shared_owners);
        while (__stlxr(v46 - 1, p_shared_owners));
        if (!v46)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging Stop", buf, 2u);
      }
      if (*(_QWORD *)(v7 + 184))
      {
        v11 = xpc_dictionary_create(0, 0, 0);
        v12 = MEMORY[0x1E0C812F8];
        if (v11 || (v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v11) == v12)
          {
            xpc_retain(v11);
            v13 = v11;
          }
          else
          {
            v13 = xpc_null_create();
          }
        }
        else
        {
          v13 = xpc_null_create();
          v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A85902BC](v13) != v12)
        {
          v19 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary!", buf, 2u);
          }
          v20 = xpc_null_create();
          if (*(_QWORD *)a4)
            v21 = _Block_copy(*(const void **)a4);
          else
            v21 = 0;
          v24 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v49 = 3321888768;
          v50 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v51 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            v25 = _Block_copy(v21);
            v54 = -534716416;
            aBlock = v25;
            object = v20;
            if (v20)
            {
LABEL_39:
              xpc_retain(v20);
LABEL_42:
              dispatch_async(v24, buf);
              xpc_release(object);
              object = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v21)
                _Block_release(v21);
LABEL_46:
              xpc_release(v20);
              goto LABEL_81;
            }
          }
          else
          {
            v54 = -534716416;
            aBlock = 0;
            object = v20;
            if (v20)
              goto LABEL_39;
          }
          object = xpc_null_create();
          goto LABEL_42;
        }
        if (!abm::CellularLoggingCommon::isStarted(*(abm::CellularLoggingCommon **)(v7 + 184)))
        {
          v26 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1A343C000, v26, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
          }
          v20 = xpc_null_create();
          if (*(_QWORD *)a4)
            v27 = _Block_copy(*(const void **)a4);
          else
            v27 = 0;
          v42 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v49 = 3321888768;
          v50 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v51 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v27)
            v43 = _Block_copy(v27);
          else
            v43 = 0;
          v54 = 0;
          aBlock = v43;
          object = v20;
          if (v20)
            xpc_retain(v20);
          else
            object = xpc_null_create();
          dispatch_async(v42, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v27)
            _Block_release(v27);
          goto LABEL_46;
        }
        v22 = *(_QWORD *)(v7 + 184);
        if (*(_QWORD *)a4)
          v23 = _Block_copy(*(const void **)a4);
        else
          v23 = 0;
        v28 = *(NSObject **)(a4 + 8);
        if (v28)
          dispatch_retain(v28);
        v30 = a1[5];
        v29 = (std::__shared_weak_count *)a1[6];
        if (v29)
        {
          p_shared_weak_owners = (unint64_t *)&v29->__shared_weak_owners_;
          do
            v32 = __ldxr(p_shared_weak_owners);
          while (__stxr(v32 + 1, p_shared_weak_owners));
        }
        v56 = 0;
        v33 = operator new(0x30uLL);
        *v33 = &off_1E4A0B430;
        v33[1] = v23;
        v33[2] = v28;
        v33[3] = v30;
        v33[4] = v29;
        if (v29)
        {
          v34 = (unint64_t *)&v29->__shared_weak_owners_;
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
        }
        v33[5] = v7;
        v56 = v33;
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v22 + 64))(v22, v55);
        v40 = v56;
        if (v56 == v55)
        {
          v41 = 4;
          v40 = v55;
        }
        else
        {
          if (!v56)
          {
LABEL_77:
            if (v29)
              std::__shared_weak_count::__release_weak(v29);
            v44 = *(NSObject **)(v7 + 160);
            *(_QWORD *)(v7 + 160) = 0;
            if (v44)
            {
              dispatch_group_leave(v44);
              dispatch_release(v44);
            }
LABEL_81:
            xpc_release(v13);
            v9 = v47;
            if (!v47)
              return;
            goto LABEL_82;
          }
          v41 = 5;
        }
        (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*v40 + 8 * v41))(v40, v36, v37, v38, v39);
        goto LABEL_77;
      }
      v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object has not been created!", buf, 2u);
      }
      v15 = xpc_null_create();
      if (*(_QWORD *)a4)
        v16 = _Block_copy(*(const void **)a4);
      else
        v16 = 0;
      v17 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v49 = 3321888768;
      v50 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v51 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        v18 = _Block_copy(v16);
        v54 = -534716414;
        aBlock = v18;
        object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v16)
            _Block_release(v16);
          xpc_release(v15);
          goto LABEL_82;
        }
      }
      else
      {
        v54 = -534716414;
        aBlock = 0;
        object = v15;
        if (v15)
          goto LABEL_19;
      }
      object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A34EECE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t _ZZZN3abm19CellularLoggingTask9init_syncEvEUb_EN3__1D1Ev(uint64_t a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;

  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = *(NSObject **)(a1 + 8);
  if (v3)
    dispatch_release(v3);
  if (*(_QWORD *)a1)
    _Block_release(*(const void **)a1);
  return a1;
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_6(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  xpc_object_t v11;
  uint64_t v12;
  xpc_object_t v13;
  NSObject *v14;
  xpc_object_t v15;
  void *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  xpc_object_t v20;
  void *v21;
  unsigned int v22;
  xpc_object_t v23;
  xpc_object_t v24;
  NSObject *v25;
  const void *v26;
  void *v27;
  NSObject *v28;
  void *v29;
  NSObject *v30;
  void *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  std::__shared_weak_count *v34;
  uint8_t buf[8];
  uint64_t v36;
  void (*v37)(uint64_t);
  void *v38;
  void *aBlock;
  xpc_object_t object;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v34 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
      {
LABEL_63:
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v33 = __ldaxr(p_shared_owners);
        while (__stlxr(v33 - 1, p_shared_owners));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Getting Current Index", buf, 2u);
      }
      if (*(_QWORD *)(v7 + 184))
      {
        v11 = xpc_dictionary_create(0, 0, 0);
        v12 = MEMORY[0x1E0C812F8];
        if (v11 || (v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v11) == v12)
          {
            xpc_retain(v11);
            v13 = v11;
          }
          else
          {
            v13 = xpc_null_create();
          }
        }
        else
        {
          v13 = xpc_null_create();
          v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A85902BC](v13) != v12)
        {
          v19 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary!", buf, 2u);
          }
          v20 = xpc_null_create();
          if (*(_QWORD *)a4)
            v21 = _Block_copy(*(const void **)a4);
          else
            v21 = 0;
          v28 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v36 = 3321888768;
          v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            v29 = _Block_copy(v21);
            v41 = -534716416;
            aBlock = v29;
            object = v20;
            if (v20)
            {
LABEL_43:
              xpc_retain(v20);
LABEL_46:
              dispatch_async(v28, buf);
              xpc_release(object);
              object = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v21)
                _Block_release(v21);
              goto LABEL_62;
            }
          }
          else
          {
            v41 = -534716416;
            aBlock = 0;
            object = v20;
            if (v20)
              goto LABEL_43;
          }
          object = xpc_null_create();
          goto LABEL_46;
        }
        v22 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v7 + 184) + 160))(*(_QWORD *)(v7 + 184));
        v23 = xpc_int64_create(v22);
        if (!v23)
          v23 = xpc_null_create();
        xpc_dictionary_set_value(v13, "kKeyCurrentIndex", v23);
        v24 = xpc_null_create();
        xpc_release(v23);
        xpc_release(v24);
        v25 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v22;
          _os_log_impl(&dword_1A343C000, v25, OS_LOG_TYPE_DEFAULT, "#I Current Index is set to - 0x%x", buf, 8u);
        }
        if (v13)
        {
          xpc_retain(v13);
          v20 = v13;
          v26 = *(const void **)a4;
          if (*(_QWORD *)a4)
          {
LABEL_39:
            v27 = _Block_copy(v26);
            goto LABEL_53;
          }
        }
        else
        {
          v20 = xpc_null_create();
          v26 = *(const void **)a4;
          if (*(_QWORD *)a4)
            goto LABEL_39;
        }
        v27 = 0;
LABEL_53:
        v30 = *(NSObject **)(a4 + 8);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        v36 = 3321888768;
        v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v27)
        {
          v31 = _Block_copy(v27);
          v41 = 0;
          aBlock = v31;
          object = v20;
          if (v20)
          {
LABEL_55:
            xpc_retain(v20);
LABEL_58:
            dispatch_async(v30, buf);
            xpc_release(object);
            object = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v27)
              _Block_release(v27);
LABEL_62:
            xpc_release(v20);
            xpc_release(v13);
            v9 = v34;
            if (!v34)
              return;
            goto LABEL_63;
          }
        }
        else
        {
          v41 = 0;
          aBlock = 0;
          object = v20;
          if (v20)
            goto LABEL_55;
        }
        object = xpc_null_create();
        goto LABEL_58;
      }
      v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      v15 = xpc_null_create();
      if (*(_QWORD *)a4)
        v16 = _Block_copy(*(const void **)a4);
      else
        v16 = 0;
      v17 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v36 = 3321888768;
      v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        v18 = _Block_copy(v16);
        v41 = -534716416;
        aBlock = v18;
        object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v16)
            _Block_release(v16);
          xpc_release(v15);
          goto LABEL_63;
        }
      }
      else
      {
        v41 = -534716416;
        aBlock = 0;
        object = v15;
        if (v15)
          goto LABEL_19;
      }
      object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A34EF354(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_7(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  xpc_object_t v11;
  uint64_t v12;
  xpc_object_t v13;
  NSObject *v14;
  xpc_object_t v15;
  void *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  xpc_object_t v20;
  void *v21;
  xpc_object_t v22;
  xpc_object_t v23;
  xpc_object_t v24;
  const void *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  void *v30;
  void **v31;
  void **v32;
  void *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  void *__p[3];
  std::__shared_weak_count *v38;
  uint8_t buf[8];
  uint64_t v40;
  void (*v41)(uint64_t);
  void *v42;
  void *aBlock;
  xpc_object_t object;
  int v45;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v38 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
      {
LABEL_69:
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v35 = __ldaxr(p_shared_owners);
        while (__stlxr(v35 - 1, p_shared_owners));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Getting Config Lists", buf, 2u);
      }
      if (*(_QWORD *)(v7 + 184))
      {
        v11 = xpc_dictionary_create(0, 0, 0);
        v12 = MEMORY[0x1E0C812F8];
        if (v11 || (v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v11) == v12)
          {
            xpc_retain(v11);
            v13 = v11;
          }
          else
          {
            v13 = xpc_null_create();
          }
        }
        else
        {
          v13 = xpc_null_create();
          v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A85902BC](v13) != v12)
        {
          v19 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary!", buf, 2u);
          }
          v20 = xpc_null_create();
          if (*(_QWORD *)a4)
            v21 = _Block_copy(*(const void **)a4);
          else
            v21 = 0;
          v27 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v40 = 3321888768;
          v41 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v42 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            v28 = _Block_copy(v21);
            v45 = -534716416;
            aBlock = v28;
            object = v20;
            if (v20)
            {
LABEL_41:
              xpc_retain(v20);
LABEL_44:
              dispatch_async(v27, buf);
              xpc_release(object);
              object = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v21)
                _Block_release(v21);
              xpc_release(v20);
              goto LABEL_68;
            }
          }
          else
          {
            v45 = -534716416;
            aBlock = 0;
            object = v20;
            if (v20)
              goto LABEL_41;
          }
          object = xpc_null_create();
          goto LABEL_44;
        }
        memset(__p, 170, sizeof(__p));
        (*(void (**)(void **__return_ptr))(**(_QWORD **)(v7 + 184) + 168))(__p);
        v22 = xpc_data_create(__p[0], (char *)__p[1] - (char *)__p[0]);
        if (!v22)
          v22 = xpc_null_create();
        xpc_dictionary_set_value(v13, "kKeyConfigLists", v22);
        v23 = xpc_null_create();
        xpc_release(v22);
        xpc_release(v23);
        if (v13)
        {
          xpc_retain(v13);
          v24 = v13;
          v25 = *(const void **)a4;
          if (*(_QWORD *)a4)
          {
LABEL_37:
            v26 = _Block_copy(v25);
            goto LABEL_51;
          }
        }
        else
        {
          v24 = xpc_null_create();
          v25 = *(const void **)a4;
          if (*(_QWORD *)a4)
            goto LABEL_37;
        }
        v26 = 0;
LABEL_51:
        v29 = *(NSObject **)(a4 + 8);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        v40 = 3321888768;
        v41 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        v42 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v26)
        {
          v30 = _Block_copy(v26);
          v45 = 0;
          aBlock = v30;
          object = v24;
          if (v24)
          {
LABEL_53:
            xpc_retain(v24);
LABEL_56:
            dispatch_async(v29, buf);
            xpc_release(object);
            object = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v26)
              _Block_release(v26);
            xpc_release(v24);
            v31 = (void **)__p[0];
            if (__p[0])
            {
              v32 = (void **)__p[1];
              v33 = __p[0];
              if (__p[1] != __p[0])
              {
                do
                {
                  if (*((char *)v32 - 1) < 0)
                    operator delete(*(v32 - 3));
                  v32 -= 3;
                }
                while (v32 != v31);
                v33 = __p[0];
              }
              __p[1] = v31;
              operator delete(v33);
            }
LABEL_68:
            xpc_release(v13);
            v9 = v38;
            if (!v38)
              return;
            goto LABEL_69;
          }
        }
        else
        {
          v45 = 0;
          aBlock = 0;
          object = v24;
          if (v24)
            goto LABEL_53;
        }
        object = xpc_null_create();
        goto LABEL_56;
      }
      v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      v15 = xpc_null_create();
      if (*(_QWORD *)a4)
        v16 = _Block_copy(*(const void **)a4);
      else
        v16 = 0;
      v17 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v40 = 3321888768;
      v41 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v42 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        v18 = _Block_copy(v16);
        v45 = -534716416;
        aBlock = v18;
        object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v16)
            _Block_release(v16);
          xpc_release(v15);
          goto LABEL_69;
        }
      }
      else
      {
        v45 = -534716416;
        aBlock = 0;
        object = v15;
        if (v15)
          goto LABEL_19;
      }
      object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A34EF984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  void *v13;

  xpc_release(v13);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_8(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  abm::CellularLoggingCommon *v11;
  uint64_t v12;
  xpc_object_t v13;
  void *v14;
  NSObject *v15;
  xpc_object_t v16;
  void *v17;
  NSObject *v18;
  void *v19;
  NSObject *v20;
  void *v21;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  NSObject *v28;
  void *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  xpc_object_t object;
  std::__shared_weak_count *v34;
  uint8_t buf[8];
  uint64_t v36;
  void (*v37)(uint64_t);
  void *v38;
  void *aBlock;
  xpc_object_t v40;
  int v41;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v34 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
        goto LABEL_67;
      v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Pause Cellular Logging", buf, 2u);
      }
      v11 = *(abm::CellularLoggingCommon **)(v7 + 184);
      if (v11)
      {
        if (abm::CellularLoggingCommon::isStarted(v11))
        {
          v12 = *(_QWORD *)(v7 + 184);
          object = xpc_null_create();
          LOBYTE(v12) = (*(uint64_t (**)(uint64_t, xpc_object_t *))(*(_QWORD *)v12 + 72))(v12, &object);
          xpc_release(object);
          object = 0;
          if ((v12 & 1) != 0)
          {
            v13 = xpc_null_create();
            if (*(_QWORD *)a4)
              v14 = _Block_copy(*(const void **)a4);
            else
              v14 = 0;
            v26 = *(NSObject **)(a4 + 8);
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            v36 = 3321888768;
            v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v14)
            {
              v27 = _Block_copy(v14);
              v41 = 0;
              aBlock = v27;
              v40 = v13;
              if (v13)
              {
LABEL_48:
                xpc_retain(v13);
LABEL_55:
                dispatch_async(v26, buf);
                xpc_release(v40);
                v40 = 0;
                if (aBlock)
                  _Block_release(aBlock);
                if (v14)
                  _Block_release(v14);
LABEL_66:
                xpc_release(v13);
LABEL_67:
                p_shared_owners = (unint64_t *)&v9->__shared_owners_;
                do
                  v31 = __ldaxr(p_shared_owners);
                while (__stlxr(v31 - 1, p_shared_owners));
                if (!v31)
                {
                  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
                  std::__shared_weak_count::__release_weak(v9);
                }
                return;
              }
            }
            else
            {
              v41 = 0;
              aBlock = 0;
              v40 = v13;
              if (v13)
                goto LABEL_48;
            }
            v40 = xpc_null_create();
            goto LABEL_55;
          }
          v20 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v20, OS_LOG_TYPE_ERROR, "Failed to pause cellular logging", buf, 2u);
          }
          v13 = xpc_null_create();
          if (*(_QWORD *)a4)
            v21 = _Block_copy(*(const void **)a4);
          else
            v21 = 0;
          v28 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v36 = 3321888768;
          v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            v29 = _Block_copy(v21);
            v41 = -534716416;
            aBlock = v29;
            v40 = v13;
            if (v13)
            {
LABEL_52:
              xpc_retain(v13);
LABEL_62:
              dispatch_async(v28, buf);
              xpc_release(v40);
              v40 = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v21)
                _Block_release(v21);
              goto LABEL_66;
            }
          }
          else
          {
            v41 = -534716416;
            aBlock = 0;
            v40 = v13;
            if (v13)
              goto LABEL_52;
          }
          v40 = xpc_null_create();
          goto LABEL_62;
        }
        v18 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
        }
        v16 = xpc_null_create();
        if (*(_QWORD *)a4)
          v19 = _Block_copy(*(const void **)a4);
        else
          v19 = 0;
        v24 = *(NSObject **)(a4 + 8);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        v36 = 3321888768;
        v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v19)
        {
          v25 = _Block_copy(v19);
          v41 = 0;
          aBlock = v25;
          v40 = v16;
          if (v16)
          {
LABEL_37:
            xpc_retain(v16);
LABEL_40:
            dispatch_async(v24, buf);
            xpc_release(v40);
            v40 = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v19)
              _Block_release(v19);
LABEL_33:
            xpc_release(v16);
            goto LABEL_67;
          }
        }
        else
        {
          v41 = 0;
          aBlock = 0;
          v40 = v16;
          if (v16)
            goto LABEL_37;
        }
        v40 = xpc_null_create();
        goto LABEL_40;
      }
      v15 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v15, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      v16 = xpc_null_create();
      if (*(_QWORD *)a4)
        v17 = _Block_copy(*(const void **)a4);
      else
        v17 = 0;
      v22 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v36 = 3321888768;
      v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v17)
      {
        v23 = _Block_copy(v17);
        v41 = -534716416;
        aBlock = v23;
        v40 = v16;
        if (v16)
        {
LABEL_26:
          xpc_retain(v16);
LABEL_29:
          dispatch_async(v22, buf);
          xpc_release(v40);
          v40 = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v17)
            _Block_release(v17);
          goto LABEL_33;
        }
      }
      else
      {
        v41 = -534716416;
        aBlock = 0;
        v40 = v16;
        if (v16)
          goto LABEL_26;
      }
      v40 = xpc_null_create();
      goto LABEL_29;
    }
  }
}

void sub_1A34EFF84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A34EFFBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_9(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  abm::CellularLoggingCommon *v11;
  uint64_t v12;
  xpc_object_t v13;
  void *v14;
  NSObject *v15;
  xpc_object_t v16;
  void *v17;
  NSObject *v18;
  void *v19;
  NSObject *v20;
  void *v21;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  NSObject *v28;
  void *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  xpc_object_t object;
  std::__shared_weak_count *v34;
  uint8_t buf[8];
  uint64_t v36;
  void (*v37)(uint64_t);
  void *v38;
  void *aBlock;
  xpc_object_t v40;
  int v41;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v34 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
        goto LABEL_67;
      v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Resume Cellular Logging", buf, 2u);
      }
      v11 = *(abm::CellularLoggingCommon **)(v7 + 184);
      if (v11)
      {
        if (abm::CellularLoggingCommon::isStarted(v11))
        {
          v12 = *(_QWORD *)(v7 + 184);
          object = xpc_null_create();
          LOBYTE(v12) = (*(uint64_t (**)(uint64_t, xpc_object_t *))(*(_QWORD *)v12 + 80))(v12, &object);
          xpc_release(object);
          object = 0;
          if ((v12 & 1) != 0)
          {
            v13 = xpc_null_create();
            if (*(_QWORD *)a4)
              v14 = _Block_copy(*(const void **)a4);
            else
              v14 = 0;
            v26 = *(NSObject **)(a4 + 8);
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            v36 = 3321888768;
            v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v14)
            {
              v27 = _Block_copy(v14);
              v41 = 0;
              aBlock = v27;
              v40 = v13;
              if (v13)
              {
LABEL_48:
                xpc_retain(v13);
LABEL_55:
                dispatch_async(v26, buf);
                xpc_release(v40);
                v40 = 0;
                if (aBlock)
                  _Block_release(aBlock);
                if (v14)
                  _Block_release(v14);
LABEL_66:
                xpc_release(v13);
LABEL_67:
                p_shared_owners = (unint64_t *)&v9->__shared_owners_;
                do
                  v31 = __ldaxr(p_shared_owners);
                while (__stlxr(v31 - 1, p_shared_owners));
                if (!v31)
                {
                  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
                  std::__shared_weak_count::__release_weak(v9);
                }
                return;
              }
            }
            else
            {
              v41 = 0;
              aBlock = 0;
              v40 = v13;
              if (v13)
                goto LABEL_48;
            }
            v40 = xpc_null_create();
            goto LABEL_55;
          }
          v20 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v20, OS_LOG_TYPE_ERROR, "Failed to resume cellular logging", buf, 2u);
          }
          v13 = xpc_null_create();
          if (*(_QWORD *)a4)
            v21 = _Block_copy(*(const void **)a4);
          else
            v21 = 0;
          v28 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v36 = 3321888768;
          v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            v29 = _Block_copy(v21);
            v41 = -534716416;
            aBlock = v29;
            v40 = v13;
            if (v13)
            {
LABEL_52:
              xpc_retain(v13);
LABEL_62:
              dispatch_async(v28, buf);
              xpc_release(v40);
              v40 = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v21)
                _Block_release(v21);
              goto LABEL_66;
            }
          }
          else
          {
            v41 = -534716416;
            aBlock = 0;
            v40 = v13;
            if (v13)
              goto LABEL_52;
          }
          v40 = xpc_null_create();
          goto LABEL_62;
        }
        v18 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
        }
        v16 = xpc_null_create();
        if (*(_QWORD *)a4)
          v19 = _Block_copy(*(const void **)a4);
        else
          v19 = 0;
        v24 = *(NSObject **)(a4 + 8);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        v36 = 3321888768;
        v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v19)
        {
          v25 = _Block_copy(v19);
          v41 = 0;
          aBlock = v25;
          v40 = v16;
          if (v16)
          {
LABEL_37:
            xpc_retain(v16);
LABEL_40:
            dispatch_async(v24, buf);
            xpc_release(v40);
            v40 = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v19)
              _Block_release(v19);
LABEL_33:
            xpc_release(v16);
            goto LABEL_67;
          }
        }
        else
        {
          v41 = 0;
          aBlock = 0;
          v40 = v16;
          if (v16)
            goto LABEL_37;
        }
        v40 = xpc_null_create();
        goto LABEL_40;
      }
      v15 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v15, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      v16 = xpc_null_create();
      if (*(_QWORD *)a4)
        v17 = _Block_copy(*(const void **)a4);
      else
        v17 = 0;
      v22 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v36 = 3321888768;
      v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v17)
      {
        v23 = _Block_copy(v17);
        v41 = -534716416;
        aBlock = v23;
        v40 = v16;
        if (v16)
        {
LABEL_26:
          xpc_retain(v16);
LABEL_29:
          dispatch_async(v22, buf);
          xpc_release(v40);
          v40 = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v17)
            _Block_release(v17);
          goto LABEL_33;
        }
      }
      else
      {
        v41 = -534716416;
        aBlock = 0;
        v40 = v16;
        if (v16)
          goto LABEL_26;
      }
      v40 = xpc_null_create();
      goto LABEL_29;
    }
  }
}

void sub_1A34F0558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A34F0590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_10(_QWORD *a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  NSObject *v11;
  xpc_object_t v12;
  void *v13;
  void *v14;
  xpc_object_t value;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  NSObject *v20;
  std::string *v21;
  uint64_t **v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD **v29;
  _QWORD *v30;
  BOOL v31;
  xpc_object_t v32;
  void *v33;
  void *v34;
  NSObject *v35;
  void *v36;
  NSObject *v37;
  void *v38;
  unint64_t *p_shared_owners;
  unint64_t v40;
  std::string __p;
  uint64_t v42;
  void *v43;
  NSObject *v44;
  NSObject *v45;
  std::string v46;
  std::__shared_weak_count *v48;
  _QWORD v49[3];
  _QWORD *v50;
  std::string buf;
  void *v52;
  void *aBlock;
  xpc_object_t object;
  int v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v8 = a1[4];
    v9 = std::__shared_weak_count::lock(v5);
    v48 = v9;
    if (v9)
    {
      v10 = v9;
      if (!a1[5])
        goto LABEL_95;
      v11 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I Setting up bundle ID monitoring for Cellular Logging", (uint8_t *)&buf, 2u);
      }
      if (*(_QWORD *)(v8 + 168))
      {
        if (MEMORY[0x1A85902BC](*a3) != MEMORY[0x1E0C812F8])
        {
          v12 = xpc_null_create();
          if (*(_QWORD *)a4)
            v13 = _Block_copy(*(const void **)a4);
          else
            v13 = 0;
          v16 = *(NSObject **)(a4 + 8);
          buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
          buf.__r_.__value_.__l.__size_ = 3321888768;
          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v52 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v13)
          {
            v17 = _Block_copy(v13);
            v55 = -534716414;
            aBlock = v17;
            object = v12;
            if (v12)
            {
LABEL_17:
              xpc_retain(v12);
LABEL_20:
              dispatch_async(v16, &buf);
              xpc_release(object);
              object = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v13)
                _Block_release(v13);
LABEL_24:
              xpc_release(v12);
LABEL_95:
              p_shared_owners = (unint64_t *)&v10->__shared_owners_;
              do
                v40 = __ldaxr(p_shared_owners);
              while (__stlxr(v40 - 1, p_shared_owners));
              if (!v40)
              {
                ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
                std::__shared_weak_count::__release_weak(v10);
              }
              return;
            }
          }
          else
          {
            v55 = -534716414;
            aBlock = 0;
            object = v12;
            if (v12)
              goto LABEL_17;
          }
          object = xpc_null_create();
          goto LABEL_20;
        }
        memset(&v46, 170, sizeof(v46));
        value = xpc_dictionary_get_value(*a3, "kKeyAppBundleID");
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)value;
        if (value)
          xpc_retain(value);
        else
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
        xpc::dyn_cast_or_default();
        xpc_release(buf.__r_.__value_.__l.__data_);
        v20 = *(NSObject **)(v8 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          v21 = &v46;
          if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v21 = (std::string *)v46.__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
          _os_log_impl(&dword_1A343C000, v20, OS_LOG_TYPE_DEFAULT, "#I Preparing to set up monitoring for bundle ID %s", (uint8_t *)&buf, 0xCu);
        }
        v22 = *(uint64_t ***)(v8 + 168);
        v23 = *(NSObject **)(v8 + 88);
        v45 = v23;
        if (v23)
          dispatch_retain(v23);
        v42 = v8;
        if (*(_QWORD *)a4)
        {
          v24 = _Block_copy(*(const void **)a4);
          v25 = *(NSObject **)(a4 + 8);
          v43 = v24;
          v44 = v25;
          if (!v25)
            goto LABEL_46;
        }
        else
        {
          v24 = 0;
          v25 = *(NSObject **)(a4 + 8);
          v43 = 0;
          v44 = v25;
          if (!v25)
          {
LABEL_46:
            v50 = 0;
            v26 = operator new(0x20uLL);
            *v26 = &off_1E4A0B4C0;
            v26[1] = v8;
            v26[2] = v24;
            v26[3] = v25;
            v43 = 0;
            v44 = 0;
            v50 = v26;
            abm::AppMonitor::setAppStateHandler(v22, &v45, v49);
            v27 = v50;
            if (v50 == v49)
            {
              v28 = 4;
              v27 = v49;
            }
            else
            {
              if (!v50)
                goto LABEL_53;
              v28 = 5;
            }
            (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_53:
            if (v23)
              dispatch_release(v23);
            v29 = *(_QWORD ***)(v8 + 168);
            if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&__p, v46.__r_.__value_.__l.__data_, v46.__r_.__value_.__l.__size_);
            else
              __p = v46;
            v30 = *v29;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
            else
              buf = __p;
            v31 = abm::AppMonitorInternal::addBundleID(v30, (uint64_t)&buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(buf.__r_.__value_.__l.__data_);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_63:
                if (v31)
                {
LABEL_64:
                  abm::AppMonitorInternal::start(**(abm::AppMonitorInternal ***)(v8 + 168));
                  v32 = xpc_null_create();
                  if (*(_QWORD *)a4)
                    v33 = _Block_copy(*(const void **)a4);
                  else
                    v33 = 0;
                  v37 = *(NSObject **)(a4 + 8);
                  buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
                  buf.__r_.__value_.__l.__size_ = 3321888768;
                  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
                  v52 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
                  if (v33)
                    v38 = _Block_copy(v33);
                  else
                    v38 = 0;
                  v55 = 0;
                  aBlock = v38;
                  object = v32;
                  if (v32)
                    xpc_retain(v32);
                  else
                    object = xpc_null_create();
                  dispatch_async(v37, &buf);
                  xpc_release(object);
                  object = 0;
                  if (aBlock)
                    _Block_release(aBlock);
                  if (v33)
                    _Block_release(v33);
LABEL_93:
                  xpc_release(v32);
                  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v46.__r_.__value_.__l.__data_);
                  goto LABEL_95;
                }
LABEL_68:
                v32 = xpc_null_create();
                if (*(_QWORD *)a4)
                  v34 = _Block_copy(*(const void **)a4);
                else
                  v34 = 0;
                v35 = *(NSObject **)(a4 + 8);
                buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
                buf.__r_.__value_.__l.__size_ = 3321888768;
                buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
                v52 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
                if (v34)
                  v36 = _Block_copy(v34);
                else
                  v36 = 0;
                v55 = -534716416;
                aBlock = v36;
                object = v32;
                if (v32)
                  xpc_retain(v32);
                else
                  object = xpc_null_create();
                dispatch_async(v35, &buf);
                xpc_release(object);
                object = 0;
                if (aBlock)
                  _Block_release(aBlock);
                if (v34)
                  _Block_release(v34);
                goto LABEL_93;
              }
            }
            else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_63;
            }
            operator delete(__p.__r_.__value_.__l.__data_);
            if (v31)
              goto LABEL_64;
            goto LABEL_68;
          }
        }
        dispatch_retain(v25);
        goto LABEL_46;
      }
      v12 = xpc_null_create();
      if (*(_QWORD *)a4)
        v14 = _Block_copy(*(const void **)a4);
      else
        v14 = 0;
      v18 = *(NSObject **)(a4 + 8);
      buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
      buf.__r_.__value_.__l.__size_ = 3321888768;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v52 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v14)
      {
        v19 = _Block_copy(v14);
        v55 = -534716416;
        aBlock = v19;
        object = v12;
        if (v12)
        {
LABEL_28:
          xpc_retain(v12);
LABEL_31:
          dispatch_async(v18, &buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v14)
            _Block_release(v14);
          goto LABEL_24;
        }
      }
      else
      {
        v55 = -534716416;
        aBlock = 0;
        object = v12;
        if (v12)
          goto LABEL_28;
      }
      object = xpc_null_create();
      goto LABEL_31;
    }
  }
}

void sub_1A34F0C28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,xpc_object_t object,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t _ZZZN3abm19CellularLoggingTask9init_syncEvEUb0_EN3__2D1Ev(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 8);
  if (v3)
    _Block_release(v3);
  return a1;
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_12(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  xpc_object_t v11;
  uint64_t v12;
  xpc_object_t v13;
  NSObject *v14;
  xpc_object_t v15;
  void *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  xpc_object_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  NSObject *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *p_shared_weak_owners;
  unint64_t v32;
  _QWORD *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  NSObject *v42;
  void *v43;
  unint64_t *p_shared_owners;
  unint64_t v45;
  std::__shared_weak_count *v46;
  uint8_t buf[8];
  uint64_t v48;
  void (*v49)(uint64_t);
  void *v50;
  void *aBlock;
  xpc_object_t object;
  int v53;
  _BYTE v54[24];
  _BYTE *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v46 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
      {
LABEL_80:
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v45 = __ldaxr(p_shared_owners);
        while (__stlxr(v45 - 1, p_shared_owners));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging dump Telephony Logs", buf, 2u);
      }
      if (*(_QWORD *)(v7 + 184))
      {
        v11 = xpc_dictionary_create(0, 0, 0);
        v12 = MEMORY[0x1E0C812F8];
        if (v11 || (v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v11) == v12)
          {
            xpc_retain(v11);
            v13 = v11;
          }
          else
          {
            v13 = xpc_null_create();
          }
        }
        else
        {
          v13 = xpc_null_create();
          v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A85902BC](v13) != v12)
        {
          v19 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary", buf, 2u);
          }
          v20 = xpc_null_create();
          if (*(_QWORD *)a4)
            v21 = _Block_copy(*(const void **)a4);
          else
            v21 = 0;
          v24 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v48 = 3321888768;
          v49 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v50 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            v25 = _Block_copy(v21);
            v53 = -534716416;
            aBlock = v25;
            object = v20;
            if (v20)
            {
LABEL_39:
              xpc_retain(v20);
LABEL_42:
              dispatch_async(v24, buf);
              xpc_release(object);
              object = 0;
              if (aBlock)
                _Block_release(aBlock);
              if (v21)
                _Block_release(v21);
LABEL_46:
              xpc_release(v20);
              goto LABEL_79;
            }
          }
          else
          {
            v53 = -534716416;
            aBlock = 0;
            object = v20;
            if (v20)
              goto LABEL_39;
          }
          object = xpc_null_create();
          goto LABEL_42;
        }
        if (!abm::CellularLoggingCommon::isStarted(*(abm::CellularLoggingCommon **)(v7 + 184)))
        {
          v26 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1A343C000, v26, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
          }
          v20 = xpc_null_create();
          if (*(_QWORD *)a4)
            v27 = _Block_copy(*(const void **)a4);
          else
            v27 = 0;
          v42 = *(NSObject **)(a4 + 8);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v48 = 3321888768;
          v49 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v50 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v27)
            v43 = _Block_copy(v27);
          else
            v43 = 0;
          v53 = 0;
          aBlock = v43;
          object = v20;
          if (v20)
            xpc_retain(v20);
          else
            object = xpc_null_create();
          dispatch_async(v42, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v27)
            _Block_release(v27);
          goto LABEL_46;
        }
        v22 = *(_QWORD *)(v7 + 184);
        if (*(_QWORD *)a4)
          v23 = _Block_copy(*(const void **)a4);
        else
          v23 = 0;
        v28 = *(NSObject **)(a4 + 8);
        if (v28)
          dispatch_retain(v28);
        v30 = a1[5];
        v29 = (std::__shared_weak_count *)a1[6];
        if (v29)
        {
          p_shared_weak_owners = (unint64_t *)&v29->__shared_weak_owners_;
          do
            v32 = __ldxr(p_shared_weak_owners);
          while (__stxr(v32 + 1, p_shared_weak_owners));
        }
        v55 = 0;
        v33 = operator new(0x30uLL);
        *v33 = &off_1E4A0B540;
        v33[1] = v23;
        v33[2] = v28;
        v33[3] = v30;
        v33[4] = v29;
        if (v29)
        {
          v34 = (unint64_t *)&v29->__shared_weak_owners_;
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
        }
        v33[5] = v7;
        v55 = v33;
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v22 + 192))(v22, v54);
        v40 = v55;
        if (v55 == v54)
        {
          v41 = 4;
          v40 = v54;
        }
        else
        {
          if (!v55)
            goto LABEL_77;
          v41 = 5;
        }
        (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*v40 + 8 * v41))(v40, v36, v37, v38, v39);
LABEL_77:
        if (v29)
          std::__shared_weak_count::__release_weak(v29);
LABEL_79:
        xpc_release(v13);
        v9 = v46;
        if (!v46)
          return;
        goto LABEL_80;
      }
      v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object has not been created", buf, 2u);
      }
      v15 = xpc_null_create();
      if (*(_QWORD *)a4)
        v16 = _Block_copy(*(const void **)a4);
      else
        v16 = 0;
      v17 = *(NSObject **)(a4 + 8);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v48 = 3321888768;
      v49 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v50 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        v18 = _Block_copy(v16);
        v53 = -534716414;
        aBlock = v18;
        object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v16)
            _Block_release(v16);
          xpc_release(v15);
          goto LABEL_80;
        }
      }
      else
      {
        v53 = -534716414;
        aBlock = 0;
        object = v15;
        if (v15)
          goto LABEL_19;
      }
      object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A34F137C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t _ZZZN3abm19CellularLoggingTask9init_syncEvEUb1_EN3__3D1Ev(uint64_t a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;

  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = *(NSObject **)(a1 + 8);
  if (v3)
    dispatch_release(v3);
  if (*(_QWORD *)a1)
    _Block_release(*(const void **)a1);
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFBundle>::~CFSharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFURL const>::~CFSharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  xpc_object_t object;

  v1 = *(unsigned int *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  object = v2;
  if (v2)
    xpc_retain(v2);
  else
    object = xpc_null_create();
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A34F1574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEED1Ev(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  *a1 = &off_1E4A0B430;
  v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)a1[1];
  if (v4)
    _Block_release(v4);
  return a1;
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEED0Ev(_QWORD *__p)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  *__p = &off_1E4A0B430;
  v2 = (std::__shared_weak_count *)__p[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = __p[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)__p[1];
  if (v4)
    _Block_release(v4);
  operator delete(__p);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEv(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E4A0B430;
  v3 = (void *)a1[1];
  if (v3)
    v3 = _Block_copy(v3);
  v4 = a1[2];
  v2[1] = v3;
  v2[2] = v4;
  if (v4)
    dispatch_retain(v4);
  v5 = a1[4];
  v2[3] = a1[3];
  v2[4] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v2[5] = a1[5];
  return v2;
}

void _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEPNS0_6__baseIS9_EE(_QWORD *a1, _QWORD *a2)
{
  void *v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  *a2 = &off_1E4A0B430;
  v4 = (void *)a1[1];
  if (v4)
    v4 = _Block_copy(v4);
  v5 = a1[2];
  a2[1] = v4;
  a2[2] = v5;
  if (v5)
    dispatch_retain(v5);
  v6 = a1[4];
  a2[3] = a1[3];
  a2[4] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 16);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  a2[5] = a1[5];
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE7destroyEv(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)a1[1];
  if (v4)
    _Block_release(v4);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE18destroy_deallocateEv(_QWORD *__p)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  v2 = (std::__shared_weak_count *)__p[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = __p[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)__p[1];
  if (v4)
    _Block_release(v4);
  operator delete(__p);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEEclEObOS8_(_QWORD *a1, unsigned __int8 *a2, void **a3)
{
  int v4;
  void *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  NSObject *v11;
  xpc_object_t v12;
  const void *v13;
  void *v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  xpc_object_t v18;
  const void *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t);
  void *v29;
  void *aBlock;
  xpc_object_t object;
  int v32;

  v4 = *a2;
  v5 = *a3;
  *a3 = xpc_null_create();
  v6 = (std::__shared_weak_count *)a1[4];
  if (!v6)
    goto LABEL_39;
  v7 = a1[5];
  v8 = std::__shared_weak_count::lock(v6);
  if (!v8)
    goto LABEL_39;
  v9 = v8;
  if (a1[3])
  {
    v10 = MEMORY[0x1E0C809B0];
    if (v4)
      goto LABEL_21;
    v11 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to stop log collection", (uint8_t *)&v26, 2u);
      if (v5)
      {
LABEL_7:
        xpc_retain(v5);
        v12 = v5;
        v13 = (const void *)a1[1];
        if (v13)
          goto LABEL_8;
        goto LABEL_13;
      }
    }
    else if (v5)
    {
      goto LABEL_7;
    }
    v12 = xpc_null_create();
    v13 = (const void *)a1[1];
    if (v13)
    {
LABEL_8:
      v14 = _Block_copy(v13);
      v15 = v14;
      v16 = a1[2];
      v26 = v10;
      v27 = 3321888768;
      v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v14)
      {
        v17 = _Block_copy(v14);
        v32 = -534716416;
        aBlock = v17;
        object = v12;
        if (v12)
        {
LABEL_10:
          xpc_retain(v12);
LABEL_16:
          dispatch_async(v16, &v26);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v15)
            _Block_release(v15);
          xpc_release(v12);
LABEL_21:
          if (v5)
          {
            xpc_retain(v5);
            v18 = v5;
            v19 = (const void *)a1[1];
            if (v19)
              goto LABEL_23;
          }
          else
          {
            v18 = xpc_null_create();
            v19 = (const void *)a1[1];
            if (v19)
            {
LABEL_23:
              v20 = _Block_copy(v19);
              v21 = v20;
              v22 = a1[2];
              v26 = v10;
              v27 = 3321888768;
              v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
              v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
              if (v20)
              {
                v23 = _Block_copy(v20);
                v32 = 0;
                aBlock = v23;
                object = v18;
                if (v18)
                {
LABEL_25:
                  xpc_retain(v18);
LABEL_30:
                  dispatch_async(v22, &v26);
                  xpc_release(object);
                  object = 0;
                  if (aBlock)
                    _Block_release(aBlock);
                  if (v21)
                    _Block_release(v21);
                  xpc_release(v18);
                  goto LABEL_35;
                }
LABEL_29:
                object = xpc_null_create();
                goto LABEL_30;
              }
LABEL_28:
              v32 = 0;
              aBlock = 0;
              object = v18;
              if (v18)
                goto LABEL_25;
              goto LABEL_29;
            }
          }
          v21 = 0;
          v22 = a1[2];
          v26 = v10;
          v27 = 3321888768;
          v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          goto LABEL_28;
        }
LABEL_15:
        object = xpc_null_create();
        goto LABEL_16;
      }
LABEL_14:
      v32 = -534716416;
      aBlock = 0;
      object = v12;
      if (v12)
        goto LABEL_10;
      goto LABEL_15;
    }
LABEL_13:
    v15 = 0;
    v16 = a1[2];
    v26 = v10;
    v27 = 3321888768;
    v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
    v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    goto LABEL_14;
  }
LABEL_35:
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_39:
  xpc_release(v5);
}

uint64_t _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE11target_typeEv()
{
  return &_ZTIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1;
}

_QWORD *_ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEED1Ev(_QWORD *a1)
{
  NSObject *v2;
  const void *v3;

  *a1 = &off_1E4A0B4C0;
  v2 = a1[3];
  if (v2)
    dispatch_release(v2);
  v3 = (const void *)a1[2];
  if (v3)
    _Block_release(v3);
  return a1;
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEED0Ev(_QWORD *__p)
{
  NSObject *v2;
  const void *v3;

  *__p = &off_1E4A0B4C0;
  v2 = __p[3];
  if (v2)
    dispatch_release(v2);
  v3 = (const void *)__p[2];
  if (v3)
    _Block_release(v3);
  operator delete(__p);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE7__cloneEv(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  NSObject *v5;

  v2 = operator new(0x20uLL);
  v4 = a1[1];
  v3 = (void *)a1[2];
  *v2 = &off_1E4A0B4C0;
  v2[1] = v4;
  if (v3)
    v3 = _Block_copy(v3);
  v5 = a1[3];
  v2[2] = v3;
  v2[3] = v5;
  if (v5)
    dispatch_retain(v5);
  return v2;
}

void _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE7__cloneEPNS0_6__baseISD_EE(_QWORD *a1, _QWORD *a2)
{
  void *v4;
  uint64_t v5;
  NSObject *v6;

  v5 = a1[1];
  v4 = (void *)a1[2];
  *a2 = &off_1E4A0B4C0;
  a2[1] = v5;
  if (v4)
    v4 = _Block_copy(v4);
  v6 = a1[3];
  a2[2] = v4;
  a2[3] = v6;
  if (v6)
    dispatch_retain(v6);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE7destroyEv(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  v2 = *(NSObject **)(a1 + 24);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 16);
  if (v3)
    _Block_release(v3);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE18destroy_deallocateEv(_QWORD *__p)
{
  NSObject *v2;
  const void *v3;

  v2 = __p[3];
  if (v2)
    dispatch_release(v2);
  v3 = (const void *)__p[2];
  if (v3)
    _Block_release(v3);
  operator delete(__p);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEEclEOSB_OSC_(_QWORD *a1, uint64_t a2, int *a3)
{
  int v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD *v8;
  NSObject *v9;
  xpc_object_t v10;
  const void *v11;
  void *v12;
  NSObject *v13;
  xpc_object_t v14;
  const void *v15;
  void *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  void *v20;
  void *__p[2];
  uint64_t v22;
  uint8_t buf[8];
  uint64_t v24;
  void (*v25)(uint64_t);
  void *v26;
  void *aBlock;
  xpc_object_t object;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)__p = *(_OWORD *)a2;
  v22 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v4 = *a3;
  v5 = (_QWORD *)a1[1];
  v6 = v5[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v4;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I App state: %d", buf, 8u);
  }
  if (v4 == 1)
  {
    v7 = v5[23];
    if (v7)
    {
      (*(void (**)(uint64_t, void **))(*(_QWORD *)v7 + 184))(v7, __p);
      v8 = (_QWORD *)v5[21];
      if (v8)
      {
        *(_QWORD *)buf = *v8;
        ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>(*(uint64_t **)buf, buf);
        goto LABEL_37;
      }
      v13 = v5[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "AppMonitor object doesn't exist!", buf, 2u);
      }
      v14 = xpc_null_create();
      v15 = (const void *)a1[2];
      if (v15)
        v16 = _Block_copy(v15);
      else
        v16 = 0;
      v19 = a1[3];
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v24 = 3321888768;
      v25 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v26 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        v20 = _Block_copy(v16);
        v29 = -534716416;
        aBlock = v20;
        object = v14;
        if (v14)
        {
LABEL_29:
          xpc_retain(v14);
LABEL_32:
          dispatch_async(v19, buf);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v16)
            _Block_release(v16);
          xpc_release(v14);
          goto LABEL_37;
        }
      }
      else
      {
        v29 = -534716416;
        aBlock = 0;
        object = v14;
        if (v14)
          goto LABEL_29;
      }
      object = xpc_null_create();
      goto LABEL_32;
    }
    v9 = v5[5];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
    }
    v10 = xpc_null_create();
    v11 = (const void *)a1[2];
    if (v11)
      v12 = _Block_copy(v11);
    else
      v12 = 0;
    v17 = a1[3];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v24 = 3321888768;
    v25 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
    v26 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v12)
    {
      v18 = _Block_copy(v12);
      v29 = -534716416;
      aBlock = v18;
      object = v10;
      if (v10)
      {
LABEL_18:
        xpc_retain(v10);
LABEL_21:
        dispatch_async(v17, buf);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v12)
          _Block_release(v12);
        xpc_release(v10);
        goto LABEL_37;
      }
    }
    else
    {
      v29 = -534716416;
      aBlock = 0;
      object = v10;
      if (v10)
        goto LABEL_18;
    }
    object = xpc_null_create();
    goto LABEL_21;
  }
LABEL_37:
  if (SHIBYTE(v22) < 0)
    operator delete(__p[0]);
}

void sub_1A34F2038(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void sub_1A34F208C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A34F207CLL);
}

uint64_t _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE11target_typeEv()
{
  return &_ZTIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2;
}

_QWORD *_ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEED1Ev(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  *a1 = &off_1E4A0B540;
  v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)a1[1];
  if (v4)
    _Block_release(v4);
  return a1;
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEED0Ev(_QWORD *__p)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  *__p = &off_1E4A0B540;
  v2 = (std::__shared_weak_count *)__p[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = __p[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)__p[1];
  if (v4)
    _Block_release(v4);
  operator delete(__p);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEv(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E4A0B540;
  v3 = (void *)a1[1];
  if (v3)
    v3 = _Block_copy(v3);
  v4 = a1[2];
  v2[1] = v3;
  v2[2] = v4;
  if (v4)
    dispatch_retain(v4);
  v5 = a1[4];
  v2[3] = a1[3];
  v2[4] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v2[5] = a1[5];
  return v2;
}

void _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEPNS0_6__baseIS9_EE(_QWORD *a1, _QWORD *a2)
{
  void *v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  *a2 = &off_1E4A0B540;
  v4 = (void *)a1[1];
  if (v4)
    v4 = _Block_copy(v4);
  v5 = a1[2];
  a2[1] = v4;
  a2[2] = v5;
  if (v5)
    dispatch_retain(v5);
  v6 = a1[4];
  a2[3] = a1[3];
  a2[4] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 16);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  a2[5] = a1[5];
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE7destroyEv(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)a1[1];
  if (v4)
    _Block_release(v4);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE18destroy_deallocateEv(_QWORD *__p)
{
  std::__shared_weak_count *v2;
  NSObject *v3;
  const void *v4;

  v2 = (std::__shared_weak_count *)__p[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = __p[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)__p[1];
  if (v4)
    _Block_release(v4);
  operator delete(__p);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEEclEObOS8_(_QWORD *a1, unsigned __int8 *a2, void **a3)
{
  int v4;
  void *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  NSObject *v11;
  xpc_object_t v12;
  const void *v13;
  void *v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  xpc_object_t v18;
  const void *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t);
  void *v29;
  void *aBlock;
  xpc_object_t object;
  int v32;

  v4 = *a2;
  v5 = *a3;
  *a3 = xpc_null_create();
  v6 = (std::__shared_weak_count *)a1[4];
  if (!v6)
    goto LABEL_39;
  v7 = a1[5];
  v8 = std::__shared_weak_count::lock(v6);
  if (!v8)
    goto LABEL_39;
  v9 = v8;
  if (a1[3])
  {
    v10 = MEMORY[0x1E0C809B0];
    if (v4)
      goto LABEL_21;
    v11 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to snapshot", (uint8_t *)&v26, 2u);
      if (v5)
      {
LABEL_7:
        xpc_retain(v5);
        v12 = v5;
        v13 = (const void *)a1[1];
        if (v13)
          goto LABEL_8;
        goto LABEL_13;
      }
    }
    else if (v5)
    {
      goto LABEL_7;
    }
    v12 = xpc_null_create();
    v13 = (const void *)a1[1];
    if (v13)
    {
LABEL_8:
      v14 = _Block_copy(v13);
      v15 = v14;
      v16 = a1[2];
      v26 = v10;
      v27 = 3321888768;
      v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v14)
      {
        v17 = _Block_copy(v14);
        v32 = -534716416;
        aBlock = v17;
        object = v12;
        if (v12)
        {
LABEL_10:
          xpc_retain(v12);
LABEL_16:
          dispatch_async(v16, &v26);
          xpc_release(object);
          object = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v15)
            _Block_release(v15);
          xpc_release(v12);
LABEL_21:
          if (v5)
          {
            xpc_retain(v5);
            v18 = v5;
            v19 = (const void *)a1[1];
            if (v19)
              goto LABEL_23;
          }
          else
          {
            v18 = xpc_null_create();
            v19 = (const void *)a1[1];
            if (v19)
            {
LABEL_23:
              v20 = _Block_copy(v19);
              v21 = v20;
              v22 = a1[2];
              v26 = v10;
              v27 = 3321888768;
              v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
              v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
              if (v20)
              {
                v23 = _Block_copy(v20);
                v32 = 0;
                aBlock = v23;
                object = v18;
                if (v18)
                {
LABEL_25:
                  xpc_retain(v18);
LABEL_30:
                  dispatch_async(v22, &v26);
                  xpc_release(object);
                  object = 0;
                  if (aBlock)
                    _Block_release(aBlock);
                  if (v21)
                    _Block_release(v21);
                  xpc_release(v18);
                  goto LABEL_35;
                }
LABEL_29:
                object = xpc_null_create();
                goto LABEL_30;
              }
LABEL_28:
              v32 = 0;
              aBlock = 0;
              object = v18;
              if (v18)
                goto LABEL_25;
              goto LABEL_29;
            }
          }
          v21 = 0;
          v22 = a1[2];
          v26 = v10;
          v27 = 3321888768;
          v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          goto LABEL_28;
        }
LABEL_15:
        object = xpc_null_create();
        goto LABEL_16;
      }
LABEL_14:
      v32 = -534716416;
      aBlock = 0;
      object = v12;
      if (v12)
        goto LABEL_10;
      goto LABEL_15;
    }
LABEL_13:
    v15 = 0;
    v16 = a1[2];
    v26 = v10;
    v27 = 3321888768;
    v28 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
    v29 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    goto LABEL_14;
  }
LABEL_35:
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_39:
  xpc_release(v5);
}

uint64_t _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE11target_typeEv()
{
  return &_ZTIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3;
}

uint64_t _GLOBAL__sub_I_CellularLoggingTask_mm()
{
  uint64_t result;

  result = ETLDIAGLoggingGetDefaultView();
  dword_1ED114B44 = result;
  return result;
}

void abm::helper::getUserConfig(int a1@<W0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4;
  uint64_t v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  xpc_object_t v12;
  xpc_object_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  xpc_object_t v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t v21;
  xpc_object_t v22;
  xpc_object_t v23;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  xpc_object_t v27;
  xpc_object_t v28;
  xpc_object_t v29;
  xpc_object_t v30;
  xpc_object_t v31;
  xpc_object_t v32;
  xpc_object_t v33;
  xpc_object_t v34;
  xpc_object_t v35;
  xpc_object_t v36;
  xpc_object_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  xpc_object_t v40;
  xpc_object_t v41;
  xpc_object_t v42;
  const char *v43;
  xpc_object_t v44;
  xpc_object_t v45;
  xpc_object_t v46;
  xpc_object_t v47;
  xpc_object_t v48;
  xpc_object_t v49;
  xpc_object_t v50;
  xpc_object_t v51;
  char __p[23];
  char v53;

  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v4 = xpc_null_create();
  *a2 = v4;
  v5 = MEMORY[0x1E0C812F8];
  if (a1 == 501)
  {
    v8 = xpc_dictionary_create(0, 0, 0);
    if (v8 || (v8 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A85902BC](v8) == v5)
      {
        xpc_retain(v8);
        v9 = v8;
      }
      else
      {
        v9 = xpc_null_create();
      }
    }
    else
    {
      v9 = xpc_null_create();
      v8 = 0;
    }
    xpc_release(v8);
    v19 = xpc_null_create();
    v20 = *a2;
    *a2 = v9;
    xpc_release(v20);
    xpc_release(v19);
    v21 = xpc_string_create("CommCenterMobileHelper");
    if (!v21)
      v21 = xpc_null_create();
    xpc_dictionary_set_value(v9, (const char *)*MEMORY[0x1E0DBD8A0], v21);
    v22 = xpc_null_create();
    xpc_release(v21);
    xpc_release(v22);
    v23 = xpc_string_create("com.apple.abm.helper.mobile");
    if (!v23)
      v23 = xpc_null_create();
    xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E0DBD8A8], v23);
    v24 = xpc_null_create();
    xpc_release(v23);
    xpc_release(v24);
    v25 = xpc_array_create(0, 0);
    if (v25 || (v25 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A85902BC](v25) == MEMORY[0x1E0C812C8])
      {
        xpc_retain(v25);
        v26 = v25;
      }
      else
      {
        v26 = xpc_null_create();
      }
    }
    else
    {
      v26 = xpc_null_create();
      v25 = 0;
    }
    xpc_release(v25);
    v34 = xpc_string_create("com.apple.abm.helper.mobile.allow");
    if (!v34)
      v34 = xpc_null_create();
    xpc_array_append_value(v26, v34);
    xpc_release(v34);
    v35 = xpc_string_create("com.apple.developer.cellular-logging.allow");
    if (!v35)
      v35 = xpc_null_create();
    xpc_array_append_value(v26, v35);
    xpc_release(v35);
    v36 = xpc_string_create("com.apple.cellular-logging.internal");
    if (!v36)
      v36 = xpc_null_create();
    xpc_array_append_value(v26, v36);
    xpc_release(v36);
    if (v26)
    {
      xpc_retain(v26);
      v37 = v26;
    }
    else
    {
      v37 = xpc_null_create();
    }
    xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E0DBD8C0], v37);
    v38 = xpc_null_create();
    xpc_release(v37);
    xpc_release(v38);
    v53 = 20;
    strcpy(__p, "ABMMobileHelperReady");
    v39 = xpc_string_create(__p);
    if (!v39)
      v39 = xpc_null_create();
    xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E0DBD8C8], v39);
    v40 = xpc_null_create();
    xpc_release(v39);
    xpc_release(v40);
    if (v53 < 0)
      operator delete(*(void **)__p);
    xpc_release(v26);
    v4 = *a2;
  }
  else
  {
    if (a1 == 25)
    {
      v10 = xpc_dictionary_create(0, 0, 0);
      if (v10 || (v10 = xpc_null_create()) != 0)
      {
        if (MEMORY[0x1A85902BC](v10) == v5)
        {
          xpc_retain(v10);
          v11 = v10;
        }
        else
        {
          v11 = xpc_null_create();
        }
      }
      else
      {
        v11 = xpc_null_create();
        v10 = 0;
      }
      xpc_release(v10);
      v27 = xpc_null_create();
      v28 = *a2;
      *a2 = v11;
      xpc_release(v28);
      xpc_release(v27);
      v29 = xpc_string_create("abm-helper");
      if (!v29)
        v29 = xpc_null_create();
      xpc_dictionary_set_value(v11, (const char *)*MEMORY[0x1E0DBD8A0], v29);
      v30 = xpc_null_create();
      xpc_release(v29);
      xpc_release(v30);
      v31 = xpc_string_create("com.apple.abm.helper.wireless");
      if (!v31)
        v31 = xpc_null_create();
      v4 = *a2;
      xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E0DBD8A8], v31);
      v32 = xpc_null_create();
      xpc_release(v31);
      xpc_release(v32);
      strcpy(__p, "ABMWirelessHelperReady");
      v53 = 22;
      v18 = xpc_string_create(__p);
      if (!v18)
        v18 = xpc_null_create();
    }
    else
    {
      if (a1)
        goto LABEL_61;
      v6 = xpc_dictionary_create(0, 0, 0);
      if (v6 || (v6 = xpc_null_create()) != 0)
      {
        if (MEMORY[0x1A85902BC](v6) == v5)
        {
          xpc_retain(v6);
          v7 = v6;
        }
        else
        {
          v7 = xpc_null_create();
        }
      }
      else
      {
        v7 = xpc_null_create();
        v6 = 0;
      }
      xpc_release(v6);
      v12 = xpc_null_create();
      v13 = *a2;
      *a2 = v7;
      xpc_release(v13);
      xpc_release(v12);
      v14 = xpc_string_create("CommCenterRootHelper");
      if (!v14)
        v14 = xpc_null_create();
      xpc_dictionary_set_value(v7, (const char *)*MEMORY[0x1E0DBD8A0], v14);
      v15 = xpc_null_create();
      xpc_release(v14);
      xpc_release(v15);
      v16 = xpc_string_create("com.apple.abm.helper.root");
      if (!v16)
        v16 = xpc_null_create();
      v4 = *a2;
      xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E0DBD8A8], v16);
      v17 = xpc_null_create();
      xpc_release(v16);
      xpc_release(v17);
      v53 = 18;
      strcpy(__p, "ABMRootHelperReady");
      v18 = xpc_string_create(__p);
      if (!v18)
        v18 = xpc_null_create();
    }
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E0DBD8C8], v18);
    v33 = xpc_null_create();
    xpc_release(v18);
    xpc_release(v33);
    if (v53 < 0)
      operator delete(*(void **)__p);
  }
LABEL_61:
  if (MEMORY[0x1A85902BC](v4) == v5)
  {
    v41 = xpc_int64_create(a1);
    if (!v41)
      v41 = xpc_null_create();
    xpc_dictionary_set_value(v4, "UserID", v41);
    v42 = xpc_null_create();
    xpc_release(v41);
    xpc_release(v42);
    if (a1)
    {
      if (a1 == 501)
      {
        v43 = "mobile";
      }
      else if (a1 == 25)
      {
        v43 = "wireless";
      }
      else
      {
        v43 = "";
      }
    }
    else
    {
      v43 = "root";
    }
    v44 = xpc_string_create(v43);
    if (!v44)
      v44 = xpc_null_create();
    xpc_dictionary_set_value(v4, "UserName", v44);
    v45 = xpc_null_create();
    xpc_release(v44);
    xpc_release(v45);
    v46 = xpc_BOOL_create(0);
    if (!v46)
      v46 = xpc_null_create();
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E0DBD8D0], v46);
    v47 = xpc_null_create();
    xpc_release(v46);
    xpc_release(v47);
    v48 = xpc_BOOL_create(0);
    if (!v48)
      v48 = xpc_null_create();
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E0DBD8D8], v48);
    v49 = xpc_null_create();
    xpc_release(v48);
    xpc_release(v49);
    v50 = xpc_string_create("unknown");
    if (!v50)
      v50 = xpc_null_create();
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E0DBD898], v50);
    v51 = xpc_null_create();
    xpc_release(v50);
    xpc_release(v51);
  }
}

void sub_1A34F2F9C(_Unwind_Exception *a1)
{
  xpc_object_t *v1;
  void *v2;
  void *v3;

  xpc_release(v3);
  xpc_release(v2);
  xpc::dict::~dict(v1);
  _Unwind_Resume(a1);
}

uint64_t abm::helper::getDaemonNotificationName@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  if ((_DWORD)result == 501)
  {
    a2[23] = 20;
    strcpy(a2, "ABMMobileHelperReady");
  }
  else if ((_DWORD)result == 25)
  {
    strcpy(a2, "ABMWirelessHelperReady");
    a2[23] = 22;
  }
  else if ((_DWORD)result)
  {
    a2[23] = 0;
    *a2 = 0;
  }
  else
  {
    a2[23] = 18;
    strcpy(a2, "ABMRootHelperReady");
  }
  return result;
}

uint64_t abm::helper::getUserForTask(int a1)
{
  if ((a1 - 1) > 9)
    return 0xFFFFFFFFLL;
  else
    return dword_1A358205C[a1 - 1];
}

void abm::helper::getTasksForUser(int a1@<W0>, char **a2@<X8>)
{
  char *v4;
  char *v5;
  char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  char *v14;
  int64_t v15;
  unint64_t v16;
  char *v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  char *v23;
  uint64_t v24;
  __int128 v25;

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  do
  {
    v9 = v7 - 1;
    if (v9 > 9)
    {
      if (a1 == -1)
      {
LABEL_9:
        if (v6 < v5)
        {
          *(_DWORD *)v6 = v7;
          v8 = (uint64_t)(v6 + 4);
        }
        else
        {
          v10 = (v6 - v4) >> 2;
          v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 62)
            std::vector<abm::helper::TaskID>::__throw_length_error[abi:ne180100]();
          if ((v5 - v4) >> 1 > v11)
            v11 = (v5 - v4) >> 1;
          if ((unint64_t)(v5 - v4) >= 0x7FFFFFFFFFFFFFFCLL)
            v12 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v12 = v11;
          if (v12)
          {
            if (v12 >> 62)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v13 = operator new(4 * v12);
            v14 = &v13[4 * v10];
            *(_DWORD *)v14 = v7;
            v8 = (uint64_t)(v14 + 4);
            v15 = v6 - v4;
            if (v6 == v4)
              goto LABEL_24;
          }
          else
          {
            v13 = 0;
            v14 = (char *)(4 * v10);
            *(_DWORD *)(4 * v10) = v7;
            v8 = 4 * v10 + 4;
            v15 = v6 - v4;
            if (v6 == v4)
              goto LABEL_24;
          }
          v16 = v15 - 4;
          if (v16 >= 0xBC)
          {
            v19 = (v6 - 4 - v4) & 0xFFFFFFFFFFFFFFFCLL;
            if (&v13[v6 - v4 - 4 - v19] > &v13[v6 - v4 - 4])
            {
              v17 = v6;
            }
            else if (&v6[-v19 - 4] > v6 - 4)
            {
              v17 = v6;
            }
            else if ((unint64_t)(v4 - v13) >= 0x20)
            {
              v20 = (v16 >> 2) + 1;
              v21 = 4 * (v20 & 0x7FFFFFFFFFFFFFF8);
              v17 = &v6[-v21];
              v14 -= v21;
              v22 = &v13[4 * v10 - 16];
              v23 = v6 - 16;
              v24 = v20 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                v25 = *(_OWORD *)v23;
                *(v22 - 1) = *((_OWORD *)v23 - 1);
                *v22 = v25;
                v22 -= 2;
                v23 -= 32;
                v24 -= 8;
              }
              while (v24);
              if (v20 == (v20 & 0x7FFFFFFFFFFFFFF8))
                goto LABEL_24;
            }
            else
            {
              v17 = v6;
            }
          }
          else
          {
            v17 = v6;
          }
          do
          {
            v18 = *((_DWORD *)v17 - 1);
            v17 -= 4;
            *((_DWORD *)v14 - 1) = v18;
            v14 -= 4;
          }
          while (v17 != v4);
LABEL_24:
          v5 = &v13[4 * v12];
          *a2 = v14;
          a2[1] = (char *)v8;
          a2[2] = v5;
          if (v4)
            operator delete(v4);
          v4 = v14;
        }
        a2[1] = (char *)v8;
        v6 = (char *)v8;
      }
    }
    else if (dword_1A358205C[v9] == a1)
    {
      goto LABEL_9;
    }
    ++v7;
  }
  while (v7 != 11);
}

void sub_1A34F344C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::helper::getLoggingDomain@<X0>(int a1@<W0>, _BYTE *a2@<X8>)
{
  __int128 v4;
  _QWORD *v5;
  _QWORD *v6;
  const char *v7;
  size_t v8;
  size_t v9;
  _BYTE *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  void *__src[2];
  void *__p[2];
  __int128 v23;
  __int128 v24;
  _OWORD v25[9];
  unint64_t v26;

  v26 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[7] = v4;
  v25[8] = v4;
  v25[5] = v4;
  v25[6] = v4;
  v25[3] = v4;
  v25[4] = v4;
  v25[1] = v4;
  v25[2] = v4;
  v24 = v4;
  v25[0] = v4;
  *(_OWORD *)__p = v4;
  v23 = v4;
  v20 = v4;
  *(_OWORD *)__src = v4;
  v18 = v4;
  v19 = v4;
  v17 = v4;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v17);
  v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)"com.apple.abm.helper", 20);
  v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)".", 1);
  if ((a1 - 1) > 9)
    v7 = "";
  else
    v7 = (&off_1E4A0B648)[a1 - 1];
  v8 = strlen(v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)v7, v8);
  if ((BYTE8(v24) & 0x10) != 0)
  {
    v10 = (_BYTE *)v24;
    if ((void *)v24 < __src[1])
    {
      *(void **)&v24 = __src[1];
      v10 = __src[1];
    }
    v11 = __src[0];
    v9 = v10 - (char *)__src[0];
    if ((unint64_t)(v10 - (char *)__src[0]) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_21;
  }
  else
  {
    if ((BYTE8(v24) & 8) == 0)
    {
      v9 = 0;
      a2[23] = 0;
      goto LABEL_17;
    }
    v11 = (const void *)*((_QWORD *)&v19 + 1);
    v9 = *((_QWORD *)&v20 + 1) - *((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v20 + 1) - *((_QWORD *)&v19 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_21:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v9 >= 0x17)
  {
    v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v12 = v9 | 7;
    v13 = v12 + 1;
    v14 = operator new(v12 + 1);
    *((_QWORD *)a2 + 1) = v9;
    *((_QWORD *)a2 + 2) = v13 | 0x8000000000000000;
    *(_QWORD *)a2 = v14;
    a2 = v14;
    goto LABEL_16;
  }
  a2[23] = v9;
  if (v9)
LABEL_16:
    memmove(a2, v11, v9);
LABEL_17:
  a2[v9] = 0;
  *(_QWORD *)&v17 = *MEMORY[0x1E0DE4F50];
  v15 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v17 + *(_QWORD *)(v17 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v18 = v15;
  *((_QWORD *)&v18 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v23) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A858F92C](v25);
}

void sub_1A34F3674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *abm::helper::DaemonObserver::DaemonObserver(_QWORD *a1, int a2, uint64_t a3)
{
  const void **v6;
  void *v7;
  NSObject *v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  const void *v11;
  char __p[23];
  char v14;

  a1[2] = 0;
  v6 = (const void **)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  v7 = *(void **)a3;
  if (*(_QWORD *)a3)
    v7 = _Block_copy(v7);
  a1[3] = v7;
  v8 = *(NSObject **)(a3 + 8);
  a1[4] = v8;
  if (v8)
    dispatch_retain(v8);
  a1[5] = 0;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a2 == 501)
  {
    v14 = 20;
    strcpy(__p, "ABMMobileHelperReady");
  }
  else if (a2 == 25)
  {
    strcpy(__p, "ABMWirelessHelperReady");
    v14 = 22;
  }
  else if (a2)
  {
    v14 = 0;
    __p[0] = 0;
  }
  else
  {
    v14 = 18;
    strcpy(__p, "ABMRootHelperReady");
  }
  v10 = CFStringCreateWithCString(v9, __p, 0x600u);
  v11 = *v6;
  *v6 = v10;
  if (v11)
    CFRelease(v11);
  if (v14 < 0)
    operator delete(*(void **)__p);
  return a1;
}

void sub_1A34F37E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;
  const void **v15;
  uint64_t v16;
  std::__shared_weak_count *v18;

  if (a14 < 0)
  {
    operator delete(__p);
    dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback(v16);
    ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(v15);
    v18 = *(std::__shared_weak_count **)(v14 + 8);
    if (!v18)
LABEL_3:
      _Unwind_Resume(a1);
  }
  else
  {
    dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback(v16);
    ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(v15);
    v18 = *(std::__shared_weak_count **)(v14 + 8);
    if (!v18)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v18);
  _Unwind_Resume(a1);
}

uint64_t dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 8);
  if (v2)
    dispatch_release(v2);
  if (*(_QWORD *)a1)
    _Block_release(*(const void **)a1);
  return a1;
}

void abm::helper::DaemonObserver::~DaemonObserver(abm::helper::DaemonObserver *this)
{
  __CFNotificationCenter *DarwinNotifyCenter;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  std::__shared_weak_count *v8;

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, *((const void **)this + 5), *((CFNotificationName *)this + 2), 0);
  v3 = (_QWORD *)*((_QWORD *)this + 5);
  if (v3)
  {
    v4 = (std::__shared_weak_count *)v3[1];
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
    operator delete(v3);
    *((_QWORD *)this + 5) = 0;
  }
  v5 = *((_QWORD *)this + 4);
  if (v5)
    dispatch_release(v5);
  v6 = (const void *)*((_QWORD *)this + 3);
  if (v6)
    _Block_release(v6);
  v7 = (const void *)*((_QWORD *)this + 2);
  if (v7)
    CFRelease(v7);
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
}

void abm::helper::DaemonObserver::init(abm::helper::DaemonObserver *this)
{
  _QWORD *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __CFNotificationCenter *DarwinNotifyCenter;

  v2 = operator new(0x10uLL);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (!v3 || (v4 = *(_QWORD *)this, (v5 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v6 = v5;
  *v2 = v4;
  v2[1] = v5;
  p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
  do
    v8 = __ldxr(p_shared_weak_owners);
  while (__stxr(v8 + 1, p_shared_weak_owners));
  *((_QWORD *)this + 5) = v2;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v6);
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, *((const void **)this + 5), (CFNotificationCallback)abm::helper::DaemonObserver::handleDaemonReadyNotificationStatic, *((CFStringRef *)this + 2), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
}

void sub_1A34F39C8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void abm::helper::DaemonObserver::handleDaemonReadyNotificationStatic(abm::helper::DaemonObserver *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  if (a2)
  {
    v7 = (std::__shared_weak_count *)*((_QWORD *)a2 + 1);
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        v9 = v8;
        if (*(_QWORD *)a2)
          abm::helper::DaemonObserver::handleDaemonReady(*(abm::helper::DaemonObserver **)a2);
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldaxr(p_shared_owners);
        while (__stlxr(v11 - 1, p_shared_owners));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
  }
}

void abm::helper::DaemonObserver::handleDaemonReady(abm::helper::DaemonObserver *this)
{
  xpc_object_t v2;
  const void *v3;
  void *v4;
  NSObject *v5;
  void *v6;
  void *v7;
  _QWORD v8[4];
  void *aBlock;
  int v10;
  void *__p;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t object;

  if (!*((_QWORD *)this + 3) || !*((_QWORD *)this + 4))
    return;
  v2 = xpc_null_create();
  v3 = (const void *)*((_QWORD *)this + 3);
  if (v3)
    v4 = _Block_copy(v3);
  else
    v4 = 0;
  v5 = *((_QWORD *)this + 4);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 1174405120;
  v8[2] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke;
  v8[3] = &__block_descriptor_tmp_16;
  if (v4)
    v6 = _Block_copy(v4);
  else
    v6 = 0;
  aBlock = v6;
  v10 = -534716411;
  __p = 0;
  v12 = 0;
  v13 = 0;
  object = v2;
  if (v2)
    xpc_retain(v2);
  else
    object = xpc_null_create();
  dispatch_async(v5, v8);
  xpc_release(object);
  object = 0;
  if ((SHIBYTE(v13) & 0x80000000) == 0)
  {
    v7 = aBlock;
    if (!aBlock)
      goto LABEL_17;
    goto LABEL_16;
  }
  operator delete(__p);
  v7 = aBlock;
  if (aBlock)
LABEL_16:
    _Block_release(v7);
LABEL_17:
  if (v4)
    _Block_release(v4);
  xpc_release(v2);
}

void std::vector<abm::helper::TaskID>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke(uint64_t a1)
{
  dispatch::block<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::operator()<TelephonyXPC::Result const&,xpc::dict const&>((uint64_t *)(a1 + 32), (int *)(a1 + 40), (void **)(a1 + 72));
}

void dispatch::block<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::operator()<TelephonyXPC::Result const&,xpc::dict const&>(uint64_t *a1, int *a2, void **a3)
{
  uint64_t v4;
  void *v5;
  xpc_object_t object;
  int v7;
  std::string __p;

  v4 = *a1;
  v7 = *a2;
  if (*((char *)a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
    v5 = *a3;
    object = v5;
    if (v5)
      goto LABEL_3;
  }
  else
  {
    __p = *(std::string *)(a2 + 2);
    v5 = *a3;
    object = v5;
    if (v5)
    {
LABEL_3:
      xpc_retain(v5);
      goto LABEL_6;
    }
  }
  object = xpc_null_create();
LABEL_6:
  (*(void (**)(uint64_t, int *, xpc_object_t *))(v4 + 16))(v4, &v7, &object);
  xpc_release(object);
  object = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1A34F3C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  xpc_release(object);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

xpc_object_t __copy_helper_block_e8_32c76_ZTSN8dispatch5blockIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE40c27_ZTSN12TelephonyXPC6ResultE72c15_ZTSN3xpc4dictE(uint64_t a1, uint64_t a2)
{
  void *v4;
  std::string *v5;
  __int128 v6;
  void *v7;
  xpc_object_t result;

  v4 = *(void **)(a2 + 32);
  if (v4)
    v4 = _Block_copy(v4);
  *(_QWORD *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  v5 = (std::string *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    v6 = *(_OWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  v7 = *(void **)(a2 + 72);
  *(_QWORD *)(a1 + 72) = v7;
  if (v7)
    return xpc_retain(v7);
  result = xpc_null_create();
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

void sub_1A34F3D44(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 32);
  if (v3)
    _Block_release(v3);
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_32c76_ZTSN8dispatch5blockIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE40c27_ZTSN12TelephonyXPC6ResultE72c15_ZTSN3xpc4dictE(uint64_t a1)
{
  const void *v2;

  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(_QWORD *)(a1 + 72) = 0;
  if (*(char *)(a1 + 71) < 0)
  {
    operator delete(*(void **)(a1 + 48));
    v2 = *(const void **)(a1 + 32);
    if (!v2)
      return;
    goto LABEL_5;
  }
  v2 = *(const void **)(a1 + 32);
  if (v2)
LABEL_5:
    _Block_release(v2);
}

uint64_t Trace::Trace(uint64_t a1, uint64_t a2)
{
  const char *v4;
  unsigned __int8 v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;
  _BYTE v15[16];
  dispatch_object_t object[5];

  v4 = (const char *)a2;
  if (*(char *)(a2 + 23) < 0)
    v4 = *(const char **)a2;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v15, "com.apple.telephony.abm", v4);
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
  }
  object[0] = (dispatch_object_t)MEMORY[0x1E0C809B0];
  object[1] = (dispatch_object_t)0x40000000;
  object[2] = (dispatch_object_t)___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  object[3] = (dispatch_object_t)&__block_descriptor_tmp_13_6;
  object[4] = (dispatch_object_t)&GetABMLogServer(void)::sLogServer;
  if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
  {
    v6 = unk_1ED114C90;
    v13 = GetABMLogServer(void)::sLogServer;
    v14 = (std::__shared_weak_count *)unk_1ED114C90;
    if (!unk_1ED114C90)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, object);
    v6 = unk_1ED114C90;
    v13 = GetABMLogServer(void)::sLogServer;
    v14 = (std::__shared_weak_count *)unk_1ED114C90;
    if (!unk_1ED114C90)
      goto LABEL_8;
  }
  v7 = (unint64_t *)(v6 + 8);
  do
    v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
LABEL_8:
  object[0] = 0;
  ctu::SharedSynchronizable<Trace>::SharedSynchronizable((_QWORD *)(a1 + 72), a2, 0, object);
  if (object[0])
    dispatch_release(object[0]);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>>((_QWORD *)a1, (uint64_t)v15, &v13);
  *(_QWORD *)a1 = off_1E4A0B6A8;
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v15);
  *(_QWORD *)a1 = &unk_1E4A07350;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  return a1;
}

void sub_1A34F3F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::~SharedSynchronizable(v2);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  _Unwind_Resume(a1);
}

void sub_1A34F3FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a12);
  _Unwind_Resume(a1);
}

void Trace::create(char *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, _QWORD *a4@<X8>)
{
  int v8;
  capabilities::trace *v9;
  const char *v10;
  capabilities::trace *v11;
  capabilities::radio *v12;
  capabilities::radio *v13;
  const char *v14;
  KernelPCITrace *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  KernelPCIABPTrace *v20;
  unint64_t *v21;
  capabilities::radio *v22;
  int v23;
  int v24;
  DIAGTrace *v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unsigned __int8 v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  NSObject *v33;
  unint64_t *v34;
  unint64_t v35;
  const char *v36;
  ICETrace *v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unsigned __int8 v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  unsigned __int8 v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  NSObject *v52;
  unint64_t *v53;
  unint64_t v54;
  char *v55;
  int v56;
  std::__shared_weak_count *v57;
  unint64_t *p_shared_weak_owners;
  unint64_t v59;
  NSObject *v60;
  __int128 v61;
  dispatch_object_t object;
  uint64_t v63;
  std::__shared_weak_count *v64;
  std::string v65;
  __int128 v66;
  __int128 v67;
  uint8_t buf[16];
  void (*v69)(uint64_t);
  void *v70;
  __int128 *v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  a4[1] = 0;
  v8 = a1[23];
  if (v8 < 0)
  {
    v10 = *(const char **)a1;
    v9 = (capabilities::trace *)strcasecmp(*(const char **)a1, "IPC");
    if ((_DWORD)v9)
    {
LABEL_3:
      v11 = (capabilities::trace *)strcasecmp(v10, "KernelPCI");
      if ((_DWORD)v11)
      {
        if ((v8 & 0x80) == 0)
        {
LABEL_5:
          v12 = (capabilities::radio *)strcasecmp(a1, "BasebandTrace");
          if ((_DWORD)v12)
          {
            v12 = (capabilities::radio *)strcasecmp(a1, abm::trace::kDIAG[0]);
            if ((_DWORD)v12)
            {
              v12 = (capabilities::radio *)strcasecmp(a1, "BBTrace");
              if ((_DWORD)v12)
              {
                v13 = (capabilities::radio *)strcasecmp(a1, "CoreDump");
                if (!(_DWORD)v13)
                  goto LABEL_86;
                v13 = (capabilities::radio *)strcasecmp(a1, abm::trace::kEURCoreDump[0]);
                v14 = a1;
                if (!(_DWORD)v13)
                  goto LABEL_86;
                goto LABEL_29;
              }
            }
          }
          goto LABEL_33;
        }
LABEL_24:
        v14 = *(const char **)a1;
        v12 = (capabilities::radio *)strcasecmp(*(const char **)a1, "BasebandTrace");
        if ((_DWORD)v12)
        {
          v12 = (capabilities::radio *)strcasecmp(v14, abm::trace::kDIAG[0]);
          if ((_DWORD)v12)
          {
            v12 = (capabilities::radio *)strcasecmp(v14, "BBTrace");
            if ((_DWORD)v12)
            {
              v13 = (capabilities::radio *)strcasecmp(v14, "CoreDump");
              if (!(_DWORD)v13
                || (v13 = (capabilities::radio *)strcasecmp(v14, abm::trace::kEURCoreDump[0]), !(_DWORD)v13))
              {
LABEL_86:
                v56 = capabilities::radio::vendor(v13);
                switch(v56)
                {
                  case 1:
                    EURCoreDumpTrace::createInternal(buf);
                    break;
                  case 2:
                    ICECoredumpTrace::createInternal(buf);
                    break;
                  case 3:
                    CoredumpTrace::createInternal(buf);
                    break;
                  default:
                    goto LABEL_94;
                }
                goto LABEL_93;
              }
LABEL_29:
              v22 = (capabilities::radio *)strcasecmp(v14, "BasebandIPC");
              if ((_DWORD)v22)
                goto LABEL_94;
              v23 = capabilities::radio::vendor(v22);
              if (v23 == 2)
              {
                BasebandIPCTraceICE::createInternal(buf);
              }
              else
              {
                if (v23 != 1)
                  goto LABEL_94;
                BasebandIPCTrace::createInternal(buf);
              }
LABEL_93:
              std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100]((uint64_t)a4, (__int128 *)buf);
              std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)buf);
              goto LABEL_94;
            }
          }
        }
LABEL_33:
        v24 = capabilities::radio::vendor(v12);
        if (v24 != 2)
        {
          if (v24 != 1)
            goto LABEL_94;
          v25 = (DIAGTrace *)operator new(0x1B0uLL);
          DIAGTrace::DIAGTrace(v25);
          memset(buf, 170, sizeof(buf));
          std::shared_ptr<DIAGTrace>::shared_ptr[abi:ne180100]<DIAGTrace,std::shared_ptr<DIAGTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<DIAGTrace>(DIAGTrace*)::{lambda(DIAGTrace*)#1},void>(buf, (uint64_t)v25);
          ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
          v26 = (std::__shared_weak_count *)a4[1];
          *(_OWORD *)a4 = *(_OWORD *)buf;
          if (v26)
          {
            p_shared_owners = (unint64_t *)&v26->__shared_owners_;
            do
              v28 = __ldaxr(p_shared_owners);
            while (__stlxr(v28 - 1, p_shared_owners));
            if (!v28)
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
          }
          {
            __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
          }
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          v69 = ___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
          v70 = &__block_descriptor_tmp_13_6;
          v71 = &GetABMLogServer(void)::sLogServer;
          if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
          {
            v30 = (std::__shared_weak_count *)*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
            v67 = GetABMLogServer(void)::sLogServer;
            if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
              goto LABEL_45;
          }
          else
          {
            dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, buf);
            v30 = (std::__shared_weak_count *)*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
            v67 = GetABMLogServer(void)::sLogServer;
            if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
              goto LABEL_45;
          }
          v31 = (unint64_t *)&v30->__shared_owners_;
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
LABEL_45:
          v33 = *((_QWORD *)GetGlobalLogger((uint64_t *)&v67) + 4);
          if (v30)
          {
            v34 = (unint64_t *)&v30->__shared_owners_;
            do
              v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            v36 = "#I DIAG is created";
LABEL_69:
            _os_log_impl(&dword_1A343C000, v33, OS_LOG_TYPE_DEFAULT, v36, buf, 2u);
            goto LABEL_94;
          }
          goto LABEL_94;
        }
        v37 = (ICETrace *)operator new(0x1F0uLL);
        ICETrace::ICETrace(v37);
        memset(buf, 170, sizeof(buf));
        std::shared_ptr<ICETrace>::shared_ptr[abi:ne180100]<ICETrace,std::shared_ptr<ICETrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICETrace>(ICETrace*)::{lambda(ICETrace*)#1},void>(buf, (uint64_t)v37);
        ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
        v38 = (std::__shared_weak_count *)a4[1];
        *(_OWORD *)a4 = *(_OWORD *)buf;
        if (v38)
        {
          v39 = (unint64_t *)&v38->__shared_owners_;
          do
            v40 = __ldaxr(v39);
          while (__stlxr(v40 - 1, v39));
          if (!v40)
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
        {
          __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
        }
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        v69 = ___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
        v70 = &__block_descriptor_tmp_13_6;
        v71 = &GetABMLogServer(void)::sLogServer;
        if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
        {
          v42 = (std::__shared_weak_count *)*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
          v66 = GetABMLogServer(void)::sLogServer;
          if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
            goto LABEL_62;
        }
        else
        {
          dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, buf);
          v42 = (std::__shared_weak_count *)*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
          v66 = GetABMLogServer(void)::sLogServer;
          if (!*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
            goto LABEL_62;
        }
        v43 = (unint64_t *)&v42->__shared_owners_;
        do
          v44 = __ldxr(v43);
        while (__stxr(v44 + 1, v43));
LABEL_62:
        v33 = *((_QWORD *)GetGlobalLogger((uint64_t *)&v66) + 4);
        if (v42)
        {
          v45 = (unint64_t *)&v42->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v36 = "#I ICE Trace is created";
          goto LABEL_69;
        }
LABEL_94:
        v47 = *a4;
        if (*a4)
          goto LABEL_95;
        goto LABEL_71;
      }
      if ((capabilities::trace::supportsKernelPCIBinaryTrace(v11) & 1) == 0)
      {
        if ((a1[23] & 0x80) == 0)
          goto LABEL_5;
        goto LABEL_24;
      }
      v20 = (KernelPCIABPTrace *)operator new(0x110uLL);
      KernelPCIABPTrace::KernelPCIABPTrace(v20);
      memset(buf, 170, sizeof(buf));
      std::shared_ptr<KernelPCIABPTrace>::shared_ptr[abi:ne180100]<KernelPCIABPTrace,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1},void>(buf, (uint64_t)v20);
      ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
      v16 = *(_QWORD *)buf;
      v17 = (std::__shared_weak_count *)a4[1];
      *(_OWORD *)a4 = *(_OWORD *)buf;
      if (v17)
      {
        v21 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldaxr(v21);
        while (__stlxr(v19 - 1, v21));
        goto LABEL_21;
      }
      goto LABEL_70;
    }
  }
  else
  {
    v9 = (capabilities::trace *)strcasecmp(a1, "IPC");
    v10 = a1;
    if ((_DWORD)v9)
      goto LABEL_3;
  }
  if (!capabilities::trace::supportsKernelPCITrace(v9))
    goto LABEL_94;
  v15 = (KernelPCITrace *)operator new(0x110uLL);
  KernelPCITrace::KernelPCITrace(v15);
  memset(buf, 170, sizeof(buf));
  std::shared_ptr<KernelPCITrace>::shared_ptr[abi:ne180100]<KernelPCITrace,std::shared_ptr<KernelPCITrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCITrace>(KernelPCITrace*)::{lambda(KernelPCITrace*)#1},void>(buf, (uint64_t)v15);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
  v16 = *(_QWORD *)buf;
  v17 = (std::__shared_weak_count *)a4[1];
  *(_OWORD *)a4 = *(_OWORD *)buf;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
LABEL_21:
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    goto LABEL_94;
  }
LABEL_70:
  v47 = v16;
  if (v16)
  {
LABEL_95:
    if (a1[23] < 0)
      std::string::__init_copy_ctor_external(&v65, *(const std::string::value_type **)a1, *((_QWORD *)a1 + 1));
    else
      v65 = *(std::string *)a1;
    v57 = (std::__shared_weak_count *)a2[1];
    v63 = *a2;
    v64 = v57;
    if (v57)
    {
      p_shared_weak_owners = (unint64_t *)&v57->__shared_weak_owners_;
      do
        v59 = __ldxr(p_shared_weak_owners);
      while (__stxr(v59 + 1, p_shared_weak_owners));
    }
    v60 = *a3;
    object = v60;
    if (v60)
      dispatch_retain(v60);
    (*(void (**)(uint64_t, std::string *, uint64_t *, dispatch_object_t *))(*(_QWORD *)v47 + 48))(v47, &v65, &v63, &object);
    if (object)
      dispatch_release(object);
    if (v64)
      std::__shared_weak_count::__release_weak(v64);
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v65.__r_.__value_.__l.__data_);
    return;
  }
LABEL_71:
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
  }
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  v69 = ___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  v70 = &__block_descriptor_tmp_13_6;
  v71 = &GetABMLogServer(void)::sLogServer;
  if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
  {
    v49 = (std::__shared_weak_count *)*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
    v61 = GetABMLogServer(void)::sLogServer;
    if (*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
      goto LABEL_74;
  }
  else
  {
    dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, buf);
    v49 = (std::__shared_weak_count *)*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1);
    v61 = GetABMLogServer(void)::sLogServer;
    if (*((_QWORD *)&GetABMLogServer(void)::sLogServer + 1))
    {
LABEL_74:
      v50 = (unint64_t *)&v49->__shared_owners_;
      do
        v51 = __ldxr(v50);
      while (__stxr(v51 + 1, v50));
    }
  }
  v52 = *((_QWORD *)GetGlobalLogger((uint64_t *)&v61) + 4);
  if (v49)
  {
    v53 = (unint64_t *)&v49->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    if (a1[23] >= 0)
      v55 = a1;
    else
      v55 = *(char **)a1;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v55;
    _os_log_impl(&dword_1A343C000, v52, OS_LOG_TYPE_DEFAULT, "#I Failed to create the trace: %s", buf, 0xCu);
  }
}

void sub_1A34F4878(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F488C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F48A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F48B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F48C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F48DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 96);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F48F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  uint64_t v21;
  void *v22;

  operator delete(v22);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v21);
  _Unwind_Resume(a1);
}

void sub_1A34F49AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F49C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F49D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F49E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void sub_1A34F4A04(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A34F4A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  std::__shared_weak_count *v22;

  if (object)
  {
    dispatch_release(object);
    v22 = a14;
    if (!a14)
    {
LABEL_3:
      if (a20 < 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else
  {
    v22 = a14;
    if (!a14)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v22);
  if (a20 < 0)
  {
LABEL_4:
    operator delete(__p);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v20);
    _Unwind_Resume(a1);
  }
LABEL_7:
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v20);
  _Unwind_Resume(a1);
}

void sub_1A34F4A74(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Trace::getCurrentBootSessionUUID(_BYTE *a1@<X8>)
{
  __int128 v3;
  size_t v4;
  size_t v5;
  unsigned __int8 v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  int *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  char __s[16];
  _BYTE v22[21];
  __int128 buf;
  void (*v24)(uint64_t);
  void *v25;
  uint64_t *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v22[13] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__s = v3;
  *(_OWORD *)v22 = v3;
  v20 = 37;
  if (!sysctlbyname("kern.bootsessionuuid", __s, &v20, 0, 0) && v20 == 37)
  {
    v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v5 = v4;
    if (v4 >= 0x17)
    {
      v13 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17)
        v13 = v4 | 7;
      v14 = v13 + 1;
      v15 = operator new(v13 + 1);
      *((_QWORD *)a1 + 1) = v5;
      *((_QWORD *)a1 + 2) = v14 | 0x8000000000000000;
      *(_QWORD *)a1 = v15;
      a1 = v15;
    }
    else
    {
      a1[23] = v4;
      if (!v4)
        goto LABEL_24;
    }
    memcpy(a1, __s, v5);
LABEL_24:
    a1[v5] = 0;
    return;
  }
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100], &GetABMLogServer(void)::sLogServer, &dword_1A343C000);
  }
  *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
  *((_QWORD *)&buf + 1) = 0x40000000;
  v24 = ___ZL17sABMLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  v25 = &__block_descriptor_tmp_13_6;
  v26 = &GetABMLogServer(void)::sLogServer;
  if (sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce == -1)
  {
    v7 = (std::__shared_weak_count *)unk_1ED114C90;
    v18 = GetABMLogServer(void)::sLogServer;
    v19 = unk_1ED114C90;
    if (unk_1ED114C90)
      goto LABEL_10;
  }
  else
  {
    dispatch_once(&sABMLogServerInit(std::shared_ptr<ctu::LogServer> &)::sOnce, &buf);
    v7 = (std::__shared_weak_count *)unk_1ED114C90;
    v18 = GetABMLogServer(void)::sLogServer;
    v19 = unk_1ED114C90;
    if (unk_1ED114C90)
    {
LABEL_10:
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
  }
  v10 = *((_QWORD *)GetGlobalLogger(&v18) + 4);
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v16 = __error();
    v17 = strerror(*v16);
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v17;
    _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Failed to get boot session uuid, error: %s", (uint8_t *)&buf, 0xCu);
  }
  a1[23] = 0;
  *a1 = 0;
}

void sub_1A34F4D14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *ctu::SharedSynchronizable<Trace>::SharedSynchronizable(_QWORD *a1, uint64_t a2, dispatch_queue_attr_t attr, dispatch_object_t *a4)
{
  const char *v6;
  NSObject *v7;
  NSObject *v8;

  if (*(char *)(a2 + 23) >= 0)
    v6 = (const char *)a2;
  else
    v6 = *(const char **)a2;
  v7 = *a4;
  if (*a4)
  {
    dispatch_retain(*a4);
    dispatch_retain(v7);
    v8 = dispatch_queue_create_with_target_V2(v6, attr, v7);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = v8;
    if (!v8)
      goto LABEL_7;
    goto LABEL_6;
  }
  v8 = dispatch_queue_create(v6, attr);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = v8;
  if (v8)
LABEL_6:
    dispatch_retain(v8);
LABEL_7:
  a1[3] = v7;
  if (v7)
    dispatch_retain(v7);
  if (v8)
    dispatch_release(v8);
  if (v7)
  {
    dispatch_release(v7);
    dispatch_release(v7);
  }
  return a1;
}

_QWORD *ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>>(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v9;
  _BYTE v10[16];

  *a1 = &unk_1E4A07490;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v10);
  a1[1] = &unk_1E4A06330;
  a1[7] = *a3;
  v5 = a3[1];
  a1[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  return a1;
}

void sub_1A34F4EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *ctu::SharedLoggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = &unk_1E4A07490;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void ctu::SharedLoggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = &unk_1E4A07490;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  operator delete(a1);
}

uint64_t __cxx_global_var_init_4()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A343C000);
  }
  return result;
}

void abm::CellularLoggingCommon::create(uint64_t *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, _QWORD *a4@<X8>)
{
  ctu::OsLogContext *v8;
  NSObject *v9;
  capabilities::radio *v10;
  int v11;
  int v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_weak_owners;
  unint64_t v18;
  NSObject *v19;
  __int128 v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  const char *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  NSObject *v31;
  __int128 v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  NSObject *v36;
  uint32_t v37;
  const char *v38;
  dispatch_object_t object;
  uint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  dispatch_object_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint8_t buf[16];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v8 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, "com.apple.telephony.abm", "carriercellularlogging.modem");
  v9 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext(v8);
  *a4 = 0;
  a4[1] = 0;
  v11 = capabilities::radio::vendor(v10);
  v12 = v11;
  if (v11 != 1)
  {
    if (v11 != 3)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v12;
        v24 = "Not supported radio vendor: %d";
        v36 = v9;
        v37 = 8;
        goto LABEL_44;
      }
      return;
    }
    v13 = a1[1];
    v42 = *a1;
    v43 = (std::__shared_weak_count *)v13;
    if (v13)
    {
      v14 = (unint64_t *)(v13 + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v16 = (std::__shared_weak_count *)a2[1];
    v40 = *a2;
    v41 = v16;
    if (v16)
    {
      p_shared_weak_owners = (unint64_t *)&v16->__shared_weak_owners_;
      do
        v18 = __ldxr(p_shared_weak_owners);
      while (__stxr(v18 + 1, p_shared_weak_owners));
    }
    v19 = *a3;
    object = v19;
    if (v19)
      dispatch_retain(v19);
    std::allocate_shared[abi:ne180100]<abm::CellularLoggingINT,std::allocator<abm::CellularLoggingINT>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(&v42, &v40, &object, buf);
    v20 = *(_OWORD *)buf;
    memset(buf, 0, sizeof(buf));
    *(_OWORD *)a4 = v20;
    if (object)
      dispatch_release(object);
    if (v41)
      std::__shared_weak_count::__release_weak(v41);
    v21 = v43;
    if (!v43)
      goto LABEL_55;
    p_shared_owners = (unint64_t *)&v43->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
      if (*a4)
      {
LABEL_20:
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v24 = "Succeeded creating CellularLoggingINT";
LABEL_41:
          v36 = v9;
          v37 = 2;
LABEL_44:
          _os_log_impl(&dword_1A343C000, v36, OS_LOG_TYPE_DEFAULT, v24, buf, v37);
          return;
        }
        return;
      }
    }
    else
    {
LABEL_55:
      if (*a4)
        goto LABEL_20;
    }
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v38 = "Failed creating CellularLoggingINT";
LABEL_52:
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, v38, buf, 2u);
    return;
  }
  v25 = a1[1];
  v47 = *a1;
  v48 = (std::__shared_weak_count *)v25;
  if (v25)
  {
    v26 = (unint64_t *)(v25 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  v28 = (std::__shared_weak_count *)a2[1];
  v45 = *a2;
  v46 = v28;
  if (v28)
  {
    v29 = (unint64_t *)&v28->__shared_weak_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  v31 = *a3;
  v44 = v31;
  if (v31)
    dispatch_retain(v31);
  std::allocate_shared[abi:ne180100]<abm::CellularLoggingEUR,std::allocator<abm::CellularLoggingEUR>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(&v47, &v45, &v44, buf);
  v32 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  *(_OWORD *)a4 = v32;
  if (v44)
    dispatch_release(v44);
  if (v46)
    std::__shared_weak_count::__release_weak(v46);
  v33 = v48;
  if (!v48)
    goto LABEL_56;
  v34 = (unint64_t *)&v48->__shared_owners_;
  do
    v35 = __ldaxr(v34);
  while (__stlxr(v35 - 1, v34));
  if (v35)
  {
LABEL_56:
    if (*a4)
      goto LABEL_39;
LABEL_49:
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v38 = "Failed creating CellularLoggingEUR";
    goto LABEL_52;
  }
  ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
  std::__shared_weak_count::__release_weak(v33);
  if (!*a4)
    goto LABEL_49;
LABEL_39:
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v24 = "Succeeded creating CellularLoggingEUR";
    goto LABEL_41;
  }
}

void sub_1A34F5334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object, uint64_t a16, std::__shared_weak_count *a17, char a18)
{
  uint64_t v18;

  if (object)
    dispatch_release(object);
  if (a17)
    std::__shared_weak_count::__release_weak(a17);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v18);
  _Unwind_Resume(a1);
}

void sub_1A34F5368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12, char a13)
{
  uint64_t v13;

  if (object)
    dispatch_release(object);
  if (a12)
    std::__shared_weak_count::__release_weak(a12);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v13);
  _Unwind_Resume(a1);
}

void sub_1A34F539C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *abm::CellularLoggingCommon::CellularLoggingCommon(_QWORD *a1, _QWORD *a2, _QWORD *a3, NSObject **a4)
{
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  const char *v17;

  *a1 = off_1E4A0B6E8;
  v17 = "carriercellularlogging.modem";
  v8 = ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>(a1, &v17, a2);
  v8[9] = 0;
  v8[10] = 0;
  *v8 = off_1E4A0B6E8;
  v9 = a3[1];
  v8[11] = *a3;
  v8[12] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 16);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v12 = a2[1];
  a1[13] = *a2;
  a1[14] = v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = *a4;
  a1[15] = *a4;
  if (v15)
    dispatch_retain(v15);
  return a1;
}

_QWORD *ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>(_QWORD *a1, const char **a2, _QWORD *a3)
{
  const char *v5;
  size_t v6;
  void *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  void *__dst[2];
  unint64_t v16;

  *a1 = off_1E4A0B858;
  v5 = *a2;
  v6 = strlen(*a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v7 = (void *)v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    v16 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v16) = v6;
  v8 = __dst;
  if (v6)
LABEL_8:
    memmove(v8, v5, (size_t)v7);
  *((_BYTE *)v7 + (_QWORD)v8) = 0;
  ctu::LoggerCommonBase::LoggerCommonBase();
  a1[1] = &unk_1E4A06330;
  a1[7] = *a3;
  v11 = a3[1];
  a1[8] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (SHIBYTE(v16) < 0)
    operator delete(__dst[0]);
  return a1;
}

void sub_1A34F5598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void abm::CellularLoggingCommon::~CellularLoggingCommon(abm::CellularLoggingCommon *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;

  *(_QWORD *)this = off_1E4A0B6E8;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    dispatch_release(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 14);
  if (!v3)
    goto LABEL_7;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (v5)
  {
LABEL_7:
    v6 = (std::__shared_weak_count *)*((_QWORD *)this + 12);
    if (!v6)
      goto LABEL_9;
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 12);
  if (v6)
LABEL_8:
    std::__shared_weak_count::__release_weak(v6);
LABEL_9:
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
  *(_QWORD *)this = off_1E4A0B858;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
}

BOOL abm::CellularLoggingCommon::setProperty(_QWORD *a1, const std::string::value_type *a2, const std::string::value_type *a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  NSObject *v10;
  _BOOL8 v11;
  xpc_object_t v12;
  xpc_object_t v13;
  const char *v14;
  xpc_object_t v15;
  xpc_object_t v16;
  const char *v17;
  xpc_object_t v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  NSObject *v30;
  dispatch_time_t v31;
  NSObject *v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::string v39;
  std::string v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  void *__p;
  char v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  char v52;
  _BYTE buf[14];
  const std::string::value_type *v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v49 = 0;
  v50 = &v49;
  v51 = 0x2020000000;
  v52 = 0;
  v47 = 0;
  v48 = 0;
  v4 = (std::__shared_weak_count *)a1[12];
  if (!v4)
  {
    v7 = 0;
    goto LABEL_9;
  }
  v7 = std::__shared_weak_count::lock(v4);
  v48 = v7;
  if (!v7 || (v47 = a1[11]) == 0)
  {
LABEL_9:
    v10 = a1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Server is not available", buf, 2u);
      v11 = 0;
      if (!v7)
        goto LABEL_76;
    }
    else
    {
      v11 = 0;
      if (!v7)
        goto LABEL_76;
    }
    goto LABEL_72;
  }
  v8 = xpc_dictionary_create(0, 0, 0);
  if (v8 || (v8 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v8) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(v8);
      v9 = v8;
    }
    else
    {
      v9 = xpc_null_create();
    }
  }
  else
  {
    v9 = xpc_null_create();
    v8 = 0;
  }
  xpc_release(v8);
  v12 = xpc_string_create("BasebandTrace");
  if (!v12)
    v12 = xpc_null_create();
  xpc_dictionary_set_value(v9, "kKeyTraceName", v12);
  v13 = xpc_null_create();
  xpc_release(v12);
  xpc_release(v13);
  v14 = a2;
  if (a2[23] < 0)
    v14 = *(const char **)a2;
  v15 = xpc_string_create(v14);
  if (!v15)
    v15 = xpc_null_create();
  xpc_dictionary_set_value(v9, "kKeyTracePropertyName", v15);
  v16 = xpc_null_create();
  xpc_release(v15);
  xpc_release(v16);
  v17 = a3;
  if (a3[23] < 0)
    v17 = *(const char **)a3;
  v18 = xpc_string_create(v17);
  if (!v18)
    v18 = xpc_null_create();
  xpc_dictionary_set_value(v9, "kKeyTracePropertyValue", v18);
  v19 = xpc_null_create();
  xpc_release(v18);
  xpc_release(v19);
  v20 = xpc_BOOL_create(1);
  if (!v20)
    v20 = xpc_null_create();
  xpc_dictionary_set_value(v9, "kKeyTracePropertyWaitForCompletion", v20);
  v21 = xpc_null_create();
  xpc_release(v20);
  xpc_release(v21);
  v22 = dispatch_group_create();
  v23 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  v24 = dispatch_queue_create("CellularLoggingCommon", v23);
  v45 = 0xAAAAAAAAAAAAAAAALL;
  v46 = 0xAAAAAAAAAAAAAAAALL;
  v55 = 12;
  strcpy(buf, "helperserver");
  abm::client::CreateManager();
  if (v55 < 0)
    operator delete(*(void **)buf);
  if (v22)
  {
    dispatch_retain(v22);
    dispatch_group_enter(v22);
  }
  v41 = v45;
  v42 = (std::__shared_weak_count *)v46;
  v25 = (unint64_t *)(v46 + 8);
  do
    v26 = __ldxr(v25);
  while (__stxr(v26 + 1, v25));
  if (v22)
  {
    dispatch_retain(v22);
    dispatch_group_enter(v22);
  }
  if (a2[23] < 0)
    std::string::__init_copy_ctor_external(&v39, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  else
    v39 = *(std::string *)a2;
  if (a3[23] < 0)
    std::string::__init_copy_ctor_external(&v40, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  else
    v40 = *(std::string *)a3;
  abm::client::SetTraceProperty();
  if (v44 < 0)
    operator delete(__p);
  v27 = v42;
  if (v42)
  {
    p_shared_owners = (unint64_t *)&v42->__shared_owners_;
    do
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_51;
LABEL_54:
    operator delete(v39.__r_.__value_.__l.__data_);
    v30 = v22;
    if (!v22)
      goto LABEL_56;
    goto LABEL_55;
  }
  operator delete(v40.__r_.__value_.__l.__data_);
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_54;
LABEL_51:
  v30 = v22;
  if (v22)
  {
LABEL_55:
    dispatch_group_leave(v30);
    dispatch_release(v22);
  }
LABEL_56:
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
  }
  v31 = dispatch_time(0, 25000000000);
  if (!dispatch_group_wait(v22, v31))
  {
    v11 = *((_BYTE *)v50 + 24) != 0;
    v33 = (std::__shared_weak_count *)v46;
    if (!v46)
      goto LABEL_67;
    goto LABEL_63;
  }
  v32 = a1[5];
  if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    v11 = 0;
    *((_BYTE *)v50 + 24) = 0;
    v33 = (std::__shared_weak_count *)v46;
    if (!v46)
      goto LABEL_67;
    goto LABEL_63;
  }
  if (a2[23] < 0)
    a2 = *(const std::string::value_type **)a2;
  if (a3[23] < 0)
    a3 = *(const std::string::value_type **)a3;
  *(_DWORD *)buf = 136315394;
  *(_QWORD *)&buf[4] = a2;
  *(_WORD *)&buf[12] = 2080;
  v54 = a3;
  _os_log_error_impl(&dword_1A343C000, v32, OS_LOG_TYPE_ERROR, "Timeout for setting property for %s with %s", buf, 0x16u);
  v11 = 0;
  *((_BYTE *)v50 + 24) = 0;
  v33 = (std::__shared_weak_count *)v46;
  if (v46)
  {
LABEL_63:
    v34 = (unint64_t *)&v33->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
LABEL_67:
  if (v24)
    dispatch_release(v24);
  if (v22)
    dispatch_release(v22);
  xpc_release(v9);
  v7 = v48;
  if (v48)
  {
LABEL_72:
    v36 = (unint64_t *)&v7->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
LABEL_76:
  _Block_object_dispose(&v49, 8);
  return v11;
}

void sub_1A34F5C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_group_t group, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  void *v35;
  NSObject *v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v40;

  if (a22 < 0)
  {
    operator delete(__p);
    v40 = group;
    if (!group)
      goto LABEL_6;
  }
  else
  {
    v40 = group;
    if (!group)
    {
LABEL_6:
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
      if (v36)
      {
        dispatch_group_leave(v36);
        dispatch_release(v36);
      }
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a35);
      if (v37)
      {
        dispatch_release(v37);
        if (!v36)
        {
LABEL_11:
          xpc_release(v35);
          std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v38 - 144);
          _Block_object_dispose((const void *)(v38 - 128), 8);
          _Unwind_Resume(a1);
        }
      }
      else if (!v36)
      {
        goto LABEL_11;
      }
      dispatch_release(v36);
      goto LABEL_11;
    }
  }
  dispatch_group_leave(v40);
  dispatch_release(group);
  goto LABEL_6;
}

void sub_1A34F5DF8(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm21CellularLoggingCommon11setPropertyENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES7__block_invoke(uint64_t a1, _DWORD *a2)
{
  NSObject *v4;
  BOOL v5;
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  _QWORD *v9;
  __int16 v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    v4 = *(NSObject **)(*(_QWORD *)(a1 + 40) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = (_QWORD *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0)
        v6 = (_QWORD *)*v6;
      v7 = (_QWORD *)(a1 + 80);
      if (*(char *)(a1 + 103) < 0)
        v7 = (_QWORD *)*v7;
      v8 = 136315394;
      v9 = v6;
      v10 = 2080;
      v11 = v7;
      _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Failed to set property with the name(%s) with the value (%s)", (uint8_t *)&v8, 0x16u);
      v5 = *a2 == 0;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = 1;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
}

void __copy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE80c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;

  v4 = *(NSObject **)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = *(NSObject **)(a1 + 48);
    if (v5)
      dispatch_group_enter(v5);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 56), *(const std::string::value_type **)(a2 + 56), *(_QWORD *)(a2 + 64));
  }
  else
  {
    v6 = *(_OWORD *)(a2 + 56);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
  }
  v7 = (std::string *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 80), *(_QWORD *)(a2 + 88));
  }
  else
  {
    v8 = *(_OWORD *)(a2 + 80);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
}

void sub_1A34F5FC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  NSObject *v4;
  NSObject *v5;

  if (*(char *)(v1 + 79) < 0)
    operator delete(*v2);
  v4 = *(NSObject **)(v1 + 48);
  if (v4)
  {
    dispatch_group_leave(v4);
    v5 = *(NSObject **)(v1 + 48);
    if (v5)
      dispatch_release(v5);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE80c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  if (*(char *)(a1 + 103) < 0)
  {
    operator delete(*(void **)(a1 + 80));
    if ((*(char *)(a1 + 79) & 0x80000000) == 0)
    {
LABEL_3:
      v2 = *(NSObject **)(a1 + 48);
      if (!v2)
        return;
      goto LABEL_7;
    }
  }
  else if ((*(char *)(a1 + 79) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 56));
  v2 = *(NSObject **)(a1 + 48);
  if (!v2)
    return;
LABEL_7:
  dispatch_group_leave(v2);
  v3 = *(NSObject **)(a1 + 48);
  if (v3)
    dispatch_release(v3);
}

void abm::CellularLoggingCommon::getProperty(uint64_t a1@<X0>, const std::string::value_type *a2@<X1>, std::string *a3@<X8>)
{
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  const char *v10;
  xpc_object_t v11;
  xpc_object_t v12;
  xpc_object_t v13;
  xpc_object_t v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  dispatch_time_t v23;
  NSObject *v24;
  uint64_t *v25;
  __int128 v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::string v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  void *__p;
  char v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  __n128 (*v40)(__n128 *, __n128 *);
  void (*v41)(uint64_t);
  __int128 v42;
  __int128 v43;
  uint8_t buf[23];
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v37 = 0;
  v38 = &v37;
  v39 = 0x4812000000;
  v40 = __Block_byref_object_copy__0;
  v41 = __Block_byref_object_dispose__0;
  v42 = 0u;
  v43 = 0u;
  v6 = xpc_dictionary_create(0, 0, 0);
  if (v6 || (v6 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v6) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(v6);
      v7 = v6;
    }
    else
    {
      v7 = xpc_null_create();
    }
  }
  else
  {
    v7 = xpc_null_create();
    v6 = 0;
  }
  xpc_release(v6);
  v8 = xpc_string_create("BasebandTrace");
  if (!v8)
    v8 = xpc_null_create();
  xpc_dictionary_set_value(v7, "kKeyTraceName", v8);
  v9 = xpc_null_create();
  xpc_release(v8);
  xpc_release(v9);
  v10 = a2;
  if (a2[23] < 0)
    v10 = *(const char **)a2;
  v11 = xpc_string_create(v10);
  if (!v11)
    v11 = xpc_null_create();
  xpc_dictionary_set_value(v7, "kKeyTracePropertyName", v11);
  v12 = xpc_null_create();
  xpc_release(v11);
  xpc_release(v12);
  v13 = xpc_BOOL_create(1);
  if (!v13)
    v13 = xpc_null_create();
  xpc_dictionary_set_value(v7, "kKeyTracePropertyWaitForCompletion", v13);
  v14 = xpc_null_create();
  xpc_release(v13);
  xpc_release(v14);
  v15 = dispatch_group_create();
  v16 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  v17 = dispatch_queue_create("CellularLoggingCommon", v16);
  v35 = 0xAAAAAAAAAAAAAAAALL;
  v36 = 0xAAAAAAAAAAAAAAAALL;
  v45 = 12;
  strcpy((char *)buf, "helperserver");
  abm::client::CreateManager();
  if (v45 < 0)
    operator delete(*(void **)buf);
  if (v15)
  {
    dispatch_retain(v15);
    dispatch_group_enter(v15);
  }
  v31 = v35;
  v32 = (std::__shared_weak_count *)v36;
  v18 = (unint64_t *)(v36 + 8);
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  if (v15)
  {
    dispatch_retain(v15);
    dispatch_group_enter(v15);
  }
  if (a2[23] < 0)
    std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  else
    v30 = *(std::string *)a2;
  abm::client::GetTraceProperty();
  if (v34 < 0)
    operator delete(__p);
  v20 = v32;
  if (!v32)
    goto LABEL_32;
  p_shared_owners = (unint64_t *)&v32->__shared_owners_;
  do
    v22 = __ldaxr(p_shared_owners);
  while (__stlxr(v22 - 1, p_shared_owners));
  if (v22)
  {
LABEL_32:
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_34;
    goto LABEL_33;
  }
  ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
  std::__shared_weak_count::__release_weak(v20);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
LABEL_33:
    operator delete(v30.__r_.__value_.__l.__data_);
LABEL_34:
  if (v15)
  {
    dispatch_group_leave(v15);
    dispatch_release(v15);
    dispatch_group_leave(v15);
    dispatch_release(v15);
  }
  v23 = dispatch_time(0, 25000000000);
  if (dispatch_group_wait(v15, v23))
  {
    v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      if (a2[23] < 0)
        a2 = *(const std::string::value_type **)a2;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = a2;
      _os_log_error_impl(&dword_1A343C000, v24, OS_LOG_TYPE_ERROR, "Timeout for getting property! for %s", buf, 0xCu);
      v25 = v38;
      if ((*((char *)v38 + 71) & 0x80000000) == 0)
        goto LABEL_39;
LABEL_45:
      std::string::__init_copy_ctor_external(a3, (const std::string::value_type *)v25[6], v25[7]);
      goto LABEL_46;
    }
  }
  v25 = v38;
  if (*((char *)v38 + 71) < 0)
    goto LABEL_45;
LABEL_39:
  v26 = *((_OWORD *)v25 + 3);
  a3->__r_.__value_.__r.__words[2] = v25[8];
  *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v26;
LABEL_46:
  v27 = (std::__shared_weak_count *)v36;
  if (v36)
  {
    v28 = (unint64_t *)(v36 + 8);
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  if (v17)
    dispatch_release(v17);
  if (v15)
    dispatch_release(v15);
  xpc_release(v7);
  _Block_object_dispose(&v37, 8);
  if (SHIBYTE(v43) < 0)
    operator delete(*((void **)&v42 + 1));
}

void sub_1A34F6554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_group_t group, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  void *v42;
  NSObject *v43;
  NSObject *v44;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
  if (v44)
  {
    dispatch_release(v44);
    if (!v43)
    {
LABEL_4:
      xpc_release(v42);
      _Block_object_dispose(&a31, 8);
      if (a42 < 0)
      {
        operator delete(__p);
        _Unwind_Resume(a1);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v43)
  {
    goto LABEL_4;
  }
  dispatch_release(v43);
  goto LABEL_4;
}

__n128 __Block_byref_object_copy__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

void ___ZN3abm21CellularLoggingCommon11getPropertyENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE_block_invoke(uint64_t a1, _DWORD *a2, xpc_object_t a3)
{
  uint64_t v6;
  xpc_object_t v7;
  NSObject *v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  const char *v12;
  xpc_object_t value;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  xpc_object_t object;
  uint8_t buf[16];
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = xpc_null_create();
  if (*a2)
  {
    v8 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v16 = (_QWORD *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0)
        v16 = (_QWORD *)*v16;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v16;
      _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to get property with the name(%s)", buf, 0xCu);
    }
    v9 = xpc_null_create();
    v10 = xpc_null_create();
    xpc_release(v7);
    xpc_release(v10);
    goto LABEL_19;
  }
  if (a3)
  {
    xpc_retain(a3);
    goto LABEL_7;
  }
  a3 = xpc_null_create();
  if (a3)
  {
LABEL_7:
    if (MEMORY[0x1A85902BC](a3) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(a3);
      v9 = a3;
    }
    else
    {
      v9 = xpc_null_create();
    }
    goto LABEL_11;
  }
  v9 = xpc_null_create();
  a3 = 0;
LABEL_11:
  v11 = xpc_null_create();
  xpc_release(v7);
  xpc_release(v11);
  xpc_release(a3);
  v12 = (const char *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
    v12 = *(const char **)v12;
  value = xpc_dictionary_get_value(v9, v12);
  object = value;
  if (value)
    xpc_retain(value);
  else
    object = xpc_null_create();
  xpc::dyn_cast_or_default();
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v15 = v14 + 48;
  if (*(char *)(v14 + 71) < 0)
    operator delete(*(void **)v15);
  *(_OWORD *)v15 = *(_OWORD *)buf;
  *(_QWORD *)(v15 + 16) = v19;
  HIBYTE(v19) = 0;
  buf[0] = 0;
  xpc_release(object);
LABEL_19:
  xpc_release(v9);
}

void sub_1A34F68C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void __copy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  std::string *v6;
  __int128 v7;

  v4 = *(NSObject **)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = *(NSObject **)(a1 + 48);
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = (std::string *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 56), *(_QWORD *)(a2 + 64));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 56);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
}

void sub_1A34F69A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v3;
  NSObject *v4;

  v3 = *(NSObject **)(v1 + 48);
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = *(NSObject **)(v1 + 48);
    if (v4)
      dispatch_release(v4);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  if (*(char *)(a1 + 79) < 0)
  {
    operator delete(*(void **)(a1 + 56));
    v2 = *(NSObject **)(a1 + 48);
    if (!v2)
      return;
  }
  else
  {
    v2 = *(NSObject **)(a1 + 48);
    if (!v2)
      return;
  }
  dispatch_group_leave(v2);
  v3 = *(NSObject **)(a1 + 48);
  if (v3)
    dispatch_release(v3);
}

BOOL abm::CellularLoggingCommon::start()
{
  uint64_t v0;
  _BOOL8 Dir;
  char *v3;
  _BYTE v4[64];
  char *v5;
  __int128 v6;

  v5 = (char *)operator new(0x38uLL);
  *(_WORD *)&v4[50] = 0;
  *(_DWORD *)&v4[52] = 0;
  *(_QWORD *)&v4[56] = 0x8000000000000038;
  v6 = xmmword_1A3580B20;
  strcpy(v5, "/private/var/mobile/Library/Logs/CellularLogging");
  strcpy(v4, "/CellularLoggingile/Library/Logs/private/var/mob0");
  v0 = support::fs::removeDir((const char *)&v5);
  Dir = v0;
  if (SHIBYTE(v6) < 0)
  {
    operator delete(v5);
    if (!Dir)
      return Dir;
  }
  else if (!(_DWORD)v0)
  {
    return Dir;
  }
  v3 = (char *)operator new(0x38uLL);
  v5 = v3;
  v6 = *(_OWORD *)&v4[48];
  *(_OWORD *)v3 = *(_OWORD *)&v4[32];
  *((_OWORD *)v3 + 1) = *(_OWORD *)&v4[16];
  *((_OWORD *)v3 + 2) = *(_OWORD *)v4;
  v3[48] = 0;
  Dir = support::fs::createDir((const char *)&v5, 0x1EDu, 0);
  if ((SHIBYTE(v6) & 0x80000000) == 0)
    return Dir;
  operator delete(v5);
  return Dir;
}

void sub_1A34F6B0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 17) < 0)
    operator delete(*(void **)(v1 - 40));
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingCommon::changeState(abm::CellularLoggingCommon *this, int a2)
{
  std::string *v4;
  __int128 v5;
  std::string *v6;
  std::error_code *v7;
  __int128 v8;
  const std::__fs::filesystem::path *v9;
  int v10;
  NSObject *v11;
  void **v12;
  int v13;
  NSObject *v14;
  void **v15;
  const char *v16;
  NSObject *v17;
  __CFNotificationCenter *DarwinNotifyCenter;
  uint64_t v19;
  NSObject *v21;
  uint32_t v22;
  void **v23;
  std::string v24;
  void *__p[2];
  int64_t v26;
  std::string v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)&v24.__r_.__value_.__s + 23) = 1;
  LOWORD(v24.__r_.__value_.__l.__data_) = 47;
  v4 = std::string::insert(&v24, 0, "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  v6 = std::string::append(&v27, "com.apple.cellularlogging.state", 0x1FuLL);
  v8 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v26 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v8;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_14:
    operator delete(v24.__r_.__value_.__l.__data_);
    if (v26 >= 0)
      v9 = (const std::__fs::filesystem::path *)__p;
    else
      v9 = (const std::__fs::filesystem::path *)__p[0];
    if (a2)
      goto LABEL_7;
    goto LABEL_18;
  }
  operator delete(v27.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_14;
LABEL_3:
  if (v26 >= 0)
    v9 = (const std::__fs::filesystem::path *)__p;
  else
    v9 = (const std::__fs::filesystem::path *)__p[0];
  if (a2)
  {
LABEL_7:
    v10 = open((const char *)v9, 1537, 420);
    v11 = *((_QWORD *)this + 5);
    if (v10 >= 1)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v27.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#N Successfully created Cellular Logging state file", (uint8_t *)&v27, 2u);
      }
      while (close(v10) && *__error() == 4)
        ;
      goto LABEL_30;
    }
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v19 = 0;
      if ((SHIBYTE(v26) & 0x80000000) == 0)
        return v19;
      goto LABEL_35;
    }
    v23 = __p;
    if (v26 < 0)
      v23 = (void **)__p[0];
    LODWORD(v27.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    v16 = "Failed to create the state file, %s";
    v17 = v11;
LABEL_43:
    v22 = 12;
    goto LABEL_44;
  }
LABEL_18:
  if (remove(v9, v7))
  {
    if (v26 >= 0)
      v12 = __p;
    else
      v12 = (void **)__p[0];
    v13 = unlink((const char *)v12);
    v14 = *((_QWORD *)this + 5);
    if (v13)
    {
      if (!os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
        goto LABEL_34;
      v15 = __p;
      if (v26 < 0)
        v15 = (void **)__p[0];
      LODWORD(v27.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
      v16 = "Failed to remove the state file, %s";
      v17 = v14;
      goto LABEL_43;
    }
  }
  else
  {
    v14 = *((_QWORD *)this + 5);
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v27.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#N Successfully removed Cellular Logging state file", (uint8_t *)&v27, 2u);
  }
LABEL_30:
  sync();
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (!DarwinNotifyCenter)
  {
    v21 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
LABEL_34:
      v19 = 0;
      if ((SHIBYTE(v26) & 0x80000000) == 0)
        return v19;
LABEL_35:
      operator delete(__p[0]);
      return v19;
    }
    LOWORD(v27.__r_.__value_.__l.__data_) = 0;
    v16 = "Failed getting darwin notification center!!!";
    v17 = v21;
    v22 = 2;
LABEL_44:
    _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v27, v22);
    v19 = 0;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
      return v19;
    goto LABEL_35;
  }
  v19 = 1;
  CFNotificationCenterPostNotification(DarwinNotifyCenter, CFSTR("com.apple.CarrierCellularLogging.state"), 0, 0, 1u);
  if (SHIBYTE(v26) < 0)
    goto LABEL_35;
  return v19;
}

void sub_1A34F6E88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingCommon::isStarted(abm::CellularLoggingCommon *this)
{
  std::string *v2;
  __int128 v3;
  std::string *v4;
  __int128 v5;
  NSObject *v6;
  timespec v7;
  void **v8;
  int v9;
  const char *v10;
  timespec v11;
  void **v12;
  int v13;
  void *__p[2];
  int64_t v16;
  stat v17;
  std::string v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)&v18.__r_.__value_.__s + 23) = 1;
  LOWORD(v18.__r_.__value_.__l.__data_) = 47;
  v2 = std::string::insert(&v18, 0, "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  *(_QWORD *)&v17.st_uid = *((_QWORD *)&v2->__r_.__value_.__l + 2);
  *(_OWORD *)&v17.st_dev = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  v4 = std::string::append((std::string *)&v17, "com.apple.cellularlogging.state", 0x1FuLL);
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v16 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v17.st_gid) < 0)
  {
    operator delete(*(void **)&v17.st_dev);
    if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_3:
      v6 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        goto LABEL_13;
      goto LABEL_7;
    }
  }
  else if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v18.__r_.__value_.__l.__data_);
  v6 = *((_QWORD *)this + 5);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    goto LABEL_13;
LABEL_7:
  v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v7.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blksize = v7;
  *(timespec *)v17.st_qspare = v7;
  v17.st_birthtimespec = v7;
  *(timespec *)&v17.st_size = v7;
  v17.st_mtimespec = v7;
  v17.st_ctimespec = v7;
  *(timespec *)&v17.st_uid = v7;
  v17.st_atimespec = v7;
  *(timespec *)&v17.st_dev = v7;
  if (v16 >= 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  v9 = stat((const char *)v8, &v17);
  v10 = "does not exist";
  if (!v9)
    v10 = "exists";
  LODWORD(v18.__r_.__value_.__l.__data_) = 136315394;
  *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
  WORD2(v18.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&v18.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
  _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I State file %s %s", (uint8_t *)&v18, 0x16u);
LABEL_13:
  v11.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v11.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blksize = v11;
  *(timespec *)v17.st_qspare = v11;
  v17.st_birthtimespec = v11;
  *(timespec *)&v17.st_size = v11;
  v17.st_mtimespec = v11;
  v17.st_ctimespec = v11;
  *(timespec *)&v17.st_uid = v11;
  v17.st_atimespec = v11;
  *(timespec *)&v17.st_dev = v11;
  if (v16 >= 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  v13 = stat((const char *)v12, &v17);
  if (SHIBYTE(v16) < 0)
    operator delete(__p[0]);
  return v13 == 0;
}

void sub_1A34F70D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A0B858;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  return a1;
}

void ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A0B858;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  operator delete(a1);
}

uint64_t __cxx_global_var_init_14()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A343C000);
  }
  return result;
}

uint64_t _GLOBAL__sub_I_CellularLoggingCommon_mm()
{
  uint64_t result;

  result = ETLDIAGLoggingGetDefaultView();
  dword_1ED114B4C = result;
  return result;
}

void abm::ProfileManagementTask::~ProfileManagementTask(abm::ProfileManagementTask *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;

  *(_QWORD *)this = off_1E4A0B8D0;
  v2 = *((_QWORD *)this + 18);
  if (v2)
    dispatch_release(v2);
  *(_QWORD *)this = off_1E4A0F3B8;
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  v4 = *((_QWORD *)this + 14);
  if (v4)
    dispatch_release(v4);
  *(_QWORD *)this = &unk_1E4A06FA8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v5 = *((_QWORD *)this + 12);
  if (v5)
    dispatch_release(v5);
  v6 = *((_QWORD *)this + 11);
  if (v6)
    dispatch_release(v6);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
}

{
  void *v1;

  abm::ProfileManagementTask::~ProfileManagementTask(this);
  operator delete(v1);
}

_QWORD *abm::ProfileManagementTask::getName(abm::ProfileManagementTask *this)
{
  unsigned __int8 v1;
  unsigned int v4;
  char *v5;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_15);
  if ((v1 & 1) != 0 || !__cxa_guard_acquire(&_MergedGlobals_15))
    return qword_1ED114B60;
  v4 = *((_DWORD *)this + 26) - 1;
  if (v4 > 9)
    v5 = "invalid";
  else
    v5 = off_1E4A0B998[v4];
  std::string::basic_string[abi:ne180100]<0>(qword_1ED114B60, v5);
  __cxa_atexit(MEMORY[0x1E0DE44D0], qword_1ED114B60, &dword_1A343C000);
  __cxa_guard_release(&_MergedGlobals_15);
  return qword_1ED114B60;
}

void sub_1A34F733C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&_MergedGlobals_15);
  _Unwind_Resume(a1);
}

_QWORD *abm::ProfileManagementTask::ProfileManagementTask(_QWORD *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  v5 = (std::__shared_weak_count *)a3[1];
  v18 = *a3;
  v19 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a4[1];
  v16 = *a4;
  v17 = v8;
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  abm::HelperTask::HelperTask((uint64_t)a1, a2, &v18, &v16);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  *a1 = off_1E4A0B8D0;
  v14 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  a1[18] = dispatch_queue_create("profile.task.queue", v14);
  return a1;
}

void sub_1A34F7440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::init_sync(abm::ProfileManagementTask *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  void *v15;
  NSObject *v16;
  unint64_t v17;
  void *v18;
  NSObject *v19;
  char *v20;
  unint64_t v21;
  void *v22;
  NSObject *v23;
  unint64_t v24;
  void *v25;
  NSObject *v26;
  unint64_t v27;
  void *v28;
  NSObject *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  _QWORD v33[6];
  std::__shared_weak_count *v34;
  _QWORD v35[2];
  char v36[24];
  _QWORD v37[6];
  std::__shared_weak_count *v38;
  _QWORD v39[2];
  char v40[24];
  _QWORD v41[6];
  std::__shared_weak_count *v42;
  _QWORD v43[2];
  char *v44;
  __int128 v45;
  _QWORD v46[6];
  std::__shared_weak_count *v47;
  _QWORD v48[2];
  char v49[24];
  _QWORD aBlock[6];
  std::__shared_weak_count *v51;
  _QWORD v52[2];
  char v53[32];
  uint64_t v54;
  std::__shared_weak_count *v55;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2 || (v3 = *((_QWORD *)this + 9), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v7 = __ldxr(p_shared_weak_owners);
  while (__stxr(v7 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (v9)
  {
    v54 = 0;
    v55 = 0;
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
      goto LABEL_13;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    v54 = 0;
    v55 = 0;
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (!v10)
    {
LABEL_13:
      v32 = 0;
      v12 = 0;
      goto LABEL_14;
    }
  }
  v11 = std::__shared_weak_count::lock(v10);
  v55 = v11;
  if (!v11)
    goto LABEL_13;
  v32 = v11;
  v12 = *((_QWORD *)this + 15);
  v54 = v12;
LABEL_14:
  *((_QWORD *)this + 17) = 0;
  abm::ProfileManagementTask::registerForNotifications_sync(this);
  v53[23] = 18;
  strcpy(v53, "CommandReadProfile");
  v13 = MEMORY[0x1E0C809B0];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke;
  aBlock[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  aBlock[4] = this;
  aBlock[5] = v3;
  v51 = v5;
  do
    v14 = __ldxr(p_shared_weak_owners);
  while (__stxr(v14 + 1, p_shared_weak_owners));
  v15 = _Block_copy(aBlock);
  v16 = *((_QWORD *)this + 11);
  if (v16)
    dispatch_retain(*((dispatch_object_t *)this + 11));
  v52[0] = v15;
  v52[1] = v16;
  abm::HelperServerInternal::setCommandHandler(v12, (uint64_t)v53, (uint64_t)v52);
  if (v16)
    dispatch_release(v16);
  if (v15)
    _Block_release(v15);
  v49[23] = 19;
  strcpy(v49, "CommandApplyProfile");
  v46[0] = v13;
  v46[1] = 3321888768;
  v46[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_3;
  v46[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v46[4] = this;
  v46[5] = v3;
  v47 = v5;
  do
    v17 = __ldxr(p_shared_weak_owners);
  while (__stxr(v17 + 1, p_shared_weak_owners));
  v18 = _Block_copy(v46);
  v19 = *((_QWORD *)this + 11);
  if (v19)
    dispatch_retain(*((dispatch_object_t *)this + 11));
  v48[0] = v18;
  v48[1] = v19;
  abm::HelperServerInternal::setCommandHandler(v12, (uint64_t)v49, (uint64_t)v48);
  if (v19)
    dispatch_release(v19);
  if (v18)
    _Block_release(v18);
  v20 = (char *)operator new(0x19uLL);
  v44 = v20;
  v45 = xmmword_1A357F840;
  strcpy(v20, "CheckIfProfileInstalled");
  v41[0] = v13;
  v41[1] = 3321888768;
  v41[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_2;
  v41[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v41[4] = this;
  v41[5] = v3;
  v42 = v5;
  do
    v21 = __ldxr(p_shared_weak_owners);
  while (__stxr(v21 + 1, p_shared_weak_owners));
  v22 = _Block_copy(v41);
  v23 = *((_QWORD *)this + 11);
  if (v23)
    dispatch_retain(*((dispatch_object_t *)this + 11));
  v43[0] = v22;
  v43[1] = v23;
  abm::HelperServerInternal::setCommandHandler(v12, (uint64_t)&v44, (uint64_t)v43);
  if (v23)
    dispatch_release(v23);
  if (v22)
    _Block_release(v22);
  operator delete(v20);
  v40[23] = 21;
  strcpy(v40, "CommandInstallProfile");
  v37[0] = v13;
  v37[1] = 3321888768;
  v37[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_5;
  v37[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v37[4] = this;
  v37[5] = v3;
  v38 = v5;
  do
    v24 = __ldxr(p_shared_weak_owners);
  while (__stxr(v24 + 1, p_shared_weak_owners));
  v25 = _Block_copy(v37);
  v26 = *((_QWORD *)this + 11);
  if (v26)
    dispatch_retain(*((dispatch_object_t *)this + 11));
  v39[0] = v25;
  v39[1] = v26;
  abm::HelperServerInternal::setCommandHandler(v12, (uint64_t)v40, (uint64_t)v39);
  if (v26)
    dispatch_release(v26);
  if (v25)
    _Block_release(v25);
  v36[23] = 16;
  strcpy(v36, "UninstallProfile");
  v33[0] = v13;
  v33[1] = 3321888768;
  v33[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_6;
  v33[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v33[4] = this;
  v33[5] = v3;
  v34 = v5;
  do
    v27 = __ldxr(p_shared_weak_owners);
  while (__stxr(v27 + 1, p_shared_weak_owners));
  v28 = _Block_copy(v33);
  v29 = *((_QWORD *)this + 11);
  if (v29)
    dispatch_retain(v29);
  v35[0] = v28;
  v35[1] = v29;
  abm::HelperServerInternal::setCommandHandler(v12, (uint64_t)v36, (uint64_t)v35);
  if (v29)
    dispatch_release(v29);
  if (v28)
    _Block_release(v28);
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  if (v38)
    std::__shared_weak_count::__release_weak(v38);
  if (v42)
    std::__shared_weak_count::__release_weak(v42);
  if (v47)
    std::__shared_weak_count::__release_weak(v47);
  if (v51)
    std::__shared_weak_count::__release_weak(v51);
  if (v32)
  {
    v30 = (unint64_t *)&v32->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A34F7934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,std::__shared_weak_count *a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52,char a53)
{
  std::__shared_weak_count *v53;
  uint64_t v54;
  std::__shared_weak_count *v56;
  std::__shared_weak_count *v57;
  std::__shared_weak_count *v58;
  std::__shared_weak_count *v59;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a17);
  if (a16)
  {
    std::__shared_weak_count::__release_weak(a16);
    v56 = a28;
    if (!a28)
    {
LABEL_3:
      v57 = a40;
      if (!a40)
        goto LABEL_4;
      goto LABEL_9;
    }
  }
  else
  {
    v56 = a28;
    if (!a28)
      goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v56);
  v57 = a40;
  if (!a40)
  {
LABEL_4:
    v58 = a52;
    if (!a52)
      goto LABEL_5;
    goto LABEL_10;
  }
LABEL_9:
  std::__shared_weak_count::__release_weak(v57);
  v58 = a52;
  if (!a52)
  {
LABEL_5:
    v59 = *(std::__shared_weak_count **)(v54 - 184);
    if (!v59)
      goto LABEL_6;
    goto LABEL_11;
  }
LABEL_10:
  std::__shared_weak_count::__release_weak(v58);
  v59 = *(std::__shared_weak_count **)(v54 - 184);
  if (!v59)
  {
LABEL_6:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v54 - 128);
    std::__shared_weak_count::__release_weak(v53);
    _Unwind_Resume(a1);
  }
LABEL_11:
  std::__shared_weak_count::__release_weak(v59);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v54 - 128);
  std::__shared_weak_count::__release_weak(v53);
  _Unwind_Resume(a1);
}

void sub_1A34F7A64(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 128);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::registerForNotifications_sync(abm::ProfileManagementTask *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  unint64_t v11;
  _QWORD handler[6];
  std::__shared_weak_count *v13;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2 || (v3 = *((_QWORD *)this + 9), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v7 = __ldxr(p_shared_weak_owners);
  while (__stxr(v7 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
    abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync((NSObject **)this);
  v10 = *((_QWORD *)this + 11);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN3abm21ProfileManagementTask29registerForNotifications_syncEv_block_invoke;
  handler[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e9_v16__0_v8l;
  handler[4] = this;
  handler[5] = v3;
  v13 = v5;
  do
    v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  xpc_set_event_stream_handler("com.apple.notifyd.matching", v10, handler);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A34F7B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  std::__shared_weak_count *v16;

  if (a16)
  {
    std::__shared_weak_count::__release_weak(a16);
    std::__shared_weak_count::__release_weak(v16);
    _Unwind_Resume(a1);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  dispatch_object_t *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  void *v13;
  xpc_object_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  xpc_object_t object;
  std::__shared_weak_count *v19;
  _QWORD block[4];
  void *aBlock;
  xpc_object_t v22;
  int v23;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = (dispatch_object_t *)a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v19 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
      {
LABEL_20:
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      v10 = v7[14];
      if (v10)
      {
        dispatch_retain(v7[14]);
        dispatch_group_enter(v10);
      }
      abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v7, &object);
      if (*(_QWORD *)a4)
        v11 = _Block_copy(*(const void **)a4);
      else
        v11 = 0;
      v12 = *(NSObject **)(a4 + 8);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3321888768;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_1;
      block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v11)
      {
        v13 = _Block_copy(v11);
        v23 = 0;
        v14 = object;
        aBlock = v13;
        v22 = object;
        if (object)
        {
LABEL_11:
          xpc_retain(v14);
LABEL_14:
          dispatch_async(v12, block);
          xpc_release(v22);
          v22 = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v11)
            _Block_release(v11);
          xpc_release(object);
          object = 0;
          if (v10)
          {
            dispatch_group_leave(v10);
            dispatch_release(v10);
          }
          goto LABEL_20;
        }
      }
      else
      {
        v23 = 0;
        v14 = object;
        aBlock = 0;
        v22 = object;
        if (object)
          goto LABEL_11;
      }
      v22 = xpc_null_create();
      goto LABEL_14;
    }
  }
}

void sub_1A34F7D7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  NSObject *v10;

  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::readProfile_sync(abm::ProfileManagementTask *this@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4;
  xpc_object_t v5;
  xpc_object_t v6;
  id v7;
  ctu *v8;
  ctu *v9;
  const void *v10;
  xpc_object_t v11;
  ctu *v12;
  ctu *v13;
  const void *v14;
  xpc_object_t v15;
  ctu *v16;
  ctu *v17;
  const void *v18;
  xpc_object_t v19;
  NSObject *v20;
  void *p_p;
  void *__p;
  char v23;
  xpc_object_t v24;
  xpc_object_t object;
  xpc_object_t value;
  uint8_t buf[4];
  void *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = v4;
  if (v4)
  {
    *a2 = v4;
  }
  else
  {
    v5 = xpc_null_create();
    *a2 = v5;
    if (!v5)
    {
      v6 = xpc_null_create();
      v5 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A85902BC](v5) == MEMORY[0x1E0C812F8])
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  v6 = xpc_null_create();
LABEL_8:
  *a2 = v6;
LABEL_9:
  xpc_release(v5);
  v7 = objc_alloc_init(MEMORY[0x1E0C99EA0]);
  if (!v7)
    return;
  objc_msgSend(v7, "addSuiteNamed:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "com.apple.commcenter"));
  v8 = (ctu *)objc_msgSend(v7, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "EnableBasebandLogging"));
  v9 = v8;
  if (v8)
  {
    __p = v8;
    CFRetain(v8);
    ctu::cf_to_xpc(v9, v10);
    xpc_dictionary_set_value(*a2, "EnableBasebandLogging", value);
    v11 = value;
    value = xpc_null_create();
    xpc_release(v11);
    xpc_release(value);
    value = 0;
    CFRelease(v9);
  }
  v12 = (ctu *)objc_msgSend(v7, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "TelephonyLoggingVersion", __p));
  v13 = v12;
  if (v12)
  {
    __p = v12;
    CFRetain(v12);
    ctu::cf_to_xpc(v13, v14);
    xpc_dictionary_set_value(*a2, "TelephonyLoggingVersion", object);
    v15 = object;
    object = xpc_null_create();
    xpc_release(v15);
    xpc_release(object);
    object = 0;
    CFRelease(v13);
  }
  v16 = (ctu *)objc_msgSend(v7, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "TelephonyLoggingPriority", __p));
  v17 = v16;
  if (v16)
  {
    __p = v16;
    CFRetain(v16);
    ctu::cf_to_xpc(v17, v18);
    xpc_dictionary_set_value(*a2, "TelephonyLoggingPriority", v24);
    v19 = v24;
    v24 = xpc_null_create();
    xpc_release(v19);
    xpc_release(v24);
    v24 = 0;
    CFRelease(v17);
    goto LABEL_17;
  }
  if ((unint64_t)v9 | (unint64_t)v13)
  {
LABEL_17:
    v20 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((xpc::object *)a2);
      if (v23 >= 0)
        p_p = &__p;
      else
        p_p = __p;
      *(_DWORD *)buf = 136315138;
      v28 = p_p;
      _os_log_impl(&dword_1A343C000, v20, OS_LOG_TYPE_DEFAULT, "#I Logging profile: %s ", buf, 0xCu);
      if (v23 < 0)
        operator delete(__p);
    }
  }

}

void sub_1A34F80AC(_Unwind_Exception *a1)
{
  xpc_object_t *v1;

  xpc::dict::~dict(v1);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_3(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  dispatch_object_t *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  xpc_object_t v11;
  void *v12;
  NSObject *v13;
  void *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  xpc_object_t v17;
  xpc_object_t object;
  std::__shared_weak_count *v20;
  _QWORD block[4];
  void *aBlock;
  xpc_object_t v23;
  int v24;

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v7 = (dispatch_object_t *)a1[4];
    v8 = std::__shared_weak_count::lock(v5);
    v20 = v8;
    if (v8)
    {
      v9 = v8;
      if (!a1[5])
      {
LABEL_20:
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      v10 = v7[14];
      if (v10)
      {
        dispatch_retain(v7[14]);
        dispatch_group_enter(v10);
      }
      abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v7, &v17);
      abm::ProfileManagementTask::convertToTraceProperties_sync((uint64_t)v7, &v17, 0, &object);
      abm::ProfileManagementTask::applyTraceProperties_sync((uint64_t)v7, &object);
      xpc_release(object);
      object = 0;
      xpc_release(v17);
      v17 = 0;
      v11 = xpc_null_create();
      if (*(_QWORD *)a4)
        v12 = _Block_copy(*(const void **)a4);
      else
        v12 = 0;
      v13 = *(NSObject **)(a4 + 8);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3321888768;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_1;
      block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v12)
      {
        v14 = _Block_copy(v12);
        v24 = 0;
        aBlock = v14;
        v23 = v11;
        if (v11)
        {
LABEL_11:
          xpc_retain(v11);
LABEL_14:
          dispatch_async(v13, block);
          xpc_release(v23);
          v23 = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v12)
            _Block_release(v12);
          xpc_release(v11);
          if (v10)
          {
            dispatch_group_leave(v10);
            dispatch_release(v10);
          }
          goto LABEL_20;
        }
      }
      else
      {
        v24 = 0;
        aBlock = 0;
        v23 = v11;
        if (v11)
          goto LABEL_11;
      }
      v23 = xpc_null_create();
      goto LABEL_14;
    }
  }
}

void sub_1A34F8350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, char a12)
{
  NSObject *v12;

  xpc_release(object);
  xpc_release(a10);
  if (v12)
  {
    dispatch_group_leave(v12);
    dispatch_release(v12);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t abm::ProfileManagementTask::applyTraceProperties_sync(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  NSObject *v8;
  void **v9;
  xpc_object_t v10;
  const char *v11;
  xpc_object_t v12;
  size_t count;
  xpc_object_t v14;
  char *v15;
  xpc_object_t v16;
  xpc_object_t v17;
  xpc_object_t v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t value;
  __int128 v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  BOOL v27;
  xpc_object_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  char *v32;
  std::__shared_weak_count *v33;
  void *__p[5];
  xpc_object_t xdict;
  xpc_object_t object;
  char *v37;
  unint64_t v38;
  unint64_t v39;
  uint8_t buf[32];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v4 = MEMORY[0x1A85902BC](*a2);
  v5 = MEMORY[0x1E0C812C8];
  if (v4 != MEMORY[0x1E0C812C8] || MEMORY[0x1A85902BC](*a2) != v5 || !xpc_array_get_count(*a2))
  {
    v6 = 0;
    return v6 & 1;
  }
  v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((xpc::object *)a2);
    v9 = SHIBYTE(__p[2]) >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v9;
    _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I Applying trace properties: %s", buf, 0xCu);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
  }
  v38 = 0xAAAAAAAAAAAAAAAALL;
  v39 = 0xAAAAAAAAAAAAAAAALL;
  HIBYTE(__p[2]) = 17;
  strcpy((char *)__p, "ProfileManagement");
  abm::client::CreateManager();
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v37 = (char *)0xAAAAAAAAAAAAAAAALL;
  v10 = *a2;
  if (*a2)
  {
    xpc_retain(*a2);
    object = v10;
  }
  else
  {
    v10 = xpc_null_create();
    object = v10;
    if (!v10)
    {
      v10 = 0;
      object = xpc_null_create();
      goto LABEL_18;
    }
  }
  xpc_retain(v10);
LABEL_18:
  v37 = 0;
  xpc_release(v10);
  v11 = (const char *)*MEMORY[0x1E0CFAF80];
  v6 = 1;
  while (1)
  {
    v12 = *a2;
    if (*a2)
      xpc_retain(*a2);
    else
      v12 = xpc_null_create();
    if (MEMORY[0x1A85902BC](*a2) == v5)
    {
      count = xpc_array_get_count(*a2);
      if (!v12)
      {
LABEL_28:
        v14 = xpc_null_create();
        goto LABEL_29;
      }
    }
    else
    {
      count = 0;
      if (!v12)
        goto LABEL_28;
    }
    xpc_retain(v12);
    v14 = v12;
LABEL_29:
    xpc_release(v12);
    v16 = object;
    v15 = v37;
    xpc_release(v14);
    if (v15 == (char *)count && v16 == v14)
      break;
    xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    __p[0] = &object;
    __p[1] = v37;
    xpc::array::object_proxy::operator xpc::dict((uint64_t)__p, &xdict);
    v17 = xpc_int64_create(3000);
    if (!v17)
      v17 = xpc_null_create();
    xpc_dictionary_set_value(xdict, v11, v17);
    v18 = xpc_null_create();
    xpc_release(v17);
    xpc_release(v18);
    v19 = xpc_BOOL_create(0);
    if (!v19)
      v19 = xpc_null_create();
    xpc_dictionary_set_value(xdict, "kKeyTracePropertyWaitForCompletion", v19);
    v20 = xpc_null_create();
    xpc_release(v19);
    xpc_release(v20);
    memset(buf, 170, 24);
    value = xpc_dictionary_get_value(xdict, "kKeyTraceName");
    __p[0] = value;
    if (value)
      xpc_retain(value);
    else
      __p[0] = xpc_null_create();
    xpc::dyn_cast_or_default();
    xpc_release(__p[0]);
    *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)__p = v22;
    *(_OWORD *)&__p[2] = v22;
    v33 = (std::__shared_weak_count *)v39;
    if (v39)
    {
      v23 = (unint64_t *)(v39 + 8);
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    v32 = (char *)operator new(0x20uLL);
    strcpy(v32, "kCommandSetTraceProperty");
    abm::client::PerformCommand();
    operator delete(v32);
    if (!v33)
      goto LABEL_45;
    p_shared_owners = (unint64_t *)&v33->__shared_owners_;
    do
      v26 = __ldaxr(p_shared_owners);
    while (__stlxr(v26 - 1, p_shared_owners));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
      v27 = LODWORD(__p[0]) == 0;
      if (SHIBYTE(__p[3]) < 0)
      {
LABEL_50:
        operator delete(__p[1]);
        if (((char)buf[23] & 0x80000000) == 0)
          goto LABEL_47;
        goto LABEL_51;
      }
    }
    else
    {
LABEL_45:
      v27 = LODWORD(__p[0]) == 0;
      if (SHIBYTE(__p[3]) < 0)
        goto LABEL_50;
    }
    if (((char)buf[23] & 0x80000000) == 0)
      goto LABEL_47;
LABEL_51:
    operator delete(*(void **)buf);
LABEL_47:
    xpc_release(xdict);
    v28 = object;
    if (object)
      xpc_retain(object);
    else
      v28 = xpc_null_create();
    v6 &= v27;
    ++v37;
    xpc_release(v28);
  }
  xpc_release(object);
  v29 = (std::__shared_weak_count *)v39;
  if (v39)
  {
    v30 = (unint64_t *)(v39 + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  return v6 & 1;
}

void sub_1A34F8894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,xpc_object_t object,xpc_object_t a29,uint64_t a30,char a31)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void abm::ProfileManagementTask::convertToTraceProperties_sync(uint64_t a1@<X0>, void **a2@<X1>, int a3@<W2>, xpc_object_t *a4@<X8>)
{
  xpc_object_t v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  _BOOL4 v15;
  NSObject *v16;
  std::string::size_type v17;
  xpc_object_t v18;
  xpc_object_t v19;
  xpc_object_t v20;
  void *v21;
  std::string::size_type v22;
  xpc_object_t v23;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  xpc_object_t v27;
  xpc_object_t v28;
  xpc_object_t v29;
  std::string *p_p;
  xpc_object_t v31;
  xpc_object_t v32;
  xpc_object_t v33;
  xpc_object_t v34;
  xpc_object_t v35;
  xpc_object_t v36;
  xpc_object_t v37;
  std::string *v38;
  xpc_object_t v39;
  xpc_object_t v40;
  xpc_object_t object;
  std::string __p;
  xpc_object_t v43;
  std::string buf;

  v8 = xpc_null_create();
  *a4 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v9 = xpc_array_create(0, 0);
  v10 = v9;
  if (v9)
  {
    *a4 = v9;
  }
  else
  {
    v10 = xpc_null_create();
    *a4 = v10;
    if (!v10)
    {
      v11 = xpc_null_create();
      v10 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A85902BC](v10) == MEMORY[0x1E0C812C8])
  {
    xpc_retain(v10);
    goto LABEL_9;
  }
  v11 = xpc_null_create();
LABEL_8:
  *a4 = v11;
LABEL_9:
  xpc_release(v10);
  v43 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)"EnableBasebandLogging";
  xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &v43);
  v12 = MEMORY[0x1A85902BC](v43);
  v13 = MEMORY[0x1E0C812F8];
  v14 = *(NSObject **)(a1 + 40);
  v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v12 == v13)
  {
    if (v15)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I Logging profile found", (uint8_t *)&buf, 2u);
    }
    v21 = *a2;
    object = v21;
    if (v21)
      xpc_retain(v21);
    else
      object = xpc_null_create();
    logs::convertToTraceProperties((std::string::size_type)&object, (xpc_object_t *)&buf.__r_.__value_.__l.__data_);
    v22 = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    v23 = *a4;
    *a4 = (xpc_object_t)v22;
    xpc_release(v23);
    xpc_release(buf.__r_.__value_.__l.__data_);
    buf.__r_.__value_.__r.__words[0] = 0;
    xpc_release(object);
    object = 0;
    v24 = xpc_dictionary_create(0, 0, 0);
    if (v24 || (v24 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A85902BC](v24) == v13)
      {
        xpc_retain(v24);
        v20 = v24;
      }
      else
      {
        v20 = xpc_null_create();
      }
    }
    else
    {
      v20 = xpc_null_create();
      v24 = 0;
    }
    xpc_release(v24);
    v25 = xpc_null_create();
    xpc_release(v8);
    xpc_release(v25);
    v26 = xpc_string_create("Profile");
    if (!v26)
      v26 = xpc_null_create();
    xpc_dictionary_set_value(v20, "kKeyTraceName", v26);
    v27 = xpc_null_create();
    xpc_release(v26);
    xpc_release(v27);
    v28 = xpc_string_create((const char *)*MEMORY[0x1E0CFAF68]);
    if (!v28)
      v28 = xpc_null_create();
    xpc_dictionary_set_value(v20, "kKeyTracePropertyName", v28);
    v29 = xpc_null_create();
    xpc_release(v28);
    xpc_release(v29);
    memset(&__p, 0, sizeof(__p));
    std::to_string(&buf, 1);
    __p = buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    v31 = xpc_string_create((const char *)p_p);
    if (!v31)
      v31 = xpc_null_create();
    xpc_dictionary_set_value(v20, "kKeyTracePropertyValue", v31);
    v32 = xpc_null_create();
    xpc_release(v31);
    xpc_release(v32);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    xpc_array_append_value(*a4, v20);
  }
  else
  {
    if (v15)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I No Logging profile found", (uint8_t *)&buf, 2u);
    }
    if (a3)
    {
      v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#I Load the default trace properties", (uint8_t *)&buf, 2u);
      }
      logs::getDefaultTraceProperties((xpc_object_t *)&buf.__r_.__value_.__l.__data_);
      v17 = buf.__r_.__value_.__r.__words[0];
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      v18 = *a4;
      *a4 = (xpc_object_t)v17;
      xpc_release(v18);
      xpc_release(buf.__r_.__value_.__l.__data_);
      v19 = xpc_dictionary_create(0, 0, 0);
      if (v19 || (v19 = xpc_null_create()) != 0)
      {
        if (MEMORY[0x1A85902BC](v19) == v13)
        {
          xpc_retain(v19);
          v20 = v19;
        }
        else
        {
          v20 = xpc_null_create();
        }
      }
      else
      {
        v20 = xpc_null_create();
        v19 = 0;
      }
      xpc_release(v19);
      v33 = xpc_null_create();
      xpc_release(v8);
      xpc_release(v33);
      v34 = xpc_string_create("Profile");
      if (!v34)
        v34 = xpc_null_create();
      xpc_dictionary_set_value(v20, "kKeyTraceName", v34);
      v35 = xpc_null_create();
      xpc_release(v34);
      xpc_release(v35);
      v36 = xpc_string_create((const char *)*MEMORY[0x1E0CFAF68]);
      if (!v36)
        v36 = xpc_null_create();
      xpc_dictionary_set_value(v20, "kKeyTracePropertyName", v36);
      v37 = xpc_null_create();
      xpc_release(v36);
      xpc_release(v37);
      std::to_string(&buf, 0);
      __p = buf;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v38 = &__p;
      else
        v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
      v39 = xpc_string_create((const char *)v38);
      if (!v39)
        v39 = xpc_null_create();
      xpc_dictionary_set_value(v20, "kKeyTracePropertyValue", v39);
      v40 = xpc_null_create();
      xpc_release(v39);
      xpc_release(v40);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      xpc_array_append_value(*a4, v20);
    }
    else
    {
      v20 = v8;
    }
  }
  xpc_release(v43);
  xpc_release(v20);
}

void sub_1A34F8F80(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A34F8EB0);
}

void sub_1A34F8F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t object)
{
  xpc_object_t *v17;
  void *v18;

  if (a16 < 0)
    operator delete(__p);
  xpc_release(object);
  xpc::array::~array(v17);
  xpc_release(v18);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_2(_QWORD *a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  NSObject **v5;
  std::__shared_weak_count *v6;
  NSObject *v9;
  xpc_object_t value;
  void *v11;
  char v12;
  NSObject *v13;
  void **v14;
  void **v15;
  char v16;
  xpc_object_t v17;
  xpc_object_t v18;
  NSObject *v19;
  xpc_object_t v20;
  void *v21;
  NSObject *v22;
  void *v23;
  xpc_object_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  const void *v27;
  void *v28;
  NSObject *v29;
  void *v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  int v34;
  void *__p[3];
  uint64_t v36;
  std::__shared_weak_count *v37;
  __int128 object;
  void (*v39)(uint64_t);
  void *v40;
  void *aBlock;
  xpc_object_t v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v5 = (NSObject **)a1[4];
  v36 = 0;
  v37 = 0;
  v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    v37 = std::__shared_weak_count::lock(v6);
    if (!v37)
      return;
    v36 = a1[5];
    if (v36)
    {
      v9 = v5[14];
      if (v9)
      {
        dispatch_retain(v5[14]);
        dispatch_group_enter(v9);
      }
      memset(__p, 170, sizeof(__p));
      value = xpc_dictionary_get_value(*a3, "ProfileName");
      *(_QWORD *)&object = value;
      if (value)
        xpc_retain(value);
      else
        *(_QWORD *)&object = xpc_null_create();
      xpc::dyn_cast_or_default();
      xpc_release((xpc_object_t)object);
      v11 = (void *)HIBYTE(__p[2]);
      v12 = HIBYTE(__p[2]);
      if (SHIBYTE(__p[2]) < 0)
        v11 = __p[1];
      if (v11)
      {
        v34 = -1431655766;
        v13 = v5[5];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = (void **)__p[0];
          if (SHIBYTE(__p[2]) >= 0)
            v14 = __p;
          LODWORD(object) = 136315138;
          *(_QWORD *)((char *)&object + 4) = v14;
          _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I Checking if profile installed: name [%s]", (uint8_t *)&object, 0xCu);
          v12 = HIBYTE(__p[2]);
        }
        if (v12 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        v16 = abm::ProfileManagementTask::checkifProfileInstalled_sync(v5, (const char *)v15, &v34);
        v17 = xpc_dictionary_create(0, 0, 0);
        if (v17 || (v17 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v17) == MEMORY[0x1E0C812F8])
          {
            xpc_retain(v17);
            v18 = v17;
          }
          else
          {
            v18 = xpc_null_create();
          }
        }
        else
        {
          v18 = xpc_null_create();
          v17 = 0;
        }
        xpc_release(v17);
        v24 = xpc_BOOL_create(v16);
        if (!v24)
          v24 = xpc_null_create();
        xpc_dictionary_set_value(v18, "ProfileIsInstalled", v24);
        v25 = xpc_null_create();
        xpc_release(v24);
        xpc_release(v25);
        if (v18)
        {
          xpc_retain(v18);
          v26 = v18;
          v27 = *(const void **)a4;
          if (*(_QWORD *)a4)
          {
LABEL_44:
            v28 = _Block_copy(v27);
            goto LABEL_47;
          }
        }
        else
        {
          v26 = xpc_null_create();
          v27 = *(const void **)a4;
          if (*(_QWORD *)a4)
            goto LABEL_44;
        }
        v28 = 0;
LABEL_47:
        v29 = *(NSObject **)(a4 + 8);
        *(_QWORD *)&object = MEMORY[0x1E0C809B0];
        *((_QWORD *)&object + 1) = 3321888768;
        v39 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
        v40 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v28)
        {
          v30 = _Block_copy(v28);
          v43 = 0;
          aBlock = v30;
          v42 = v26;
          if (v26)
          {
LABEL_49:
            xpc_retain(v26);
LABEL_52:
            dispatch_async(v29, &object);
            xpc_release(v42);
            v42 = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v28)
              _Block_release(v28);
            xpc_release(v26);
            xpc_release(v18);
LABEL_57:
            if (SHIBYTE(__p[2]) < 0)
              operator delete(__p[0]);
            if (v9)
            {
              dispatch_group_leave(v9);
              dispatch_release(v9);
            }
            goto LABEL_61;
          }
        }
        else
        {
          v43 = 0;
          aBlock = 0;
          v42 = v26;
          if (v26)
            goto LABEL_49;
        }
        v42 = xpc_null_create();
        goto LABEL_52;
      }
      v19 = v5[5];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(object) = 0;
        _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Requested profile info is empty", (uint8_t *)&object, 2u);
      }
      v20 = xpc_null_create();
      if (*(_QWORD *)a4)
        v21 = _Block_copy(*(const void **)a4);
      else
        v21 = 0;
      v22 = *(NSObject **)(a4 + 8);
      *(_QWORD *)&object = MEMORY[0x1E0C809B0];
      *((_QWORD *)&object + 1) = 3321888768;
      v39 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
      v40 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v21)
      {
        v23 = _Block_copy(v21);
        v43 = -534716414;
        aBlock = v23;
        v42 = v20;
        if (v20)
        {
LABEL_31:
          xpc_retain(v20);
LABEL_34:
          dispatch_async(v22, &object);
          xpc_release(v42);
          v42 = 0;
          if (aBlock)
            _Block_release(aBlock);
          if (v21)
            _Block_release(v21);
          xpc_release(v20);
          goto LABEL_57;
        }
      }
      else
      {
        v43 = -534716414;
        aBlock = 0;
        v42 = v20;
        if (v20)
          goto LABEL_31;
      }
      v42 = xpc_null_create();
      goto LABEL_34;
    }
  }
LABEL_61:
  v31 = v37;
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      v33 = __ldaxr(p_shared_owners);
    while (__stlxr(v33 - 1, p_shared_owners));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_1A34F9584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, xpc_object_t object)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t abm::ProfileManagementTask::checkifProfileInstalled_sync(NSObject **this, const char *a2, int *a3)
{
  size_t v6;
  abm *v7;
  size_t v8;
  NSObject *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  xpc_object_t value;
  int v15;
  xpc_object_t v16;
  NSObject *v17;
  _BOOL4 v18;
  int v19;
  xpc_object_t object;
  _BYTE buf[12];
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  abm::sProfileInfoList((abm *)this);
  v6 = strlen(a2);
  v7 = (abm *)strncasecmp(a2, *(const char **)qword_1ED114B78, v6);
  if (!(_DWORD)v7)
  {
    v11 = 0;
    goto LABEL_7;
  }
  abm::sProfileInfoList(v7);
  v8 = strlen(a2);
  v7 = (abm *)strncasecmp(a2, *(const char **)(qword_1ED114B78 + 24), v8);
  if (!(_DWORD)v7)
  {
    v11 = 1;
LABEL_7:
    abm::sProfileInfoList(v7);
    v12 = *(_DWORD *)(qword_1ED114B78 + 24 * v11 + 16);
    object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)this, &object);
    if (MEMORY[0x1A85902BC](object) == MEMORY[0x1E0C812F8])
    {
      value = xpc_dictionary_get_value(object, "TelephonyLoggingPriority");
      *(_QWORD *)buf = value;
      if (value)
        xpc_retain(value);
      else
        *(_QWORD *)buf = xpc_null_create();
      v15 = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      v16 = xpc_dictionary_get_value(object, "TelephonyLoggingVersion");
      *(_QWORD *)buf = v16;
      if (v16)
        xpc_retain(v16);
      else
        *(_QWORD *)buf = xpc_null_create();
      *a3 = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      v17 = this[5];
      v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (v12 == v15)
      {
        if (v18)
        {
          v19 = *a3;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = a2;
          v22 = 1024;
          v23 = v19;
          _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, "#I Installed profile name [%s] : version [%d] ", buf, 0x12u);
        }
        v10 = 1;
        goto LABEL_9;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        v22 = 1024;
        v23 = v12;
        v24 = 1024;
        v25 = v15;
        _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, "#I Checking profile [%s: index %d] but installed profile index is [%d] ", buf, 0x18u);
      }
    }
    v10 = 0;
LABEL_9:
    xpc_release(object);
    return v10;
  }
  v9 = this[5];
  v10 = 0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = a2;
    _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#E Could not find info for profile: %s", buf, 0xCu);
    return 0;
  }
  return v10;
}

void sub_1A34F990C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_5(_QWORD *a1, uint64_t a2, xpc_object_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v5;
  NSObject **v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  NSObject *v11;
  xpc_object_t value;
  xpc_object_t v13;
  int v14;
  NSObject *v15;
  std::string *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  char *v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::string v29;
  std::__shared_weak_count *v31;
  uint64_t v32;
  uint64_t v33;
  _BYTE object[24];
  __int128 v35;
  std::string __p;
  dispatch_object_t v37[3];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v8 = (NSObject **)a1[4];
    v9 = std::__shared_weak_count::lock(v5);
    v31 = v9;
    if (v9)
    {
      v10 = v9;
      if (a1[5])
      {
        v11 = v8[14];
        if (v11)
        {
          dispatch_retain(v8[14]);
          dispatch_group_enter(v11);
        }
        memset(&v29, 170, sizeof(v29));
        value = xpc_dictionary_get_value(*a3, "ProfileName");
        *(_QWORD *)object = value;
        if (value)
          xpc_retain(value);
        else
          *(_QWORD *)object = xpc_null_create();
        xpc::dyn_cast_or_default();
        xpc_release(*(xpc_object_t *)object);
        v13 = xpc_dictionary_get_value(*a3, "RequireUserConfirmation");
        *(_QWORD *)object = v13;
        if (v13)
          xpc_retain(v13);
        else
          *(_QWORD *)object = xpc_null_create();
        v14 = xpc::dyn_cast_or_default();
        xpc_release(*(xpc_object_t *)object);
        v15 = v8[5];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = &v29;
          if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v16 = (std::string *)v29.__r_.__value_.__r.__words[0];
          *(_DWORD *)object = 136315394;
          *(_QWORD *)&object[4] = v16;
          *(_WORD *)&object[12] = 1024;
          *(_DWORD *)&object[14] = v14;
          _os_log_impl(&dword_1A343C000, v15, OS_LOG_TYPE_DEFAULT, "#I Install profile: %s, with confirmation %d", object, 0x12u);
        }
        v17 = a1[6];
        *(_QWORD *)object = a1[5];
        *(_QWORD *)&object[8] = v17;
        if (v17)
        {
          v18 = (unint64_t *)(v17 + 16);
          do
            v19 = __ldxr(v18);
          while (__stxr(v19 + 1, v18));
        }
        *(_QWORD *)&object[16] = v11;
        if (v11)
        {
          dispatch_retain(v11);
          if (*(_QWORD *)&object[16])
            dispatch_group_enter(*(dispatch_group_t *)&object[16]);
        }
        LOBYTE(v35) = v14;
        *((_QWORD *)&v35 + 1) = v8;
        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external(&__p, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
        else
          __p = v29;
        v20 = *a4;
        if (*a4)
          v20 = _Block_copy(v20);
        v21 = a4[1];
        v37[0] = v20;
        v37[1] = v21;
        if (v21)
          dispatch_retain(v21);
        v22 = v8[18];
        v23 = (char *)operator new(0x50uLL);
        v24 = *(_QWORD *)&object[8];
        *(_QWORD *)v23 = *(_QWORD *)object;
        *((_QWORD *)v23 + 1) = v24;
        if (v24)
        {
          v25 = (unint64_t *)(v24 + 16);
          do
            v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
        }
        *((_QWORD *)v23 + 2) = *(_QWORD *)&object[16];
        *(_OWORD *)(v23 + 24) = v35;
        *(std::string *)(v23 + 40) = __p;
        memset(&__p, 0, sizeof(__p));
        *((_OWORD *)v23 + 4) = *(_OWORD *)v37;
        *(_QWORD *)&object[16] = 0;
        v37[0] = 0;
        v37[1] = 0;
        v32 = 0;
        v33 = 0;
        dispatch_async_f(v22, v23, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v32);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v33);
        if (v37[1])
          dispatch_release(v37[1]);
        if (v37[0])
          _Block_release(v37[0]);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (*(_QWORD *)&object[16])
        {
          dispatch_group_leave(*(dispatch_group_t *)&object[16]);
          if (*(_QWORD *)&object[16])
            dispatch_release(*(dispatch_object_t *)&object[16]);
        }
        if (*(_QWORD *)&object[8])
          std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&object[8]);
        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v29.__r_.__value_.__l.__data_);
        if (v11)
        {
          dispatch_group_leave(v11);
          dispatch_release(v11);
        }
      }
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v28 = __ldaxr(p_shared_owners);
      while (__stlxr(v28 - 1, p_shared_owners));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

void sub_1A34F9CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object,std::__shared_weak_count *a21,dispatch_group_t group)
{
  NSObject *v22;

  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  if (a21)
    std::__shared_weak_count::__release_weak(a21);
  if (a15 < 0)
    operator delete(__p);
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_6(uint64_t a1, uint64_t a2, xpc_object_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v5;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  NSObject *v11;
  xpc_object_t value;
  std::string::size_type size;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  NSObject *v17;
  xpc_object_t v18;
  void *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  char *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  __int128 v27;
  NSObject *v28;
  void *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  xpc_object_t object;
  std::__shared_weak_count *v33;
  dispatch_group_t group[2];
  std::string __p;
  dispatch_object_t v36[2];
  std::string v37;
  std::__shared_weak_count *v39;
  uint64_t v40;
  uint64_t v41;

  v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = std::__shared_weak_count::lock(v5);
    v39 = v9;
    if (v9)
    {
      v10 = v9;
      if (!*(_QWORD *)(a1 + 40))
      {
LABEL_54:
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v31 = __ldaxr(p_shared_owners);
        while (__stlxr(v31 - 1, p_shared_owners));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      v11 = *(NSObject **)(v8 + 112);
      if (v11)
      {
        dispatch_retain(*(dispatch_object_t *)(v8 + 112));
        dispatch_group_enter(v11);
      }
      memset(&v37, 170, sizeof(v37));
      value = xpc_dictionary_get_value(*a3, "ProfileName");
      object = value;
      if (value)
        xpc_retain(value);
      else
        object = xpc_null_create();
      xpc::dyn_cast_or_default();
      xpc_release(object);
      size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v37.__r_.__value_.__l.__size_;
      if (size)
      {
        v14 = *(std::__shared_weak_count **)(a1 + 48);
        object = *(xpc_object_t *)(a1 + 40);
        v33 = v14;
        if (v14)
        {
          p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
          do
            v16 = __ldxr(p_shared_weak_owners);
          while (__stxr(v16 + 1, p_shared_weak_owners));
        }
        group[0] = v11;
        if (v11)
        {
          dispatch_retain(v11);
          dispatch_group_enter(group[0]);
        }
        group[1] = (dispatch_group_t)v8;
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external(&__p, v37.__r_.__value_.__l.__data_, v37.__r_.__value_.__l.__size_);
        else
          __p = v37;
        v20 = *a4;
        if (*a4)
          v20 = _Block_copy(v20);
        v21 = a4[1];
        v36[0] = v20;
        v36[1] = v21;
        if (v21)
          dispatch_retain(v21);
        v22 = *(NSObject **)(v8 + 144);
        v23 = (char *)operator new(0x48uLL);
        v24 = v33;
        *(_QWORD *)v23 = object;
        *((_QWORD *)v23 + 1) = v24;
        if (v24)
        {
          v25 = (unint64_t *)&v24->__shared_weak_owners_;
          do
            v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
        }
        v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((_OWORD *)v23 + 1) = *(_OWORD *)group;
        *((_OWORD *)v23 + 2) = v27;
        *((_QWORD *)v23 + 6) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        memset(&__p, 0, sizeof(__p));
        *(_OWORD *)(v23 + 56) = *(_OWORD *)v36;
        group[0] = 0;
        v36[0] = 0;
        v36[1] = 0;
        v40 = 0;
        v41 = 0;
        dispatch_async_f(v22, v23, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v40);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v41);
        if (v36[1])
          dispatch_release(v36[1]);
        if (v36[0])
          _Block_release(v36[0]);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v33)
          std::__shared_weak_count::__release_weak(v33);
LABEL_50:
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v37.__r_.__value_.__l.__data_);
        if (v11)
        {
          dispatch_group_leave(v11);
          dispatch_release(v11);
        }
        goto LABEL_54;
      }
      v17 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        LOWORD(object) = 0;
        _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, "Requested profile info is empty", (uint8_t *)&object, 2u);
      }
      v18 = xpc_null_create();
      if (*a4)
        v19 = _Block_copy(*a4);
      else
        v19 = 0;
      v28 = a4[1];
      object = (xpc_object_t)MEMORY[0x1E0C809B0];
      v33 = (std::__shared_weak_count *)3321888768;
      group[0] = (dispatch_group_t)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
      group[1] = (dispatch_group_t)&__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v19)
      {
        v29 = _Block_copy(v19);
        LODWORD(__p.__r_.__value_.__r.__words[2]) = -534716414;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v18;
        if (v18)
        {
LABEL_42:
          xpc_retain(v18);
LABEL_45:
          dispatch_async(v28, &object);
          xpc_release((xpc_object_t)__p.__r_.__value_.__l.__size_);
          __p.__r_.__value_.__l.__size_ = 0;
          if (__p.__r_.__value_.__r.__words[0])
            _Block_release(__p.__r_.__value_.__l.__data_);
          if (v19)
            _Block_release(v19);
          xpc_release(v18);
          goto LABEL_50;
        }
      }
      else
      {
        LODWORD(__p.__r_.__value_.__r.__words[2]) = -534716414;
        __p.__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v18;
        if (v18)
          goto LABEL_42;
      }
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)xpc_null_create();
      goto LABEL_45;
    }
  }
}

void sub_1A34FA17C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, std::__shared_weak_count *a10, dispatch_group_t group, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  NSObject *v23;
  uint64_t v24;

  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (a10)
  {
    std::__shared_weak_count::__release_weak(a10);
    if ((a23 & 0x80000000) == 0)
      goto LABEL_9;
  }
  else if ((a23 & 0x80000000) == 0)
  {
LABEL_9:
    if (!v23)
      goto LABEL_11;
    goto LABEL_10;
  }
  operator delete(__p);
  if (!v23)
  {
LABEL_11:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v24 - 80);
    _Unwind_Resume(a1);
  }
LABEL_10:
  dispatch_group_leave(v23);
  dispatch_release(v23);
  goto LABEL_11;
}

uint64_t abm::ProfileManagementTask::showMCProfileInstallNotification_sync(abm::ProfileManagementTask *this, const char *a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL8 v6;
  size_t v7;
  abm *v8;
  size_t v9;
  NSObject *v10;
  const char *v11;
  unsigned int v12;
  NSObject *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  int v19;
  const char *v20;
  size_t v21;
  std::string *p_buf;
  std::string *v23;
  uint64_t v24;
  __CFUserNotification *v25;
  __CFUserNotification *v26;
  uint64_t (*v27)(uint64_t);
  SInt32 v28;
  SInt32 v29;
  NSObject *v30;
  NSObject *v31;
  BOOL v32;
  int v33;
  char v34;
  void *v35;
  CFOptionFlags responseFlags;
  SInt32 error;
  std::string buf;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!TelephonyUtilIsCarrierBuild() || (TelephonyUtilIsInternalBuild() & 1) != 0)
    return 1;
  v5 = *((_QWORD *)this + 5);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Checking [%s] logging profile notification", (uint8_t *)&buf, 0xCu);
  }
  abm::sProfileInfoList((abm *)v6);
  v7 = strlen(a2);
  v8 = (abm *)strncasecmp(a2, *(const char **)qword_1ED114B78, v7);
  if ((_DWORD)v8)
  {
    abm::sProfileInfoList(v8);
    v9 = strlen(a2);
    if (strncasecmp(a2, *(const char **)(qword_1ED114B78 + 24), v9))
    {
      v10 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        v11 = "Profile notification skipped as we failed to get profile info";
LABEL_66:
        _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, 2u);
        return 0;
      }
      return 0;
    }
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  if ((abm::ProfileManagementTask::isProfileValid((NSObject **)this, v12) & 1) == 0)
  {
    v10 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v11 = "Profile notification skipped as profile is not valid";
      goto LABEL_66;
    }
    return 0;
  }
  if ((abm::ProfileManagementTask::isAllowedToOverrideProfile((NSObject **)this, v12) & 1) == 0)
  {
    v10 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v11 = "Profile notification skipped as we want to keep pre-installed one";
      goto LABEL_66;
    }
    return 0;
  }
  if (*((_QWORD *)this + 17) && (unint64_t)(TelephonyUtilGetSystemTime() - *((_QWORD *)this + 17)) >> 6 < 0x753)
    return 0;
  v13 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A343C000, v13, OS_LOG_TYPE_DEFAULT, "#I Asking for user confirmation to install profile", (uint8_t *)&buf, 2u);
  }
  v14 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  objc_msgSend(v14, "setObject:forKeyedSubscript:", CFSTR("Dismiss"), *MEMORY[0x1E0C9B838]);
  v15 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Update %s %@"), a2, CFSTR("Logging Profile"));
  objc_msgSend(v14, "setObject:forKeyedSubscript:", v15, *MEMORY[0x1E0C9B800]);
  objc_msgSend(v14, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0C9B820]);
  objc_msgSend(v14, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0DABBB0]);
  objc_msgSend(v14, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAA0], *MEMORY[0x1E0DABB98]);
  objc_msgSend(v14, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0DABC38]);
  if (config::hw::watch((config::hw *)objc_msgSend(v14, "setObject:forKeyedSubscript:", CFSTR("Install"), *MEMORY[0x1E0C9B830])))
  {
    v16 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "The Telephony Logging Profile generates files that allow Apple to troubleshoot issues with your device and help Apple to improve its products and services. The generated files may contain some of your personal information, including contents of SMS's, device identifiers and names, the IP addresses and recent location history of your device, phone numbers of the registering device, Apple Accounts into which you are signed, and logs of incoming and outgoing calls and audio routes during the time the logging is enabled. If you install this profile, it will automatically turn the logging on and this data will be captured when you take a Sysdiagnose on this device. The data will not leave the device unless you initiate a Sysdiagnose and send the results. The profile will expire after 21 days. You will be able to turn on and off logging at any time while the Profile is installed. To turn off logging on your device, go to your iphone and watch app. By enabling this diagnostic tool and sending a copy of the generated files to Apple, you are consenting to Apple's use of the content of such files in accordance with its privacy policy (http://www.apple.com/legal/privacy).");
    objc_msgSend(v14, "setObject:forKeyedSubscript:", v16, *MEMORY[0x1E0C9B810]);
    v17 = 1;
  }
  else
  {
    v19 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E0D47230], "sharedConnection"), "isProfileUIInstallationAllowed");
    v17 = v19;
    if (v19)
      v20 = "Do you want to ";
    else
      v20 = "Do you want to enable profile installation and ";
    buf.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    buf.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAAAALL;
    if (v19)
      v21 = 15;
    else
      v21 = 47;
    buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    if ((v19 & 1) != 0)
    {
      *((_BYTE *)&buf.__r_.__value_.__s + 23) = 15;
      p_buf = &buf;
    }
    else
    {
      p_buf = (std::string *)operator new(0x30uLL);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = xmmword_1A3582170;
    }
    memcpy(p_buf, v20, v21);
    p_buf->__r_.__value_.__s.__data_[v21] = 0;
    std::string::append(&buf, "install profile to avoid missing important logging information?", 0x3FuLL);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v23 = &buf;
    else
      v23 = (std::string *)buf.__r_.__value_.__r.__words[0];
    v24 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v23);
    objc_msgSend(v14, "setObject:forKeyedSubscript:", v24, *MEMORY[0x1E0C9B810]);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf.__r_.__value_.__l.__data_);
  }
  error = 0;
  responseFlags = 3;
  v25 = CFUserNotificationCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 600.0, 3uLL, &error, (CFDictionaryRef)v14);
  v26 = v25;
  v27 = ctu::SharedRef<__CFUserNotification,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUserNotification>::get;
  if (!v25)
    v27 = 0;
  v28 = error;
  if (!v27 || error)
  {
    v31 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v28;
      _os_log_error_impl(&dword_1A343C000, v31, OS_LOG_TYPE_ERROR, "Creating profile installation notification resulted in error: %d", (uint8_t *)&buf, 8u);
    }
    v4 = 0;
  }
  else
  {
    v29 = CFUserNotificationReceiveResponse(v25, 0.0, &responseFlags);
    error = v29;
    v30 = *((_QWORD *)this + 5);
    if (v29)
    {
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v29;
        _os_log_error_impl(&dword_1A343C000, v30, OS_LOG_TYPE_ERROR, "Receiving profile installation notification resulted in error: %d", (uint8_t *)&buf, 8u);
      }
    }
    else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = responseFlags;
      _os_log_impl(&dword_1A343C000, v30, OS_LOG_TYPE_DEFAULT, "#I responseFlags=0x%lx", (uint8_t *)&buf, 0xCu);
    }
    v32 = responseFlags == 1 && error == 0;
    v33 = !v32;
    if (v32)
      v34 = v17;
    else
      v34 = 1;
    if ((v34 & 1) != 0)
    {
      v4 = v33 ^ 1u;
    }
    else
    {
      v35 = (void *)objc_msgSend(MEMORY[0x1E0D47230], "sharedConnection");
      v4 = 1;
      objc_msgSend(v35, "setBoolValue:forSetting:", 1, *MEMORY[0x1E0D47190]);
    }
  }
  *((_QWORD *)this + 17) = TelephonyUtilGetSystemTime();
  if (v26)
    CFRelease(v26);
  return v4;
}

void sub_1A34FA834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t abm::ProfileManagementTask::getProfileInfoIndex_sync(abm::ProfileManagementTask *this, const char *a2)
{
  size_t v3;
  uint64_t result;
  size_t v5;

  abm::sProfileInfoList(this);
  v3 = strlen(a2);
  result = strncasecmp(a2, *(const char **)qword_1ED114B78, v3);
  if ((_DWORD)result)
  {
    abm::sProfileInfoList((abm *)result);
    v5 = strlen(a2);
    if (!strncasecmp(a2, *(const char **)(qword_1ED114B78 + 24), v5))
      return 1;
    else
      return 2;
  }
  return result;
}

uint64_t abm::ProfileManagementTask::isProfileValid(NSObject **this, unsigned int a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  _BOOL8 v15;
  uint64_t v17;
  uint64_t v18;
  uint8_t buf[4];
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  abm::sProfileInfoList((abm *)this);
  v4 = *(_QWORD *)(qword_1ED114B78 + 24 * a2 + 8);
  v5 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFSTR("com.apple.ABMHelper")), "bundleURL");
  v6 = objc_msgSend((id)objc_msgSend(v5, "URLByAppendingPathComponent:isDirectory:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4), 0), "path");
  v7 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithContentsOfFile:", v6);
  if (v7)
  {
    v8 = (void *)v7;
    v18 = 0;
    v9 = (void *)objc_msgSend(MEMORY[0x1E0D47220], "profileWithData:outError:", v7, &v18);
    v10 = objc_msgSend(MEMORY[0x1E0C99D68], "date");
    v11 = (void *)objc_msgSend(v9, "removalDate");
    if (v11 && (void *)objc_msgSend(v11, "earlierDate:", v10) == v11)
    {
      v14 = this[5];
      v15 = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
      if (v15)
      {
        abm::sProfileInfoList((abm *)v15);
        v17 = *(_QWORD *)(qword_1ED114B78 + 24 * a2);
        *(_DWORD *)buf = 136315138;
        v20 = v17;
        _os_log_error_impl(&dword_1A343C000, v14, OS_LOG_TYPE_ERROR, "Profile [%s] is expired", buf, 0xCu);
      }
      v12 = 0;
    }
    else
    {
      v12 = 1;
    }

  }
  else
  {
    v13 = this[5];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v20) = a2;
      _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Failed to get profile data [index:%d]", buf, 8u);
    }
    return 0;
  }
  return v12;
}

uint64_t abm::ProfileManagementTask::isAllowedToOverrideProfile(NSObject **this, unsigned int a2)
{
  const char *v4;
  size_t v5;
  void *v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  abm *v11;
  int v12;
  uint64_t v13;
  xpc_object_t value;
  int v16;
  xpc_object_t v17;
  int v18;
  NSObject *v19;
  void **v20;
  const char *v21;
  NSObject *v22;
  NSObject *v23;
  _BOOL4 v24;
  void **v25;
  void **v26;
  xpc_object_t object;
  void *__dst[3];
  _BYTE v29[12];
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  memset(__dst, 170, sizeof(__dst));
  abm::sProfileInfoList((abm *)this);
  v4 = *(const char **)(qword_1ED114B78 + 24 * a2);
  v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (void *)v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    v7 = (void **)operator new(v8 + 1);
    __dst[1] = v6;
    __dst[2] = (void *)(v9 | 0x8000000000000000);
    __dst[0] = v7;
    goto LABEL_8;
  }
  HIBYTE(__dst[2]) = v5;
  v7 = __dst;
  if (v5)
LABEL_8:
    v5 = (size_t)memmove(v7, v4, (size_t)v6);
  *((_BYTE *)v6 + (_QWORD)v7) = 0;
  abm::sProfileInfoList((abm *)v5);
  v10 = *(_DWORD *)(qword_1ED114B78 + 24 * a2 + 20);
  abm::sProfileInfoList(v11);
  v12 = *(_DWORD *)(qword_1ED114B78 + 24 * a2 + 16);
  object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)this, &object);
  if (MEMORY[0x1A85902BC](object) != MEMORY[0x1E0C812F8])
  {
LABEL_10:
    v13 = 1;
    goto LABEL_11;
  }
  value = xpc_dictionary_get_value(object, "TelephonyLoggingPriority");
  *(_QWORD *)v29 = value;
  if (value)
    xpc_retain(value);
  else
    *(_QWORD *)v29 = xpc_null_create();
  v16 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)v29);
  v17 = xpc_dictionary_get_value(object, "TelephonyLoggingVersion");
  *(_QWORD *)v29 = v17;
  if (v17)
    xpc_retain(v17);
  else
    *(_QWORD *)v29 = xpc_null_create();
  v18 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)v29);
  if (v16 == v12 && v18 >= v10)
  {
    v19 = this[5];
    v13 = 0;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    v20 = __dst;
    if (SHIBYTE(__dst[2]) < 0)
      v20 = (void **)__dst[0];
    *(_DWORD *)v29 = 136315394;
    *(_QWORD *)&v29[4] = v20;
    v30 = 1024;
    v31 = v10;
    v21 = "#I Skip install [%s, version: %d] as installed profile version is same or higher";
    v22 = v19;
    goto LABEL_31;
  }
  v23 = this[5];
  v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (v16 <= v12)
  {
    if (v24)
    {
      v26 = __dst;
      if (SHIBYTE(__dst[2]) < 0)
        v26 = (void **)__dst[0];
      *(_DWORD *)v29 = 136315394;
      *(_QWORD *)&v29[4] = v26;
      v30 = 1024;
      v31 = v10;
      _os_log_impl(&dword_1A343C000, v23, OS_LOG_TYPE_DEFAULT, "#I Allow to override [%s, version: %d] ", v29, 0x12u);
    }
    goto LABEL_10;
  }
  if (v24)
  {
    v25 = __dst;
    if (SHIBYTE(__dst[2]) < 0)
      v25 = (void **)__dst[0];
    *(_DWORD *)v29 = 136315394;
    *(_QWORD *)&v29[4] = v25;
    v30 = 1024;
    v31 = v10;
    v21 = "#I Skip install [%s, version: %d] as installed profile has higher priority ";
    v22 = v23;
LABEL_31:
    _os_log_impl(&dword_1A343C000, v22, OS_LOG_TYPE_DEFAULT, v21, v29, 0x12u);
    v13 = 0;
    goto LABEL_11;
  }
  v13 = 0;
LABEL_11:
  xpc_release(object);
  if (SHIBYTE(__dst[2]) < 0)
    operator delete(__dst[0]);
  return v13;
}

void sub_1A34FAE60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t ctu::SharedRef<__CFUserNotification,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUserNotification>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

const void **ctu::cf::CFSharedRef<__CFUserNotification>::~CFSharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync(NSObject **this)
{
  xpc_object_t v2;
  xpc_object_t v3;
  xpc_object_t v4;
  xpc_object_t v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  int v10;
  std::string *p_p;
  xpc_object_t v12;
  xpc_object_t v13;
  xpc_object_t object;
  std::string __p;
  int v16;
  std::string v17;

  v2 = xpc_array_create(0, 0);
  if (v2 || (v2 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v2) == MEMORY[0x1E0C812C8])
    {
      xpc_retain(v2);
      v3 = v2;
    }
    else
    {
      v3 = xpc_null_create();
    }
  }
  else
  {
    v3 = xpc_null_create();
    v2 = 0;
  }
  v16 = -1431655766;
  xpc_release(v2);
  v4 = xpc_dictionary_create(0, 0, 0);
  if (v4 || (v4 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v4) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(v4);
      v5 = v4;
    }
    else
    {
      v5 = xpc_null_create();
    }
  }
  else
  {
    v5 = xpc_null_create();
    v4 = 0;
  }
  xpc_release(v4);
  v6 = xpc_string_create("Profile");
  if (!v6)
    v6 = xpc_null_create();
  xpc_dictionary_set_value(v5, "kKeyTraceName", v6);
  v7 = xpc_null_create();
  xpc_release(v6);
  xpc_release(v7);
  v8 = xpc_string_create("InstalledCarrierProfileVersion");
  if (!v8)
    v8 = xpc_null_create();
  xpc_dictionary_set_value(v5, "kKeyTracePropertyName", v8);
  v9 = xpc_null_create();
  xpc_release(v8);
  xpc_release(v9);
  if (abm::ProfileManagementTask::checkifProfileInstalled_sync(this, "Baseband", &v16))
    v10 = v16;
  else
    v10 = 0;
  std::to_string(&v17, v10);
  __p = v17;
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v12 = xpc_string_create((const char *)p_p);
  if (!v12)
    v12 = xpc_null_create();
  xpc_dictionary_set_value(v5, "kKeyTracePropertyValue", v12);
  v13 = xpc_null_create();
  xpc_release(v12);
  xpc_release(v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  xpc_array_append_value(v3, v5);
  object = v3;
  if (v3)
    xpc_retain(v3);
  else
    object = xpc_null_create();
  abm::ProfileManagementTask::applyTraceProperties_sync((uint64_t)this, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v5);
  xpc_release(v3);
}

void sub_1A34FB1E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;
  void *v17;

  xpc_release(object);
  xpc_release(v17);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask29registerForNotifications_syncEv_block_invoke(_QWORD *a1, void *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  const char *string;
  NSObject *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  int v15;
  int IsCarrierBuild;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *p_shared_weak_owners;
  unint64_t v20;
  NSObject *v21;
  _QWORD *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD v27[4];
  xpc_object_t v28;
  xpc_object_t object;
  xpc_object_t v30;
  xpc_object_t v31;
  std::__shared_weak_count *v33;

  v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    v5 = a1[4];
    v6 = std::__shared_weak_count::lock(v3);
    v33 = v6;
    if (v6)
    {
      v7 = v6;
      if (a1[5])
      {
        v8 = *(NSObject **)(v5 + 112);
        if (v8)
        {
          dispatch_retain(*(dispatch_object_t *)(v5 + 112));
          dispatch_group_enter(v8);
        }
        if (a2)
        {
          string = xpc_dictionary_get_string(a2, (const char *)*MEMORY[0x1E0C81298]);
          if (string)
          {
            if (!strcasecmp("com.apple.ManagedConfiguration.profileListChanged", string))
            {
              v14 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v27[0]) = 0;
                _os_log_impl(&dword_1A343C000, v14, OS_LOG_TYPE_DEFAULT, "#I streamed event received: Profile Changed", (uint8_t *)v27, 2u);
              }
              if ((abm::ProfileManagementTask::wasProfileInstalled_sync((abm::ProfileManagementTask *)v5) & 1) != 0)
              {
                v15 = 1;
              }
              else
              {
                if ((TelephonyUtilIsInternalBuild() & 1) != 0)
                  IsCarrierBuild = 1;
                else
                  IsCarrierBuild = TelephonyUtilIsCarrierBuild();
                v15 = IsCarrierBuild ^ 1;
              }
              abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v5, &v30);
              abm::ProfileManagementTask::convertToTraceProperties_sync(v5, &v30, v15, &v31);
              abm::ProfileManagementTask::applyTraceProperties_sync(v5, &v31);
              xpc_release(v31);
              v31 = 0;
              xpc_release(v30);
              v30 = 0;
              if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
              {
                abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync((NSObject **)v5);
                v18 = a1[5];
                v17 = (std::__shared_weak_count *)a1[6];
                if (v17)
                {
                  p_shared_weak_owners = (unint64_t *)&v17->__shared_weak_owners_;
                  do
                    v20 = __ldxr(p_shared_weak_owners);
                  while (__stxr(v20 + 1, p_shared_weak_owners));
                }
                if (v8)
                {
                  dispatch_retain(v8);
                  dispatch_group_enter(v8);
                }
                v21 = *(NSObject **)(v5 + 144);
                v22 = operator new(0x20uLL);
                *v22 = v18;
                v22[1] = v17;
                if (v17)
                {
                  v23 = (unint64_t *)&v17->__shared_weak_owners_;
                  do
                    v24 = __ldxr(v23);
                  while (__stxr(v24 + 1, v23));
                  v22[2] = v8;
                  v22[3] = v5;
                  dispatch_async_f(v21, v22, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__3EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
                  std::__shared_weak_count::__release_weak(v17);
                }
                else
                {
                  v22[2] = v8;
                  v22[3] = v5;
                  dispatch_async_f(v21, v22, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__3EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
                }
              }
            }
            else if (!strcasecmp("com.apple.purplebuddy.setupdone", string))
            {
              v10 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v27[0]) = 0;
                _os_log_impl(&dword_1A343C000, v10, OS_LOG_TYPE_DEFAULT, "#I streamed event received: Buddy Setup Done", (uint8_t *)v27, 2u);
              }
              if ((TelephonyUtilIsInternalBuild() & 1) == 0 && (TelephonyUtilIsCarrierBuild() & 1) == 0)
              {
                abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v5, &v28);
                abm::ProfileManagementTask::convertToTraceProperties_sync(v5, &v28, 1, &object);
                abm::ProfileManagementTask::applyTraceProperties_sync(v5, &object);
                xpc_release(object);
                object = 0;
                xpc_release(v28);
                v28 = 0;
              }
              if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
              {
                v11 = a1[6];
                v27[0] = a1[5];
                v27[1] = v11;
                if (v11)
                {
                  v12 = (unint64_t *)(v11 + 16);
                  do
                    v13 = __ldxr(v12);
                  while (__stxr(v13 + 1, v12));
                }
                v27[2] = v8;
                if (v8)
                {
                  dispatch_retain(v8);
                  dispatch_group_enter(v8);
                }
                v27[3] = v5;
                _ZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvRKNS_5queueEOT_(*(NSObject **)(v5 + 144), (uint64_t)v27);
                _ZZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_EN3__4D1Ev((uint64_t)v27);
              }
            }
          }
        }
        if (v8)
        {
          dispatch_group_leave(v8);
          dispatch_release(v8);
        }
      }
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A34FB608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t object, xpc_object_t a15, xpc_object_t a16, char a17)
{
  NSObject *v17;

  xpc_release(object);
  xpc_release(a13);
  if (v17)
  {
    dispatch_group_leave(v17);
    dispatch_release(v17);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t abm::ProfileManagementTask::wasProfileInstalled_sync(abm::ProfileManagementTask *this)
{
  xpc_object_t v2;
  uint64_t v3;
  xpc_object_t v4;
  xpc_object_t v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  __int128 v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t value;
  unsigned __int8 v17;
  size_t v18;
  std::string::size_type size;
  int v20;
  std::string *v21;
  uint64_t v22;
  void **p_s1;
  int v24;
  int v25;
  int v26;
  int v27;
  BOOL v29;
  _BOOL4 v30;
  NSObject *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::string v37;
  xpc_object_t object;
  void *__s1;
  size_t __n;
  unsigned __int8 v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  void *__p[5];
  xpc_object_t v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  std::string v48;

  v46 = 0xAAAAAAAAAAAAAAAALL;
  v47 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(__p[2]) = 17;
  strcpy((char *)__p, "ProfileManagement");
  abm::client::CreateManager();
  v2 = xpc_dictionary_create(0, 0, 0);
  v3 = MEMORY[0x1E0C812F8];
  if (v2 || (v2 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v2) == v3)
    {
      xpc_retain(v2);
      v4 = v2;
    }
    else
    {
      v4 = xpc_null_create();
    }
  }
  else
  {
    v4 = xpc_null_create();
    v2 = 0;
  }
  xpc_release(v2);
  v5 = xpc_string_create("Profile");
  if (!v5)
    v5 = xpc_null_create();
  xpc_dictionary_set_value(v4, "kKeyTraceName", v5);
  v6 = xpc_null_create();
  xpc_release(v5);
  xpc_release(v6);
  v7 = xpc_string_create((const char *)*MEMORY[0x1E0CFAF68]);
  if (!v7)
    v7 = xpc_null_create();
  xpc_dictionary_set_value(v4, "kKeyTracePropertyName", v7);
  v8 = xpc_null_create();
  xpc_release(v7);
  xpc_release(v8);
  v45 = xpc_null_create();
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__p = v9;
  *(_OWORD *)&__p[2] = v9;
  v42 = v46;
  v43 = v47;
  p_shared_owners = (unint64_t *)&v47->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v48.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&v48.__r_.__value_.__r.__words[1] = xmmword_1A357F050;
  strcpy(v48.__r_.__value_.__l.__data_, "kCommandGetTraceProperty");
  abm::client::PerformCommand();
  operator delete(v48.__r_.__value_.__l.__data_);
  v12 = &v43->__shared_owners_;
  do
    v13 = __ldaxr((unint64_t *)v12);
  while (__stlxr(v13 - 1, (unint64_t *)v12));
  if (v13)
  {
    v14 = v45;
    if (v45)
      goto LABEL_20;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
    v14 = v45;
    if (v45)
      goto LABEL_20;
  }
  v14 = xpc_null_create();
  if (!v14)
  {
    v15 = xpc_null_create();
    v14 = 0;
    goto LABEL_23;
  }
LABEL_20:
  if (MEMORY[0x1A85902BC](v14) == v3)
  {
    xpc_retain(v14);
    v15 = v14;
  }
  else
  {
    v15 = xpc_null_create();
  }
LABEL_23:
  xpc_release(v14);
  if (LODWORD(__p[0]) || MEMORY[0x1A85902BC](v15) != v3)
  {
LABEL_56:
    v32 = 0;
    goto LABEL_57;
  }
  value = xpc_dictionary_get_value(v15, "kKeyTracePropertyValue");
  object = value;
  if (value)
    xpc_retain(value);
  else
    object = xpc_null_create();
  xpc::dyn_cast_or_default();
  std::to_string(&v48, 1);
  v37 = v48;
  v17 = v41;
  if ((v41 & 0x80u) == 0)
    v18 = v41;
  else
    v18 = __n;
  size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
  v20 = SHIBYTE(v37.__r_.__value_.__r.__words[2]);
  if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v37.__r_.__value_.__l.__size_;
  if (v18 != size)
  {
    v30 = 0;
    if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_50;
    goto LABEL_47;
  }
  if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = &v37;
  else
    v21 = (std::string *)v37.__r_.__value_.__r.__words[0];
  if ((char)v41 < 0)
  {
    v30 = memcmp(__s1, v21, __n) == 0;
    goto LABEL_49;
  }
  if (v41)
  {
    v22 = v41 - 1;
    p_s1 = &__s1;
    do
    {
      v25 = *(unsigned __int8 *)p_s1;
      p_s1 = (void **)((char *)p_s1 + 1);
      v24 = v25;
      v27 = v21->__r_.__value_.__s.__data_[0];
      v21 = (std::string *)((char *)v21 + 1);
      v26 = v27;
      v29 = v22-- != 0;
      v30 = v24 == v26;
    }
    while (v24 == v26 && v29);
LABEL_49:
    if ((v20 & 0x80000000) == 0)
      goto LABEL_50;
LABEL_47:
    operator delete(v37.__r_.__value_.__l.__data_);
    v17 = v41;
    goto LABEL_50;
  }
  v30 = 1;
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_47;
LABEL_50:
  if ((v17 & 0x80) != 0)
    operator delete(__s1);
  xpc_release(object);
  if (!v30)
    goto LABEL_56;
  v31 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v48.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A343C000, v31, OS_LOG_TYPE_DEFAULT, "#I Logging profile was installed", (uint8_t *)&v48, 2u);
  }
  v32 = 1;
LABEL_57:
  xpc_release(v15);
  if (SHIBYTE(__p[3]) < 0)
    operator delete(__p[1]);
  xpc_release(v4);
  v33 = v47;
  if (v47)
  {
    v34 = (unint64_t *)&v47->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  return v32;
}

void sub_1A34FBB40(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A34FB9BCLL);
}

void sub_1A34FBB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  void *v31;
  void *v32;
  uint64_t v33;

  if (a14 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  xpc_release(object);
  xpc_release(v32);
  if (a31 < 0)
    operator delete(a26);
  xpc_release(v31);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v33 - 96);
  _Unwind_Resume(a1);
}

void sub_1A34FBC44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void _ZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvRKNS_5queueEOT_(NSObject *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;

  v4 = operator new(0x20uLL);
  v5 = *(_QWORD *)(a2 + 8);
  *v4 = *(_QWORD *)a2;
  v4[1] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  *((_OWORD *)v4 + 1) = v8;
  dispatch_async_f(a1, v4, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
}

uint64_t _ZZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_EN3__4D1Ev(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 16);
    if (v3)
      dispatch_release(v3);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void abm::sProfileInfoList(abm *this)
{
  unsigned __int8 v1;
  _QWORD v2[7];

  v2[6] = *MEMORY[0x1E0C80C00];
  v1 = atomic_load((unsigned __int8 *)&qword_1ED114B58);
  if ((v1 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED114B58))
    {
      v2[0] = "Baseband";
      v2[1] = "Baseband.mobileconfig";
      v2[2] = 0x1000000003;
      v2[3] = "CellularDE";
      v2[4] = "CellularDE.mobileconfig";
      v2[5] = 0x1000000002;
      std::vector<abm::ProfileManagementTask::ProfileDetail>::vector[abi:ne180100](v2, 2uLL);
      __cxa_atexit((void (*)(void *))std::vector<abm::ProfileManagementTask::ProfileDetail>::~vector[abi:ne180100], &qword_1ED114B78, &dword_1A343C000);
      __cxa_guard_release(&qword_1ED114B58);
    }
  }
}

void sub_1A34FBDF8(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED114B58);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::getProfileIdentifier_sync(NSObject **this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  size_t v17;
  size_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint8_t buf[16];
  unint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  abm::sProfileInfoList((abm *)this);
  v6 = *(_QWORD *)(qword_1ED114B78 + 24 * a2 + 8);
  v7 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFSTR("com.apple.ABMHelper")), "bundleURL");
  v8 = objc_msgSend((id)objc_msgSend(v7, "URLByAppendingPathComponent:isDirectory:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v6), 0), "path");
  v9 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithContentsOfFile:", v8);
  if (v9)
  {
    v10 = (void *)v9;
    v22 = 0;
    v11 = (void *)objc_msgSend(MEMORY[0x1E0D47220], "profileWithData:outError:", v9, &v22);
    v12 = v22;
    if (v22)
    {
      v13 = this[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v14 = objc_msgSend((id)objc_msgSend(v12, "localizedDescription"), "UTF8String");
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v14;
        _os_log_error_impl(&dword_1A343C000, v13, OS_LOG_TYPE_ERROR, "Reading profile Error: %s", buf, 0xCu);
      }
      goto LABEL_12;
    }
    v16 = (const char *)objc_msgSend((id)objc_msgSend(v11, "identifier"), "UTF8String");
    v17 = strlen(v16);
    if (v17 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v18 = v17;
    if (v17 >= 0x17)
    {
      v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17)
        v20 = v17 | 7;
      v21 = v20 + 1;
      v19 = operator new(v20 + 1);
      *(_QWORD *)&buf[8] = v18;
      v24 = v21 | 0x8000000000000000;
      *(_QWORD *)buf = v19;
    }
    else
    {
      HIBYTE(v24) = v17;
      v19 = buf;
      if (!v17)
      {
        buf[0] = 0;
        if ((*(char *)(a3 + 23) & 0x80000000) == 0)
        {
LABEL_11:
          *(_OWORD *)a3 = *(_OWORD *)buf;
          *(_QWORD *)(a3 + 16) = v24;
LABEL_12:

          return;
        }
LABEL_18:
        operator delete(*(void **)a3);
        goto LABEL_11;
      }
    }
    memmove(v19, v16, v18);
    *((_BYTE *)v19 + v18) = 0;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
      goto LABEL_11;
    goto LABEL_18;
  }
  v15 = this[5];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = a2;
    _os_log_error_impl(&dword_1A343C000, v15, OS_LOG_TYPE_ERROR, "Failed to get profile data [index:%d]", buf, 8u);
  }
}

void sub_1A34FC07C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t abm::ProfileManagementTask::installMCProfile_sync(NSObject **this, const char *a2, int a3)
{
  size_t v6;
  abm *v7;
  size_t v8;
  NSObject *v9;
  const char *v10;
  unsigned int v11;
  uint64_t isAllowedToOverrideProfile;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  config::hw *v16;
  config::hw *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  void *v22;
  BOOL v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t IsInternalBuild;
  int isProfileValid;
  uint64_t v29;
  id v30;
  uint8_t buf[4];
  _DWORD v32[7];

  *(_QWORD *)&v32[5] = *MEMORY[0x1E0C80C00];
  abm::sProfileInfoList((abm *)this);
  v6 = strlen(a2);
  v7 = (abm *)strncasecmp(a2, *(const char **)qword_1ED114B78, v6);
  if ((_DWORD)v7)
  {
    abm::sProfileInfoList(v7);
    v8 = strlen(a2);
    if (strncasecmp(a2, *(const char **)(qword_1ED114B78 + 24), v8))
    {
      v9 = this[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v10 = "Install profile failed as we failed to get profile info";
LABEL_13:
        _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
        return 0;
      }
      return 0;
    }
    v11 = 1;
    isAllowedToOverrideProfile = abm::ProfileManagementTask::isAllowedToOverrideProfile(this, 1u);
    if ((isAllowedToOverrideProfile & 1) == 0)
    {
LABEL_11:
      v9 = this[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v10 = "Install profile failed as we want to keep pre-installed one";
        goto LABEL_13;
      }
      return 0;
    }
  }
  else
  {
    v11 = 0;
    isAllowedToOverrideProfile = abm::ProfileManagementTask::isAllowedToOverrideProfile(this, 0);
    if ((isAllowedToOverrideProfile & 1) == 0)
      goto LABEL_11;
  }
  v30 = 0;
  abm::sProfileInfoList((abm *)isAllowedToOverrideProfile);
  v13 = *(_QWORD *)(qword_1ED114B78 + 24 * v11 + 8);
  v14 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFSTR("com.apple.ABMHelper")), "bundleURL");
  v15 = objc_msgSend((id)objc_msgSend(v14, "URLByAppendingPathComponent:isDirectory:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v13), 0), "path");
  v16 = (config::hw *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithContentsOfFile:", v15);
  if (!v16)
  {
    v19 = this[5];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v32 = a2;
      _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Profile [%s] not found", buf, 0xCu);
    }
    return 0;
  }
  v17 = v16;
  if (a3 && (config::hw::watch(v16) & 1) == 0)
    v18 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E0D47230], "sharedConnection"), "queueFileDataForAcceptance:originalFileName:outError:", v17, 0, &v30);
  else
    v18 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E0D47230], "sharedConnection"), "installProfileData:options:outError:", v17, 0, &v30);
  v22 = (void *)v18;
  if (v18)
    v23 = v30 == 0;
  else
    v23 = 0;
  v20 = v23;
  v24 = this[5];
  if (v23)
  {
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = objc_msgSend(v22, "UTF8String");
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v32 = v25;
      _os_log_impl(&dword_1A343C000, v24, OS_LOG_TYPE_DEFAULT, "#I Install profile data success, id: %s", buf, 0xCu);
    }
    if (TelephonyUtilIsCarrierBuild())
    {
      IsInternalBuild = TelephonyUtilIsInternalBuild();
      if ((IsInternalBuild & 1) == 0)
      {
        if (config::hw::watch((config::hw *)IsInternalBuild))
          abm::ProfileManagementTask::rebootWithConfirmation_sync((abm::ProfileManagementTask *)this);
      }
    }
  }
  else if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    isProfileValid = abm::ProfileManagementTask::isProfileValid(this, v11);
    v29 = objc_msgSend((id)objc_msgSend(v30, "localizedDescription"), "UTF8String");
    *(_DWORD *)buf = 67109378;
    v32[0] = isProfileValid;
    LOWORD(v32[1]) = 2080;
    *(_QWORD *)((char *)&v32[1] + 2) = v29;
    _os_log_error_impl(&dword_1A343C000, v24, OS_LOG_TYPE_ERROR, "Install profile data [valid=%d] failed: %s", buf, 0x12u);
  }

  return v20;
}

void abm::ProfileManagementTask::rebootWithConfirmation_sync(abm::ProfileManagementTask *this)
{
  NSObject *v2;
  void *v3;
  __CFUserNotification *v4;
  __CFUserNotification *v5;
  uint64_t (*v6)(uint64_t);
  SInt32 v7;
  SInt32 v8;
  NSObject *v9;
  NSObject *v10;
  CFOptionFlags responseFlags;
  SInt32 error;
  uint8_t buf[4];
  CFOptionFlags v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I Asking for user confirmation to reboot after installing profile", buf, 2u);
  }
  v3 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  objc_msgSend(v3, "setObject:forKeyedSubscript:", CFSTR("Dismiss"), *MEMORY[0x1E0C9B838]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", CFSTR("Reboot Required"), *MEMORY[0x1E0C9B800]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0C9B820]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0DABBB0]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAA0], *MEMORY[0x1E0DABB98]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0DABC38]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", CFSTR("Reboot"), *MEMORY[0x1E0C9B830]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", CFSTR("A reboot is required for the logging profile change to take effect. Would you like to reboot now?"), *MEMORY[0x1E0C9B810]);
  error = 0;
  responseFlags = 3;
  v4 = CFUserNotificationCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 600.0, 3uLL, &error, (CFDictionaryRef)v3);
  v5 = v4;
  v6 = ctu::SharedRef<__CFUserNotification,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUserNotification>::get;
  if (!v4)
    v6 = 0;
  v7 = error;
  if (!v6 || error)
  {
    v10 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v14) = v7;
      _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Creating reboot notification resulted in error: %d", buf, 8u);
    }
  }
  else
  {
    v8 = CFUserNotificationReceiveResponse(v4, 0.0, &responseFlags);
    error = v8;
    v9 = *((_QWORD *)this + 5);
    if (v8)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v14) = v8;
        _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Receiving reboot notification resulted in error: %d", buf, 8u);
      }
    }
    else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v14 = responseFlags;
      _os_log_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEFAULT, "#I responseFlags=0x%lx", buf, 0xCu);
    }
    if (responseFlags == 1 && !error)
      abm::ProfileManagementTask::reboot_sync(this);
  }
  if (v5)
    CFRelease(v5);
}

void sub_1A34FC708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void abm::ProfileManagementTask::uninstallMCProfile_sync(NSObject **a1, const char *a2, uint64_t a3)
{
  NSObject *v6;
  _BOOL8 v7;
  size_t v8;
  abm *v9;
  size_t v10;
  NSObject *v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  void *v15;
  void **v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  xpc_object_t v20;
  void *v21;
  NSObject *v22;
  void *v23;
  _QWORD v24[5];
  void *aBlock;
  dispatch_object_t object;
  void *__p[2];
  void (*v28)(uint64_t);
  uint8_t buf[16];
  void (*v30)(uint64_t);
  void *v31;
  void *v32;
  xpc_object_t v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v6 = a1[5];
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = a2;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Uninstall profile: %s", buf, 0xCu);
  }
  __p[0] = 0;
  __p[1] = 0;
  v28 = 0;
  abm::sProfileInfoList((abm *)v7);
  v8 = strlen(a2);
  v9 = (abm *)strncasecmp(a2, *(const char **)qword_1ED114B78, v8);
  if ((_DWORD)v9)
  {
    abm::sProfileInfoList(v9);
    v10 = strlen(a2);
    if (strncasecmp(a2, *(const char **)(qword_1ED114B78 + 24), v10))
    {
      v11 = a1[5];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = a2;
        _os_log_error_impl(&dword_1A343C000, v11, OS_LOG_TYPE_ERROR, "Failed to get profile [%s] info", buf, 0xCu);
      }
      goto LABEL_38;
    }
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  abm::ProfileManagementTask::getProfileIdentifier_sync(a1, v12, (uint64_t)buf);
  v28 = v30;
  *(_OWORD *)__p = *(_OWORD *)buf;
  v13 = (unint64_t)v30 >> 56;
  v14 = SHIBYTE(v30);
  if (SHIBYTE(v30) < 0)
    v13 = *(_QWORD *)&buf[8];
  if (v13)
  {
    v15 = (void *)objc_msgSend(MEMORY[0x1E0D47230], "sharedConnection");
    if (v14 >= 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    v17 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v16);
    v24[0] = MEMORY[0x1E0C809B0];
    v24[1] = 3321888768;
    v24[2] = ___ZN3abm21ProfileManagementTask23uninstallMCProfile_syncEPKcN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_block_invoke;
    v24[3] = &__block_descriptor_56_e8_40c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
    v24[4] = a1;
    v18 = *(void **)a3;
    if (*(_QWORD *)a3)
      v18 = _Block_copy(v18);
    v19 = *(NSObject **)(a3 + 8);
    aBlock = v18;
    object = v19;
    if (v19)
      dispatch_retain(v19);
    objc_msgSend(v15, "removeProfileWithIdentifier:completion:", v17, v24);
    if (object)
      dispatch_release(object);
    if (aBlock)
      _Block_release(aBlock);
    goto LABEL_38;
  }
  if (!*(_QWORD *)a3 || !*(_QWORD *)(a3 + 8))
    goto LABEL_38;
  v20 = xpc_null_create();
  if (*(_QWORD *)a3)
    v21 = _Block_copy(*(const void **)a3);
  else
    v21 = 0;
  v22 = *(NSObject **)(a3 + 8);
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3321888768;
  v30 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
  v31 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v21)
  {
    v34 = -534716416;
    v32 = 0;
    v33 = v20;
    if (v20)
      goto LABEL_30;
LABEL_32:
    v33 = xpc_null_create();
    goto LABEL_33;
  }
  v23 = _Block_copy(v21);
  v34 = -534716416;
  v32 = v23;
  v33 = v20;
  if (!v20)
    goto LABEL_32;
LABEL_30:
  xpc_retain(v20);
LABEL_33:
  dispatch_async(v22, buf);
  xpc_release(v33);
  v33 = 0;
  if (v32)
    _Block_release(v32);
  if (v21)
    _Block_release(v21);
  xpc_release(v20);
LABEL_38:
  if (SHIBYTE(v28) < 0)
    operator delete(__p[0]);
}

void sub_1A34FCA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ___ZN3abm21ProfileManagementTask23uninstallMCProfile_syncEPKcN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_block_invoke(_QWORD *a1)
{
  NSObject **v1;
  xpc_object_t v3;
  const void *v4;
  void *v5;
  NSObject *v6;
  config::hw *v7;
  _QWORD block[4];
  void *aBlock;
  xpc_object_t object;
  int v11;

  v1 = (NSObject **)a1[4];
  if (!a1[5] || !a1[6])
    goto LABEL_16;
  v3 = xpc_null_create();
  v4 = (const void *)a1[5];
  if (v4)
    v5 = _Block_copy(v4);
  else
    v5 = 0;
  v6 = a1[6];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
  block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v5)
  {
    v11 = 0;
    aBlock = 0;
    object = v3;
    if (v3)
      goto LABEL_8;
LABEL_10:
    object = xpc_null_create();
    goto LABEL_11;
  }
  v11 = 0;
  aBlock = _Block_copy(v5);
  object = v3;
  if (!v3)
    goto LABEL_10;
LABEL_8:
  xpc_retain(v3);
LABEL_11:
  dispatch_async(v6, block);
  xpc_release(object);
  object = 0;
  if (aBlock)
    _Block_release(aBlock);
  if (v5)
    _Block_release(v5);
  xpc_release(v3);
LABEL_16:
  if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
  {
    abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync(v1);
    if (config::hw::watch(v7))
      abm::ProfileManagementTask::rebootWithConfirmation_sync((abm::ProfileManagementTask *)v1);
  }
}

void __copy_helper_block_e8_40c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(uint64_t a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;

  v4 = *(void **)(a2 + 40);
  if (v4)
    v4 = _Block_copy(v4);
  v5 = *(NSObject **)(a2 + 48);
  *(_QWORD *)(a1 + 40) = v4;
  *(_QWORD *)(a1 + 48) = v5;
  if (v5)
    dispatch_retain(v5);
}

void __destroy_helper_block_e8_40c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  v2 = *(NSObject **)(a1 + 48);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    _Block_release(v3);
}

void abm::ProfileManagementTask::reboot_sync(abm::ProfileManagementTask *this)
{
  NSObject *v1;
  void *v2;
  uint8_t v3[16];

  v1 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_1A343C000, v1, OS_LOG_TYPE_DEFAULT, "#I Rebooting", v3, 2u);
  }
  v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D23280]), "initWithReason:", CFSTR("For logging profile change to take effect"));
  objc_msgSend(v2, "setRebootType:", 1);
  objc_msgSend(v2, "setSource:", 1);
  objc_msgSend((id)objc_msgSend(MEMORY[0x1E0D23288], "sharedService"), "shutdownWithOptions:", v2);

}

void *std::vector<abm::ProfileManagementTask::ProfileDetail>::vector[abi:ne180100](void *result, unint64_t a2)
{
  const void *v2;
  size_t v3;
  uint64_t v4;

  qword_1ED114B78 = 0;
  qword_1ED114B80 = 0;
  qword_1ED114B88 = 0;
  if (a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    v2 = result;
    v3 = 24 * a2;
    qword_1ED114B78 = (uint64_t)operator new(24 * a2);
    qword_1ED114B80 = qword_1ED114B78;
    v4 = qword_1ED114B78 + v3;
    qword_1ED114B88 = qword_1ED114B78 + v3;
    result = memmove((void *)qword_1ED114B78, v2, v3);
    qword_1ED114B80 = v4;
  }
  return result;
}

void sub_1A34FCDCC(_Unwind_Exception *exception_object)
{
  if (qword_1ED114B78)
  {
    qword_1ED114B80 = qword_1ED114B78;
    operator delete((void *)qword_1ED114B78);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<abm::ProfileManagementTask::ProfileDetail>::~vector[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_1(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  xpc_object_t object;

  v1 = *(unsigned int *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  object = v2;
  if (v2)
    xpc_retain(v2);
  else
    object = xpc_null_create();
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A34FCE80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  xpc_object_t object;

  v1 = *(unsigned int *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  object = v2;
  if (v2)
    xpc_retain(v2);
  else
    object = xpc_null_create();
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A34FCEFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t *_ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(uint64_t *a1)
{
  uint64_t v2;
  NSObject *v3;
  const void *v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(NSObject **)(v2 + 72);
    if (v3)
      dispatch_release(v3);
    v4 = *(const void **)(v2 + 64);
    if (v4)
      _Block_release(v4);
    if (*(char *)(v2 + 63) < 0)
      operator delete(*(void **)(v2 + 40));
    v5 = *(NSObject **)(v2 + 16);
    if (v5)
    {
      dispatch_group_leave(v5);
      v6 = *(NSObject **)(v2 + 16);
      if (v6)
        dispatch_release(v6);
    }
    v7 = *(std::__shared_weak_count **)(v2 + 8);
    if (v7)
      std::__shared_weak_count::__release_weak(v7);
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t *_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(uint64_t a1)
{
  std::__shared_weak_count *v2;
  NSObject **v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  int v6;
  const char *v7;
  const char *v8;
  xpc_object_t v9;
  const void *v10;
  void *v11;
  NSObject *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v16;
  _QWORD block[4];
  void *aBlock;
  xpc_object_t object;
  int v20;

  v16 = a1;
  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v2)
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v16);
  v3 = *(NSObject ***)(a1 + 32);
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v16);
  v5 = v4;
  if (*(_QWORD *)a1)
  {
    v6 = -534716416;
    if (!*(_BYTE *)(a1 + 24))
      goto LABEL_8;
    v7 = (const char *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v7 = *(const char **)v7;
    if (abm::ProfileManagementTask::showMCProfileInstallNotification_sync((abm::ProfileManagementTask *)v3, v7))
    {
LABEL_8:
      v8 = (const char *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0)
        v8 = *(const char **)v8;
      if (abm::ProfileManagementTask::installMCProfile_sync(v3, v8, *(unsigned __int8 *)(a1 + 24)))
        v6 = 0;
      else
        v6 = -534716416;
    }
    v9 = xpc_null_create();
    v10 = *(const void **)(a1 + 64);
    if (v10)
      v11 = _Block_copy(v10);
    else
      v11 = 0;
    v12 = *(NSObject **)(a1 + 72);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
    block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v11)
    {
      v20 = v6;
      aBlock = _Block_copy(v11);
      object = v9;
      if (v9)
      {
LABEL_18:
        xpc_retain(v9);
LABEL_21:
        dispatch_async(v12, block);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v11)
          _Block_release(v11);
        xpc_release(v9);
        goto LABEL_26;
      }
    }
    else
    {
      v20 = v6;
      aBlock = 0;
      object = v9;
      if (v9)
        goto LABEL_18;
    }
    object = xpc_null_create();
    goto LABEL_21;
  }
LABEL_26:
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v16);
}

void sub_1A34FD160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v12;

  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&a9);
  _Unwind_Resume(a1);
}

uint64_t *_ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(uint64_t *a1)
{
  uint64_t v2;
  NSObject *v3;
  const void *v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(NSObject **)(v2 + 64);
    if (v3)
      dispatch_release(v3);
    v4 = *(const void **)(v2 + 56);
    if (v4)
      _Block_release(v4);
    if (*(char *)(v2 + 55) < 0)
      operator delete(*(void **)(v2 + 32));
    v5 = *(NSObject **)(v2 + 16);
    if (v5)
    {
      dispatch_group_leave(v5);
      v6 = *(NSObject **)(v2 + 16);
      if (v6)
        dispatch_release(v6);
    }
    v7 = *(std::__shared_weak_count **)(v2 + 8);
    if (v7)
      std::__shared_weak_count::__release_weak(v7);
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t *_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(uint64_t a1)
{
  std::__shared_weak_count *v2;
  NSObject **v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  const char *v6;
  const void *v7;
  void *v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  void *v14;
  NSObject *v15;

  v13 = a1;
  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v2)
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v13);
  v3 = *(NSObject ***)(a1 + 24);
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v13);
  v5 = v4;
  if (*(_QWORD *)a1)
  {
    v6 = (const char *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0)
    {
      v6 = *(const char **)v6;
      v7 = *(const void **)(a1 + 56);
      if (v7)
      {
LABEL_6:
        v8 = _Block_copy(v7);
        v9 = *(NSObject **)(a1 + 64);
        v14 = v8;
        v15 = v9;
        if (!v9)
        {
LABEL_8:
          abm::ProfileManagementTask::uninstallMCProfile_sync(v3, v6, (uint64_t)&v14);
          if (v9)
            dispatch_release(v9);
          if (v8)
            _Block_release(v8);
          goto LABEL_12;
        }
LABEL_7:
        dispatch_retain(v9);
        goto LABEL_8;
      }
    }
    else
    {
      v7 = *(const void **)(a1 + 56);
      if (v7)
        goto LABEL_6;
    }
    v8 = 0;
    v9 = *(NSObject **)(a1 + 64);
    v14 = 0;
    v15 = v9;
    if (!v9)
      goto LABEL_8;
    goto LABEL_7;
  }
LABEL_12:
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v13);
}

void sub_1A34FD338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__shared_weak_count *v10;
  const void *v11;
  NSObject *v12;
  unint64_t *p_shared_owners;
  unint64_t v15;

  if (v12)
    dispatch_release(v12);
  if (v11)
    _Block_release(v11);
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&a10);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__3EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(_QWORD *__p)
{
  std::__shared_weak_count *v2;
  abm::ProfileManagementTask *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  config::hw *v6;
  int v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  NSObject *v11;
  std::__shared_weak_count *v12;

  v2 = (std::__shared_weak_count *)__p[1];
  if (v2)
  {
    v3 = (abm::ProfileManagementTask *)__p[3];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*__p)
      {
        v6 = (config::hw *)abm::ProfileManagementTask::showMCProfileInstallNotification_sync(v3, "Baseband");
        if ((_DWORD)v6)
        {
          v7 = config::hw::watch(v6);
          abm::ProfileManagementTask::installMCProfile_sync((NSObject **)v3, "Baseband", v7 ^ 1);
        }
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  v10 = __p[2];
  if (v10)
  {
    dispatch_group_leave(v10);
    v11 = __p[2];
    if (v11)
      dispatch_release(v11);
  }
  v12 = (std::__shared_weak_count *)__p[1];
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  operator delete(__p);
}

void sub_1A34FD460(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  v6 = v1[2];
  if (v6)
  {
    dispatch_group_leave(v6);
    v7 = v1[2];
    if (v7)
      dispatch_release(v7);
  }
  v8 = (std::__shared_weak_count *)v1[1];
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(_QWORD *__p)
{
  std::__shared_weak_count *v2;
  abm::ProfileManagementTask *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  config::hw *v6;
  int v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  NSObject *v11;
  std::__shared_weak_count *v12;

  v2 = (std::__shared_weak_count *)__p[1];
  if (v2)
  {
    v3 = (abm::ProfileManagementTask *)__p[3];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*__p)
      {
        v6 = (config::hw *)abm::ProfileManagementTask::showMCProfileInstallNotification_sync(v3, "Baseband");
        if ((_DWORD)v6)
        {
          v7 = config::hw::watch(v6);
          abm::ProfileManagementTask::installMCProfile_sync((NSObject **)v3, "Baseband", v7 ^ 1);
        }
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  v10 = __p[2];
  if (v10)
  {
    dispatch_group_leave(v10);
    v11 = __p[2];
    if (v11)
      dispatch_release(v11);
  }
  v12 = (std::__shared_weak_count *)__p[1];
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  operator delete(__p);
}

void sub_1A34FD590(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  v6 = v1[2];
  if (v6)
  {
    dispatch_group_leave(v6);
    v7 = v1[2];
    if (v7)
      dispatch_release(v7);
  }
  v8 = (std::__shared_weak_count *)v1[1];
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t diag::FileInfo::shouldFilter(diag::FileInfo *this)
{
  int IsCarrierBuild;
  int IsInternalBuild;
  uint64_t result;
  int v5;
  BOOL v6;

  IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  IsInternalBuild = TelephonyUtilIsInternalBuild();
  result = (IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild()) ^ 1;
  if (*((_BYTE *)this + 28))
  {
    v5 = *((_DWORD *)this + 6);
    if (v5)
      v6 = v5 == 7;
    else
      v6 = 1;
    if (v6)
      return 1;
    else
      return result;
  }
  return result;
}

void diag::getFileInfo(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  const std::string::value_type *v4;
  int v5;
  size_t size;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  std::string *p_p;
  std::string *v13;
  const char *v14;
  int v15;
  int st_gid_high;
  uint64_t v17;
  timespec v18;
  const char *v19;
  std::string __p;
  int v21;
  stat v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v21 = -1431655766;
  v4 = (const std::string::value_type *)ETLDMCGetMatchingFileNameAndType();
  *(_QWORD *)(a2 + 24) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)(a2 + 32) = 0xAAAAAAAAAAAAAAAALL;
  *(_BYTE *)(a2 + 28) = 0;
  *(_BYTE *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_BYTE *)(a2 + 24) = 0;
  memset(&__p, 0, sizeof(__p));
  if (v4)
  {
    std::string::__assign_external(&__p, v4);
    *(_DWORD *)(a2 + 24) = v21;
    *(_BYTE *)(a2 + 28) = 1;
  }
  else if (&__p != (std::string *)a1)
  {
    if (*(char *)(a1 + 23) < 0)
      std::string::__assign_no_alias<true>(&__p, *(void **)a1, *(_QWORD *)(a1 + 8));
    else
      __p = *(std::string *)a1;
  }
  v5 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v7 = size + 17;
  memset(&v22, 170, 24);
  if (size + 17 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v7 >= 0x17)
  {
    v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v9 = v7 | 7;
    v10 = v9 + 1;
    v11 = (char *)operator new(v9 + 1);
    v22.st_ino = size + 17;
    *(_QWORD *)&v22.st_uid = v10 | 0x8000000000000000;
    *(_QWORD *)&v22.st_dev = v11;
    v11[16] = 47;
    *(_OWORD *)v11 = *(_OWORD *)"/usr/lib/bbmasks/";
    v8 = v11 + 17;
  }
  else
  {
    *(_QWORD *)&v22.st_uid = 47;
    *(_OWORD *)&v22.st_dev = *(_OWORD *)"/usr/lib/bbmasks/";
    v8 = (char *)&v22.st_uid + 1;
    if (!size)
      goto LABEL_17;
  }
  if (v5 >= 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  memmove(v8, p_p, size);
LABEL_17:
  v8[size] = 0;
  v13 = std::string::append((std::string *)&v22, ".dmc", 4uLL);
  v14 = (const char *)v13->__r_.__value_.__r.__words[0];
  v23[0] = v13->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v23 + 7) = *(std::string::size_type *)((char *)&v13->__r_.__value_.__r.__words[1] + 7);
  v15 = SHIBYTE(v13->__r_.__value_.__r.__words[2]);
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  st_gid_high = SHIBYTE(v22.st_gid);
  *(_QWORD *)(a2 + 15) = *(_QWORD *)((char *)v23 + 7);
  v17 = v23[0];
  *(_QWORD *)a2 = v14;
  *(_QWORD *)(a2 + 8) = v17;
  *(_BYTE *)(a2 + 23) = v15;
  if (st_gid_high < 0)
    operator delete(*(void **)&v22.st_dev);
  v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v22.st_blksize = v18;
  *(timespec *)v22.st_qspare = v18;
  v22.st_birthtimespec = v18;
  *(timespec *)&v22.st_size = v18;
  v22.st_mtimespec = v18;
  v22.st_ctimespec = v18;
  *(timespec *)&v22.st_uid = v18;
  v22.st_atimespec = v18;
  if (v15 >= 0)
    v19 = (const char *)a2;
  else
    v19 = v14;
  *(timespec *)&v22.st_dev = v18;
  *(_BYTE *)(a2 + 32) = stat(v19, &v22) == 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1A34FD8CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (a21 < 0)
  {
    operator delete(__p);
    if (a14 < 0)
    {
LABEL_5:
      operator delete(a9);
      if ((*(char *)(v21 + 23) & 0x80000000) == 0)
        goto LABEL_9;
LABEL_8:
      operator delete(*(void **)v21);
LABEL_9:
      _Unwind_Resume(a1);
    }
  }
  else if (a14 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v21 + 23) & 0x80000000) == 0)
    goto LABEL_9;
  goto LABEL_8;
}

uint64_t diag::loadDMC(uint64_t a1)
{
  __int128 v1;
  timespec v2;
  void **v3;
  uint64_t v4;
  void **v6;
  char IsCarrierBuild;
  char IsInternalBuild;
  char v9;
  unsigned int DefaultFilters;
  uint64_t v11;
  uint64_t v12;
  void *__p[2];
  __int128 v14;
  unint64_t v15;
  stat v16;

  v15 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v1 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__p = v1;
  v14 = v1;
  diag::getFileInfo(a1, (uint64_t)__p);
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v16.st_blksize = v2;
  *(timespec *)v16.st_qspare = v2;
  v16.st_birthtimespec = v2;
  *(timespec *)&v16.st_size = v2;
  v16.st_mtimespec = v2;
  v16.st_ctimespec = v2;
  *(timespec *)&v16.st_uid = v2;
  v16.st_atimespec = v2;
  *(timespec *)&v16.st_dev = v2;
  if ((SBYTE7(v14) & 0x80u) == 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  if (stat((const char *)v3, &v16))
  {
    v4 = 0;
    goto LABEL_6;
  }
  if ((SBYTE7(v14) & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  v4 = MEMORY[0x1A858EA08](v6, *MEMORY[0x1E0C9AE00], kETLDIAGLoggingDefaultView, 0);
  if (!v4)
    goto LABEL_6;
  IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  IsInternalBuild = TelephonyUtilIsInternalBuild();
  v9 = IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild();
  if (BYTE12(v14))
  {
    if ((v9 & 1) != 0 && DWORD2(v14) && DWORD2(v14) != 7)
      goto LABEL_6;
  }
  else if ((v9 & 1) != 0)
  {
    goto LABEL_6;
  }
  *(_QWORD *)&v16.st_dev = 0;
  DefaultFilters = ETLDMCLogGetDefaultFilters();
  if (DefaultFilters)
  {
    v11 = 0;
    v12 = 24 * DefaultFilters;
    do
    {
      ETLDMCLogFilter();
      v11 += 24;
    }
    while (v12 != v11);
  }
LABEL_6:
  if (SBYTE7(v14) < 0)
    operator delete(__p[0]);
  return v4;
}

void sub_1A34FDAAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t diag::filterDMC()
{
  unsigned int DefaultFilters;
  uint64_t v1;
  int v2;
  uint64_t v3;

  DefaultFilters = ETLDMCLogGetDefaultFilters();
  if (!DefaultFilters)
    return 0;
  v1 = 0;
  v2 = 0;
  v3 = 24 * DefaultFilters;
  do
  {
    v2 |= ETLDMCLogFilter();
    v1 += 24;
  }
  while (v3 != v1);
  return v2 & 1;
}

uint64_t diag::mergeDMC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  timespec v10;
  void **v11;
  const void *v12;
  void **v13;
  uint64_t v14;
  timespec v15;
  void **v16;
  const void *v17;
  void **v18;
  timespec v19;
  void **v20;
  const void *v21;
  void **v22;
  char IsCarrierBuild;
  char IsInternalBuild;
  char v25;
  unsigned int DefaultFilters;
  uint64_t v27;
  uint64_t v28;
  char v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  char v36;
  char v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  uint64_t v44;
  void *__p[2];
  __int128 v46;
  unint64_t v47;
  void *v48[2];
  __int128 v49;
  unint64_t v50;
  void *v51[2];
  __int128 v52;
  unint64_t v53;
  stat v54;

  v53 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v51 = v7;
  v52 = v7;
  diag::getFileInfo(a1, (uint64_t)v51);
  v50 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v48 = v8;
  v49 = v8;
  diag::getFileInfo(a2, (uint64_t)v48);
  v47 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__p = v9;
  v46 = v9;
  diag::getFileInfo(a3, (uint64_t)__p);
  v10.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v10.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize = v10;
  *(timespec *)v54.st_qspare = v10;
  v54.st_birthtimespec = v10;
  *(timespec *)&v54.st_size = v10;
  v54.st_mtimespec = v10;
  v54.st_ctimespec = v10;
  *(timespec *)&v54.st_uid = v10;
  v54.st_atimespec = v10;
  *(timespec *)&v54.st_dev = v10;
  if ((SBYTE7(v52) & 0x80u) == 0)
    v11 = v51;
  else
    v11 = (void **)v51[0];
  if (stat((const char *)v11, &v54))
  {
    v12 = 0;
  }
  else
  {
    if ((SBYTE7(v52) & 0x80u) == 0)
      v13 = v51;
    else
      v13 = (void **)v51[0];
    v12 = (const void *)MEMORY[0x1A858EA08](v13, *MEMORY[0x1E0C9AE00], kETLDIAGLoggingDefaultView, a4);
  }
  if (v12)
    v14 = 0;
  else
    v14 = a4;
  v15.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v15.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize = v15;
  *(timespec *)v54.st_qspare = v15;
  v54.st_birthtimespec = v15;
  *(timespec *)&v54.st_size = v15;
  v54.st_mtimespec = v15;
  v54.st_ctimespec = v15;
  *(timespec *)&v54.st_uid = v15;
  v54.st_atimespec = v15;
  *(timespec *)&v54.st_dev = v15;
  if ((SBYTE7(v49) & 0x80u) == 0)
    v16 = v48;
  else
    v16 = (void **)v48[0];
  if (stat((const char *)v16, &v54))
  {
    v17 = 0;
  }
  else
  {
    if ((SBYTE7(v49) & 0x80u) == 0)
      v18 = v48;
    else
      v18 = (void **)v48[0];
    v17 = (const void *)MEMORY[0x1A858EA08](v18, *MEMORY[0x1E0C9AE00], kETLDIAGLoggingDefaultView, v14);
  }
  if (v17)
    v14 = 0;
  else
    v14 = v14;
  v19.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v19.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize = v19;
  *(timespec *)v54.st_qspare = v19;
  v54.st_birthtimespec = v19;
  *(timespec *)&v54.st_size = v19;
  v54.st_mtimespec = v19;
  v54.st_ctimespec = v19;
  *(timespec *)&v54.st_uid = v19;
  v54.st_atimespec = v19;
  *(timespec *)&v54.st_dev = v19;
  if ((SBYTE7(v46) & 0x80u) == 0)
    v20 = __p;
  else
    v20 = (void **)__p[0];
  if (stat((const char *)v20, &v54))
  {
    v21 = 0;
    if (!v12)
      goto LABEL_44;
  }
  else
  {
    if ((SBYTE7(v46) & 0x80u) == 0)
      v22 = __p;
    else
      v22 = (void **)__p[0];
    v21 = (const void *)MEMORY[0x1A858EA08](v22, *MEMORY[0x1E0C9AE00], kETLDIAGLoggingDefaultView, v14);
    if (!v12)
      goto LABEL_44;
  }
  IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  IsInternalBuild = TelephonyUtilIsInternalBuild();
  v25 = IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild();
  if (BYTE12(v52))
  {
    if ((v25 & 1) != 0 && DWORD2(v52) && DWORD2(v52) != 7)
      goto LABEL_44;
  }
  else if ((v25 & 1) != 0)
  {
    goto LABEL_44;
  }
  *(_QWORD *)&v54.st_dev = 0;
  DefaultFilters = ETLDMCLogGetDefaultFilters();
  if (DefaultFilters)
  {
    v27 = 0;
    v28 = 24 * DefaultFilters;
    do
    {
      ETLDMCLogFilter();
      v27 += 24;
    }
    while (v28 != v27);
  }
LABEL_44:
  if (!v17)
    goto LABEL_54;
  v29 = TelephonyUtilIsCarrierBuild();
  v30 = TelephonyUtilIsInternalBuild();
  v31 = v29 | v30 | TelephonyUtilIsVendorBuild();
  if (BYTE12(v49))
  {
    if ((v31 & 1) != 0 && DWORD2(v49) && DWORD2(v49) != 7)
      goto LABEL_54;
  }
  else if ((v31 & 1) != 0)
  {
    goto LABEL_54;
  }
  *(_QWORD *)&v54.st_dev = 0;
  v32 = ETLDMCLogGetDefaultFilters();
  if (v32)
  {
    v33 = 0;
    v34 = 24 * v32;
    do
    {
      ETLDMCLogFilter();
      v33 += 24;
    }
    while (v34 != v33);
  }
LABEL_54:
  if (!v21)
  {
    if (v12 && v17)
    {
      v38 = ETLDMCMerge();
      CFRelease(v12);
      CFRelease(v17);
      goto LABEL_72;
    }
    goto LABEL_78;
  }
  v35 = TelephonyUtilIsCarrierBuild();
  v36 = TelephonyUtilIsInternalBuild();
  v37 = v35 | v36 | TelephonyUtilIsVendorBuild();
  if (BYTE12(v46))
  {
    if ((v37 & 1) != 0 && DWORD2(v46) && DWORD2(v46) != 7)
      goto LABEL_67;
LABEL_64:
    *(_QWORD *)&v54.st_dev = 0;
    v39 = ETLDMCLogGetDefaultFilters();
    if (v39)
    {
      v40 = 0;
      v41 = 24 * v39;
      do
      {
        ETLDMCLogFilter();
        v40 += 24;
      }
      while (v41 != v40);
    }
    goto LABEL_67;
  }
  if ((v37 & 1) == 0)
    goto LABEL_64;
LABEL_67:
  if (v12 && v17)
  {
    v42 = (const void *)ETLDMCMerge();
    v38 = ETLDMCMerge();
    CFRelease(v12);
    CFRelease(v17);
    CFRelease(v21);
    CFRelease(v42);
    goto LABEL_72;
  }
  if (v17)
  {
    v38 = ETLDMCMerge();
    CFRelease(v17);
    CFRelease(v21);
    goto LABEL_72;
  }
  if (v12)
  {
    v38 = ETLDMCMerge();
    CFRelease(v12);
    CFRelease(v21);
LABEL_72:
    if ((SBYTE7(v46) & 0x80000000) == 0)
      goto LABEL_73;
    goto LABEL_85;
  }
LABEL_78:
  if (v17)
    v44 = (uint64_t)v17;
  else
    v44 = (uint64_t)v21;
  if (v12)
    v38 = (uint64_t)v12;
  else
    v38 = v44;
  if ((SBYTE7(v46) & 0x80000000) == 0)
  {
LABEL_73:
    if ((SBYTE7(v49) & 0x80000000) == 0)
      goto LABEL_74;
LABEL_86:
    operator delete(v48[0]);
    if ((SBYTE7(v52) & 0x80000000) == 0)
      return v38;
LABEL_87:
    operator delete(v51[0]);
    return v38;
  }
LABEL_85:
  operator delete(__p[0]);
  if (SBYTE7(v49) < 0)
    goto LABEL_86;
LABEL_74:
  if (SBYTE7(v52) < 0)
    goto LABEL_87;
  return v38;
}

void sub_1A34FE05C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a23 < 0)
  {
    operator delete(__p);
    if ((a32 & 0x80000000) == 0)
LABEL_3:
      _Unwind_Resume(exception_object);
  }
  else if ((a32 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a27);
  _Unwind_Resume(exception_object);
}

BOOL diag::copyDMC(uint64_t a1, const void **a2)
{
  int v4;
  size_t v5;
  unint64_t v6;
  std::string *p_dst;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  int v11;
  const std::string::value_type *v12;
  std::string::size_type v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  timespec v18;
  void **v19;
  _BOOL8 v20;
  std::string __dst;
  void *__p[2];
  std::string::size_type v24;
  void *v25[2];
  uint64_t v26;
  stat v27;

  diag::getFileInfo(a1, (uint64_t)&v27);
  *(_OWORD *)v25 = *(_OWORD *)&v27.st_dev;
  v26 = *(_QWORD *)&v27.st_uid;
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  v6 = v5 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v5 + 1 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v6 >= 0x17)
  {
    v8 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v8 = v6 | 7;
    v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v5 + 1;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v5 + 1;
    if (!v5)
      goto LABEL_15;
  }
  if (v4 >= 0)
    v10 = a2;
  else
    v10 = *a2;
  memmove(p_dst, v10, v5);
LABEL_15:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v5) = 47;
  v11 = *(char *)(a1 + 23);
  if (v11 >= 0)
    v12 = (const std::string::value_type *)a1;
  else
    v12 = *(const std::string::value_type **)a1;
  if (v11 >= 0)
    v13 = *(unsigned __int8 *)(a1 + 23);
  else
    v13 = *(_QWORD *)(a1 + 8);
  v14 = std::string::append(&__dst, v12, v13);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  *(_QWORD *)&v27.st_uid = *((_QWORD *)&v14->__r_.__value_.__l + 2);
  *(_OWORD *)&v27.st_dev = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v16 = std::string::append((std::string *)&v27, ".dmc", 4uLL);
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v24 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v27.st_gid) < 0)
  {
    operator delete(*(void **)&v27.st_dev);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_23;
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_23;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_23:
  v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v27.st_blksize = v18;
  *(timespec *)v27.st_qspare = v18;
  v27.st_birthtimespec = v18;
  *(timespec *)&v27.st_size = v18;
  v27.st_mtimespec = v18;
  v27.st_ctimespec = v18;
  *(timespec *)&v27.st_uid = v18;
  v27.st_atimespec = v18;
  *(timespec *)&v27.st_dev = v18;
  if (v26 >= 0)
    v19 = v25;
  else
    v19 = (void **)v25[0];
  if (stat((const char *)v19, &v27))
  {
    v20 = 0;
    if ((SHIBYTE(v24) & 0x80000000) == 0)
      goto LABEL_29;
    goto LABEL_28;
  }
  v20 = support::fs::copyFile((const char *)v25, (const char *)__p, 0);
  if (SHIBYTE(v24) < 0)
LABEL_28:
    operator delete(__p[0]);
LABEL_29:
  if (SHIBYTE(v26) < 0)
    operator delete(v25[0]);
  return v20;
}

void sub_1A34FE308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(exception_object);
}

uint64_t _GLOBAL__sub_I_DIAGUtil_cpp()
{
  uint64_t result;

  result = ETLDIAGLoggingGetDefaultView();
  kETLDIAGLoggingDefaultView = result;
  return result;
}

_QWORD *abm::LogCompressionTask::LogCompressionTask(_QWORD *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  v5 = (std::__shared_weak_count *)a3[1];
  v18 = *a3;
  v19 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a4[1];
  v16 = *a4;
  v17 = v8;
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  abm::HelperTask::HelperTask((uint64_t)a1, a2, &v18, &v16);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  *a1 = off_1E4A0B9F8;
  a1[17] = 0;
  v14 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  a1[18] = dispatch_queue_create("log.compression.task.queue", v14);
  return a1;
}

void sub_1A34FE474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void abm::LogCompressionTask::~LogCompressionTask(abm::LogCompressionTask *this)
{
  void *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;

  *(_QWORD *)this = off_1E4A0B9F8;
  v2 = (void *)*((_QWORD *)this + 17);
  if (v2)
  {
    operator delete[](v2);
    *((_QWORD *)this + 17) = 0;
  }
  v3 = *((_QWORD *)this + 18);
  if (v3)
    dispatch_release(v3);
  *(_QWORD *)this = off_1E4A0F3B8;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  v5 = *((_QWORD *)this + 14);
  if (v5)
    dispatch_release(v5);
  *(_QWORD *)this = &unk_1E4A06FA8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v6 = *((_QWORD *)this + 12);
  if (v6)
    dispatch_release(v6);
  v7 = *((_QWORD *)this + 11);
  if (v7)
    dispatch_release(v7);
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
}

{
  void *v1;

  abm::LogCompressionTask::~LogCompressionTask(this);
  operator delete(v1);
}

_QWORD *abm::LogCompressionTask::getName(abm::LogCompressionTask *this)
{
  unsigned __int8 v1;
  unsigned int v4;
  char *v5;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_16);
  if ((v1 & 1) != 0 || !__cxa_guard_acquire(&_MergedGlobals_16))
    return qword_1ED114BB0;
  v4 = *((_DWORD *)this + 26) - 1;
  if (v4 > 9)
    v5 = "invalid";
  else
    v5 = off_1E4A0BB40[v4];
  std::string::basic_string[abi:ne180100]<0>(qword_1ED114BB0, v5);
  __cxa_atexit(MEMORY[0x1E0DE44D0], qword_1ED114BB0, &dword_1A343C000);
  __cxa_guard_release(&_MergedGlobals_16);
  return qword_1ED114BB0;
}

void sub_1A34FE60C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&_MergedGlobals_16);
  _Unwind_Resume(a1);
}

void abm::LogCompressionTask::init_sync(abm::LogCompressionTask *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unsigned __int8 v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  _QWORD *v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t v26;
  void *v27;
  NSObject *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD aBlock[6];
  std::__shared_weak_count *v32;
  _QWORD v33[2];
  char v34[32];
  uint64_t v35;
  std::__shared_weak_count *v36;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v2)
    goto LABEL_38;
  v3 = *((_QWORD *)this + 9);
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    goto LABEL_38;
  v5 = v4;
  v6 = atomic_load((unsigned __int8 *)&qword_1ED114B98);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED114B98))
  {
    __cxa_atexit((void (*)(void *))std::weak_ptr<abm::HelperTask>::~weak_ptr, &qword_1ED114BA0, &dword_1A343C000);
    __cxa_guard_release(&qword_1ED114B98);
  }
  p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
  do
    v8 = __ldxr(p_shared_weak_owners);
  while (__stxr(v8 + 1, p_shared_weak_owners));
  v9 = (std::__shared_weak_count *)qword_1ED114BA8;
  qword_1ED114BA0 = v3;
  qword_1ED114BA8 = (uint64_t)v5;
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v12 || (v13 = *((_QWORD *)this + 9), (v14 = std::__shared_weak_count::lock(v12)) == 0))
LABEL_38:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v15 = v14;
  v16 = (unint64_t *)&v14->__shared_weak_owners_;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  v18 = (unint64_t *)&v14->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v15);
  }
  v20 = *((_QWORD *)this + 18);
  v21 = operator new(8uLL);
  *v21 = this;
  dispatch_async_f(v20, v21, (dispatch_function_t)dispatch::async<abm::LogCompressionTask::init_sync(void)::$_0>(dispatch_queue_s *,std::unique_ptr<abm::LogCompressionTask::init_sync(void)::$_0,std::default_delete<abm::LogCompressionTask::init_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  v22 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v22)
  {
    v23 = std::__shared_weak_count::lock(v22);
    v36 = v23;
    if (v23)
    {
      v24 = v23;
      v25 = *((_QWORD *)this + 15);
      v35 = v25;
      if (v25)
      {
        v34[23] = 20;
        strcpy(v34, "CommandCreateArchive");
        aBlock[0] = MEMORY[0x1E0C809B0];
        aBlock[1] = 1174405120;
        aBlock[2] = ___ZN3abm18LogCompressionTask9init_syncEv_block_invoke;
        aBlock[3] = &__block_descriptor_tmp_17;
        aBlock[4] = this;
        aBlock[5] = v13;
        v32 = v15;
        do
          v26 = __ldxr(v16);
        while (__stxr(v26 + 1, v16));
        v27 = _Block_copy(aBlock);
        v28 = *((_QWORD *)this + 11);
        if (v28)
          dispatch_retain(v28);
        v33[0] = v27;
        v33[1] = v28;
        abm::HelperServerInternal::setCommandHandler(v25, (uint64_t)v34, (uint64_t)v33);
        if (v28)
          dispatch_release(v28);
        if (v27)
          _Block_release(v27);
        if (v32)
          std::__shared_weak_count::__release_weak(v32);
      }
      v29 = (unint64_t *)&v24->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  std::__shared_weak_count::__release_weak(v15);
}

void sub_1A34FE8B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  std::__shared_weak_count *v17;
  uint64_t v18;

  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a17);
  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v18 - 64);
  std::__shared_weak_count::__release_weak(v17);
  _Unwind_Resume(a1);
}

void ___ZN3abm18LogCompressionTask9init_syncEv_block_invoke(_QWORD *a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  NSObject **v5;
  std::__shared_weak_count *v6;
  NSObject *v9;
  xpc_object_t v10;
  void *v11;
  ctu::XpcJetsamAssertion *v12;
  uint64_t v13;
  __int128 v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  xpc_object_t v33;
  NSObject *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  void *v38;
  NSObject *v39;
  _QWORD *v40;
  _QWORD *v41;
  unint64_t *v42;
  unint64_t v43;
  xpc_object_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  NSObject *queue;
  __int128 block;
  void (*v50)(uint64_t);
  void *v51;
  void *aBlock;
  xpc_object_t object;
  xpc_object_t v54;
  void *v55;
  NSObject *v56;
  void *__p[2];
  char v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;

  v5 = (NSObject **)a1[4];
  v63 = 0;
  v64 = 0;
  v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    v64 = std::__shared_weak_count::lock(v6);
    if (!v64)
      return;
    v63 = a1[5];
    if (v63)
    {
      if (*(_QWORD *)a4 && *(_QWORD *)(a4 + 8))
      {
        v9 = v5[14];
        if (v9)
        {
          dispatch_retain(v5[14]);
          dispatch_group_enter(v9);
        }
        if (MEMORY[0x1A85902BC](*a3) == MEMORY[0x1E0C812F8])
        {
          v61 = 0xAAAAAAAAAAAAAAAALL;
          v62 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
          v12 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
          v13 = xmmword_1ED1146C0;
          if (!(_QWORD)xmmword_1ED1146C0)
          {
            ctu::XpcJetsamAssertion::create_default_global(v12);
            v14 = block;
            block = 0uLL;
            v15 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1146C0 + 1);
            xmmword_1ED1146C0 = v14;
            if (v15)
            {
              p_shared_owners = (unint64_t *)&v15->__shared_owners_;
              do
                v17 = __ldaxr(p_shared_owners);
              while (__stlxr(v17 - 1, p_shared_owners));
              if (!v17)
              {
                ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
                std::__shared_weak_count::__release_weak(v15);
              }
            }
            if (*((_QWORD *)&block + 1))
            {
              v18 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
              do
                v19 = __ldaxr(v18);
              while (__stlxr(v19 - 1, v18));
              if (!v19)
              {
                (*(void (**)(_QWORD))(**((_QWORD **)&block + 1) + 16))(*((_QWORD *)&block + 1));
                std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&block + 1));
              }
            }
            v13 = xmmword_1ED1146C0;
          }
          v20 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_1ED1146C0 + 1);
          v59 = v13;
          v60 = *((_QWORD *)&xmmword_1ED1146C0 + 1);
          if (*((_QWORD *)&xmmword_1ED1146C0 + 1))
          {
            v21 = (unint64_t *)(*((_QWORD *)&xmmword_1ED1146C0 + 1) + 8);
            do
              v22 = __ldxr(v21);
            while (__stxr(v22 + 1, v21));
          }
          pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
          v58 = 14;
          strcpy((char *)__p, "Archiving Logs");
          ctu::XpcJetsamAssertion::createActivity();
          if (v20)
          {
            v23 = (unint64_t *)&v20->__shared_owners_;
            do
              v24 = __ldaxr(v23);
            while (__stlxr(v24 - 1, v23));
            if (!v24)
            {
              ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
              std::__shared_weak_count::__release_weak(v20);
            }
          }
          v25 = a1[5];
          v26 = a1[6];
          *(_QWORD *)&block = v25;
          *((_QWORD *)&block + 1) = v26;
          if (v26)
          {
            v27 = (unint64_t *)(v26 + 16);
            do
              v28 = __ldxr(v27);
            while (__stxr(v28 + 1, v27));
          }
          v50 = (void (*)(uint64_t))v9;
          if (v9)
          {
            dispatch_retain(v9);
            dispatch_group_enter(v9);
          }
          v29 = v61;
          v30 = v62;
          v51 = (void *)v61;
          aBlock = v62;
          v31 = (unint64_t *)&v62->__shared_owners_;
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
          v33 = (xpc_object_t)*a3;
          object = v5;
          v54 = v33;
          if (v33)
          {
            xpc_retain(v33);
          }
          else
          {
            v33 = xpc_null_create();
            v54 = v33;
          }
          if (*(_QWORD *)a4)
            v38 = _Block_copy(*(const void **)a4);
          else
            v38 = 0;
          v39 = *(NSObject **)(a4 + 8);
          v55 = v38;
          v56 = v39;
          if (v39)
            dispatch_retain(v39);
          queue = v5[18];
          v40 = operator new(0x48uLL);
          v41 = v40;
          *v40 = v25;
          v40[1] = v26;
          if (v26)
          {
            v42 = (unint64_t *)(v26 + 16);
            do
              v43 = __ldxr(v42);
            while (__stxr(v43 + 1, v42));
          }
          v50 = 0;
          v40[2] = v9;
          v40[3] = v29;
          v51 = 0;
          aBlock = 0;
          v40[4] = v30;
          v40[5] = v5;
          v40[6] = v33;
          v44 = xpc_null_create();
          v41[7] = v38;
          v41[8] = v39;
          v55 = 0;
          v56 = 0;
          v54 = v44;
          dispatch_async_f(queue, v41, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm18LogCompressionTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
          _ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev((uint64_t)&block);
          v45 = v62;
          if (v62)
          {
            v46 = (unint64_t *)&v62->__shared_owners_;
            do
              v47 = __ldaxr(v46);
            while (__stlxr(v47 - 1, v46));
            if (!v47)
            {
              ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
              std::__shared_weak_count::__release_weak(v45);
            }
          }
          goto LABEL_51;
        }
        v10 = xpc_null_create();
        if (*(_QWORD *)a4)
          v11 = _Block_copy(*(const void **)a4);
        else
          v11 = 0;
        v34 = *(NSObject **)(a4 + 8);
        *(_QWORD *)&block = MEMORY[0x1E0C809B0];
        *((_QWORD *)&block + 1) = 1174405120;
        v50 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__2ES2_EEEvDpT__block_invoke_0;
        v51 = &__block_descriptor_tmp_26_0;
        if (v11)
        {
          LODWORD(v54) = -534716414;
          aBlock = _Block_copy(v11);
          object = v10;
          if (v10)
          {
LABEL_43:
            xpc_retain(v10);
LABEL_46:
            dispatch_async(v34, &block);
            xpc_release(object);
            object = 0;
            if (aBlock)
              _Block_release(aBlock);
            if (v11)
              _Block_release(v11);
            xpc_release(v10);
LABEL_51:
            if (v9)
            {
              dispatch_group_leave(v9);
              dispatch_release(v9);
            }
            goto LABEL_53;
          }
        }
        else
        {
          LODWORD(v54) = -534716414;
          aBlock = 0;
          object = v10;
          if (v10)
            goto LABEL_43;
        }
        object = xpc_null_create();
        goto LABEL_46;
      }
    }
  }
LABEL_53:
  v35 = v64;
  if (v64)
  {
    v36 = (unint64_t *)&v64->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
}

void sub_1A34FED68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  NSObject *v27;
  uint64_t v28;

  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  if (v27)
  {
    dispatch_group_leave(v27);
    dispatch_release(v27);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v28 - 104);
  _Unwind_Resume(a1);
}

uint64_t _ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev(uint64_t a1)
{
  NSObject *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  NSObject *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;

  v2 = *(NSObject **)(a1 + 64);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 56);
  if (v3)
    _Block_release(v3);
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v7 = *(NSObject **)(a1 + 16);
  if (v7)
  {
    dispatch_group_leave(v7);
    v8 = *(NSObject **)(a1 + 16);
    if (v8)
      dispatch_release(v8);
  }
  v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  return a1;
}

uint64_t std::weak_ptr<abm::HelperTask>::~weak_ptr(uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void abm::LogCompressionTask::initWorkspace_sync(abm::LogCompressionTask *this)
{
  NSObject *v2;
  char *v3;
  size_t v4;
  const void *v5;
  const void **v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  size_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  std::locale v19[6];
  std::__shared_weak_count *v20;
  void *__p[2];
  unint64_t v22;
  const void *__dst[2];
  unint64_t v24;
  uint8_t buf[4];
  char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEBUG, "#D Initialization of Workspace", buf, 2u);
  }
  strlen(abm::trace::kSnapshotFolder[0]);
  ctu::fs::create_directory();
  v3 = abm::trace::kPendingCompressionFolder;
  v4 = strlen(abm::trace::kPendingCompressionFolder);
  if (v4 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = (const void *)v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = (const void **)operator new(v7 + 1);
    __dst[1] = v5;
    v24 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_10;
  }
  HIBYTE(v24) = v4;
  v6 = __dst;
  if (v4)
LABEL_10:
    memmove(v6, v3, (size_t)v5);
  *((_BYTE *)v5 + (_QWORD)v6) = 0;
  v9 = abm::trace::kSnapshotFolder[0];
  v10 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v10 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v11 = (void *)v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    v12 = operator new(v13 + 1);
    __p[1] = v11;
    v22 = v14 | 0x8000000000000000;
    __p[0] = v12;
  }
  else
  {
    HIBYTE(v22) = v10;
    v12 = __p;
    if (!v10)
      goto LABEL_19;
  }
  memmove(v12, v9, (size_t)v11);
LABEL_19:
  *((_BYTE *)v11 + (_QWORD)v12) = 0;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)v19, "[^\\.].*", 0);
  util::moveDirContent(__dst, (uint64_t)__p, 1u, 1, (uint64_t)v19);
  v15 = v20;
  if (!v20)
    goto LABEL_23;
  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (v17)
  {
LABEL_23:
    std::locale::~locale(v19);
    if ((SHIBYTE(v22) & 0x80000000) == 0)
      goto LABEL_24;
LABEL_29:
    operator delete(__p[0]);
    if ((SHIBYTE(v24) & 0x80000000) == 0)
      goto LABEL_25;
    goto LABEL_30;
  }
  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
  std::__shared_weak_count::__release_weak(v15);
  std::locale::~locale(v19);
  if (SHIBYTE(v22) < 0)
    goto LABEL_29;
LABEL_24:
  if ((SHIBYTE(v24) & 0x80000000) == 0)
    goto LABEL_25;
LABEL_30:
  operator delete((void *)__dst[0]);
LABEL_25:
  strlen(abm::trace::kPendingCompressionFolder);
  ctu::fs::create_directory();
  v18 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    v26 = abm::trace::kPendingCompressionFolder;
    v27 = 2080;
    v28 = abm::trace::kSnapshotFolder[0];
    _os_log_debug_impl(&dword_1A343C000, v18, OS_LOG_TYPE_DEBUG, "#D Moved %s/*/* -> %s/", buf, 0x16u);
  }
}

void sub_1A34FF1F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex((std::locale *)&a9);
  if (a22 < 0)
    operator delete(__p);
  if (a28 < 0)
  {
    operator delete(a23);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t abm::LogCompressionTask::archive_sync(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t value;
  uint64_t IsInternalBuild;
  unsigned int v6;
  xpc_object_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  xpc_object_t v11;
  uint64_t v12;
  char *v13;
  size_t v14;
  std::string::size_type v15;
  std::string *p_dst;
  uint64_t v17;
  uint64_t v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  __int128 v24;
  xpc_object_t v25;
  xpc_object_t v26;
  char **v27;
  const std::string::value_type *v28;
  size_t v29;
  std::string *v30;
  char v31;
  std::string::size_type v32;
  std::string::size_type size;
  std::string *v34;
  std::string::size_type v35;
  std::string::size_type v36;
  size_t v37;
  std::string *p_buf;
  uint64_t *v39;
  size_t v40;
  uint64_t v41;
  std::string *v42;
  _BYTE *v43;
  std::string *v44;
  std::string *v45;
  int v46;
  int v47;
  char *v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  int v53;
  std::string *v54;
  int v55;
  int v56;
  unint64_t v57;
  char *v58;
  unint64_t v59;
  char *v60;
  char *v61;
  int v62;
  std::string *v63;
  std::string::size_type v64;
  std::string::size_type v65;
  std::string::size_type v66;
  uint64_t v67;
  __int128 v68;
  NSObject *v69;
  os_signpost_id_t v70;
  NSObject *v71;
  void **v72;
  _QWORD *v73;
  std::string *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;
  unint64_t *p_shared_owners;
  unint64_t v78;
  uint64_t v79;
  int v80;
  size_t v81;
  int v82;
  size_t v83;
  unint64_t v84;
  char *v85;
  const void *v86;
  char *v87;
  std::string *v88;
  int v89;
  size_t v90;
  int v91;
  size_t v92;
  unint64_t v93;
  char *v94;
  const void *v95;
  char *v96;
  std::string *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  _BYTE *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v105;
  uint64_t v106;
  int v107;
  unsigned int v108;
  void *__p[3];
  std::string v110;
  std::string v111;
  std::string v112;
  void *v113[3];
  std::string v114;
  std::string v115;
  std::string v116;
  void *v117;
  size_t v118;
  uint64_t v119;
  std::locale v120;
  std::__shared_weak_count *v121;
  std::string v122;
  std::string v123;
  std::string v124;
  void *v125[3];
  std::string v126;
  std::string __dst;
  std::string object;
  void *v129[3];
  _BYTE v130[32];
  __int128 v131;
  uint64_t v132;
  size_t v133;
  std::string buf;
  std::string *v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  value = xpc_dictionary_get_value(*a2, "Mode");
  *(_QWORD *)v130 = value;
  if (value)
    xpc_retain(value);
  else
    *(_QWORD *)v130 = xpc_null_create();
  IsInternalBuild = TelephonyUtilIsInternalBuild();
  if ((IsInternalBuild & 1) != 0 || (IsInternalBuild = TelephonyUtilIsCarrierBuild(), (_DWORD)IsInternalBuild))
    capabilities::trace::getCompressionMode((capabilities::trace *)IsInternalBuild);
  v6 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)v130);
  if (v6)
  {
    v7 = xpc_dictionary_get_value(*a2, "SplitArchive");
    *(_QWORD *)v130 = v7;
    if (v7)
      xpc_retain(v7);
    else
      *(_QWORD *)v130 = xpc_null_create();
    v10 = xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)v130);
    memset(v129, 170, sizeof(v129));
    v11 = xpc_dictionary_get_value(*a2, "TimestampString");
    object.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
    if (v11)
      xpc_retain(v11);
    else
      object.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    Timestamp::Timestamp((Timestamp *)&buf);
    Timestamp::asString(v12, 0, 9, v130);
    xpc::dyn_cast_or_default();
    if ((v130[23] & 0x80000000) != 0)
      operator delete(*(void **)v130);
    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&buf, (_QWORD *)buf.__r_.__value_.__l.__size_);
    xpc_release(object.__r_.__value_.__l.__data_);
    memset(&object, 170, sizeof(object));
    v13 = abm::trace::kPendingCompressionFolder;
    v14 = strlen(abm::trace::kPendingCompressionFolder);
    if (v14 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v15 = v14;
    if (v14 >= 0x17)
    {
      v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17)
        v17 = v14 | 7;
      v18 = v17 + 1;
      p_dst = (std::string *)operator new(v17 + 1);
      __dst.__r_.__value_.__l.__size_ = v15;
      __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v14;
      p_dst = &__dst;
      if (!v14)
      {
LABEL_27:
        p_dst->__r_.__value_.__s.__data_[v15] = 0;
        if (SHIBYTE(v129[2]) >= 0)
          v19 = (const std::string::value_type *)v129;
        else
          v19 = (const std::string::value_type *)v129[0];
        if (SHIBYTE(v129[2]) >= 0)
          v20 = HIBYTE(v129[2]);
        else
          v20 = (std::string::size_type)v129[1];
        v21 = std::string::append(&__dst, v19, v20);
        v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
        buf.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v22;
        v21->__r_.__value_.__l.__size_ = 0;
        v21->__r_.__value_.__r.__words[2] = 0;
        v21->__r_.__value_.__r.__words[0] = 0;
        ctu::fs::get_unique_pathname();
        v23 = std::string::append((std::string *)v130, "/", 1uLL);
        v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        object.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&object.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        if ((v130[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)v130);
          if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_35:
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_36;
LABEL_40:
            operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_36:
            memset(&__dst, 170, sizeof(__dst));
            v25 = xpc_dictionary_get_value(*a2, "ArchiveSource");
            *(_QWORD *)v130 = v25;
            if (v25)
              xpc_retain(v25);
            else
              *(_QWORD *)v130 = xpc_null_create();
            xpc::dyn_cast_or_default();
            xpc_release(*(xpc_object_t *)v130);
            memset(&v126, 170, sizeof(v126));
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&v126, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            else
              v126 = __dst;
            memset(v125, 170, sizeof(v125));
            v26 = xpc_dictionary_get_value(*a2, "ArchiveDestFileName");
            *(_QWORD *)v130 = v26;
            if (v26)
              xpc_retain(v26);
            else
              *(_QWORD *)v130 = xpc_null_create();
            xpc::dyn_cast_or_default();
            xpc_release(*(xpc_object_t *)v130);
            v130[23] = 1;
            strcpy(v130, ".");
            v27 = abm::trace::kLogTarExtension;
            if (v6 == 1)
              v27 = &abm::trace::kLogTarGzExtension;
            v28 = *v27;
            v29 = strlen(*v27);
            v30 = std::string::append((std::string *)v130, v28, v29);
            v124 = *v30;
            v30->__r_.__value_.__l.__size_ = 0;
            v30->__r_.__value_.__r.__words[2] = 0;
            v30->__r_.__value_.__r.__words[0] = 0;
            if ((v130[23] & 0x80000000) != 0)
              operator delete(*(void **)v130);
            v107 = v10;
            v108 = v6;
            v132 = 47;
            v133 = 1;
            v130[0] = -86;
            std::__sort<std::__less<char,char> &,char *>();
            v31 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
            size = v126.__r_.__value_.__l.__size_;
            v32 = v126.__r_.__value_.__r.__words[0];
            if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v34 = &v126;
            else
              v34 = (std::string *)v126.__r_.__value_.__r.__words[0];
            v35 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
            if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v36 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
            else
              v36 = v126.__r_.__value_.__l.__size_;
            v37 = v133;
            buf.__r_.__value_.__r.__words[2] = v133;
            buf.__r_.__value_.__r.__words[0] = 0;
            if (v133 >= 0x11)
            {
              p_buf = (std::string *)operator new[](v133);
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
              v39 = (uint64_t *)v132;
            }
            else
            {
              p_buf = &buf;
              v39 = &v132;
            }
            memcpy(p_buf, v39, v37);
            v40 = buf.__r_.__value_.__r.__words[2];
            *(_QWORD *)&v130[16] = *((_QWORD *)&buf.__r_.__value_.__l + 2);
            *(_QWORD *)v130 = 0;
            if (buf.__r_.__value_.__r.__words[2] >= 0x11)
            {
              v43 = operator new[](buf.__r_.__value_.__r.__words[2]);
              v41 = a1;
              *(_QWORD *)v130 = v43;
              v42 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            else
            {
              v41 = a1;
              v42 = &buf;
              v43 = v130;
            }
            v44 = (std::string *)((char *)v34 + v36);
            memcpy(v43, v42, v40);
            if (*(_QWORD *)&v130[16] >= 0x11uLL)
            {
              v54 = (std::string *)((char *)v34 + v36);
              while (v54 != v34)
              {
                v44 = v54;
                v56 = SHIBYTE(v54[-1].__r_.__value_.__r.__words[2]);
                v54 = (std::string *)((char *)v54 - 1);
                v55 = v56;
                v57 = *(_QWORD *)&v130[16];
                v58 = *(char **)v130;
                do
                {
                  v59 = v57 >> 1;
                  v60 = &v58[v57 >> 1];
                  v62 = *v60;
                  v61 = v60 + 1;
                  v57 += ~(v57 >> 1);
                  if (v62 >= v55)
                    v57 = v59;
                  else
                    v58 = v61;
                }
                while (v57);
                if (v58 == (char *)(*(_QWORD *)v130 + *(_QWORD *)&v130[16]) || *v58 > v55)
                  goto LABEL_89;
              }
              v44 = v34;
            }
            else
            {
              if (*(_QWORD *)&v130[16])
              {
                v45 = (std::string *)((char *)v34 + v36);
                while (v45 != v34)
                {
                  v44 = v45;
                  v47 = SHIBYTE(v45[-1].__r_.__value_.__r.__words[2]);
                  v45 = (std::string *)((char *)v45 - 1);
                  v46 = v47;
                  v48 = v130;
                  v49 = *(_QWORD *)&v130[16];
                  do
                  {
                    v50 = v49 >> 1;
                    v51 = &v48[v49 >> 1];
                    v53 = *v51;
                    v52 = v51 + 1;
                    v49 += ~(v49 >> 1);
                    if (v53 >= v46)
                      v49 = v50;
                    else
                      v48 = v52;
                  }
                  while (v49);
                  if (v48 == &v130[*(_QWORD *)&v130[16]] || *v48 > v46)
                    goto LABEL_89;
                }
                v44 = v34;
LABEL_92:
                v63 = &v126;
                if (v31 >= 0)
                {
                  v64 = v35;
                }
                else
                {
                  v63 = (std::string *)v32;
                  v64 = size;
                }
                v65 = (char *)v44 - (char *)v63;
                if (v64 < (char *)v44 - (char *)v63)
                  std::string::__throw_out_of_range[abi:ne180100]();
                v66 = (char *)v63 + v64 - (char *)v44;
                if (v66 == -1)
                {
                  v67 = v41;
                  if (v31 < 0)
                  {
                    v126.__r_.__value_.__l.__size_ = v65;
                    *(_BYTE *)(v32 + v65) = 0;
                    if (v40 < 0x11)
                      goto LABEL_103;
LABEL_101:
                    if (buf.__r_.__value_.__r.__words[0])
                      operator delete[](buf.__r_.__value_.__l.__data_);
LABEL_103:
                    if (v133 >= 0x11 && v132)
                      operator delete[]((void *)v132);
                    std::string::append(&v126, "-lite", 5uLL);
                    *(_QWORD *)&v68 = 0xAAAAAAAAAAAAAAAALL;
                    *((_QWORD *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
                    *(_OWORD *)&v130[16] = v68;
                    v131 = v68;
                    *(_OWORD *)v130 = v68;
                    v69 = *(NSObject **)(v67 + 40);
                    v70 = os_signpost_id_generate(v69);
                    if (v70 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
                    {
                      v71 = *(NSObject **)(v67 + 40);
                      if (os_signpost_enabled(v71))
                      {
                        v72 = v129;
                        if (SHIBYTE(v129[2]) < 0)
                          v72 = (void **)v129[0];
                        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v72;
                        _os_signpost_emit_with_name_impl(&dword_1A343C000, v71, OS_SIGNPOST_INTERVAL_BEGIN, v70, "ArchivingLogs", "RequestTime=%{signpost.description:attribute}s", (uint8_t *)&buf, 0xCu);
                      }
                    }
                    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1E4A0BAD0;
                    v135 = &buf;
                    *(_QWORD *)v130 = v70;
                    *(_QWORD *)&v130[8] = os_retain(v69);
                    v73 = &v130[16];
                    if (v135)
                    {
                      if (v135 == &buf)
                      {
                        *((_QWORD *)&v131 + 1) = &v130[16];
                        (*(void (**)(uint64_t, _QWORD *))(buf.__r_.__value_.__r.__words[0] + 24))((uint64_t)&buf, &v130[16]);
                      }
                      else
                      {
                        *((_QWORD *)&v131 + 1) = v135;
                        v135 = 0;
                      }
                    }
                    else
                    {
                      *((_QWORD *)&v131 + 1) = 0;
                    }
                    v74 = v135;
                    if (v135 == &buf)
                    {
                      v75 = 4;
                      v74 = &buf;
                    }
                    else
                    {
                      if (!v135)
                        goto LABEL_121;
                      v75 = 5;
                    }
                    (*(void (**)(void))(v74->__r_.__value_.__r.__words[0] + 8 * v75))();
LABEL_121:
                    if (!v107)
                      goto LABEL_167;
                    ctu::fs::create_directory();
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      std::string::__init_copy_ctor_external(&v123, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                    else
                      v123 = __dst;
                    if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                      std::string::__init_copy_ctor_external(&v122, v126.__r_.__value_.__l.__data_, v126.__r_.__value_.__l.__size_);
                    else
                      v122 = v126;
                    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v120, ".*-live$", 0);
                    util::moveDirContent((const void **)&v123.__r_.__value_.__l.__data_, (uint64_t)&v122, 0, 0, (uint64_t)&v120);
                    v76 = v121;
                    if (!v121)
                      goto LABEL_132;
                    p_shared_owners = (unint64_t *)&v121->__shared_owners_;
                    do
                      v78 = __ldaxr(p_shared_owners);
                    while (__stlxr(v78 - 1, p_shared_owners));
                    if (!v78)
                    {
                      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
                      std::__shared_weak_count::__release_weak(v76);
                      std::locale::~locale(&v120);
                      if ((SHIBYTE(v122.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      {
LABEL_133:
                        if ((SHIBYTE(v123.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                          goto LABEL_134;
LABEL_252:
                        operator delete(v123.__r_.__value_.__l.__data_);
LABEL_134:
                        memset(&buf, 0, sizeof(buf));
                        v117 = 0;
                        v118 = 0;
                        v119 = 0;
                        abm::resolveProcessingDirAndArchiveFileName(1, (const void **)&object.__r_.__value_.__l.__data_, (__int128 *)v125, (uint64_t)v129, (uint64_t)&buf, (uint64_t)&v117);
                        if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                          std::string::__init_copy_ctor_external(&v116, v126.__r_.__value_.__l.__data_, v126.__r_.__value_.__l.__size_);
                        else
                          v116 = v126;
                        if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0)
                          std::string::__init_copy_ctor_external(&v115, object.__r_.__value_.__l.__data_, object.__r_.__value_.__l.__size_);
                        else
                          v115 = object;
                        v79 = v67;
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                          std::string::__init_copy_ctor_external(&v114, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                        else
                          v114 = buf;
                        v80 = SHIBYTE(v119);
                        if (v119 >= 0)
                          v81 = HIBYTE(v119);
                        else
                          v81 = v118;
                        v82 = SHIBYTE(v124.__r_.__value_.__r.__words[2]);
                        if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                          v83 = HIBYTE(v124.__r_.__value_.__r.__words[2]);
                        else
                          v83 = v124.__r_.__value_.__l.__size_;
                        v84 = v83 + v81;
                        memset(v113, 170, sizeof(v113));
                        if (v83 + v81 > 0x7FFFFFFFFFFFFFF7)
                          std::string::__throw_length_error[abi:ne180100]();
                        if (v84 > 0x16)
                        {
                          v105 = (v84 & 0xFFFFFFFFFFFFFFF8) + 8;
                          if ((v84 | 7) != 0x17)
                            v105 = v84 | 7;
                          v106 = v105 + 1;
                          v85 = (char *)operator new(v105 + 1);
                          v113[1] = (void *)(v83 + v81);
                          v113[2] = (void *)(v106 | 0x8000000000000000);
                          v113[0] = v85;
                          if (!v81)
                          {
LABEL_156:
                            v87 = &v85[v81];
                            if (v83)
                            {
                              if (v82 >= 0)
                                v88 = &v124;
                              else
                                v88 = (std::string *)v124.__r_.__value_.__r.__words[0];
                              memmove(v87, v88, v83);
                            }
                            v87[v83] = 0;
                            v67 = v79;
                            abm::LogCompressionTask::archiveHelper_sync(v79, 1, (uint64_t)&v116, (const void **)&v115.__r_.__value_.__l.__data_, (uint64_t)&v114, (const void **)v113, v108);
                            if (SHIBYTE(v113[2]) < 0)
                            {
                              operator delete(v113[0]);
                              if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                              {
LABEL_163:
                                if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  goto LABEL_164;
                                goto LABEL_244;
                              }
                            }
                            else if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
                              goto LABEL_163;
                            }
                            operator delete(v114.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_164:
                              if ((SHIBYTE(v116.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                goto LABEL_165;
                              goto LABEL_245;
                            }
LABEL_244:
                            operator delete(v115.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v116.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_165:
                              if ((SHIBYTE(v119) & 0x80000000) == 0)
                                goto LABEL_166;
                              goto LABEL_246;
                            }
LABEL_245:
                            operator delete(v116.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v119) & 0x80000000) == 0)
                            {
LABEL_166:
                              if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                goto LABEL_167;
LABEL_247:
                              operator delete(buf.__r_.__value_.__l.__data_);
LABEL_167:
                              memset(&buf, 0, sizeof(buf));
                              v117 = 0;
                              v118 = 0;
                              v119 = 0;
                              abm::resolveProcessingDirAndArchiveFileName(0, (const void **)&object.__r_.__value_.__l.__data_, (__int128 *)v125, (uint64_t)v129, (uint64_t)&buf, (uint64_t)&v117);
                              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                                std::string::__init_copy_ctor_external(&v112, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                              else
                                v112 = __dst;
                              if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0)
                                std::string::__init_copy_ctor_external(&v111, object.__r_.__value_.__l.__data_, object.__r_.__value_.__l.__size_);
                              else
                                v111 = object;
                              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                                std::string::__init_copy_ctor_external(&v110, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                              else
                                v110 = buf;
                              v89 = SHIBYTE(v119);
                              if (v119 >= 0)
                                v90 = HIBYTE(v119);
                              else
                                v90 = v118;
                              v91 = SHIBYTE(v124.__r_.__value_.__r.__words[2]);
                              if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                v92 = HIBYTE(v124.__r_.__value_.__r.__words[2]);
                              else
                                v92 = v124.__r_.__value_.__l.__size_;
                              v93 = v92 + v90;
                              memset(__p, 170, sizeof(__p));
                              if (v92 + v90 > 0x7FFFFFFFFFFFFFF7)
                                std::string::__throw_length_error[abi:ne180100]();
                              if (v93 > 0x16)
                              {
                                v99 = (v93 & 0xFFFFFFFFFFFFFFF8) + 8;
                                if ((v93 | 7) != 0x17)
                                  v99 = v93 | 7;
                                v100 = v99 + 1;
                                v94 = (char *)operator new(v99 + 1);
                                __p[1] = (void *)(v92 + v90);
                                __p[2] = (void *)(v100 | 0x8000000000000000);
                                __p[0] = v94;
                                if (!v90)
                                {
LABEL_189:
                                  v96 = &v94[v90];
                                  if (v92)
                                  {
                                    if (v91 >= 0)
                                      v97 = &v124;
                                    else
                                      v97 = (std::string *)v124.__r_.__value_.__r.__words[0];
                                    memmove(v96, v97, v92);
                                  }
                                  v96[v92] = 0;
                                  v9 = abm::LogCompressionTask::archiveHelper_sync(v67, 0, (uint64_t)&v112, (const void **)&v111.__r_.__value_.__l.__data_, (uint64_t)&v110, (const void **)__p, v108);
                                  if (SHIBYTE(__p[2]) < 0)
                                  {
                                    operator delete(__p[0]);
                                    if ((SHIBYTE(v110.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                    {
LABEL_196:
                                      if ((SHIBYTE(v111.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                        goto LABEL_197;
                                      goto LABEL_208;
                                    }
                                  }
                                  else if ((SHIBYTE(v110.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
                                    goto LABEL_196;
                                  }
                                  operator delete(v110.__r_.__value_.__l.__data_);
                                  if ((SHIBYTE(v111.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
LABEL_197:
                                    if ((SHIBYTE(v112.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                      goto LABEL_198;
                                    goto LABEL_209;
                                  }
LABEL_208:
                                  operator delete(v111.__r_.__value_.__l.__data_);
                                  if ((SHIBYTE(v112.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
LABEL_198:
                                    if ((SHIBYTE(v119) & 0x80000000) == 0)
                                      goto LABEL_199;
                                    goto LABEL_210;
                                  }
LABEL_209:
                                  operator delete(v112.__r_.__value_.__l.__data_);
                                  if ((SHIBYTE(v119) & 0x80000000) == 0)
                                  {
LABEL_199:
                                    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                      goto LABEL_200;
                                    goto LABEL_211;
                                  }
LABEL_210:
                                  operator delete(v117);
                                  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
LABEL_200:
                                    v98 = *((_QWORD *)&v131 + 1);
                                    if (!*((_QWORD *)&v131 + 1))
                                      goto LABEL_214;
                                    goto LABEL_212;
                                  }
LABEL_211:
                                  operator delete(buf.__r_.__value_.__l.__data_);
                                  v98 = *((_QWORD *)&v131 + 1);
                                  if (!*((_QWORD *)&v131 + 1))
                                    goto LABEL_214;
LABEL_212:
                                  if (*(_QWORD *)v130)
                                  {
                                    buf.__r_.__value_.__r.__words[0] = *(_QWORD *)&v130[8];
                                    v117 = *(void **)v130;
                                    (*(void (**)(uint64_t, std::string *, void **))(*(_QWORD *)v98 + 48))(v98, &buf, &v117);
                                  }
LABEL_214:
                                  if (*(_QWORD *)&v130[8])
                                    os_release(*(void **)&v130[8]);
                                  v101 = (_BYTE *)*((_QWORD *)&v131 + 1);
                                  *(_QWORD *)&v130[8] = 0;
                                  *((_QWORD *)&v131 + 1) = 0;
                                  if (v101 == &v130[16])
                                  {
                                    v102 = 4;
                                    v101 = &v130[16];
                                  }
                                  else
                                  {
                                    if (!v101)
                                      goto LABEL_225;
                                    v102 = 5;
                                  }
                                  (*(void (**)(void))(*(_QWORD *)v101 + 8 * v102))();
                                  *(_QWORD *)v130 = 0;
                                  if (*((_BYTE **)&v131 + 1) == &v130[16])
                                  {
                                    v103 = 4;
                                  }
                                  else
                                  {
                                    if (!*((_QWORD *)&v131 + 1))
                                      goto LABEL_225;
                                    v103 = 5;
                                    v73 = (_QWORD *)*((_QWORD *)&v131 + 1);
                                  }
                                  (*(void (**)(_QWORD *))(*v73 + 8 * v103))(v73);
LABEL_225:
                                  if (v91 < 0)
                                  {
                                    operator delete(v124.__r_.__value_.__l.__data_);
                                    if ((SHIBYTE(v125[2]) & 0x80000000) == 0)
                                    {
LABEL_227:
                                      if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                        goto LABEL_228;
                                      goto LABEL_234;
                                    }
                                  }
                                  else if ((SHIBYTE(v125[2]) & 0x80000000) == 0)
                                  {
                                    goto LABEL_227;
                                  }
                                  operator delete(v125[0]);
                                  if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
LABEL_228:
                                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                      goto LABEL_229;
                                    goto LABEL_235;
                                  }
LABEL_234:
                                  operator delete(v126.__r_.__value_.__l.__data_);
                                  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
LABEL_229:
                                    if ((SHIBYTE(object.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                      goto LABEL_230;
                                    goto LABEL_236;
                                  }
LABEL_235:
                                  operator delete(__dst.__r_.__value_.__l.__data_);
                                  if ((SHIBYTE(object.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                                  {
LABEL_230:
                                    if ((SHIBYTE(v129[2]) & 0x80000000) == 0)
                                      return v9;
LABEL_237:
                                    operator delete(v129[0]);
                                    return v9;
                                  }
LABEL_236:
                                  operator delete(object.__r_.__value_.__l.__data_);
                                  if ((SHIBYTE(v129[2]) & 0x80000000) == 0)
                                    return v9;
                                  goto LABEL_237;
                                }
                              }
                              else
                              {
                                memset(__p, 0, sizeof(__p));
                                v94 = (char *)__p;
                                HIBYTE(__p[2]) = v92 + v90;
                                if (!v90)
                                  goto LABEL_189;
                              }
                              if (v89 >= 0)
                                v95 = &v117;
                              else
                                v95 = v117;
                              memmove(v94, v95, v90);
                              goto LABEL_189;
                            }
LABEL_246:
                            operator delete(v117);
                            if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                              goto LABEL_167;
                            goto LABEL_247;
                          }
                        }
                        else
                        {
                          memset(v113, 0, sizeof(v113));
                          v85 = (char *)v113;
                          HIBYTE(v113[2]) = v83 + v81;
                          if (!v81)
                            goto LABEL_156;
                        }
                        if (v80 >= 0)
                          v86 = &v117;
                        else
                          v86 = v117;
                        memmove(v85, v86, v81);
                        goto LABEL_156;
                      }
                    }
                    else
                    {
LABEL_132:
                      std::locale::~locale(&v120);
                      if ((SHIBYTE(v122.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                        goto LABEL_133;
                    }
                    operator delete(v122.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v123.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_134;
                    goto LABEL_252;
                  }
                  *((_BYTE *)&v126.__r_.__value_.__s + 23) = v65 & 0x7F;
                  v126.__r_.__value_.__s.__data_[v65] = 0;
                }
                else
                {
                  std::string::__erase_external_with_move(&v126, v65, v66);
                  v67 = v41;
                }
                if (v40 < 0x11)
                  goto LABEL_103;
                goto LABEL_101;
              }
              if (!v36)
              {
                v44 = v34;
                goto LABEL_92;
              }
            }
LABEL_89:
            if (*(_QWORD *)&v130[16] >= 0x11uLL && *(_QWORD *)v130)
            {
              operator delete[](*(void **)v130);
              v35 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
              size = v126.__r_.__value_.__l.__size_;
              v32 = v126.__r_.__value_.__r.__words[0];
              v31 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
            }
            goto LABEL_92;
          }
        }
        else if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_35;
        }
        operator delete(buf.__r_.__value_.__l.__data_);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_36;
        goto LABEL_40;
      }
    }
    memmove(p_dst, v13, v15);
    goto LABEL_27;
  }
  v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v130 = 0;
    _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Skipping archive creation because compression is disabled!", v130, 2u);
  }
  return 0;
}

void sub_1A35001C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,std::locale a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a66;
  char a71;
  void *a72;
  char a73;
  void *a74;
  char a75;
  void *a76;
  char a77;
  xpc_object_t object;
  char a79;
  uint64_t v79;

  if (a36 < 0)
  {
    operator delete(__p);
    if ((a43 & 0x80000000) == 0)
      goto LABEL_6;
  }
  else if ((a43 & 0x80000000) == 0)
  {
LABEL_6:
    if (a49 < 0)
      operator delete(a44);
    if (*(char *)(v79 - 121) < 0)
      operator delete(*(void **)(v79 - 144));
    ctu::os::signpost_interval::~signpost_interval((ctu::os::signpost_interval *)(v79 - 224));
    if (a71 < 0)
      operator delete(a66);
    if (a73 < 0)
      operator delete(a72);
    if (a75 < 0)
      operator delete(a74);
    if (a77 < 0)
      operator delete(a76);
    if (a79 < 0)
      operator delete(object);
    if (*(char *)(v79 - 225) < 0)
    {
      operator delete(*(void **)(v79 - 248));
      _Unwind_Resume(a1);
    }
    _Unwind_Resume(a1);
  }
  operator delete(a38);
  goto LABEL_6;
}

void abm::resolveProcessingDirAndArchiveFileName(int a1, const void **a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  size_t v10;
  int v11;
  __int128 v12;
  char *v14;
  size_t v15;
  std::string::size_type v16;
  std::string *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const std::string::value_type *v21;
  std::string::size_type v22;
  std::string *v23;
  std::string::size_type v24;
  char v25;
  uint64_t v26;
  __int128 *v27;
  int v28;
  size_t v29;
  int v30;
  size_t v31;
  unint64_t v32;
  std::string *p_p;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  const void *v37;
  std::string *v38;
  std::string::size_type v39;
  char v40;
  uint64_t v41;
  char v42;
  __int128 v43;
  void *v44;
  size_t v45;
  std::string __p;
  _QWORD v47[3];

  v47[2] = *MEMORY[0x1E0C80C00];
  v10 = *((unsigned __int8 *)a3 + 23);
  v11 = (char)v10;
  if ((v10 & 0x80u) != 0)
    v10 = *((_QWORD *)a3 + 1);
  if (v10)
  {
    if ((__int128 *)a6 != a3)
    {
      if ((*(char *)(a6 + 23) & 0x80000000) == 0)
      {
        if (v11 < 0)
        {
          std::string::__assign_no_alias<true>((_QWORD *)a6, *(void **)a3, *((_QWORD *)a3 + 1));
          if (a1 != 1)
          {
LABEL_34:
            v28 = *((char *)a2 + 23);
            if (v28 >= 0)
              v29 = *((unsigned __int8 *)a2 + 23);
            else
              v29 = (size_t)a2[1];
            v30 = *(char *)(a6 + 23);
            if (v30 >= 0)
              v31 = *(unsigned __int8 *)(a6 + 23);
            else
              v31 = *(_QWORD *)(a6 + 8);
            v32 = v31 + v29;
            memset(&__p, 170, sizeof(__p));
            if (v31 + v29 > 0x7FFFFFFFFFFFFFF7)
              std::string::__throw_length_error[abi:ne180100]();
            if (v32 > 0x16)
            {
              v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v32 | 7) != 0x17)
                v34 = v32 | 7;
              v35 = v34 + 1;
              p_p = (std::string *)operator new(v34 + 1);
              __p.__r_.__value_.__l.__size_ = v31 + v29;
              __p.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
              if (!v29)
                goto LABEL_51;
            }
            else
            {
              memset(&__p, 0, sizeof(__p));
              p_p = &__p;
              *((_BYTE *)&__p.__r_.__value_.__s + 23) = v31 + v29;
              if (!v29)
              {
LABEL_51:
                if (v31)
                {
                  if (v30 >= 0)
                    v37 = (const void *)a6;
                  else
                    v37 = *(const void **)a6;
                  memmove((char *)p_p + v29, v37, v31);
                }
                p_p->__r_.__value_.__s.__data_[v29 + v31] = 0;
                v38 = std::string::append(&__p, "/", 1uLL);
                v39 = v38->__r_.__value_.__r.__words[0];
                v47[0] = v38->__r_.__value_.__l.__size_;
                *(_QWORD *)((char *)v47 + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
                v40 = HIBYTE(v38->__r_.__value_.__r.__words[2]);
                v38->__r_.__value_.__l.__size_ = 0;
                v38->__r_.__value_.__r.__words[2] = 0;
                v38->__r_.__value_.__r.__words[0] = 0;
                if (*(char *)(a5 + 23) < 0)
                  operator delete(*(void **)a5);
                v41 = v47[0];
                *(_QWORD *)a5 = v39;
                *(_QWORD *)(a5 + 8) = v41;
                *(_QWORD *)(a5 + 15) = *(_QWORD *)((char *)v47 + 7);
                *(_BYTE *)(a5 + 23) = v40;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
                return;
              }
            }
            if (v28 >= 0)
              v36 = a2;
            else
              v36 = *a2;
            memmove(p_p, v36, v29);
            goto LABEL_51;
          }
        }
        else
        {
          v12 = *a3;
          *(_QWORD *)(a6 + 16) = *((_QWORD *)a3 + 2);
          *(_OWORD *)a6 = v12;
          if (a1 != 1)
            goto LABEL_34;
        }
LABEL_33:
        std::string::append((std::string *)a6, "-lite", 5uLL);
        goto LABEL_34;
      }
      if (v11 >= 0)
        v27 = a3;
      else
        v27 = *(__int128 **)a3;
      std::string::__assign_no_alias<false>((void **)a6, v27, v10);
    }
    if (a1 != 1)
      goto LABEL_34;
    goto LABEL_33;
  }
  v14 = abm::trace::kLogDirPrefix[0];
  v15 = strlen(abm::trace::kLogDirPrefix[0]);
  if (v15 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v16 = v15;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    v17 = (std::string *)operator new(v18 + 1);
    __p.__r_.__value_.__l.__size_ = v16;
    __p.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    goto LABEL_16;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v15;
  v17 = &__p;
  if (v15)
LABEL_16:
    memmove(v17, v14, v16);
  v17->__r_.__value_.__s.__data_[v16] = 0;
  v20 = *(char *)(a4 + 23);
  if (v20 >= 0)
    v21 = (const std::string::value_type *)a4;
  else
    v21 = *(const std::string::value_type **)a4;
  if (v20 >= 0)
    v22 = *(unsigned __int8 *)(a4 + 23);
  else
    v22 = *(_QWORD *)(a4 + 8);
  v23 = std::string::append(&__p, v21, v22);
  v24 = v23->__r_.__value_.__r.__words[0];
  v47[0] = v23->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v47 + 7) = *(std::string::size_type *)((char *)&v23->__r_.__value_.__r.__words[1] + 7);
  v25 = HIBYTE(v23->__r_.__value_.__r.__words[2]);
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a6 + 23) < 0)
    operator delete(*(void **)a6);
  v26 = v47[0];
  *(_QWORD *)a6 = v24;
  *(_QWORD *)(a6 + 8) = v26;
  *(_QWORD *)(a6 + 15) = *(_QWORD *)((char *)v47 + 7);
  *(_BYTE *)(a6 + 23) = v25;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (a1 != 1)
      goto LABEL_62;
    goto LABEL_61;
  }
  if (a1 == 1)
LABEL_61:
    std::string::append((std::string *)a6, "-lite", 5uLL);
LABEL_62:
  if ((const void **)a5 != a2)
  {
    v42 = *((_BYTE *)a2 + 23);
    if (*(char *)(a5 + 23) < 0)
    {
      if (v42 >= 0)
        v44 = a2;
      else
        v44 = (void *)*a2;
      if (v42 >= 0)
        v45 = *((unsigned __int8 *)a2 + 23);
      else
        v45 = (size_t)a2[1];
      std::string::__assign_no_alias<false>((void **)a5, v44, v45);
    }
    else if ((*((_BYTE *)a2 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((_QWORD *)a5, (void *)*a2, (size_t)a2[1]);
    }
    else
    {
      v43 = *(_OWORD *)a2;
      *(_QWORD *)(a5 + 16) = a2[2];
      *(_OWORD *)a5 = v43;
    }
  }
}

void sub_1A35009A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::LogCompressionTask::archiveHelper_sync(uint64_t a1, int a2, uint64_t a3, const void **a4, uint64_t a5, const void **a6, unsigned int a7)
{
  int v7;
  size_t v8;
  int v9;
  size_t v10;
  unint64_t v11;
  std::string *p_dst;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  char *v19;
  const void *v20;
  uint64_t v21;
  NSObject *v22;
  const void **v23;
  const std::string::value_type *v24;
  void *v25;
  const std::string::value_type *v26;
  void *v27;
  int v28;
  std::string::size_type v29;
  std::string *v30;
  std::string *p_p;
  std::__shared_weak_count *v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  uint64_t SystemTime;
  char filtered_files;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  NSObject *v40;
  const std::string::value_type *v41;
  const char *v42;
  NSObject *v43;
  uint32_t v44;
  uint64_t Archive_sync;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  void **v49;
  void **v50;
  void *v51;
  uint64_t v52;
  NSObject *v53;
  const char *v54;
  std::string *v55;
  const void *v56;
  _BOOL4 v57;
  std::string *v58;
  char *v59;
  size_t v60;
  std::string::size_type v61;
  std::string *v62;
  void *v63;
  char *v64;
  size_t v65;
  void *v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  unint64_t *v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  const std::string::value_type *v76;
  std::string::size_type v77;
  std::string *v78;
  __int128 v79;
  _BYTE *v80;
  char *v81;
  size_t v82;
  std::string::size_type v83;
  std::string *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  const std::string::value_type *v88;
  std::string::size_type v89;
  std::string *v90;
  __int128 v91;
  int v92;
  NSObject *v93;
  const char *v94;
  void **v95;
  void **v96;
  void **v97;
  std::locale v103;
  std::__shared_weak_count *v104;
  void *v105[2];
  unint64_t v106;
  std::string v107;
  std::string v108;
  void *v109;
  void **v110;
  uint64_t v111;
  std::string v112;
  std::string v113;
  std::locale v114;
  std::__shared_weak_count *v115;
  std::locale v116;
  std::__shared_weak_count *v117;
  std::string v118;
  std::string v119;
  std::string __p;
  void **v121;
  void **v122;
  uint64_t v123;
  std::string __dst;
  uint8_t v125[4];
  std::string *v126;
  __int16 v127;
  _BYTE *v128;
  _BYTE buf[24];
  const void *v130;
  __int16 v131;
  const std::string::value_type *v132;
  __int16 v133;
  const void *v134;
  __int16 v135;
  std::string *v136;
  __int16 v137;
  std::string *v138;
  uint64_t v139;

  v139 = *MEMORY[0x1E0C80C00];
  v7 = *((char *)a4 + 23);
  if (v7 >= 0)
    v8 = *((unsigned __int8 *)a4 + 23);
  else
    v8 = (size_t)a4[1];
  v9 = *((char *)a6 + 23);
  if (v9 >= 0)
    v10 = *((unsigned __int8 *)a6 + 23);
  else
    v10 = (size_t)a6[1];
  v11 = v10 + v8;
  memset(&__dst, 170, sizeof(__dst));
  if (v10 + v8 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v11 <= 0x16)
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v10 + v8;
    if (!v8)
      goto LABEL_18;
    goto LABEL_14;
  }
  v16 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v11 | 7) != 0x17)
    v16 = v11 | 7;
  v17 = v16 + 1;
  p_dst = (std::string *)operator new(v16 + 1);
  __dst.__r_.__value_.__l.__size_ = v10 + v8;
  __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  if (v8)
  {
LABEL_14:
    if (v7 >= 0)
      v18 = a4;
    else
      v18 = *a4;
    memmove(p_dst, v18, v8);
  }
LABEL_18:
  v19 = (char *)p_dst + v8;
  if (v10)
  {
    if (v9 >= 0)
      v20 = a6;
    else
      v20 = *a6;
    memmove(v19, v20, v10);
  }
  v19[v10] = 0;
  v21 = a1;
  v22 = *(NSObject **)(a1 + 40);
  v23 = a4;
  if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    goto LABEL_40;
  if (a2 == 1)
  {
    HIBYTE(v123) = 4;
    strcpy((char *)&v121, "lite");
    v24 = (const std::string::value_type *)a3;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
      goto LABEL_30;
    goto LABEL_29;
  }
  if (!a2)
  {
    HIBYTE(v123) = 4;
    strcpy((char *)&v121, "main");
    v24 = (const std::string::value_type *)a3;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
      goto LABEL_30;
    goto LABEL_29;
  }
  HIBYTE(v123) = 3;
  LODWORD(v121) = 4144959;
  v24 = (const std::string::value_type *)a3;
  if (*(char *)(a3 + 23) < 0)
LABEL_29:
    v24 = *(const std::string::value_type **)a3;
LABEL_30:
  v25 = a4;
  if ((v7 & 0x80000000) == 0)
  {
    v26 = (const std::string::value_type *)a5;
    if ((*(char *)(a5 + 23) & 0x80000000) == 0)
      goto LABEL_32;
LABEL_68:
    v26 = *(const std::string::value_type **)a5;
    v27 = a6;
    if ((v9 & 0x80000000) == 0)
      goto LABEL_33;
LABEL_69:
    v27 = (void *)*a6;
    goto LABEL_33;
  }
  v25 = (void *)*a4;
  v26 = (const std::string::value_type *)a5;
  if (*(char *)(a5 + 23) < 0)
    goto LABEL_68;
LABEL_32:
  v27 = a6;
  if (v9 < 0)
    goto LABEL_69;
LABEL_33:
  v28 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  v29 = __dst.__r_.__value_.__r.__words[0];
  abm::helper::asString(a7, &__p);
  v30 = &__dst;
  if (v28 < 0)
    v30 = (std::string *)v29;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  *(_DWORD *)buf = 136316674;
  *(_QWORD *)&buf[4] = &v121;
  *(_WORD *)&buf[12] = 2080;
  *(_QWORD *)&buf[14] = v24;
  *(_WORD *)&buf[22] = 2080;
  v130 = v25;
  v131 = 2080;
  v132 = v26;
  v133 = 2080;
  v134 = v27;
  v135 = 2080;
  v136 = v30;
  v137 = 2080;
  v138 = p_p;
  _os_log_impl(&dword_1A343C000, v22, OS_LOG_TYPE_DEFAULT, "#I Beginning to create %s archive:\n\tsource directory     = %s\n\tpending directory    = %s\n\tprocessing directory = %s\n\tarchive file name    = %s\n\tarchive file path    = %s\n\tcompression mode     = %s", buf, 0x48u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    v23 = a4;
    v21 = a1;
    if ((SHIBYTE(v123) & 0x80000000) == 0)
      goto LABEL_40;
  }
  else
  {
    v23 = a4;
    v21 = a1;
    if ((SHIBYTE(v123) & 0x80000000) == 0)
      goto LABEL_40;
  }
  operator delete(v121);
LABEL_40:
  ctu::fs::create_directory();
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v119, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v119 = *(std::string *)a3;
  if (*(char *)(a5 + 23) < 0)
    std::string::__init_copy_ctor_external(&v118, *(const std::string::value_type **)a5, *(_QWORD *)(a5 + 8));
  else
    v118 = *(std::string *)a5;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v116, "[^\\.].*", 0);
  util::moveDirContent((const void **)&v119.__r_.__value_.__l.__data_, (uint64_t)&v118, 1u, 0, (uint64_t)&v116);
  v32 = v117;
  if (!v117)
    goto LABEL_50;
  p_shared_owners = (unint64_t *)&v117->__shared_owners_;
  do
    v34 = __ldaxr(p_shared_owners);
  while (__stlxr(v34 - 1, p_shared_owners));
  if (v34)
  {
LABEL_50:
    std::locale::~locale(&v116);
    if ((SHIBYTE(v118.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_51;
LABEL_60:
    operator delete(v118.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v119.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_52;
LABEL_61:
    operator delete(v119.__r_.__value_.__l.__data_);
    goto LABEL_52;
  }
  ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
  std::__shared_weak_count::__release_weak(v32);
  std::locale::~locale(&v116);
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_60;
LABEL_51:
  if (SHIBYTE(v119.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_61;
LABEL_52:
  sync();
  v121 = 0;
  v122 = 0;
  v123 = 0;
  SystemTime = TelephonyUtilGetSystemTime();
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v114, "^(?!.*(\\.tar\\.gz|\\.$)).*", 0);
  filtered_files = ctu::fs::get_filtered_files();
  v37 = v115;
  if (!v115)
    goto LABEL_56;
  v38 = (unint64_t *)&v115->__shared_owners_;
  do
    v39 = __ldaxr(v38);
  while (__stlxr(v39 - 1, v38));
  if (v39)
  {
LABEL_56:
    std::locale::~locale(&v114);
    if ((filtered_files & 1) != 0)
      goto LABEL_57;
LABEL_63:
    v40 = *(NSObject **)(v21 + 40);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
LABEL_79:
      v48 = 0;
      goto LABEL_99;
    }
    v41 = (const std::string::value_type *)v23;
    if (*((char *)v23 + 23) < 0)
      v41 = (const std::string::value_type *)*v23;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v41;
    v42 = "Failed to find matching files for archiving in %s";
    v43 = v40;
    v44 = 12;
LABEL_193:
    _os_log_error_impl(&dword_1A343C000, v43, OS_LOG_TYPE_ERROR, v42, buf, v44);
    goto LABEL_79;
  }
  ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
  std::__shared_weak_count::__release_weak(v37);
  std::locale::~locale(&v114);
  if ((filtered_files & 1) == 0)
    goto LABEL_63;
LABEL_57:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v113, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  else
    v113 = __dst;
  Archive_sync = abm::LogCompressionTask::createArchive_sync(v21, (uint64_t *)&v113, a7);
  v46 = Archive_sync;
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v113.__r_.__value_.__l.__data_);
    if (v46)
      goto LABEL_75;
    goto LABEL_78;
  }
  if (!Archive_sync)
  {
LABEL_78:
    v47 = *(NSObject **)(v21 + 40);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      goto LABEL_79;
    *(_WORD *)buf = 0;
    v42 = "Failed to create archive object";
    v43 = v47;
    v44 = 2;
    goto LABEL_193;
  }
LABEL_75:
  if (*((char *)v23 + 23) < 0)
    std::string::__init_copy_ctor_external(&v112, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
  else
    v112 = *(std::string *)v23;
  v109 = 0;
  v110 = 0;
  v111 = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v109, (uint64_t)v121, (uint64_t)v122, 0xAAAAAAAAAAAAAAABLL * (v122 - v121));
  if (*((char *)v23 + 23) < 0)
    std::string::__init_copy_ctor_external(&v108, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
  else
    v108 = *(std::string *)v23;
  v48 = abm::LogCompressionTask::archiveEntries_sync(v21, v46, (std::string::size_type)&v112, (__int128 **)&v109, (uint64_t)&v108);
  if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v108.__r_.__value_.__l.__data_);
  v49 = (void **)v109;
  if (v109)
  {
    v50 = v110;
    v51 = v109;
    if (v110 != v109)
    {
      do
      {
        if (*((char *)v50 - 1) < 0)
          operator delete(*(v50 - 3));
        v50 -= 3;
      }
      while (v50 != v49);
      v51 = v109;
    }
    v110 = v49;
    operator delete(v51);
  }
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v112.__r_.__value_.__l.__data_);
  archive_write_free();
LABEL_99:
  v52 = TelephonyUtilGetSystemTime();
  v53 = *(NSObject **)(v21 + 40);
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
  {
    v54 = "Failed";
    if ((_DWORD)v48)
      v54 = "Succeeded";
    v55 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v55 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    v56 = v23;
    if (*((char *)v23 + 23) < 0)
      v56 = *v23;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v54;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v55;
    *(_WORD *)&buf[22] = 2080;
    v130 = v56;
    v131 = 2048;
    v132 = (const std::string::value_type *)(v52 - SystemTime);
    _os_log_impl(&dword_1A343C000, v53, OS_LOG_TYPE_DEFAULT, "#I %s to create archive %s from contents of pending directory %s (elapsed archiving time = %llu ms)", buf, 0x2Au);
    v53 = *(NSObject **)(v21 + 40);
  }
  v57 = os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
  if (!(_DWORD)v48)
  {
    if (v57)
    {
      v63 = v23;
      if (*((char *)v23 + 23) < 0)
        v63 = (void *)*v23;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v63;
      *(_WORD *)&buf[12] = 2080;
      *(char **)&buf[14] = abm::trace::kSnapshotFolder[0];
      _os_log_impl(&dword_1A343C000, v53, OS_LOG_TYPE_DEFAULT, "#I Fall-back move %s -> %s", buf, 0x16u);
    }
    if (*((char *)v23 + 23) < 0)
      std::string::__init_copy_ctor_external(&v107, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
    else
      v107 = *(std::string *)v23;
    v64 = abm::trace::kSnapshotFolder[0];
    v65 = strlen(abm::trace::kSnapshotFolder[0]);
    if (v65 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v66 = (void *)v65;
    if (v65 >= 0x17)
    {
      v68 = (v65 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v65 | 7) != 0x17)
        v68 = v65 | 7;
      v69 = v68 + 1;
      v67 = operator new(v68 + 1);
      v105[1] = v66;
      v106 = v69 | 0x8000000000000000;
      v105[0] = v67;
    }
    else
    {
      HIBYTE(v106) = v65;
      v67 = v105;
      if (!v65)
        goto LABEL_131;
    }
    memmove(v67, v64, (size_t)v66);
LABEL_131:
    *((_BYTE *)v66 + (_QWORD)v67) = 0;
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v103, "[^\\.].*", 0);
    util::moveDirContent((const void **)&v107.__r_.__value_.__l.__data_, (uint64_t)v105, 1u, 0, (uint64_t)&v103);
    v70 = v104;
    if (!v104)
      goto LABEL_135;
    v71 = (unint64_t *)&v104->__shared_owners_;
    do
      v72 = __ldaxr(v71);
    while (__stlxr(v72 - 1, v71));
    if (!v72)
    {
      ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
      std::__shared_weak_count::__release_weak(v70);
      std::locale::~locale(&v103);
      if ((SHIBYTE(v106) & 0x80000000) == 0)
      {
LABEL_136:
        if ((SHIBYTE(v107.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_179;
LABEL_178:
        operator delete(v107.__r_.__value_.__l.__data_);
        goto LABEL_179;
      }
    }
    else
    {
LABEL_135:
      std::locale::~locale(&v103);
      if ((SHIBYTE(v106) & 0x80000000) == 0)
        goto LABEL_136;
    }
    operator delete(v105[0]);
    if ((SHIBYTE(v107.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_179;
    goto LABEL_178;
  }
  if (!v57)
    goto LABEL_152;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v58 = &__dst;
  else
    v58 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  v59 = abm::trace::kSnapshotFolder[0];
  v60 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v60 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v61 = v60;
  if (v60 >= 0x17)
  {
    v73 = (v60 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v60 | 7) != 0x17)
      v73 = v60 | 7;
    v74 = v73 + 1;
    v62 = (std::string *)operator new(v73 + 1);
    __p.__r_.__value_.__l.__size_ = v61;
    __p.__r_.__value_.__r.__words[2] = v74 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v62;
    goto LABEL_141;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v60;
  v62 = &__p;
  if (v60)
LABEL_141:
    memmove(v62, v59, v61);
  v62->__r_.__value_.__s.__data_[v61] = 0;
  v75 = *((char *)a6 + 23);
  if (v75 >= 0)
    v76 = (const std::string::value_type *)a6;
  else
    v76 = (const std::string::value_type *)*a6;
  if (v75 >= 0)
    v77 = *((unsigned __int8 *)a6 + 23);
  else
    v77 = (std::string::size_type)a6[1];
  v78 = std::string::append(&__p, v76, v77);
  v79 = *(_OWORD *)&v78->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf[16] = *((_QWORD *)&v78->__r_.__value_.__l + 2);
  *(_OWORD *)buf = v79;
  v78->__r_.__value_.__l.__size_ = 0;
  v78->__r_.__value_.__r.__words[2] = 0;
  v78->__r_.__value_.__r.__words[0] = 0;
  v80 = buf;
  if (buf[23] < 0)
    v80 = *(_BYTE **)buf;
  *(_DWORD *)v125 = 136315394;
  v126 = v58;
  v127 = 2080;
  v128 = v80;
  _os_log_impl(&dword_1A343C000, v53, OS_LOG_TYPE_DEFAULT, "#I Moving archive %s -> %s", v125, 0x16u);
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_152;
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_152;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_152:
  v81 = abm::trace::kSnapshotFolder[0];
  v82 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v82 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v83 = v82;
  if (v82 >= 0x17)
  {
    v85 = (v82 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v82 | 7) != 0x17)
      v85 = v82 | 7;
    v86 = v85 + 1;
    v84 = (std::string *)operator new(v85 + 1);
    __p.__r_.__value_.__l.__size_ = v83;
    __p.__r_.__value_.__r.__words[2] = v86 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v84;
    v23 = a4;
    goto LABEL_159;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v82;
  v84 = &__p;
  if (v82)
LABEL_159:
    memmove(v84, v81, v83);
  v84->__r_.__value_.__s.__data_[v83] = 0;
  v87 = *((char *)a6 + 23);
  if (v87 >= 0)
    v88 = (const std::string::value_type *)a6;
  else
    v88 = (const std::string::value_type *)*a6;
  if (v87 >= 0)
    v89 = *((unsigned __int8 *)a6 + 23);
  else
    v89 = (std::string::size_type)a6[1];
  v90 = std::string::append(&__p, v88, v89);
  v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf[16] = *((_QWORD *)&v90->__r_.__value_.__l + 2);
  *(_OWORD *)buf = v91;
  v90->__r_.__value_.__l.__size_ = 0;
  v90->__r_.__value_.__r.__words[2] = 0;
  v90->__r_.__value_.__r.__words[0] = 0;
  ctu::fs::rename();
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_168;
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_168;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_168:
  v92 = ctu::fs::remove_dir();
  v93 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
  {
    v94 = "Failed";
    if (v92)
      v94 = "Succeeded";
    if (*((char *)v23 + 23) < 0)
      v23 = (const void **)*v23;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v94;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v23;
    _os_log_impl(&dword_1A343C000, v93, OS_LOG_TYPE_DEFAULT, "#I %s to remove pending directory %s", buf, 0x16u);
  }
LABEL_179:
  v95 = v121;
  if (v121)
  {
    v96 = v122;
    v97 = v121;
    if (v122 != v121)
    {
      do
      {
        if (*((char *)v96 - 1) < 0)
          operator delete(*(v96 - 3));
        v96 -= 3;
      }
      while (v96 != v95);
      v97 = v121;
    }
    v122 = v95;
    operator delete(v97);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  return v48;
}

void sub_1A35016E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v40;

  std::vector<std::string>::~vector[abi:ne180100](&a32);
  if (a40 < 0)
    operator delete(__p);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v40 - 256));
  if (*(char *)(v40 - 209) < 0)
  {
    operator delete(*(void **)(v40 - 232));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t abm::LogCompressionTask::createArchive_sync(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  int v11;
  uint64_t *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v6 = archive_write_new();
  if (!v6)
    return v6;
  if (a3 != 1)
  {
    archive_write_set_format_ustar();
    if ((*((char *)a2 + 23) & 0x80000000) == 0)
      goto LABEL_4;
LABEL_7:
    v7 = archive_write_open_filename();
    if (!v7)
      return v6;
    goto LABEL_8;
  }
  archive_write_add_filter_gzip();
  archive_write_set_format_ustar();
  if (*((char *)a2 + 23) < 0)
    goto LABEL_7;
LABEL_4:
  v7 = archive_write_open_filename();
  if (!v7)
    return v6;
LABEL_8:
  v8 = v7;
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) < 0)
      a2 = (uint64_t *)*a2;
    v11 = 136315394;
    v12 = a2;
    v13 = 1024;
    v14 = v8;
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Error creating archive at path %s, error code: %d", (uint8_t *)&v11, 0x12u);
  }
  archive_write_free();
  return 0;
}

uint64_t abm::LogCompressionTask::archiveEntries_sync(uint64_t a1, uint64_t a2, std::string::size_type a3, __int128 **a4, uint64_t a5)
{
  std::string::size_type v6;
  __int128 *v8;
  char v9;
  uint64_t v10;
  __int128 v11;
  int v12;
  std::string::size_type size;
  std::string *v14;
  int v15;
  std::string *v16;
  int v17;
  size_t v18;
  unint64_t v19;
  _BYTE *v20;
  std::string::size_type v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  std::string *v26;
  std::string *v27;
  __int128 v28;
  char filtered_files;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  NSObject *v33;
  void **v34;
  char v35;
  NSObject *v36;
  void **v37;
  void **v38;
  void *v39;
  void **v40;
  void **v41;
  NSObject *v42;
  unint64_t v44;
  __int128 *v47;
  std::string v48;
  std::string v49;
  std::string v50;
  void *__p;
  void **v52;
  uint64_t v53;
  std::string v54;
  uint8_t buf[16];
  std::locale v56;
  std::__shared_weak_count *v57;
  _BYTE __dst[64];
  std::string v59;
  unint64_t v60;
  uint64_t v61;

  v6 = a3;
  v61 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      if (!*(_QWORD *)(a3 + 8))
        goto LABEL_108;
    }
    else if (!*(_BYTE *)(a3 + 23))
    {
      goto LABEL_108;
    }
    v8 = *a4;
    v47 = a4[1];
    if (v47 == *a4)
      goto LABEL_108;
    v9 = 1;
    v10 = a1;
    while (1)
    {
      memset(&v59, 170, sizeof(v59));
      if (*((char *)v8 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
      }
      else
      {
        v11 = *v8;
        v59.__r_.__value_.__r.__words[2] = *((_QWORD *)v8 + 2);
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v11;
      }
      v12 = SHIBYTE(v59.__r_.__value_.__r.__words[2]);
      if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v59.__r_.__value_.__r.__words[2]);
      else
        size = v59.__r_.__value_.__l.__size_;
      if (size == 2)
      {
        v16 = (std::string *)v59.__r_.__value_.__r.__words[0];
        if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v16 = &v59;
        if (LOWORD(v16->__r_.__value_.__l.__data_) == 11822)
        {
LABEL_20:
          v15 = 5;
          if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            goto LABEL_100;
          goto LABEL_101;
        }
      }
      else if (size == 1)
      {
        v14 = (std::string *)v59.__r_.__value_.__r.__words[0];
        if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v14 = &v59;
        if (v14->__r_.__value_.__s.__data_[0] == 46)
          goto LABEL_20;
      }
      memset(&__dst[32], 170, 24);
      v17 = *(char *)(v6 + 23);
      if (v17 >= 0)
        v18 = *(unsigned __int8 *)(v6 + 23);
      else
        v18 = *(_QWORD *)(v6 + 8);
      v19 = v18 + 1;
      memset(__dst, 170, 24);
      if (v18 + 1 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      if (v19 >= 0x17)
      {
        v21 = v6;
        v22 = a5;
        v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v19 | 7) != 0x17)
          v23 = v19 | 7;
        v24 = v23 + 1;
        v20 = operator new(v23 + 1);
        *(_QWORD *)&__dst[8] = v18 + 1;
        *(_QWORD *)&__dst[16] = v24 | 0x8000000000000000;
        *(_QWORD *)__dst = v20;
        a5 = v22;
        v6 = v21;
        v10 = a1;
      }
      else
      {
        memset(__dst, 0, 24);
        v20 = __dst;
        __dst[23] = v18 + 1;
        if (!v18)
          goto LABEL_39;
      }
      if (v17 >= 0)
        v25 = (const void *)v6;
      else
        v25 = *(const void **)v6;
      memmove(v20, v25, v18);
LABEL_39:
      *(_WORD *)&v20[v18] = 47;
      if (v12 >= 0)
        v26 = &v59;
      else
        v26 = (std::string *)v59.__r_.__value_.__r.__words[0];
      v27 = std::string::append((std::string *)__dst, (const std::string::value_type *)v26, size);
      v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      *(_QWORD *)&__dst[48] = *((_QWORD *)&v27->__r_.__value_.__l + 2);
      *(_OWORD *)&__dst[32] = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      if ((__dst[23] & 0x80000000) != 0)
        operator delete(*(void **)__dst);
      if (!ctu::fs::is_directory())
      {
        if (!ctu::fs::file_exists())
          goto LABEL_72;
        if ((__dst[55] & 0x80000000) != 0)
          std::string::__init_copy_ctor_external(&v49, *(const std::string::value_type **)&__dst[32], *(std::string::size_type *)&__dst[40]);
        else
          v49 = *(std::string *)&__dst[32];
        if (*(char *)(a5 + 23) < 0)
          std::string::__init_copy_ctor_external(&v48, *(const std::string::value_type **)a5, *(_QWORD *)(a5 + 8));
        else
          v48 = *(std::string *)a5;
        v35 = abm::LogCompressionTask::archiveEntry_sync(v10, a2, (__darwin_ino64_t)&v49, (const void **)&v48.__r_.__value_.__l.__data_);
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v48.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_65;
        }
        else if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_65:
          if ((v35 & 1) == 0)
            goto LABEL_72;
LABEL_66:
          v9 = 1;
LABEL_97:
          v15 = 0;
          goto LABEL_98;
        }
        operator delete(v49.__r_.__value_.__l.__data_);
        if ((v35 & 1) == 0)
        {
LABEL_72:
          v36 = *(NSObject **)(v10 + 40);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__dst = 0;
            _os_log_error_impl(&dword_1A343C000, v36, OS_LOG_TYPE_ERROR, "Failed to add archive.", __dst, 2u);
          }
          v9 = 0;
          v15 = 4;
          goto LABEL_98;
        }
        goto LABEL_66;
      }
      memset(__dst, 0, 24);
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v56, ".*", 0);
      filtered_files = ctu::fs::get_filtered_files();
      v30 = v57;
      if (!v57)
        goto LABEL_49;
      p_shared_owners = (unint64_t *)&v57->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
        std::locale::~locale(&v56);
        if ((filtered_files & 1) == 0)
        {
LABEL_56:
          v33 = *(NSObject **)(v10 + 40);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1A343C000, v33, OS_LOG_TYPE_ERROR, "Failed to get files for archiving.", buf, 2u);
            v9 = 0;
            v15 = 4;
            v34 = *(void ***)__dst;
            if (!*(_QWORD *)__dst)
              goto LABEL_96;
          }
          else
          {
            v9 = 0;
            v15 = 4;
            v34 = *(void ***)__dst;
            if (!*(_QWORD *)__dst)
              goto LABEL_96;
          }
LABEL_89:
          v40 = *(void ***)&__dst[8];
          v41 = v34;
          if (*(void ***)&__dst[8] != v34)
          {
            do
            {
              if (*((char *)v40 - 1) < 0)
                operator delete(*(v40 - 3));
              v40 -= 3;
            }
            while (v40 != v34);
            v41 = *(void ***)__dst;
          }
          *(_QWORD *)&__dst[8] = v34;
          operator delete(v41);
          goto LABEL_96;
        }
      }
      else
      {
LABEL_49:
        std::locale::~locale(&v56);
        if ((filtered_files & 1) == 0)
          goto LABEL_56;
      }
      if ((__dst[55] & 0x80000000) != 0)
        std::string::__init_copy_ctor_external(&v54, *(const std::string::value_type **)&__dst[32], *(std::string::size_type *)&__dst[40]);
      else
        v54 = *(std::string *)&__dst[32];
      __p = 0;
      v52 = 0;
      v53 = 0;
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&__p, *(uint64_t *)__dst, *(uint64_t *)&__dst[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&__dst[8] - *(_QWORD *)__dst) >> 3));
      if (*(char *)(a5 + 23) < 0)
        std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)a5, *(_QWORD *)(a5 + 8));
      else
        v50 = *(std::string *)a5;
      v9 = abm::LogCompressionTask::archiveEntries_sync(v10, a2, &v54, &__p, &v50);
      if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v50.__r_.__value_.__l.__data_);
      v37 = (void **)__p;
      if (__p)
      {
        v38 = v52;
        v39 = __p;
        if (v52 != __p)
        {
          do
          {
            if (*((char *)v38 - 1) < 0)
              operator delete(*(v38 - 3));
            v38 -= 3;
          }
          while (v38 != v37);
          v39 = __p;
        }
        v52 = v37;
        operator delete(v39);
      }
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v54.__r_.__value_.__l.__data_);
      v15 = 0;
      v34 = *(void ***)__dst;
      if (*(_QWORD *)__dst)
        goto LABEL_89;
LABEL_96:
      if ((filtered_files & 1) != 0)
        goto LABEL_97;
LABEL_98:
      if ((__dst[55] & 0x80000000) != 0)
      {
        operator delete(*(void **)&__dst[32]);
        if ((*((_BYTE *)&v59.__r_.__value_.__s + 23) & 0x80) == 0)
          goto LABEL_101;
LABEL_100:
        operator delete(v59.__r_.__value_.__l.__data_);
        goto LABEL_101;
      }
      if ((*((_BYTE *)&v59.__r_.__value_.__s + 23) & 0x80) != 0)
        goto LABEL_100;
LABEL_101:
      if (v15 == 5 || !v15)
      {
        v8 = (__int128 *)((char *)v8 + 24);
        if (v8 != v47)
          continue;
      }
      return v9 & 1;
    }
  }
LABEL_108:
  v42 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(v6 + 23) < 0)
      v6 = *(_QWORD *)v6;
    v44 = 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3);
    LODWORD(v59.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)v59.__r_.__value_.__r.__words + 4) = a2;
    WORD2(v59.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v59.__r_.__value_.__r.__words[1] + 6) = v6;
    HIWORD(v59.__r_.__value_.__r.__words[2]) = 2048;
    v60 = v44;
    _os_log_error_impl(&dword_1A343C000, v42, OS_LOG_TYPE_ERROR, "Error on the given parameter. arch: %p, baseDir: %s, fileLists.size(): %lu", (uint8_t *)&v59, 0x20u);
    v9 = 0;
  }
  else
  {
    v9 = 0;
  }
  return v9 & 1;
}

void sub_1A35020F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,std::locale a45)
{
  uint64_t v45;

  std::vector<std::string>::~vector[abi:ne180100](&a33);
  if (a41 < 0)
    operator delete(__p);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v45 - 208));
  if (*(char *)(v45 - 153) < 0)
    operator delete(*(void **)(v45 - 176));
  if (*(char *)(v45 - 121) < 0)
    operator delete(*(void **)(v45 - 144));
  _Unwind_Resume(a1);
}

BOOL abm::LogCompressionTask::closeArchive_sync(uint64_t a1, uint64_t a2)
{
  return a2 && archive_write_free() == 0;
}

uint64_t abm::LogCompressionTask::archiveEntry_sync(uint64_t a1, uint64_t a2, __darwin_ino64_t a3, const void **a4)
{
  __darwin_ino64_t v4;
  timespec v8;
  uint64_t v9;
  const char *v10;
  __int128 v11;
  int v12;
  size_t v13;
  unint64_t v14;
  std::string::value_type *v15;
  NSObject *v16;
  _BOOL8 v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  const void *v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  __int128 v26;
  uint64_t v27;
  std::__wrap_iter<const char *> v28;
  std::__wrap_iter<const char *> v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  const char *v33;
  int v34;
  int v35;
  ssize_t v36;
  ssize_t v37;
  uint64_t v38;
  int v39;
  int *v40;
  char *v41;
  const char *v42;
  std::__shared_weak_count *cntrl;
  uint64_t *p_shared_owners;
  unint64_t v45;
  std::string *v47;
  char *v48;
  uint64_t v49;
  std::string v50;
  std::string v51;
  std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type v52;
  _BYTE __p[28];
  stat v54;
  uint64_t v55;

  v4 = a3;
  v55 = *MEMORY[0x1E0C80C00];
  if (!a2)
    goto LABEL_16;
  if (*(char *)(a3 + 23) < 0)
  {
    if (*(_QWORD *)(a3 + 8))
      goto LABEL_4;
LABEL_16:
    v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(v4 + 23) < 0)
        v4 = *(_QWORD *)v4;
      v54.st_dev = 134218242;
      *(_QWORD *)&v54.st_mode = a2;
      WORD2(v54.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&v54.st_ino + 6) = v4;
      _os_log_error_impl(&dword_1A343C000, v16, OS_LOG_TYPE_ERROR, "Error on the given parameter. arch: %p, filePath: %s", (uint8_t *)&v54, 0x16u);
    }
    return 0;
  }
  if (!*(_BYTE *)(a3 + 23))
    goto LABEL_16;
LABEL_4:
  v8.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v8.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize = v8;
  *(timespec *)v54.st_qspare = v8;
  v54.st_birthtimespec = v8;
  *(timespec *)&v54.st_size = v8;
  v54.st_mtimespec = v8;
  v54.st_ctimespec = v8;
  *(timespec *)&v54.st_uid = v8;
  v54.st_atimespec = v8;
  *(timespec *)&v54.st_dev = v8;
  v9 = archive_entry_new();
  if (v9)
  {
    v49 = v9;
    v10 = (const char *)v4;
    if (*(char *)(v4 + 23) < 0)
      v10 = *(const char **)v4;
    lstat(v10, &v54);
    if ((v54.st_mode & 0xF000) != 0x8000)
    {
      v17 = 1;
LABEL_66:
      archive_entry_free();
      return v17;
    }
    archive_entry_copy_stat();
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v52.__loop_count_ = v11;
    *(_OWORD *)&v52.__start_.__cntrl_ = v11;
    *(_OWORD *)&v52.__traits_.__loc_.__locale_ = v11;
    *(_OWORD *)&v52.__traits_.__col_ = v11;
    v12 = *((char *)a4 + 23);
    if (v12 >= 0)
      v13 = *((unsigned __int8 *)a4 + 23);
    else
      v13 = (size_t)a4[1];
    v14 = v13 + 1;
    memset(&v50, 170, sizeof(v50));
    if (v13 + 1 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v14 >= 0x17)
    {
      v19 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17)
        v19 = v14 | 7;
      v20 = v19 + 1;
      v21 = operator new(v19 + 1);
      v50.__r_.__value_.__l.__size_ = v13 + 1;
      v50.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
      v50.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
      *v21 = 40;
      v15 = v21 + 1;
    }
    else
    {
      v50.__r_.__value_.__r.__words[2] = 0;
      *((_BYTE *)&v50.__r_.__value_.__s + 23) = v13 + 1;
      v15 = &v50.__r_.__value_.__s.__data_[1];
      *(_OWORD *)&v50.__r_.__value_.__l.__data_ = 0x28uLL;
      if (!v13)
        goto LABEL_29;
    }
    if (v12 >= 0)
      v22 = a4;
    else
      v22 = *a4;
    memmove(v15, v22, v13);
LABEL_29:
    v15[v13] = 0;
    v23 = std::string::append(&v50, ")", 1uLL);
    v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    v25 = std::string::append(&v51, "([/]*)(.*)", 0xAuLL);
    v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    *(_QWORD *)&__p[16] = *((_QWORD *)&v25->__r_.__value_.__l + 2);
    *(_OWORD *)__p = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)&v52, (uint64_t)__p, 0);
    if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
      if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_31:
        if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_32;
LABEL_44:
        operator delete(v50.__r_.__value_.__l.__data_);
LABEL_32:
        memset(&v51, 0, sizeof(v51));
        v27 = *(unsigned __int8 *)(v4 + 23);
        if ((v27 & 0x80u) == 0)
          v28.__i_ = (std::__wrap_iter<const char *>::iterator_type)v4;
        else
          v28.__i_ = *(std::__wrap_iter<const char *>::iterator_type *)v4;
        if ((v27 & 0x80u) != 0)
          v27 = *(_QWORD *)(v4 + 8);
        v29.__i_ = &v28.__i_[v27];
        std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(&v51, v28, v29, &v52, "$3", 0);
        v30 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v47 = &v51;
          if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v47 = (std::string *)v51.__r_.__value_.__r.__words[0];
          *(_DWORD *)__p = 136315138;
          *(_QWORD *)&__p[4] = v47;
          _os_log_debug_impl(&dword_1A343C000, v30, OS_LOG_TYPE_DEBUG, "#D archivePathName: %s", __p, 0xCu);
        }
        archive_entry_set_pathname();
        if (archive_write_header())
        {
          v31 = archive_errno();
          v32 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            goto LABEL_40;
          if (*(char *)(v4 + 23) < 0)
            v4 = *(_QWORD *)v4;
          v48 = strerror(v31);
          *(_DWORD *)__p = 136315650;
          *(_QWORD *)&__p[4] = v4;
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v31;
          *(_WORD *)&__p[18] = 2080;
          *(_QWORD *)&__p[20] = v48;
          v42 = "Failed to write header for file for file: %s error: %d(%s)";
        }
        else
        {
          v33 = (const char *)v4;
          if (*(char *)(v4 + 23) < 0)
            v33 = *(const char **)v4;
          v34 = open(v33, 0, v49);
          v35 = v34;
          if (v34 != -1)
          {
            v36 = read(v34, *(void **)(a1 + 136), 0x300000uLL);
            if (v36 < 1)
            {
              v17 = 1;
            }
            else
            {
              do
              {
                v37 = v36;
                v38 = archive_write_data();
                v36 = read(v35, *(void **)(a1 + 136), 0x300000uLL);
              }
              while (v36 > 0);
              v17 = v38 == v37;
            }
            close(v35);
            if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_60;
            goto LABEL_41;
          }
          v32 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
LABEL_40:
            v17 = 1;
            if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_60;
            goto LABEL_41;
          }
          if (*(char *)(v4 + 23) < 0)
            v4 = *(_QWORD *)v4;
          v39 = *__error();
          v40 = __error();
          v41 = strerror(*v40);
          *(_DWORD *)__p = 136315650;
          *(_QWORD *)&__p[4] = v4;
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v39;
          *(_WORD *)&__p[18] = 2080;
          *(_QWORD *)&__p[20] = v41;
          v42 = "Failed to open file: %s  error: %d(%s)";
        }
        _os_log_error_impl(&dword_1A343C000, v32, OS_LOG_TYPE_ERROR, v42, __p, 0x1Cu);
        v17 = 1;
        if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_60:
          cntrl = v52.__start_.__cntrl_;
          if (v52.__start_.__cntrl_)
          {
            p_shared_owners = &v52.__start_.__cntrl_->__shared_owners_;
            do
              v45 = __ldaxr((unint64_t *)p_shared_owners);
            while (__stlxr(v45 - 1, (unint64_t *)p_shared_owners));
            if (!v45)
            {
              ((void (*)(std::__shared_weak_count *))cntrl->__on_zero_shared)(cntrl);
              std::__shared_weak_count::__release_weak(cntrl);
            }
          }
          std::locale::~locale(&v52.__traits_.__loc_);
          goto LABEL_66;
        }
LABEL_41:
        operator delete(v51.__r_.__value_.__l.__data_);
        goto LABEL_60;
      }
    }
    else if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_31;
    }
    operator delete(v51.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_32;
    goto LABEL_44;
  }
  v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v52.__traits_.__loc_.__locale_) = 0;
    _os_log_error_impl(&dword_1A343C000, v18, OS_LOG_TYPE_ERROR, "Failed to get archive_entry_new()", (uint8_t *)&v52, 2u);
  }
  return 1;
}

void sub_1A3502814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::locale a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a21 < 0)
    operator delete(__p);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a23);
  _Unwind_Resume(a1);
}

void dispatch::async<abm::LogCompressionTask::init_sync(void)::$_0>(dispatch_queue_s *,std::unique_ptr<abm::LogCompressionTask::init_sync(void)::$_0,std::default_delete<abm::LogCompressionTask::init_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke(abm::LogCompressionTask **a1)
{
  abm::LogCompressionTask::initWorkspace_sync(*a1);
  operator delete(a1);
}

void sub_1A35028F4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__2ES2_EEEvDpT__block_invoke_0(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  xpc_object_t object;

  v1 = *(unsigned int *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  object = v2;
  if (v2)
    xpc_retain(v2);
  else
    object = xpc_null_create();
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A3502968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZN3abm18LogCompressionTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  xpc_object_t v6;
  int v7;
  void *v8;
  int v9;
  xpc_object_t v10;
  const void *v11;
  void *v12;
  NSObject *v13;
  void *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  void *v17;
  xpc_object_t v18;
  _QWORD block[4];
  void *aBlock;
  xpc_object_t object;
  int v22;

  v2 = (std::__shared_weak_count *)a1[1];
  if (!v2)
    goto LABEL_29;
  v3 = a1[5];
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    goto LABEL_29;
  v5 = v4;
  if (*a1)
  {
    *(_QWORD *)(v3 + 136) = operator new[](0x300000uLL);
    v6 = (xpc_object_t)a1[6];
    v18 = v6;
    if (v6)
    {
      xpc_retain(v6);
    }
    else
    {
      v6 = xpc_null_create();
      v18 = v6;
    }
    v7 = abm::LogCompressionTask::archive_sync(v3, &v18);
    xpc_release(v6);
    v18 = 0;
    v8 = *(void **)(v3 + 136);
    if (v8)
      operator delete[](v8);
    *(_QWORD *)(v3 + 136) = 0;
    if (v7)
      v9 = 0;
    else
      v9 = -534716416;
    v10 = xpc_null_create();
    v11 = (const void *)a1[7];
    if (v11)
      v12 = _Block_copy(v11);
    else
      v12 = 0;
    v13 = a1[8];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 1174405120;
    block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__2ES2_EEEvDpT__block_invoke_0;
    block[3] = &__block_descriptor_tmp_26_0;
    if (v12)
    {
      v14 = _Block_copy(v12);
      v22 = v9;
      aBlock = v14;
      object = v10;
      if (v10)
      {
LABEL_17:
        xpc_retain(v10);
LABEL_20:
        dispatch_async(v13, block);
        xpc_release(object);
        object = 0;
        if (aBlock)
          _Block_release(aBlock);
        if (v12)
          _Block_release(v12);
        xpc_release(v10);
        goto LABEL_25;
      }
    }
    else
    {
      v22 = v9;
      aBlock = 0;
      object = v10;
      if (v10)
        goto LABEL_17;
    }
    object = xpc_null_create();
    goto LABEL_20;
  }
LABEL_25:
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_29:
  v17 = (void *)_ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev((uint64_t)a1);
  operator delete(v17);
}

void sub_1A3502B68(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  void *v3;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;

  xpc_release(v3);
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  v7 = (void *)_ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev(v1);
  operator delete(v7);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1E4A0BAD0;
  return result;
}

void std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E4A0BAD0;
}

void std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::operator()(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A343C000, v4, OS_SIGNPOST_INTERVAL_END, v3, "ArchivingLogs", "", v5, 2u);
    }
  }
}

uint64_t std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::target_type()
{
}

uint64_t __cxx_global_var_init_22()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A343C000);
  }
  return result;
}

double ICECoredumpTrace::createInternal@<D0>(_OWORD *a1@<X8>)
{
  CoredumpTrace *v3;
  double result;
  __int128 v5;

  v3 = (CoredumpTrace *)operator new(0xF0uLL);
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  CoredumpTrace::CoredumpTrace(v3);
  *(_QWORD *)v3 = off_1E4A0BBA0;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<ICECoredumpTrace>::shared_ptr[abi:ne180100]<ICECoredumpTrace,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  result = *(double *)&v5;
  *a1 = v5;
  return result;
}

void sub_1A3502DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A3502DCC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void ICECoredumpTrace::parseCrashReason_sync(ICECoredumpTrace *this@<X0>, xpc_object_t *a2@<X8>)
{
  NSObject *v4;
  _QWORD *v5;
  const char *v6;
  _QWORD *v7;
  timespec v8;
  const char *v9;
  NSObject *v10;
  xpc_object_t v11;
  xpc_object_t v12;
  void *v13;
  void *v14;
  ctu *v15;
  const void *v16;
  xpc_object_t v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  xpc_object_t v22;
  xpc_object_t v23;
  std::string *v24;
  __int128 v25;
  const char *v26;
  xpc_object_t v27;
  xpc_object_t v28;
  void *v29;
  NSObject *v30;
  uint64_t v31;
  xpc_object_t v32;
  xpc_object_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  xpc_object_t v39;
  xpc_object_t v40;
  NSObject *v41;
  xpc_object_t value;
  xpc_object_t v43;
  xpc_object_t v44;
  std::string *v45;
  __int128 v46;
  std::string::size_type size;
  int v48;
  std::string *v49;
  std::string::size_type v50;
  std::string::size_type v51;
  int v52;
  BOOL v53;
  NSObject *v55;
  std::string *v56;
  std::string::size_type v57;
  xpc_object_t v58;
  NSObject *v59;
  xpc_object_t v60;
  xpc_object_t v61;
  std::string *p_p;
  std::string::size_type v63;
  std::string::size_type v64;
  uint64_t v65;
  xpc_object_t v68;
  std::string *v69;
  xpc_object_t v70;
  xpc_object_t v71;
  __darwin_ino64_t st_gid_high;
  timespec v73;
  std::string::size_type v74;
  std::string *v75;
  std::string::size_type v76;
  _QWORD *v77;
  void *p_xdict;
  uint64_t v79;
  _QWORD *v80;
  std::string::size_type v81;
  std::string *v82;
  std::string::size_type v83;
  _QWORD *v84;
  void *v85;
  uint64_t v86;
  std::string *v87;
  xpc_object_t v88;
  xpc_object_t v89;
  xpc_object_t v90;
  xpc_object_t v91;
  xpc_object_t v92;
  std::string *v93;
  __int128 v94;
  stat *v95;
  xpc_object_t v96;
  xpc_object_t v97;
  std::string *v98;
  xpc_object_t v99;
  xpc_object_t v100;
  const char *p_buf;
  xpc_object_t v102;
  xpc_object_t v103;
  std::string *v104;
  xpc_object_t v105;
  xpc_object_t v106;
  xpc_object_t v107;
  xpc_object_t v108;
  xpc_object_t xdict;
  uint64_t v110;
  unsigned __int8 v111;
  xpc_object_t v112;
  void *v113;
  std::string __p;
  xpc_object_t object;
  stat buf;
  timespec v117;
  timespec v118;
  timespec v119;
  timespec v120;
  timespec v121;
  timespec v122;
  timespec v123;
  timespec v124;
  unint64_t v125;
  std::string v126;
  uint64_t v127;

  v127 = *MEMORY[0x1E0C80C00];
  object = xpc_null_create();
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  *a2 = xpc_null_create();
  __p.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  __p.__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)&__p, "unknown");
  v113 = 0;
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v5 = (_QWORD *)*v5;
    buf.st_dev = 136315138;
    *(_QWORD *)&buf.st_mode = v5;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Looking for crash report file: %s", (uint8_t *)&buf, 0xCu);
  }
  v7 = (_QWORD *)((char *)this + 200);
  v6 = (const char *)*((_QWORD *)this + 25);
  v8.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v8.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&buf.st_blksize = v8;
  *(timespec *)buf.st_qspare = v8;
  buf.st_birthtimespec = v8;
  *(timespec *)&buf.st_size = v8;
  buf.st_mtimespec = v8;
  buf.st_ctimespec = v8;
  *(timespec *)&buf.st_uid = v8;
  buf.st_atimespec = v8;
  *(timespec *)&buf.st_dev = v8;
  if (*((char *)this + 223) >= 0)
    v9 = (char *)this + 200;
  else
    v9 = v6;
  if (!stat(v9, &buf))
  {
    if (*((char *)this + 223) < 0)
      v7 = (_QWORD *)*v7;
    v13 = (void *)objc_msgSend(MEMORY[0x1E0C99DB0], "inputStreamWithFileAtPath:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v7));
    v14 = v13;
    if (v13)
    {
      objc_msgSend(v13, "open");
      v15 = (ctu *)objc_msgSend(MEMORY[0x1E0CB36D8], "JSONObjectWithStream:options:error:", v14, 0, &v113);
      if (v15)
      {
        ctu::cf_to_xpc(v15, v16);
        v17 = *(xpc_object_t *)&buf.st_dev;
        if (*(_QWORD *)&buf.st_dev && MEMORY[0x1A85902BC](*(_QWORD *)&buf.st_dev) == MEMORY[0x1E0C812F8])
          xpc_retain(v17);
        else
          v17 = xpc_null_create();
        v32 = xpc_null_create();
        v33 = object;
        object = v17;
        xpc_release(v33);
        xpc_release(v32);
        xpc_release(*(xpc_object_t *)&buf.st_dev);
        v34 = MEMORY[0x1A85902BC](object);
        v35 = MEMORY[0x1E0C812F8];
        if (v34 != MEMORY[0x1E0C812F8])
          goto LABEL_44;
        v41 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          xpc::object::to_string((xpc::object *)&object);
          v95 = (buf.st_gid & 0x80000000) == 0 ? &buf : *(stat **)&buf.st_dev;
          LODWORD(v126.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v126.__r_.__value_.__r.__words + 4) = (std::string::size_type)v95;
          _os_log_debug_impl(&dword_1A343C000, v41, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v126, 0xCu);
          if (SHIBYTE(buf.st_gid) < 0)
            operator delete(*(void **)&buf.st_dev);
        }
        value = xpc_dictionary_get_value(object, "crash");
        xdict = value;
        if (value)
          xpc_retain(value);
        else
          xdict = xpc_null_create();
        memset(&buf, 0, 24);
        xpc::dyn_cast_or_default();
        if (SHIBYTE(buf.st_gid) < 0)
          operator delete(*(void **)&buf.st_dev);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        __p = v126;
        *((_BYTE *)&v126.__r_.__value_.__s + 23) = 0;
        v126.__r_.__value_.__s.__data_[0] = 0;
        xpc_release(xdict);
        size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        v48 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = __p.__r_.__value_.__l.__size_;
        if (size == 23)
        {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_p = &__p;
          v63 = p_p->__r_.__value_.__r.__words[0];
          v64 = p_p->__r_.__value_.__l.__size_;
          v65 = *(std::string::size_type *)((char *)&p_p->__r_.__value_.__r.__words[1] + 7);
          if (v63 != 0x695F6D6574737973 || v64 != 0x635F64696C61766ELL || v65 != 0x656C626174646463)
            goto LABEL_84;
        }
        else
        {
          if (size != 18)
            goto LABEL_84;
          v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v49 = &__p;
          v50 = v49->__r_.__value_.__r.__words[0];
          v51 = v49->__r_.__value_.__l.__size_;
          v52 = LOWORD(v49->__r_.__value_.__r.__words[2]);
          v53 = v50 == 0x6E5F6D6574737973 && v51 == 0x6261746464635F6FLL;
          if (!v53 || v52 != 25964)
          {
LABEL_84:
            v55 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              v56 = (std::string *)__p.__r_.__value_.__r.__words[0];
              if (v48 >= 0)
                v56 = &__p;
              buf.st_dev = 136315138;
              *(_QWORD *)&buf.st_mode = v56;
              _os_log_impl(&dword_1A343C000, v55, OS_LOG_TYPE_DEFAULT, "#I Found crash type '%s'", (uint8_t *)&buf, 0xCu);
            }
            *(_QWORD *)&buf.st_dev = &object;
            buf.st_ino = (__darwin_ino64_t)"system_details";
            xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &v126);
            v57 = v126.__r_.__value_.__r.__words[0];
            v126.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
            v58 = *a2;
            *a2 = (xpc_object_t)v57;
            xpc_release(v58);
            xpc_release(v126.__r_.__value_.__l.__data_);
            if (MEMORY[0x1A85902BC](*a2) != v35)
            {
              v59 = *((_QWORD *)this + 5);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.st_dev) = 0;
                _os_log_impl(&dword_1A343C000, v59, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to unrecognized or missing system_details", (uint8_t *)&buf, 2u);
              }
              v60 = xpc_dictionary_create(0, 0, 0);
              if (v60 || (v60 = xpc_null_create()) != 0)
              {
                if (MEMORY[0x1A85902BC](v60) == v35)
                {
                  xpc_retain(v60);
                  v61 = v60;
                }
                else
                {
                  v61 = xpc_null_create();
                }
              }
              else
              {
                v61 = xpc_null_create();
                v60 = 0;
              }
              xpc_release(v60);
              v91 = xpc_null_create();
              v92 = *a2;
              *a2 = v61;
              xpc_release(v92);
              xpc_release(v91);
              v126.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x40uLL);
              *(_OWORD *)&v126.__r_.__value_.__r.__words[1] = xmmword_1A35802B0;
              strcpy(v126.__r_.__value_.__l.__data_, "Coredump invalid, unrecognized or missing system_details: ");
              v93 = std::string::append(&v126, "report.json", 0xBuLL);
              v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
              *(_QWORD *)&buf.st_uid = *((_QWORD *)&v93->__r_.__value_.__l + 2);
              *(_OWORD *)&buf.st_dev = v94;
              v93->__r_.__value_.__l.__size_ = 0;
              v93->__r_.__value_.__r.__words[2] = 0;
              v93->__r_.__value_.__r.__words[0] = 0;
              CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
              if (SHIBYTE(buf.st_gid) < 0)
                operator delete(*(void **)&buf.st_dev);
              if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v126.__r_.__value_.__l.__data_);
              objc_msgSend(v14, "close");
              goto LABEL_60;
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v69 = &__p;
            else
              v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
            v70 = xpc_string_create((const char *)v69);
            if (!v70)
              v70 = xpc_null_create();
            xpc_dictionary_set_value(*a2, "crash", v70);
            v71 = xpc_null_create();
            xpc_release(v70);
            xpc_release(v71);
            if (!xpc_dictionary_get_value(*a2, "log_data"))
              goto LABEL_119;
            xpc::dict::object_proxy::operator xpc::object(&v126, *a2, "log_data");
            xpc::dyn_cast_or_default();
            if ((buf.st_gid & 0x80000000) == 0)
              st_gid_high = HIBYTE(buf.st_gid);
            else
              st_gid_high = buf.st_ino;
            if (SHIBYTE(buf.st_gid) < 0)
              operator delete(*(void **)&buf.st_dev);
            xpc_release(v126.__r_.__value_.__l.__data_);
            if (!st_gid_high)
            {
LABEL_119:
              v125 = 0xAAAAAAAAAAAAAAAALL;
              v73.tv_sec = 0xAAAAAAAAAAAAAAAALL;
              v73.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
              v123 = v73;
              v124 = v73;
              v121 = v73;
              v122 = v73;
              v119 = v73;
              v120 = v73;
              v117 = v73;
              v118 = v73;
              *(timespec *)&buf.st_blksize = v73;
              *(timespec *)buf.st_qspare = v73;
              buf.st_birthtimespec = v73;
              *(timespec *)&buf.st_size = v73;
              buf.st_mtimespec = v73;
              buf.st_ctimespec = v73;
              *(timespec *)&buf.st_uid = v73;
              buf.st_atimespec = v73;
              *(timespec *)&buf.st_dev = v73;
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&buf);
              if (xpc_dictionary_get_value(*a2, "ucs_context_id"))
              {
                xpc::dict::object_proxy::operator xpc::object(&xdict, *a2, "ucs_context_id");
                xpc::dyn_cast_or_default();
                if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v74 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                else
                  v74 = v126.__r_.__value_.__l.__size_;
                if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v126.__r_.__value_.__l.__data_);
                xpc_release(xdict);
                if (v74)
                {
                  std::string::basic_string[abi:ne180100]<0>(&v126, "c:");
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    v75 = &v126;
                  else
                    v75 = (std::string *)v126.__r_.__value_.__r.__words[0];
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    v76 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                  else
                    v76 = v126.__r_.__value_.__l.__size_;
                  v77 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)v75, v76);
                  xpc::dict::object_proxy::operator xpc::object(&v112, *a2, "ucs_context_id");
                  xpc::dyn_cast_or_default();
                  if ((v111 & 0x80u) == 0)
                    p_xdict = &xdict;
                  else
                    p_xdict = xdict;
                  if ((v111 & 0x80u) == 0)
                    v79 = v111;
                  else
                    v79 = v110;
                  v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)p_xdict, v79);
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v80, (uint64_t)" ", 1);
                  if ((char)v111 < 0)
                    operator delete(xdict);
                  xpc_release(v112);
                  if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v126.__r_.__value_.__l.__data_);
                }
              }
              if (xpc_dictionary_get_value(*a2, "ucs_static_id"))
              {
                xpc::dict::object_proxy::operator xpc::object(&xdict, *a2, "ucs_static_id");
                xpc::dyn_cast_or_default();
                if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v81 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                else
                  v81 = v126.__r_.__value_.__l.__size_;
                if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v126.__r_.__value_.__l.__data_);
                xpc_release(xdict);
                if (v81)
                {
                  std::string::basic_string[abi:ne180100]<0>(&v126, "s:");
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    v82 = &v126;
                  else
                    v82 = (std::string *)v126.__r_.__value_.__r.__words[0];
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    v83 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                  else
                    v83 = v126.__r_.__value_.__l.__size_;
                  v84 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)v82, v83);
                  xpc::dict::object_proxy::operator xpc::object(&v112, *a2, "ucs_static_id");
                  xpc::dyn_cast_or_default();
                  if ((v111 & 0x80u) == 0)
                    v85 = &xdict;
                  else
                    v85 = xdict;
                  if ((v111 & 0x80u) == 0)
                    v86 = v111;
                  else
                    v86 = v110;
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v84, (uint64_t)v85, v86);
                  if ((char)v111 < 0)
                    operator delete(xdict);
                  xpc_release(v112);
                  if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v126.__r_.__value_.__l.__data_);
                }
              }
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str[abi:ne180100](&buf, &v126);
              if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v87 = &v126;
              else
                v87 = (std::string *)v126.__r_.__value_.__r.__words[0];
              v107 = xpc_string_create((const char *)v87);
              if (!v107)
                v107 = xpc_null_create();
              xpc::dict::object_proxy::operator=(&v108, *a2, "log_data", &v107);
              xpc_release(v108);
              v108 = 0;
              xpc_release(v107);
              v107 = 0;
              if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v126.__r_.__value_.__l.__data_);
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&buf);
            }
LABEL_44:
            v36 = MEMORY[0x1A85902BC](*a2);
            v37 = MEMORY[0x1E0C812F8];
            if (v36 == MEMORY[0x1E0C812F8])
              goto LABEL_58;
            v38 = *((_QWORD *)this + 5);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.st_dev) = 0;
              _os_log_impl(&dword_1A343C000, v38, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to processing errors", (uint8_t *)&buf, 2u);
            }
            v39 = xpc_dictionary_create(0, 0, 0);
            if (v39 || (v39 = xpc_null_create()) != 0)
            {
              if (MEMORY[0x1A85902BC](v39) == v37)
              {
                xpc_retain(v39);
                v40 = v39;
              }
              else
              {
                v40 = xpc_null_create();
              }
            }
            else
            {
              v40 = xpc_null_create();
              v39 = 0;
            }
            xpc_release(v39);
            v43 = xpc_null_create();
            v44 = *a2;
            *a2 = v40;
            xpc_release(v44);
            xpc_release(v43);
            v126.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x30uLL);
            *(_OWORD *)&v126.__r_.__value_.__r.__words[1] = xmmword_1A3582290;
            strcpy(v126.__r_.__value_.__l.__data_, "Coredump invalid: IO error or zero size file: ");
            v45 = std::string::append(&v126, "report.json", 0xBuLL);
            v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
            *(_QWORD *)&buf.st_uid = *((_QWORD *)&v45->__r_.__value_.__l + 2);
            *(_OWORD *)&buf.st_dev = v46;
            v45->__r_.__value_.__l.__size_ = 0;
            v45->__r_.__value_.__r.__words[2] = 0;
            v45->__r_.__value_.__r.__words[0] = 0;
            CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
            if (SHIBYTE(buf.st_gid) < 0)
            {
              operator delete(*(void **)&buf.st_dev);
              if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_58:
                if (!v14)
                  goto LABEL_60;
                goto LABEL_59;
              }
            }
            else if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_58;
            }
            operator delete(v126.__r_.__value_.__l.__data_);
            if (!v14)
              goto LABEL_60;
LABEL_59:
            objc_msgSend(v14, "close");
            goto LABEL_60;
          }
        }
        xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&buf.st_dev = &object;
        buf.st_ino = (__darwin_ino64_t)"agent";
        xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &xdict);
        memset(&buf, 170, 24);
        v68 = xpc_dictionary_get_value(xdict, "name");
        v126.__r_.__value_.__r.__words[0] = (std::string::size_type)v68;
        if (v68)
          xpc_retain(v68);
        else
          v126.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
        xpc::dyn_cast_or_default();
        xpc_release(v126.__r_.__value_.__l.__data_);
        memset(&v126, 170, sizeof(v126));
        v88 = xpc_dictionary_get_value(object, "scu_rstsr");
        v112 = v88;
        if (v88)
          xpc_retain(v88);
        else
          v112 = xpc_null_create();
        xpc::dyn_cast_or_default();
        xpc_release(v112);
        v89 = xpc_dictionary_create(0, 0, 0);
        if (v89 || (v89 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A85902BC](v89) == v35)
          {
            xpc_retain(v89);
            v90 = v89;
          }
          else
          {
            v90 = xpc_null_create();
          }
        }
        else
        {
          v90 = xpc_null_create();
          v89 = 0;
        }
        xpc_release(v89);
        v96 = xpc_null_create();
        v97 = *a2;
        *a2 = v90;
        xpc_release(v97);
        xpc_release(v96);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v98 = &__p;
        else
          v98 = (std::string *)__p.__r_.__value_.__r.__words[0];
        v99 = xpc_string_create((const char *)v98);
        if (!v99)
          v99 = xpc_null_create();
        xpc_dictionary_set_value(*a2, "crash", v99);
        v100 = xpc_null_create();
        xpc_release(v99);
        xpc_release(v100);
        if ((buf.st_gid & 0x80000000) == 0)
          p_buf = (const char *)&buf;
        else
          p_buf = *(const char **)&buf.st_dev;
        v102 = xpc_string_create(p_buf);
        if (!v102)
          v102 = xpc_null_create();
        xpc_dictionary_set_value(*a2, "agent", v102);
        v103 = xpc_null_create();
        xpc_release(v102);
        xpc_release(v103);
        if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v104 = &v126;
        else
          v104 = (std::string *)v126.__r_.__value_.__r.__words[0];
        v105 = xpc_string_create((const char *)v104);
        if (!v105)
          v105 = xpc_null_create();
        xpc_dictionary_set_value(*a2, "scu_rstsr", v105);
        v106 = xpc_null_create();
        xpc_release(v105);
        xpc_release(v106);
        if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v126.__r_.__value_.__l.__data_);
        if (SHIBYTE(buf.st_gid) < 0)
          operator delete(*(void **)&buf.st_dev);
        xpc_release(xdict);
        goto LABEL_44;
      }
      v29 = v113;
      if (!v113)
        goto LABEL_44;
      v30 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      v31 = objc_msgSend((id)objc_msgSend(v29, "localizedDescription"), "UTF8String");
      buf.st_dev = 136315138;
      *(_QWORD *)&buf.st_mode = v31;
      v19 = "Error parsing file via return code: %s";
      v20 = v30;
      v21 = 12;
    }
    else
    {
      v18 = *((_QWORD *)this + 5);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      LOWORD(buf.st_dev) = 0;
      v19 = "Error reading file";
      v20 = v18;
      v21 = 2;
    }
    _os_log_error_impl(&dword_1A343C000, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&buf, v21);
    goto LABEL_44;
  }
  v10 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)this + 223) < 0)
      v7 = (_QWORD *)*v7;
    buf.st_dev = 136315138;
    *(_QWORD *)&buf.st_mode = v7;
    _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "File not found: %s", (uint8_t *)&buf, 0xCu);
  }
  v11 = xpc_dictionary_create(0, 0, 0);
  if (v11 || (v11 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A85902BC](v11) == MEMORY[0x1E0C812F8])
    {
      xpc_retain(v11);
      v12 = v11;
    }
    else
    {
      v12 = xpc_null_create();
    }
  }
  else
  {
    v12 = xpc_null_create();
    v11 = 0;
  }
  xpc_release(v11);
  v22 = xpc_null_create();
  v23 = *a2;
  *a2 = v12;
  xpc_release(v23);
  xpc_release(v22);
  *((_BYTE *)&v126.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v126, "report.json");
  v24 = std::string::append(&v126, " missing", 8uLL);
  v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf.st_uid = *((_QWORD *)&v24->__r_.__value_.__l + 2);
  *(_OWORD *)&buf.st_dev = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  if ((buf.st_gid & 0x80000000) == 0)
    v26 = (const char *)&buf;
  else
    v26 = *(const char **)&buf.st_dev;
  v27 = xpc_string_create(v26);
  if (!v27)
    v27 = xpc_null_create();
  xpc_dictionary_set_value(*a2, "ioerror", v27);
  v28 = xpc_null_create();
  xpc_release(v27);
  xpc_release(v28);
  if (SHIBYTE(buf.st_gid) < 0)
  {
    operator delete(*(void **)&buf.st_dev);
    if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_60;
  }
  else if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_60;
  }
  operator delete(v126.__r_.__value_.__l.__data_);
LABEL_60:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  xpc_release(object);
}

void sub_1A3503DD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t object, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,xpc_object_t a26,uint64_t buf,int a28,__int16 a29,uint64_t a30,char a31,char a32)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

xpc_object_t xpc::dict::object_proxy::operator xpc::object(_QWORD *a1, xpc_object_t xdict, char *key)
{
  xpc_object_t value;
  xpc_object_t result;

  value = xpc_dictionary_get_value(xdict, key);
  *a1 = value;
  if (value)
    return xpc_retain(value);
  result = xpc_null_create();
  *a1 = result;
  return result;
}

xpc_object_t xpc::dict::object_proxy::operator=(xpc_object_t *a1, xpc_object_t xdict, char *key, xpc_object_t *a4)
{
  xpc_object_t result;

  xpc_dictionary_set_value(xdict, key, *a4);
  *a1 = *a4;
  result = xpc_null_create();
  *a4 = result;
  return result;
}

uint64_t ICECoredumpTrace::crashBaseband_sync(uint64_t a1)
{
  const void *Controller;
  uint64_t Reset;
  NSObject *v4;
  int v5;
  NSObject *v6;
  _BOOL4 v7;
  uint8_t v9[16];
  const void *v10;
  char v11;

  v11 = 0;
  Controller = (const void *)TelephonyBasebandCreateController();
  v10 = Controller;
  Reset = TelephonyBasebandGetReset();
  if ((Reset & 1) == 0)
  {
    v4 = *(NSObject **)(a1 + 40);
    Reset = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    if ((_DWORD)Reset)
    {
      *(_WORD *)v9 = 0;
      _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Failed to get baseband reset state", v9, 2u);
    }
    v11 = 0;
  }
  v5 = capabilities::coredump::supportsGPIOSignalling((capabilities::coredump *)Reset);
  v6 = *(NSObject **)(a1 + 40);
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      *(_WORD *)v9 = 0;
      _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Crashing baseband (GPIO)", v9, 2u);
    }
    TelephonyBasebandSetModemCoredumpGPIO();
    usleep(0xF4240u);
    TelephonyBasebandSetModemCoredumpGPIO();
  }
  else if (v7)
  {
    *(_WORD *)v9 = 0;
    _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Modem does not support coredump GPIO signalling", v9, 2u);
  }
  if (Controller)
    CFRelease(Controller);
  return 0;
}

void sub_1A350447C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t ICECoredumpTrace::makeCrashString@<X0>(xpc_object_t *a1@<X1>, _BYTE *a2@<X8>)
{
  __int128 v5;
  xpc_object_t value;
  xpc_object_t v7;
  __int128 *v8;
  std::string *p_p;
  std::string::size_type size;
  xpc_object_t v11;
  xpc_object_t v12;
  size_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;
  xpc_object_t v21;
  _BOOL4 v22;
  _QWORD *v23;
  xpc_object_t v24;
  _QWORD *v25;
  xpc_object_t v26;
  std::string *v27;
  std::string::size_type v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  xpc_object_t v32;
  std::string *v33;
  std::string::size_type v34;
  _QWORD *v35;
  _QWORD *v36;
  xpc_object_t v37;
  void *v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  xpc_object_t v42;
  void *p_object;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  xpc_object_t v47;
  void *v48;
  uint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  xpc_object_t v52;
  void *v53;
  uint64_t v54;
  xpc_object_t *v55;
  uint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  xpc_object_t v59;
  xpc_object_t *v60;
  uint64_t v61;
  xpc_object_t v62;
  xpc_object_t v63[2];
  unsigned __int8 v64;
  xpc_object_t v65;
  xpc_object_t v66[2];
  unsigned __int8 v67;
  xpc_object_t v68;
  xpc_object_t v69;
  xpc_object_t v70;
  void *v71;
  uint64_t v72;
  unsigned __int8 v73;
  xpc_object_t object;
  uint64_t v75;
  unsigned __int8 v76;
  std::string __p;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  void *v83[2];
  __int128 v84;
  __int128 v85;
  _OWORD v86[9];
  unint64_t v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;

  v87 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v86[7] = v5;
  v86[8] = v5;
  v86[5] = v5;
  v86[6] = v5;
  v86[3] = v5;
  v86[4] = v5;
  v86[1] = v5;
  v86[2] = v5;
  v85 = v5;
  v86[0] = v5;
  *(_OWORD *)v83 = v5;
  v84 = v5;
  v81 = v5;
  v82 = v5;
  v79 = v5;
  v80 = v5;
  v78 = v5;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v78);
  if (xpc_dictionary_get_value(*a1, "ioerror"))
  {
    memset(&__p, 170, sizeof(__p));
    value = xpc_dictionary_get_value(*a1, "ioerror");
    object = value;
    if (value)
      xpc_retain(value);
    else
      object = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    xpc_release(object);
    v8 = &v79;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
LABEL_27:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (xpc_dictionary_get_value(*a1, "fullreport"))
  {
    memset(&__p, 170, sizeof(__p));
    v7 = xpc_dictionary_get_value(*a1, "fullreport");
    object = v7;
    if (v7)
      xpc_retain(v7);
    else
      object = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    xpc_release(object);
    util::strip_non_printable(&__p);
    v8 = (__int128 *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)"RAW=", 4);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    goto LABEL_27;
  }
  v11 = xpc_dictionary_get_value(*a1, "crash");
  v12 = v11;
  if (v11)
    xpc_retain(v11);
  else
    v12 = xpc_null_create();
  v21 = xpc_string_create("system_no_cddtable");
  if (!v21)
    v21 = xpc_null_create();
  v22 = xpc_equal(v12, v21);
  xpc_release(v21);
  xpc_release(v12);
  if (v22)
  {
    v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)"Missing or corrupt coredump table (", 35);
    v24 = xpc_dictionary_get_value(*a1, "crash");
    v66[0] = v24;
    if (v24)
      xpc_retain(v24);
    else
      v66[0] = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v27 = &__p;
    else
      v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v28 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      v28 = __p.__r_.__value_.__l.__size_;
    v29 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)v27, v28);
    v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)")", 1);
    v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)" agent=", 7);
    v32 = xpc_dictionary_get_value(*a1, "agent");
    v63[0] = v32;
    if (v32)
      xpc_retain(v32);
    else
      v63[0] = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((v76 & 0x80u) == 0)
      p_object = &object;
    else
      p_object = object;
    if ((v76 & 0x80u) == 0)
      v44 = v76;
    else
      v44 = v75;
    v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)p_object, v44);
    v46 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)" scu=", 5);
    v47 = xpc_dictionary_get_value(*a1, "scu_rstsr");
    v70 = v47;
    if (v47)
      xpc_retain(v47);
    else
      v70 = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((v73 & 0x80u) == 0)
      v53 = &v71;
    else
      v53 = v71;
    if ((v73 & 0x80u) == 0)
      v54 = v73;
    else
      v54 = v72;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v46, (uint64_t)v53, v54);
    if ((char)v73 < 0)
      operator delete(v71);
    xpc_release(v70);
    if ((char)v76 < 0)
      operator delete(object);
    xpc_release(v63[0]);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    xpc_release(v66[0]);
  }
  else
  {
    v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)"TASK=", 5);
    v26 = xpc_dictionary_get_value(*a1, "host_taskname");
    v70 = v26;
    if (v26)
      xpc_retain(v26);
    else
      v70 = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v33 = &__p;
    else
      v33 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v34 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      v34 = __p.__r_.__value_.__l.__size_;
    v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)v33, v34);
    v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" @ ", 3);
    v37 = xpc_dictionary_get_value(*a1, "host_filename");
    v69 = v37;
    if (v37)
      xpc_retain(v37);
    else
      v69 = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((v76 & 0x80u) == 0)
      v38 = &object;
    else
      v38 = object;
    if ((v76 & 0x80u) == 0)
      v39 = v76;
    else
      v39 = v75;
    v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)v38, v39);
    v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)":", 1);
    v42 = xpc_dictionary_get_value(*a1, "host_line");
    v68 = v42;
    if (v42)
      xpc_retain(v42);
    else
      v68 = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((v73 & 0x80u) == 0)
      v48 = &v71;
    else
      v48 = v71;
    if ((v73 & 0x80u) == 0)
      v49 = v73;
    else
      v49 = v72;
    v50 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)v48, v49);
    v51 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)",CPU=", 5);
    v52 = xpc_dictionary_get_value(*a1, "host_cpu_id");
    v65 = v52;
    if (v52)
      xpc_retain(v52);
    else
      v65 = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((v67 & 0x80u) == 0)
      v55 = v66;
    else
      v55 = (xpc_object_t *)v66[0];
    if ((v67 & 0x80u) == 0)
      v56 = v67;
    else
      v56 = (uint64_t)v66[1];
    v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)v55, v56);
    v58 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)",LOG=", 5);
    v59 = xpc_dictionary_get_value(*a1, "log_data");
    v62 = v59;
    if (v59)
      xpc_retain(v59);
    else
      v62 = xpc_null_create();
    v88 = 0;
    v89 = 0;
    v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0)
      operator delete(v88);
    if ((v64 & 0x80u) == 0)
      v60 = v63;
    else
      v60 = (xpc_object_t *)v63[0];
    if ((v64 & 0x80u) == 0)
      v61 = v64;
    else
      v61 = (uint64_t)v63[1];
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)v60, v61);
    if ((char)v64 < 0)
      operator delete(v63[0]);
    xpc_release(v62);
    if ((char)v67 < 0)
      operator delete(v66[0]);
    xpc_release(v65);
    if ((char)v73 < 0)
      operator delete(v71);
    xpc_release(v68);
    if ((char)v76 < 0)
      operator delete(object);
    xpc_release(v69);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    xpc_release(v70);
  }
LABEL_29:
  if ((BYTE8(v85) & 0x10) != 0)
  {
    v14 = v85;
    if ((unint64_t)v85 < *((_QWORD *)&v82 + 1))
    {
      *(_QWORD *)&v85 = *((_QWORD *)&v82 + 1);
      v14 = *((_QWORD *)&v82 + 1);
    }
    v15 = (const void *)v82;
    v13 = v14 - v82;
    if ((unint64_t)(v14 - v82) >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_46;
  }
  else
  {
    if ((BYTE8(v85) & 8) == 0)
    {
      v13 = 0;
      a2[23] = 0;
      goto LABEL_42;
    }
    v15 = (const void *)*((_QWORD *)&v80 + 1);
    v13 = *((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1);
    if (*((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
LABEL_46:
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v13 >= 0x17)
  {
    v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v16 = v13 | 7;
    v17 = v16 + 1;
    v18 = operator new(v16 + 1);
    *((_QWORD *)a2 + 1) = v13;
    *((_QWORD *)a2 + 2) = v17 | 0x8000000000000000;
    *(_QWORD *)a2 = v18;
    a2 = v18;
    goto LABEL_41;
  }
  a2[23] = v13;
  if (v13)
LABEL_41:
    memmove(a2, v15, v13);
LABEL_42:
  a2[v13] = 0;
  *(_QWORD *)&v78 = *MEMORY[0x1E0DE4F50];
  v19 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v78 + *(_QWORD *)(v78 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v79 = v19;
  *((_QWORD *)&v79 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v84) < 0)
    operator delete(v83[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A858F92C](v86);
}

void sub_1A3504D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t a16, xpc_object_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,xpc_object_t a24,xpc_object_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,xpc_object_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  if (a15 < 0)
    operator delete(__p);
  xpc_release(object);
  if (a22 < 0)
    operator delete(a17);
  xpc_release(a16);
  if (a31 < 0)
    operator delete(a26);
  xpc_release(a23);
  if (a37 < 0)
    operator delete(a32);
  xpc_release(a24);
  if (a43 < 0)
    operator delete(a38);
  xpc_release(a25);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void ICECoredumpTrace::~ICECoredumpTrace(ICECoredumpTrace *this)
{
  void *v1;

  CoredumpTrace::~CoredumpTrace(this);
  operator delete(v1);
}

_QWORD *std::shared_ptr<ICECoredumpTrace>::shared_ptr[abi:ne180100]<ICECoredumpTrace,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1},void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;

  *a1 = a2;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0BC98;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2)
    return a1;
  v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ != -1)
      return a1;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    *(_QWORD *)(a2 + 72) = a2;
    *(_QWORD *)(a2 + 80) = v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A3505140(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1}::operator() const(ICECoredumpTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A3505160(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<ICECoredumpTrace *,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace *)#1},std::allocator<ICECoredumpTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<ICECoredumpTrace *,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace *)#1},std::allocator<ICECoredumpTrace>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1}::operator() const(ICECoredumpTrace*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<ICECoredumpTrace *,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace *)#1},std::allocator<ICECoredumpTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110share"
                                "d_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1}::operator() const(ICECoredumpTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL trace::isModeActive(int a1)
{
  return !a1 || a1 == 6;
}

const char *trace::toString(unsigned int a1)
{
  if (a1 > 6)
    return "Unknown";
  else
    return off_1E4A0BD38[a1];
}

{
  if (a1 > 3)
    return "unknown";
  else
    return off_1E4A0BD70[a1];
}

{
  if (a1 > 2)
    return "Unknown";
  else
    return off_1E4A0BD90[a1];
}

{
  if (a1 > 3)
    return "Unknown";
  else
    return off_1E4A0BDA8[a1];
}

const char *trace::dal::toString(unsigned int a1)
{
  if (a1 > 6)
    return "TraceLevelUnknown";
  else
    return off_1E4A0BDC8[a1];
}

{
  if (a1 > 2)
    return "TraceModeUnknown";
  else
    return off_1E4A0BE00[a1];
}

std::string *abm::trace::getBasebandTraceDirSuffix@<X0>(abm::trace *this@<X0>, std::string *a2@<X8>)
{
  int v2;
  std::string *result;
  char **v5;

  v2 = (int)this;
  memset(a2, 170, sizeof(std::string));
  *((_BYTE *)&a2->__r_.__value_.__s + 23) = 0;
  a2->__r_.__value_.__s.__data_[0] = 0;
  result = (std::string *)capabilities::radio::vendor(this);
  if (((_DWORD)result - 2) >= 2)
  {
    if ((_DWORD)result != 1)
      return result;
    v5 = abm::trace::kEURTraceSnapshotDirectorySuffix;
    if (v2)
      v5 = abm::trace::kEURQDSSTraceSnapshotDirectorySuffix;
  }
  else
  {
    v5 = abm::trace::kICETraceSnapshotDirectorySuffix;
  }
  return std::string::__assign_external(a2, *v5);
}

void sub_1A3505388(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void abm::trace::getCoreDumpDirSuffix(std::string *a1@<X8>)
{
  unsigned __int8 v3;
  capabilities::radio *v4;
  int v5;
  char **v6;

  if ((v3 & 1) == 0)
  {
    if ((_DWORD)v4)
    {
      v5 = capabilities::radio::maverick(v4);
      v6 = abm::trace::kEURCoreDumpSnapshotDirectorySuffix;
      if (!v5)
        v6 = abm::trace::kCoreDumpSnapshotDirectorySuffix;
      std::string::basic_string[abi:ne180100]<0>(&abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix, *v6);
    }
  }
  if (byte_1EE6C06FF < 0)
  {
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix, *((std::string::size_type *)&abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix + 1));
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix;
    a1->__r_.__value_.__r.__words[2] = unk_1EE6C06F8;
  }
}

void sub_1A350545C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t abm::trace::isSupported(uint64_t a1)
{
  const char *v1;
  int v2;
  capabilities::radio *v3;
  const char *v4;
  capabilities::radio *v5;
  const char *v6;
  capabilities::radio *v7;
  capabilities::trace *v8;
  capabilities::trace *v9;

  v1 = (const char *)a1;
  v2 = *(char *)(a1 + 23);
  if (v2 < 0)
  {
    v3 = (capabilities::radio *)strcasecmp(*(const char **)a1, abm::trace::kDIAG[0]);
    if ((_DWORD)v3)
    {
LABEL_3:
      v4 = v1;
      if ((v2 & 0x80) == 0)
        goto LABEL_4;
      goto LABEL_11;
    }
  }
  else
  {
    v3 = (capabilities::radio *)strcasecmp((const char *)a1, abm::trace::kDIAG[0]);
    if ((_DWORD)v3)
      goto LABEL_3;
  }
  if ((capabilities::radio::maverick(v3) & 1) != 0)
    return 1;
  LOBYTE(v2) = v1[23];
  v4 = v1;
  if ((v2 & 0x80) == 0)
  {
LABEL_4:
    v5 = (capabilities::radio *)strcasecmp(v4, abm::trace::kICETrace[0]);
    if ((_DWORD)v5)
      goto LABEL_5;
LABEL_12:
    if ((capabilities::radio::ice(v5) & 1) != 0)
      return 1;
    LOBYTE(v2) = v1[23];
    if ((v2 & 0x80) == 0)
      goto LABEL_6;
    goto LABEL_14;
  }
LABEL_11:
  v5 = (capabilities::radio *)strcasecmp(*(const char **)v1, abm::trace::kICETrace[0]);
  if (!(_DWORD)v5)
    goto LABEL_12;
LABEL_5:
  if ((v2 & 0x80) == 0)
  {
LABEL_6:
    v6 = v1;
    if (!strcasecmp(v1, (const char *)abm::trace::kBasebandTrace))
      return 1;
    goto LABEL_15;
  }
LABEL_14:
  v6 = *(const char **)v1;
  if (!strcasecmp(*(const char **)v1, (const char *)abm::trace::kBasebandTrace))
    return 1;
LABEL_15:
  v7 = (capabilities::radio *)strcasecmp(v6, abm::trace::kEURCoreDump[0]);
  if ((_DWORD)v7)
  {
    if ((v2 & 0x80) == 0)
      goto LABEL_17;
  }
  else
  {
    if ((capabilities::radio::maverick(v7) & 1) != 0)
      return 1;
    if ((v1[23] & 0x80) == 0)
    {
LABEL_17:
      if (!strcasecmp(v1, (const char *)abm::trace::kCoreDump)
        || !strcasecmp(v1, (const char *)abm::trace::kSystemLogs))
      {
        return 1;
      }
      v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kCompression);
      if (!(_DWORD)v8)
        return capabilities::trace::allowed(v8);
      v9 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kBasebandIPC);
      if ((_DWORD)v9)
      {
        v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kIPC);
        if (!(_DWORD)v8)
          return capabilities::trace::allowed(v8);
        v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kKernelPCI);
        if (!(_DWORD)v8)
          return capabilities::trace::allowed(v8);
        v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTapToRadar);
        if (!(_DWORD)v8)
          return capabilities::trace::allowed(v8);
        goto LABEL_34;
      }
      return capabilities::trace::supportsBasebandIPCTrace(v9);
    }
  }
  v1 = *(const char **)v1;
  if (!strcasecmp(v1, (const char *)abm::trace::kCoreDump) || !strcasecmp(v1, (const char *)abm::trace::kSystemLogs))
    return 1;
  v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kCompression);
  if (!(_DWORD)v8)
    return capabilities::trace::allowed(v8);
  v9 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kBasebandIPC);
  if ((_DWORD)v9)
  {
    v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kIPC);
    if (!(_DWORD)v8)
      return capabilities::trace::allowed(v8);
    v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kKernelPCI);
    if (!(_DWORD)v8)
      return capabilities::trace::allowed(v8);
    v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTapToRadar);
    if (!(_DWORD)v8)
      return capabilities::trace::allowed(v8);
LABEL_34:
    if (strcasecmp(v1, (const char *)abm::trace::kProfile))
    {
      v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTraceTailspin);
      if ((_DWORD)v8)
      {
        v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTraceSettings);
        if ((_DWORD)v8)
        {
          v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTraceFilter);
          if ((_DWORD)v8)
            return 0;
        }
      }
      return capabilities::trace::allowed(v8);
    }
    return 1;
  }
  return capabilities::trace::supportsBasebandIPCTrace(v9);
}

BasebandTransportICE *BasebandTransportICE::BasebandTransportICE(BasebandTransportICE *a1, uint64_t *a2, NSObject **a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  dispatch_object_t object;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v4 = (std::__shared_weak_count *)a2[1];
  v13 = *a2;
  v14 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *a3;
  object = v7;
  if (v7)
    dispatch_retain(v7);
  BasebandTransport::BasebandTransport((uint64_t)a1, &v13, &object);
  if (object)
    dispatch_release(object);
  v8 = v14;
  if (v14)
  {
    v9 = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(_QWORD *)a1 = off_1E4A0BE28;
  *((_QWORD *)a1 + 54) = 0;
  *((_QWORD *)a1 + 58) = 0;
  *((_QWORD *)a1 + 62) = 0;
  *((_QWORD *)a1 + 63) = 0;
  *((_QWORD *)a1 + 64) = dispatch_queue_create("BasebandTransportARI", 0);
  BasebandTransportICE::configurePhysical(a1);
  return a1;
}

void sub_1A350581C(_Unwind_Exception *a1)
{
  BasebandTransport *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v7 = *((_QWORD *)v1 + 64);
  if (v7)
    dispatch_release(v7);
  if ((_QWORD *)*v5 == v4)
  {
    v8 = 4;
  }
  else
  {
    if (!*v5)
      goto LABEL_8;
    v8 = 5;
    v4 = (_QWORD *)*v5;
  }
  (*(void (**)(_QWORD *))(*v4 + 8 * v8))(v4);
LABEL_8:
  v9 = (_QWORD *)*((_QWORD *)v1 + 58);
  if (v9 == v3)
  {
    v10 = 4;
  }
  else
  {
    if (!v9)
      goto LABEL_13;
    v10 = 5;
    v3 = (_QWORD *)*((_QWORD *)v1 + 58);
  }
  (*(void (**)(_QWORD *))(*v3 + 8 * v10))(v3);
LABEL_13:
  v11 = (_QWORD *)*((_QWORD *)v1 + 54);
  if (v11 == v2)
  {
    v12 = 4;
  }
  else
  {
    if (!v11)
      goto LABEL_18;
    v12 = 5;
    v2 = (_QWORD *)*((_QWORD *)v1 + 54);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v12))(v2);
LABEL_18:
  BasebandTransport::~BasebandTransport(v1);
  _Unwind_Resume(a1);
}

void sub_1A35058CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t (***BasebandTransportICE::configurePhysical(BasebandTransportICE *this))()
{
  NSObject *v2;
  uint64_t (***v3)();
  uint64_t v4;
  uint64_t (***v5)();
  uint64_t v6;
  uint64_t (***result)();
  uint64_t v8;
  uint64_t (**v9)();
  BasebandTransportICE *v10;
  uint64_t (***v11)();
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I using physical pipe...", (uint8_t *)&v9, 2u);
  }
  v9 = off_1E4A0C170;
  v10 = this;
  v11 = &v9;
  std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](&v9, (_QWORD *)this + 59);
  v3 = v11;
  if (v11 == &v9)
  {
    v4 = 4;
    v3 = &v9;
  }
  else
  {
    if (!v11)
      goto LABEL_8;
    v4 = 5;
  }
  (*v3)[v4]();
LABEL_8:
  v9 = off_1E4A0C1F0;
  v10 = this;
  v11 = &v9;
  std::__function::__value_func<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v9, (_QWORD *)this + 55);
  v5 = v11;
  if (v11 == &v9)
  {
    v6 = 4;
    v5 = &v9;
  }
  else
  {
    if (!v11)
      goto LABEL_13;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_13:
  v9 = off_1E4A0C270;
  v10 = this;
  v11 = &v9;
  std::__function::__value_func<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v9, (_QWORD *)this + 51);
  result = v11;
  if (v11 == &v9)
  {
    v8 = 4;
    result = &v9;
  }
  else
  {
    if (!v11)
      return result;
    v8 = 5;
  }
  return (uint64_t (***)())(*result)[v8]();
}

uint64_t (***BasebandTransportICE::configureARIPipe(BasebandTransportICE *this))()
{
  NSObject *v2;
  uint64_t (***v3)();
  uint64_t v4;
  uint64_t (***v5)();
  uint64_t v6;
  uint64_t (***result)();
  uint64_t v8;
  uint64_t (**v9)();
  BasebandTransportICE *v10;
  uint64_t (***v11)();
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I using ARI client pipe...", (uint8_t *)&v9, 2u);
  }
  v9 = off_1E4A0BF78;
  v10 = this;
  v11 = &v9;
  std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](&v9, (_QWORD *)this + 59);
  v3 = v11;
  if (v11 == &v9)
  {
    v4 = 4;
    v3 = &v9;
  }
  else
  {
    if (!v11)
      goto LABEL_8;
    v4 = 5;
  }
  (*v3)[v4]();
LABEL_8:
  v9 = off_1E4A0C008;
  v11 = &v9;
  std::__function::__value_func<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v9, (_QWORD *)this + 55);
  v5 = v11;
  if (v11 == &v9)
  {
    v6 = 4;
    v5 = &v9;
  }
  else
  {
    if (!v11)
      goto LABEL_13;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_13:
  v9 = off_1E4A0C098;
  v10 = this;
  v11 = &v9;
  std::__function::__value_func<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v9, (_QWORD *)this + 51);
  result = v11;
  if (v11 == &v9)
  {
    v8 = 4;
    result = &v9;
  }
  else
  {
    if (!v11)
      return result;
    v8 = 5;
  }
  return (uint64_t (***)())(*result)[v8]();
}

uint64_t BasebandTransportICE::open(BasebandTransport *a1, uint64_t *a2, const void **a3)
{
  uint64_t v6;
  void *v7;
  __int128 v8;
  void *v9;
  BOOL v10;
  _BOOL8 v11;
  NSObject *v12;
  __int128 v13;
  void *v14;
  void *v16;
  __int128 v17[2];
  uint64_t v18;
  void *v19;
  __int128 v20[2];
  uint64_t v21;
  uint8_t buf[16];
  void *v23;
  __int128 v24[2];
  uint64_t v25;

  if (*(_DWORD *)a2 != 8)
  {
    v8 = *((_OWORD *)a2 + 1);
    v17[0] = *(_OWORD *)a2;
    v17[1] = v8;
    v18 = a2[4];
    if (*a3)
      v9 = _Block_copy(*a3);
    else
      v9 = 0;
    v16 = v9;
    v11 = BasebandTransport::open(a1, v17, &v16);
    if (v9)
      _Block_release(v9);
    goto LABEL_23;
  }
  v6 = *a2;
  v24[1] = *((_OWORD *)a2 + 1);
  v25 = a2[4];
  *(_QWORD *)&v24[0] = v6;
  *((_QWORD *)&v24[0] + 1) = 1;
  if (*a3)
    v7 = _Block_copy(*a3);
  else
    v7 = 0;
  v23 = v7;
  v10 = BasebandTransport::open(a1, v24, &v23);
  if (v7)
    _Block_release(v7);
  if (v10)
  {
    v11 = 1;
LABEL_23:
    BasebandTransportICE::configurePhysical(a1);
    return v11;
  }
  v12 = *((_QWORD *)a1 + 5);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEFAULT, "#I Physical transport not available.  Trying ARI pipe...", buf, 2u);
  }
  v13 = *((_OWORD *)a2 + 1);
  v20[0] = *(_OWORD *)a2;
  v20[1] = v13;
  v21 = a2[4];
  if (*a3)
    v14 = _Block_copy(*a3);
  else
    v14 = 0;
  v19 = v14;
  v11 = BasebandTransportICE::openARIClientPipe((uint64_t)a1, v20, &v19);
  if (v14)
    _Block_release(v14);
  if (!v11)
    goto LABEL_23;
  BasebandTransportICE::configureARIPipe(a1);
  return 1;
}

void sub_1A3505D7C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    _Block_release(v1);
  _Unwind_Resume(exception_object);
}

BOOL BasebandTransportICE::openARIClientPipe(uint64_t a1, __int128 *a2, void **a3)
{
  _QWORD *v3;
  __int128 v6;
  __int128 v7;
  void *v8;
  const void *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  int *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  int v19;
  _BOOL8 v20;
  NSObject *v21;
  const char *v22;
  int v23;
  std::__shared_weak_count *v24;
  unint64_t v26;
  _QWORD v27[2];
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = a2[1];
  *(_BYTE *)(a1 + 136) = *((_BYTE *)a2 + 32);
  *(_OWORD *)(a1 + 120) = v7;
  *(_OWORD *)(a1 + 104) = v6;
  v8 = *a3;
  if (*a3)
    v8 = _Block_copy(v8);
  v9 = *(const void **)(a1 + 144);
  *(_QWORD *)(a1 + 144) = v8;
  if (v9)
    _Block_release(v9);
  *(_DWORD *)(a1 + 504) = 0;
  v10 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v10 || (v11 = *(_QWORD *)(a1 + 72), (v12 = std::__shared_weak_count::lock(v10)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v13 = v12;
  v14 = (int *)(a1 + 504);
  p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
  do
    v16 = __ldxr(p_shared_weak_owners);
  while (__stxr(v16 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v13);
  }
  v19 = AriHost::RegisterClient((AriHost *)"ipc.bb", (const char *)(a1 + 504), *(int **)(a1 + 512), (dispatch_queue_s *)(1000 * *((_DWORD *)a2 + 2)));
  if (v19)
  {
    v20 = 0;
    v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      goto LABEL_18;
  }
  else
  {
    v3 = v27;
    v27[0] = v11;
    v27[1] = v13;
    do
      v26 = __ldxr(p_shared_weak_owners);
    while (__stxr(v26 + 1, p_shared_weak_owners));
    v20 = AriHost::SetRTEventHandler() == 0;
    v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      goto LABEL_18;
  }
  v22 = "fail";
  v23 = *v14;
  if (v20)
    v22 = "success";
  *(_DWORD *)buf = 136315394;
  v29 = v22;
  v30 = 1024;
  v31 = v23;
  _os_log_impl(&dword_1A343C000, v21, OS_LOG_TYPE_DEFAULT, "#I ARI pipe open %s ctx 0x%x", buf, 0x12u);
LABEL_18:
  if (!v19)
  {
    v24 = (std::__shared_weak_count *)v3[1];
    if (v24)
      std::__shared_weak_count::__release_weak(v24);
  }
  std::__shared_weak_count::__release_weak(v13);
  return v20;
}

void sub_1A3506018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  std::__shared_weak_count *v16;

  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransportICE::write(BasebandTransportICE *this, const unsigned __int8 *a2, uint64_t a3, unsigned int *a4, char a5, int a6)
{
  uint64_t v6;
  int v8;
  char v9;
  unsigned int *v10;
  uint64_t v11;
  const unsigned __int8 *v12;

  v12 = a2;
  v10 = a4;
  v11 = a3;
  v9 = a5;
  v8 = a6;
  v6 = *((_QWORD *)this + 54);
  if (!v6)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, const unsigned __int8 **, uint64_t *, unsigned int **, char *, int *))(*(_QWORD *)v6 + 48))(v6, &v12, &v11, &v10, &v9, &v8);
}

uint64_t BasebandTransportICE::read(BasebandTransportICE *this, unsigned __int8 *a2, uint64_t a3, unsigned int *a4, char a5, int a6)
{
  uint64_t v6;
  int v8;
  char v9;
  unsigned int *v10;
  uint64_t v11;
  unsigned __int8 *v12;

  v12 = a2;
  v10 = a4;
  v11 = a3;
  v9 = a5;
  v8 = a6;
  v6 = *((_QWORD *)this + 58);
  if (!v6)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, unsigned __int8 **, uint64_t *, unsigned int **, char *, int *))(*(_QWORD *)v6 + 48))(v6, &v12, &v11, &v10, &v9, &v8);
}

uint64_t BasebandTransportICE::close_sync(BasebandTransportICE *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 62);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN20BasebandTransportICE17openARIClientPipeEN17BasebandTransport10ParametersEN8dispatch5blockIU13block_pointerFvPhjEEE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  NSObject *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _BYTE __p[12];
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = v4;
  if (a1[5])
  {
    v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136315138;
      *(_QWORD *)&__p[4] = "ipc.bb";
      _os_log_error_impl(&dword_1A343C000, v6, OS_LOG_TYPE_ERROR, "Got AriHost::ARI_RT_REINIT callback for %s", __p, 0xCu);
    }
    v12 = 6;
    strcpy(__p, "ipc.bb");
    AriHost::ReRegisterClient();
    if (v12 < 0)
      operator delete(*(void **)__p);
    v7 = 0;
  }
  else
  {
    v7 = 0xFFFFFFFFLL;
  }
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return v7;
}

void sub_1A3506278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL BasebandTransportICE::writeARIClientPipe(BasebandTransportICE *this, const unsigned __int8 *a2, uint64_t a3, unsigned int *a4)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  int started;
  std::__shared_weak_count *v16;
  NSObject *v17;
  unint64_t v18;
  uint8_t buf[4];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (!v5 || (v8 = std::__shared_weak_count::lock(v5)) == 0)
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
  do
    v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
  {
    if (*((_DWORD *)this + 127))
    {
      do
LABEL_9:
        v14 = __ldxr(p_shared_weak_owners);
      while (__stxr(v14 + 1, p_shared_weak_owners));
      started = AriHost::Send();
      v16 = v9;
      goto LABEL_11;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v9);
    if (*((_DWORD *)this + 127))
      goto LABEL_9;
  }
  do
    v18 = __ldxr(p_shared_weak_owners);
  while (__stxr(v18 + 1, p_shared_weak_owners));
  started = AriHost::StartStream();
  v16 = v9;
LABEL_11:
  std::__shared_weak_count::__release_weak(v16);
  if (started)
  {
    v17 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v21 = a3;
      _os_log_error_impl(&dword_1A343C000, v17, OS_LOG_TYPE_ERROR, "Failed to send %zu bytes on ARI pipe", buf, 0xCu);
    }
  }
  else if (a4)
  {
    *a4 = a3;
  }
  std::__shared_weak_count::__release_weak(v9);
  return started == 0;
}

void sub_1A35064D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  std::__shared_weak_count *v22;

  if (a15)
    std::__shared_weak_count::__release_weak(a15);
  std::__shared_weak_count::__release_weak(v22);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke(_QWORD *a1, uint64_t a2, int a3)
{
  std::__shared_weak_count *v4;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _QWORD block[6];
  int v15;

  v4 = (std::__shared_weak_count *)a1[6];
  if (!v4)
    return 0xFFFFFFFFLL;
  v7 = a1[4];
  v8 = std::__shared_weak_count::lock(v4);
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = v8;
  if (a1[5])
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2;
    block[3] = &__block_descriptor_tmp_5_3;
    block[4] = v7;
    block[5] = a2;
    v15 = a3;
    dispatch_async(*(dispatch_queue_t *)(v7 + 152), block);
    v10 = 0;
  }
  else
  {
    v10 = 0xFFFFFFFFLL;
  }
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v10;
}

void ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  size_t v5;
  void *v6;
  const void *v7;
  size_t v8;
  void *v9;
  void *__p;
  _BYTE *v11;
  uint64_t v12;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 128);
  if (v3)
  {
    __p = 0;
    v11 = 0;
    v12 = 0;
    (*(void (**)(uint64_t, _QWORD, _QWORD, void **))(*(_QWORD *)v3 + 8))(v3, *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48), &__p);
    v4 = __p;
    v5 = v11 - (_BYTE *)__p;
    if (*(_BYTE *)(v2 + 136))
    {
      v6 = malloc_type_malloc(v11 - (_BYTE *)__p, 0x6FF6341AuLL);
      memcpy(v6, v4, v5);
    }
    (*(void (**)(void))(*(_QWORD *)(v2 + 144) + 16))();
    if (__p)
    {
      v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v7 = *(const void **)(a1 + 40);
    v8 = *(unsigned int *)(a1 + 48);
    if (*(_BYTE *)(v2 + 136))
    {
      v9 = malloc_type_malloc(v8, 0x6FF6341AuLL);
      memcpy(v9, v7, v8);
    }
    (*(void (**)(void))(*(_QWORD *)(v2 + 144) + 16))();
  }
}

void sub_1A350670C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t BasebandTransportICE::sendToDataHandler(BasebandTransportICE *this, unsigned __int8 *a2, size_t size)
{
  void *v6;

  if (!*((_BYTE *)this + 136))
    return (*(uint64_t (**)(void))(*((_QWORD *)this + 18) + 16))();
  v6 = malloc_type_malloc(size, 0x6FF6341AuLL);
  memcpy(v6, a2, size);
  return (*(uint64_t (**)(void))(*((_QWORD *)this + 18) + 16))();
}

uint64_t ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_8(_QWORD *a1, AriMsg *a2, unsigned int a3)
{
  std::__shared_weak_count *v4;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  int BufCtx;
  NSObject *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD block[6];
  unsigned int v17;
  std::__shared_weak_count *v19;
  uint8_t buf[4];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = (std::__shared_weak_count *)a1[6];
  if (!v4)
    return 0xFFFFFFFFLL;
  v7 = a1[4];
  v8 = std::__shared_weak_count::lock(v4);
  v19 = v8;
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = v8;
  if (a1[5])
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2_9;
    block[3] = &__block_descriptor_tmp_10_3;
    block[4] = v7;
    block[5] = a2;
    v17 = a3;
    dispatch_async(*(dispatch_queue_t *)(v7 + 152), block);
    BufCtx = AriMsg::GetBufCtx(a2, (const unsigned __int8 *)a3);
    *(_DWORD *)(v7 + 508) = BufCtx;
    v11 = *(NSObject **)(v7 + 40);
    v12 = 0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v21 = BufCtx;
      _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I bypass will use ctx id 0x%x", buf, 8u);
      v12 = 0;
    }
  }
  else
  {
    v12 = 0xFFFFFFFFLL;
  }
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v12;
}

void sub_1A3506924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2_9(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  size_t v5;
  void *v6;
  const void *v7;
  size_t v8;
  void *v9;
  void *__p;
  _BYTE *v11;
  uint64_t v12;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 128);
  if (v3)
  {
    __p = 0;
    v11 = 0;
    v12 = 0;
    (*(void (**)(uint64_t, _QWORD, _QWORD, void **))(*(_QWORD *)v3 + 8))(v3, *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48), &__p);
    v4 = __p;
    v5 = v11 - (_BYTE *)__p;
    if (*(_BYTE *)(v2 + 136))
    {
      v6 = malloc_type_malloc(v11 - (_BYTE *)__p, 0x6FF6341AuLL);
      memcpy(v6, v4, v5);
    }
    (*(void (**)(void))(*(_QWORD *)(v2 + 144) + 16))();
    if (__p)
    {
      v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v7 = *(const void **)(a1 + 40);
    v8 = *(unsigned int *)(a1 + 48);
    if (*(_BYTE *)(v2 + 136))
    {
      v9 = malloc_type_malloc(v8, 0x6FF6341AuLL);
      memcpy(v9, v7, v8);
    }
    (*(void (**)(void))(*(_QWORD *)(v2 + 144) + 16))();
  }
}

void sub_1A3506A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t BasebandTransportICE::closeARIClientPipe_sync(BasebandTransportICE *this)
{
  AriHost::EndStream((AriHost *)*((unsigned int *)this + 127));
  *((_DWORD *)this + 127) = 0;
  AriHost::DeregisterClient((AriHost *)*((unsigned int *)this + 126));
  *((_DWORD *)this + 126) = 0;
  return 1;
}

void BasebandTransportICE::~BasebandTransportICE(BasebandTransportICE *this)
{
  NSObject *v2;
  BasebandTransportICE *v3;
  uint64_t v4;
  BasebandTransportICE *v5;
  uint64_t v6;
  BasebandTransportICE *v7;
  uint64_t v8;

  *(_QWORD *)this = off_1E4A0BE28;
  v2 = *((_QWORD *)this + 64);
  if (v2)
    dispatch_release(v2);
  v3 = (BasebandTransportICE *)*((_QWORD *)this + 62);
  if (v3 == (BasebandTransportICE *)((char *)this + 472))
  {
    v4 = 4;
    v3 = (BasebandTransportICE *)((char *)this + 472);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (BasebandTransportICE *)*((_QWORD *)this + 58);
  if (v5 == (BasebandTransportICE *)((char *)this + 440))
  {
    v6 = 4;
    v5 = (BasebandTransportICE *)((char *)this + 440);
  }
  else
  {
    if (!v5)
      goto LABEL_13;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
LABEL_13:
  v7 = (BasebandTransportICE *)*((_QWORD *)this + 54);
  if (v7 == (BasebandTransportICE *)((char *)this + 408))
  {
    v8 = 4;
    v7 = (BasebandTransportICE *)((char *)this + 408);
    goto LABEL_17;
  }
  if (v7)
  {
    v8 = 5;
LABEL_17:
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
  }
  BasebandTransport::~BasebandTransport(this);
}

{
  NSObject *v2;
  BasebandTransportICE *v3;
  uint64_t v4;
  BasebandTransportICE *v5;
  uint64_t v6;
  BasebandTransportICE *v7;
  uint64_t v8;
  void *v9;

  *(_QWORD *)this = off_1E4A0BE28;
  v2 = *((_QWORD *)this + 64);
  if (v2)
    dispatch_release(v2);
  v3 = (BasebandTransportICE *)*((_QWORD *)this + 62);
  if (v3 == (BasebandTransportICE *)((char *)this + 472))
  {
    v4 = 4;
    v3 = (BasebandTransportICE *)((char *)this + 472);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (BasebandTransportICE *)*((_QWORD *)this + 58);
  if (v5 == (BasebandTransportICE *)((char *)this + 440))
  {
    v6 = 4;
    v5 = (BasebandTransportICE *)((char *)this + 440);
  }
  else
  {
    if (!v5)
      goto LABEL_13;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
LABEL_13:
  v7 = (BasebandTransportICE *)*((_QWORD *)this + 54);
  if (v7 == (BasebandTransportICE *)((char *)this + 408))
  {
    v8 = 4;
    v7 = (BasebandTransportICE *)((char *)this + 408);
    goto LABEL_17;
  }
  if (v7)
  {
    v8 = 5;
LABEL_17:
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
  }
  BasebandTransport::~BasebandTransport(this);
  operator delete(v9);
}

_QWORD *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E4A0BF78;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E4A0BF78;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  AriHost::EndStream((AriHost *)*(unsigned int *)(v1 + 508));
  *(_DWORD *)(v1 + 508) = 0;
  AriHost::DeregisterClient((AriHost *)*(unsigned int *)(v1 + 504));
  *(_DWORD *)(v1 + 504) = 0;
  return 1;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE16configureARIPipeEvE3$_0")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE16configureARIPipeEvE3$_0"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::target_type()
{
}

_QWORD *std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1A3506EF0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1E4A0C008;
  return result;
}

void std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E4A0C008;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  **a4 = 0;
  return 0;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE16configureARIPipeEvE3$_1")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE16configureARIPipeEvE3$_1"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

_QWORD *std::__function::__value_func<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1A3507168(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E4A0C098;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E4A0C098;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3, unsigned int **a4)
{
  BasebandTransportICE *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  NSObject *v8;
  uint64_t v9;
  _BOOL8 v10;
  _QWORD v12[10];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[5];
  void *__p;
  void *v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD block[6];

  v4 = *(BasebandTransportICE **)(a1 + 8);
  v5 = *a2;
  v6 = *a3;
  v7 = *a4;
  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x4002000000;
  v21[3] = __Block_byref_object_copy__1;
  v21[4] = __Block_byref_object_dispose__1;
  v23 = 0;
  v24 = 0;
  __p = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = v5;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = v6;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = ___ZZN20BasebandTransportICE16configureARIPipeEvENK3__2clEPKhmPjbj_block_invoke;
  v12[3] = &unk_1E4A0C110;
  v12[8] = v5;
  v12[9] = v6;
  v12[4] = v21;
  v12[5] = &v17;
  v12[6] = &v13;
  v12[7] = v4;
  v25 = v12;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_0;
  block[3] = &__block_descriptor_tmp_14_3;
  block[4] = (char *)v4 + 72;
  block[5] = &v25;
  v8 = *((_QWORD *)v4 + 11);
  if (*((_QWORD *)v4 + 12))
  {
    dispatch_async_and_wait(v8, block);
    v9 = v14[3];
    if (v9)
    {
LABEL_3:
      v10 = BasebandTransportICE::writeARIClientPipe(v4, (const unsigned __int8 *)v18[3], v9, v7);
      goto LABEL_6;
    }
  }
  else
  {
    dispatch_sync(v8, block);
    v9 = v14[3];
    if (v9)
      goto LABEL_3;
  }
  v10 = 1;
LABEL_6:
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  if (__p)
  {
    v23 = __p;
    operator delete(__p);
  }
  return v10;
}

void sub_1A3507348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a28, 8);
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE16configureARIPipeEvE3$_2")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_2" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE16configureARIPipeEvE3$_2"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

__n128 __Block_byref_object_copy__1(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

_QWORD *std::__function::__value_func<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1A3507660(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E4A0C170;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E4A0C170;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  return BasebandTransport::close_sync(*(BasebandTransport **)(a1 + 8));
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE17configurePhysicalEvE3$_0")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE17configurePhysicalEvE3$_0"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::target_type()
{
}

_QWORD *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E4A0C1F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E4A0C1F0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, unsigned __int8 **a2, unint64_t *a3, unsigned int **a4)
{
  return BasebandTransport::read(*(BasebandTransport **)(a1 + 8), *a2, *a3, *a4);
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE17configurePhysicalEvE3$_1")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE17configurePhysicalEvE3$_1"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

_QWORD *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E4A0C270;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E4A0C270;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, const unsigned __int8 **a2, uint64_t *a3, unsigned int **a4)
{
  return BasebandTransport::write(*(BasebandTransport **)(a1 + 8), *a2, *a3, *a4);
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE17configurePhysicalEvE3$_2")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_2" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE17configurePhysicalEvE3$_2"))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

void abm::CellularLoggingINT::create(uint64_t *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, _QWORD *a4@<X8>)
{
  std::allocate_shared[abi:ne180100]<abm::CellularLoggingINT,std::allocator<abm::CellularLoggingINT>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(a1, a2, a3, a4);
}

uint64_t abm::CellularLoggingINT::CellularLoggingINT(uint64_t a1, uint64_t *a2, uint64_t *a3, dispatch_object_t *a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  NSObject *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v22;
  std::__shared_weak_count *v23;
  const char *v24;

  v5 = (std::__shared_weak_count *)a2[1];
  v22 = *a2;
  v23 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *a3;
  v8 = (std::__shared_weak_count *)a3[1];
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v11 = __ldxr(p_shared_weak_owners);
    while (__stxr(v11 + 1, p_shared_weak_owners));
  }
  v12 = *a4;
  if (*a4)
    dispatch_retain(*a4);
  *(_QWORD *)a1 = off_1E4A0B6E8;
  v24 = "carriercellularlogging.modem";
  ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>((_QWORD *)a1, &v24, &v22);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)a1 = off_1E4A0B6E8;
  *(_QWORD *)(a1 + 88) = v9;
  *(_QWORD *)(a1 + 96) = v8;
  if (v8)
  {
    v13 = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = v23;
  *(_QWORD *)(a1 + 104) = v22;
  *(_QWORD *)(a1 + 112) = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  *(_QWORD *)(a1 + 120) = v12;
  if (v12)
  {
    dispatch_retain(v12);
    dispatch_release(v12);
  }
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  v18 = v23;
  if (v23)
  {
    v19 = (unint64_t *)&v23->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  *(_QWORD *)a1 = off_1E4A0C2F0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 232) = 3;
  return a1;
}

void sub_1A3507AC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::__shared_weak_count *v10;
  NSObject *v11;

  if (v11)
  {
    dispatch_release(v11);
    if (!v10)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
      _Unwind_Resume(a1);
    }
  }
  else if (!v10)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingINT::~CellularLoggingINT(void **this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;

  *this = off_1E4A0C2F0;
  if (*((char *)this + 223) < 0)
  {
    operator delete(this[25]);
    v2 = (std::__shared_weak_count *)this[23];
    if (!v2)
      goto LABEL_8;
  }
  else
  {
    v2 = (std::__shared_weak_count *)this[23];
    if (!v2)
      goto LABEL_8;
  }
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (v4)
  {
LABEL_8:
    if ((*((char *)this + 175) & 0x80000000) == 0)
      goto LABEL_9;
    goto LABEL_12;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if ((*((char *)this + 175) & 0x80000000) == 0)
  {
LABEL_9:
    v5 = (std::__shared_weak_count *)this[17];
    if (!v5)
      goto LABEL_16;
    goto LABEL_13;
  }
LABEL_12:
  operator delete(this[19]);
  v5 = (std::__shared_weak_count *)this[17];
  if (!v5)
    goto LABEL_16;
LABEL_13:
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    *this = off_1E4A0B6E8;
    v8 = this[15];
    if (!v8)
      goto LABEL_18;
    goto LABEL_17;
  }
LABEL_16:
  *this = off_1E4A0B6E8;
  v8 = this[15];
  if (v8)
LABEL_17:
    dispatch_release(v8);
LABEL_18:
  v9 = (std::__shared_weak_count *)this[14];
  if (!v9)
    goto LABEL_22;
  v10 = (unint64_t *)&v9->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (v11)
  {
LABEL_22:
    v12 = (std::__shared_weak_count *)this[12];
    if (!v12)
      goto LABEL_24;
    goto LABEL_23;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  v12 = (std::__shared_weak_count *)this[12];
  if (v12)
LABEL_23:
    std::__shared_weak_count::__release_weak(v12);
LABEL_24:
  v13 = (std::__shared_weak_count *)this[10];
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  *this = off_1E4A0B858;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
}

{
  void *v1;

  abm::CellularLoggingINT::~CellularLoggingINT(this);
  operator delete(v1);
}

uint64_t abm::CellularLoggingINT::start(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v4;
  BOOL v5;
  int v6;
  int v7;
  xpc_object_t value;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  unsigned int v12;
  const char *v13;
  unsigned int v14;
  const char *v15;
  NSObject *v16;
  uint64_t v17;
  const char *v18;
  _BOOL4 v19;
  NSObject *v20;
  const char *v21;
  xpc_object_t v22;
  void **v23;
  NSObject *v24;
  std::string *v25;
  void *v26;
  int *v27;
  xpc_object_t v28;
  NSObject *v29;
  std::string *v30;
  int v31;
  xpc_object_t v32;
  unsigned int v33;
  capabilities::radio *v34;
  capabilities::abs *v35;
  unsigned int v36;
  NSObject *v37;
  _BOOL8 v38;
  unsigned int v39;
  capabilities::abs *v40;
  int v41;
  const char *v42;
  NSObject *v43;
  uint32_t v44;
  unsigned int v45;
  NSObject *v46;
  size_t v47;
  void *v48;
  void **v49;
  xpc_object_t v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  size_t v55;
  void *v56;
  void *v57;
  unsigned int v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  _BOOL4 v62;
  char *v63;
  BOOL v64;
  char *__src;
  std::string v66;
  void *v67[2];
  char v68;
  std::string v69;
  void *v70[2];
  char v71;
  std::string v72;
  void *v73[2];
  char v74;
  std::string v75;
  void *v76[2];
  char v77;
  std::string v78;
  void *v79[2];
  char v80;
  std::string v81;
  void *v82[2];
  char v83;
  std::string v84;
  void *v85[2];
  char v86;
  void *v87[2];
  uint64_t v88;
  void *v89[2];
  char v90;
  void *v91[2];
  uint64_t v92;
  void *v93[2];
  char v94;
  void *v95[2];
  unint64_t v96;
  void *v97[2];
  char v98;
  void *v99[2];
  uint64_t v100;
  void *__dst[2];
  unint64_t v102;
  void *v103[2];
  char v104;
  void *v105[2];
  char v106;
  xpc_object_t object;
  void *__p[2];
  char v109;
  BOOL v110;
  void *v111[2];
  char v112;
  void *v113[2];
  char v114;
  void *v115[4];
  std::string v116;
  uint64_t v117;
  _BYTE buf[28];
  __int16 v119;
  unsigned int v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  if (*a2)
    xpc_retain(*a2);
  else
    v4 = xpc_null_create();
  v5 = abm::CellularLoggingCommon::start();
  xpc_release(v4);
  v117 = 0;
  if (v5)
  {
    memset(&v116, 170, sizeof(v116));
    HIBYTE(v115[2]) = 19;
    strcpy((char *)v115, "Live_Filter_Setting");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v115, &v116);
    if (SHIBYTE(v115[2]) < 0)
      operator delete(v115[0]);
    *(_DWORD *)buf = -1431655766;
    v6 = util::convert<int>(&v116, buf, 0);
    v7 = *(_DWORD *)buf;
    if (!v6)
      v7 = 0;
    *(_DWORD *)(a1 + 228) = v7;
    value = xpc_dictionary_get_value(*a2, "kKeyLiveFilterSetting");
    *(_QWORD *)buf = value;
    if (value)
      xpc_retain(value);
    else
      *(_QWORD *)buf = xpc_null_create();
    *(_DWORD *)(a1 + 232) = xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)buf);
    v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
LABEL_22:
      v114 = 4;
      strcpy((char *)v113, "Mode");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v113, (std::string *)buf);
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v116.__r_.__value_.__l.__data_);
      v116 = *(std::string *)buf;
      buf[23] = 0;
      buf[0] = 0;
      if (v114 < 0)
        operator delete(v113[0]);
      *(_DWORD *)buf = -1431655766;
      if (util::convert<int>(&v116, buf, 0))
        *(_DWORD *)(a1 + 192) = *(_DWORD *)buf;
      v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = *(int *)(a1 + 192);
        if (v17 > 6)
          v18 = "Unknown";
        else
          v18 = off_1E4A0C4E0[v17];
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v18;
        _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#I Previous trace mode: %s", buf, 0xCu);
      }
      v112 = 7;
      strcpy((char *)v111, "Enabled");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v111, (std::string *)buf);
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v116.__r_.__value_.__l.__data_);
      v116 = *(std::string *)buf;
      buf[23] = 0;
      buf[0] = 0;
      if (v112 < 0)
        operator delete(v111[0]);
      v110 = 0;
      util::convert<BOOL>(&v116, &v110, 0);
      v19 = v110;
      *(_BYTE *)(a1 + 144) = v110;
      v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = "true";
        if (!v19)
          v21 = "false";
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v21;
        _os_log_impl(&dword_1A343C000, v20, OS_LOG_TYPE_DEFAULT, "#I Previous trace enabled: %s", buf, 0xCu);
      }
      v109 = 4;
      strcpy((char *)__p, "File");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)__p, (std::string *)buf);
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v116.__r_.__value_.__l.__data_);
      v116 = *(std::string *)buf;
      buf[23] = 0;
      buf[0] = 0;
      if (v109 < 0)
        operator delete(__p[0]);
      v22 = xpc_dictionary_get_value(*a2, "kKeyConfigName");
      object = v22;
      if (v22)
        xpc_retain(v22);
      else
        object = xpc_null_create();
      xpc::dyn_cast_or_default();
      v23 = (void **)(a1 + 200);
      if (*(char *)(a1 + 223) < 0)
        operator delete(*v23);
      *(_OWORD *)v23 = *(_OWORD *)buf;
      *(_QWORD *)(a1 + 216) = *(_QWORD *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;
      xpc_release(object);
      v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = &v116;
        if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v25 = (std::string *)v116.__r_.__value_.__r.__words[0];
        v26 = (void *)(a1 + 200);
        if (*(char *)(a1 + 223) < 0)
          v26 = *v23;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v25;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v26;
        _os_log_impl(&dword_1A343C000, v24, OS_LOG_TYPE_DEFAULT, "#I Previous trace primary config: %s, Current trace config: %s", buf, 0x16u);
      }
      v106 = 7;
      strcpy((char *)v105, "History");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v105, (std::string *)buf);
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v116.__r_.__value_.__l.__data_);
      v116 = *(std::string *)buf;
      buf[23] = 0;
      buf[0] = 0;
      if (v106 < 0)
        operator delete(v105[0]);
      v27 = (int *)(a1 + 196);
      util::convert<int>(&v116, (_DWORD *)(a1 + 196), 0);
      v28 = xpc_dictionary_get_value(*a2, "kKeyConfigHistory");
      *(_QWORD *)buf = v28;
      if (v28)
        xpc_retain(v28);
      else
        *(_QWORD *)buf = xpc_null_create();
      *v27 = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      v29 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        v30 = &v116;
        if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v30 = (std::string *)v116.__r_.__value_.__r.__words[0];
        v31 = *v27;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v30;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v31;
        _os_log_impl(&dword_1A343C000, v29, OS_LOG_TYPE_DEFAULT, "#I Previous trace history size: %s, Current trace history size: %d", buf, 0x12u);
      }
      v104 = 8;
      strcpy((char *)v103, "FileSize");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v103, (std::string *)buf);
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v116.__r_.__value_.__l.__data_);
      v116 = *(std::string *)buf;
      buf[23] = 0;
      buf[0] = 0;
      if (v104 < 0)
        operator delete(v103[0]);
      LODWORD(object) = 0;
      util::convert<unsigned int>(&v116, &object, 0);
      v32 = xpc_dictionary_get_value(*a2, "kKeyFileSize");
      *(_QWORD *)buf = v32;
      if (v32)
        xpc_retain(v32);
      else
        *(_QWORD *)buf = xpc_null_create();
      *(_DWORD *)(a1 + 224) = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      v33 = *(_DWORD *)(a1 + 224);
      v35 = (capabilities::abs *)capabilities::radio::vendor(v34);
      if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v35))
        v36 = 0x4000;
      else
        v36 = 0x8000;
      if (v33 < v36)
      {
        v37 = *(NSObject **)(a1 + 40);
        v38 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
        if (v38)
        {
          v39 = *(_DWORD *)(a1 + 224);
          v40 = (capabilities::abs *)capabilities::radio::vendor((capabilities::radio *)v38);
          if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v40))
            v41 = 16;
          else
            v41 = 32;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v39 >> 10;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v41;
          v42 = "The Given file size %u KB is less than minimum %u KB";
          v43 = v37;
          v44 = 14;
          goto LABEL_148;
        }
LABEL_92:
        v10 = 0;
        goto LABEL_93;
      }
      v45 = *(_DWORD *)(a1 + 224);
      v46 = *(NSObject **)(a1 + 40);
      if ((v45 & (v45 - 1)) != 0)
      {
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          goto LABEL_92;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v45 >> 10;
        v42 = "File size (%u) KB must be the power of 2";
        v43 = v46;
      }
      else
      {
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = object >> 10;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v45 >> 10;
          _os_log_impl(&dword_1A343C000, v46, OS_LOG_TYPE_DEFAULT, "#I Previous trace file size: %u KB, Current trace file size: %u KB", buf, 0xEu);
        }
        if (*(_DWORD *)(a1 + 232) == 3)
        {
LABEL_87:
          __src = (char *)*MEMORY[0x1E0CFAF68];
          v47 = strlen((const char *)*MEMORY[0x1E0CFAF68]);
          if (v47 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          v48 = (void *)v47;
          if (v47 >= 0x17)
          {
            v52 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v47 | 7) != 0x17)
              v52 = v47 | 7;
            v53 = v52 + 1;
            v49 = (void **)operator new(v52 + 1);
            v102 = v53 | 0x8000000000000000;
            __dst[0] = v49;
            __dst[1] = v48;
          }
          else
          {
            HIBYTE(v102) = v47;
            v49 = __dst;
            if (!v47)
            {
LABEL_102:
              *((_BYTE *)v48 + (_QWORD)v49) = 0;
              std::to_string((std::string *)buf, 0);
              *(_OWORD *)v99 = *(_OWORD *)buf;
              v100 = *(_QWORD *)&buf[16];
              v54 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)__dst, (const std::string::value_type *)v99);
              if (SHIBYTE(v100) < 0)
              {
                operator delete(v99[0]);
                if ((SHIBYTE(v102) & 0x80000000) == 0)
                {
LABEL_104:
                  if (!v54)
                    goto LABEL_151;
LABEL_108:
                  v98 = 4;
                  strcpy((char *)v97, "File");
                  if (*(char *)(a1 + 223) < 0)
                    v23 = (void **)*v23;
                  v55 = strlen((const char *)v23);
                  if (v55 > 0x7FFFFFFFFFFFFFF7)
                    std::string::__throw_length_error[abi:ne180100]();
                  v56 = (void *)v55;
                  if (v55 >= 0x17)
                  {
                    v60 = (v55 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v55 | 7) != 0x17)
                      v60 = v55 | 7;
                    v61 = v60 + 1;
                    v57 = operator new(v60 + 1);
                    v95[1] = v56;
                    v96 = v61 | 0x8000000000000000;
                    v95[0] = v57;
                  }
                  else
                  {
                    HIBYTE(v96) = v55;
                    v57 = v95;
                    if (!v55)
                    {
LABEL_126:
                      *((_BYTE *)v56 + (_QWORD)v57) = 0;
                      v62 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v97, (const std::string::value_type *)v95);
                      if (SHIBYTE(v96) < 0)
                        operator delete(v95[0]);
                      if (v98 < 0)
                      {
                        operator delete(v97[0]);
                        if (!v62)
                          goto LABEL_151;
                      }
                      else if (!v62)
                      {
LABEL_151:
                        v10 = 0;
                        if (*(_DWORD *)(a1 + 232) == 3)
                          goto LABEL_93;
                        goto LABEL_152;
                      }
                      v94 = 7;
                      strcpy((char *)v93, "History");
                      std::to_string((std::string *)buf, *v27);
                      *(_OWORD *)v91 = *(_OWORD *)buf;
                      v92 = *(_QWORD *)&buf[16];
                      v64 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v93, (const std::string::value_type *)v91);
                      if (SHIBYTE(v92) < 0)
                      {
                        operator delete(v91[0]);
                        if ((v94 & 0x80000000) == 0)
                        {
LABEL_136:
                          if (!v64)
                            goto LABEL_151;
                          goto LABEL_137;
                        }
                      }
                      else if ((v94 & 0x80000000) == 0)
                      {
                        goto LABEL_136;
                      }
                      operator delete(v93[0]);
                      if (!v64)
                        goto LABEL_151;
LABEL_137:
                      v90 = 8;
                      v88 = 0;
                      strcpy((char *)v89, "FileSize");
                      std::to_string((std::string *)buf, *(_DWORD *)(a1 + 224));
                      *(_OWORD *)v87 = *(_OWORD *)buf;
                      v88 = *(_QWORD *)&buf[16];
                      v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v89, (const std::string::value_type *)v87);
                      if (SHIBYTE(v88) < 0)
                      {
                        operator delete(v87[0]);
                        if ((v90 & 0x80000000) == 0)
                        {
LABEL_139:
                          if (*(_DWORD *)(a1 + 232) == 3)
                          {
LABEL_140:
                            if (!(_DWORD)v10)
                              goto LABEL_93;
                            std::string::basic_string[abi:ne180100]<0>(v76, "TraceOwnership");
                            util::to_str<abm::traceOwnership>(&v75, 0);
                            v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v76, (const std::string::value_type *)&v75);
                            if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v75.__r_.__value_.__l.__data_);
                            if (v77 < 0)
                            {
                              operator delete(v76[0]);
                              if ((v10 & 1) == 0)
                                goto LABEL_92;
                            }
                            else if (!(_DWORD)v10)
                            {
                              goto LABEL_93;
                            }
                            std::string::basic_string[abi:ne180100]<0>(v73, "Mode");
                            util::to_str<trace::Mode>(&v72, 0);
                            v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v73, (const std::string::value_type *)&v72);
                            if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v72.__r_.__value_.__l.__data_);
                            if (v74 < 0)
                            {
                              operator delete(v73[0]);
                              if ((v10 & 1) == 0)
                                goto LABEL_92;
                            }
                            else if (!(_DWORD)v10)
                            {
                              goto LABEL_93;
                            }
                            std::string::basic_string[abi:ne180100]<0>(v70, "Live_Filter_Setting");
                            util::to_str<trace::LiveFilterSetting>(&v69, *(_DWORD *)(a1 + 232));
                            v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v70, (const std::string::value_type *)&v69);
                            if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v69.__r_.__value_.__l.__data_);
                            if (v71 < 0)
                            {
                              operator delete(v70[0]);
                              if ((v10 & 1) == 0)
                                goto LABEL_92;
                            }
                            else if (!(_DWORD)v10)
                            {
                              goto LABEL_93;
                            }
                            std::string::basic_string[abi:ne180100]<0>(v67, __src);
                            util::to_str<BOOL>(1, &v66);
                            v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v67, (const std::string::value_type *)&v66);
                            if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v66.__r_.__value_.__l.__data_);
                            if (v68 < 0)
                            {
                              operator delete(v67[0]);
                              if ((v10 & 1) == 0)
                                goto LABEL_92;
                            }
                            else if (!(_DWORD)v10)
                            {
                              goto LABEL_93;
                            }
                            v10 = abm::CellularLoggingCommon::changeState((abm::CellularLoggingCommon *)a1, 1);
LABEL_93:
                            if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v116.__r_.__value_.__l.__data_);
                            return v10;
                          }
LABEL_158:
                          if (!(_DWORD)v10)
                            goto LABEL_152;
                          std::string::basic_string[abi:ne180100]<0>(v85, "TraceOwnership");
                          util::to_str<abm::traceOwnership>(&v84, 1);
                          v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v85, (const std::string::value_type *)&v84);
                          if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(v84.__r_.__value_.__l.__data_);
                          if (v86 < 0)
                          {
                            operator delete(v85[0]);
                            if ((v10 & 1) == 0)
                              goto LABEL_187;
                          }
                          else if (!(_DWORD)v10)
                          {
                            goto LABEL_152;
                          }
                          std::string::basic_string[abi:ne180100]<0>(v82, "Mode");
                          util::to_str<trace::Mode>(&v81, 4);
                          v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v82, (const std::string::value_type *)&v81);
                          if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(v81.__r_.__value_.__l.__data_);
                          if ((v83 & 0x80000000) == 0)
                          {
                            if (!(_DWORD)v10)
                              goto LABEL_152;
                            goto LABEL_183;
                          }
                          operator delete(v82[0]);
                          if ((v10 & 1) != 0)
                          {
LABEL_183:
                            std::string::basic_string[abi:ne180100]<0>(v79, __src);
                            util::to_str<BOOL>(1, &v78);
                            v10 = abm::CellularLoggingCommon::setProperty((_QWORD *)a1, (const std::string::value_type *)v79, (const std::string::value_type *)&v78);
                            if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v78.__r_.__value_.__l.__data_);
                            if (v80 < 0)
                              operator delete(v79[0]);
LABEL_152:
                            if ((abm::CellularLoggingINT::startReader((abm::CellularLoggingINT *)a1, 1) & 1) == 0)
                            {
                              abm::CellularLoggingINT::stopReader((abm::CellularLoggingINT *)a1, 1);
                              goto LABEL_92;
                            }
                            goto LABEL_93;
                          }
LABEL_187:
                          v10 = 0;
                          goto LABEL_152;
                        }
                      }
                      else if ((v90 & 0x80000000) == 0)
                      {
                        goto LABEL_139;
                      }
                      operator delete(v89[0]);
                      if (*(_DWORD *)(a1 + 232) == 3)
                        goto LABEL_140;
                      goto LABEL_158;
                    }
                  }
                  memmove(v57, v23, (size_t)v56);
                  goto LABEL_126;
                }
              }
              else if ((SHIBYTE(v102) & 0x80000000) == 0)
              {
                goto LABEL_104;
              }
              operator delete(__dst[0]);
              if (!v54)
                goto LABEL_151;
              goto LABEL_108;
            }
          }
          memmove(v49, __src, (size_t)v48);
          goto LABEL_102;
        }
        v51 = xpc_dictionary_get_value(*a2, "kKeyLiveFilterFileSize");
        *(_QWORD *)buf = v51;
        if (v51)
          xpc_retain(v51);
        else
          *(_QWORD *)buf = xpc_null_create();
        *(_DWORD *)(a1 + 236) = xpc::dyn_cast_or_default();
        xpc_release(*(xpc_object_t *)buf);
        v58 = *(_DWORD *)(a1 + 236);
        if ((v58 & (v58 - 1)) != 0)
        {
          v59 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            goto LABEL_92;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v58 >> 10;
          v42 = "Live-Filter File size (%u) KB must be the power of 2";
        }
        else
        {
          if (v58 - 4194305 > 0xFFC003FE)
          {
            if (*(char *)(a1 + 175) < 0)
            {
              *(_QWORD *)(a1 + 160) = 4;
              v63 = *(char **)(a1 + 152);
            }
            else
            {
              v63 = (char *)(a1 + 152);
              *(_BYTE *)(a1 + 175) = 4;
            }
            strcpy(v63, ".acp");
            goto LABEL_87;
          }
          v59 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            goto LABEL_92;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v58 >> 10;
          v42 = "The Given Live-Filtered file size (%u) KB is beyond allowed limit";
        }
        v43 = v59;
      }
      v44 = 8;
LABEL_148:
      _os_log_error_impl(&dword_1A343C000, v43, OS_LOG_TYPE_ERROR, v42, buf, v44);
      goto LABEL_92;
    }
    v12 = *(_DWORD *)(a1 + 228);
    if (v12 > 3)
    {
      v13 = "unknown";
      v14 = *(_DWORD *)(a1 + 232);
      if (v14 > 3)
        goto LABEL_18;
    }
    else
    {
      v13 = off_1E4A0C4C0[v12];
      v14 = *(_DWORD *)(a1 + 232);
      if (v14 > 3)
      {
LABEL_18:
        v15 = "unknown";
LABEL_21:
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v12;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v15;
        v119 = 1024;
        v120 = v14;
        _os_log_impl(&dword_1A343C000, v11, OS_LOG_TYPE_DEFAULT, "#I Live Filter Setting was %s (%d) and is now being set to %s (%d)", buf, 0x22u);
        goto LABEL_22;
      }
    }
    v15 = off_1E4A0C4C0[v14];
    goto LABEL_21;
  }
  v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1A343C000, v9, OS_LOG_TYPE_ERROR, "Failed creating path", buf, 2u);
  }
  return 0;
}

void sub_1A3508C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  uint64_t v22;

  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (*(char *)(v22 - 153) < 0)
    operator delete(*(void **)(v22 - 176));
  _Unwind_Resume(a1);
}

double util::to_str<abm::traceOwnership>(std::string *a1, int __val)
{
  double result;
  std::string v4;

  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::to_string(&v4, __val);
  result = *(double *)&v4.__r_.__value_.__l.__data_;
  *a1 = v4;
  return result;
}

void sub_1A35090B0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A35090A0);
}

void sub_1A35090BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

double util::to_str<trace::Mode>(std::string *a1, int __val)
{
  double result;
  std::string v4;

  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::to_string(&v4, __val);
  result = *(double *)&v4.__r_.__value_.__l.__data_;
  *a1 = v4;
  return result;
}

void sub_1A3509120(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A3509110);
}

void sub_1A350912C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingINT::startReader(abm::CellularLoggingINT *this, int a2)
{
  NSObject *v4;
  int data;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  NSObject *v10;
  uint64_t v11;
  int v13;
  char *v14;
  std::string *v15;
  std::string::size_type v16;
  char v17;
  char *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  __int128 v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  __int128 v36;
  capabilities::abs *shouldUseMinBasebandTransportIOReadSize;
  int v38;
  unint64_t *v39;
  unint64_t v40;
  NSObject *v41;
  NSObject *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  void *v49;
  void *v50;
  const void *v51;
  _QWORD aBlock[6];
  std::__shared_weak_count *v53;
  __int128 v54;
  __int128 v55;
  unint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t v59;
  void *v60[2];
  __int128 v61;
  void *v62[2];
  void *v63[2];
  __int128 v64;
  _BYTE v65[24];
  unint64_t v66;
  unsigned int v67;
  void *v68[2];
  char v69;
  unsigned int v70;
  void *v71[2];
  char v72;
  int v73;
  void *v74[3];
  void *__p[2];
  char v76;
  std::string v77;
  uint8_t v78[4];
  const char *v79;
  __int128 v80;
  std::string buf;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  _BYTE v86[24];
  unint64_t v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Starting Readers", (uint8_t *)&buf, 2u);
  }
  memset(&v77, 170, sizeof(v77));
  v76 = 14;
  strcpy((char *)__p, "TraceOwnership");
  abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)__p, &v77);
  if (v76 < 0)
    operator delete(__p[0]);
  data = -1431655766;
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if ((util::convert<int>(&v77, &buf, 0) & 1) != 0)
  {
    data = (int)buf.__r_.__value_.__l.__data_;
    if (LODWORD(buf.__r_.__value_.__l.__data_) == 1)
    {
      HIBYTE(v74[2]) = 18;
      strcpy((char *)v74, "MaxMemoryFileCount");
      abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)v74, &buf);
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v77.__r_.__value_.__l.__data_);
      v77 = buf;
      *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (SHIBYTE(v74[2]) < 0)
        operator delete(v74[0]);
      v73 = 0;
      util::convert<unsigned int>(&v77, &v73, 0);
      v6 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v73;
        _os_log_impl(&dword_1A343C000, v6, OS_LOG_TYPE_DEFAULT, "#I Maximum memory file count: %u", (uint8_t *)&buf, 8u);
      }
      v72 = 6;
      strcpy((char *)v71, "SizeIO");
      abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)v71, &buf);
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v77.__r_.__value_.__l.__data_);
      v77 = buf;
      *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (v72 < 0)
        operator delete(v71[0]);
      v70 = 0;
      util::convert<unsigned int>(&v77, &v70, 0);
      v7 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v70;
        _os_log_impl(&dword_1A343C000, v7, OS_LOG_TYPE_DEFAULT, "#I Transport IO Read Size: %u", (uint8_t *)&buf, 8u);
      }
      v69 = 14;
      strcpy((char *)v68, "NumberOfReadIO");
      abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)v68, &buf);
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v77.__r_.__value_.__l.__data_);
      v77 = buf;
      *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (v69 < 0)
        operator delete(v68[0]);
      v67 = 0;
      util::convert<unsigned int>(&v77, &v67, 0);
      v8 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v67;
        _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I Transport IO Read Count: %u", (uint8_t *)&buf, 8u);
      }
      buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAA0000;
      *(_OWORD *)&v86[8] = 0xAAAAAAAAAAAAAAAALL;
      v87 = 0xAAAAAAAA00100000;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0u;
      v82 = 0u;
      v83 = 0u;
      v84 = 0u;
      v85 = 0u;
      *(_OWORD *)v86 = 0u;
      std::string::__assign_external((std::string *)((char *)&v85 + 8), "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
      if (SBYTE7(v85) < 0)
      {
        *((_QWORD *)&v84 + 1) = 4;
        v9 = (char *)v84;
      }
      else
      {
        v9 = (char *)&v84;
        BYTE7(v85) = 4;
      }
      strcpy(v9, ".acp");
      *(_DWORD *)&v86[16] = *((_DWORD *)this + 49);
      *(_DWORD *)&v86[20] = v73;
      v13 = *((_DWORD *)this + 58);
      if (v13 != 2)
      {
        if (v13 == 1)
        {
          v14 = (char *)this + 236;
          goto LABEL_39;
        }
        if (v13)
          goto LABEL_40;
      }
      v14 = (char *)this + 224;
LABEL_39:
      LODWORD(v87) = *(_DWORD *)v14;
LABEL_40:
      v59 = 0xAAAAAAAAAAAA0000;
      *(_OWORD *)&v65[8] = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)v60 = 0u;
      v61 = 0u;
      *(_OWORD *)v62 = 0u;
      *(_OWORD *)v63 = 0u;
      v64 = 0u;
      *(_OWORD *)v65 = 0u;
      v66 = 0xAAAAAAAA00100000;
      BYTE7(v55) = 5;
      strcpy((char *)&v54, "-live");
      v15 = std::string::insert((std::string *)&v54, 0, "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
      v16 = v15->__r_.__value_.__r.__words[0];
      *(_QWORD *)&v80 = v15->__r_.__value_.__l.__size_;
      *(_QWORD *)((char *)&v80 + 7) = *(std::string::size_type *)((char *)&v15->__r_.__value_.__r.__words[1] + 7);
      v17 = HIBYTE(v15->__r_.__value_.__r.__words[2]);
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      if ((v65[15] & 0x80000000) != 0)
        operator delete(*((void **)&v64 + 1));
      *((_QWORD *)&v64 + 1) = v16;
      *(_QWORD *)v65 = v80;
      *(_QWORD *)&v65[7] = *(_QWORD *)((char *)&v80 + 7);
      v65[15] = v17;
      if (SBYTE7(v55) < 0)
      {
        operator delete((void *)v54);
        if ((SBYTE7(v64) & 0x80000000) == 0)
          goto LABEL_44;
      }
      else if ((SBYTE7(v64) & 0x80000000) == 0)
      {
LABEL_44:
        v18 = (char *)v63;
        BYTE7(v64) = 4;
        goto LABEL_47;
      }
      v63[1] = (void *)4;
      v18 = (char *)v63[0];
LABEL_47:
      strcpy(v18, ".acp");
      *(_DWORD *)&v65[16] = *((_DWORD *)this + 49);
      *(_DWORD *)&v65[20] = v73;
      LODWORD(v66) = *((_DWORD *)this + 59);
      v19 = (std::__shared_weak_count *)*((_QWORD *)this + 14);
      v57 = *((_QWORD *)this + 13);
      v58 = v19;
      if (v19)
      {
        p_shared_owners = (unint64_t *)&v19->__shared_owners_;
        do
          v21 = __ldxr(p_shared_owners);
        while (__stxr(v21 + 1, p_shared_owners));
      }
      abm::trace::TraceReader::create();
      v22 = v54;
      v54 = 0uLL;
      v23 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
      *((_OWORD *)this + 8) = v22;
      if (v23)
      {
        v24 = (unint64_t *)&v23->__shared_owners_;
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v26 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
      if (*((_QWORD *)&v54 + 1))
      {
        v27 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v58;
      if (!v58)
        goto LABEL_115;
      v30 = (unint64_t *)&v58->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
        if (*((_QWORD *)this + 16))
        {
LABEL_65:
          v33 = *((_QWORD *)this + 9);
          v32 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
          *(_QWORD *)&v80 = v33;
          if (!v32 || (v34 = std::__shared_weak_count::lock(v32), (*((_QWORD *)&v80 + 1) = v34) == 0))
            std::__throw_bad_weak_ptr[abi:ne180100]();
          v35 = v34;
          *(_QWORD *)&v36 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v55 = v36;
          *(_QWORD *)&v54 = 0xAAAAAA0000000011;
          v56 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v54 + 1) = 10;
          shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v34);
          if ((_DWORD)shouldUseMinBasebandTransportIOReadSize)
            v38 = 0x4000;
          else
            v38 = 0x8000;
          LODWORD(v55) = v38;
          capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize);
          LOBYTE(v56) = 0;
          v55 = __PAIR64__(v67, v70);
          aBlock[0] = MEMORY[0x1E0C809B0];
          aBlock[1] = 3321888768;
          aBlock[2] = ___ZN3abm18CellularLoggingINT11startReaderEb_block_invoke;
          aBlock[3] = &__block_descriptor_56_e8_40c55_ZTSNSt3__110shared_ptrIN3abm21CellularLoggingCommonEEE_e22_v48__0_Status_iBQQQQ_8l;
          aBlock[4] = this;
          aBlock[5] = v33;
          v39 = (unint64_t *)&v35->__shared_owners_;
          v53 = v35;
          do
            v40 = __ldxr(v39);
          while (__stxr(v40 + 1, v39));
          v51 = _Block_copy(aBlock);
          v11 = abm::trace::TraceReader::start();
          if (v51)
            _Block_release(v51);
          if ((v11 & a2) == 1)
          {
            if ((abm::CellularLoggingCommon::changeState(this, 1) & 1) != 0)
            {
              v11 = 1;
            }
            else
            {
              v42 = *((_QWORD *)this + 5);
              if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v78 = 136315138;
                v79 = "true";
                _os_log_error_impl(&dword_1A343C000, v42, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", v78, 0xCu);
              }
              v11 = 0;
            }
          }
          v43 = v53;
          if (v53)
          {
            v44 = (unint64_t *)&v53->__shared_owners_;
            do
              v45 = __ldaxr(v44);
            while (__stlxr(v45 - 1, v44));
            if (!v45)
            {
              ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
              std::__shared_weak_count::__release_weak(v43);
            }
          }
          v46 = (std::__shared_weak_count *)*((_QWORD *)&v80 + 1);
          if (*((_QWORD *)&v80 + 1))
          {
            v47 = (unint64_t *)(*((_QWORD *)&v80 + 1) + 8);
            do
              v48 = __ldaxr(v47);
            while (__stlxr(v48 - 1, v47));
            if (!v48)
            {
              ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
              std::__shared_weak_count::__release_weak(v46);
            }
          }
          goto LABEL_94;
        }
      }
      else
      {
LABEL_115:
        if (*((_QWORD *)this + 16))
          goto LABEL_65;
      }
      v41 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v54) = 0;
        _os_log_error_impl(&dword_1A343C000, v41, OS_LOG_TYPE_ERROR, "Failed to create trace reader!", (uint8_t *)&v54, 2u);
      }
      v11 = 0;
LABEL_94:
      if ((v65[15] & 0x80000000) != 0)
      {
        operator delete(*((void **)&v64 + 1));
        if ((SBYTE7(v64) & 0x80000000) == 0)
        {
LABEL_96:
          v49 = (void *)*((_QWORD *)&v61 + 1);
          if (!*((_QWORD *)&v61 + 1))
            goto LABEL_98;
          goto LABEL_97;
        }
      }
      else if ((SBYTE7(v64) & 0x80000000) == 0)
      {
        goto LABEL_96;
      }
      operator delete(v63[0]);
      v49 = (void *)*((_QWORD *)&v61 + 1);
      if (!*((_QWORD *)&v61 + 1))
      {
LABEL_98:
        if (SBYTE7(v61) < 0)
        {
          operator delete(v60[0]);
          if ((v86[15] & 0x80000000) == 0)
          {
LABEL_100:
            if ((SBYTE7(v85) & 0x80000000) == 0)
              goto LABEL_101;
            goto LABEL_110;
          }
        }
        else if ((v86[15] & 0x80000000) == 0)
        {
          goto LABEL_100;
        }
        operator delete(*((void **)&v85 + 1));
        if ((SBYTE7(v85) & 0x80000000) == 0)
        {
LABEL_101:
          v50 = (void *)*((_QWORD *)&v82 + 1);
          if (!*((_QWORD *)&v82 + 1))
            goto LABEL_103;
          goto LABEL_102;
        }
LABEL_110:
        operator delete((void *)v84);
        v50 = (void *)*((_QWORD *)&v82 + 1);
        if (!*((_QWORD *)&v82 + 1))
        {
LABEL_103:
          if (SBYTE7(v82) < 0)
            operator delete((void *)buf.__r_.__value_.__l.__size_);
          goto LABEL_30;
        }
LABEL_102:
        *(_QWORD *)&v83 = v50;
        operator delete(v50);
        goto LABEL_103;
      }
LABEL_97:
      v62[0] = v49;
      operator delete(v49);
      goto LABEL_98;
    }
  }
  v10 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
    _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Trace Owner: %d, CellularLogging does not own trace transport. Skip creating trace reader", (uint8_t *)&buf, 8u);
  }
  v11 = 0;
LABEL_30:
  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v77.__r_.__value_.__l.__data_);
  return v11;
}

void sub_1A3509B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  uint64_t v63;
  uint64_t v64;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v63);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v64 - 208);
  TraceFileCollection::Parameters::~Parameters(&a28);
  TraceFileCollection::Parameters::~Parameters((void **)(v64 - 192));
  if (*(char *)(v64 - 233) < 0)
    operator delete(*(void **)(v64 - 256));
  _Unwind_Resume(a1);
}

void sub_1A3509C20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a57 < 0)
    JUMPOUT(0x1A3509C10);
  JUMPOUT(0x1A3509C18);
}

uint64_t abm::CellularLoggingINT::stopReader(abm::CellularLoggingINT *this, int a2)
{
  NSObject *v4;
  abm::trace::TraceReader *v5;
  _QWORD *v6;
  char v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  int v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v18) = 0;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping Readers", (uint8_t *)&v18, 2u);
  }
  v6 = (_QWORD *)((char *)this + 128);
  v5 = (abm::trace::TraceReader *)*((_QWORD *)this + 16);
  if (!v5)
    goto LABEL_22;
  v7 = abm::trace::TraceReader::stop(v5);
  v8 = *((_QWORD *)this + 5);
  if ((v7 & 1) != 0)
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl(&dword_1A343C000, v8, OS_LOG_TYPE_DEFAULT, "#I Succeeded stopping reader.", (uint8_t *)&v18, 2u);
    }
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      v12 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
      *v6 = 0;
      *((_QWORD *)this + 17) = 0;
      if (v12)
      {
        v13 = (unint64_t *)&v12->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
          v15 = 1;
          if (!a2)
            return v15;
          goto LABEL_23;
        }
      }
    }
    else
    {
      *v6 = 0;
      *((_QWORD *)this + 17) = 0;
    }
LABEL_22:
    v15 = 1;
    if (!a2)
      return v15;
    goto LABEL_23;
  }
  if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
  {
    LOWORD(v18) = 0;
    _os_log_error_impl(&dword_1A343C000, v8, OS_LOG_TYPE_ERROR, "Failed to stop reader", (uint8_t *)&v18, 2u);
    v15 = 0;
    if (!a2)
      return v15;
  }
  else
  {
    v15 = 0;
    if (!a2)
      return v15;
  }
LABEL_23:
  if ((abm::CellularLoggingCommon::changeState(this, 0) & 1) == 0)
  {
    v16 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v18 = 136315138;
      v19 = "false";
      _os_log_error_impl(&dword_1A343C000, v16, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", (uint8_t *)&v18, 0xCu);
    }
    return 0;
  }
  return v15;
}

double util::to_str<trace::LiveFilterSetting>(std::string *a1, int __val)
{
  double result;
  std::string v4;

  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::to_string(&v4, __val);
  result = *(double *)&v4.__r_.__value_.__l.__data_;
  *a1 = v4;
  return result;
}

void sub_1A3509EB0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A3509EA0);
}

void sub_1A3509EBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingINT::pause(uint64_t a1)
{
  NSObject *v2;
  uint8_t v4[16];

  v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I CellularLogging Pause", v4, 2u);
    if (*(_DWORD *)(a1 + 232) == 3)
      return 1;
  }
  else if (*(_DWORD *)(a1 + 232) == 3)
  {
    return 1;
  }
  if (*(_QWORD *)(a1 + 128))
    return abm::CellularLoggingINT::stopReader((abm::CellularLoggingINT *)a1, 0);
  return 1;
}

uint64_t abm::CellularLoggingINT::resume(uint64_t a1)
{
  NSObject *v2;
  uint8_t v4[16];

  v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#I CellularLogging Resume", v4, 2u);
    if (*(_DWORD *)(a1 + 232) == 3)
      return 1;
  }
  else if (*(_DWORD *)(a1 + 232) == 3)
  {
    return 1;
  }
  if (*(_QWORD *)(a1 + 128))
    return abm::CellularLoggingINT::startReader((abm::CellularLoggingINT *)a1, 0);
  return 1;
}

void ___ZN3abm18CellularLoggingINT11startReaderEb_block_invoke(uint64_t a1, _DWORD *a2)
{
  NSObject *v2;
  uint8_t v3[16];

  if (*a2 == 3)
  {
    v2 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, "#E No Logging Traffic detected (Stalled?)", v3, 2u);
    }
  }
}

uint64_t __copy_helper_block_e8_40c55_ZTSNSt3__110shared_ptrIN3abm21CellularLoggingCommonEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c55_ZTSNSt3__110shared_ptrIN3abm21CellularLoggingCommonEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void abm::CellularLoggingINT::restoreDefaultState(abm::CellularLoggingINT *this)
{
  const void *v2;
  size_t v3;
  void *v4;
  void **v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL8 v8;
  int v9;
  const char *v10;
  size_t v11;
  _BOOL8 v12;
  int v13;
  _BOOL8 v14;
  unsigned int v15;
  int v16;
  char *v17;
  size_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  std::string v23;
  void *v24[2];
  unint64_t v25;
  std::string v26;
  std::string::value_type v27[32];
  std::string v28;
  std::string::value_type v29[32];
  std::string v30;
  void *v31[2];
  char v32;
  std::string v33;
  void *v34[2];
  char v35;
  void *__p[2];
  char v37;
  void *v38[2];
  char v39;
  std::string v40;
  void *v41[2];
  char v42;
  std::string v43;
  void *v44[2];
  char v45;
  std::string v46;
  void *__dst[2];
  unint64_t v48;
  std::string v49;

  v2 = (const void *)*MEMORY[0x1E0CFAF68];
  v3 = strlen((const char *)*MEMORY[0x1E0CFAF68]);
  if (v3 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v4 = (void *)v3;
  if (v3 >= 0x17)
  {
    v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17)
      v6 = v3 | 7;
    v7 = v6 + 1;
    v5 = (void **)operator new(v6 + 1);
    __dst[1] = v4;
    v48 = v7 | 0x8000000000000000;
    __dst[0] = v5;
    goto LABEL_8;
  }
  HIBYTE(v48) = v3;
  v5 = __dst;
  if (v3)
LABEL_8:
    memmove(v5, v2, (size_t)v4);
  *((_BYTE *)v4 + (_QWORD)v5) = 0;
  std::to_string(&v49, 0);
  v46 = v49;
  v8 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)__dst, (const std::string::value_type *)&v46);
  if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v48) & 0x80000000) == 0)
      goto LABEL_11;
LABEL_14:
    operator delete(__dst[0]);
    if (*((_DWORD *)this + 58) == 3)
      goto LABEL_19;
    goto LABEL_15;
  }
  operator delete(v46.__r_.__value_.__l.__data_);
  if (SHIBYTE(v48) < 0)
    goto LABEL_14;
LABEL_11:
  if (*((_DWORD *)this + 58) == 3)
    goto LABEL_19;
LABEL_15:
  v45 = 14;
  strcpy((char *)v44, "TraceOwnership");
  std::to_string(&v49, 0);
  v43 = v49;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v44, (const std::string::value_type *)&v43);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((v45 & 0x80000000) == 0)
      goto LABEL_17;
LABEL_45:
    operator delete(v44[0]);
    goto LABEL_17;
  }
  if (v45 < 0)
    goto LABEL_45;
LABEL_17:
  v42 = 4;
  strcpy((char *)v41, "Mode");
  std::to_string(&v49, 0);
  v40 = v49;
  v8 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v41, (const std::string::value_type *)&v40);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
    if ((v42 & 0x80000000) == 0)
      goto LABEL_19;
  }
  else if ((v42 & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(v41[0]);
LABEL_19:
  v39 = 4;
  strcpy((char *)v38, "File");
  v9 = config::hw::watch((config::hw *)v8);
  if (v9)
    v10 = "Lite";
  else
    v10 = "Default";
  if (v9)
    v11 = 4;
  else
    v11 = 7;
  v37 = v11;
  memcpy(__p, v10, v11);
  *(_BYTE *)((unint64_t)__p | v11) = 0;
  v12 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v38, (const std::string::value_type *)__p);
  if (v37 < 0)
  {
    operator delete(__p[0]);
    if ((v39 & 0x80000000) == 0)
      goto LABEL_27;
  }
  else if ((v39 & 0x80000000) == 0)
  {
    goto LABEL_27;
  }
  operator delete(v38[0]);
LABEL_27:
  v35 = 7;
  strcpy((char *)v34, "History");
  v13 = capabilities::trace::defaultHistorySizeMB((capabilities::trace *)v12);
  std::to_string(&v49, v13);
  v33 = v49;
  v14 = abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v34, (const std::string::value_type *)&v33);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((v35 & 0x80000000) == 0)
      goto LABEL_29;
  }
  else if ((v35 & 0x80000000) == 0)
  {
    goto LABEL_29;
  }
  operator delete(v34[0]);
LABEL_29:
  v32 = 8;
  strcpy((char *)v31, "FileSize");
  v15 = capabilities::trace::defaultFileSizeBytes((capabilities::trace *)v14);
  std::to_string(&v49, v15);
  v30 = v49;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v31, (const std::string::value_type *)&v30);
  if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v32 & 0x80000000) == 0)
      goto LABEL_31;
LABEL_40:
    operator delete(v31[0]);
    v16 = *((_DWORD *)this + 57);
    if (v16 == 3)
      goto LABEL_32;
    goto LABEL_41;
  }
  operator delete(v30.__r_.__value_.__l.__data_);
  if (v32 < 0)
    goto LABEL_40;
LABEL_31:
  v16 = *((_DWORD *)this + 57);
  if (v16 == 3)
  {
LABEL_32:
    v29[23] = 19;
    strcpy(v29, "Live_Filter_Setting");
    std::to_string(&v49, 0);
    v28 = v49;
    abm::CellularLoggingCommon::setProperty(this, v29, (const std::string::value_type *)&v28);
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v28.__r_.__value_.__l.__data_);
      if ((v29[23] & 0x80000000) == 0)
        goto LABEL_53;
    }
    else if ((v29[23] & 0x80000000) == 0)
    {
      goto LABEL_53;
    }
    v17 = v29;
    goto LABEL_52;
  }
LABEL_41:
  v27[23] = 19;
  strcpy(v27, "Live_Filter_Setting");
  std::to_string(&v49, v16);
  v26 = v49;
  abm::CellularLoggingCommon::setProperty(this, v27, (const std::string::value_type *)&v26);
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26.__r_.__value_.__l.__data_);
    if ((v27[23] & 0x80000000) == 0)
      goto LABEL_53;
  }
  else if ((v27[23] & 0x80000000) == 0)
  {
    goto LABEL_53;
  }
  v17 = v27;
LABEL_52:
  operator delete(*(void **)v17);
LABEL_53:
  if (!*((_BYTE *)this + 144))
    return;
  v18 = strlen((const char *)v2);
  if (v18 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v19 = (void *)v18;
  if (v18 >= 0x17)
  {
    v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17)
      v21 = v18 | 7;
    v22 = v21 + 1;
    v20 = operator new(v21 + 1);
    v24[1] = v19;
    v25 = v22 | 0x8000000000000000;
    v24[0] = v20;
    goto LABEL_61;
  }
  HIBYTE(v25) = v18;
  v20 = v24;
  if (v18)
LABEL_61:
    memmove(v20, v2, (size_t)v19);
  *((_BYTE *)v19 + (_QWORD)v20) = 0;
  std::to_string(&v49, *((unsigned __int8 *)this + 144));
  v23 = v49;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v24, (const std::string::value_type *)&v23);
  if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v25) & 0x80000000) == 0)
      return;
LABEL_66:
    operator delete(v24[0]);
    return;
  }
  operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v25) < 0)
    goto LABEL_66;
}

void sub_1A350A6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

void sub_1A350A910(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A350A1D4);
}

void sub_1A350A91C()
{
  uint64_t v0;

  if ((*(char *)(v0 - 121) & 0x80000000) == 0)
    JUMPOUT(0x1A350A8F4);
  JUMPOUT(0x1A350A8ECLL);
}

void abm::CellularLoggingINT::stop(abm::CellularLoggingINT *this)
{
  NSObject *v2;
  const char *v3;
  uint8_t *v4;
  __int16 v5;
  uint8_t buf[2];

  if (!abm::CellularLoggingCommon::isStarted(this))
  {
    v2 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v3 = "#I Cellular Logging has not been started yet";
    v4 = buf;
    goto LABEL_7;
  }
  if (*((_DWORD *)this + 58) != 3)
  {
    abm::CellularLoggingINT::stopReader(this, 1);
    abm::CellularLoggingINT::restoreDefaultState(this);
    return;
  }
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 0;
    v3 = "#I In streaming mode, skipping";
    v4 = (uint8_t *)&v5;
LABEL_7:
    _os_log_impl(&dword_1A343C000, v2, OS_LOG_TYPE_DEFAULT, v3, v4, 2u);
  }
}

void abm::CellularLoggingINT::stopWithConfig(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  NSObject *v10;
  xpc_object_t v11;
  xpc_object_t object;
  uint8_t buf[8];
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (abm::CellularLoggingCommon::isStarted((abm::CellularLoggingCommon *)a1))
  {
    if (*(_DWORD *)(a1 + 232) == 3)
    {
      v4 = (_QWORD *)a2[3];
      if (v4)
      {
        if (v4 == a2)
        {
          v15 = v14;
          (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v14);
        }
        else
        {
          v15 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
        }
      }
      else
      {
        v15 = 0;
      }
      abm::CellularLoggingINT::snapshotInternal(a1, v14);
      v8 = v15;
      if (v15 == v14)
      {
        v9 = 4;
        v8 = v14;
      }
      else
      {
        if (!v15)
          goto LABEL_19;
        v9 = 5;
      }
      (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_19:
      abm::CellularLoggingINT::restoreDefaultState((abm::CellularLoggingINT *)a1);
      if ((abm::CellularLoggingCommon::changeState((abm::CellularLoggingCommon *)a1, 0) & 1) == 0)
      {
        v10 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "stopWithConfig: Change state error", buf, 2u);
        }
      }
      return;
    }
    abm::CellularLoggingINT::stop((abm::CellularLoggingINT *)a1);
    v11 = xpc_null_create();
    buf[0] = 1;
    v7 = a2[3];
    if (!v7)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(_QWORD *)v7 + 48))(v7, buf, &v11);
    xpc_release(v11);
  }
  else
  {
    v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v5, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
    }
    object = xpc_null_create();
    buf[0] = 1;
    v6 = a2[3];
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(_QWORD *)v6 + 48))(v6, buf, &object);
    xpc_release(object);
  }
}

void sub_1A350AC0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void abm::CellularLoggingINT::snapshotInternal(uint64_t a1, _QWORD *a2)
{
  NSObject *v4;
  NSObject *v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  uint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  void *v29;
  char v30;
  void *__p[4];
  std::__shared_weak_count *v32;
  _QWORD v33[6];
  xpc_object_t object;
  _QWORD v35[3];
  char v36;
  _QWORD block[6];
  _BYTE v38[24];
  _BYTE *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = dispatch_group_create();
  v5 = dispatch_queue_create("CellularLoggingCommon", 0);
  v35[0] = 0;
  v35[1] = v35;
  v35[2] = 0x2020000000;
  v36 = 0;
  v33[0] = 0;
  v33[1] = v33;
  v33[2] = 0x3812000000;
  v33[3] = __Block_byref_object_copy__2;
  v33[4] = __Block_byref_object_dispose__2;
  v33[5] = "";
  object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (v6)
  {
    object = v6;
  }
  else
  {
    v7 = xpc_null_create();
    object = v7;
    if (!v7)
    {
      v8 = xpc_null_create();
      v7 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A85902BC](v7) == MEMORY[0x1E0C812F8])
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  v8 = xpc_null_create();
LABEL_8:
  object = v8;
LABEL_9:
  xpc_release(v7);
  __p[3] = (void *)0xAAAAAAAAAAAAAAAALL;
  v32 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(__p[2]) = 12;
  strcpy((char *)__p, "helperserver");
  abm::client::CreateManager();
  v9 = *(std::__shared_weak_count **)(a1 + 80);
  if (v9)
  {
    p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v11 = __ldxr(p_shared_weak_owners);
    while (__stxr(v11 + 1, p_shared_weak_owners));
  }
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  p_shared_owners = &v32->__shared_owners_;
  do
    v13 = __ldxr((unint64_t *)p_shared_owners);
  while (__stxr(v13 + 1, (unint64_t *)p_shared_owners));
  __p[0] = operator new(0x20uLL);
  *(_OWORD *)&__p[1] = xmmword_1A357F820;
  strcpy((char *)__p[0], "Triggered by streaming mode");
  v14 = MEMORY[0x1E0C809B0];
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  v15 = &v32->__shared_owners_;
  do
    v16 = __ldxr((unint64_t *)v15);
  while (__stxr(v16 + 1, (unint64_t *)v15));
  if (v9)
  {
    v17 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  abm::client::CollectTelephonyLogs();
  if (v30 < 0)
  {
    operator delete(v29);
    if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      goto LABEL_25;
LABEL_27:
    operator delete(__p[0]);
    v19 = v32;
    goto LABEL_28;
  }
  if (SHIBYTE(__p[2]) < 0)
    goto LABEL_27;
LABEL_25:
  v19 = v32;
LABEL_28:
  v20 = (unint64_t *)&v19->__shared_owners_;
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 - 1, v20));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  v22 = &v32->__shared_owners_;
  do
    v23 = __ldaxr((unint64_t *)v22);
  while (__stlxr(v23 - 1, (unint64_t *)v22));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  block[0] = v14;
  block[1] = 3321888768;
  block[2] = ___ZN3abm18CellularLoggingINT16snapshotInternalENSt3__18functionIFvbN3xpc4dictEEEE_block_invoke_17;
  block[3] = &unk_1E4A0C428;
  v24 = v38;
  v25 = a2[3];
  if (!v25)
    goto LABEL_45;
  if ((_QWORD *)v25 != a2)
  {
    v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 16))(v25);
LABEL_45:
    v39 = (_BYTE *)v25;
    goto LABEL_47;
  }
  v39 = v38;
  (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v38);
LABEL_47:
  block[4] = v35;
  block[5] = v33;
  dispatch_group_notify(v4, *(dispatch_queue_t *)(a1 + 120), block);
  if (v39 == v38)
  {
    v26 = 4;
    goto LABEL_51;
  }
  if (v39)
  {
    v26 = 5;
    v24 = v39;
LABEL_51:
    (*(void (**)(_QWORD *))(*v24 + 8 * v26))(v24);
  }
  v27 = &v32->__shared_owners_;
  do
    v28 = __ldaxr((unint64_t *)v27);
  while (__stlxr(v28 - 1, (unint64_t *)v27));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  _Block_object_dispose(v33, 8);
  xpc_release(object);
  _Block_object_dispose(v35, 8);
  if (v5)
    dispatch_release(v5);
  if (v4)
    dispatch_release(v4);
}

void sub_1A350B180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t group, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,xpc_object_t object)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void abm::CellularLoggingINT::getConfigName(abm::CellularLoggingINT *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 223) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 25), *((_QWORD *)this + 26));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 200);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 27);
  }
}

uint64_t abm::CellularLoggingINT::getConfigHistoryMB(abm::CellularLoggingINT *this)
{
  return *((unsigned int *)this + 49);
}

void abm::CellularLoggingINT::getFileExtension(abm::CellularLoggingINT *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 175) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 19), *((_QWORD *)this + 20));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 152);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 21);
  }
}

uint64_t abm::CellularLoggingINT::getMaxNumberOfFiles(abm::CellularLoggingINT *this)
{
  return *((unsigned int *)this + 49);
}

uint64_t abm::CellularLoggingINT::getFileSize(abm::CellularLoggingINT *this)
{
  return *((unsigned int *)this + 56);
}

xpc_object_t abm::CellularLoggingINT::getModemInformation1@<X0>(_QWORD *a1@<X8>)
{
  xpc_object_t result;

  result = xpc_null_create();
  *a1 = result;
  return result;
}

xpc_object_t abm::CellularLoggingINT::getModemInformation2@<X0>(_QWORD *a1@<X8>)
{
  xpc_object_t result;

  result = xpc_null_create();
  *a1 = result;
  return result;
}

uint64_t abm::CellularLoggingINT::getCurrentIndex(abm::trace::TraceReader **this)
{
  NSObject *v2;
  uint8_t v3[16];

  if (this[16])
    return abm::trace::TraceReader::getCurrentIndex(this[16]);
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v3 = 0;
    _os_log_error_impl(&dword_1A343C000, v2, OS_LOG_TYPE_ERROR, "Reader does not exist!", v3, 2u);
  }
  return 0;
}

void abm::CellularLoggingINT::getCandidateConfigNames(_QWORD *a1@<X8>)
{
  void *__p[2];
  char v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  memset(a1, 170, 24);
  v3 = 7;
  strcpy((char *)__p, "Default");
  std::vector<std::string>::vector[abi:ne180100](a1, (uint64_t)__p, 1uLL);
  if (v3 < 0)
    operator delete(__p[0]);
}

void sub_1A350B490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingINT::checkPrecondition(abm::CellularLoggingINT *this)
{
  _BOOL8 isStarted;
  std::string __p;
  void *v5[3];
  std::string v6;

  isStarted = abm::CellularLoggingCommon::isStarted(this);
  if (!isStarted || *((_DWORD *)this + 58) != 3)
    return isStarted;
  HIBYTE(v5[2]) = 19;
  strcpy((char *)v5, "Live_Filter_Setting");
  std::to_string(&v6, 3);
  __p = v6;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v5, (const std::string::value_type *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v5[2]) & 0x80000000) == 0)
      return isStarted;
  }
  else if ((SHIBYTE(v5[2]) & 0x80000000) == 0)
  {
    return isStarted;
  }
  operator delete(v5[0]);
  return isStarted;
}

void sub_1A350B580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
    operator delete(__p);
  if ((a21 & 0x80000000) == 0)
    _Unwind_Resume(exception_object);
  operator delete(a16);
  _Unwind_Resume(exception_object);
}

void sub_1A350B5B4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1A350B520);
}

void sub_1A350B5C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((a14 & 0x80000000) == 0)
    JUMPOUT(0x1A350B594);
  JUMPOUT(0x1A350B58CLL);
}

BOOL abm::CellularLoggingINT::handleAppCrash(NSObject **this, std::string::size_type a2)
{
  NSObject *v4;
  std::string::size_type v5;
  _BOOL8 v6;
  std::string *v7;
  __int128 v8;
  size_t v9;
  std::string *v10;
  __int128 v11;
  void **v12;
  std::string::size_type v13;
  std::string *v14;
  _BOOL8 Dir;
  NSObject *v16;
  std::string::size_type v17;
  std::string *v18;
  NSObject *v19;
  void *__p[2];
  unsigned __int8 v22;
  std::string v23;
  std::string v24;
  std::string v25;
  std::string v26;
  uint8_t buf[24];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 58) != 3)
  {
    abm::CellularLoggingINT::stopReader((abm::CellularLoggingINT *)this, 1);
    memset(buf, 170, sizeof(buf));
    Timestamp::Timestamp((Timestamp *)buf);
    *((_BYTE *)&v23.__r_.__value_.__s + 23) = 1;
    LOWORD(v23.__r_.__value_.__l.__data_) = 47;
    v7 = std::string::insert(&v23, 0, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging", 0x47uLL);
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    v9 = strlen(abm::trace::kLogDirPrefix[0]);
    v10 = std::string::append(&v25, abm::trace::kLogDirPrefix[0], v9);
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    Timestamp::asString((uint64_t)buf, 0, 9, __p);
    if ((v22 & 0x80u) == 0)
      v12 = __p;
    else
      v12 = (void **)__p[0];
    if ((v22 & 0x80u) == 0)
      v13 = v22;
    else
      v13 = (std::string::size_type)__p[1];
    v14 = std::string::append(&v26, (const std::string::value_type *)v12, v13);
    v24 = *v14;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if ((char)v22 < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_16:
        if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_17;
        goto LABEL_31;
      }
    }
    else if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_16;
    }
    operator delete(v26.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_17:
      if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_18;
LABEL_32:
      operator delete(v23.__r_.__value_.__l.__data_);
LABEL_18:
      v26.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
      *(_OWORD *)&v26.__r_.__value_.__r.__words[1] = xmmword_1A357F760;
      strcpy(v26.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging");
      Dir = support::fs::createDir((const char *)&v26, 0x1EDu, 1);
      v6 = Dir;
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v26.__r_.__value_.__l.__data_);
        if (v6)
        {
LABEL_20:
          memset(&v26, 170, sizeof(v26));
          v25.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x38uLL);
          *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A3580B20;
          strcpy(v25.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CellularLogging");
          support::fs::moveDirUnique((const char *)&v25, (uint64_t)&v24, (uint64_t)&v26);
          if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v25.__r_.__value_.__l.__data_);
            v16 = this[5];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
LABEL_22:
              if (*(char *)(a2 + 23) >= 0)
                v17 = a2;
              else
                v17 = *(_QWORD *)a2;
              v18 = &v26;
              if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v18 = (std::string *)v26.__r_.__value_.__r.__words[0];
              LODWORD(v25.__r_.__value_.__l.__data_) = 136315394;
              *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = v17;
              WORD2(v25.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v25.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
              _os_log_impl(&dword_1A343C000, v16, OS_LOG_TYPE_DEFAULT, "#N Detected %s crash, moving logs to %s", (uint8_t *)&v25, 0x16u);
              if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
              {
LABEL_43:
                operator delete(v26.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_41;
                goto LABEL_40;
              }
              goto LABEL_39;
            }
          }
          else
          {
            v16 = this[5];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
              goto LABEL_22;
          }
          if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
            goto LABEL_43;
          goto LABEL_39;
        }
      }
      else if (Dir)
      {
        goto LABEL_20;
      }
      v19 = this[5];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v26.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v26.__r_.__value_.__r.__words + 4) = (std::string::size_type)"/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging";
        _os_log_error_impl(&dword_1A343C000, v19, OS_LOG_TYPE_ERROR, "Failed to create directory %s", (uint8_t *)&v26, 0xCu);
        if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_40;
        goto LABEL_41;
      }
LABEL_39:
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
LABEL_40:
        operator delete(v24.__r_.__value_.__l.__data_);
LABEL_41:
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)buf, *(_QWORD **)&buf[8]);
      return v6;
    }
LABEL_31:
    operator delete(v25.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_32;
  }
  v4 = this[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0)
      v5 = a2;
    else
      v5 = *(_QWORD *)a2;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v5;
    _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Detected %s crashed", buf, 0xCu);
  }
  return 1;
}

void sub_1A350B9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (a33 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v33 - 64, *(_QWORD **)(v33 - 56));
  _Unwind_Resume(a1);
}

_QWORD *abm::CellularLoggingINT::snapshot(abm::CellularLoggingCommon *a1, _QWORD *a2)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  uint64_t v8;
  xpc_object_t object;
  uint8_t buf[8];
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!abm::CellularLoggingCommon::isStarted(a1))
  {
    v4 = *((_QWORD *)a1 + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A343C000, v4, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
    }
    if (a2[3])
    {
      object = xpc_null_create();
      buf[0] = 0;
      v5 = a2[3];
      if (!v5)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(_QWORD *)v5 + 48))(v5, buf, &object);
      xpc_release(object);
      object = 0;
    }
  }
  v6 = (_QWORD *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      v12 = v11;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v11);
    }
    else
    {
      v12 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v6 + 16))(v6);
    }
  }
  else
  {
    v12 = 0;
  }
  abm::CellularLoggingINT::snapshotInternal((uint64_t)a1, v11);
  result = v12;
  if (v12 == v11)
  {
    v8 = 4;
    result = v11;
  }
  else
  {
    if (!v12)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1A350BC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void abm::CellularLoggingINT::getLogPath(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X3>, std::string *a4@<X8>)
{
  size_t v7;
  std::string *v8;
  size_t v9;
  std::string::size_type v10;
  char v11;
  char *v12;
  size_t v13;
  std::string::size_type v14;
  std::string *p_dst;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  size_t v19;
  size_t v20;
  void *p_p;
  uint64_t v22;
  uint64_t v23;
  const std::string::value_type *v24;
  std::string::size_type v25;
  std::string *v26;
  __int128 v27;
  int v28;
  const std::string::value_type *v29;
  std::string::size_type v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  std::string::size_type size;
  std::string *v35;
  void *__p;
  size_t v37;
  int64_t v38;
  std::string __dst;
  std::string v40;
  std::string v41;
  std::string v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  memset(&v41, 170, sizeof(v41));
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v41, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v41 = *(std::string *)a3;
  if (a2 == 2)
  {
    *((_BYTE *)&v40.__r_.__value_.__s + 23) = 1;
    LOWORD(v40.__r_.__value_.__l.__data_) = 46;
    v9 = strlen(abm::trace::kLogTarExtension[0]);
    v8 = std::string::append(&v40, abm::trace::kLogTarExtension[0], v9);
  }
  else
  {
    if (a2 != 1)
      goto LABEL_12;
    *((_BYTE *)&v40.__r_.__value_.__s + 23) = 1;
    LOWORD(v40.__r_.__value_.__l.__data_) = 46;
    v7 = strlen(abm::trace::kLogTarGzExtension);
    v8 = std::string::append(&v40, abm::trace::kLogTarGzExtension, v7);
  }
  v10 = v8->__r_.__value_.__r.__words[0];
  v42.__r_.__value_.__r.__words[0] = v8->__r_.__value_.__l.__size_;
  *(std::string::size_type *)((char *)v42.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v8->__r_.__value_.__r.__words[1] + 7);
  v11 = HIBYTE(v8->__r_.__value_.__r.__words[2]);
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  v41.__r_.__value_.__r.__words[0] = v10;
  v41.__r_.__value_.__l.__size_ = v42.__r_.__value_.__r.__words[0];
  *(std::string::size_type *)((char *)&v41.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v42.__r_.__value_.__r.__words + 7);
  *((_BYTE *)&v41.__r_.__value_.__s + 23) = v11;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
LABEL_12:
  v12 = abm::trace::kSnapshotFolder[0];
  v13 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v13 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v14 = v13;
  if (v13 >= 0x17)
  {
    v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v16 = v13 | 7;
    v17 = v16 + 1;
    p_dst = (std::string *)operator new(v16 + 1);
    __dst.__r_.__value_.__l.__size_ = v14;
    __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_19;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v13;
  p_dst = &__dst;
  if (v13)
LABEL_19:
    memmove(p_dst, v12, v14);
  p_dst->__r_.__value_.__s.__data_[v14] = 0;
  v18 = abm::trace::kLogDirPrefix[0];
  v19 = strlen(abm::trace::kLogDirPrefix[0]);
  if (v19 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v20 = v19;
  if (v19 >= 0x17)
  {
    v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v22 = v19 | 7;
    v23 = v22 + 1;
    p_p = operator new(v22 + 1);
    v37 = v20;
    v38 = v23 | 0x8000000000000000;
    __p = p_p;
    goto LABEL_27;
  }
  HIBYTE(v38) = v19;
  p_p = &__p;
  if (v19)
LABEL_27:
    memmove(p_p, v18, v20);
  *((_BYTE *)p_p + v20) = 0;
  if (v38 >= 0)
    v24 = (const std::string::value_type *)&__p;
  else
    v24 = (const std::string::value_type *)__p;
  if (v38 >= 0)
    v25 = HIBYTE(v38);
  else
    v25 = v37;
  v26 = std::string::append(&__dst, v24, v25);
  v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  v28 = *(char *)(a1 + 23);
  if (v28 >= 0)
    v29 = (const std::string::value_type *)a1;
  else
    v29 = *(const std::string::value_type **)a1;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a1 + 23);
  else
    v30 = *(_QWORD *)(a1 + 8);
  v31 = std::string::append(&v42, v29, v30);
  v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v33 = &v41;
  else
    v33 = (std::string *)v41.__r_.__value_.__r.__words[0];
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  else
    size = v41.__r_.__value_.__l.__size_;
  v35 = std::string::append(&v40, (const std::string::value_type *)v33, size);
  *a4 = *v35;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_48:
      if ((SHIBYTE(v38) & 0x80000000) == 0)
        goto LABEL_49;
      goto LABEL_54;
    }
  }
  else if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_48;
  }
  operator delete(v42.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
LABEL_49:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_50;
    goto LABEL_55;
  }
LABEL_54:
  operator delete(__p);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_50:
    if ((SHIBYTE(v41.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_56:
    operator delete(v41.__r_.__value_.__l.__data_);
    return;
  }
LABEL_55:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_56;
}

void sub_1A350C068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a26 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

xpc_object_t __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  xpc_object_t result;

  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  result = xpc_null_create();
  *(_QWORD *)(a2 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
}

void ___ZN3abm18CellularLoggingINT16snapshotInternalENSt3__18functionIFvbN3xpc4dictEEEE_block_invoke(_QWORD *a1, _DWORD *a2, xpc_object_t a3)
{
  std::__shared_weak_count *v4;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  NSObject *v10;
  uint64_t v11;
  xpc_object_t v12;
  xpc_object_t value;
  std::string *p_p;
  xpc_object_t v15;
  xpc_object_t v16;
  NSObject *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  xpc_object_t object;
  void *v21;
  char v22;
  std::string __p;
  std::__shared_weak_count *v25;
  uint8_t buf[8];
  uint64_t v27;
  uint64_t v28;

  v4 = (std::__shared_weak_count *)a1[11];
  if (!v4)
    return;
  v7 = a1[6];
  v8 = std::__shared_weak_count::lock(v4);
  v25 = v8;
  if (!v8)
    return;
  v9 = v8;
  if (!a1[10])
  {
LABEL_31:
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return;
  }
  if (*a2)
  {
    v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v10, OS_LOG_TYPE_ERROR, "Failed to collect telephony logs", buf, 2u);
    }
    goto LABEL_31;
  }
  v11 = MEMORY[0x1E0C812F8];
  if (a3)
  {
    xpc_retain(a3);
  }
  else
  {
    a3 = xpc_null_create();
    if (!a3)
    {
      v12 = xpc_null_create();
      a3 = 0;
      goto LABEL_14;
    }
  }
  if (MEMORY[0x1A85902BC](a3) == v11)
  {
    xpc_retain(a3);
    v12 = a3;
  }
  else
  {
    v12 = xpc_null_create();
  }
LABEL_14:
  xpc_release(a3);
  if (MEMORY[0x1A85902BC](v12) == v11)
  {
    value = xpc_dictionary_get_value(v12, (const char *)*MEMORY[0x1E0CFB370]);
    object = value;
    if (value)
      xpc_retain(value);
    else
      object = xpc_null_create();
    *(_QWORD *)buf = 0;
    v27 = 0;
    v28 = 0x200000000000000;
    xpc::dyn_cast_or_default();
    strcpy((char *)buf, "-*");
    abm::CellularLoggingINT::getLogPath((uint64_t)&v21, 2, (uint64_t)buf, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    v15 = xpc_string_create((const char *)p_p);
    if (!v15)
      v15 = xpc_null_create();
    xpc_dictionary_set_value(*(xpc_object_t *)(*(_QWORD *)(a1[4] + 8) + 48), "kKeyLogDumpMainPath", v15);
    v16 = xpc_null_create();
    xpc_release(v15);
    xpc_release(v16);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v22 < 0)
      operator delete(v21);
    xpc_release(object);
  }
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  v17 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1A343C000, v17, OS_LOG_TYPE_DEFAULT, "#I Telephony logs dumped successfully", buf, 2u);
  }
  xpc_release(v12);
  v9 = v25;
  if (v25)
    goto LABEL_31;
}

void sub_1A350C470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;

  if (a16 < 0)
    operator delete(__p);
  xpc_release(object);
  xpc_release(v27);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_56c30_ZTSN8dispatch13group_sessionE64c47_ZTSNSt3__110shared_ptrIN3abm6client7ManagerEEE80c52_ZTSNSt3__18weak_ptrIN3abm21CellularLoggingCommonEEE(_QWORD *a1, _QWORD *a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v4 = a2[7];
  a1[7] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = a1[7];
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = a2[9];
  a1[8] = a2[8];
  a1[9] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = a2[11];
  a1[10] = a2[10];
  a1[11] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 16);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
}

void __destroy_helper_block_e8_56c30_ZTSN8dispatch13group_sessionE64c47_ZTSNSt3__110shared_ptrIN3abm6client7ManagerEEE80c52_ZTSNSt3__18weak_ptrIN3abm21CellularLoggingCommonEEE(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;

  v2 = (std::__shared_weak_count *)a1[11];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = (std::__shared_weak_count *)a1[9];
  if (!v3)
    goto LABEL_7;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    v6 = a1[7];
    if (!v6)
      return;
  }
  else
  {
LABEL_7:
    v6 = a1[7];
    if (!v6)
      return;
  }
  dispatch_group_leave(v6);
  v7 = a1[7];
  if (v7)
    dispatch_release(v7);
}

void ___ZN3abm18CellularLoggingINT16snapshotInternalENSt3__18functionIFvbN3xpc4dictEEEE_block_invoke_17(_QWORD *a1)
{
  char v2;
  void *v3;
  uint64_t v4;
  xpc_object_t object;
  char v6;

  if (a1[9])
  {
    v2 = *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24);
    v3 = *(void **)(*(_QWORD *)(a1[5] + 8) + 48);
    object = v3;
    if (v3)
    {
      xpc_retain(v3);
      v6 = v2;
      v4 = a1[9];
      if (v4)
      {
LABEL_4:
        (*(void (**)(uint64_t, char *, xpc_object_t *))(*(_QWORD *)v4 + 48))(v4, &v6, &object);
        xpc_release(object);
        return;
      }
    }
    else
    {
      object = xpc_null_create();
      v6 = v2;
      v4 = a1[9];
      if (v4)
        goto LABEL_4;
    }
    std::__throw_bad_function_call[abi:ne180100]();
  }
}

void sub_1A350C67C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c38_ZTSNSt3__18functionIFvbN3xpc4dictEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a2 + 72);
  if (result)
  {
    if (result == a2 + 48)
    {
      *(_QWORD *)(a1 + 72) = a1 + 48;
      return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 72) + 24))(*(_QWORD *)(a2 + 72), a1 + 48);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
      *(_QWORD *)(a1 + 72) = result;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 72) = 0;
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c38_ZTSNSt3__18functionIFvbN3xpc4dictEEEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 48;
  result = *(_QWORD *)(a1 + 72);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::allocate_shared[abi:ne180100]<abm::CellularLoggingINT,std::allocator<abm::CellularLoggingINT>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, NSObject **a3@<X3>, _QWORD *a4@<X8>)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count_vtbl *v10;
  std::__shared_weak_count *shared_owners;
  unint64_t v12;
  unint64_t *p_shared_weak_owners;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;

  v8 = (std::__shared_weak_count *)operator new(0x108uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0C480;
  v10 = (std::__shared_weak_count_vtbl *)&v8[1];
  std::construct_at[abi:ne180100]<abm::CellularLoggingINT,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingINT*>((uint64_t)&v8[1], a1, a2, a3);
  *a4 = v8 + 1;
  a4[1] = v8;
  shared_owners = (std::__shared_weak_count *)v8[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
      return;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v14 = __ldxr(p_shared_weak_owners);
    while (__stxr(v14 + 1, p_shared_weak_owners));
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    v16 = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
  }
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1A350C870(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<abm::CellularLoggingINT>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0C480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::CellularLoggingINT>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0C480;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<abm::CellularLoggingINT>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::construct_at[abi:ne180100]<abm::CellularLoggingINT,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingINT*>(uint64_t a1, uint64_t *a2, uint64_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  NSObject *v11;
  unint64_t *v12;
  unint64_t v13;
  dispatch_object_t v15;
  uint64_t v16[2];
  uint64_t v17[2];

  v5 = (std::__shared_weak_count *)a2[1];
  v17[0] = *a2;
  v17[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a3[1];
  v16[0] = *a3;
  v16[1] = (uint64_t)v8;
  if (v8)
  {
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  v11 = *a4;
  v15 = v11;
  if (v11)
    dispatch_retain(v11);
  abm::CellularLoggingINT::CellularLoggingINT(a1, v17, v16, &v15);
  if (v11)
    dispatch_release(v11);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  if (!v5)
    return a1;
  v12 = (unint64_t *)&v5->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (v13)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void sub_1A350C9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  std::__shared_weak_count *v13;
  NSObject *v14;

  if (v14)
  {
    dispatch_release(v14);
    if (!v13)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
      _Unwind_Resume(a1);
    }
  }
  else if (!v13)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v13);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_19()
{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A343C000);
  }
  return result;
}

void abm::HelperClient::create(char *a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18[2];

  v6 = operator new(0x28uLL);
  v7 = v6;
  v6[1] = 0;
  v6[2] = 0;
  *v6 = off_1E4A0C808;
  v8 = v6 + 3;
  v9 = *a2;
  v10 = (std::__shared_weak_count *)a2[1];
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v18[0] = v9;
  v18[1] = (uint64_t)v10;
  abm::HelperClient::HelperClient(v6 + 3, a1, v18);
  if (v10)
  {
    v14 = (unint64_t *)&v10->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v10)
  {
    v16 = (unint64_t *)&v10->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  *a3 = v8;
  a3[1] = v7;
}

void sub_1A350CB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v13;
  void *v14;

  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v14);
  _Unwind_Resume(a1);
}

_QWORD *abm::HelperClient::HelperClient(_QWORD *a1, char *__s, uint64_t *a3)
{
  size_t v6;
  std::string::size_type v7;
  std::string *p_dst;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD *v15;
  unint64_t *v16;
  unint64_t v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  std::string::size_type size;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  const char *p_p;
  NSObject *v26;
  NSObject *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::string *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  std::__shared_weak_count *v37;
  unint64_t v38;
  unint64_t *p_shared_weak_owners;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  std::__shared_weak_count *v46;
  std::string::size_type v47;
  std::__shared_weak_count *v48;
  std::string::size_type v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v66;
  std::string __dst;
  uint64_t v68;
  std::__shared_weak_count *v69;
  std::string v70;
  std::string v71;
  void *v72;
  uint64_t v73;
  __int128 __p;
  _QWORD *(*v75)(uint64_t);
  void *v76;
  uint64_t v77;
  std::string *v78;
  _BYTE v79[16];
  std::string v80;
  char v81[16];
  char v82[16];

  v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v11 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v11 = v6 | 7;
    v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
LABEL_9:
    memcpy(p_dst, __s, v7);
    p_dst->__r_.__value_.__s.__data_[v7] = 0;
    v10 = *a3;
    v9 = (std::__shared_weak_count *)a3[1];
    v66 = v9;
    if (!v9)
      goto LABEL_12;
LABEL_10:
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    goto LABEL_12;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v6;
  p_dst = &__dst;
  if (v6)
    goto LABEL_9;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  v10 = *a3;
  v9 = (std::__shared_weak_count *)a3[1];
  v66 = v9;
  if (v9)
    goto LABEL_10;
LABEL_12:
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  v15 = operator new(0x90uLL);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v70, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  else
    v70 = __dst;
  v68 = v10;
  v69 = v9;
  if (v9)
  {
    v16 = (unint64_t *)&v9->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  *((_BYTE *)&v80.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v80, "com.apple.abm.helper");
  v18 = std::string::append(&v80, ".", 1uLL);
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v71.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = &v70;
  else
    v20 = (std::string *)v70.__r_.__value_.__r.__words[0];
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v70.__r_.__value_.__r.__words[2]);
  else
    size = v70.__r_.__value_.__l.__size_;
  v22 = std::string::append(&v71, (const std::string::value_type *)v20, size);
  v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v75 = (_QWORD *(*)(uint64_t))v22->__r_.__value_.__r.__words[2];
  __p = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v24 = &v70;
  else
    v24 = (std::string *)v70.__r_.__value_.__r.__words[0];
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v79, "com.apple.abm.helper", (const char *)v24);
  if (SHIBYTE(v75) >= 0)
    p_p = (const char *)&__p;
  else
    p_p = (const char *)__p;
  v26 = dispatch_queue_create(p_p, 0);
  v15[9] = 0;
  v15[10] = 0;
  v15[11] = v26;
  if (v26)
  {
    v27 = v26;
    dispatch_retain(v26);
    v15[12] = 0;
    dispatch_release(v27);
  }
  else
  {
    v15[12] = 0;
  }
  *v15 = off_1E4A0C688;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v82);
  v15[1] = &unk_1E4A06330;
  v28 = v69;
  v15[7] = v68;
  v15[8] = v28;
  if (v28)
  {
    v29 = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v81);
  *v15 = off_1E4A0C648;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v79);
  if (SHIBYTE(v75) < 0)
  {
    operator delete((void *)__p);
    if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_38:
      if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_39;
LABEL_43:
      operator delete(v80.__r_.__value_.__l.__data_);
      *v15 = off_1E4A0C578;
      v31 = (std::string *)(v15 + 13);
      if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_40;
      goto LABEL_44;
    }
  }
  else if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_38;
  }
  operator delete(v71.__r_.__value_.__l.__data_);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_43;
LABEL_39:
  *v15 = off_1E4A0C578;
  v31 = (std::string *)(v15 + 13);
  if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_40:
    *v31 = v70;
    goto LABEL_45;
  }
LABEL_44:
  std::string::__init_copy_ctor_external(v31, v70.__r_.__value_.__l.__data_, v70.__r_.__value_.__l.__size_);
LABEL_45:
  v32 = v69;
  v15[16] = v68;
  v15[17] = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  *a1 = v15;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  v35 = (std::__shared_weak_count *)operator new(0x20uLL);
  v35->__shared_owners_ = 0;
  v36 = (unint64_t *)&v35->__shared_owners_;
  v35->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0C528;
  v35->__shared_weak_owners_ = 0;
  v35[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
  a1[1] = v35;
  v37 = (std::__shared_weak_count *)v15[10];
  if (v37)
  {
    if (v37->__shared_owners_ != -1)
      goto LABEL_60;
    do
      v38 = __ldxr(v36);
    while (__stxr(v38 + 1, v36));
    p_shared_weak_owners = (unint64_t *)&v35->__shared_weak_owners_;
    do
      v40 = __ldxr(p_shared_weak_owners);
    while (__stxr(v40 + 1, p_shared_weak_owners));
    v15[9] = v15;
    v15[10] = v35;
    std::__shared_weak_count::__release_weak(v37);
  }
  else
  {
    do
      v41 = __ldxr(v36);
    while (__stxr(v41 + 1, v36));
    v42 = (unint64_t *)&v35->__shared_weak_owners_;
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
    v15[9] = v15;
    v15[10] = v35;
  }
  do
    v44 = __ldaxr(v36);
  while (__stlxr(v44 - 1, v36));
  if (v44)
  {
LABEL_60:
    v45 = (_QWORD *)*a1;
    if (!*(_QWORD *)(*a1 + 56))
      goto LABEL_74;
    goto LABEL_61;
  }
  ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
  std::__shared_weak_count::__release_weak(v35);
  v45 = (_QWORD *)*a1;
  if (!*(_QWORD *)(*a1 + 56))
    goto LABEL_74;
LABEL_61:
  v46 = (std::__shared_weak_count *)v45[10];
  if (!v46 || (v47 = v45[9], (v48 = std::__shared_weak_count::lock(v46)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v49 = (std::string::size_type)v48;
  *(_QWORD *)&__p = v47;
  *((_QWORD *)&__p + 1) = v48;
  ctu::LoggerCommonBase::getLogDomain((ctu::LoggerCommonBase *)(v45 + 1));
  v71.__r_.__value_.__r.__words[0] = v47;
  v71.__r_.__value_.__l.__size_ = v49;
  __p = 0uLL;
  ctu::TrackedLogger::registerLoggerToServer();
  v50 = (std::__shared_weak_count *)v71.__r_.__value_.__l.__size_;
  if (v71.__r_.__value_.__l.__size_)
  {
    v51 = (unint64_t *)(v71.__r_.__value_.__l.__size_ + 8);
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  v53 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
  if (*((_QWORD *)&__p + 1))
  {
    v54 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
LABEL_74:
  v56 = v69;
  if (!v69)
    goto LABEL_78;
  v57 = (unint64_t *)&v69->__shared_owners_;
  do
    v58 = __ldaxr(v57);
  while (__stlxr(v58 - 1, v57));
  if (v58)
  {
LABEL_78:
    if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_80;
    goto LABEL_79;
  }
  ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
  std::__shared_weak_count::__release_weak(v56);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
LABEL_79:
    operator delete(v70.__r_.__value_.__l.__data_);
LABEL_80:
  v59 = *a1;
  v60 = *a1 + 72;
  v71.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
  v71.__r_.__value_.__l.__size_ = 0x40000000;
  v71.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN3abm20HelperClientInternal4initEv_block_invoke;
  v72 = &__block_descriptor_tmp_19;
  v73 = v59;
  v80.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
  *(_QWORD *)&__p = MEMORY[0x1E0C809B0];
  *((_QWORD *)&__p + 1) = 0x40000000;
  v75 = ___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  v76 = &__block_descriptor_tmp_4_2;
  v77 = v60;
  v78 = &v80;
  v61 = *(NSObject **)(v59 + 88);
  if (*(_QWORD *)(v59 + 96))
  {
    dispatch_async_and_wait(v61, &__p);
    v62 = v66;
    if (!v66)
      goto LABEL_87;
  }
  else
  {
    dispatch_sync(v61, &__p);
    v62 = v66;
    if (!v66)
      goto LABEL_87;
  }
  v63 = (unint64_t *)&v62->__shared_owners_;
  do
    v64 = __ldaxr(v63);
  while (__stlxr(v64 - 1, v63));
  if (!v64)
  {
    ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
    std::__shared_weak_count::__release_weak(v62);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return a1;
    goto LABEL_88;
  }
LABEL_87:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
LABEL_88:
    operator delete(__dst.__r_.__value_.__l.__data_);
  return a1;
}

void sub_1A350D1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  _QWORD *v25;

  ctu::SharedLoggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(v25);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  if (a25 < 0)
    operator delete(__p);
  operator delete(v25);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if ((a17 & 0x80000000) == 0)
    _Unwind_Resume(a1);
  operator delete(a12);
  _Unwind_Resume(a1);
}

void sub_1A350D208()
{
  JUMPOUT(0x1A350D2C0);
}

void sub_1A350D210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;

  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a27);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a33);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v33);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  if (a25 < 0)
  {
    operator delete(__p);
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
    if ((a17 & 0x80000000) == 0)
LABEL_3:
      _Unwind_Resume(a1);
  }
  else
  {
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
    if ((a17 & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(a12);
  _Unwind_Resume(a1);
}

void sub_1A350D230(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal*)#1}::operator() const(abm::HelperClientInternal*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A350D250()
{
  __cxa_end_catch();
  JUMPOUT(0x1A350D35CLL);
}

void sub_1A350D260(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  void *v38;
  _QWORD *v39;
  uint64_t v40;

  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v40 - 80));
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v40 - 96));
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::~SharedSynchronizable(v39);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v40 - 144));
  if (a38 < 0)
  {
    operator delete(__p);
    if ((a29 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v40 - 105) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else if ((a29 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a24);
  if ((*(char *)(v40 - 105) & 0x80000000) == 0)
  {
LABEL_4:
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
    if ((a22 & 0x80000000) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
LABEL_10:
  operator delete(*(void **)(v40 - 128));
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  if ((a22 & 0x80000000) == 0)
  {
LABEL_6:
    operator delete(v38);
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
    if (SHIBYTE(a14) < 0)
      JUMPOUT(0x1A350D39CLL);
    JUMPOUT(0x1A350D37CLL);
  }
LABEL_5:
  operator delete(a17);
  goto LABEL_6;
}

void sub_1A350D2F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    JUMPOUT(0x1A350D2FCLL);
  JUMPOUT(0x1A350D2A0);
}

void sub_1A350D310()
{
  uint64_t v0;

  if (*(char *)(v0 - 105) < 0)
    JUMPOUT(0x1A350D31CLL);
  JUMPOUT(0x1A350D2A8);
}

void sub_1A350D338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if ((a17 & 0x80000000) == 0)
    _Unwind_Resume(a1);
  operator delete(a12);
  _Unwind_Resume(a1);
}

void abm::HelperClient::~HelperClient(abm::HelperClient *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void abm::HelperClient::perform(uint64_t *a1, int a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  uint64_t v8;
  xpc_object_t v9;
  void *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  xpc_object_t v18;
  uint64_t v19;
  void *v20;
  NSObject *v21;
  void *aBlock;
  NSObject *object;
  _QWORD v24[5];
  void *v25;
  dispatch_object_t v26;
  uint64_t v27;
  xpc_object_t v28;
  int v29;
  _QWORD *v30;
  _QWORD block[6];

  v8 = *a1;
  v9 = *a4;
  if (!*a4)
  {
    v9 = xpc_null_create();
    v10 = *(void **)a5;
    if (!*(_QWORD *)a5)
      goto LABEL_6;
    goto LABEL_5;
  }
  xpc_retain(*a4);
  v10 = *(void **)a5;
  if (*(_QWORD *)a5)
LABEL_5:
    v10 = _Block_copy(v10);
LABEL_6:
  v11 = *(NSObject **)(a5 + 8);
  aBlock = v10;
  object = v11;
  if (v11)
    dispatch_retain(v11);
  v12 = MEMORY[0x1A85902BC](v9);
  v13 = MEMORY[0x1E0C812F8];
  if (v12 == MEMORY[0x1E0C812F8])
  {
    v15 = v9;
  }
  else
  {
    v14 = xpc_dictionary_create(0, 0, 0);
    if (v14 || (v14 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A85902BC](v14) == v13)
      {
        xpc_retain(v14);
        v15 = v14;
      }
      else
      {
        v15 = xpc_null_create();
      }
    }
    else
    {
      v15 = xpc_null_create();
      v14 = 0;
    }
    xpc_release(v14);
    v16 = xpc_null_create();
    xpc_release(v9);
    xpc_release(v16);
  }
  v17 = xpc_int64_create(a2);
  if (!v17)
    v17 = xpc_null_create();
  xpc_dictionary_set_value(v15, "TaskID", v17);
  v18 = xpc_null_create();
  xpc_release(v17);
  xpc_release(v18);
  v19 = MEMORY[0x1E0C809B0];
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 1174405120;
  v24[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke;
  v24[3] = &__block_descriptor_tmp_8_6;
  v24[4] = v8;
  v29 = a2;
  v20 = aBlock;
  if (aBlock)
    v20 = _Block_copy(aBlock);
  v25 = v20;
  v26 = object;
  if (object)
    dispatch_retain(object);
  v27 = a3;
  v28 = v15;
  if (v15)
    xpc_retain(v15);
  else
    v28 = xpc_null_create();
  v30 = v24;
  block[0] = v19;
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_4_2;
  block[4] = v8 + 72;
  block[5] = &v30;
  v21 = *(NSObject **)(v8 + 88);
  if (*(_QWORD *)(v8 + 96))
    dispatch_async_and_wait(v21, block);
  else
    dispatch_sync(v21, block);
  xpc_release(v28);
  v28 = 0;
  if (v26)
    dispatch_release(v26);
  if (v25)
    _Block_release(v25);
  if (object)
    dispatch_release(object);
  if (aBlock)
    _Block_release(aBlock);
  xpc_release(v15);
}

void sub_1A350D734(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback((uint64_t)va);
  xpc_release(v2);
  _Unwind_Resume(a1);
}

void abm::HelperClient::perform(uint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, xpc_object_t *a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v10;
  xpc_object_t v11;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  xpc_object_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t *v21;
  std::string *v22;
  __int128 v23;
  _QWORD v24[7];
  xpc_object_t object;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  __n128 (*v31)(__n128 *, __n128 *);
  void (*v32)(uint64_t);
  unint64_t v33;
  void *__p;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD block[6];

  v10 = *a1;
  v11 = *a4;
  if (*a4)
    xpc_retain(*a4);
  else
    v11 = xpc_null_create();
  v12 = MEMORY[0x1A85902BC](v11);
  v13 = MEMORY[0x1E0C812F8];
  if (v12 == MEMORY[0x1E0C812F8])
  {
    v15 = v11;
  }
  else
  {
    v14 = xpc_dictionary_create(0, 0, 0);
    if (v14 || (v14 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A85902BC](v14) == v13)
      {
        xpc_retain(v14);
        v15 = v14;
      }
      else
      {
        v15 = xpc_null_create();
      }
    }
    else
    {
      v15 = xpc_null_create();
      v14 = 0;
    }
    xpc_release(v14);
    v16 = xpc_null_create();
    xpc_release(v11);
    xpc_release(v16);
  }
  v17 = xpc_int64_create(a2);
  if (!v17)
    v17 = xpc_null_create();
  xpc_dictionary_set_value(v15, "TaskID", v17);
  v18 = xpc_null_create();
  xpc_release(v17);
  xpc_release(v18);
  v28 = 0;
  v29 = &v28;
  v30 = 0x4802000000;
  v31 = __Block_byref_object_copy__3;
  v32 = __Block_byref_object_dispose__3;
  v33 = 0xAAAAAAAAE020E001;
  __p = 0;
  v35 = 0;
  v36 = 0;
  v19 = MEMORY[0x1E0C809B0];
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 1174405120;
  v24[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke;
  v24[3] = &unk_1E4A0C7C8;
  v27 = a2;
  v24[4] = &v28;
  v24[5] = v10;
  v24[6] = a3;
  object = v15;
  if (v15)
    xpc_retain(v15);
  else
    object = xpc_null_create();
  v26 = a5;
  v37 = v24;
  block[0] = v19;
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_4_2;
  block[4] = v10 + 72;
  block[5] = &v37;
  v20 = *(NSObject **)(v10 + 88);
  if (*(_QWORD *)(v10 + 96))
  {
    dispatch_async_and_wait(v20, block);
    v21 = v29;
    *a6 = *((_DWORD *)v29 + 10);
    v22 = (std::string *)(a6 + 2);
    if ((*((char *)v21 + 71) & 0x80000000) == 0)
    {
LABEL_20:
      v23 = *((_OWORD *)v21 + 3);
      v22->__r_.__value_.__r.__words[2] = v21[8];
      *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v23;
      goto LABEL_23;
    }
  }
  else
  {
    dispatch_sync(v20, block);
    v21 = v29;
    *a6 = *((_DWORD *)v29 + 10);
    v22 = (std::string *)(a6 + 2);
    if ((*((char *)v21 + 71) & 0x80000000) == 0)
      goto LABEL_20;
  }
  std::string::__init_copy_ctor_external(v22, (const std::string::value_type *)v21[6], v21[7]);
LABEL_23:
  xpc_release(object);
  object = 0;
  _Block_object_dispose(&v28, 8);
  if (SHIBYTE(v36) < 0)
    operator delete(__p);
  xpc_release(v15);
}

void sub_1A350DA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;

  xpc_release(object);
  _Block_object_dispose(&a19, 8);
  if (a30 < 0)
    operator delete(__p);
  xpc_release(v30);
  _Unwind_Resume(a1);
}

void abm::HelperClient::registerForHelperReady(int a1@<W0>, uint64_t a2@<X1>, abm::helper::DaemonObserver **a3@<X8>)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  void *v8;
  abm::helper::DaemonObserver *v9;
  NSObject *v10;
  std::__shared_weak_count *shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  NSObject *v20;

  if (a1 == -1)
  {
    v6 = 0;
    v9 = 0;
    goto LABEL_24;
  }
  v6 = (std::__shared_weak_count *)operator new(0x48uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_1E4A0C858;
  if (*(_QWORD *)a2)
  {
    v8 = _Block_copy(*(const void **)a2);
    v9 = (abm::helper::DaemonObserver *)&v6[1];
    v10 = *(NSObject **)(a2 + 8);
    v19 = v8;
    v20 = v10;
    if (!v10)
      goto LABEL_5;
    goto LABEL_4;
  }
  v8 = 0;
  v9 = (abm::helper::DaemonObserver *)&v6[1];
  v10 = *(NSObject **)(a2 + 8);
  v19 = 0;
  v20 = v10;
  if (v10)
LABEL_4:
    dispatch_retain(v10);
LABEL_5:
  abm::helper::DaemonObserver::DaemonObserver(v9, a1, (uint64_t)&v19);
  if (v10)
    dispatch_release(v10);
  if (v8)
    _Block_release(v8);
  shared_owners = (std::__shared_weak_count *)v6[1].__shared_owners_;
  if (!shared_owners)
  {
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
    do
      v17 = __ldxr(p_shared_weak_owners);
    while (__stxr(v17 + 1, p_shared_weak_owners));
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)&v6[1];
    v6[1].__shared_owners_ = (uint64_t)v6;
    goto LABEL_19;
  }
  if (shared_owners->__shared_owners_ == -1)
  {
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    v13 = (unint64_t *)&v6->__shared_weak_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)&v6[1];
    v6[1].__shared_owners_ = (uint64_t)v6;
    std::__shared_weak_count::__release_weak(shared_owners);
    do
LABEL_19:
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  abm::helper::DaemonObserver::init(v9);
LABEL_24:
  *a3 = v9;
  a3[1] = (abm::helper::DaemonObserver *)v6;
}

void sub_1A350DC30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A350DC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::__shared_weak_count *v11;
  void *v13;

  dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback((uint64_t)&a11);
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v13);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A350DC6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<abm::HelperClientInternal *,std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal *)#1},std::allocator<abm::HelperClientInternal>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<abm::HelperClientInternal *,std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal *)#1},std::allocator<abm::HelperClientInternal>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 88), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal*)#1}::operator() const(abm::HelperClientInternal*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<abm::HelperClientInternal *,std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal *)#1},std::allocator<abm::HelperClientInternal>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__110shared_pt"
                     "rIT_EEPS7_EUlPS2_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__1"
                                "10shared_ptrIT_EEPS7_EUlPS2_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrIT_EEPS7_EUlPS2_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrIT_EEPS7_EUlPS2_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  return 0;
}

uint64_t std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal*)#1}::operator() const(abm::HelperClientInternal*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *ctu::SharedLoggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A0C688;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A0C688;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void abm::HelperClientInternal::~HelperClientInternal(abm::HelperClientInternal *this)
{
  void *v1;

  abm::HelperClientInternal::~HelperClientInternal(this);
  operator delete(v1);
}

{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;

  *(_QWORD *)this = off_1E4A0C578;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (v4)
  {
LABEL_5:
    if ((*((char *)this + 127) & 0x80000000) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if (*((char *)this + 127) < 0)
LABEL_6:
    operator delete(*((void **)this + 13));
LABEL_7:
  *(_QWORD *)this = off_1E4A0C688;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v5 = *((_QWORD *)this + 12);
  if (v5)
    dispatch_release(v5);
  v6 = *((_QWORD *)this + 11);
  if (v6)
    dispatch_release(v6);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
}

uint64_t ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig()
{
  return ctu::LoggerCommonBase::setInheritedLogLevel();
}

void ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 127) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 104), *(_QWORD *)(a1 + 112));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 104);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 120);
  }
}

uint64_t ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return ctu::LoggerCommonBase::getLocalLogLevel((ctu::LoggerCommonBase *)(a1 + 8));
}

void ctu::SharedLoggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = off_1E4A0C688;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  v2 = a1[12];
  if (v2)
    dispatch_release(v2);
  v3 = a1[11];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[10];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  operator delete(a1);
}

_QWORD *ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A0C688;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  return a1;
}

void ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(_QWORD *a1)
{
  *a1 = off_1E4A0C688;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  operator delete(a1);
}

void ___ZN3abm20HelperClientInternal4initEv_block_invoke(uint64_t a1)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v2 = 0;
    _os_log_debug_impl(&dword_1A343C000, v1, OS_LOG_TYPE_DEBUG, "#D Init", v2, 2u);
  }
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  xpc_object_t v5;
  const void *v6;
  void *v7;
  int v8;
  const char *v9;
  xpc_object_t v10;
  xpc_object_t v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  NSObject *v14;
  void *v15;
  const void *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  void *v28;
  NSObject *v29;
  void *v30;
  NSObject *global_queue;
  NSObject *v32;
  const char *v33;
  size_t v34;
  size_t v35;
  _BYTE *v36;
  void *v37;
  void *v38;
  NSObject *v39;
  void *v40;
  NSObject *v41;
  xpc_object_t v42;
  const void *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  _BYTE *v56;
  NSObject *v57;
  void *v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  unsigned int v62;
  const char *v63;
  uint64_t v64;
  xpc_object_t v65;
  void *v66;
  NSObject *v67;
  _QWORD aBlock[5];
  std::__shared_weak_count *v69;
  uint64_t v70;
  std::__shared_weak_count *v71;
  void *v72;
  dispatch_object_t v73;
  void *v74;
  dispatch_object_t v75;
  uint64_t v76;
  std::__shared_weak_count *v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  xpc_object_t object;
  xpc_object_t xdict;
  uint8_t buf[16];
  _BYTE block[24];
  void *v84;
  const void *v85;
  int v86;
  void *v87;
  uint64_t v88;
  uint64_t v89;
  xpc_object_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 72) - 1;
  if (v3 < 0xA && ((0x3FDu >> v3) & 1) != 0)
  {
    v8 = dword_1A3582BB0[v3];
    xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    abm::helper::getUserConfig(v8, &xdict);
    v9 = (const char *)(v2 + 104);
    if (*(char *)(v2 + 127) < 0)
      v9 = *(const char **)v9;
    v10 = xpc_string_create(v9);
    if (!v10)
      v10 = xpc_null_create();
    xpc_dictionary_set_value(xdict, (const char *)*MEMORY[0x1E0DBD898], v10);
    v11 = xpc_null_create();
    xpc_release(v10);
    xpc_release(v11);
    v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      xpc::object::to_string((xpc::object *)&xdict);
      v56 = block[23] >= 0 ? block : *(_BYTE **)block;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v56;
      _os_log_debug_impl(&dword_1A343C000, v12, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
      if ((block[23] & 0x80000000) != 0)
        operator delete(*(void **)block);
    }
    memset(buf, 170, sizeof(buf));
    object = xdict;
    if (xdict)
    {
      xpc_retain(xdict);
      v13 = *(std::__shared_weak_count **)(v2 + 136);
      v78 = *(_QWORD *)(v2 + 128);
      v79 = v13;
      if (!v13)
        goto LABEL_34;
    }
    else
    {
      object = xpc_null_create();
      v13 = *(std::__shared_weak_count **)(v2 + 136);
      v78 = *(_QWORD *)(v2 + 128);
      v79 = v13;
      if (!v13)
        goto LABEL_34;
    }
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
LABEL_34:
    TelephonyXPC::Client::create();
    if (v79)
    {
      v19 = &v79->__shared_owners_;
      do
        v20 = __ldaxr((unint64_t *)v19);
      while (__stlxr(v20 - 1, (unint64_t *)v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
        std::__shared_weak_count::__release_weak(v79);
      }
    }
    xpc_release(object);
    object = 0;
    if (*(_QWORD *)buf)
    {
      v22 = *(_QWORD *)(v2 + 72);
      v21 = *(std::__shared_weak_count **)(v2 + 80);
      v76 = v22;
      if (!v21 || (v23 = std::__shared_weak_count::lock(v21), (v77 = v23) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v74 = (void *)0xAAAAAAAAAAAAAAAALL;
      v75 = (dispatch_object_t)0xAAAAAAAAAAAAAAAALL;
      aBlock[0] = MEMORY[0x1E0C809B0];
      aBlock[1] = 1174405120;
      aBlock[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke_5;
      aBlock[3] = &__block_descriptor_tmp_7_6;
      aBlock[4] = v22;
      v69 = v23;
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
      v70 = *(_QWORD *)buf;
      v71 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v26 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
      }
      v28 = *(void **)(a1 + 40);
      if (v28)
        v28 = _Block_copy(v28);
      v29 = *(NSObject **)(a1 + 48);
      v72 = v28;
      v73 = v29;
      if (v29)
        dispatch_retain(v29);
      v30 = _Block_copy(aBlock);
      global_queue = dispatch_get_global_queue(0, 0);
      v32 = global_queue;
      if (global_queue)
        dispatch_retain(global_queue);
      v74 = v30;
      v75 = v32;
      v33 = *(const char **)(a1 + 56);
      v34 = strlen(v33);
      if (v34 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      v35 = v34;
      if (v34 >= 0x17)
      {
        v45 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v34 | 7) != 0x17)
          v45 = v34 | 7;
        v46 = v45 + 1;
        v36 = operator new(v45 + 1);
        *(_QWORD *)&block[8] = v35;
        *(_QWORD *)&block[16] = v46 | 0x8000000000000000;
        *(_QWORD *)block = v36;
      }
      else
      {
        block[23] = v34;
        v36 = block;
        if (!v34)
        {
          block[0] = 0;
          v37 = v74;
          if (v74)
            goto LABEL_57;
          goto LABEL_70;
        }
      }
      memmove(v36, v33, v35);
      v36[v35] = 0;
      v37 = v74;
      if (v74)
      {
LABEL_57:
        v38 = _Block_copy(v37);
        v39 = v75;
        v66 = v38;
        v67 = v75;
        if (!v75)
        {
LABEL_59:
          v40 = *(void **)(a1 + 64);
          v65 = v40;
          if (v40)
            xpc_retain(v40);
          else
            v65 = xpc_null_create();
          TelephonyXPC::Client::perform();
          xpc_release(v65);
          if (v67)
            dispatch_release(v67);
          if (v66)
            _Block_release(v66);
          if ((block[23] & 0x80000000) != 0)
            operator delete(*(void **)block);
          if (v39)
            dispatch_release(v39);
          if (v37)
            _Block_release(v37);
          if (v73)
            dispatch_release(v73);
          if (v72)
            _Block_release(v72);
          v47 = v71;
          if (v71)
          {
            v48 = (unint64_t *)&v71->__shared_owners_;
            do
              v49 = __ldaxr(v48);
            while (__stlxr(v49 - 1, v48));
            if (!v49)
            {
              ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
              std::__shared_weak_count::__release_weak(v47);
            }
          }
          v50 = v69;
          if (v69)
          {
            v51 = (unint64_t *)&v69->__shared_owners_;
            do
              v52 = __ldaxr(v51);
            while (__stlxr(v52 - 1, v51));
            if (!v52)
            {
              ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
              std::__shared_weak_count::__release_weak(v50);
            }
          }
          v53 = v77;
          if (v77)
          {
            v54 = (unint64_t *)&v77->__shared_owners_;
            do
              v55 = __ldaxr(v54);
            while (__stlxr(v55 - 1, v54));
            if (!v55)
            {
              ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
              std::__shared_weak_count::__release_weak(v53);
            }
          }
          goto LABEL_123;
        }
LABEL_58:
        dispatch_retain(v39);
        goto LABEL_59;
      }
LABEL_70:
      v39 = v75;
      v66 = 0;
      v67 = v75;
      if (!v75)
        goto LABEL_59;
      goto LABEL_58;
    }
    v41 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      v62 = *(_DWORD *)(a1 + 72) - 1;
      if (v62 > 9)
        v63 = "invalid";
      else
        v63 = off_1E4A0C898[v62];
      v64 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)block = 136315394;
      *(_QWORD *)&block[4] = v63;
      *(_WORD *)&block[12] = 2080;
      *(_QWORD *)&block[14] = v64;
      _os_log_error_impl(&dword_1A343C000, v41, OS_LOG_TYPE_ERROR, "Unable to perform command: %s, %s", block, 0x16u);
      if (*(_QWORD *)(a1 + 40))
      {
LABEL_63:
        if (*(_QWORD *)(a1 + 48))
        {
          v42 = xpc_null_create();
          v43 = *(const void **)(a1 + 40);
          if (v43)
            v44 = _Block_copy(v43);
          else
            v44 = 0;
          v57 = *(NSObject **)(a1 + 48);
          *(_QWORD *)block = MEMORY[0x1E0C809B0];
          *(_QWORD *)&block[8] = 1174405120;
          *(_QWORD *)&block[16] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0;
          v84 = &__block_descriptor_tmp_9_3;
          if (v44)
            v58 = _Block_copy(v44);
          else
            v58 = 0;
          v85 = v58;
          v86 = -534716415;
          v87 = 0;
          v88 = 0;
          v89 = 0;
          v90 = v42;
          if (v42)
            xpc_retain(v42);
          else
            v90 = xpc_null_create();
          dispatch_async(v57, block);
          xpc_release(v90);
          v90 = 0;
          if (SHIBYTE(v89) < 0)
            operator delete(v87);
          if (v85)
            _Block_release(v85);
          if (v44)
            _Block_release(v44);
          xpc_release(v42);
        }
      }
    }
    else if (*(_QWORD *)(a1 + 40))
    {
      goto LABEL_63;
    }
LABEL_123:
    v59 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v60 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    xpc_release(xdict);
    return;
  }
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)block = 0;
    _os_log_error_impl(&dword_1A343C000, v4, OS_LOG_TYPE_ERROR, "Task not available!", block, 2u);
    if (!*(_QWORD *)(a1 + 40))
      return;
  }
  else if (!*(_QWORD *)(a1 + 40))
  {
    return;
  }
  if (*(_QWORD *)(a1 + 48))
  {
    v5 = xpc_null_create();
    v6 = *(const void **)(a1 + 40);
    if (v6)
      v7 = _Block_copy(v6);
    else
      v7 = 0;
    v14 = *(NSObject **)(a1 + 48);
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    *(_QWORD *)&block[8] = 1174405120;
    *(_QWORD *)&block[16] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0;
    v84 = &__block_descriptor_tmp_9_3;
    if (v7)
      v15 = _Block_copy(v7);
    else
      v15 = 0;
    v85 = v15;
    v86 = -534716415;
    v87 = 0;
    v88 = 0;
    v89 = 0;
    v90 = v5;
    if (v5)
      xpc_retain(v5);
    else
      v90 = xpc_null_create();
    dispatch_async(v14, block);
    xpc_release(v90);
    v90 = 0;
    if (SHIBYTE(v89) < 0)
    {
      operator delete(v87);
      v16 = v85;
      if (!v85)
      {
LABEL_28:
        if (v7)
          _Block_release(v7);
        xpc_release(v5);
        return;
      }
    }
    else
    {
      v16 = v85;
      if (!v85)
        goto LABEL_28;
    }
    _Block_release(v16);
    goto LABEL_28;
  }
}

void sub_1A350E824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,char a27,uint64_t a28,xpc_object_t a29,xpc_object_t a30,char a31)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke_5(uint64_t a1, int *a2, xpc_object_t *a3)
{
  xpc_object_t v5;
  const void *v6;
  void *v7;
  NSObject *v8;
  void *v9;
  void *v10;
  int v11;
  std::string v12;
  _QWORD block[4];
  void *aBlock;
  int v15;
  std::string __p;
  xpc_object_t object;

  if (!*(_QWORD *)(a1 + 64) || !*(_QWORD *)(a1 + 72))
    return;
  v11 = *a2;
  if ((*((char *)a2 + 31) & 0x80000000) == 0)
  {
    v12 = *(std::string *)(a2 + 2);
    v5 = *a3;
    if (*a3)
      goto LABEL_5;
LABEL_8:
    v5 = xpc_null_create();
    v6 = *(const void **)(a1 + 64);
    if (v6)
      goto LABEL_6;
    goto LABEL_9;
  }
  std::string::__init_copy_ctor_external(&v12, *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
  v5 = *a3;
  if (!v5)
    goto LABEL_8;
LABEL_5:
  xpc_retain(v5);
  v6 = *(const void **)(a1 + 64);
  if (v6)
  {
LABEL_6:
    v7 = _Block_copy(v6);
    goto LABEL_10;
  }
LABEL_9:
  v7 = 0;
LABEL_10:
  v8 = *(NSObject **)(a1 + 72);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 1174405120;
  block[2] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0;
  block[3] = &__block_descriptor_tmp_9_3;
  if (v7)
    v9 = _Block_copy(v7);
  else
    v9 = 0;
  aBlock = v9;
  v15 = v11;
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v12.__r_.__value_.__l.__data_, v12.__r_.__value_.__l.__size_);
  else
    __p = v12;
  object = v5;
  if (v5)
    xpc_retain(v5);
  else
    object = xpc_null_create();
  dispatch_async(v8, block);
  xpc_release(object);
  object = 0;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v10 = aBlock;
    if (!aBlock)
      goto LABEL_24;
    goto LABEL_23;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  v10 = aBlock;
  if (aBlock)
LABEL_23:
    _Block_release(v10);
LABEL_24:
  if (v7)
    _Block_release(v7);
  xpc_release(v5);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
}

void sub_1A350EB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *aBlock)
{
  void *v20;
  const void *v21;

  if (aBlock)
    _Block_release(aBlock);
  if (v21)
    _Block_release(v21);
  xpc_release(v20);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_32c54_ZTSNSt3__110shared_ptrIN3abm20HelperClientInternalEEE48c49_ZTSNSt3__110shared_ptrIN12TelephonyXPC6ClientEEE64c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  void *v10;
  NSObject *v11;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = a2[7];
  a1[6] = a2[6];
  a1[7] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = (void *)a2[8];
  if (v10)
    v10 = _Block_copy(v10);
  v11 = a2[9];
  a1[8] = v10;
  a1[9] = v11;
  if (v11)
    dispatch_retain(v11);
}

void __destroy_helper_block_e8_32c54_ZTSNSt3__110shared_ptrIN3abm20HelperClientInternalEEE48c49_ZTSNSt3__110shared_ptrIN12TelephonyXPC6ClientEEE64c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE(_QWORD *a1)
{
  NSObject *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;

  v2 = a1[9];
  if (v2)
    dispatch_release(v2);
  v3 = (const void *)a1[8];
  if (v3)
    _Block_release(v3);
  v4 = (std::__shared_weak_count *)a1[7];
  if (!v4)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    v7 = (std::__shared_weak_count *)a1[5];
    if (!v7)
      return;
  }
  else
  {
LABEL_9:
    v7 = (std::__shared_weak_count *)a1[5];
    if (!v7)
      return;
  }
  v8 = (unint64_t *)&v7->__shared_owners_;
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

xpc_object_t __copy_helper_block_e8_40c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE64c15_ZTSN3xpc4dictE(_QWORD *a1, _QWORD *a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  xpc_object_t result;

  v4 = (void *)a2[5];
  if (v4)
    v4 = _Block_copy(v4);
  v5 = a2[6];
  a1[5] = v4;
  a1[6] = v5;
  if (v5)
    dispatch_retain(v5);
  v6 = (void *)a2[8];
  a1[8] = v6;
  if (v6)
    return xpc_retain(v6);
  result = xpc_null_create();
  a1[8] = result;
  return result;
}

void __destroy_helper_block_e8_40c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE64c15_ZTSN3xpc4dictE(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  xpc_release(*(xpc_object_t *)(a1 + 64));
  *(_QWORD *)(a1 + 64) = 0;
  v2 = *(NSObject **)(a1 + 48);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    _Block_release(v3);
}

void ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0(uint64_t a1)
{
  dispatch::block<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::operator()<TelephonyXPC::Result const&,xpc::dict const&>((uint64_t *)(a1 + 32), (int *)(a1 + 40), (void **)(a1 + 72));
}

__n128 __Block_byref_object_copy__3(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[2].n128_u32[2] = a2[2].n128_u32[2];
  result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  NSObject *v3;
  int v5;
  const char *v6;
  xpc_object_t v7;
  xpc_object_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  NSObject *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  void *v22;
  NSObject *global_queue;
  NSObject *v24;
  const char *v25;
  size_t v26;
  void *v27;
  xpc_object_t *v28;
  void *v29;
  void *v30;
  NSObject *v31;
  void *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  xpc_object_t value;
  char *v45;
  size_t v46;
  void *v47;
  xpc_object_t *v48;
  unsigned int v49;
  dispatch_time_t v50;
  void **v51;
  xpc_object_t v52;
  void *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  xpc_object_t *v59;
  xpc_object_t v60;
  void *v61;
  NSObject *v62;
  _QWORD aBlock[7];
  std::__shared_weak_count *v64;
  dispatch_group_t group;
  void *v66;
  dispatch_object_t v67;
  uint64_t v68;
  std::__shared_weak_count *v69;
  uint64_t v70;
  std::__shared_weak_count *v71;
  xpc_object_t object;
  xpc_object_t __dst[3];
  xpc_object_t v74;
  uint8_t buf[8];
  uint8_t *v76;
  uint64_t v77;
  xpc_object_t (*v78)(uint64_t, uint64_t);
  void (*v79)(uint64_t);
  xpc_object_t v80;
  uint8_t v81[24];
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_DWORD *)(a1 + 72) - 1;
  if (v2 >= 0xA || ((0x3FDu >> v2) & 1) == 0)
  {
    v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1A343C000, v3, OS_LOG_TYPE_ERROR, "Task not available!", buf, 2u);
    }
    return;
  }
  v5 = dword_1A3582BB0[v2];
  *(_QWORD *)buf = 0;
  v76 = buf;
  v77 = 0x3002000000;
  v78 = __Block_byref_object_copy__10;
  v79 = __Block_byref_object_dispose__11;
  v80 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  v80 = xpc_null_create();
  v74 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  abm::helper::getUserConfig(v5, &v74);
  v6 = (const char *)(v1 + 104);
  if (*(char *)(v1 + 127) < 0)
    v6 = *(const char **)v6;
  v7 = xpc_string_create(v6);
  if (!v7)
    v7 = xpc_null_create();
  xpc_dictionary_set_value(v74, (const char *)*MEMORY[0x1E0DBD898], v7);
  v8 = xpc_null_create();
  xpc_release(v7);
  xpc_release(v8);
  v9 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    v45 = (char *)MEMORY[0x1A8590268](v74);
    memset(__dst, 170, sizeof(__dst));
    v46 = strlen(v45);
    if (v46 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v47 = (void *)v46;
    if (v46 >= 0x17)
    {
      v57 = (v46 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v46 | 7) != 0x17)
        v57 = v46 | 7;
      v58 = v57 + 1;
      v48 = (xpc_object_t *)operator new(v57 + 1);
      __dst[1] = v47;
      __dst[2] = (xpc_object_t)(v58 | 0x8000000000000000);
      __dst[0] = v48;
    }
    else
    {
      HIBYTE(__dst[2]) = v46;
      v48 = __dst;
      if (!v46)
        goto LABEL_105;
    }
    memcpy(v48, v45, (size_t)v47);
LABEL_105:
    *((_BYTE *)v47 + (_QWORD)v48) = 0;
    free(v45);
    v59 = __dst;
    if (SHIBYTE(__dst[2]) < 0)
      v59 = (xpc_object_t *)__dst[0];
    *(_DWORD *)v81 = 136315138;
    *(_QWORD *)&v81[4] = v59;
    _os_log_debug_impl(&dword_1A343C000, v9, OS_LOG_TYPE_DEBUG, "#D %s", v81, 0xCu);
    if (SHIBYTE(__dst[2]) < 0)
      operator delete(__dst[0]);
  }
  memset(v81, 170, 16);
  object = v74;
  if (v74)
  {
    xpc_retain(v74);
    v10 = *(std::__shared_weak_count **)(v1 + 136);
    v70 = *(_QWORD *)(v1 + 128);
    v71 = v10;
    if (!v10)
      goto LABEL_16;
  }
  else
  {
    object = xpc_null_create();
    v10 = *(std::__shared_weak_count **)(v1 + 136);
    v70 = *(_QWORD *)(v1 + 128);
    v71 = v10;
    if (!v10)
      goto LABEL_16;
  }
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
LABEL_16:
  TelephonyXPC::Client::create();
  if (v71)
  {
    v13 = &v71->__shared_owners_;
    do
      v14 = __ldaxr((unint64_t *)v13);
    while (__stlxr(v14 - 1, (unint64_t *)v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  xpc_release(object);
  object = 0;
  if (!*(_QWORD *)v81)
  {
    v33 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__dst[0]) = 0;
      _os_log_error_impl(&dword_1A343C000, v33, OS_LOG_TYPE_ERROR, "Task not available!", (uint8_t *)__dst, 2u);
    }
    v16 = 0;
    goto LABEL_92;
  }
  v15 = dispatch_group_create();
  v16 = v15;
  if (v15)
  {
    dispatch_retain(v15);
    dispatch_group_enter(v16);
  }
  v18 = *(_QWORD *)(v1 + 72);
  v17 = *(std::__shared_weak_count **)(v1 + 80);
  v68 = v18;
  if (!v17 || (v19 = std::__shared_weak_count::lock(v17), (v69 = v19) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v66 = (void *)0xAAAAAAAAAAAAAAAALL;
  v67 = (dispatch_object_t)0xAAAAAAAAAAAAAAAALL;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 1174405120;
  aBlock[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke_12;
  aBlock[3] = &unk_1E4A0C790;
  aBlock[6] = v18;
  v64 = v19;
  v20 = (unint64_t *)&v19->__shared_owners_;
  do
    v21 = __ldxr(v20);
  while (__stxr(v21 + 1, v20));
  group = v16;
  if (v16)
  {
    dispatch_retain(v16);
    dispatch_group_enter(group);
  }
  aBlock[4] = *(_QWORD *)(a1 + 32);
  aBlock[5] = buf;
  v22 = _Block_copy(aBlock);
  global_queue = dispatch_get_global_queue(0, 0);
  v24 = global_queue;
  if (global_queue)
    dispatch_retain(global_queue);
  v66 = v22;
  v67 = v24;
  v25 = *(const char **)(a1 + 48);
  v26 = strlen(v25);
  if (v26 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v27 = (void *)v26;
  if (v26 >= 0x17)
  {
    v34 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v26 | 7) != 0x17)
      v34 = v26 | 7;
    v35 = v34 + 1;
    v28 = (xpc_object_t *)operator new(v34 + 1);
    __dst[1] = v27;
    __dst[2] = (xpc_object_t)(v35 | 0x8000000000000000);
    __dst[0] = v28;
  }
  else
  {
    HIBYTE(__dst[2]) = v26;
    v28 = __dst;
    if (!v26)
    {
      LOBYTE(__dst[0]) = 0;
      v29 = v66;
      if (v66)
        goto LABEL_36;
      goto LABEL_47;
    }
  }
  memmove(v28, v25, (size_t)v27);
  *((_BYTE *)v27 + (_QWORD)v28) = 0;
  v29 = v66;
  if (v66)
  {
LABEL_36:
    v30 = _Block_copy(v29);
    v31 = v67;
    v61 = v30;
    v62 = v67;
    if (!v67)
      goto LABEL_38;
    goto LABEL_37;
  }
LABEL_47:
  v31 = v67;
  v61 = 0;
  v62 = v67;
  if (v67)
LABEL_37:
    dispatch_retain(v31);
LABEL_38:
  v32 = *(void **)(a1 + 56);
  v60 = v32;
  if (v32)
    xpc_retain(v32);
  else
    v60 = xpc_null_create();
  TelephonyXPC::Client::perform();
  xpc_release(v60);
  if (v62)
    dispatch_release(v62);
  if (v61)
    _Block_release(v61);
  if (SHIBYTE(__dst[2]) < 0)
    operator delete(__dst[0]);
  if (v31)
    dispatch_release(v31);
  if (v29)
    _Block_release(v29);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  v36 = v64;
  if (v64)
  {
    v37 = (unint64_t *)&v64->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v69;
  if (v69)
  {
    v40 = (unint64_t *)&v69->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  if (!v16)
    goto LABEL_92;
  dispatch_group_leave(v16);
  dispatch_release(v16);
  if (MEMORY[0x1A85902BC](*(_QWORD *)(a1 + 56)) == MEMORY[0x1E0C812F8])
  {
    value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "Timeout");
    __dst[0] = value;
    if (value)
      xpc_retain(value);
    else
      __dst[0] = xpc_null_create();
    v49 = xpc::dyn_cast_or_default();
    xpc_release(__dst[0]);
    if (v49)
    {
      v50 = dispatch_time(0, 1000000 * v49);
      if (!dispatch_group_wait(v16, v50))
        goto LABEL_88;
LABEL_76:
      v42 = (char *)operator new(0x30uLL);
      strcpy(v42, "Timeout waiting for response from helper server");
      v43 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)(v43 + 40) = -534716413;
      if (*(char *)(v43 + 71) < 0)
        operator delete(*(void **)(v43 + 48));
      *(_QWORD *)(v43 + 48) = v42;
      *(_QWORD *)(v43 + 56) = 47;
      *(_QWORD *)(v43 + 64) = 0x8000000000000030;
      goto LABEL_92;
    }
  }
  if (dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL))
    goto LABEL_76;
LABEL_88:
  v51 = *(void ***)(a1 + 64);
  v52 = (xpc_object_t)*((_QWORD *)v76 + 5);
  if (v52)
    xpc_retain(*((xpc_object_t *)v76 + 5));
  else
    v52 = xpc_null_create();
  v53 = *v51;
  *v51 = v52;
  xpc_release(v53);
LABEL_92:
  v54 = *(std::__shared_weak_count **)&v81[8];
  if (*(_QWORD *)&v81[8])
  {
    v55 = (unint64_t *)(*(_QWORD *)&v81[8] + 8);
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  xpc_release(v74);
  if (v16)
    dispatch_release(v16);
  _Block_object_dispose(buf, 8);
  xpc_release(v80);
}

