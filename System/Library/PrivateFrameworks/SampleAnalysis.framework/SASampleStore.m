@implementation SASampleStore

- (int64_t)addMicrostackshotsFromData:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8
{
  return -[SASampleStore addMicrostackshotsFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:](self, "addMicrostackshotsFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:", a3, *(_QWORD *)&a4, *(_QWORD *)&a7, a8, 0, a5, a6);
}

- (SAFrame)cpuSignalHandlerStackLeafKernelFrame
{
  return (SAFrame *)objc_getProperty(self, a2, 416, 1);
}

- (id)sharedCacheWithUUID:(uint64_t)a3 slide:(uint64_t)a4 slidBaseAddress:
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  void *v13;
  void *v14;
  void *v15;
  id v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  objc_msgSend(*(id *)(a1 + 112), "reverseObjectEnumerator", 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v9)
  {
    v10 = v9;
    v11 = *(_QWORD *)v19;
    while (2)
    {
      for (i = 0; i != v10; ++i)
      {
        if (*(_QWORD *)v19 != v11)
          objc_enumerationMutation(v8);
        v13 = *(void **)(*((_QWORD *)&v18 + 1) + 8 * i);
        if ((objc_msgSend(v13, "matchesUUID:slide:slidBaseAddress:", a2, a3, a4) & 1) != 0)
        {
          v17 = v13;

          return v17;
        }
      }
      v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
      if (v10)
        continue;
      break;
    }
  }

  uuidForBytes(a2);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  +[SASharedCache sharedCacheWithUUID:slide:slidBaseAddress:](SASharedCache, "sharedCacheWithUUID:slide:slidBaseAddress:", v14, a3, a4);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(*(id *)(a1 + 112), "addObject:", v15);
  return v15;
}

- (NSArray)sharedCaches
{
  return (NSArray *)objc_getProperty(self, a2, 112, 1);
}

- (SATimestamp)startTime
{
  void *startTime;
  void *v4;
  SATimestamp *v5;

  -[NSMutableArray firstObject](self->_sampleTimestamps, "firstObject");
  startTime = (void *)objc_claimAutoreleasedReturnValue();
  v4 = startTime;
  if (!startTime)
    startTime = self->_startTime;
  v5 = startTime;

  return v5;
}

- (id)addPowerModeTransition:(id *)a1
{
  id v3;
  uint64_t v4;
  id v5;
  void *v6;
  double v7;
  double v8;
  id v9;
  unint64_t v10;
  void *v11;
  void *v12;
  double v13;
  double v14;
  int v15;
  NSObject *v16;
  id *v17;
  void *v19;
  void *v20;
  void *v21;
  _QWORD v22[5];
  uint8_t buf[4];
  void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (a1)
  {
    if (!a1[10])
    {
      v4 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 1);
      v5 = a1[10];
      a1[10] = (id)v4;

    }
    objc_msgSend(v3, "timestamp");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "wallTime");
    v8 = v7;

    v9 = a1[10];
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = __40__SASampleStore_addPowerModeTransition___block_invoke;
    v22[3] = &__block_descriptor_40_e31_q16__0__SAPowerModeTransition_8l;
    *(double *)&v22[4] = v8;
    v10 = SABinarySearchArray(v9, 1280, (uint64_t)v22);
    if (v10 >= objc_msgSend(a1[10], "count"))
      goto LABEL_9;
    objc_msgSend(a1[10], "objectAtIndexedSubscript:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "timestamp");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "wallTime");
    v14 = v13;

    if (v14 == v8)
    {
      v15 = *__error();
      _sa_logt();
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(a1[10], "objectAtIndexedSubscript:", v10);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v19, "timestamp");
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v20, "debugDescription");
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        v24 = v21;
        _os_log_debug_impl(&dword_1B9BE0000, v16, OS_LOG_TYPE_DEBUG, "Already have a power mode transition at %{public}@", buf, 0xCu);

      }
      *__error() = v15;
      objc_msgSend(a1[10], "objectAtIndexedSubscript:", v10);
      v17 = (id *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
LABEL_9:
      objc_msgSend(a1[10], "insertObject:atIndex:", v3, v10);
      v17 = (id *)v3;
    }
    a1 = v17;
  }

  return a1;
}

- (SATask)targetProcess
{
  return self->_targetProcess;
}

- (void)setTargetProcessId:(int)a3
{
  if (self->_targetProcessId != a3)
  {
    self->_targetProcessId = a3;
    self->_targetThreadId = 0;
    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)self, 0);
  }
}

- (SASampleStore)init
{
  SASampleStore *v2;
  NSMutableDictionary *v3;
  NSMutableDictionary *tasksByPid;
  NSMutableDictionary *v5;
  NSMutableDictionary *tasksByUniquePid;
  SATask *targetProcess;
  NSMutableArray *v8;
  NSMutableArray *sampleTimestamps;
  NSMutableArray *v10;
  NSMutableArray *hidEvents;
  NSMutableArray *v12;
  NSMutableArray *gestures;
  NSMutableArray *v14;
  NSMutableArray *ioEvents;
  NSMutableDictionary *v16;
  NSMutableDictionary *ioEventsByTid;
  NSMutableArray *v18;
  NSMutableArray *memoryPressureEvents;
  uint64_t v20;
  NSMutableArray *kernelCaches;
  uint64_t v22;
  NSMutableArray *sharedCaches;
  NSMutableArray *v24;
  NSMutableArray *fanSpeeds;
  SAMountStatusTracker *v26;
  SAMountStatusTracker *mountStatusTracker;
  SAWSUpdateDataStore *wsDataStore;
  SABinaryLocator *v29;
  SABinaryLocator *binaryLocator;
  objc_super v32;

  v32.receiver = self;
  v32.super_class = (Class)SASampleStore;
  v2 = -[SASampleStore init](&v32, sel_init);
  if (v2)
  {
    v3 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
    tasksByPid = v2->_tasksByPid;
    v2->_tasksByPid = v3;

    v5 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
    tasksByUniquePid = v2->_tasksByUniquePid;
    v2->_tasksByUniquePid = v5;

    v2->_targetProcessId = -1;
    targetProcess = v2->_targetProcess;
    v2->_targetProcess = 0;

    v8 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    sampleTimestamps = v2->_sampleTimestamps;
    v2->_sampleTimestamps = v8;

    v10 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    hidEvents = v2->_hidEvents;
    v2->_hidEvents = v10;

    v12 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    gestures = v2->_gestures;
    v2->_gestures = v12;

    v14 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    ioEvents = v2->_ioEvents;
    v2->_ioEvents = v14;

    v16 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
    ioEventsByTid = v2->_ioEventsByTid;
    v2->_ioEventsByTid = v16;

    v18 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    memoryPressureEvents = v2->_memoryPressureEvents;
    v2->_memoryPressureEvents = v18;

    v20 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 1);
    kernelCaches = v2->_kernelCaches;
    v2->_kernelCaches = (NSMutableArray *)v20;

    v22 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 1);
    sharedCaches = v2->_sharedCaches;
    v2->_sharedCaches = (NSMutableArray *)v22;

    v24 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    fanSpeeds = v2->_fanSpeeds;
    v2->_fanSpeeds = v24;

    v26 = objc_alloc_init(SAMountStatusTracker);
    mountStatusTracker = v2->_mountStatusTracker;
    v2->_mountStatusTracker = v26;

    wsDataStore = v2->_wsDataStore;
    v2->_wsDataStore = 0;

    v29 = +[SABinaryLocator sharedBinaryLocator](SABinaryLocator, "sharedBinaryLocator");
    binaryLocator = v2->_binaryLocator;
    v2->_binaryLocator = v29;

    v2->_additionalCSSymbolicatorFlags = 0;
    v2->_sampleOnlyMainThreads = 0;
    v2->_stackshotsOnlyIncludeSpecificProcesses = 0;
  }
  return v2;
}

- (id)initForLiveSampling
{
  id result;

  result = -[SASampleStore init](self, "init");
  if (result)
  {
    *((_BYTE *)result + 316) = 1;
    *((_QWORD *)result + 51) = 1415;
  }
  return result;
}

- (SATimestamp)endTime
{
  void *endTime;
  void *v4;
  SATimestamp *v5;

  -[NSMutableArray lastObject](self->_sampleTimestamps, "lastObject");
  endTime = (void *)objc_claimAutoreleasedReturnValue();
  v4 = endTime;
  if (!endTime)
    endTime = self->_endTime;
  v5 = endTime;

  return v5;
}

- (void)gatherBootArgs
{
  size_t v2;
  _BYTE *v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  void *v7;
  int v8;
  int *v9;
  char *v10;
  uint64_t v11;
  size_t v12;
  uint8_t buf[4];
  int v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 && !*(_QWORD *)(a1 + 496))
  {
    v2 = *MEMORY[0x1E0C85AD8];
    v3 = (char *)&v11 - ((*MEMORY[0x1E0C85AD8] + 15) & 0xFFFFFFFFFFFFFFF0);
    *v3 = 0;
    v12 = v2;
    if (sysctlbyname("kern.bootargs", v3, &v12, 0, 0))
    {
      v4 = *__error();
      _sa_logt();
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v8 = *__error();
        v9 = __error();
        v10 = strerror(*v9);
        *(_DWORD *)buf = 67109378;
        v14 = v8;
        v15 = 2080;
        v16 = v10;
        _os_log_error_impl(&dword_1B9BE0000, v5, OS_LOG_TYPE_ERROR, "Unable to get kern.bootargs: %d %s", buf, 0x12u);
      }

      *__error() = v4;
    }
    else
    {
      SANSStringForCString(v3);
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = *(void **)(a1 + 496);
      *(_QWORD *)(a1 + 496) = v6;

    }
  }
}

- (unint64_t)dataGatheringOptions
{
  return self->_dataGatheringOptions;
}

- (void)setDataGatheringOptions:(unint64_t)a3
{
  self->_dataGatheringOptions = a3;
}

- (void)findTargetProcessInTimeRange:(uint64_t)a1
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  uint64_t v27;
  void *v28;
  int v29;
  NSObject *v30;
  int v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (!a1)
    goto LABEL_15;
  v4 = *(void **)(a1 + 160);
  *(_QWORD *)(a1 + 160) = 0;

  v5 = *(_QWORD *)(a1 + 168);
  if (v5)
  {
    if (v3)
    {
      objc_msgSend(v3, "endTime");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      -[SASampleStore taskWithPid:orTid:atTimestamp:]((id)a1, 0xFFFFFFFFLL, v5, v6);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = v7;
      if (v7)
      {
        v9 = v7;
        v10 = *(void **)(a1 + 160);
        *(_QWORD *)(a1 + 160) = v9;
      }
      else
      {
        v18 = *(_QWORD *)(a1 + 168);
        objc_msgSend(v3, "startTime");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        -[SASampleStore taskWithPid:orTid:atTimestamp:]((id)a1, 0xFFFFFFFFLL, v18, v10);
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = *(void **)(a1 + 160);
        *(_QWORD *)(a1 + 160) = v19;

      }
      v13 = *(void **)(a1 + 160);
      if (v13)
        goto LABEL_11;
      v14 = *__error();
      _sa_logt();
      v15 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        goto LABEL_13;
      v36 = *(_QWORD *)(a1 + 168);
      v38 = 134217984;
      v39 = v36;
      v17 = "No task with thread 0x%llx in event time range, clearing target thread";
    }
    else
    {
      -[SASampleStore lastTaskWithPid:orTid:]((_QWORD *)a1, 0xFFFFFFFFLL, *(_QWORD *)(a1 + 168));
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = *(void **)(a1 + 160);
      *(_QWORD *)(a1 + 160) = v11;

      v13 = *(void **)(a1 + 160);
      if (v13)
      {
LABEL_11:
        *(_DWORD *)(a1 + 152) = objc_msgSend(v13, "pid");
        goto LABEL_14;
      }
      v14 = *__error();
      _sa_logt();
      v15 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
LABEL_13:

        *__error() = v14;
        *(_QWORD *)(a1 + 168) = 0;
        goto LABEL_14;
      }
      v16 = *(_QWORD *)(a1 + 168);
      v38 = 134217984;
      v39 = v16;
      v17 = "No task with thread 0x%llx, clearing target thread";
    }
    _os_log_error_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v38, 0xCu);
    goto LABEL_13;
  }
LABEL_14:
  if (!*(_QWORD *)(a1 + 160))
  {
    v21 = *(unsigned int *)(a1 + 152);
    if ((v21 & 0x80000000) == 0)
    {
      if (v3)
      {
        objc_msgSend(v3, "endTime");
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        -[SASampleStore taskWithPid:atTimestamp:](a1, v21, v22);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        v24 = v23;
        if (v23)
        {
          v25 = v23;
          v26 = *(void **)(a1 + 160);
          *(_QWORD *)(a1 + 160) = v25;
        }
        else
        {
          v33 = *(unsigned int *)(a1 + 152);
          objc_msgSend(v3, "startTime");
          v26 = (void *)objc_claimAutoreleasedReturnValue();
          -[SASampleStore taskWithPid:atTimestamp:](a1, v33, v26);
          v34 = objc_claimAutoreleasedReturnValue();
          v35 = *(void **)(a1 + 160);
          *(_QWORD *)(a1 + 160) = v34;

        }
        if (!*(_QWORD *)(a1 + 160))
        {
          v29 = *__error();
          _sa_logt();
          v30 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            goto LABEL_26;
          v37 = *(_DWORD *)(a1 + 152);
          v38 = 67109120;
          LODWORD(v39) = v37;
          v32 = "no task with pid %d in event time range, clearing target process";
          goto LABEL_30;
        }
      }
      else
      {
        -[SASampleStore lastTaskWithPid:]((_QWORD *)a1, *(unsigned int *)(a1 + 152));
        v27 = objc_claimAutoreleasedReturnValue();
        v28 = *(void **)(a1 + 160);
        *(_QWORD *)(a1 + 160) = v27;

        if (!*(_QWORD *)(a1 + 160))
        {
          v29 = *__error();
          _sa_logt();
          v30 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
LABEL_26:

            *__error() = v29;
            *(_DWORD *)(a1 + 152) = -1;
            goto LABEL_15;
          }
          v31 = *(_DWORD *)(a1 + 152);
          v38 = 67109120;
          LODWORD(v39) = v31;
          v32 = "no task with pid %d, clearing target process";
LABEL_30:
          _os_log_error_impl(&dword_1B9BE0000, v30, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&v38, 8u);
          goto LABEL_26;
        }
      }
    }
  }
LABEL_15:

}

- (NSString)kextStat
{
  return (NSString *)objc_getProperty(self, a2, 440, 1);
}

- (NSString)eventNote
{
  return (NSString *)objc_getProperty(self, a2, 728, 1);
}

- (void)postprocess
{
  int v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  int32_t v11;
  _BOOL4 v12;
  int v13;
  NSObject *v14;
  unint64_t dataGatheringOptions;
  void *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  _BOOL4 v24;
  id v25;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t j;
  void *v32;
  void *v33;
  void *v34;
  _BOOL4 v35;
  void *v36;
  void *v37;
  uint64_t SymbolOwnerForExclaveUUID;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  void *v43;
  id v44;
  CFDictionaryRef AdvisoryDetailed;
  CFDictionaryRef v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  uint32_t state;
  uint64_t v54;
  void *v55;
  void *v56;
  SEL v57;
  void *v58;
  void *v59;
  id v60;
  uint64_t f_bsize;
  uint64_t f_blocks;
  uint64_t f_bavail;
  void *v64;
  void *v65;
  void *v66;
  id v67;
  void *v68;
  NSDictionary *v69;
  NSDictionary *homeVolumeSpace;
  void *v71;
  void *v72;
  void *v73;
  BOOL v74;
  char v75;
  void *v76;
  double v77;
  double v78;
  void *v79;
  int v80;
  NSObject *v81;
  int *v82;
  id *v83;
  id v84;
  int v85;
  int v86;
  NSObject *v87;
  NSObject *v88;
  void *v89;
  id v90;
  void *v91;
  id v92;
  dispatch_semaphore_t v93;
  NSObject *v94;
  NSObject *v95;
  dispatch_time_t v96;
  int v97;
  NSObject *v98;
  unint64_t numMicrostackshotsSkippedDueToMissingLoadInfos;
  id v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t k;
  void *v104;
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  void *v109;
  int v110;
  NSObject *v111;
  int v112;
  NSObject *v113;
  const char *ClassName;
  NSArray *v115;
  NSArray *keyboardLanguages;
  int v117;
  NSObject *v118;
  void *v119;
  void *v120;
  int v121;
  NSObject *v122;
  NSArray *v123;
  NSArray *preferredLanguages;
  int v125;
  NSObject *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  int v132;
  NSObject *v133;
  int v134;
  NSObject *v135;
  statfs *p_hasHardwareKeyboardInfo;
  const __CFBoolean *v137;
  const __CFBoolean *v138;
  CFTypeID v139;
  int v140;
  NSObject *v141;
  NSObject *v142;
  int v143;
  NSObject *v144;
  NSDictionary *v145;
  NSDictionary *processNameForUnknownPids;
  id v147;
  id v148;
  dispatch_semaphore_t v149;
  NSObject *v150;
  NSObject *v151;
  dispatch_time_t v152;
  int v153;
  NSObject *v154;
  CFMutableDictionaryRef v155;
  const void *v156;
  const void *Subscription;
  const void *Samples;
  int v159;
  NSObject *v160;
  int v161;
  NSObject *v162;
  int *v163;
  NSObject *v164;
  void *v165;
  _BOOL4 v166;
  NSArray *v167;
  NSArray *models;
  void *v169;
  void *v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  dispatch_semaphore_t v175;
  NSObject *v176;
  id v177;
  void (*v178)(const __CFBoolean *, id, statfs *);
  dispatch_time_t v179;
  int v180;
  NSObject *v181;
  int v182;
  NSObject *v183;
  void *v184;
  void *v185;
  void *v186;
  double v187;
  double v188;
  double v189;
  double v190;
  double LastWake;
  SATimestamp *v192;
  int v193;
  NSObject *v194;
  int v195;
  NSString *v196;
  NSString *kernelVersion;
  const __CFDictionary *v198;
  const __CFDictionary *v199;
  NSString *v200;
  NSString *osProductName;
  NSString *v202;
  NSString *osProductVersion;
  NSString *v204;
  NSString *osProductVersionExtra;
  NSString *v206;
  NSString *osBuildVersion;
  int v208;
  int v209;
  int v210;
  NSObject *v211;
  int v212;
  NSObject *v213;
  int v214;
  NSObject *v215;
  const char *v216;
  int v217;
  NSObject *v218;
  uint64_t current;
  int v220;
  int v221;
  NSObject *v222;
  void *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t m;
  _BYTE *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  _BOOL4 v232;
  id v233;
  void *v234;
  void *v235;
  char v236;
  int32_t v237;
  int *v238;
  char *v239;
  int32_t v240;
  int *v241;
  char *v242;
  int32_t v243;
  int *v244;
  char *v245;
  unint64_t v246;
  unint64_t v247;
  const char *v248;
  int v249;
  void *v250;
  int v251;
  int v252;
  CFTypeID v253;
  __CFString *v254;
  char *v255;
  id v256;
  id v257;
  NSMutableArray *obj;
  uint64_t v259;
  id v260;
  id v261;
  void *i;
  id v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  _QWORD v280[4];
  NSMutableArray *v281;
  id v282;
  double v283;
  _QWORD v284[4];
  char v285;
  BOOL v286;
  _QWORD v287[8];
  uint64_t v288;
  uint64_t *v289;
  uint64_t v290;
  char v291;
  uint64_t v292;
  uint64_t *v293;
  uint64_t v294;
  char v295;
  uint64_t v296;
  uint64_t *v297;
  uint64_t v298;
  char v299;
  uint64_t v300;
  uint64_t *v301;
  uint64_t v302;
  char v303;
  _QWORD v304[5];
  id v305;
  uint64_t v306;
  CFTypeRef v307;
  CFTypeRef cf;
  size_t v309[3];
  char v310;
  _BYTE v311[128];
  _BYTE v312[128];
  _BYTE v313[128];
  _BYTE v314[128];
  statfs buf;
  int out_token[4];
  __int128 v317;
  __int128 v318;
  __int128 v319;
  uint8_t v320[8];
  uint8_t *v321;
  uint64_t v322;
  char v323;
  _BYTE v324[24];
  void *v325;
  uint64_t v326;

  v326 = *MEMORY[0x1E0C80C00];
  if (self->_numMicrostackshotsSkippedDueToMissingLoadInfos)
  {
    v3 = *__error();
    _sa_logt();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      numMicrostackshotsSkippedDueToMissingLoadInfos = self->_numMicrostackshotsSkippedDueToMissingLoadInfos;
      buf.f_bsize = 134217984;
      *(_QWORD *)&buf.f_iosize = numMicrostackshotsSkippedDueToMissingLoadInfos;
      _os_log_error_impl(&dword_1B9BE0000, v4, OS_LOG_TYPE_ERROR, "%llu microstackshots were skipped due to having no load infos", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v3;
  }
  if (self->_nextSampleIsFirstSamplingAllThreads)
  {
    v5 = *__error();
    _sa_logt();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1B9BE0000, v6, OS_LOG_TYPE_DEFAULT, "WARNING: No stackshot provided after sampleOnlyMainThreads set to NO", (uint8_t *)&buf, 2u);
    }

    *__error() = v5;
    *(_WORD *)&self->_sampleOnlyMainThreads = 1;
  }
  if (self->_nextSampleIsFirstSamplingAllProcesses)
  {
    v7 = *__error();
    _sa_logt();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1B9BE0000, v8, OS_LOG_TYPE_DEFAULT, "WARNING: No stackshot provided after stackshotsOnlyIncludeSpecificProcesses set to NO", (uint8_t *)&buf, 2u);
    }

    *__error() = v7;
    *(_WORD *)&self->_stackshotsOnlyIncludeSpecificProcesses = 1;
  }
  if (self->_mostRecentNativeSharedCache || (~LODWORD(self->_dataGatheringOptions) & 3) != 0)
  {
    v10 = 0;
    v9 = 0;
  }
  else
  {
    +[SASharedCache currentSharedCache](SASharedCache, "currentSharedCache");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (v9)
    {
      v10 = MEMORY[0x1BCCCB7F0]();
      -[SASampleStore addSharedCache:]((uint64_t)self, v9);
    }
    else
    {
      v10 = 0;
    }
  }
  if ((~LODWORD(self->_dataGatheringOptions) & 0x502) == 0)
    -[SASampleStore resampleTruncatedBacktraces]((uint64_t)self);
  v304[0] = MEMORY[0x1E0C809B0];
  v304[1] = 3221225472;
  v304[2] = __28__SASampleStore_postprocess__block_invoke;
  v304[3] = &unk_1E7146D30;
  v304[4] = self;
  v306 = v10;
  v257 = v9;
  v305 = v257;
  -[SASampleStore enumerateTasksWithLiveness:]((uint64_t)self, v304);
  v300 = 0;
  v301 = &v300;
  v302 = 0x2020000000;
  v303 = 0;
  v296 = 0;
  v297 = &v296;
  v298 = 0x2020000000;
  v299 = 0;
  v292 = 0;
  v293 = &v292;
  v294 = 0x2020000000;
  v295 = 0;
  v288 = 0;
  v289 = &v288;
  v290 = 0x2020000000;
  v291 = 0;
  v287[0] = MEMORY[0x1E0C809B0];
  v287[1] = 3221225472;
  v287[2] = __28__SASampleStore_postprocess__block_invoke_2;
  v287[3] = &unk_1E7146D80;
  v287[4] = &v292;
  v287[5] = &v300;
  v287[6] = &v288;
  v287[7] = &v296;
  -[SASampleStore enumerateTasks:](self, "enumerateTasks:", v287);
  if (*((_BYTE *)v293 + 24))
    v11 = *((_BYTE *)v301 + 24) == 0;
  else
    v11 = 0;
  if (*((_BYTE *)v289 + 24))
  {
    v12 = *((_BYTE *)v297 + 24) == 0;
    if ((v11 & 1) != 0)
      goto LABEL_28;
LABEL_27:
    if (!v12)
      goto LABEL_31;
    goto LABEL_28;
  }
  v12 = 0;
  if ((v11 & 1) == 0)
    goto LABEL_27;
LABEL_28:
  v13 = *__error();
  _sa_logt();
  v14 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    buf.f_bsize = 67109376;
    buf.f_iosize = v11;
    LOWORD(buf.f_blocks) = 1024;
    *(_DWORD *)((char *)&buf.f_blocks + 2) = v12;
    _os_log_debug_impl(&dword_1B9BE0000, v14, OS_LOG_TYPE_DEBUG, "No valid originPid:%d or proximatePid:%d, clearing it all out", (uint8_t *)&buf, 0xEu);
  }

  *__error() = v13;
  v284[0] = MEMORY[0x1E0C809B0];
  v284[1] = 3221225472;
  v284[2] = __28__SASampleStore_postprocess__block_invoke_154;
  v284[3] = &__block_descriptor_34_e20_v24__0__SATask_8_B16l;
  v285 = v11;
  v286 = v12;
  -[SASampleStore enumerateTasks:](self, "enumerateTasks:", v284);
LABEL_31:
  dataGatheringOptions = self->_dataGatheringOptions;
  if ((dataGatheringOptions & 1) == 0)
    goto LABEL_328;
  if ((dataGatheringOptions & 2) == 0)
  {
    -[SASampleStore lastTaskWithPid:](self, 0);
    v278 = 0u;
    v279 = 0u;
    v276 = 0u;
    v277 = 0u;
    v256 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v256, "binaryLoadInfos");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v276, v314, 16);
    if (!v17)
    {
LABEL_45:

      v274 = 0u;
      v275 = 0u;
      v272 = 0u;
      v273 = 0u;
      obj = self->_exclaves;
      v260 = (id)-[NSMutableArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v272, v313, 16);
      if (v260)
      {
        v259 = *(_QWORD *)v273;
        do
        {
          for (i = 0; i != v260; i = (char *)i + 1)
          {
            if (*(_QWORD *)v273 != v259)
              objc_enumerationMutation(obj);
            v27 = *(void **)(*((_QWORD *)&v272 + 1) + 8 * (_QWORD)i);
            v268 = 0u;
            v269 = 0u;
            v270 = 0u;
            v271 = 0u;
            objc_msgSend(v27, "loadInfos");
            v28 = (void *)objc_claimAutoreleasedReturnValue();
            v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v268, v312, 16);
            if (v29)
            {
              v30 = *(_QWORD *)v269;
              do
              {
                for (j = 0; j != v29; ++j)
                {
                  if (*(_QWORD *)v269 != v30)
                    objc_enumerationMutation(v28);
                  v32 = *(void **)(*((_QWORD *)&v268 + 1) + 8 * j);
                  objc_msgSend(v32, "binary");
                  v33 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v33, "path");
                  v34 = (void *)objc_claimAutoreleasedReturnValue();
                  v35 = v34 == 0;

                  if (v35)
                  {
                    objc_msgSend(v32, "binary");
                    v36 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v36, "uuid");
                    v37 = (void *)objc_claimAutoreleasedReturnValue();
                    SymbolOwnerForExclaveUUID = CreateSymbolOwnerForExclaveUUID(v37);
                    v40 = v39;

                    if ((CSIsNull() & 1) == 0)
                    {
                      objc_msgSend(v32, "binary");
                      v41 = objc_claimAutoreleasedReturnValue();
                      v42 = (void *)v41;
                      if (v41)
                        -[SABinary addInfoFromSymbolOwner:fromDisk:includeExpensiveInfo:](v41, SymbolOwnerForExclaveUUID, v40, 0, 0);

                      CSRelease();
                      objc_msgSend(v32, "binary");
                      v43 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v43, "gatherInfoWithDataGatheringOptions:pid:", self->_dataGatheringOptions, 0xFFFFFFFFLL);

                    }
                  }
                }
                v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v268, v312, 16);
              }
              while (v29);
            }

          }
          v260 = (id)-[NSMutableArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v272, v313, 16);
        }
        while (v260);
      }
LABEL_280:

      goto LABEL_281;
    }
    v18 = 0;
    v19 = *(_QWORD *)v277;
LABEL_35:
    v20 = 0;
    while (1)
    {
      if (*(_QWORD *)v277 != v19)
        objc_enumerationMutation(v16);
      v21 = *(void **)(*((_QWORD *)&v276 + 1) + 8 * v20);
      if ((v18 & 1) != 0)
        goto LABEL_42;
      objc_msgSend(*(id *)(*((_QWORD *)&v276 + 1) + 8 * v20), "binary");
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v22, "path");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      v24 = v23 == 0;

      if (v24)
        break;
      v18 = 0;
LABEL_43:
      objc_msgSend(v21, "binary");
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v26, "gatherInfoWithDataGatheringOptions:pid:", self->_dataGatheringOptions | 2, 0);

      if (v17 == ++v20)
      {
        v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v276, v314, 16);
        if (!v17)
          goto LABEL_45;
        goto LABEL_35;
      }
    }
    v25 = +[SABinaryLoadInfo binaryLoadInfoForLiveProcessWithPid:dataGatheringOptions:additionalCSSymbolicatorFlags:](SABinaryLoadInfo, "binaryLoadInfoForLiveProcessWithPid:dataGatheringOptions:additionalCSSymbolicatorFlags:", 0, self->_dataGatheringOptions | 2, self->_additionalCSSymbolicatorFlags);
LABEL_42:
    v18 = 1;
    goto LABEL_43;
  }
  if (self->_lastWakeTime == 0.0)
    self->_lastWakeTime = -[SASampleStore _getLastWakeTime]((uint64_t)self);
  if (self->_shouldGatherKextStat && !self->_kextStat)
  {
    if (qword_1ED1DD570 != -1)
      dispatch_once(&qword_1ED1DD570, &__block_literal_global_346);
    objc_storeStrong((id *)&self->_kextStat, (id)qword_1ED1DD568);
  }
  -[SASampleStore gatherBootArgs]((uint64_t)self);
  if (!self->_systemAdvisoryLevels)
  {
    v44 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    AdvisoryDetailed = IOCopySystemLoadAdvisoryDetailed();
    v46 = AdvisoryDetailed;
    if (AdvisoryDetailed)
    {
      -[__CFDictionary objectForKeyedSubscript:](AdvisoryDetailed, "objectForKeyedSubscript:", CFSTR("UserLevel"));
      v47 = (void *)objc_claimAutoreleasedReturnValue();
      -[__CFDictionary objectForKeyedSubscript:](v46, "objectForKeyedSubscript:", CFSTR("BatteryLevel"));
      v48 = (void *)objc_claimAutoreleasedReturnValue();
      -[__CFDictionary objectForKeyedSubscript:](v46, "objectForKeyedSubscript:", CFSTR("CombinedLevel"));
      v49 = (void *)objc_claimAutoreleasedReturnValue();
      if (v47)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v50 = (void *)objc_msgSend(v47, "copy");
          objc_msgSend(v44, "setObject:forKeyedSubscript:", v50, 0x1E714A610);

        }
      }
      if (v48)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v51 = (void *)objc_msgSend(v48, "copy");
          objc_msgSend(v44, "setObject:forKeyedSubscript:", v51, 0x1E714A630);

        }
      }
      if (v49)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v52 = (void *)objc_msgSend(v49, "copy");
          objc_msgSend(v44, "setObject:forKeyedSubscript:", v52, 0x1E714A650);

        }
      }

    }
    out_token[0] = 0;
    if (!notify_register_check((const char *)*MEMORY[0x1E0C83A00], out_token))
    {
      *(_QWORD *)&buf.f_bsize = 0;
      state = notify_get_state(out_token[0], (uint64_t *)&buf.f_bsize);
      v54 = *(_QWORD *)&buf.f_bsize;
      notify_cancel(out_token[0]);
      if (!state)
      {
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v54);
        v55 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v44, "setObject:forKeyedSubscript:", v55, 0x1E714A670);

      }
    }
    if (objc_msgSend(v44, "count"))
    {
      v56 = (void *)objc_msgSend(v44, "copy");
      objc_setProperty_atomic(self, v57, v56, 504);

    }
  }
  if (!self->_homeVolumeSpace)
  {
    SAGetHomeDirectoryURL();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    v59 = v58;
    if (v58)
    {
      memset(&buf, 0, 512);
      v60 = objc_retainAutorelease(v58);
      if (!statfs((const char *)objc_msgSend(v60, "fileSystemRepresentation"), &buf))
      {
        f_bsize = buf.f_bsize;
        f_blocks = buf.f_blocks;
        f_bavail = buf.f_bavail;
        v64 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 3);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", f_blocks * f_bsize);
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v64, "setObject:forKeyedSubscript:", v65, 0x1E714A6B0);

        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", f_bavail * f_bsize);
        v66 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v64, "setObject:forKeyedSubscript:", v66, 0x1E714A6D0);

        *(_DWORD *)&v324[8] = 0;
        *(_QWORD *)v324 = 0;
        out_token[3] = 0;
        *(_QWORD *)&v317 = 0;
        *(_QWORD *)out_token = 5;
        out_token[2] = 32;
        v67 = objc_retainAutorelease(v60);
        if (!getattrlist((const char *)objc_msgSend(v67, "fileSystemRepresentation"), out_token, v324, 0xCuLL, 1u)
          && *(uint64_t *)&v324[4] >= 1)
        {
          v309[0] = 0;
          if (!fsctl((const char *)objc_msgSend(objc_retainAutorelease(v67), "fileSystemRepresentation"), 0x4004681BuLL, v309, 0))
          {
            if (v309[0])
            {
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)&v324[4] * v309[0]);
              v68 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v64, "setObject:forKeyedSubscript:", v68, 0x1E714A6F0);

            }
          }
        }
        v69 = (NSDictionary *)objc_msgSend(v64, "copy");
        homeVolumeSpace = self->_homeVolumeSpace;
        self->_homeVolumeSpace = v69;

      }
    }

  }
  if (!self->_nonDefaultFeatureFlags)
  {
    if (qword_1ED1DD590 != -1)
      dispatch_once(&qword_1ED1DD590, &__block_literal_global_367);
    objc_storeStrong((id *)&self->_nonDefaultFeatureFlags, (id)qword_1ED1DD598);
  }
  if (-[NSMutableArray count](self->_powerModeTransitions, "count"))
    goto LABEL_117;
  v71 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.powerd.lowpowermode.state"));
  v72 = v71;
  if (!v71
    || (objc_msgSend(v71, "objectForKey:", CFSTR("state")),
        v73 = (void *)objc_claimAutoreleasedReturnValue(),
        v74 = v73 == 0,
        v73,
        v74))
  {
    v80 = *__error();
    _sa_logt();
    v81 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_debug_impl(&dword_1B9BE0000, v81, OS_LOG_TYPE_DEBUG, "Unable to get low power mode defaults", (uint8_t *)&buf, 2u);
    }

    v82 = __error();
    v75 = 0;
    goto LABEL_115;
  }
  v75 = objc_msgSend(v72, "BOOLForKey:", CFSTR("state"));
  objc_msgSend(v72, "objectForKey:", CFSTR("stateChangeDate"));
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v76)
  {
    v80 = *__error();
    _sa_logt();
    v142 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v142, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_fault_impl(&dword_1B9BE0000, v142, OS_LOG_TYPE_FAULT, "No stateChangeDate for low power mode", (uint8_t *)&buf, 2u);
    }

    v82 = __error();
LABEL_115:
    v76 = 0;
    v79 = 0;
    *v82 = v80;
    goto LABEL_116;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    v143 = *__error();
    _sa_logt();
    v144 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v144, OS_LOG_TYPE_FAULT))
    {
      objc_msgSend((id)objc_opt_class(), "debugDescription");
      v250 = (void *)objc_claimAutoreleasedReturnValue();
      buf.f_bsize = 138412290;
      *(_QWORD *)&buf.f_iosize = v250;
      _os_log_fault_impl(&dword_1B9BE0000, v144, OS_LOG_TYPE_FAULT, "low power mode stateChangeDate is not an NSDate: %@", (uint8_t *)&buf, 0xCu);

    }
    *__error() = v143;

    v76 = 0;
    goto LABEL_214;
  }
  objc_msgSend(v76, "timeIntervalSinceReferenceDate");
  if (v77 == 0.0)
  {
LABEL_214:
    v79 = 0;
    goto LABEL_116;
  }
  objc_msgSend(v76, "timeIntervalSinceReferenceDate");
  +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, v78);
  v79 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_116:
  v83 = -[SAPowerModeTransition initWithLowPowerMode:timestamp:]((id *)[SAPowerModeTransition alloc], v75, v79);
  v84 = -[SASampleStore addPowerModeTransition:]((id *)&self->super.isa, v83);

LABEL_117:
  if (!self->_installedRootNames)
  {
    if (!qword_1ED1DD5D8)
    {
      *(_OWORD *)&buf.f_bsize = xmmword_1E71477C0;
      buf.f_bfree = 0;
      qword_1ED1DD5D8 = _sl_dlopen();
    }
    if (qword_1ED1DD5D8)
    {
      *(_QWORD *)out_token = 0;
      *(_QWORD *)&out_token[2] = out_token;
      *(_QWORD *)&v317 = 0x2050000000;
      v89 = (void *)qword_1ED1DD5E0;
      *((_QWORD *)&v317 + 1) = qword_1ED1DD5E0;
      if (!qword_1ED1DD5E0)
      {
        *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
        buf.f_blocks = 3221225472;
        buf.f_bfree = (uint64_t)__getDUSessionClass_block_invoke;
        buf.f_bavail = (uint64_t)&unk_1E71477A0;
        buf.f_files = (uint64_t)out_token;
        __getDUSessionClass_block_invoke((uint64_t)&buf);
        v89 = *(void **)(*(_QWORD *)&out_token[2] + 24);
      }
      v90 = objc_retainAutorelease(v89);
      _Block_object_dispose(out_token, 8);
      *(_QWORD *)out_token = 0;
      *(_QWORD *)&out_token[2] = out_token;
      *(_QWORD *)&v317 = 0x2050000000;
      v91 = (void *)qword_1ED1DD5E8;
      *((_QWORD *)&v317 + 1) = qword_1ED1DD5E8;
      if (!qword_1ED1DD5E8)
      {
        *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
        buf.f_blocks = 3221225472;
        buf.f_bfree = (uint64_t)__getDURootClass_block_invoke;
        buf.f_bavail = (uint64_t)&unk_1E71477A0;
        buf.f_files = (uint64_t)out_token;
        __getDURootClass_block_invoke((uint64_t)&buf);
        v91 = *(void **)(*(_QWORD *)&out_token[2] + 24);
      }
      v92 = objc_retainAutorelease(v91);
      _Block_object_dispose(out_token, 8);
      if (objc_opt_class() && objc_opt_class())
      {
        v93 = dispatch_semaphore_create(0);
        dispatch_get_global_queue(0, 0);
        v94 = objc_claimAutoreleasedReturnValue();
        *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
        buf.f_blocks = 3221225472;
        buf.f_bfree = (uint64_t)__40__SASampleStore_gatherRootInstalledInfo__block_invoke;
        buf.f_bavail = (uint64_t)&unk_1E7147548;
        buf.f_fsid = (fsid_t)v90;
        buf.f_files = (uint64_t)self;
        v95 = v93;
        buf.f_ffree = (uint64_t)v95;
        dispatch_async(v94, &buf);

        v96 = dispatch_time(0, 1000000000);
        if (dispatch_semaphore_wait(v95, v96))
        {
          v97 = *__error();
          _sa_logt();
          v98 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
          {
            LOWORD(out_token[0]) = 0;
            _os_log_error_impl(&dword_1B9BE0000, v98, OS_LOG_TYPE_ERROR, "Timed out waiting for darwinup", (uint8_t *)out_token, 2u);
          }

          *__error() = v97;
        }

      }
    }
  }
  if (!self->_isRootInstalled)
  {
    *(_QWORD *)v324 = 0;
    v309[0] = 8;
    v85 = sysctlbyname("kern.roots_installed", v324, v309, 0, 0);
    v86 = *__error();
    _sa_logt();
    v87 = objc_claimAutoreleasedReturnValue();
    v88 = v87;
    if (v85)
    {
      if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
      {
        v208 = *__error();
        out_token[0] = 67109120;
        out_token[1] = v208;
        _os_log_error_impl(&dword_1B9BE0000, v88, OS_LOG_TYPE_ERROR, "Unable to get installed root info kern.roots_installed: %{errno}d", (uint8_t *)out_token, 8u);
      }

      *__error() = v86;
    }
    else
    {
      if (os_log_type_enabled(v87, OS_LOG_TYPE_INFO))
      {
        out_token[0] = 134217984;
        *(_QWORD *)&out_token[1] = *(_QWORD *)v324;
        _os_log_impl(&dword_1B9BE0000, v88, OS_LOG_TYPE_INFO, "Installed root info kern.roots_installed: %llu", (uint8_t *)out_token, 0xCu);
      }

      *__error() = v86;
      if (*(_QWORD *)v324)
        self->_isRootInstalled = 1;
    }
  }
  if (!self->_keyboardLanguages)
  {
    v263 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v261 = (id)CFPreferencesCopyValue(CFSTR("KeyboardsCurrentAndNext"), CFSTR("com.apple.keyboard.preferences"), CFSTR("mobile"), (CFStringRef)*MEMORY[0x1E0C9B230]);
    if (v261)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v319 = 0u;
        v318 = 0u;
        v317 = 0u;
        *(_OWORD *)out_token = 0u;
        v100 = v261;
        v101 = objc_msgSend(v100, "countByEnumeratingWithState:objects:count:", out_token, &buf, 16);
        if (v101)
        {
          v102 = *(_QWORD *)v317;
          do
          {
            for (k = 0; k != v101; ++k)
            {
              if (*(_QWORD *)v317 != v102)
                objc_enumerationMutation(v100);
              v104 = *(void **)(*(_QWORD *)&out_token[2] + 8 * k);
              if (v104)
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  objc_msgSend(v104, "stringByReplacingOccurrencesOfString:withString:", CFSTR("@sw="), CFSTR(" "));
                  v105 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v105, "stringByReplacingOccurrencesOfString:withString:", CFSTR("@hw="), CFSTR(" "));
                  v106 = (void *)objc_claimAutoreleasedReturnValue();

                  objc_msgSend(v106, "stringByReplacingOccurrencesOfString:withString:", CFSTR(";hw="), &stru_1E714A250);
                  v107 = (void *)objc_claimAutoreleasedReturnValue();

                  objc_msgSend(v107, "stringByReplacingOccurrencesOfString:withString:", CFSTR(";sw="), &stru_1E714A250);
                  v108 = (void *)objc_claimAutoreleasedReturnValue();

                  objc_msgSend(v108, "stringByReplacingOccurrencesOfString:withString:", CFSTR("Automatic"), &stru_1E714A250);
                  v109 = (void *)objc_claimAutoreleasedReturnValue();

                  v110 = *__error();
                  _sa_logt();
                  v111 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)v324 = 138412546;
                    *(_QWORD *)&v324[4] = v104;
                    *(_WORD *)&v324[12] = 2112;
                    *(_QWORD *)&v324[14] = v109;
                    _os_log_debug_impl(&dword_1B9BE0000, v111, OS_LOG_TYPE_DEBUG, "keyboard %@ -> %@", v324, 0x16u);
                  }

                  *__error() = v110;
                  if ((objc_msgSend(v263, "containsObject:", v109) & 1) == 0)
                    objc_msgSend(v263, "addObject:", v109);

                }
                else
                {
                  v112 = *__error();
                  _sa_logt();
                  v113 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT))
                  {
                    ClassName = object_getClassName(v104);
                    *(_DWORD *)v324 = 136315138;
                    *(_QWORD *)&v324[4] = ClassName;
                    _os_log_fault_impl(&dword_1B9BE0000, v113, OS_LOG_TYPE_FAULT, "keyboard not a string! %s", v324, 0xCu);
                  }

                  *__error() = v112;
                }
              }
            }
            v101 = objc_msgSend(v100, "countByEnumeratingWithState:objects:count:", out_token, &buf, 16);
          }
          while (v101);
        }

        v115 = (NSArray *)objc_msgSend(v263, "copy");
        keyboardLanguages = self->_keyboardLanguages;
        self->_keyboardLanguages = v115;

      }
      else
      {
        v117 = *__error();
        _sa_logt();
        v118 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT))
        {
          v248 = object_getClassName(v261);
          buf.f_bsize = 136315138;
          *(_QWORD *)&buf.f_iosize = v248;
          _os_log_fault_impl(&dword_1B9BE0000, v118, OS_LOG_TYPE_FAULT, "keyboards not an array! %s", (uint8_t *)&buf, 0xCu);
        }

        *__error() = v117;
      }
    }

  }
  if (!self->_preferredLanguages)
  {
    getPreferredLanguages();
    v119 = (void *)objc_claimAutoreleasedReturnValue();
    v120 = v119;
    if (v119 && objc_msgSend(v119, "count"))
    {
      v121 = *__error();
      _sa_logt();
      v122 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
      {
        buf.f_bsize = 138412290;
        *(_QWORD *)&buf.f_iosize = v120;
        _os_log_debug_impl(&dword_1B9BE0000, v122, OS_LOG_TYPE_DEBUG, "Preferred languages found: %@", (uint8_t *)&buf, 0xCu);
      }

      *__error() = v121;
      if ((unint64_t)objc_msgSend(v120, "count") < 2)
      {
        v123 = (NSArray *)objc_msgSend(v120, "copy");
      }
      else
      {
        objc_msgSend(v120, "subarrayWithRange:", 0, 2);
        v123 = (NSArray *)objc_claimAutoreleasedReturnValue();
      }
      preferredLanguages = self->_preferredLanguages;
      self->_preferredLanguages = v123;

    }
    else
    {
      v125 = *__error();
      _sa_logt();
      v126 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_fault_impl(&dword_1B9BE0000, v126, OS_LOG_TYPE_FAULT, "Preferred languages are not found!", (uint8_t *)&buf, 2u);
      }

      *__error() = v125;
    }

  }
  if (!self->_countryCode)
  {
    getPreferredLanguages();
    v127 = (void *)objc_claimAutoreleasedReturnValue();
    v128 = (void *)MEMORY[0x1E0C99DC8];
    objc_msgSend(v127, "firstObject");
    v129 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v128, "localeWithLocaleIdentifier:", v129);
    v130 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v130, "objectForKey:", *MEMORY[0x1E0C997B0]);
    v131 = (void *)objc_claimAutoreleasedReturnValue();

    if (v131 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      v132 = *__error();
      _sa_logt();
      v133 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
      {
        buf.f_bsize = 138412290;
        *(_QWORD *)&buf.f_iosize = v131;
        _os_log_debug_impl(&dword_1B9BE0000, v133, OS_LOG_TYPE_DEBUG, "Country code found: %@", (uint8_t *)&buf, 0xCu);
      }

      *__error() = v132;
      objc_storeStrong((id *)&self->_countryCode, v131);
    }
    else
    {
      v134 = *__error();
      _sa_logt();
      v135 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_debug_impl(&dword_1B9BE0000, v135, OS_LOG_TYPE_DEBUG, "Country code not found!", (uint8_t *)&buf, 2u);
      }

      *__error() = v134;
    }

  }
  if (!self->_hasHardwareKeyboardInfo)
  {
    p_hasHardwareKeyboardInfo = (statfs *)&self->_hasHardwareKeyboardInfo;
    self->_hasHardwareKeyboardInfo = 1;
    v137 = (const __CFBoolean *)CFPreferencesCopyValue(CFSTR("HardwareKeyboardLastSeen"), CFSTR("com.apple.keyboard.preferences"), CFSTR("mobile"), (CFStringRef)*MEMORY[0x1E0C9B230]);
    v138 = v137;
    if (!v137)
    {
      p_hasHardwareKeyboardInfo = (statfs *)&self->_hardwareKeyboard;
      goto LABEL_194;
    }
    v139 = CFGetTypeID(v137);
    if (v139 != CFBooleanGetTypeID())
    {
      LODWORD(v178) = *__error();
      _sa_logt();
      v176 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v176, OS_LOG_TYPE_FAULT))
        goto LABEL_355;
      goto LABEL_353;
    }
    self->_hardwareKeyboard = CFBooleanGetValue(v138) != 0;
    CFRelease(v138);
  }
  while (1)
  {
    if (self->_numVnodesHardLimit)
      goto LABEL_219;
    *(_QWORD *)out_token = 0;
    *(_QWORD *)v324 = 0;
    v309[0] = 0;
    *(_QWORD *)&buf.f_bsize = 8;
    if (sysctlbyname("kern.num_vnodes", out_token, (size_t *)&buf.f_bsize, 0, 0))
    {
      v140 = *__error();
      _sa_logt();
      v141 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        v209 = *__error();
        *(_DWORD *)v320 = 67109120;
        *(_DWORD *)&v320[4] = v209;
        _os_log_error_impl(&dword_1B9BE0000, v141, OS_LOG_TYPE_ERROR, "Unable to get kern.num_vnodes: %{errno}d", v320, 8u);
      }
LABEL_218:

      *__error() = v140;
      goto LABEL_219;
    }
    *(_QWORD *)&buf.f_bsize = 8;
    if (sysctlbyname("kern.free_vnodes", v324, (size_t *)&buf.f_bsize, 0, 0))
    {
      v140 = *__error();
      _sa_logt();
      v141 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        v249 = *__error();
        *(_DWORD *)v320 = 67109120;
        *(_DWORD *)&v320[4] = v249;
        _os_log_error_impl(&dword_1B9BE0000, v141, OS_LOG_TYPE_ERROR, "Unable to get kern.free_vnodes: %{errno}d", v320, 8u);
      }
      goto LABEL_218;
    }
    *(_QWORD *)&buf.f_bsize = 8;
    if (sysctlbyname("kern.maxvnodes", v309, (size_t *)&buf.f_bsize, 0, 0))
    {
      v140 = *__error();
      _sa_logt();
      v141 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        v251 = *__error();
        *(_DWORD *)v320 = 67109120;
        *(_DWORD *)&v320[4] = v251;
        _os_log_error_impl(&dword_1B9BE0000, v141, OS_LOG_TYPE_ERROR, "Unable to get kern.maxvnodes: %{errno}d", v320, 8u);
      }
      goto LABEL_218;
    }
    LODWORD(cf) = 0;
    *(_QWORD *)&buf.f_bsize = 4;
    if (sysctlbyname("vfs.vnstats.vn_dealloc_level", &cf, (size_t *)&buf.f_bsize, 0, 0))
    {
      v140 = *__error();
      _sa_logt();
      v141 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        v252 = *__error();
        *(_DWORD *)v320 = 67109120;
        *(_DWORD *)&v320[4] = v252;
        _os_log_error_impl(&dword_1B9BE0000, v141, OS_LOG_TYPE_ERROR, "Unable to get vfs.vnstats.vn_dealloc_level: %{errno}d", v320, 8u);
      }
      goto LABEL_218;
    }
    v246 = v309[0];
    v247 = v309[0] << ((_DWORD)cf != 0);
    self->_numVnodesAllocated = *(_QWORD *)out_token;
    self->_numVnodesFree = *(_QWORD *)v324;
    self->_numVnodesSoftLimit = v246;
    self->_numVnodesHardLimit = v247;
LABEL_219:
    if (!self->_processNameForUnknownPids)
    {
      *(_QWORD *)&buf.f_bsize = 0;
      buf.f_blocks = (uint64_t)&buf;
      buf.f_bfree = 0x3032000000;
      buf.f_bavail = (uint64_t)__Block_byref_object_copy__0;
      buf.f_files = (uint64_t)__Block_byref_object_dispose__0;
      buf.f_ffree = (uint64_t)objc_alloc_init(MEMORY[0x1E0C99E08]);
      *(_QWORD *)out_token = MEMORY[0x1E0C809B0];
      *(_QWORD *)&out_token[2] = 3221225472;
      *(_QWORD *)&v317 = __42__SASampleStore_gatherUnknownProcessNames__block_invoke;
      *((_QWORD *)&v317 + 1) = &unk_1E71474F8;
      *(_QWORD *)&v318 = self;
      *((_QWORD *)&v318 + 1) = &buf;
      -[SASampleStore enumerateTasks:](self, "enumerateTasks:", out_token);
      v145 = (NSDictionary *)-[NSDictionary copy](self->_processNameForUnknownPids, "copy");
      processNameForUnknownPids = self->_processNameForUnknownPids;
      self->_processNameForUnknownPids = v145;

      _Block_object_dispose(&buf, 8);
    }
    v147 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
    buf.f_blocks = 3221225472;
    buf.f_bfree = (uint64_t)__52__SASampleStore_gatherUnknownResourceCoalitionNames__block_invoke;
    buf.f_bavail = (uint64_t)&unk_1E7147520;
    buf.f_files = (uint64_t)v147;
    v148 = v147;
    -[SASampleStore enumerateTasks:](self, "enumerateTasks:", &buf);

    if (!self->_activeTrials)
    {
      if (!qword_1ED1DD5C8)
      {
        *(_OWORD *)&buf.f_bsize = xmmword_1E7147780;
        buf.f_bfree = 0;
        qword_1ED1DD5C8 = _sl_dlopen();
      }
      if (qword_1ED1DD5C8)
      {
        v149 = dispatch_semaphore_create(0);
        dispatch_get_global_queue(0, 0);
        v150 = objc_claimAutoreleasedReturnValue();
        *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
        buf.f_blocks = 3221225472;
        buf.f_bfree = (uint64_t)__29__SASampleStore_gatherTrials__block_invoke;
        buf.f_bavail = (uint64_t)&unk_1E7147438;
        buf.f_files = (uint64_t)self;
        v151 = v149;
        buf.f_ffree = (uint64_t)v151;
        dispatch_async(v150, &buf);

        v152 = dispatch_time(0, 5000000000);
        if (dispatch_semaphore_wait(v151, v152))
        {
          v153 = *__error();
          _sa_logt();
          v154 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
          {
            LOWORD(out_token[0]) = 0;
            _os_log_error_impl(&dword_1B9BE0000, v154, OS_LOG_TYPE_ERROR, "Timed out waiting for trial info", (uint8_t *)out_token, 2u);
          }

          *__error() = v153;
        }

      }
    }
    if (!self->_gpuRestartCount)
    {
      *(_QWORD *)out_token = 0;
      *(_QWORD *)&out_token[2] = out_token;
      v317 = 0x2020000000uLL;
      *(_QWORD *)v324 = 0;
      *(_QWORD *)&v324[8] = v324;
      *(_QWORD *)&v324[16] = 0x2020000000;
      v325 = 0;
      v309[0] = 0;
      v309[1] = (size_t)v309;
      v309[2] = 0x2020000000;
      v310 = 0;
      *(_QWORD *)v320 = 0;
      v321 = v320;
      v322 = 0x2020000000;
      v323 = 0;
      self->_gpuRestartCount = 0;
      self->_gpuRestartLastMachAbs = 0;
      cf = 0;
      v307 = 0;
      v155 = IOServiceMatching("AGXAccelerator");
      v156 = (const void *)IOReportCopyChannelsForDrivers();
      CFRelease(v155);
      if (!v156)
      {
        v159 = *__error();
        _sa_logt();
        v160 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
        {
          buf.f_bsize = 138412290;
          *(_QWORD *)&buf.f_iosize = cf;
          _os_log_error_impl(&dword_1B9BE0000, v160, OS_LOG_TYPE_ERROR, "Failed to get IOReport channels: %@", (uint8_t *)&buf, 0xCu);
        }

        *__error() = v159;
        goto LABEL_259;
      }
      if (IOReportGetChannelCount())
      {
        Subscription = (const void *)IOReportCreateSubscription();
        if (Subscription && v307)
        {
          Samples = (const void *)IOReportCreateSamples();
          if (Samples)
          {
            *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
            buf.f_blocks = 3221225472;
            buf.f_bfree = (uint64_t)__30__SASampleStore_gatherGPUInfo__block_invoke;
            buf.f_bavail = (uint64_t)&unk_1E7147480;
            buf.f_files = (uint64_t)out_token;
            buf.f_ffree = (uint64_t)v309;
            buf.f_fsid = (fsid_t)v324;
            *(_QWORD *)&buf.f_owner = v320;
            IOReportIterate();
            self->_gpuRestartCount = *(_QWORD *)(*(_QWORD *)&out_token[2] + 24);
            self->_gpuRestartLastMachAbs = *(_QWORD *)(*(_QWORD *)&v324[8] + 24);
LABEL_250:
            if (cf)
              CFRelease(cf);
            if (Samples)
              CFRelease(Samples);
            if (v307)
              CFRelease(v307);
            if (Subscription)
              CFRelease(Subscription);
            CFRelease(v156);
LABEL_259:
            _Block_object_dispose(v320, 8);
            _Block_object_dispose(v309, 8);
            _Block_object_dispose(v324, 8);
            _Block_object_dispose(out_token, 8);
            goto LABEL_260;
          }
          v161 = *__error();
          _sa_logt();
          v164 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
          {
            buf.f_bsize = 138412290;
            *(_QWORD *)&buf.f_iosize = cf;
            _os_log_error_impl(&dword_1B9BE0000, v164, OS_LOG_TYPE_ERROR, "Failed to create IOReport samples: %@", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          v161 = *__error();
          _sa_logt();
          v164 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
          {
            buf.f_bsize = 138412290;
            *(_QWORD *)&buf.f_iosize = cf;
            _os_log_error_impl(&dword_1B9BE0000, v164, OS_LOG_TYPE_ERROR, "Failed to subscribe to IOReport channels: %@", (uint8_t *)&buf, 0xCu);
          }
        }

        v163 = __error();
        Samples = 0;
      }
      else
      {
        v161 = *__error();
        _sa_logt();
        v162 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf.f_bsize) = 0;
          _os_log_debug_impl(&dword_1B9BE0000, v162, OS_LOG_TYPE_DEBUG, "No IOReport channels found", (uint8_t *)&buf, 2u);
        }

        v163 = __error();
        Samples = 0;
        Subscription = 0;
      }
      *v163 = v161;
      goto LABEL_250;
    }
LABEL_260:
    -[SASampleStore models](self, "models", v255);
    v165 = (void *)objc_claimAutoreleasedReturnValue();
    v166 = v165 == 0;

    if (!v166)
      goto LABEL_275;
    v167 = (NSArray *)objc_alloc_init(MEMORY[0x1E0C99D20]);
    models = self->_models;
    self->_models = v167;

    if (!qword_1ED1DD600)
    {
      *(_OWORD *)&buf.f_bsize = xmmword_1E7147818;
      buf.f_bfree = 0;
      qword_1ED1DD600 = _sl_dlopen();
    }
    if (!qword_1ED1DD600)
      break;
    -[SASampleStore startTime](self, "startTime");
    v169 = (void *)objc_claimAutoreleasedReturnValue();
    v170 = (void *)objc_msgSend(v169, "copyDate");
    objc_msgSend(v170, "dateByAddingTimeInterval:", -60.0);
    v171 = (void *)objc_claimAutoreleasedReturnValue();

    -[SASampleStore endTime](self, "endTime");
    v172 = (void *)objc_claimAutoreleasedReturnValue();
    v173 = (void *)objc_msgSend(v172, "copyDate");
    objc_msgSend(v173, "dateByAddingTimeInterval:", 60.0);
    v174 = (void *)objc_claimAutoreleasedReturnValue();

    v175 = dispatch_semaphore_create(0);
    *(_QWORD *)&buf.f_bsize = MEMORY[0x1E0C809B0];
    buf.f_blocks = 3221225472;
    buf.f_bfree = (uint64_t)__32__SASampleStore_gatherModelInfo__block_invoke;
    buf.f_bavail = (uint64_t)&unk_1E7147570;
    buf.f_files = (uint64_t)self;
    v176 = v175;
    buf.f_ffree = (uint64_t)v176;
    v138 = v171;
    v177 = v174;
    p_hasHardwareKeyboardInfo = &buf;
    *(_QWORD *)v324 = 0;
    *(_QWORD *)&v324[8] = v324;
    *(_QWORD *)&v324[16] = 0x2020000000;
    v178 = (void (*)(const __CFBoolean *, id, statfs *))off_1ED1DD608;
    v325 = off_1ED1DD608;
    if (!off_1ED1DD608)
    {
      *(_QWORD *)out_token = MEMORY[0x1E0C809B0];
      *(_QWORD *)&out_token[2] = 3221225472;
      *(_QWORD *)&v317 = __getSAModelGatherInfoSymbolLoc_block_invoke;
      *((_QWORD *)&v317 + 1) = &unk_1E71477A0;
      *(_QWORD *)&v318 = v324;
      __getSAModelGatherInfoSymbolLoc_block_invoke((uint64_t)out_token);
      v178 = *(void (**)(const __CFBoolean *, id, statfs *))(*(_QWORD *)&v324[8] + 24);
    }
    _Block_object_dispose(v324, 8);
    if (v178)
    {
      v178(v138, v177, p_hasHardwareKeyboardInfo);

      v179 = dispatch_time(0, 10000000000);
      if (dispatch_semaphore_wait(v176, v179))
      {
        v180 = *__error();
        _sa_logt();
        v181 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
        {
          LOWORD(out_token[0]) = 0;
          _os_log_error_impl(&dword_1B9BE0000, v181, OS_LOG_TYPE_ERROR, "Timed out waiting for model info", (uint8_t *)out_token, 2u);
        }

        *__error() = v180;
      }

      goto LABEL_275;
    }
    v255 = dlerror();
    abort_report_np();
    __break(1u);
LABEL_355:
    v253 = CFGetTypeID(v138);
    v254 = (__CFString *)CFCopyTypeIDDescription(v253);
    buf.f_bsize = 138412290;
    *(_QWORD *)&buf.f_iosize = v254;
    _os_log_fault_impl(&dword_1B9BE0000, v176, OS_LOG_TYPE_FAULT, "HardwareKeyboardLastSeen not a BOOLean: %@", (uint8_t *)&buf, 0xCu);

LABEL_353:
    *__error() = (int)v178;
    CFRelease(v138);
LABEL_194:
    LOBYTE(p_hasHardwareKeyboardInfo->f_bsize) = 0;
  }
  v182 = *__error();
  _sa_logt();
  v183 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.f_bsize) = 0;
    _os_log_error_impl(&dword_1B9BE0000, v183, OS_LOG_TYPE_ERROR, "SAModel not available", (uint8_t *)&buf, 2u);
  }

  *__error() = v182;
LABEL_275:
  objc_msgSend(MEMORY[0x1E0DC5F00], "personaAttributesForPersonaType:", 2);
  v184 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v184, "userPersonaUniqueString");
  v185 = (void *)objc_claimAutoreleasedReturnValue();
  self->_hasEnterprisePersona = v185 != 0;

  +[SATimestamp timestamp](SATimestamp, "timestamp");
  v186 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v186, "wallTime");
  v188 = v187;
  objc_msgSend(v186, "machContTimeSeconds");
  v190 = v189;
  v256 = v186;
  LastWake = -[SASampleStore _getLastWakeTime]((uint64_t)self);
  if (LastWake != 0.0)
  {
    if (LastWake <= 0.0)
    {
      v192 = 0;
    }
    else
    {
      v192 = -[SATimestamp initWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]([SATimestamp alloc], "initWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, LastWake);
      -[SATimestamp guessMissingTimesBasedOnTimestamp:](v192, "guessMissingTimesBasedOnTimestamp:", v256);
    }
    v280[0] = MEMORY[0x1E0C809B0];
    v280[1] = 3221225472;
    v280[2] = __28__SASampleStore_postprocess__block_invoke_3_158;
    v280[3] = &unk_1E7146DE8;
    v283 = v188 - v190;
    obj = v192;
    v281 = obj;
    v256 = v256;
    v282 = v256;
    -[SASampleStore iterateAllTimestamps:]((uint64_t)self, v280);

    goto LABEL_280;
  }
LABEL_281:

  if (self)
  {
    if (!self->_kernelVersion)
    {
      memset(&buf, 0, 512);
      buf.f_mntonname[680] = 0;
      if (uname((utsname *)&buf))
      {
        v193 = *__error();
        _sa_logt();
        v194 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
        {
          v195 = *__error();
          out_token[0] = 67109120;
          out_token[1] = v195;
          _os_log_impl(&dword_1B9BE0000, v194, OS_LOG_TYPE_DEFAULT, "WARNING: unable to get kernel strings: %d", (uint8_t *)out_token, 8u);
        }

        *__error() = v193;
      }
      else if (buf.f_mntonname[680])
      {
        SANSStringForCString(&buf.f_mntonname[680]);
        v196 = (NSString *)objc_claimAutoreleasedReturnValue();
        kernelVersion = self->_kernelVersion;
        self->_kernelVersion = v196;

      }
    }
    if (!self->_osProductName && !self->_osProductVersion && !self->_osProductVersionExtra && !self->_osBuildVersion)
    {
      v198 = (const __CFDictionary *)_CFCopySupplementalVersionDictionary();
      v199 = v198;
      if (v198)
      {
        CFDictionaryGetValue(v198, (const void *)*MEMORY[0x1E0C9AB98]);
        v200 = (NSString *)objc_claimAutoreleasedReturnValue();
        osProductName = self->_osProductName;
        self->_osProductName = v200;

        CFDictionaryGetValue(v199, (const void *)*MEMORY[0x1E0C9ABB0]);
        v202 = (NSString *)objc_claimAutoreleasedReturnValue();
        osProductVersion = self->_osProductVersion;
        self->_osProductVersion = v202;

        CFDictionaryGetValue(v199, (const void *)*MEMORY[0x1E0C9ABA8]);
        v204 = (NSString *)objc_claimAutoreleasedReturnValue();
        osProductVersionExtra = self->_osProductVersionExtra;
        self->_osProductVersionExtra = v204;

        CFDictionaryGetValue(v199, (const void *)*MEMORY[0x1E0C9AB90]);
        v206 = (NSString *)objc_claimAutoreleasedReturnValue();
        osBuildVersion = self->_osBuildVersion;
        self->_osBuildVersion = v206;

        CFRelease(v199);
      }
      else
      {
        v210 = *__error();
        _sa_logt();
        v211 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v211, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.f_bsize) = 0;
          _os_log_error_impl(&dword_1B9BE0000, v211, OS_LOG_TYPE_ERROR, "unable to get system versions dictionary", (uint8_t *)&buf, 2u);
        }

        *__error() = v210;
      }
    }
  }
  -[SASampleStore gatherMachineArchitecture](self, "gatherMachineArchitecture");
  if (self)
  {
    if (!self->_workQueueSoftThreadLimit)
    {
      *(_QWORD *)out_token = 4;
      if (sysctlbyname("kern.wq_max_constrained_threads", &self->_workQueueSoftThreadLimit, (size_t *)out_token, 0, 0))
      {
        v212 = *__error();
        _sa_logt();
        v213 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
        {
          v237 = *__error();
          v238 = __error();
          v239 = strerror(*v238);
          buf.f_bsize = 67109378;
          buf.f_iosize = v237;
          LOWORD(buf.f_blocks) = 2080;
          *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v239;
          _os_log_error_impl(&dword_1B9BE0000, v213, OS_LOG_TYPE_ERROR, "Unable to get kern.wq_max_constrained_threads: %d %s", (uint8_t *)&buf, 0x12u);
        }

        *__error() = v212;
      }
    }
    if (!self->_workQueueHardThreadLimit)
    {
      *(_QWORD *)out_token = 4;
      if (sysctlbyname("kern.wq_max_threads", &self->_workQueueHardThreadLimit, (size_t *)out_token, 0, 0))
      {
        v214 = *__error();
        _sa_logt();
        v215 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
        {
          v240 = *__error();
          v241 = __error();
          v242 = strerror(*v241);
          buf.f_bsize = 67109378;
          buf.f_iosize = v240;
          LOWORD(buf.f_blocks) = 2080;
          *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v242;
          _os_log_error_impl(&dword_1B9BE0000, v215, OS_LOG_TYPE_ERROR, "Unable to get kern.wq_max_threads: %d %s", (uint8_t *)&buf, 0x12u);
        }

        *__error() = v214;
      }
    }
    if (qword_1ED1DD588 != -1)
      dispatch_once(&qword_1ED1DD588, &__block_literal_global_354);
    objc_storeStrong((id *)&self->_hardwareModel, (id)qword_1ED1DD580);
    if (!self->_numActiveCPUs)
    {
      *(_QWORD *)out_token = 4;
      if (sysctlbyname("hw.activecpu", &self->_numActiveCPUs, (size_t *)out_token, 0, 0))
      {
        v217 = *__error();
        _sa_logt();
        v218 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v218, OS_LOG_TYPE_ERROR))
        {
          v243 = *__error();
          v244 = __error();
          v245 = strerror(*v244);
          buf.f_bsize = 67109378;
          buf.f_iosize = v243;
          LOWORD(buf.f_blocks) = 2080;
          *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v245;
          _os_log_error_impl(&dword_1B9BE0000, v218, OS_LOG_TYPE_ERROR, "Unable to get hw.activecpu: %d %s", (uint8_t *)&buf, 0x12u);
        }

        *__error() = v217;
      }
      if (!objc_getProperty(self, v216, 1032, 1))
      {
        current = ktrace_machine_create_current();
        if (current)
        {
          MEMORY[0x1BCCCB7F0]();
          v220 = CSArchitectureIs64Bit();
          -[SASampleStore _populateFromKtraceMachineInfo:is64bit:]((uint64_t)self, current, v220);
          ktrace_machine_destroy();
        }
        else
        {
          v221 = *__error();
          _sa_logt();
          v222 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf.f_bsize) = 0;
            _os_log_error_impl(&dword_1B9BE0000, v222, OS_LOG_TYPE_ERROR, "Unable to get ktrace machine - cannot determine P vs E cores", (uint8_t *)&buf, 2u);
          }

          *__error() = v221;
        }
      }
    }
  }
  -[SASampleStore gatherHWPageSize]((int *)self);
  -[SASampleStore gatherVMPageSize]((int *)self);
  if (self)
  {
    if (!self->_appleInternalIsKnown)
    {
      self->_appleInternalIsKnown = 1;
      self->_isAppleInternal = is_apple_internal_setting();
      if (qword_1ED1DD5F8 != -1)
        dispatch_once(&qword_1ED1DD5F8, &__block_literal_global_1483);
      objc_storeStrong((id *)&self->_automatedDeviceGroup, (id)qword_1ED1DD5F0);
      if (self->_isAppleInternal)
      {
        self->_hasInternalCarryDeviceDistinction = 1;
        if (!self->_automatedDeviceGroup)
        {
          v234 = (void *)CFPreferencesCopyValue(CFSTR("ExperimentGroup"), CFSTR("com.apple.da"), CFSTR("mobile"), (CFStringRef)*MEMORY[0x1E0C9B230]);
          objc_msgSend(v234, "lowercaseString");
          v235 = (void *)objc_claimAutoreleasedReturnValue();

          if ((objc_msgSend(v235, "containsString:", CFSTR("carry")) & 1) != 0)
            v236 = 1;
          else
            v236 = objc_msgSend(v235, "containsString:", CFSTR("walkabout"));

          self->_isInternalCarryDevice = v236;
        }
      }
    }
    if (self->_numOSCryptexFileExtents <= 0)
    {
      if (qword_1ED1DD5A8 != -1)
        dispatch_once(&qword_1ED1DD5A8, &__block_literal_global_396);
      self->_numOSCryptexFileExtents = qword_1ED1DD5B0;
    }
  }
LABEL_328:
  v266 = 0u;
  v267 = 0u;
  v264 = 0u;
  v265 = 0u;
  v223 = (void *)-[NSMutableArray copy](self->_sharedCaches, "copy");
  v224 = objc_msgSend(v223, "countByEnumeratingWithState:objects:count:", &v264, v311, 16);
  if (v224)
  {
    v225 = *(_QWORD *)v265;
    do
    {
      for (m = 0; m != v224; ++m)
      {
        if (*(_QWORD *)v265 != v225)
          objc_enumerationMutation(v223);
        v227 = *(_BYTE **)(*((_QWORD *)&v264 + 1) + 8 * m);
        if (v227 && (v227[24] & 1) != 0)
        {
          objc_msgSend(*(id *)(*((_QWORD *)&v264 + 1) + 8 * m), "uuid");
          v228 = (void *)objc_claimAutoreleasedReturnValue();
          +[SASharedCache sharedCacheWithUUID:slide:slidBaseAddress:](SASharedCache, "sharedCacheWithUUID:slide:slidBaseAddress:", v228, objc_msgSend(v227, "slide"), objc_msgSend(v227, "slidBaseAddress"));
          v229 = (void *)objc_claimAutoreleasedReturnValue();

          objc_msgSend(v229, "binaryLoadInfos");
          v230 = (void *)objc_claimAutoreleasedReturnValue();
          if (objc_msgSend(v230, "count"))
          {

            goto LABEL_337;
          }
          objc_msgSend(v227, "binaryLoadInfos");
          v231 = (void *)objc_claimAutoreleasedReturnValue();
          v232 = objc_msgSend(v231, "count") == 0;

          if (v232)
          {
LABEL_337:
            -[NSMutableArray removeObject:](self->_sharedCaches, "removeObject:", v227);
            -[SASampleStore addSharedCache:]((uint64_t)self, v229);
          }

          continue;
        }
      }
      v224 = objc_msgSend(v223, "countByEnumeratingWithState:objects:count:", &v264, v311, 16);
    }
    while (v224);
  }

  -[NSMutableArray sortUsingComparator:](self->_ioEvents, "sortUsingComparator:", &__block_literal_global_162);
  -[NSMutableDictionary enumerateKeysAndObjectsUsingBlock:](self->_ioEventsByTid, "enumerateKeysAndObjectsUsingBlock:", &__block_literal_global_163);
  v233 = -[SASampleStore fixupAllFrames]((id *)&self->super.isa);
  _Block_object_dispose(&v288, 8);
  _Block_object_dispose(&v292, 8);
  _Block_object_dispose(&v296, 8);
  _Block_object_dispose(&v300, 8);

}

void __36__SASampleStore_gatherHardwareModel__block_invoke()
{
  dispatch_semaphore_t v0;
  NSObject *v1;
  NSObject *v2;
  dispatch_time_t v3;
  int v4;
  NSObject *v5;
  uint8_t v6[8];
  _QWORD block[4];
  NSObject *v8;

  v0 = dispatch_semaphore_create(0);
  dispatch_get_global_queue(0, 0);
  v1 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __36__SASampleStore_gatherHardwareModel__block_invoke_2;
  block[3] = &unk_1E7146F90;
  v2 = v0;
  v8 = v2;
  dispatch_async(v1, block);

  v3 = dispatch_time(0, 1000000000);
  if (dispatch_semaphore_wait(v2, v3))
  {
    v4 = *__error();
    _sa_logt();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v6 = 0;
      _os_log_error_impl(&dword_1B9BE0000, v5, OS_LOG_TYPE_ERROR, "Timed out waiting for MobileGestalt", v6, 2u);
    }

    *__error() = v4;
  }

}

- (_QWORD)lastTaskWithPid:(_QWORD *)a1
{
  if (a1)
  {
    -[SASampleStore lastTaskWithPid:onOrBeforeTimestamp:](a1, a2, 0);
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

void __32__SASampleStore_enumerateTasks___block_invoke(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v6 = a3;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v12;
LABEL_3:
    v10 = 0;
    while (1)
    {
      if (*(_QWORD *)v12 != v9)
        objc_enumerationMutation(v6);
      (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
      if (*a4)
        break;
      if (v8 == ++v10)
      {
        v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
        if (v8)
          goto LABEL_3;
        break;
      }
    }
  }

}

- (void)addTask:(uint64_t)a1
{
  id v3;
  uint64_t v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  int v15;
  NSObject *v16;
  id v17;
  id v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  id v26;
  uint8_t buf[4];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (a1)
  {
    v26 = v3;
    v4 = objc_msgSend(v3, "uniquePid");
    v5 = *(void **)(a1 + 8);
    if (v4 == -1)
    {
      if (objc_msgSend(*(id *)(a1 + 8), "count"))
      {
        v15 = *__error();
        _sa_logt();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(v26, "debugDescription");
          v17 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          *(_DWORD *)buf = 136315138;
          v28 = objc_msgSend(v17, "UTF8String");
          _os_log_error_impl(&dword_1B9BE0000, v16, OS_LOG_TYPE_ERROR, "%s has no uniquePid", buf, 0xCu);

        }
        *__error() = v15;
        objc_msgSend(v26, "debugDescription");
        v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v19 = objc_msgSend(v18, "UTF8String");
        _SASetCrashLogMessage(488, "%s has no uniquePid", v20, v21, v22, v23, v24, v25, v19);

        _os_crash();
        __break(1u);
      }
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v26, "uniquePid"));
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "objectForKeyedSubscript:", v6);
      v7 = (id)objc_claimAutoreleasedReturnValue();

      if (!v7)
      {
        v7 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v8 = *(void **)(a1 + 8);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v26, "uniquePid"));
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "setObject:forKeyedSubscript:", v7, v9);

      }
      objc_msgSend(v7, "addObject:", v26);

    }
    v10 = *(void **)(a1 + 16);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(v26, "pid"));
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "objectForKeyedSubscript:", v11);
    v12 = (id)objc_claimAutoreleasedReturnValue();

    if (!v12)
    {
      v12 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
      v13 = *(void **)(a1 + 16);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(v26, "pid"));
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "setObject:forKeyedSubscript:", v12, v14);

    }
    objc_msgSend(v12, "addObject:", v26);

    v3 = v26;
  }

}

- (NSDictionary)tasksByUniquePid
{
  return (NSDictionary *)objc_getProperty(self, a2, 8, 1);
}

- (unint64_t)targetHIDEventMachAbs
{
  return self->_targetHIDEventMachAbs;
}

- (void)setTargetHIDEventMachAbs:(unint64_t)a3
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;
  int targetProcessId;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  SATimeRange *v18;
  SATimeRange *eventTimeRange;
  NSMutableArray *obj;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  self->_targetHIDEventMachAbs = a3;
  if (a3 && !self->_eventTimeRange)
  {
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    obj = self->_hidEvents;
    v4 = -[NSMutableArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v22;
      while (2)
      {
        for (i = 0; i != v5; ++i)
        {
          if (*(_QWORD *)v22 != v6)
            objc_enumerationMutation(obj);
          v8 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * i);
          objc_msgSend(v8, "hidEventTimestamp");
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          if (objc_msgSend(v9, "machAbsTime") == self->_targetHIDEventMachAbs)
          {
            if (self->_targetProcessId < 0)
            {

LABEL_17:
              objc_msgSend(v8, "hidEventTimestamp");
              v14 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "steps");
              v15 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v15, "lastObject");
              v16 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v16, "timestamp");
              v17 = (void *)objc_claimAutoreleasedReturnValue();
              +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", v14, v17);
              v18 = (SATimeRange *)objc_claimAutoreleasedReturnValue();
              eventTimeRange = self->_eventTimeRange;
              self->_eventTimeRange = v18;

              goto LABEL_18;
            }
            objc_msgSend(v8, "steps");
            v10 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v10, "lastObject");
            v11 = (void *)objc_claimAutoreleasedReturnValue();
            v12 = objc_msgSend(v11, "pid");
            targetProcessId = self->_targetProcessId;

            if (v12 == targetProcessId)
              goto LABEL_17;
          }
          else
          {

          }
        }
        v5 = -[NSMutableArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
        if (v5)
          continue;
        break;
      }
    }
LABEL_18:

  }
}

- (BOOL)haveKPerfSched
{
  return self->_haveKPerfSched;
}

- (void)setHaveKPerfSched:(BOOL)a3
{
  self->_haveKPerfSched = a3;
}

- (NSArray)kperfTriggers
{
  return self->_kperfTriggers;
}

- (void)setKperfTriggers:(id)a3
{
  NSArray *v4;
  NSArray *kperfTriggers;

  v4 = (NSArray *)objc_msgSend(a3, "copy");
  kperfTriggers = self->_kperfTriggers;
  self->_kperfTriggers = v4;

}

- (double)kPerfPETSampleIntervalLimit
{
  return self->_sampleIntervalLimit;
}

- (void)setKPerfPETSampleIntervalLimit:(double)a3
{
  self->_sampleIntervalLimit = a3;
}

- (BOOL)kPerfPETParsePastLastStackshot
{
  return self->_kPerfPETParsePastLastStackshot;
}

- (void)setKPerfPETParsePastLastStackshot:(BOOL)a3
{
  self->_kPerfPETParsePastLastStackshot = a3;
}

- (void)addSharedCache:(uint64_t)a1
{
  id v3;
  char v4;
  id v5;

  v3 = a2;
  if (a1)
  {
    v5 = v3;
    v4 = objc_msgSend(*(id *)(a1 + 112), "containsObject:", v3);
    v3 = v5;
    if ((v4 & 1) == 0)
    {
      objc_msgSend(*(id *)(a1 + 112), "addObject:", v5);
      v3 = v5;
    }
  }

}

- (unint64_t)numSamples
{
  unint64_t result;

  result = -[NSMutableArray count](self->_sampleTimestamps, "count");
  if (!result)
    return self->_numSamples;
  return result;
}

- (void)setStartTime:(uint64_t)a1
{
  id v4;

  v4 = a2;
  if (a1)
    objc_storeStrong((id *)(a1 + 40), a2);

}

- (void)setEndTime:(uint64_t)a1
{
  id v4;

  v4 = a2;
  if (a1)
    objc_storeStrong((id *)(a1 + 48), a2);

}

- (void)addIOEvent:(uint64_t)a1
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v3 = a2;
  if (a1)
  {
    v10 = v3;
    objc_msgSend(*(id *)(a1 + 88), "addObject:", v3);
    v4 = *(void **)(a1 + 968);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v10, "threadID"));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "objectForKeyedSubscript:", v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      objc_msgSend(v6, "addObject:", v10);
    }
    else
    {
      v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithObjects:", v10, 0);
      v8 = *(void **)(a1 + 968);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v10, "threadID"));
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v7, v9);

    }
    v3 = v10;
  }

}

- (void)removeAllData
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  id v20;
  void *v21;

  if (a1)
  {
    v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v3 = (void *)a1[3];
    a1[3] = v2;

    v4 = (void *)a1[5];
    a1[4] = 0;
    a1[5] = 0;

    v5 = (void *)a1[6];
    a1[6] = 0;

    v6 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    v7 = (void *)a1[2];
    a1[2] = v6;

    v8 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    v9 = (void *)a1[1];
    a1[1] = v8;

    v10 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v11 = (void *)a1[7];
    a1[7] = v10;

    v12 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v13 = (void *)a1[8];
    a1[8] = v12;

    v14 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v15 = (void *)a1[11];
    a1[11] = v14;

    v16 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    v17 = (void *)a1[121];
    a1[121] = v16;

    v18 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v19 = (void *)a1[12];
    a1[12] = v18;

    v20 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v21 = (void *)a1[9];
    a1[9] = v20;

  }
}

- (BOOL)isEmpty
{
  return -[SASampleStore numSamples](self, "numSamples") == 0;
}

- (void)enumerateTasks:(id)a3
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD v9[4];
  id v10;

  v4 = a3;
  v5 = -[NSMutableDictionary count](self->_tasksByUniquePid, "count");
  v6 = 8;
  if (!v5)
    v6 = 16;
  v7 = *(Class *)((char *)&self->super.isa + v6);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __32__SASampleStore_enumerateTasks___block_invoke;
  v9[3] = &unk_1E7146C98;
  v10 = v4;
  v8 = v4;
  objc_msgSend(v7, "enumerateKeysAndObjectsUsingBlock:", v9);

}

- (void)useDsymForUUIDFor:(id)a3
{
  const char *v4;
  unint64_t v5;
  SASampleStore *v6;
  NSMutableArray *namesToUseDsymForUUID;
  uint64_t v8;
  NSMutableArray *v9;
  unint64_t v10;
  NSMutableArray *idsToUseDsymForUUID;
  void *v12;
  id v13;
  uint64_t v14;
  NSMutableArray *v15;
  id v16;
  char *__endptr;

  v16 = objc_retainAutorelease(a3);
  v4 = (const char *)objc_msgSend(v16, "UTF8String");
  if (v4 && (__endptr = 0, v5 = strtoull(v4, &__endptr, 0), __endptr) && !*__endptr)
  {
    v10 = v5;
    v6 = self;
    objc_sync_enter(v6);
    idsToUseDsymForUUID = v6->_idsToUseDsymForUUID;
    if (idsToUseDsymForUUID)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v10);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      -[NSMutableArray addObject:](idsToUseDsymForUUID, "addObject:", v12);
    }
    else
    {
      v13 = objc_alloc(MEMORY[0x1E0C99DE8]);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v10);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = objc_msgSend(v13, "initWithObjects:", v12, 0);
      v15 = v6->_idsToUseDsymForUUID;
      v6->_idsToUseDsymForUUID = (NSMutableArray *)v14;

    }
  }
  else
  {
    v6 = self;
    objc_sync_enter(v6);
    namesToUseDsymForUUID = v6->_namesToUseDsymForUUID;
    if (namesToUseDsymForUUID)
    {
      -[NSMutableArray addObject:](namesToUseDsymForUUID, "addObject:", v16);
    }
    else
    {
      v8 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithObjects:", v16, 0);
      v9 = v6->_namesToUseDsymForUUID;
      v6->_namesToUseDsymForUUID = (NSMutableArray *)v8;

    }
  }
  objc_sync_exit(v6);

}

- (id)fanSpeedClosestToTimestamp:(id)a3
{
  id v4;
  NSMutableArray *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  void *v17;
  double v18;
  double v19;
  double v20;
  double v21;
  id v22;
  void *v23;
  char v24;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[128];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v5 = self->_fanSpeeds;
  v6 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v26, v30, 16);
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    v9 = *(_QWORD *)v27;
LABEL_3:
    v10 = 0;
    while (1)
    {
      if (*(_QWORD *)v27 != v9)
        objc_enumerationMutation(v5);
      v11 = *(void **)(*((_QWORD *)&v26 + 1) + 8 * v10);
      if (!v8)
        goto LABEL_8;
      objc_msgSend(v8, "timestamp", (_QWORD)v26);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "machAbsTimeSeconds");
      v14 = v13;
      objc_msgSend(v4, "machAbsTimeSeconds");
      v16 = vabdd_f64(v14, v15);
      objc_msgSend(v11, "timestamp");
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v17, "machAbsTimeSeconds");
      v19 = v18;
      objc_msgSend(v4, "machAbsTimeSeconds");
      v21 = vabdd_f64(v19, v20);

      if (v16 > v21)
      {
LABEL_8:
        v22 = v11;

        v8 = v22;
      }
      objc_msgSend(v8, "timestamp", (_QWORD)v26);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      v24 = objc_msgSend(v23, "ge:", v4);

      if ((v24 & 1) != 0)
        break;
      if (v7 == ++v10)
      {
        v7 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v26, v30, 16);
        if (v7)
          goto LABEL_3;
        break;
      }
    }
  }
  else
  {
    v8 = 0;
  }

  return v8;
}

- (BOOL)haveCPUClusterInfo
{
  if (self)
    self = (SASampleStore *)objc_getProperty(self, a2, 1032, 1);
  return self != 0;
}

- (BOOL)isECoreForCPUNum:(unsigned int)a3
{
  return -[SASampleStore clusterFlagsForCPUNum:](self, *(const char **)&a3) & 1;
}

- (void)clusterFlagsForCPUNum:(void *)result
{
  id Property;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;

  if (result)
  {
    Property = objc_getProperty(result, a2, 1032, 1);
    v4 = (void *)MEMORY[0x1E0CB37E8];
    v5 = Property;
    objc_msgSend(v4, "numberWithUnsignedInt:", a2);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "objectForKeyedSubscript:", v6);
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    v8 = objc_msgSend(v7, "unsignedLongLongValue");
    return (void *)v8;
  }
  return result;
}

- (BOOL)isPCoreForCPUNum:(unsigned int)a3
{
  return ((unint64_t)-[SASampleStore clusterFlagsForCPUNum:](self, *(const char **)&a3) >> 1) & 1;
}

- (BOOL)setTargetProcessWithHint:(id)a3
{
  id v4;
  void *v5;
  const __CFNumber *v6;
  const __CFNumber *v7;
  void *v8;
  void *v9;
  void *v10;
  BOOL v11;
  void *v12;
  id v13;
  SASampleStore *v14;
  uint64_t v15;
  void *v16;
  uint64_t i;
  void *v18;
  void *v19;
  SATimeRange *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  char v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  SATask *v39;
  SATask *v40;
  SATask *v41;
  SATask *v42;
  SATask *v43;
  SATask *v44;
  SATask *v45;
  SATimeRange *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  const __CFNumber *v50;
  uint64_t v51;
  void *v52;
  SASampleStore *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  uint64_t v61;
  void *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  void *v66;
  void *v67;
  id v68;
  const __CFNumber *v69;
  id obj;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  SATask *v74;
  SATask *v75;
  SATask *v76;
  id v77;
  SATask *v78;
  SATask *v79;
  SASampleStore *v80;
  id v81;
  uint64_t v82;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  _BYTE v92[128];
  _BYTE v93[128];
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5 = v4;
  if (!v4 || !objc_msgSend(v4, "length"))
  {
    self->_targetProcessId = -1;
    self->_targetThreadId = 0;
    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)self, 0);
    v11 = 1;
    goto LABEL_75;
  }
  v68 = objc_alloc_init(MEMORY[0x1E0CB37F0]);
  objc_msgSend(v68, "numberFromString:", v5);
  v6 = (const __CFNumber *)objc_claimAutoreleasedReturnValue();
  v80 = self;
  v69 = v6;
  if (!v6)
    goto LABEL_5;
  v7 = v6;
  if (CFNumberIsFloatType(v6))
    goto LABEL_5;
  v46 = self->_eventTimeRange;
  v47 = -[__CFNumber intValue](v7, "intValue");
  if (v46)
  {
    -[SATimeRange endTime](v46, "endTime");
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    -[SASampleStore lastTaskWithPid:onOrBeforeTimestamp:](self, v47, v48);
    v49 = objc_claimAutoreleasedReturnValue();
    if (v49)
    {
      v40 = (SATask *)v49;

LABEL_64:
      v50 = v69;
      goto LABEL_65;
    }
    v51 = -[__CFNumber intValue](v69, "intValue");
    -[SATimeRange endTime](v46, "endTime");
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    -[SASampleStore firstTaskWithPid:onOrAfterTimestamp:](self, v51, v52);
    v40 = (SATask *)objc_claimAutoreleasedReturnValue();

    if (v40)
      goto LABEL_64;
    v61 = -[__CFNumber unsignedLongLongValue](v69, "unsignedLongLongValue");
    -[SATimeRange endTime](v46, "endTime");
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    -[SASampleStore lastTaskWithUniquePid:onOrBeforeTimestamp:](self, v61, v62);
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    v64 = v63;
    if (v63)
    {
      v40 = v63;
    }
    else
    {
      v65 = -[__CFNumber unsignedLongLongValue](v69, "unsignedLongLongValue");
      -[SATimeRange endTime](v46, "endTime");
      v66 = v5;
      v67 = (void *)objc_claimAutoreleasedReturnValue();
      -[SASampleStore firstTaskWithUniquePid:onOrAfterTimestamp:](v80, v65, v67);
      v40 = (SATask *)objc_claimAutoreleasedReturnValue();

      v5 = v66;
    }

  }
  else
  {
    -[SASampleStore lastTaskWithPid:](self, v47);
    v40 = (SATask *)objc_claimAutoreleasedReturnValue();
    if (v40)
      goto LABEL_64;
    -[SASampleStore lastTaskWithUniquePid:](self, -[__CFNumber unsignedLongLongValue](v69, "unsignedLongLongValue"));
    v40 = (SATask *)objc_claimAutoreleasedReturnValue();
  }

  self = v80;
  v50 = v69;
  if (v40)
    goto LABEL_65;
LABEL_5:
  if (-[NSMutableDictionary count](self->_tasksByUniquePid, "count"))
  {
    -[NSMutableDictionary allValues](self->_tasksByUniquePid, "allValues");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = v8;
    v10 = &__block_literal_global_1;
  }
  else
  {
    -[NSMutableDictionary allValues](self->_tasksByPid, "allValues");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = v8;
    v10 = &__block_literal_global_144;
  }
  objc_msgSend(v8, "sortedArrayUsingComparator:", v10);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v13 = v12;
  v72 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v88, v93, 16);
  if (!v72)
  {

    v41 = 0;
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v42 = 0;
    v39 = 0;
    v40 = 0;
    goto LABEL_57;
  }
  v77 = 0;
  v78 = 0;
  v74 = 0;
  v75 = 0;
  v79 = 0;
  v76 = 0;
  obj = v13;
  v71 = *(_QWORD *)v89;
  v14 = v80;
  do
  {
    v15 = 0;
    do
    {
      if (*(_QWORD *)v89 != v71)
        objc_enumerationMutation(obj);
      v73 = v15;
      v16 = *(void **)(*((_QWORD *)&v88 + 1) + 8 * v15);
      v84 = 0u;
      v85 = 0u;
      v86 = 0u;
      v87 = 0u;
      v81 = v16;
      v83 = objc_msgSend(v81, "countByEnumeratingWithState:objects:count:", &v84, v92, 16);
      if (v83)
      {
        v82 = *(_QWORD *)v85;
        do
        {
          for (i = 0; i != v83; ++i)
          {
            if (*(_QWORD *)v85 != v82)
              objc_enumerationMutation(v81);
            v18 = *(void **)(*((_QWORD *)&v84 + 1) + 8 * i);
            objc_msgSend(v18, "name");
            v19 = (void *)objc_claimAutoreleasedReturnValue();
            if (v19)
            {
              v20 = v14->_eventTimeRange;
              if (v20)
              {
                objc_msgSend(v18, "startTimestamp");
                v21 = (void *)objc_claimAutoreleasedReturnValue();
                -[SATimeRange endTime](v20, "endTime");
                v22 = (void *)objc_claimAutoreleasedReturnValue();
                if (objc_msgSend(v21, "gt:", v22))
                {

LABEL_42:
                  goto LABEL_43;
                }
                objc_msgSend(v18, "endTimestamp");
                v23 = v5;
                v24 = (void *)objc_claimAutoreleasedReturnValue();
                -[SATimeRange startTime](v20, "startTime");
                v25 = (void *)objc_claimAutoreleasedReturnValue();
                v26 = objc_msgSend(v24, "lt:", v25);

                v5 = v23;
                v14 = v80;

                if ((v26 & 1) != 0)
                  goto LABEL_42;
              }
              objc_msgSend(v18, "name");
              v27 = (void *)objc_claimAutoreleasedReturnValue();
              v28 = objc_msgSend(v27, "rangeOfString:", v5);
              v30 = v29;

              if (v28 == 0x7FFFFFFFFFFFFFFFLL)
              {
                objc_msgSend(v18, "name");
                v33 = (void *)objc_claimAutoreleasedReturnValue();
                v34 = objc_msgSend(v33, "rangeOfString:options:", v5, 1);
                v36 = v35;

                if (v34 != 0x7FFFFFFFFFFFFFFFLL)
                {
                  if (v34)
                  {
                    if (!v76)
                      v76 = v18;
                  }
                  else
                  {
                    objc_msgSend(v18, "name");
                    v37 = (void *)objc_claimAutoreleasedReturnValue();
                    v38 = objc_msgSend(v37, "length");

                    if (v36 == v38)
                    {
                      if (!v75)
                        v75 = v18;
                    }
                    else if (!v74)
                    {
                      v74 = v18;
                    }
                  }
                }
              }
              else if (v28)
              {
                if (!v79)
                  v79 = v18;
              }
              else
              {
                objc_msgSend(v18, "name");
                v31 = (void *)objc_claimAutoreleasedReturnValue();
                v32 = objc_msgSend(v31, "length");

                if (v30 == v32)
                {
                  if (!v77)
                    v77 = v18;
                }
                else if (!v78)
                {
                  v78 = v18;
                }
              }
              goto LABEL_42;
            }
LABEL_43:

          }
          v83 = objc_msgSend(v81, "countByEnumeratingWithState:objects:count:", &v84, v92, 16);
        }
        while (v83);
      }

      v15 = v73 + 1;
    }
    while (v73 + 1 != v72);
    v72 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v88, v93, 16);
  }
  while (v72);
  v13 = obj;

  if (v77)
  {
    v39 = (SATask *)v77;
    v40 = v39;
    v42 = v75;
    v41 = v76;
    goto LABEL_55;
  }
  if (v75)
  {
    v42 = v75;
    v39 = 0;
    v40 = v42;
    v41 = v76;
LABEL_55:
    v45 = v78;
    v43 = v79;
LABEL_56:
    v44 = v74;
  }
  else
  {
    if (v78)
    {
      v45 = v78;
      v42 = 0;
      v39 = 0;
      v40 = v45;
      v41 = v76;
      v43 = v79;
      goto LABEL_56;
    }
    if (v74)
    {
      v44 = v74;
      v45 = 0;
      v42 = 0;
      v39 = 0;
      v40 = v44;
      v41 = v76;
      v43 = v79;
    }
    else if (v79)
    {
      v43 = v79;
      v44 = 0;
      v45 = 0;
      v42 = 0;
      v39 = 0;
      v40 = v43;
      v41 = v76;
    }
    else
    {
      if (v76)
      {
        v41 = v76;
        v43 = 0;
        v44 = 0;
        v45 = 0;
        v42 = 0;
        v39 = 0;
        v40 = v41;
      }
      else
      {
        v41 = 0;
        v43 = 0;
        v44 = 0;
        v45 = 0;
        v42 = 0;
        v39 = 0;
        v40 = 0;
      }
      v13 = obj;
    }
  }
LABEL_57:

  self = v80;
  v50 = v69;
  if (!v40)
  {
    v11 = 0;
    goto LABEL_74;
  }
LABEL_65:
  if (self->_targetProcess == v40)
  {
    v11 = 1;
  }
  else
  {
    objc_storeStrong((id *)&self->_targetProcess, v40);
    self->_targetProcessId = -[SATask pid](v40, "pid");
    v53 = self;
    if (self->_targetThreadId)
    {
      -[SATask threads](self->_targetProcess, "threads");
      v54 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v53->_targetThreadId);
      v55 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v54, "objectForKeyedSubscript:", v55);
      v56 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v56)
        v53->_targetThreadId = 0;
    }
    if (v53->_targetDispatchQueueId)
    {
      -[SATask dispatchQueues](v53->_targetProcess, "dispatchQueues");
      v57 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v53->_targetDispatchQueueId);
      v58 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v57, "objectForKeyedSubscript:", v58);
      v59 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v59)
        v53->_targetDispatchQueueId = 0;
    }
    v11 = 1;
    v50 = v69;
  }
LABEL_74:

LABEL_75:
  return v11;
}

- (_QWORD)lastTaskWithPid:(void *)a3 onOrBeforeTimestamp:
{
  id v5;
  void *v6;
  void *v7;
  void *v8;

  v5 = a3;
  if (a1)
  {
    v6 = (void *)a1[2];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      if (v5)
        -[SASampleStore _lastTaskOnOrBeforeTimestamp:inTasks:]((uint64_t)a1, v5, v8);
      else
        objc_msgSend(v8, "lastObject");
      a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      a1 = 0;
    }

  }
  return a1;
}

- (_QWORD)firstTaskWithPid:(void *)a3 onOrAfterTimestamp:
{
  id v5;
  void *v6;
  void *v7;
  void *v8;

  v5 = a3;
  if (a1)
  {
    v6 = (void *)a1[2];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      if (v5)
        -[SASampleStore _firstTaskOnOrAfterTimestamp:inTasks:](v5, v8);
      else
        objc_msgSend(v8, "firstObject");
      a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      a1 = 0;
    }

  }
  return a1;
}

- (_QWORD)lastTaskWithUniquePid:(void *)a3 onOrBeforeTimestamp:
{
  id v5;
  void *v6;
  void *v7;
  void *v8;

  v5 = a3;
  if (a1)
  {
    v6 = (void *)a1[1];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v5)
      -[SASampleStore _lastTaskOnOrBeforeTimestamp:inTasks:]((uint64_t)a1, v5, v8);
    else
      objc_msgSend(v8, "lastObject");
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();

  }
  return a1;
}

- (_QWORD)firstTaskWithUniquePid:(void *)a3 onOrAfterTimestamp:
{
  id v5;
  void *v6;
  void *v7;
  void *v8;

  v5 = a3;
  if (a1)
  {
    v6 = (void *)a1[1];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v5)
      -[SASampleStore _firstTaskOnOrAfterTimestamp:inTasks:](v5, v8);
    else
      objc_msgSend(v8, "firstObject");
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();

  }
  return a1;
}

- (_QWORD)lastTaskWithUniquePid:(_QWORD *)a1
{
  if (a1)
  {
    -[SASampleStore lastTaskWithUniquePid:onOrBeforeTimestamp:](a1, a2, 0);
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

uint64_t __42__SASampleStore_setTargetProcessWithHint___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  void *v6;
  unint64_t v7;
  void *v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  unint64_t v12;
  void *v13;

  v4 = a2;
  v5 = a3;
  objc_msgSend(v4, "lastObject");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "uniquePid");
  objc_msgSend(v5, "lastObject");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = objc_msgSend(v8, "uniquePid");

  if (v7 <= v9)
  {
    objc_msgSend(v4, "lastObject");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = objc_msgSend(v11, "uniquePid");
    objc_msgSend(v5, "lastObject");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = v12 < objc_msgSend(v13, "uniquePid");

  }
  else
  {
    v10 = -1;
  }

  return v10;
}

uint64_t __42__SASampleStore_setTargetProcessWithHint___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v4;
  void *v5;
  int v6;
  void *v7;
  uint64_t v8;

  v4 = a2;
  objc_msgSend(a3, "lastObject");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "pid");
  objc_msgSend(v4, "lastObject");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (int)(v6 - objc_msgSend(v7, "pid"));
  return v8;
}

- (unint64_t)targetThreadId
{
  return self->_targetThreadId;
}

- (void)setTargetThreadId:(unint64_t)a3
{
  if (self->_targetThreadId != a3)
  {
    self->_targetThreadId = a3;
    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)self, 0);
  }
}

- (unint64_t)targetDispatchQueueId
{
  return self->_targetDispatchQueueId;
}

- (void)setTargetDispatchQueueId:(unint64_t)a3
{
  unint64_t v3;
  SATask *targetProcess;
  void *v6;
  void *v7;
  void *v8;

  if (self->_targetDispatchQueueId != a3)
  {
    v3 = a3;
    if (a3)
    {
      targetProcess = self->_targetProcess;
      if (targetProcess)
      {
        -[SATask dispatchQueues](targetProcess, "dispatchQueues");
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v3);
        v7 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v6, "objectForKeyedSubscript:", v7);
        v8 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v8)
          v3 = 0;
      }
    }
    self->_targetDispatchQueueId = v3;
  }
}

- (int)targetProcessId
{
  return self->_targetProcessId;
}

- (void)setTargetProcess:(id)a3
{
  SATask *v5;
  SATask *targetProcess;
  NSMutableDictionary *tasksByPid;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  int v17;
  NSObject *v18;
  id v19;
  id v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  SATask *v28;
  uint8_t buf[4];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v5 = (SATask *)a3;
  targetProcess = self->_targetProcess;
  if (targetProcess != v5)
  {
    v28 = v5;
    if (v5)
    {
      tasksByPid = self->_tasksByPid;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[SATask pid](v5, "pid"));
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      -[NSMutableDictionary objectForKeyedSubscript:](tasksByPid, "objectForKeyedSubscript:", v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = objc_msgSend(v9, "indexOfObjectIdenticalTo:", v28);

      if (v10 == 0x7FFFFFFFFFFFFFFFLL)
      {
        v17 = *__error();
        _sa_logt();
        v18 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          -[SATask debugDescription](v28, "debugDescription");
          v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          *(_DWORD *)buf = 136315138;
          v30 = objc_msgSend(v19, "UTF8String");
          _os_log_error_impl(&dword_1B9BE0000, v18, OS_LOG_TYPE_ERROR, "Setting target process %s which isn't in this SASampleStore", buf, 0xCu);

        }
        *__error() = v17;
        -[SATask debugDescription](v28, "debugDescription");
        v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v21 = objc_msgSend(v20, "UTF8String");
        _SASetCrashLogMessage(859, "Setting target process %s which isn't in this SASampleStore", v22, v23, v24, v25, v26, v27, v21);

        _os_crash();
        __break(1u);
      }
      objc_storeStrong((id *)&self->_targetProcess, a3);
      self->_targetProcessId = -[SATask pid](v28, "pid");
      if (self->_targetThreadId)
      {
        -[SATask threads](v28, "threads");
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", self->_targetThreadId);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v11, "objectForKeyedSubscript:", v12);
        v13 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v13)
          self->_targetThreadId = 0;
      }
      v5 = v28;
      if (self->_targetDispatchQueueId)
      {
        -[SATask dispatchQueues](v28, "dispatchQueues");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", self->_targetDispatchQueueId);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "objectForKeyedSubscript:", v15);
        v16 = (void *)objc_claimAutoreleasedReturnValue();

        v5 = v28;
        if (!v16)
          self->_targetDispatchQueueId = 0;
      }
    }
    else
    {
      self->_targetProcess = 0;

      v5 = 0;
      self->_targetProcessId = -1;
      self->_targetThreadId = 0;
      self->_targetDispatchQueueId = 0;
    }
  }

}

- (id)taskWithPid:(uint64_t)a3 orTid:(void *)a4 atTimestamp:
{
  id v7;
  void *v8;
  id v9;
  id result;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  _QWORD v20[4];
  id v21;
  uint8_t *v22;
  uint64_t v23;
  uint8_t buf[8];
  uint8_t *v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  id v29;

  v7 = a4;
  if (!a1)
  {
LABEL_14:

    return a1;
  }
  if ((_DWORD)a2 != -1 || a3)
  {
    objc_msgSend(a1, "startTime");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    if (v8 && objc_msgSend(v7, "lt:", v8))
    {
      v9 = v7;
      v7 = v8;
    }
    else
    {
      objc_msgSend(a1, "endTime");
      v9 = (id)objc_claimAutoreleasedReturnValue();
      if (v9 && objc_msgSend(v7, "gt:", v9))
      {
        v9 = v9;

        v7 = v9;
      }
    }

    if ((_DWORD)a2 == -1)
    {
      *(_QWORD *)buf = 0;
      v25 = buf;
      v26 = 0x3032000000;
      v27 = __Block_byref_object_copy__0;
      v28 = __Block_byref_object_dispose__0;
      v29 = 0;
      v20[0] = MEMORY[0x1E0C809B0];
      v20[1] = 3221225472;
      v20[2] = __47__SASampleStore_taskWithPid_orTid_atTimestamp___block_invoke;
      v20[3] = &unk_1E7146E90;
      v23 = a3;
      v21 = v7;
      v22 = buf;
      objc_msgSend(a1, "enumerateTasks:", v20);
      a1 = *((id *)v25 + 5);

      _Block_object_dispose(buf, 8);
    }
    else
    {
      -[SASampleStore taskWithPid:atTimestamp:]((uint64_t)a1, a2, v7);
      a1 = (id)objc_claimAutoreleasedReturnValue();
    }

    goto LABEL_14;
  }
  v11 = *__error();
  _sa_logt();
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_ERROR, "neither pid nor tid provided", buf, 2u);
  }

  *__error() = v11;
  _SASetCrashLogMessage(1863, "neither pid nor tid provided", v13, v14, v15, v16, v17, v18, v19);
  result = (id)_os_crash();
  __break(1u);
  return result;
}

- (id)lastTaskWithPid:(uint64_t)a3 orTid:
{
  id v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[6];
  uint8_t buf[8];
  uint8_t *v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t, uint64_t);
  void (*v18)(uint64_t);
  id v19;

  if (!a1)
    return 0;
  if ((_DWORD)a2 == -1 && !a3)
  {
    v5 = *__error();
    _sa_logt();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v6, OS_LOG_TYPE_ERROR, "neither pid nor tid provided", buf, 2u);
    }

    *__error() = v5;
    _SASetCrashLogMessage(1894, "neither pid nor tid provided", v7, v8, v9, v10, v11, v12, v13[0]);
    _os_crash();
    __break(1u);
    return 0;
  }
  if ((_DWORD)a2 == -1)
  {
    *(_QWORD *)buf = 0;
    v15 = buf;
    v16 = 0x3032000000;
    v17 = __Block_byref_object_copy__0;
    v18 = __Block_byref_object_dispose__0;
    v19 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __39__SASampleStore_lastTaskWithPid_orTid___block_invoke;
    v13[3] = &unk_1E7146EB8;
    v13[4] = buf;
    v13[5] = a3;
    objc_msgSend(a1, "enumerateTasks:", v13);
    v4 = *((id *)v15 + 5);
    _Block_object_dispose(buf, 8);

    return v4;
  }
  else
  {
    -[SASampleStore lastTaskWithPid:](a1, a2);
    return (id)objc_claimAutoreleasedReturnValue();
  }
}

- (id)taskWithPid:(void *)a3 atTimestamp:
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  uint64_t v11;
  void *i;
  void *v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = *(void **)(a1 + 16);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKeyedSubscript:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v9 = v8;
  v10 = (id)objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v10)
  {
    v11 = *(_QWORD *)v16;
    while (2)
    {
      for (i = 0; i != v10; i = (char *)i + 1)
      {
        if (*(_QWORD *)v16 != v11)
          objc_enumerationMutation(v9);
        v13 = *(void **)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)i);
        if ((-[SATask isAliveAtTimestamp:](v13, v5) & 1) != 0)
        {
          v10 = v13;
          goto LABEL_11;
        }
      }
      v10 = (id)objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
      if (v10)
        continue;
      break;
    }
  }
LABEL_11:

  return v10;
}

- (NSString)targetProcessName
{
  return -[SATask name](self->_targetProcess, "name");
}

- (NSString)targetProcessAbsolutePath
{
  void *v2;
  id v3;

  -[SATask mainBinaryPath](self->_targetProcess, "mainBinaryPath");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v2, "isAbsolutePath"))
    v3 = v2;
  else
    v3 = 0;

  return (NSString *)v3;
}

- (NSString)targetProcessBundleName
{
  return -[SATask bundleName](self->_targetProcess, "bundleName");
}

- (NSString)targetProcessBundleVersion
{
  return -[SATask bundleVersion](self->_targetProcess, "bundleVersion");
}

- (NSString)targetProcessBundleShortVersion
{
  return -[SATask bundleShortVersion](self->_targetProcess, "bundleShortVersion");
}

- (NSString)targetProcessBundleBuildVersion
{
  return -[SATask bundleBuildVersion](self->_targetProcess, "bundleBuildVersion");
}

- (NSString)targetProcessBundleProjectName
{
  return -[SATask bundleProjectName](self->_targetProcess, "bundleProjectName");
}

- (NSString)targetProcessBundleSourceVersion
{
  return -[SATask bundleSourceVersion](self->_targetProcess, "bundleSourceVersion");
}

- (NSString)targetProcessBundleProductBuildVersion
{
  return -[SATask bundleProductBuildVersion](self->_targetProcess, "bundleProductBuildVersion");
}

- (NSString)targetProcessBundleId
{
  return -[SATask bundleIdentifier](self->_targetProcess, "bundleIdentifier");
}

- (NSString)targetProcessCommerceAppID
{
  return (NSString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%llu"), -[SATask adamID](self->_targetProcess, "adamID"));
}

- (NSString)targetProcessCommerceExternalID
{
  return -[SATask installerVersionID](self->_targetProcess, "installerVersionID");
}

- (NSString)targetProcessVendorID
{
  return -[SATask vendorID](self->_targetProcess, "vendorID");
}

- (BOOL)cacheLoadInfoForProcess:(int)a3
{
  void *v4;
  void *v5;
  unint64_t dataGatheringOptions;
  void *v7;
  char v8;

  -[SASampleStore lastTaskWithPid:](self, *(uint64_t *)&a3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (v4 && (dataGatheringOptions = self->_dataGatheringOptions, (dataGatheringOptions & 2) != 0))
  {
    v8 = -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v4, dataGatheringOptions, self->_additionalCSSymbolicatorFlags);
  }
  else
  {
    objc_msgSend(v4, "binaryLoadInfos");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = objc_msgSend(v7, "count") != 0;

  }
  return v8;
}

- (void)addAuxiliaryData:(id)a3
{
  _QWORD *v4;
  const char *v5;
  const char *v6;
  id v7;
  _QWORD *v8;
  SAMountStatusTracker *mountStatusTracker;
  id Property;
  _QWORD *selfa;

  v4 = a3;
  selfa = v4;
  if (v4)
  {
    v7 = objc_getProperty(v4, v5, 8, 1);
    if (v7)
      -[NSMutableArray addObject:](self->_fanSpeeds, "addObject:", v7);
    v8 = (_QWORD *)selfa[2];
    if (v8)
    {
      mountStatusTracker = self->_mountStatusTracker;
      Property = objc_getProperty(selfa, v6, 24, 1);
      -[SAMountStatusTracker addMountStatus:forTimestamp:]((uint64_t)mountStatusTracker, v8, Property);
    }
  }
  else
  {
    v7 = 0;
  }

}

- (void)startingSamplingLiveSystem
{
  if (self)
  {
    if (self->_lastWakeTime == 0.0)
      self->_lastWakeTime = -[SASampleStore _getLastWakeTime]((uint64_t)self);
  }
}

- (void)enumerateTasksWithLiveness:(uint64_t)a1
{
  id v3;
  void *v4;
  id v5;
  _QWORD v6[5];
  id v7;

  v3 = a2;
  if (a1)
  {
    v4 = *(void **)(a1 + 16);
    v6[1] = 3221225472;
    v6[2] = __44__SASampleStore_enumerateTasksWithLiveness___block_invoke;
    v6[3] = &unk_1E7146CE0;
    v6[4] = a1;
    v5 = v3;
    v6[0] = MEMORY[0x1E0C809B0];
    v7 = v3;
    objc_msgSend(v4, "enumerateKeysAndObjectsUsingBlock:", v6);

    v3 = v5;
  }

}

void __44__SASampleStore_enumerateTasksWithLiveness___block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 408);
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  objc_msgSend(a3, "reverseObjectEnumerator", 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v6)
  {
    v8 = v6;
    v9 = *(_QWORD *)v13;
    v10 = (v4 >> 1) & 1;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v13 != v9)
          objc_enumerationMutation(v5);
        if ((v10 & 1) != 0 && (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 352) & 4) != 0)
          -[SATask isFromCurrentBootCycle](*(id *)(*((_QWORD *)&v12 + 1) + 8 * i), v7);
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        LOBYTE(v10) = 0;
      }
      v8 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      LOBYTE(v10) = 0;
    }
    while (v8);
  }

}

- (id)fixupAllFrames
{
  id *v1;
  id v2;
  uint64_t v3;
  double v4;
  int v5;
  uint64_t *v6;
  int v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  int v14;
  NSObject *v15;
  uint64_t v17;
  double v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _QWORD v23[5];
  id v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  double v33;
  _BYTE v34[128];
  uint64_t v35;

  v1 = a1;
  v35 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = objc_alloc_init(MEMORY[0x1E0C99E20]);
    v26 = 0;
    v27 = &v26;
    v28 = 0x2020000000;
    v29 = 0;
    v3 = mach_absolute_time();
    v4 = SASecondsFromMachTimeUsingLiveTimebase(v3);
    v5 = 0;
    v6 = v27;
    do
    {
      v7 = v5;
      *((_BYTE *)v6 + 24) = 0;
      v23[0] = MEMORY[0x1E0C809B0];
      v23[1] = 3221225472;
      v23[2] = __31__SASampleStore_fixupAllFrames__block_invoke;
      v23[3] = &unk_1E7146D08;
      v23[4] = v1;
      v8 = v2;
      v24 = v8;
      v25 = &v26;
      -[SASampleStore enumerateTasksWithLiveness:]((uint64_t)v1, v23);
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v9 = v1[15];
      v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v19, v34, 16);
      if (v10)
      {
        v11 = *(_QWORD *)v20;
        do
        {
          for (i = 0; i != v10; ++i)
          {
            if (*(_QWORD *)v20 != v11)
              objc_enumerationMutation(v9);
            v13 = *(_QWORD *)(*((_QWORD *)&v19 + 1) + 8 * i);
            buf[0] = 0;
            -[SAExclave fixupFrameInstructionsWithNewInstructions:foundNewBinaryInfo:](v13, v8, buf);
            if (buf[0])
              *((_BYTE *)v27 + 24) = 1;
          }
          v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v19, v34, 16);
        }
        while (v10);
      }

      v5 = v7 + 1;
      v6 = v27;
    }
    while (*((_BYTE *)v27 + 24));
    if (v7)
    {
      v14 = *__error();
      _sa_logt();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v17 = mach_absolute_time();
        v18 = SASecondsFromMachTimeUsingLiveTimebase(v17);
        *(_DWORD *)buf = 67109376;
        v31 = v7 + 1;
        v32 = 2048;
        v33 = v18 - v4;
        _os_log_debug_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_DEBUG, "Iterated frame fixup %d times (in %.3fs)", buf, 0x12u);
      }

      *__error() = v14;
    }
    v1 = (id *)objc_msgSend(v8, "copy");
    _Block_object_dispose(&v26, 8);

  }
  return v1;
}

void __31__SASampleStore_fixupAllFrames__block_invoke(uint64_t a1, id *a2, int a3)
{
  char v4;

  v4 = 0;
  -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:](a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 408), a3, &v4, *(void **)(a1 + 40), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 328));
  if (v4)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
}

- (void)resampleTruncatedBacktraces
{
  uint64_t v2;
  double v3;
  SAFrameIterator *v4;
  void *v5;
  SAFrameIterator *v6;
  uint64_t v7;
  double v8;
  int v9;
  NSObject *v10;
  int v11;
  int v12;
  _QWORD v13[4];
  SAFrameIterator *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  double v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1 && (~*(_DWORD *)(a1 + 408) & 0x402) == 0 && !*(_BYTE *)(a1 + 312))
  {
    *(_BYTE *)(a1 + 312) = 1;
    v2 = mach_absolute_time();
    v3 = SASecondsFromMachTimeUsingLiveTimebase(v2);
    v22 = 0;
    v23 = &v22;
    v24 = 0x2020000000;
    v25 = 0;
    v18 = 0;
    v19 = &v18;
    v20 = 0x2020000000;
    v21 = 0;
    v4 = objc_alloc_init(SAFrameIterator);
    -[SAFrameIterator setBacktracer:](v4, "setBacktracer:", 3);
    objc_msgSend((id)a1, "tasksByPid");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __44__SASampleStore_resampleTruncatedBacktraces__block_invoke;
    v13[3] = &unk_1E7147160;
    v6 = v4;
    v14 = v6;
    v15 = a1;
    v16 = &v18;
    v17 = &v22;
    objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v13);

    v7 = mach_absolute_time();
    v8 = SASecondsFromMachTimeUsingLiveTimebase(v7);
    v9 = *__error();
    _sa_logt();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v11 = *((_DWORD *)v23 + 6);
      v12 = *((_DWORD *)v19 + 6);
      *(_DWORD *)buf = 67109632;
      v27 = v11;
      v28 = 1024;
      v29 = v12;
      v30 = 2048;
      v31 = v8 - v3;
      _os_log_debug_impl(&dword_1B9BE0000, v10, OS_LOG_TYPE_DEBUG, "Resampling %d tasks (%d threads) took %.3fs", buf, 0x18u);
    }

    *__error() = v9;
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }
}

void __28__SASampleStore_postprocess__block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  -[SATask postprocessWithDataGatheringOptions:mightBeAlive:machineArchitecture:dataSource:spindumpArchitecture:spindumpSharedCache:additionalCSSymbolicatorFlags:](a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 408), a3, *(void **)(*(_QWORD *)(a1 + 32) + 192), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 352), *(_QWORD *)(a1 + 48), *(void **)(a1 + 40), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 328));
}

void __28__SASampleStore_postprocess__block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  __int128 v5;
  id v6;
  _QWORD v7[4];
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  objc_msgSend(a2, "threads");
  v6 = (id)objc_claimAutoreleasedReturnValue();
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __28__SASampleStore_postprocess__block_invoke_3;
  v7[3] = &unk_1E7146D58;
  v5 = *(_OWORD *)(a1 + 48);
  v8 = *(_OWORD *)(a1 + 32);
  v9 = v5;
  v10 = a3;
  objc_msgSend(v6, "enumerateKeysAndObjectsUsingBlock:", v7);

}

void __28__SASampleStore_postprocess__block_invoke_3(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  void *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  objc_msgSend(a3, "threadStates", 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v13;
    while (2)
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v13 != v9)
          objc_enumerationMutation(v6);
        v11 = *(void **)(*((_QWORD *)&v12 + 1) + 8 * i);
        if (objc_msgSend(v11, "originPid") != -1)
        {
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
          if ((int)objc_msgSend(v11, "originPid") >= 1)
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
        }
        if (objc_msgSend(v11, "proximatePid") != -1)
        {
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
          if ((int)objc_msgSend(v11, "proximatePid") >= 1)
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
        }
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24)
          && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
        {
          *a4 = 1;
          **(_BYTE **)(a1 + 64) = 1;
          goto LABEL_18;
        }
      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      if (v8)
        continue;
      break;
    }
  }
LABEL_18:

}

void __28__SASampleStore_postprocess__block_invoke_154(uint64_t a1, void *a2)
{
  id v3;
  _QWORD v4[4];
  __int16 v5;

  objc_msgSend(a2, "threads");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __28__SASampleStore_postprocess__block_invoke_2_155;
  v4[3] = &__block_descriptor_34_e35_v32__0__NSNumber_8__SAThread_16_B24l;
  v5 = *(_WORD *)(a1 + 32);
  objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);

}

void __28__SASampleStore_postprocess__block_invoke_2_155(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  objc_msgSend(a3, "threadStates", 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v12;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v12 != v7)
          objc_enumerationMutation(v4);
        v9 = *(_QWORD *)(*((_QWORD *)&v11 + 1) + 8 * v8);
        if (*(_BYTE *)(a1 + 32))
        {
          if (!v9)
            goto LABEL_14;
          *(_DWORD *)(v9 + 28) = -1;
        }
        if (*(_BYTE *)(a1 + 33))
          v10 = v9 == 0;
        else
          v10 = 1;
        if (!v10)
          *(_DWORD *)(v9 + 32) = -1;
LABEL_14:
        ++v8;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v6);
  }

}

- (double)_getLastWakeTime
{
  int WakeTime;
  int v2;
  int v4;
  NSObject *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    WakeTime = IOPMGetLastWakeTime();
    if (WakeTime == -536870184)
      return -1.0;
    v2 = WakeTime;
    if (!WakeTime)
      return 0.0;
    v4 = *__error();
    _sa_logt();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v7 = v2;
      _os_log_error_impl(&dword_1B9BE0000, v5, OS_LOG_TYPE_ERROR, "Unable to get last wake time: %d", buf, 8u);
    }

    *__error() = v4;
  }
  return 0.0;
}

void __28__SASampleStore_postprocess__block_invoke_3_158(uint64_t a1, void *a2)
{
  double v3;
  double v4;
  void *v5;
  id v6;

  v6 = a2;
  objc_msgSend(v6, "wallTime");
  if (v3 == 0.0 || (objc_msgSend(v6, "wallTime"), v4 >= *(double *)(a1 + 48)))
  {
    v5 = *(void **)(a1 + 32);
    if (!v5 || objc_msgSend(v5, "le:", v6))
      objc_msgSend(v6, "guessMissingTimesBasedOnTimestamp:", *(_QWORD *)(a1 + 40));
  }

}

- (void)iterateAllTimestamps:(uint64_t)a1
{
  void (**v3)(_QWORD);
  void (**v4)(_QWORD);
  void *v5;
  void *v6;
  void *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t j;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t k;
  void *v25;
  const char *v26;
  uint64_t v27;
  void *v28;
  id v29;
  void *v30;
  SEL v31;
  id Property;
  id v33;
  void *v34;
  const char *v35;
  id v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t m;
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t n;
  void *v49;
  void *v50;
  uint64_t v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t ii;
  void *v57;
  void *v58;
  void *v59;
  id v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t jj;
  void *v65;
  id v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t kk;
  void *v71;
  id v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t mm;
  void *v77;
  void *v78;
  void *v79;
  void (**v80)(_QWORD);
  uint64_t nn;
  void *v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t i1;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t i2;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  uint64_t v103;
  id obj;
  id v105;
  id v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  _QWORD v123[4];
  id v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  _BYTE v165[128];
  _BYTE v166[128];
  _BYTE v167[128];
  _BYTE v168[128];
  _BYTE v169[128];
  _BYTE v170[128];
  _BYTE v171[128];
  _BYTE v172[128];
  _BYTE v173[128];
  _BYTE v174[128];
  _BYTE v175[128];
  _BYTE v176[128];
  _BYTE v177[128];
  uint64_t v178;

  v178 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 40))
      v3[2](v3);
    if (*(_QWORD *)(a1 + 48))
      v4[2](v4);
    v5 = *(void **)(a1 + 736);
    if (v5)
    {
      objc_msgSend(v5, "startTime");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v6);

      objc_msgSend(*(id *)(a1 + 736), "endTime");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v7);

    }
    v163 = 0u;
    v164 = 0u;
    v161 = 0u;
    v162 = 0u;
    v103 = a1;
    v8 = *(id *)(a1 + 24);
    v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v161, v177, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v162;
      do
      {
        for (i = 0; i != v10; ++i)
        {
          if (*(_QWORD *)v162 != v11)
            objc_enumerationMutation(v8);
          ((void (*)(void (**)(_QWORD), _QWORD))v4[2])(v4, *(_QWORD *)(*((_QWORD *)&v161 + 1) + 8 * i));
        }
        v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v161, v177, 16);
      }
      while (v10);
    }

    v159 = 0u;
    v160 = 0u;
    v157 = 0u;
    v158 = 0u;
    v13 = *(id *)(v103 + 56);
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v157, v176, 16);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)v158;
      do
      {
        for (j = 0; j != v15; ++j)
        {
          if (*(_QWORD *)v158 != v16)
            objc_enumerationMutation(v13);
          v18 = *(void **)(*((_QWORD *)&v157 + 1) + 8 * j);
          objc_msgSend(v18, "hidEventTimestamp");
          v19 = (void *)objc_claimAutoreleasedReturnValue();
          ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v19);

          v155 = 0u;
          v156 = 0u;
          v153 = 0u;
          v154 = 0u;
          objc_msgSend(v18, "steps");
          v20 = (void *)objc_claimAutoreleasedReturnValue();
          v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v153, v175, 16);
          if (v21)
          {
            v22 = v21;
            v23 = *(_QWORD *)v154;
            do
            {
              for (k = 0; k != v22; ++k)
              {
                if (*(_QWORD *)v154 != v23)
                  objc_enumerationMutation(v20);
                objc_msgSend(*(id *)(*((_QWORD *)&v153 + 1) + 8 * k), "timestamp");
                v25 = (void *)objc_claimAutoreleasedReturnValue();
                ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v25);

              }
              v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v153, v175, 16);
            }
            while (v22);
          }

        }
        v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v157, v176, 16);
      }
      while (v15);
    }

    v151 = 0u;
    v152 = 0u;
    v149 = 0u;
    v150 = 0u;
    obj = *(id *)(v103 + 64);
    v107 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v149, v174, 16);
    if (v107)
    {
      v105 = *(id *)v150;
      do
      {
        v27 = 0;
        do
        {
          if (*(id *)v150 != v105)
            objc_enumerationMutation(obj);
          v28 = *(void **)(*((_QWORD *)&v149 + 1) + 8 * v27);
          if (v28)
          {
            v29 = objc_getProperty(*(id *)(*((_QWORD *)&v149 + 1) + 8 * v27), v26, 32, 1);
            objc_msgSend(v29, "startTime");
            v30 = (void *)objc_claimAutoreleasedReturnValue();
            ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v30);

            Property = objc_getProperty(v28, v31, 32, 1);
          }
          else
          {
            objc_msgSend(0, "startTime");
            v50 = (void *)objc_claimAutoreleasedReturnValue();
            ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v50);

            Property = 0;
          }
          v33 = Property;
          objc_msgSend(v33, "endTime");
          v34 = (void *)objc_claimAutoreleasedReturnValue();
          ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v34);

          v147 = 0u;
          v148 = 0u;
          v145 = 0u;
          v146 = 0u;
          v109 = v27;
          if (v28)
            v36 = objc_getProperty(v28, v35, 8, 1);
          else
            v36 = 0;
          v37 = v36;
          v38 = objc_msgSend(v37, "countByEnumeratingWithState:objects:count:", &v145, v173, 16);
          if (v38)
          {
            v39 = v38;
            v40 = *(_QWORD *)v146;
            do
            {
              for (m = 0; m != v39; ++m)
              {
                if (*(_QWORD *)v146 != v40)
                  objc_enumerationMutation(v37);
                v42 = *(void **)(*((_QWORD *)&v145 + 1) + 8 * m);
                objc_msgSend(v42, "hidEventTimestamp");
                v43 = (void *)objc_claimAutoreleasedReturnValue();
                ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v43);

                v143 = 0u;
                v144 = 0u;
                v141 = 0u;
                v142 = 0u;
                objc_msgSend(v42, "steps");
                v44 = (void *)objc_claimAutoreleasedReturnValue();
                v45 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v141, v172, 16);
                if (v45)
                {
                  v46 = v45;
                  v47 = *(_QWORD *)v142;
                  do
                  {
                    for (n = 0; n != v46; ++n)
                    {
                      if (*(_QWORD *)v142 != v47)
                        objc_enumerationMutation(v44);
                      objc_msgSend(*(id *)(*((_QWORD *)&v141 + 1) + 8 * n), "timestamp");
                      v49 = (void *)objc_claimAutoreleasedReturnValue();
                      ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v49);

                    }
                    v46 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v141, v172, 16);
                  }
                  while (v46);
                }

              }
              v39 = objc_msgSend(v37, "countByEnumeratingWithState:objects:count:", &v145, v173, 16);
            }
            while (v39);
          }

          v27 = v109 + 1;
        }
        while (v109 + 1 != v107);
        v51 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v149, v174, 16);
        v107 = v51;
      }
      while (v51);
    }

    v139 = 0u;
    v140 = 0u;
    v137 = 0u;
    v138 = 0u;
    v52 = *(id *)(v103 + 88);
    v53 = objc_msgSend(v52, "countByEnumeratingWithState:objects:count:", &v137, v171, 16);
    if (v53)
    {
      v54 = v53;
      v55 = *(_QWORD *)v138;
      do
      {
        for (ii = 0; ii != v54; ++ii)
        {
          if (*(_QWORD *)v138 != v55)
            objc_enumerationMutation(v52);
          v57 = *(void **)(*((_QWORD *)&v137 + 1) + 8 * ii);
          objc_msgSend(v57, "startTimestamp");
          v58 = (void *)objc_claimAutoreleasedReturnValue();
          ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v58);

          objc_msgSend(v57, "endTimestamp");
          v59 = (void *)objc_claimAutoreleasedReturnValue();
          ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v59);

        }
        v54 = objc_msgSend(v52, "countByEnumeratingWithState:objects:count:", &v137, v171, 16);
      }
      while (v54);
    }

    v135 = 0u;
    v136 = 0u;
    v133 = 0u;
    v134 = 0u;
    v60 = *(id *)(v103 + 96);
    v61 = objc_msgSend(v60, "countByEnumeratingWithState:objects:count:", &v133, v170, 16);
    if (v61)
    {
      v62 = v61;
      v63 = *(_QWORD *)v134;
      do
      {
        for (jj = 0; jj != v62; ++jj)
        {
          if (*(_QWORD *)v134 != v63)
            objc_enumerationMutation(v60);
          objc_msgSend(*(id *)(*((_QWORD *)&v133 + 1) + 8 * jj), "timestamp");
          v65 = (void *)objc_claimAutoreleasedReturnValue();
          ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v65);

        }
        v62 = objc_msgSend(v60, "countByEnumeratingWithState:objects:count:", &v133, v170, 16);
      }
      while (v62);
    }

    -[SAMountStatusTracker iterateAllTimestamps:](*(_QWORD *)(v103 + 400), v4);
    v131 = 0u;
    v132 = 0u;
    v129 = 0u;
    v130 = 0u;
    v66 = *(id *)(v103 + 72);
    v67 = objc_msgSend(v66, "countByEnumeratingWithState:objects:count:", &v129, v169, 16);
    if (v67)
    {
      v68 = v67;
      v69 = *(_QWORD *)v130;
      do
      {
        for (kk = 0; kk != v68; ++kk)
        {
          if (*(_QWORD *)v130 != v69)
            objc_enumerationMutation(v66);
          objc_msgSend(*(id *)(*((_QWORD *)&v129 + 1) + 8 * kk), "timestamp");
          v71 = (void *)objc_claimAutoreleasedReturnValue();
          ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v71);

        }
        v68 = objc_msgSend(v66, "countByEnumeratingWithState:objects:count:", &v129, v169, 16);
      }
      while (v68);
    }

    v127 = 0u;
    v128 = 0u;
    v125 = 0u;
    v126 = 0u;
    v72 = *(id *)(v103 + 80);
    v73 = objc_msgSend(v72, "countByEnumeratingWithState:objects:count:", &v125, v168, 16);
    if (v73)
    {
      v74 = v73;
      v75 = *(_QWORD *)v126;
      do
      {
        for (mm = 0; mm != v74; ++mm)
        {
          if (*(_QWORD *)v126 != v75)
            objc_enumerationMutation(v72);
          v77 = *(void **)(*((_QWORD *)&v125 + 1) + 8 * mm);
          objc_msgSend(v77, "timestamp");
          v78 = (void *)objc_claimAutoreleasedReturnValue();

          if (v78)
          {
            objc_msgSend(v77, "timestamp");
            v79 = (void *)objc_claimAutoreleasedReturnValue();
            ((void (*)(void (**)(_QWORD), void *))v4[2])(v4, v79);

          }
        }
        v74 = objc_msgSend(v72, "countByEnumeratingWithState:objects:count:", &v125, v168, 16);
      }
      while (v74);
    }

    if (*(_QWORD *)(v103 + 424))
      v4[2](v4);
    if (*(_QWORD *)(v103 + 432))
      v4[2](v4);
    v123[0] = MEMORY[0x1E0C809B0];
    v123[1] = 3221225472;
    v123[2] = __38__SASampleStore_iterateAllTimestamps___block_invoke;
    v123[3] = &unk_1E71475C0;
    v80 = v4;
    v124 = v80;
    objc_msgSend((id)v103, "enumerateTasks:", v123);
    v121 = 0u;
    v122 = 0u;
    v119 = 0u;
    v120 = 0u;
    objc_msgSend((id)v103, "models");
    v106 = (id)objc_claimAutoreleasedReturnValue();
    v110 = objc_msgSend(v106, "countByEnumeratingWithState:objects:count:", &v119, v167, 16);
    if (v110)
    {
      v108 = *(_QWORD *)v120;
      do
      {
        for (nn = 0; nn != v110; ++nn)
        {
          if (*(_QWORD *)v120 != v108)
            objc_enumerationMutation(v106);
          v82 = *(void **)(*((_QWORD *)&v119 + 1) + 8 * nn);
          v115 = 0u;
          v116 = 0u;
          v117 = 0u;
          v118 = 0u;
          objc_msgSend(v82, "loadedChanges");
          v83 = (void *)objc_claimAutoreleasedReturnValue();
          v84 = objc_msgSend(v83, "countByEnumeratingWithState:objects:count:", &v115, v166, 16);
          if (v84)
          {
            v85 = v84;
            v86 = *(_QWORD *)v116;
            do
            {
              for (i1 = 0; i1 != v85; ++i1)
              {
                if (*(_QWORD *)v116 != v86)
                  objc_enumerationMutation(v83);
                v88 = *(void **)(*((_QWORD *)&v115 + 1) + 8 * i1);
                objc_msgSend(v88, "timestamp");
                v89 = (void *)objc_claimAutoreleasedReturnValue();

                if (v89)
                {
                  objc_msgSend(v88, "timestamp");
                  v90 = (void *)objc_claimAutoreleasedReturnValue();
                  ((void (*)(void (**)(_QWORD), void *))v80[2])(v80, v90);

                }
                objc_msgSend(v88, "endTime");
                v91 = (void *)objc_claimAutoreleasedReturnValue();

                if (v91)
                {
                  objc_msgSend(v88, "endTime");
                  v92 = (void *)objc_claimAutoreleasedReturnValue();
                  ((void (*)(void (**)(_QWORD), void *))v80[2])(v80, v92);

                }
              }
              v85 = objc_msgSend(v83, "countByEnumeratingWithState:objects:count:", &v115, v166, 16);
            }
            while (v85);
          }

          v113 = 0u;
          v114 = 0u;
          v111 = 0u;
          v112 = 0u;
          objc_msgSend(v82, "executions");
          v93 = (void *)objc_claimAutoreleasedReturnValue();
          v94 = objc_msgSend(v93, "countByEnumeratingWithState:objects:count:", &v111, v165, 16);
          if (v94)
          {
            v95 = v94;
            v96 = *(_QWORD *)v112;
            do
            {
              for (i2 = 0; i2 != v95; ++i2)
              {
                if (*(_QWORD *)v112 != v96)
                  objc_enumerationMutation(v93);
                v98 = *(void **)(*((_QWORD *)&v111 + 1) + 8 * i2);
                objc_msgSend(v98, "startTime");
                v99 = (void *)objc_claimAutoreleasedReturnValue();

                if (v99)
                {
                  objc_msgSend(v98, "startTime");
                  v100 = (void *)objc_claimAutoreleasedReturnValue();
                  ((void (*)(void (**)(_QWORD), void *))v80[2])(v80, v100);

                }
                objc_msgSend(v98, "endTime");
                v101 = (void *)objc_claimAutoreleasedReturnValue();

                if (v101)
                {
                  objc_msgSend(v98, "endTime");
                  v102 = (void *)objc_claimAutoreleasedReturnValue();
                  ((void (*)(void (**)(_QWORD), void *))v80[2])(v80, v102);

                }
              }
              v95 = objc_msgSend(v93, "countByEnumeratingWithState:objects:count:", &v111, v165, 16);
            }
            while (v95);
          }

        }
        v110 = objc_msgSend(v106, "countByEnumeratingWithState:objects:count:", &v119, v167, 16);
      }
      while (v110);
    }

  }
}

- (int)gatherHWPageSize
{
  int v1;
  NSObject *v2;
  int v3;
  int *v4;
  char *v5;
  size_t v6;
  uint8_t buf[4];
  int v8;
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    if (!result[86])
    {
      v6 = 4;
      result = (int *)sysctlbyname("hw.pagesize", result + 86, &v6, 0, 0);
      if ((_DWORD)result)
      {
        v1 = *__error();
        _sa_logt();
        v2 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        {
          v3 = *__error();
          v4 = __error();
          v5 = strerror(*v4);
          *(_DWORD *)buf = 67109378;
          v8 = v3;
          v9 = 2080;
          v10 = v5;
          _os_log_error_impl(&dword_1B9BE0000, v2, OS_LOG_TYPE_ERROR, "Unable to get hw.pagesize: %d %s", buf, 0x12u);
        }

        result = __error();
        *result = v1;
      }
    }
  }
  return result;
}

- (int)gatherVMPageSize
{
  int v1;
  NSObject *v2;
  int v3;
  int *v4;
  char *v5;
  size_t v6;
  uint8_t buf[4];
  int v8;
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    if (!result[87])
    {
      v6 = 4;
      result = (int *)sysctlbyname("vm.pagesize", result + 87, &v6, 0, 0);
      if ((_DWORD)result)
      {
        v1 = *__error();
        _sa_logt();
        v2 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        {
          v3 = *__error();
          v4 = __error();
          v5 = strerror(*v4);
          *(_DWORD *)buf = 67109378;
          v8 = v3;
          v9 = 2080;
          v10 = v5;
          _os_log_error_impl(&dword_1B9BE0000, v2, OS_LOG_TYPE_ERROR, "Unable to get vm.pagesize: %d %s", buf, 0x12u);
        }

        result = __error();
        *result = v1;
      }
    }
  }
  return result;
}

uint64_t __28__SASampleStore_postprocess__block_invoke_4(uint64_t a1, void *a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;

  v4 = a3;
  objc_msgSend(a2, "startTimestamp");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "startTimestamp");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v7 = objc_msgSend(v5, "compare:", v6);
  return v7;
}

uint64_t __28__SASampleStore_postprocess__block_invoke_5(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "sortUsingComparator:", &__block_literal_global_164);
}

uint64_t __28__SASampleStore_postprocess__block_invoke_6(uint64_t a1, void *a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;

  v4 = a3;
  objc_msgSend(a2, "startTimestamp");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "startTimestamp");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v7 = objc_msgSend(v5, "compare:", v6);
  return v7;
}

- (void)task:(void *)a3 exitedAtTimestamp:
{
  id v5;
  void *v6;
  const char *v7;
  void *v8;
  int v9;
  NSObject *v10;
  id v11;
  uint64_t v12;
  void *v13;
  id v14;
  uint64_t v15;
  id v16;
  id v17;
  char v18;
  void *v19;
  id v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  id self;
  _QWORD v29[4];
  id v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  self = a2;
  v5 = a3;
  if (a1)
  {
    objc_msgSend(self, "exitTimestamp");
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      v9 = *__error();
      _sa_logt();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(self, "debugDescription");
        v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v12 = objc_msgSend(v11, "UTF8String");
        objc_msgSend(self, "exitTimestamp");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "debugDescription");
        v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v15 = objc_msgSend(v14, "UTF8String");
        objc_msgSend(v5, "debugDescription");
        v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        *(_DWORD *)buf = 136315650;
        v32 = v12;
        v33 = 2080;
        v34 = v15;
        v35 = 2080;
        v36 = objc_msgSend(v16, "UTF8String");
        _os_log_error_impl(&dword_1B9BE0000, v10, OS_LOG_TYPE_ERROR, "%s exited at %s, updating to %s", buf, 0x20u);

      }
      *__error() = v9;
      objc_msgSend(self, "debugDescription");
      v17 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v18 = objc_msgSend(v17, "UTF8String");
      objc_msgSend(self, "exitTimestamp");
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "debugDescription");
      v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v20, "UTF8String");
      objc_msgSend(v5, "debugDescription");
      v21 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v21, "UTF8String");
      _SASetCrashLogMessage(1308, "%s exited at %s, updating to %s", v22, v23, v24, v25, v26, v27, v18);

      _os_crash();
      __break(1u);
    }
    if (self)
      objc_setProperty_atomic(self, v7, v5, 232);
    if (*(_QWORD *)(a1 + 360) >= 2uLL)
    {
      objc_msgSend(self, "threads");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v29[0] = MEMORY[0x1E0C809B0];
      v29[1] = 3221225472;
      v29[2] = __40__SASampleStore_task_exitedAtTimestamp___block_invoke;
      v29[3] = &unk_1E7147888;
      v30 = v5;
      objc_msgSend(v8, "enumerateKeysAndObjectsUsingBlock:", v29);

    }
  }

}

void __40__SASampleStore_task_exitedAtTimestamp___block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  const char *v5;
  void *v6;
  id self;

  self = a3;
  objc_msgSend(self, "exitTimestamp");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = self;
  if (self && !v4)
  {
    objc_setProperty_atomic(self, v5, *(id *)(a1 + 32), 40);
    v6 = self;
  }

}

- (void)_backfillPidStartTimestamp:(void *)a1 toPreviousTasksEnumerator:(void *)a2 execTimestampOfNextTask:(void *)a3
{
  id v5;
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  id Property;
  id v17;
  uint64_t v18;
  void *v19;
  void *v20;
  char v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v8 = v6;
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
  if (v9)
  {
    v11 = v9;
    v12 = *(_QWORD *)v26;
    do
    {
      v13 = 0;
      v14 = v7;
      do
      {
        if (*(_QWORD *)v26 != v12)
          objc_enumerationMutation(v8);
        v15 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * v13);
        if (v15)
          Property = objc_getProperty(*(id *)(*((_QWORD *)&v25 + 1) + 8 * v13), v10, 272, 1);
        else
          Property = 0;
        v17 = Property;

        if (v17)
          goto LABEL_19;
        objc_msgSend(v15, "exitTimestamp", (_QWORD)v25);
        v18 = objc_claimAutoreleasedReturnValue();
        if (!v18)
          goto LABEL_19;
        v19 = (void *)v18;
        objc_msgSend(v15, "exitTimestamp");
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = objc_msgSend(v20, "ne:", v14);

        if ((v21 & 1) != 0)
          goto LABEL_19;
        if (v15)
          objc_setProperty_atomic(v15, v22, v5, 272);
        objc_msgSend(v15, "execTimestamp");
        v23 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v23)
        {
LABEL_19:
          v7 = v14;
          goto LABEL_20;
        }
        objc_msgSend(v15, "execTimestamp");
        v7 = (id)objc_claimAutoreleasedReturnValue();

        ++v13;
        v14 = v7;
      }
      while (v11 != v13);
      v24 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
      v11 = v24;
    }
    while (v24);
  }
LABEL_20:

}

- (void)addNewImageInfos:(unsigned int)a3 numLoadInfos:(const char *)a4 name:(void *)a5 sharedCache:(uint64_t)a6 architecture:(void *)a7 toTask:
{
  id v13;
  _BYTE *v14;
  void *v15;
  const char *v16;
  int v17;
  NSObject *v18;
  void *v19;
  char v20;
  void *v21;
  void *v22;
  void *v23;
  _BYTE dest[12];
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v13 = a5;
  v14 = a7;
  objc_msgSend(v14, "sharedCache");
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v14 && v13 && !v15)
  {
    if ((v14[72] & 1) != 0)
    {
      v17 = *__error();
      _sa_logt();
      v18 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      {
        objc_msgSend(v13, "debugDescription");
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "debugDescription");
        *(_DWORD *)dest = 138412546;
        *(_QWORD *)&dest[4] = v23;
        v25 = 2112;
        v26 = objc_claimAutoreleasedReturnValue();
        v22 = (void *)v26;
        _os_log_fault_impl(&dword_1B9BE0000, v18, OS_LOG_TYPE_FAULT, "shared cache %@, though task %@ has no shared cache", dest, 0x16u);

      }
      *__error() = v17;
    }
    else
    {
      objc_setProperty_atomic(v14, v16, v13, 256);
    }
  }
  objc_msgSend(v14, "binaryLoadInfos");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v19, "count") < (unint64_t)a3)
    goto LABEL_10;
  if (!a3)
    goto LABEL_20;
  if (!v14)
  {
LABEL_10:

LABEL_14:
    if ((*(_BYTE *)(a1 + 408) & 2) != 0)
    {
      SAExecutablePath(objc_msgSend(v14, "pid"), a4);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v19 = 0;
    }
    _SABinaryCreateLoadInfoArrayFromDyldImageInfos(a2, a3, v19, 0, 0, 0);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    -[SATask addImageInfos:]((uint64_t)v14, v21);
    if (v14)
      v14[73] = 1;

LABEL_20:
    if (!v14)
      goto LABEL_23;
    goto LABEL_21;
  }
  v20 = v14[73];

  if ((v20 & 1) == 0)
    goto LABEL_14;
LABEL_21:
  objc_copyStruct(dest, v14 + 288, 8, 1, 0);
  if (!*(_QWORD *)dest)
  {
    *(_QWORD *)dest = a6;
    objc_copyStruct(v14 + 288, dest, 8, 1, 0);
  }
LABEL_23:

}

- (NSObject)_taskForPid:(uint64_t)a3 uniquePid:(char *)a4 name:(uint64_t)a5 pidStartTime:(NSObject *)a6 loadInfos:(unsigned int)a7 numLoadInfos:(char)a8 loadInfosIsPartial:(NSObject *)a9 textExecLoadInfos:(unsigned int)a10 numTextExecLoadInfos:(char)a11 textExecLoadInfosIsPartial:(uint64_t)a12 architecture:(void *)a13 timestamp:(void *)a14 sharedCache:(char)a15 needAOTInfo:
{
  NSObject *v20;
  char *v21;
  void *v22;
  void *v23;
  void *v24;
  NSObject *v25;
  NSObject *v26;
  void *v27;
  void *v28;
  void *v29;
  NSObject *v30;
  void *v31;
  char v32;
  void *v33;
  void *v34;
  void *v35;
  id v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  const char *v42;
  void *v43;
  char v44;
  unint64_t v45;
  id v46;
  id v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  SEL v52;
  void *v53;
  void *v54;
  void *v55;
  const char *v56;
  NSObject *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  NSObject *v61;
  const char *v62;
  SEL v63;
  id v64;
  const char *v65;
  void *v66;
  id v67;
  id v68;
  const char *v69;
  id v70;
  char *v71;
  id v72;
  void *v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  int v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  NSObject *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  id v97;
  uint64_t v98;
  id v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  id v103;
  uint64_t v104;
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  void *v109;
  id v110;
  id v111;
  id v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  NSObject *v120;
  void *v121;
  void *v122;
  void *v123;
  uint64_t v124;
  id v125;
  uint64_t v126;
  void *v127;
  void *v128;
  void *v129;
  char v130;
  id v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  void *v140;
  void *v141;
  uint64_t v142;
  void *v143;
  void *v144;
  void *v145;
  void *v146;
  void *v147;
  void *v148;
  uint64_t v149;
  void *v150;
  void *v151;
  void *v152;
  void *v153;
  NSObject *log;
  os_log_t loga;
  void *v156;
  id v157;
  char v158;
  void *v159;
  void *v160;
  void *v161;
  id v162;
  char *v163;
  char *newValue;
  id newValuea;
  id newValueb;
  void *v168;
  void *v169;
  void *v171;
  void *v172;
  id v174;
  int v175;
  uint8_t buf[4];
  _BYTE v177[24];
  __int16 v178;
  uint64_t v179;
  __int16 v180;
  uint64_t v181;
  __int16 v182;
  uint64_t v183;
  __int16 v184;
  uint64_t v185;
  __int16 v186;
  uint64_t v187;
  __int16 v188;
  uint64_t v189;
  __int16 v190;
  uint64_t v191;
  uint64_t v192;

  v20 = a9;
  v192 = *MEMORY[0x1E0C80C00];
  v21 = a13;
  v174 = a14;
  if (!a1)
  {
LABEL_90:
    v57 = 0;
    goto LABEL_73;
  }
  newValue = v21;
  if (a4)
  {
    if (*a4)
      v21 = a4;
    else
      v21 = 0;
  }
  else
  {
    v21 = 0;
  }
  v158 = a8;
  if (a3 != -1)
  {
    v163 = (char *)a2;
    v22 = (void *)*((_QWORD *)a1 + 1);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:");
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "objectForKeyedSubscript:", v23);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v24)
    {
      v26 = 0;
      v44 = 1;
      goto LABEL_42;
    }
    objc_msgSend(v24, "lastObject");
    v25 = objc_claimAutoreleasedReturnValue();
    v26 = v25;
    if ((_DWORD)v163 != -1)
    {
      v156 = v24;
      v27 = (void *)*((_QWORD *)a1 + 2);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "objectForKeyedSubscript:", v28);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v29, "lastObject");
      v30 = objc_claimAutoreleasedReturnValue();

      if (v30 == v26)
      {
LABEL_18:
        if (v26)
        {
          v24 = v156;
          a2 = (uint64_t)v163;
          goto LABEL_29;
        }
        v44 = 1;
        v24 = v156;
LABEL_42:
        a2 = (uint64_t)v163;
        goto LABEL_48;
      }
      if (-[NSObject pid](v26, "pid") == -1)
      {
        if (v26)
          HIDWORD(v26[9].isa) = (_DWORD)v163;
        objc_msgSend(*((id *)a1 + 2), "objectForKeyedSubscript:", &unk_1E71677B0);
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = objc_msgSend(v31, "containsObject:", v26);

        if ((v32 & 1) != 0)
        {
          objc_msgSend(*((id *)a1 + 2), "objectForKeyedSubscript:", &unk_1E71677B0);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v33, "removeObject:", v26);

          v34 = (void *)*((_QWORD *)a1 + 2);
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v26, "pid"));
          v35 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v34, "objectForKeyedSubscript:", v35);
          v36 = (id)objc_claimAutoreleasedReturnValue();

          if (!v36)
          {
            v36 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
            v37 = (void *)*((_QWORD *)a1 + 2);
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v26, "pid"));
            v38 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v37, "setObject:forKeyedSubscript:", v36, v38);

          }
          objc_msgSend(v36, "addObject:", v26);

          goto LABEL_18;
        }
        goto LABEL_87;
      }
LABEL_84:
      v175 = *__error();
      _sa_logt();
      v92 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
      {
        log = v92;
        v93 = (void *)*((_QWORD *)a1 + 2);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
        v171 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v93, "objectForKeyedSubscript:", v171);
        v168 = (void *)objc_claimAutoreleasedReturnValue();
        v149 = objc_msgSend(v168, "count");
        v94 = (void *)*((_QWORD *)a1 + 2);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
        newValuea = (id)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v94, "objectForKeyedSubscript:", newValuea);
        v161 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v161, "lastObject");
        v159 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v159, "debugDescription");
        v157 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v142 = objc_msgSend(v157, "UTF8String");
        v95 = (void *)*((_QWORD *)a1 + 2);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
        v152 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v95, "objectForKeyedSubscript:", v152);
        v150 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v150, "lastObject");
        v147 = (void *)objc_claimAutoreleasedReturnValue();
        v139 = objc_msgSend(v147, "uniquePid");
        v96 = (void *)*((_QWORD *)a1 + 2);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
        v145 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v96, "objectForKeyedSubscript:", v145);
        v143 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v143, "lastObject");
        v141 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v141, "mainBinaryLoadInfo");
        v140 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v140, "debugDescription");
        v97 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v138 = objc_msgSend(v97, "UTF8String");
        v98 = objc_msgSend(v156, "count");
        -[NSObject debugDescription](v26, "debugDescription");
        v99 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v100 = objc_msgSend(v99, "UTF8String");
        v101 = -[NSObject uniquePid](v26, "uniquePid");
        -[NSObject mainBinaryLoadInfo](v26, "mainBinaryLoadInfo");
        v102 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v102, "debugDescription");
        v103 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v104 = objc_msgSend(v103, "UTF8String");
        *(_DWORD *)buf = 67111426;
        *(_DWORD *)v177 = (_DWORD)v163;
        *(_WORD *)&v177[4] = 2048;
        *(_QWORD *)&v177[6] = v149;
        *(_WORD *)&v177[14] = 2080;
        *(_QWORD *)&v177[16] = v142;
        v178 = 2048;
        v179 = v139;
        v180 = 2080;
        v181 = v138;
        v182 = 2048;
        v183 = a3;
        v184 = 2048;
        v185 = v98;
        v92 = log;
        v186 = 2080;
        v187 = v100;
        v188 = 2048;
        v189 = v101;
        v190 = 2080;
        v191 = v104;
        _os_log_error_impl(&dword_1B9BE0000, log, OS_LOG_TYPE_ERROR, "_tasksByPid[%d] (count %lu) .lastObject %s (unique pid %llu, main binary %s) != tasksWithUniquePid[%llu] (count %lu) .lastObject %s (unique pid %llu, main binary %s)", buf, 0x62u);

      }
      *__error() = v175;
      v105 = (void *)*((_QWORD *)a1 + 2);
      v21 = v163;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
      loga = (os_log_t)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v105, "objectForKeyedSubscript:", loga);
      v174 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v174, "count");
      v106 = (void *)*((_QWORD *)a1 + 2);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
      v172 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v106, "objectForKeyedSubscript:", v172);
      v169 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v169, "lastObject");
      newValueb = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(newValueb, "debugDescription");
      v162 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v162, "UTF8String");
      v107 = (void *)*((_QWORD *)a1 + 2);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
      v160 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v107, "objectForKeyedSubscript:", v160);
      v153 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v153, "lastObject");
      v151 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v151, "uniquePid");
      v108 = (void *)*((_QWORD *)a1 + 2);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
      v148 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v108, "objectForKeyedSubscript:", v148);
      v146 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v146, "lastObject");
      v144 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v144, "mainBinaryLoadInfo");
      v109 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v109, "debugDescription");
      v110 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v110, "UTF8String");
      objc_msgSend(v156, "count");
      -[NSObject debugDescription](v26, "debugDescription");
      v111 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      a1 = (id)objc_msgSend(v111, "UTF8String");
      -[NSObject uniquePid](v26, "uniquePid");
      -[NSObject mainBinaryLoadInfo](v26, "mainBinaryLoadInfo");
      v26 = objc_claimAutoreleasedReturnValue();
      -[NSObject debugDescription](v26, "debugDescription");
      v112 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v112, "UTF8String");
      _SASetCrashLogMessage(1440, "_tasksByPid[%d] (count %lu) .lastObject %s (unique pid %llu, main binary %s) != tasksWithUniquePid[%llu] (count %lu) .lastObject %s (unique pid %llu, main binary %s)", v113, v114, v115, v116, v117, v118, (char)v163);

      _os_crash();
      __break(1u);
LABEL_87:
      v119 = *__error();
      _sa_logt();
      v120 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
      {
        v121 = (void *)*((_QWORD *)a1 + 2);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
        v122 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v121, "objectForKeyedSubscript:", v122);
        v123 = (void *)objc_claimAutoreleasedReturnValue();
        v124 = objc_msgSend(v123, "count");
        -[NSObject debugDescription](v26, "debugDescription");
        v125 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v126 = objc_msgSend(v125, "UTF8String");
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)v177 = v124;
        *(_WORD *)&v177[8] = 2080;
        *(_QWORD *)&v177[10] = v126;
        _os_log_error_impl(&dword_1B9BE0000, v120, OS_LOG_TYPE_ERROR, "_tasksByPid[-1] (count %lu) does not contain task %s that didn't have pid until now", buf, 0x16u);

      }
      *__error() = v119;
      v127 = (void *)*((_QWORD *)a1 + 2);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v163);
      v128 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v127, "objectForKeyedSubscript:", v128);
      v129 = (void *)objc_claimAutoreleasedReturnValue();
      v130 = objc_msgSend(v129, "count");
      -[NSObject debugDescription](v26, "debugDescription");
      v131 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v131, "UTF8String");
      _SASetCrashLogMessage(1451, "_tasksByPid[-1] (count %lu) does not contain task %s that didn't have pid until now", v132, v133, v134, v135, v136, v137, v130);

      _os_crash();
      __break(1u);
      goto LABEL_90;
    }
    if (v25)
    {
      a2 = -[NSObject pid](v25, "pid");
LABEL_29:
      if ((-[SATask correspondsToUniquePid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:]((uint64_t)v26, a3, v21, a6, a7, a9, a10, a12, v174) & 1) != 0)
      {
LABEL_30:
        if (a5)
        {
          v45 = a5;
          v46 = objc_getProperty(v26, v42, 272, 1);

          if (!v46)
          {
            v47 = v24;
            objc_msgSend(v47, "reverseObjectEnumerator");
            v48 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v48, "nextObject");
            v49 = (void *)objc_claimAutoreleasedReturnValue();
            if (v49)
            {
              v50 = v24;
              +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, (double)v45 - *MEMORY[0x1E0C9ADF8]);
              v51 = (void *)objc_claimAutoreleasedReturnValue();
              objc_setProperty_atomic(v49, v52, v51, 272);
              objc_msgSend(v49, "execTimestamp");
              v53 = (void *)objc_claimAutoreleasedReturnValue();

              if (v53)
              {
                objc_msgSend(v49, "execTimestamp");
                v54 = (void *)objc_claimAutoreleasedReturnValue();
                -[SASampleStore _backfillPidStartTimestamp:toPreviousTasksEnumerator:execTimestampOfNextTask:](v51, v48, v54);

              }
              v24 = v50;
            }

          }
        }
        -[SASampleStore addNewImageInfos:numLoadInfos:name:sharedCache:architecture:toTask:]((uint64_t)a1, (uint64_t)a6, a7, v21, v174, a12, v26);
        -[NSObject exitTimestamp](v26, "exitTimestamp");
        v55 = (void *)objc_claimAutoreleasedReturnValue();

        v21 = newValue;
        if (v55)
          objc_setProperty_atomic(v26, v56, newValue, 232);
        v26 = v26;
        v57 = v26;
        goto LABEL_72;
      }
      goto LABEL_24;
    }
    a2 = 0xFFFFFFFFLL;
    goto LABEL_47;
  }
  if ((_DWORD)a2 == -1)
  {
    v78 = *__error();
    _sa_logt();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      if (a7)
      {
        uuidForBytes((uint64_t)&a6[1]);
        a1 = (id)objc_claimAutoreleasedReturnValue();
        objc_msgSend(a1, "UUIDString");
        v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v79 = (const char *)-[NSObject UTF8String](v20, "UTF8String");
      }
      else
      {
        v79 = "no load info";
      }
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v177 = v21;
      *(_WORD *)&v177[8] = 2080;
      *(_QWORD *)&v177[10] = v79;
      _os_log_error_impl(&dword_1B9BE0000, v26, OS_LOG_TYPE_ERROR, "unknown uniquepid and pid for %s (%s)", buf, 0x16u);
      if (a7)
      {

      }
    }

    *__error() = v78;
    if (a7)
    {
      uuidForBytes((uint64_t)&a6[1]);
      v26 = objc_claimAutoreleasedReturnValue();
      -[NSObject UUIDString](v26, "UUIDString");
      a1 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(a1, "UTF8String");
      _SASetCrashLogMessage(1473, "unknown uniquepid and pid for %s (%s)", v86, v87, v88, v89, v90, v91, (char)v21);

    }
    else
    {
      _SASetCrashLogMessage(1473, "unknown uniquepid and pid for %s (%s)", v80, v81, v82, v83, v84, v85, (char)v21);
    }
    _os_crash();
    __break(1u);
    goto LABEL_84;
  }
  v39 = (void *)*((_QWORD *)a1 + 2);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v39, "objectForKeyedSubscript:", v40);
  v24 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v24)
  {
    v26 = 0;
    goto LABEL_47;
  }
  objc_msgSend(v24, "lastObject");
  v41 = objc_claimAutoreleasedReturnValue();
  v26 = v41;
  if (!v41)
  {
LABEL_47:
    v44 = 1;
    goto LABEL_48;
  }
  if (-[SATask correspondsToPid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:](v41, a2, v21, a6, a7, a9, a10, a12, v174))goto LABEL_30;
LABEL_24:
  -[NSObject exitTimestamp](v26, "exitTimestamp");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  if (v43)
  {

  }
  else if (*((_QWORD *)a1 + 45) >= 2uLL)
  {
    -[SASampleStore task:exitedAtTimestamp:]((uint64_t)a1, v26, newValue);
  }
  v44 = 0;
LABEL_48:
  if ((*((_BYTE *)a1 + 408) & 2) != 0)
  {
    SAExecutablePath(a2, v21);
    v60 = objc_claimAutoreleasedReturnValue();
    v58 = a2;
    v59 = (void *)v60;
  }
  else
  {
    v58 = a2;
    v59 = 0;
  }
  +[SATask taskWithPid:uniquePid:name:mainBinaryPath:pidStartTime:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:]((uint64_t)SATask, v58, a3, (uint64_t)v21, v59, a5, (uint64_t)a6, a7, (uint64_t)a9, a10, a12, v174);
  v61 = objc_claimAutoreleasedReturnValue();
  v57 = v61;
  v21 = newValue;
  if ((v44 & 1) == 0 && *((_QWORD *)a1 + 45) >= 2uLL)
  {
    if (v61)
    {
      objc_setProperty_atomic(v61, v62, newValue, 224);
      v64 = objc_getProperty(v57, v63, 272, 1);
      if (v64)
      {
        v66 = v64;
        v67 = v26 ? objc_getProperty(v26, v65, 272, 1) : 0;
        v68 = v67;

        if (!v68)
        {
          v70 = objc_getProperty(v57, v69, 272, 1);
          v71 = newValue;
          v72 = v70;
          objc_msgSend(v24, "reverseObjectEnumerator");
          v73 = (void *)objc_claimAutoreleasedReturnValue();
          -[SASampleStore _backfillPidStartTimestamp:toPreviousTasksEnumerator:execTimestampOfNextTask:](v72, v73, v71);

        }
      }
    }
  }
  -[SASampleStore addTask:]((uint64_t)a1, v57);
  v74 = *((_QWORD *)a1 + 51);
  if ((v74 & 2) == 0)
    goto LABEL_71;
  if ((a15 & 1) != 0)
    goto LABEL_69;
  if ((v74 & 0x80) != 0)
  {
    -[NSObject binaryLoadInfos](v57, "binaryLoadInfos");
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    if (!objc_msgSend(v75, "count") || (v158 & 1) != 0 || (a11 & 1) != 0 || !-[NSObject pid](v57, "pid"))
    {

LABEL_69:
      -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v57, *((_QWORD *)a1 + 51), *((_DWORD *)a1 + 82));
      goto LABEL_70;
    }
    v76 = -[NSObject uniquePid](v57, "uniquePid");

    if (!v76)
      goto LABEL_69;
  }
LABEL_70:
  -[SATask _gatherDataFromLiveProcessIsLate:mainBinaryPath:]((uint64_t)v57, 0, v59);
LABEL_71:

LABEL_72:
LABEL_73:

  return v57;
}

- (id)taskForKCDataTask:(NSObject *)a3 loadInfos:(unsigned int)a4 numLoadInfos:(char)a5 loadInfosIsPartial:(NSObject *)a6 textExecLoadInfos:(unsigned int)a7 numTextExecLoadInfos:(char)a8 textExecLoadInfosIsPartial:(uint64_t)a9 architecture:(void *)a10 timestamp:(void *)a11 sharedCache:(char)a12 needAOTInfo:
{
  -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](a1, *(unsigned int *)(a2 + 84), *(_QWORD *)a2, (char *)(a2 + 88), *(_QWORD *)(a2 + 32), a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  return (id)objc_claimAutoreleasedReturnValue();
}

- (id)taskForKCDataDeltaTask:(NSObject *)a3 loadInfos:(unsigned int)a4 numLoadInfos:(char)a5 loadInfosIsPartial:(NSObject *)a6 textExecLoadInfos:(unsigned int)a7 numTextExecLoadInfos:(char)a8 textExecLoadInfosIsPartial:(void *)a9 timestamp:(void *)a10 sharedCache:(char)a11 needAOTInfo:
{
  -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](a1, 0xFFFFFFFFLL, a2, 0, 0, a3, a4, a5, a6, a7, a8, 0, a9, a10, a11);
  return (id)objc_claimAutoreleasedReturnValue();
}

- (id)taskForKCDataTransitioningTask:(void *)a1 loadInfos:(uint64_t)a2 numLoadInfos:(NSObject *)a3 loadInfosIsPartial:(unsigned int)a4 textExecLoadInfos:(char)a5 numTextExecLoadInfos:(NSObject *)a6 textExecLoadInfosIsPartial:(unsigned int)a7 architecture:(char)a8 timestamp:(void *)a9 sharedCache:(void *)a10 needAOTInfo:(char)a11
{
  -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](a1, *(unsigned int *)(a2 + 24), *(_QWORD *)a2, (char *)(a2 + 28), 0, a3, a4, a5, a6, a7, a8, 0, a9, a10, a11);
  return (id)objc_claimAutoreleasedReturnValue();
}

- (id)taskForMicrostackshotTask:(char *)a3 taskName:(NSObject *)a4 loadInfos:(unsigned int)a5 numLoadInfos:(void *)a6 sharedCache:(int)a7 loadInfosIsPartial:(void *)a8 timestamp:(uint64_t)a9 architecture:(char)a10 needAOTInfo:(char)a11 isFromCurrentBoot:
{
  id v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  id v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  NSObject *v31;
  unsigned int v32;
  id v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  id v40;
  void *v41;
  int v42;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  id v52;
  void *v53;
  void *v54;
  char v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  id v60;
  void *v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  int v72;
  void *v73;
  unsigned int v74;
  void *v75;
  id v76;
  int v77;
  NSObject *log;
  os_log_t loga;
  uint8_t buf[4];
  uint64_t v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  uint64_t v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v18 = a6;
  v19 = a8;
  if (*(_QWORD *)(a2 + 8) == -1)
  {
    v72 = a7;
    v31 = a4;
    v32 = a5;
    v33 = v19;
    v34 = *(void **)(a1 + 16);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a2 + 4));
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v34, "objectForKeyedSubscript:", v35);
    v22 = (void *)objc_claimAutoreleasedReturnValue();

    if (v22)
    {
      objc_msgSend(v22, "lastObject");
      v36 = objc_claimAutoreleasedReturnValue();
      v24 = (id)v36;
      v19 = v33;
      if (v36)
      {
        a5 = v32;
        if ((-[SATask correspondsToPid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:](v36, *(_DWORD *)(a2 + 4), a3, v31, v32, 0, 0, a9, v18) & 1) != 0)
        {
          -[SASampleStore addNewImageInfos:numLoadInfos:name:sharedCache:architecture:toTask:](a1, (uint64_t)v31, v32, a3, v18, a9, v24);
          v24 = v24;
          v30 = v24;
          goto LABEL_34;
        }
        objc_msgSend(v24, "exitTimestamp");
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        a4 = v31;
        a7 = v72;
        if (v37)
          goto LABEL_19;
LABEL_17:
        v38 = *(_QWORD *)(a1 + 360);
        if (!v38)
          goto LABEL_20;
        if (v38 != 1)
        {
          -[SASampleStore task:exitedAtTimestamp:](a1, v24, v19);
LABEL_20:

          if ((*(_BYTE *)(a1 + 408) & 2) != 0)
          {
            SAExecutablePath(*(_DWORD *)(a2 + 4), a3);
            v22 = (void *)objc_claimAutoreleasedReturnValue();
          }
          else
          {
            v22 = 0;
          }
          +[SATask taskWithPid:uniquePid:name:mainBinaryPath:pidStartTime:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:]((uint64_t)SATask, *(unsigned int *)(a2 + 4), *(_QWORD *)(a2 + 8), (uint64_t)a3, v22, 0, (uint64_t)a4, a5, 0, 0, a9, v18);
          v30 = (void *)objc_claimAutoreleasedReturnValue();
          -[SASampleStore addTask:](a1, v30);
          v39 = *(_QWORD *)(a1 + 408);
          if ((v39 & 2) == 0 || !a11)
            goto LABEL_34;
          v40 = v19;
          if ((a10 & 1) != 0)
            goto LABEL_32;
          if ((v39 & 0x80) != 0)
          {
            objc_msgSend(v30, "binaryLoadInfos");
            v41 = (void *)objc_claimAutoreleasedReturnValue();
            if (!objc_msgSend(v41, "count") || a7)
            {

LABEL_32:
              -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v30, *(_QWORD *)(a1 + 408), *(_DWORD *)(a1 + 328));
              goto LABEL_33;
            }
            v42 = objc_msgSend(v30, "pid");

            if (!v42)
              goto LABEL_32;
          }
LABEL_33:
          -[SATask _gatherDataFromLiveProcessIsLate:mainBinaryPath:]((uint64_t)v30, 0, v22);
          v19 = v40;
          goto LABEL_34;
        }
LABEL_19:

        goto LABEL_20;
      }
    }
    else
    {
      v24 = 0;
      v19 = v33;
    }
    a5 = v32;
    a4 = v31;
    a7 = v72;
    goto LABEL_20;
  }
  v20 = *(void **)(a1 + 8);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v20, "objectForKeyedSubscript:", v21);
  v22 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v22)
  {
    v24 = 0;
    goto LABEL_20;
  }
  objc_msgSend(v22, "lastObject");
  v23 = objc_claimAutoreleasedReturnValue();
  v24 = (id)v23;
  if (!v23)
    goto LABEL_20;
  if (!-[SATask correspondsToUniquePid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:](v23, *(_QWORD *)(a2 + 8), a3, a4, a5, 0, 0, a9, v18))
  {
    objc_msgSend(v24, "exitTimestamp");
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    if (v37)
      goto LABEL_19;
    goto LABEL_17;
  }
  v71 = (uint64_t)a4;
  v74 = a5;
  v76 = v19;
  v25 = *(void **)(a1 + 16);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a2 + 4));
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v25, "objectForKeyedSubscript:", v26);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v27, "lastObject");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v22, "lastObject");
  v29 = (void *)objc_claimAutoreleasedReturnValue();

  if (v28 != v29)
  {
    v77 = *__error();
    _sa_logt();
    log = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
    {
      v44 = *(void **)(a1 + 16);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a2 + 4));
      v75 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v44, "objectForKeyedSubscript:", v75);
      v73 = (void *)objc_claimAutoreleasedReturnValue();
      v69 = objc_msgSend(v73, "count");
      v45 = *(void **)(a1 + 16);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a2 + 4));
      v70 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v45, "objectForKeyedSubscript:", v70);
      v46 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v46, "lastObject");
      v47 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v47, "debugDescription");
      v48 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v49 = objc_msgSend(v48, "UTF8String");
      v50 = objc_msgSend(v22, "count");
      objc_msgSend(v22, "lastObject");
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v51, "debugDescription");
      v52 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      *(_DWORD *)buf = 134218754;
      v81 = v69;
      v82 = 2080;
      v83 = v49;
      v84 = 2048;
      v85 = v50;
      v86 = 2080;
      v87 = objc_msgSend(v52, "UTF8String");
      _os_log_error_impl(&dword_1B9BE0000, log, OS_LOG_TYPE_ERROR, "_tasksByPid[@(task_snap->pid)] (count %lu) .lastObject %s != tasksWithUniquePid (count %lu) .lastObject %s", buf, 0x2Au);

    }
    *__error() = v77;
    v53 = *(void **)(a1 + 16);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a2 + 4));
    loga = (os_log_t)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v53, "objectForKeyedSubscript:", loga);
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = objc_msgSend(v54, "count");
    v56 = *(void **)(a1 + 16);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a2 + 4));
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v56, "objectForKeyedSubscript:", v57);
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v58, "lastObject");
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v59, "debugDescription");
    v60 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    objc_msgSend(v60, "UTF8String");
    objc_msgSend(v22, "count");
    objc_msgSend(v22, "lastObject");
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v61, "debugDescription");
    v62 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    objc_msgSend(v62, "UTF8String");
    _SASetCrashLogMessage(1656, "_tasksByPid[@(task_snap->pid)] (count %lu) .lastObject %s != tasksWithUniquePid (count %lu) .lastObject %s", v63, v64, v65, v66, v67, v68, v55);

    _os_crash();
    __break(1u);
  }
  -[SASampleStore addNewImageInfos:numLoadInfos:name:sharedCache:architecture:toTask:](a1, v71, v74, a3, v18, a9, v24);
  v24 = v24;
  v30 = v24;
  v19 = v76;
LABEL_34:

  return v30;
}

- (id)_lastTaskOnOrBeforeTimestamp:(void *)a3 inTasks:
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  uint64_t v10;
  void *i;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (a1)
  {
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    objc_msgSend(v6, "reverseObjectEnumerator", 0);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = (id)objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
    if (v9)
    {
      v10 = *(_QWORD *)v18;
      while (2)
      {
        for (i = 0; i != v9; i = (char *)i + 1)
        {
          if (*(_QWORD *)v18 != v10)
            objc_enumerationMutation(v8);
          v12 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)i);
          objc_msgSend(v12, "startTimestamp");
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          v14 = v13;
          if (v13)
          {
            if (!objc_msgSend(v13, "gt:", v5))
              goto LABEL_14;
          }
          else
          {
            objc_msgSend(v7, "firstObject");
            v15 = (void *)objc_claimAutoreleasedReturnValue();

            if (v12 == v15)
            {
LABEL_14:
              v9 = v12;

              goto LABEL_15;
            }
          }

        }
        v9 = (id)objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
        if (v9)
          continue;
        break;
      }
    }
LABEL_15:

  }
  else
  {
    v9 = 0;
  }

  return v9;
}

- (_QWORD)firstTaskWithPid:(_QWORD *)a1
{
  if (a1)
  {
    -[SASampleStore firstTaskWithPid:onOrAfterTimestamp:](a1, a2, 0);
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

- (id)_firstTaskOnOrAfterTimestamp:(void *)a1 inTasks:(void *)a2
{
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v4 = a2;
  v5 = (id)objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v14;
    while (2)
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v14 != v6)
          objc_enumerationMutation(v4);
        v8 = *(void **)(*((_QWORD *)&v13 + 1) + 8 * (_QWORD)i);
        objc_msgSend(v8, "endTimestamp", (_QWORD)v13);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        v10 = v9;
        if (v9)
        {
          if (!objc_msgSend(v9, "lt:", v3))
            goto LABEL_13;
        }
        else
        {
          objc_msgSend(v4, "lastObject");
          v11 = (void *)objc_claimAutoreleasedReturnValue();

          if (v8 == v11)
          {
LABEL_13:
            v5 = v8;

            goto LABEL_14;
          }
        }

      }
      v5 = (id)objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
      if (v5)
        continue;
      break;
    }
  }
LABEL_14:

  return v5;
}

- (_QWORD)taskWithUniquePid:(void *)a3 atTimestamp:
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (a1)
  {
    v6 = (void *)a1[1];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v9 = v8;
    a1 = (_QWORD *)objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    if (a1)
    {
      v10 = *(_QWORD *)v15;
      while (2)
      {
        v11 = 0;
        do
        {
          if (*(_QWORD *)v15 != v10)
            objc_enumerationMutation(v9);
          v12 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)v11);
          if ((-[SATask isAliveAtTimestamp:](v12, v5) & 1) != 0)
          {
            a1 = v12;
            goto LABEL_12;
          }
          v11 = (_QWORD *)((char *)v11 + 1);
        }
        while (a1 != v11);
        a1 = (_QWORD *)objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
        if (a1)
          continue;
        break;
      }
    }
LABEL_12:

  }
  return a1;
}

void __47__SASampleStore_taskWithPid_orTid_atTimestamp___block_invoke(uint64_t a1, void *a2, _BYTE *a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  unsigned int v10;
  id v11;

  v11 = a2;
  objc_msgSend(v11, "threads");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 48));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKeyedSubscript:", v7);
  v8 = objc_claimAutoreleasedReturnValue();
  if (v8)
  {
    v9 = (void *)v8;
    v10 = -[SATask isAliveAtTimestamp:](v11, *(void **)(a1 + 32));

    if (v10)
    {
      objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a2);
      *a3 = 1;
    }
  }
  else
  {

  }
}

void __39__SASampleStore_lastTaskWithPid_orTid___block_invoke(uint64_t a1, void *a2, _BYTE *a3)
{
  void *v6;
  void *v7;
  void *v8;
  id *v9;
  int v10;
  id v11;

  v11 = a2;
  objc_msgSend(v11, "threads");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 40));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKeyedSubscript:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = (id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (v8)
  {
    objc_storeStrong(v9, a2);
  }
  else if (*v9)
  {
    v10 = objc_msgSend(v11, "pid");
    if (v10 != objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "pid"))
      *a3 = 1;
  }

}

- (id)initForFileParsing
{
  id result;

  result = -[SASampleStore init](self, "init");
  if (result)
  {
    *((_BYTE *)result + 316) = 0;
    *((_QWORD *)result + 51) = 1652;
  }
  return result;
}

- (void)setSampleOnlyMainThreads:(BOOL)a3
{
  _BOOL4 v3;
  int v5;
  NSObject *v6;
  uint8_t v7[16];

  if (self->_sampleOnlyMainThreads == a3)
    return;
  v3 = a3;
  if (!-[NSMutableArray count](self->_sampleTimestamps, "count"))
  {
LABEL_8:
    self->_sampleOnlyMainThreads = v3;
    return;
  }
  if (!v3)
  {
    self->_nextSampleIsFirstSamplingAllThreads = 1;
    goto LABEL_8;
  }
  v5 = *__error();
  _sa_logt();
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v7 = 0;
    _os_log_error_impl(&dword_1B9BE0000, v6, OS_LOG_TYPE_ERROR, "Cannot set sampleOnlyMainThreads to YES after parsing any data", v7, 2u);
  }

  *__error() = v5;
}

- (BOOL)sampleOnlyMainThreads
{
  return self->_sampleOnlyMainThreads;
}

- (void)setStackshotsOnlyIncludeSpecificProcesses:(BOOL)a3
{
  _BOOL4 v3;
  int v5;
  NSObject *v6;
  uint8_t v7[16];

  if (self->_stackshotsOnlyIncludeSpecificProcesses == a3)
    return;
  v3 = a3;
  if (!-[NSMutableArray count](self->_sampleTimestamps, "count"))
  {
LABEL_8:
    self->_stackshotsOnlyIncludeSpecificProcesses = v3;
    return;
  }
  if (!v3)
  {
    self->_nextSampleIsFirstSamplingAllProcesses = 1;
    goto LABEL_8;
  }
  v5 = *__error();
  _sa_logt();
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v7 = 0;
    _os_log_error_impl(&dword_1B9BE0000, v6, OS_LOG_TYPE_ERROR, "Cannot set stackshotsOnlyIncludeSpecificProcesses to YES after parsing any data", v7, 2u);
  }

  *__error() = v5;
}

- (BOOL)stackshotsOnlyIncludeSpecificProcesses
{
  return self->_stackshotsOnlyIncludeSpecificProcesses;
}

- (void)dealloc
{
  objc_super v3;

  -[SABinaryLocator done](self->_binaryLocator, "done");
  v3.receiver = self;
  v3.super_class = (Class)SASampleStore;
  -[SASampleStore dealloc](&v3, sel_dealloc);
}

- (unint64_t)indexOfFirstSampleOnOrAfterTimestamp:(id)a3
{
  id v4;
  unint64_t v5;
  unint64_t v6;

  v4 = a3;
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if (-[NSMutableArray count](self->_sampleTimestamps, "count"))
  {
    v6 = -[NSMutableArray indexOfObject:inSortedRange:options:usingComparator:](self->_sampleTimestamps, "indexOfObject:inSortedRange:options:usingComparator:", v4, 0, -[NSMutableArray count](self->_sampleTimestamps, "count"), 1280, &__block_literal_global_186);
    if (v6 < -[NSMutableArray count](self->_sampleTimestamps, "count"))
      v5 = v6;
  }

  return v5;
}

uint64_t __54__SASampleStore_indexOfFirstSampleOnOrAfterTimestamp___block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "compare:");
}

- (unint64_t)indexOfLastSampleOnOrBeforeTimestamp:(id)a3
{
  id v4;
  unint64_t v5;
  uint64_t v6;

  v4 = a3;
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if (-[NSMutableArray count](self->_sampleTimestamps, "count"))
  {
    v6 = -[NSMutableArray indexOfObject:inSortedRange:options:usingComparator:](self->_sampleTimestamps, "indexOfObject:inSortedRange:options:usingComparator:", v4, 0, -[NSMutableArray count](self->_sampleTimestamps, "count"), 1536, &__block_literal_global_187);
    if (v6)
      v5 = v6 - 1;
  }

  return v5;
}

uint64_t __54__SASampleStore_indexOfLastSampleOnOrBeforeTimestamp___block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "compare:");
}

- (_QWORD)exclaveWithIdentifier:(uint64_t)a1
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  void *v9;
  _QWORD *v10;
  void *v11;
  id v12;
  void *v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v4 = *(id *)(a1 + 120);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v16;
    while (2)
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v16 != v7)
          objc_enumerationMutation(v4);
        v9 = *(void **)(*((_QWORD *)&v15 + 1) + 8 * i);
        if (objc_msgSend(v9, "identifier", (_QWORD)v15) == a2)
        {
          v10 = v9;

          return v10;
        }
      }
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
      if (v6)
        continue;
      break;
    }
  }

  v10 = -[SAExclave initWithIdentifier:]([SAExclave alloc], a2);
  v11 = *(void **)(a1 + 120);
  if (!v11)
  {
    v12 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v13 = *(void **)(a1 + 120);
    *(_QWORD *)(a1 + 120) = v12;

    v11 = *(void **)(a1 + 120);
  }
  objc_msgSend(v11, "addObject:", v10, (_QWORD)v15);
  return v10;
}

- (uint64_t)parseKCDataExclavesContainer:(void *)a3 exclaveInfo:(_QWORD *)a4 primaryDataIsKPerf:
{
  id v7;
  int cache;
  id v9;
  uint64_t superclass;
  unint64_t v11;
  id v12;
  __objc2_class *v13;
  char *v14;
  _DWORD *v15;
  char *v16;
  char *__ptr32 *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD **Property;
  _QWORD **v24;
  uint64_t v25;
  _QWORD **v26;
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t **v30;
  void *v31;
  void *v32;
  void **v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  uint64_t v43;
  int v44;
  NSObject *v45;
  void *v46;
  id v47;
  const char *v48;
  id v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *__ptr32 *v53;
  const char *v54;
  __objc2_class *v55;
  __objc2_class *v56;
  _QWORD *v57;
  __objc2_class *v58;
  char *__ptr32 *v59;
  void *v60;
  const char *v61;
  void *v62;
  void *v63;
  id v64;
  SAExclaveCallstack *v65;
  _QWORD *v66;
  id *v67;
  id *v68;
  id v69;
  uint64_t v70;
  void *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  NSObject *v76;
  const char *ClassName;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  void *v87;
  __objc2_class *isa;
  int v89;
  int v90;
  unint64_t v91;
  uint64_t isa_high;
  BOOL v93;
  BOOL v94;
  int v95;
  id v96;
  id v97;
  __objc2_class *v98;
  void *v99;
  __objc2_class *v100;
  __objc2_class *v101;
  char *v102;
  _DWORD *v103;
  char *v104;
  _QWORD *v105;
  void *v106;
  void *v107;
  __objc2_class *v108;
  int v109;
  int v110;
  _DWORD *v111;
  unsigned int v112;
  unsigned int v113;
  BOOL v114;
  unsigned int v115;
  int v116;
  unsigned int v118;
  __objc2_class *v119;
  __objc2_class *v120;
  int v121;
  NSObject *v122;
  char *v123;
  _QWORD *v124;
  void *v125;
  __objc2_class *v126;
  char *v127;
  _DWORD *v128;
  char *v129;
  void **p_cache;
  void *v131;
  void *v132;
  __objc2_class *v133;
  int v134;
  int v135;
  unint64_t v136;
  uint64_t v137;
  BOOL v138;
  BOOL v139;
  __objc2_class *v140;
  __objc2_class *v141;
  __objc2_class *v142;
  char *v143;
  _DWORD *v144;
  char *v145;
  id v146;
  int v147;
  NSObject *v148;
  void *v149;
  __objc2_class *v150;
  int v151;
  unsigned int v152;
  int v153;
  uint64_t p_superclass;
  unint64_t v155;
  void *v156;
  void **v157;
  uint64_t v158;
  BOOL v159;
  BOOL v160;
  uint64_t v161;
  __objc2_class *v162;
  unint64_t v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  id v167;
  unsigned int v168;
  uint64_t v169;
  uint64_t v170;
  char *v171;
  _QWORD *v172;
  int v173;
  NSObject *v174;
  char *v175;
  __objc2_class *v176;
  id v177;
  __objc2_class *v178;
  __objc2_class *v179;
  __objc2_class *v180;
  char *v181;
  _DWORD *v182;
  char *v183;
  void *v184;
  int v185;
  NSObject *v186;
  uint64_t v187;
  id v188;
  void *v189;
  void *v190;
  __objc2_class *v191;
  int v192;
  unsigned int v193;
  int v194;
  uint64_t v195;
  unint64_t v196;
  void **v197;
  uint64_t v198;
  BOOL v199;
  BOOL v200;
  uint64_t v201;
  __objc2_class *v202;
  unint64_t v203;
  unsigned int v204;
  unsigned int v205;
  unsigned int v206;
  unsigned int v207;
  uint64_t v208;
  uint64_t v209;
  id v210;
  uint64_t v211;
  char *v212;
  _QWORD *v213;
  _QWORD *v214;
  void *v215;
  void *v216;
  id v217;
  int v218;
  NSObject *v219;
  int v220;
  NSObject *v221;
  int v222;
  NSObject *v223;
  __objc2_class *v224;
  void **v225;
  SAKCDataExclaveSCResult *v226;
  void *v227;
  _QWORD *v228;
  void *v229;
  int v230;
  NSObject *v231;
  __objc2_class *v232;
  int v233;
  NSObject *v234;
  char *v235;
  __objc2_class *v236;
  int v237;
  NSObject *v238;
  __objc2_class *v240;
  int v241;
  NSObject *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  int v249;
  NSObject *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  int v257;
  NSObject *v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  int v265;
  NSObject *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  NSObject *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  void *v281;
  id v282;
  id v283;
  _QWORD **context;
  void *contexta;
  uint64_t v286;
  __objc2_class *v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  int v291;
  uint64_t v292;
  __objc2_class *v293;
  id obj;
  id obja;
  id objb;
  void *v297;
  id v298;
  uint64_t v299;
  id v300;
  _QWORD **v301;
  void **v302;
  __objc2_class *v303;
  uint64_t v304;
  __objc2_class *v305;
  id v306;
  uint64_t v307;
  void *v308;
  int v309;
  uint64_t v310;
  id v311;
  uint64_t v312;
  id v313;
  void *v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  _QWORD **v320;
  _QWORD v321[5];
  _QWORD v322[5];
  __int128 v323;
  __int128 v324;
  __int128 v325;
  __int128 v326;
  __int128 v327;
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  __int128 v332;
  __int128 v333;
  __int128 v334;
  _BYTE v335[128];
  _BYTE v336[128];
  uint8_t v337[128];
  _BYTE buf[24];
  void *v339;
  id v340;
  uint8_t v341[32];
  __int128 v342;
  __int128 v343;
  uint64_t v344;

  v344 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  cache = (int)a2->isa->cache;
  if (cache != 2377)
  {
    v241 = *__error();
    _sa_logt();
    v242 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v242, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = cache;
      _os_log_error_impl(&dword_1B9BE0000, v242, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
    }

    *__error() = v241;
    _SASetCrashLogMessage(5775, "bad container type %u", v243, v244, v245, v246, v247, v248, cache);
    _os_crash();
    __break(1u);
LABEL_432:
    v249 = *__error();
    _sa_logt();
    v250 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = v309;
      *(_DWORD *)&buf[4] = cache;
      _os_log_error_impl(&dword_1B9BE0000, v250, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
    }

    *__error() = v249;
    _SASetCrashLogMessage(6217, "bad container type %u", v251, v252, v253, v254, v255, v256, cache);
    _os_crash();
    __break(1u);
    goto LABEL_435;
  }
  v9 = v7;
  v320 = a4;
  v299 = a1;
  superclass = (uint64_t)a2->isa->superclass;
  v11 = 0x1E0C99000uLL;
  v300 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v298 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v12 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v297 = v12;
  v13 = a2->superclass;
  v14 = (char *)a2->isa + HIDWORD(a2->isa->isa);
  v15 = v14 + 16;
  a2->isa = (__objc2_class *)(v14 + 16);
  v16 = v14 + 32;
  v17 = &off_1B9CC2000;
  if (v16 > (char *)v13)
    goto LABEL_3;
LABEL_89:
  v309 = 67109120;
  v85 = *((_QWORD *)v17 + 298);
  while (2)
  {
    if (&v16[v15[1]] > (char *)v13 || *v15 == -242132755)
    {
LABEL_3:
      v311 = objc_alloc_init(*(Class *)(v11 + 3592));
      v331 = 0u;
      v332 = 0u;
      v333 = 0u;
      v334 = 0u;
      objc_msgSend(v297, "allValues");
      obj = (id)objc_claimAutoreleasedReturnValue();
      v289 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v331, v337, 16);
      if (!v289)
        goto LABEL_85;
      v19 = *(_QWORD *)v332;
      v288 = (uint64_t)((_QWORD)v320 << 63) >> 63;
      v20 = *((_QWORD *)v17 + 298);
      v281 = v9;
      v286 = *(_QWORD *)v332;
LABEL_5:
      v21 = 0;
LABEL_6:
      if (*(_QWORD *)v332 != v19)
      {
        v22 = v21;
        objc_enumerationMutation(obj);
        v21 = v22;
      }
      v292 = v21;
      Property = *(_QWORD ***)(*((_QWORD *)&v331 + 1) + 8 * v21);
      v327 = 0u;
      v328 = 0u;
      v329 = 0u;
      v330 = 0u;
      context = Property;
      if (Property)
        Property = (_QWORD **)objc_getProperty(Property, v18, 16, 1);
      v24 = Property;
      v310 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v327, v336, 16);
      if (!v310)
      {
LABEL_82:

        goto LABEL_83;
      }
      v304 = *(_QWORD *)v328;
      v308 = 0;
      v301 = v24;
LABEL_12:
      v25 = 0;
LABEL_13:
      if (*(_QWORD *)v328 != v304)
        objc_enumerationMutation(v24);
      v26 = *(_QWORD ***)(*((_QWORD *)&v327 + 1) + 8 * v25);
      v27 = *v26[1];
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v27);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v311, "objectForKeyedSubscript:", v28);
      v9 = (id)objc_claimAutoreleasedReturnValue();

      v320 = v26;
      if (!v9)
      {
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v27);
        v29 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v300, "objectForKeyedSubscript:", v29);
        v30 = (uint64_t **)objc_claimAutoreleasedReturnValue();

        if (v30)
        {
          v315 = v25;
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v30[1][2]);
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v298, "objectForKeyedSubscript:", v31);
          v32 = (void *)objc_claimAutoreleasedReturnValue();

          v33 = v30;
          v34 = v32;
          memset(v341, 0, sizeof(v341));
          v342 = 0u;
          v343 = 0u;
          a2 = (__objc2_class *)*(id *)(v299 + 120);
          v35 = -[__objc2_class countByEnumeratingWithState:objects:count:](a2, "countByEnumeratingWithState:objects:count:", v341, buf, 16);
          if (!v35)
            goto LABEL_25;
          v36 = v35;
          v37 = **(_QWORD **)&v341[16];
          do
          {
            for (i = 0; i != v36; ++i)
            {
              if (**(_QWORD **)&v341[16] != v37)
                objc_enumerationMutation(a2);
              v39 = *(void **)(*(_QWORD *)&v341[8] + 8 * i);
              if (objc_msgSend(v39, "identifier") == *v30[1])
              {
                -[SAExclave fillInName:textLayout:]((uint64_t)v39, v33[2], v34);
                v9 = v39;
                goto LABEL_30;
              }
            }
            v36 = -[__objc2_class countByEnumeratingWithState:objects:count:](a2, "countByEnumeratingWithState:objects:count:", v341, buf, 16);
          }
          while (v36);
LABEL_25:

          v9 = -[SAExclave initWithKCData:name:textLayout:]([SAExclave alloc], v30[1], v33[2], v34);
          v40 = *(void **)(v299 + 120);
          if (!v40)
          {
            v41 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
            v42 = *(void **)(v299 + 120);
            *(_QWORD *)(v299 + 120) = v41;

            v40 = *(void **)(v299 + 120);
          }
          objc_msgSend(v40, "addObject:", v9);
          -[SASampleStore lastTaskWithPid:]((_QWORD *)v299, 0);
          v43 = objc_claimAutoreleasedReturnValue();
          if (v43)
          {
            a2 = (__objc2_class *)v43;
          }
          else
          {
            +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v288, 0, 0);
            a2 = (__objc2_class *)objc_claimAutoreleasedReturnValue();
            -[SASampleStore addTask:](v299, a2);
          }
LABEL_30:

          v24 = v301;
          v25 = v315;
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0C99E38], "null");
          v9 = (id)objc_claimAutoreleasedReturnValue();
          v44 = *__error();
          _sa_logt();
          v45 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v27;
            _os_log_error_impl(&dword_1B9BE0000, v45, OS_LOG_TYPE_ERROR, "No exclave address space %llu in stackshot", buf, 0xCu);
          }

          *__error() = v44;
        }
        v26 = v320;
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v27);
        v46 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v311, "setObject:forKeyedSubscript:", v9, v46);

        if (!v9)
          goto LABEL_74;
      }
      objc_msgSend(MEMORY[0x1E0C99E38], "null");
      v47 = (id)objc_claimAutoreleasedReturnValue();

      if (v9 == v47)
        goto LABEL_74;
      v316 = v25;
      v325 = 0u;
      v326 = 0u;
      v323 = 0u;
      v324 = 0u;
      v49 = objc_getProperty(v26, v48, 16, 1);
      v50 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v323, v335, 16);
      if (!v50)
      {
        v17 = 0;
        goto LABEL_68;
      }
      v51 = v50;
      v17 = 0;
      v11 = *(_QWORD *)v324;
LABEL_38:
      v52 = 0;
      while (1)
      {
        v53 = v17;
        if (*(_QWORD *)v324 != v11)
          objc_enumerationMutation(v49);
        superclass = objc_msgSend(*(id *)(*((_QWORD *)&v323 + 1) + 8 * v52), "unsignedLongLongValue");
        if (!v17)
          break;
        v55 = (__objc2_class *)objc_getProperty(v17, v54, 40, 1);
        if (!v55)
          goto LABEL_53;
        v56 = v55;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v322[0] = MEMORY[0x1E0C809B0];
          v322[1] = v20;
          v322[2] = __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke;
          v322[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
          v322[4] = superclass;
          v57 = v322;
          v58 = v56;
LABEL_46:
          -[__objc2_class objectsPassingTest:](v58, "objectsPassingTest:", v57);
          a2 = (__objc2_class *)objc_claimAutoreleasedReturnValue();
          -[__objc2_class anyObject](a2, "anyObject");
          v17 = (char *__ptr32 *)objc_claimAutoreleasedReturnValue();
          goto LABEL_52;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          v75 = *__error();
          _sa_logt();
          v76 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          {
            ClassName = object_getClassName(v56);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = ClassName;
            _os_log_error_impl(&dword_1B9BE0000, v76, OS_LOG_TYPE_ERROR, "child is %s", buf, 0xCu);
          }

          *__error() = v75;
          v78 = object_getClassName(v56);
          _SASetCrashLogMessage(5922, "child is %s", v79, v80, v81, v82, v83, v84, v78);
          v12 = (id)_os_crash();
          __break(1u);
          goto LABEL_89;
        }
        a2 = v56;
        if (superclass == -[__objc2_class address](a2, "address"))
          v17 = a2;
        else
          v17 = 0;
        v56 = a2;
LABEL_52:

        if (!v17)
        {
LABEL_53:
          v59 = (char *__ptr32 *)-[SAExclaveFrame initWithExclave:]([SAExclaveFrame alloc], v9);
          v17 = v59;
          if (v59)
            *((_QWORD *)v59 + 2) = superclass;
          objc_msgSend(v9, "loadInfos");
          v60 = (void *)objc_claimAutoreleasedReturnValue();

          if (v60)
          {
            a2 = SABinaryLoadInfo;
            objc_msgSend(v9, "loadInfos");
            v62 = (void *)objc_claimAutoreleasedReturnValue();
            +[SABinaryLoadInfo binaryLoadInfoForAddress:inBinaryLoadInfos:](SABinaryLoadInfo, "binaryLoadInfoForAddress:inBinaryLoadInfos:", superclass, v62);
            v63 = (void *)objc_claimAutoreleasedReturnValue();
            if (v17)
              objc_storeWeak((id *)v17 + 3, v63);

          }
          if (v17)
            *((_QWORD *)v17 + 4) = v53;
          if (v53)
          {
            -[SAFrame _addChildFrame:]((uint64_t)v53, v17);
          }
          else
          {
            v64 = objc_getProperty(v9, v61, 40, 1);
            objc_msgSend(v64, "addObject:", v17);

          }
        }

        if (v51 == ++v52)
        {
          v51 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v323, v335, 16);
          if (v51)
            goto LABEL_38;
LABEL_68:

          v65 = [SAExclaveCallstack alloc];
          if (v65)
          {
            v66 = v320[1];
            v67 = -[SAExclaveCallstack initWithExclave:leafFrame:]((id *)&v65->super.isa, v9, v17);
            v68 = v67;
            v24 = v301;
            v25 = v316;
            if (v67)
            {
              v67[4] = (id)v66[2];
              v67[3] = (id)v66[1];
            }
            v69 = v308;
            if (!v308)
LABEL_72:
              v69 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          }
          else
          {
            v68 = 0;
            v69 = v308;
            v24 = v301;
            v25 = v316;
            if (!v308)
              goto LABEL_72;
          }
          v308 = v69;
          objc_msgSend(v69, "insertObject:atIndex:", v68, 0);

LABEL_74:
          if (++v25 != v310)
            goto LABEL_13;
          v70 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v327, v336, 16);
          v310 = v70;
          if (v70)
            goto LABEL_12;

          v9 = v281;
          if (v308)
          {
            v71 = (void *)objc_msgSend(v308, "copy");
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *context[1]);
            v72 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v281, "setObject:forKeyedSubscript:", v71, v72);

            v24 = (_QWORD **)v308;
            goto LABEL_82;
          }
LABEL_83:
          v21 = v292 + 1;
          v19 = v286;
          if (v292 + 1 == v289)
          {
            v73 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v331, v337, 16);
            v19 = v286;
            v289 = v73;
            if (!v73)
            {
LABEL_85:

              v74 = 0;
              goto LABEL_423;
            }
            goto LABEL_5;
          }
          goto LABEL_6;
        }
      }
      v58 = (__objc2_class *)objc_getProperty(v9, v54, 40, 1);
      v56 = v58;
      v321[0] = MEMORY[0x1E0C809B0];
      v321[1] = v20;
      v321[2] = __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke_301;
      v321[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
      v321[4] = superclass;
      v57 = v321;
      goto LABEL_46;
    }
    v86 = (void *)MEMORY[0x1BCCCC288](v12);
    v87 = v86;
    isa = a2->isa;
    v89 = (int)a2->isa->isa;
    if ((v89 & 0xFFFFFFF0) == 0x20)
      v90 = 17;
    else
      v90 = (int)a2->isa->isa;
    if ((v90 - 1) < 6)
      goto LABEL_98;
    if (v90 != 19)
    {
      if (v90 != 20)
      {
LABEL_98:
        objc_autoreleasePoolPop(v86);
        goto LABEL_403;
      }
      v240 = isa->superclass;
      if ((__objc2_class *)superclass == v240)
      {
        objc_autoreleasePoolPop(v86);
        v11 = 0x1E0C99000;
        goto LABEL_3;
      }
      v237 = *__error();
      _sa_logt();
      v238 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v238, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = superclass;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v240;
        _os_log_error_impl(&dword_1B9BE0000, v238, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
      }
      v74 = 7;
LABEL_422:

      *__error() = v237;
      objc_autoreleasePoolPop(v87);
      break;
    }
    v91 = (unint64_t)a2->superclass;
    if ((unint64_t)&isa->cache > v91
      || (isa_high = HIDWORD(isa->isa), (unint64_t)&isa->cache + isa_high > v91)
      || ((v89 & 0xFFFFFFF0) != 0x20 ? (v93 = v89 == 19) : (v93 = 0),
          v93 ? (v94 = isa_high > 3) : (v94 = 0),
          !v94))
    {
      v237 = *__error();
      _sa_logt();
      v238 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v238, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = 2377;
        _os_log_error_impl(&dword_1B9BE0000, v238, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
      }
      v74 = 1;
      goto LABEL_422;
    }
    v95 = (int)isa->cache;
    if (v95 == 2378)
    {
      v306 = v297;
      cache = (int)a2->isa->cache;
      if (cache == 2378)
      {
        v293 = a2->isa->superclass;
        v313 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v126 = a2->superclass;
        v127 = (char *)a2->isa + HIDWORD(a2->isa->isa);
        v128 = v127 + 16;
        a2->isa = (__objc2_class *)(v127 + 16);
        v129 = v127 + 32;
        if (v129 > (char *)v126)
          goto LABEL_392;
        p_cache = 0;
        v282 = v9;
        while (2)
        {
          if (&v129[v128[1]] > (char *)v126 || *v128 == -242132755)
          {
LABEL_387:
            if (p_cache)
            {
              v225 = p_cache;
              v226 = [SAKCDataExclaveSCResult alloc];
              if (objc_msgSend(v313, "count"))
                v227 = v313;
              else
                v227 = 0;
              v228 = -[SAKCDataExclaveSCResult initWithInfo:callstacks:](v226, (uint64_t)v225, v227);
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v225);
              v229 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v306, "setObject:forKeyedSubscript:", v228, v229);

              v11 = 0x1E0C99000;
              v74 = 0;
              goto LABEL_395;
            }
LABEL_392:
            v230 = *__error();
            _sa_logt();
            v231 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_1B9BE0000, v231, OS_LOG_TYPE_ERROR, "No exclave_scresult_info in scresult container", buf, 2u);
            }

            *__error() = v230;
            v74 = 1;
            goto LABEL_395;
          }
          v131 = (void *)MEMORY[0x1BCCCC288]();
          v132 = v131;
          v133 = a2->isa;
          v134 = (int)a2->isa->isa;
          if ((v134 & 0xFFFFFFF0) == 0x20)
            v135 = 17;
          else
            v135 = (int)a2->isa->isa;
          if (v135 != 19)
          {
            if (v135 == 2379)
            {
              p_cache = &v133->cache;
            }
            else if (v135 == 20)
            {
              v224 = v133->superclass;
              if (v293 == v224)
              {
                objc_autoreleasePoolPop(v131);
                v11 = 0x1E0C99000;
                goto LABEL_387;
              }
              v220 = *__error();
              _sa_logt();
              v221 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v221, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134218240;
                *(_QWORD *)&buf[4] = v293;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v224;
                _os_log_error_impl(&dword_1B9BE0000, v221, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
              }
              v74 = 7;
              v11 = 0x1E0C99000;
LABEL_376:

              *__error() = v220;
              objc_autoreleasePoolPop(v132);
LABEL_395:

              goto LABEL_402;
            }
            objc_autoreleasePoolPop(v131);
            goto LABEL_282;
          }
          v136 = (unint64_t)a2->superclass;
          if ((unint64_t)&v133->cache > v136
            || (v137 = HIDWORD(v133->isa), (unint64_t)&v133->cache + v137 > v136)
            || ((v134 & 0xFFFFFFF0) != 0x20 ? (v138 = v134 == 19) : (v138 = 0),
                v138 ? (v139 = v137 > 3) : (v139 = 0),
                !v139))
          {
            v220 = *__error();
            _sa_logt();
            v221 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v221, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = 2378;
              _os_log_error_impl(&dword_1B9BE0000, v221, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
            }
            v74 = 1;
            goto LABEL_376;
          }
          if (LODWORD(v133->cache) != 2380)
          {
            v74 = SkipToContainerEnd((int **)a2, 1);
            goto LABEL_281;
          }
          v302 = p_cache;
          obja = v313;
          v140 = a2->isa;
          cache = (int)a2->isa->cache;
          if (cache != 2380)
            goto LABEL_441;
          v141 = v140->superclass;
          v142 = a2->superclass;
          v143 = (char *)v140 + HIDWORD(v140->isa);
          v144 = v143 + 16;
          a2->isa = (__objc2_class *)(v143 + 16);
          v145 = v143 + 32;
          if (v145 > (char *)v142)
          {
            v146 = 0;
            goto LABEL_192;
          }
          v287 = v141;
          v290 = 0;
          v146 = 0;
          p_cache = v302;
          v318 = superclass;
          while (2)
          {
            if (&v145[v144[1]] > (char *)v142 || *v144 == -242132755)
              goto LABEL_269;
            v149 = (void *)MEMORY[0x1BCCCC288]();
            v150 = a2->isa;
            v151 = (int)a2->isa->isa;
            v152 = v151 & 0xFFFFFFF0;
            if ((v151 & 0xFFFFFFF0) == 0x20)
              v153 = 17;
            else
              v153 = (int)a2->isa->isa;
            if ((v153 - 1) >= 6)
              p_superclass = (uint64_t)&a2->isa->cache;
            else
              p_superclass = (uint64_t)&v150[1].superclass;
            if (v153 > 19)
            {
              if (v153 == 2381)
              {
                v290 = p_superclass;
              }
              else if (v153 == 20)
              {
                v176 = v150->superclass;
                if (v287 != v176)
                {
                  v156 = v149;
                  v291 = *__error();
                  _sa_logt();
                  v174 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v341 = 134218240;
                    *(_QWORD *)&v341[4] = v287;
                    *(_WORD *)&v341[12] = 2048;
                    *(_QWORD *)&v341[14] = v176;
                    _os_log_error_impl(&dword_1B9BE0000, v174, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", v341, 0x16u);
                  }
                  v74 = 7;
                  v11 = 0x1E0C99000;
                  v173 = v291;
                  goto LABEL_278;
                }
                objc_autoreleasePoolPop(v149);
                v11 = 0x1E0C99000;
LABEL_269:
                if (v290)
                {
                  v172 = -[SAKCDataExclaveCallstack initWithInfo:addresses:]([SAKCDataExclaveCallstack alloc], v290, v146);
                  objc_msgSend(obja, "addObject:", v172);

                  v74 = 0;
                }
                else
                {
LABEL_192:
                  v147 = *__error();
                  _sa_logt();
                  v148 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)v341 = 0;
                    _os_log_error_impl(&dword_1B9BE0000, v148, OS_LOG_TYPE_ERROR, "No exclave_ipcstackentry_info in ipcstackentry container", v341, 2u);
                  }

                  *__error() = v147;
                  v74 = 1;
                }
                p_cache = v302;
                goto LABEL_280;
              }
              goto LABEL_267;
            }
            v155 = (unint64_t)a2->superclass;
            if (v153 != 17)
            {
              if (v153 == 19)
              {
                v156 = v149;
                v157 = &v150->cache;
                if ((unint64_t)&v150->cache > v155
                  || (v158 = HIDWORD(v150->isa), (unint64_t)v157 + v158 > v155)
                  || (v152 != 32 ? (v159 = v151 == 19) : (v159 = 0),
                      v159 ? (v160 = v158 > 3) : (v160 = 0),
                      !v160))
                {
                  v173 = *__error();
                  _sa_logt();
                  v174 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v341 = 67109120;
                    *(_DWORD *)&v341[4] = 2380;
                    _os_log_error_impl(&dword_1B9BE0000, v174, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", v341, 8u);
                  }
                  v74 = 1;
                  goto LABEL_278;
                }
                v74 = SkipToContainerEnd((int **)a2, 1);
                objc_autoreleasePoolPop(v156);
                if ((_DWORD)v74)
                  goto LABEL_279;
                superclass = v318;
                goto LABEL_268;
              }
LABEL_267:
              objc_autoreleasePoolPop(v149);
LABEL_268:
              v142 = a2->superclass;
              v171 = (char *)a2->isa + HIDWORD(a2->isa->isa);
              v144 = v171 + 16;
              a2->isa = (__objc2_class *)(v171 + 16);
              v145 = v171 + 32;
              if (v145 > (char *)v142)
                goto LABEL_269;
              continue;
            }
            break;
          }
          if ((unint64_t)&v150->cache > v155)
            goto LABEL_272;
          v161 = HIDWORD(v150->isa);
          if ((unint64_t)&v150->cache + v161 > v155 || v151 != 17 && v152 != 32)
            goto LABEL_272;
          v162 = v150->superclass;
          if ((_DWORD)v162)
          {
            if (v151 == 17)
            {
              v163 = (unint64_t)v162 >> 32;
              if (SHIDWORD(v162) <= 2310)
              {
                switch(HIDWORD(v162))
                {
                  case 0x30:
                    v164 = 20;
                    break;
                  case 0x31:
                    v164 = 24;
                    break;
                  case 0x81A:
LABEL_245:
                    v164 = 8;
                    break;
                  default:
                    goto LABEL_272;
                }
              }
              else
              {
                switch(HIDWORD(v162))
                {
                  case 0x907:
                    v164 = 4;
                    break;
                  case 0x908:
                  case 0x909:
                    goto LABEL_272;
                  case 0x90A:
                  case 0x90C:
                    goto LABEL_245;
                  case 0x90B:
                  case 0x90D:
                    v164 = 16;
                    break;
                  default:
                    if (HIDWORD(v162) != 2369)
                      goto LABEL_272;
                    v164 = 48;
                    break;
                }
              }
              if (v161 / v164 < v162 || v161 % v162 >= 0x10)
              {
LABEL_272:
                v156 = v149;
                v173 = *__error();
                _sa_logt();
                v174 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v341 = 0;
                  v74 = 2;
                  _os_log_error_impl(&dword_1B9BE0000, v174, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", v341, 2u);
                }
                else
                {
                  v74 = 2;
                }
                v11 = 0x1E0C99000;
LABEL_278:

                *__error() = v173;
                objc_autoreleasePoolPop(v156);
                p_cache = v302;
LABEL_279:
                superclass = v318;
LABEL_280:

                v9 = v282;
LABEL_281:
                objc_autoreleasePoolPop(v132);
                if ((_DWORD)v74)
                  goto LABEL_395;
LABEL_282:
                v126 = a2->superclass;
                v175 = (char *)a2->isa + HIDWORD(a2->isa->isa);
                v128 = v175 + 16;
                a2->isa = (__objc2_class *)(v175 + 16);
                v129 = v175 + 32;
                if (v129 > (char *)v126)
                  goto LABEL_387;
                continue;
              }
LABEL_253:
              if ((v163 - 2311) > 0x3A
                || ((1 << (v163 - 7)) & 0x400000000000079) == 0)
              {
                v11 = 0x1E0C99000;
                if ((v163 - 48) < 2 || (_DWORD)v163 == 2074)
                  goto LABEL_267;
                goto LABEL_257;
              }
LABEL_263:
              v11 = 0x1E0C99000;
              goto LABEL_267;
            }
            v165 = v161 - ((uint64_t)a2->isa->isa & 0xF);
            if (v161 < (unint64_t)((uint64_t)a2->isa->isa & 0xF))
              goto LABEL_272;
            if (v165 < v162)
              goto LABEL_272;
            v166 = v165 / v162;
            if (v165 % v162)
              goto LABEL_272;
            v163 = (unint64_t)v162 >> 32;
          }
          else
          {
            if ((_DWORD)v161)
              goto LABEL_272;
            v163 = (unint64_t)v162 >> 32;
            if (v151 == 17)
              goto LABEL_253;
LABEL_257:
            v166 = 0;
          }
          break;
        }
        if ((_DWORD)v163 == 2382)
        {
          contexta = v149;
          v167 = objc_alloc_init(MEMORY[0x1E0C99DE8]);

          if ((_DWORD)v162)
          {
            v168 = 0;
            v162 = (__objc2_class *)v162;
            v169 = MEMORY[0x1E0C809B0];
            do
            {
              *(_QWORD *)buf = v169;
              *(_QWORD *)&buf[8] = v85;
              *(_QWORD *)&buf[16] = __65__SASampleStore_parseKCDataExclavesIPCStackContainer_callstacks___block_invoke;
              v339 = &unk_1E71470E8;
              v146 = v167;
              v340 = v146;
              __65__SASampleStore_parseKCDataExclavesIPCStackContainer_callstacks___block_invoke((uint64_t)buf, v170, (_QWORD *)(p_superclass + v168));

              v168 += v166;
              v162 = (__objc2_class *)((char *)v162 - 1);
            }
            while (v162);
            v17 = &off_1B9CC2000;
            superclass = v318;
            v11 = 0x1E0C99000;
          }
          else
          {
            v146 = v167;
            v11 = 0x1E0C99000;
          }
          p_cache = v302;
          v149 = contexta;
          goto LABEL_267;
        }
        goto LABEL_263;
      }
LABEL_435:
      v257 = *__error();
      _sa_logt();
      v258 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v258, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = v309;
        *(_DWORD *)&buf[4] = cache;
        _os_log_error_impl(&dword_1B9BE0000, v258, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
      }

      *__error() = v257;
      _SASetCrashLogMessage(5977, "bad container type %u", v259, v260, v261, v262, v263, v264, cache);
      _os_crash();
      __break(1u);
      goto LABEL_438;
    }
    if (v95 == 2386)
    {
      v177 = v298;
      v178 = a2->isa;
      cache = (int)a2->isa->cache;
      if (cache == 2386)
      {
        v179 = v178->superclass;
        v180 = a2->superclass;
        v181 = (char *)v178 + HIDWORD(v178->isa);
        v182 = v181 + 16;
        a2->isa = (__objc2_class *)(v181 + 16);
        v183 = v181 + 32;
        v314 = v177;
        if (v183 > (char *)v180)
        {
          v184 = 0;
          goto LABEL_293;
        }
        v303 = v179;
        v319 = superclass;
        v187 = 0;
        v188 = 0;
        while (1)
        {
          if (&v183[v182[1]] > (char *)v180 || *v182 == -242132755)
          {
LABEL_368:
            if (!v187)
              goto LABEL_407;
            goto LABEL_369;
          }
          v189 = (void *)MEMORY[0x1BCCCC288]();
          v190 = v189;
          v191 = a2->isa;
          v192 = (int)a2->isa->isa;
          v193 = v192 & 0xFFFFFFF0;
          v194 = (v192 & 0xFFFFFFF0) == 0x20 ? 17 : LODWORD(a2->isa->isa);
          v195 = (v194 - 1) >= 6 ? (uint64_t)&a2->isa->cache : (uint64_t)&v191[1].superclass;
          if (v194 > 19)
            break;
          v196 = (unint64_t)a2->superclass;
          if (v194 == 17)
          {
            v307 = v187;
            if ((unint64_t)&v191->cache > v196)
              goto LABEL_371;
            v201 = HIDWORD(v191->isa);
            if ((unint64_t)&v191->cache + v201 > v196 || v192 != 17 && v193 != 32)
              goto LABEL_371;
            v202 = v191->superclass;
            if (!(_DWORD)v202)
            {
              if ((_DWORD)v201)
                goto LABEL_371;
              v203 = (unint64_t)v202 >> 32;
              if (v192 == 17)
                goto LABEL_352;
              goto LABEL_356;
            }
            if (v192 == 17)
            {
              v203 = (unint64_t)v202 >> 32;
              if (SHIDWORD(v202) <= 2310)
              {
                switch(HIDWORD(v202))
                {
                  case 0x30:
                    v204 = 20;
                    break;
                  case 0x31:
                    v204 = 24;
                    break;
                  case 0x81A:
LABEL_344:
                    v204 = 8;
                    break;
                  default:
                    goto LABEL_371;
                }
              }
              else
              {
                switch(HIDWORD(v202))
                {
                  case 0x907:
                    v204 = 4;
                    break;
                  case 0x908:
                  case 0x909:
                    goto LABEL_371;
                  case 0x90A:
                  case 0x90C:
                    goto LABEL_344;
                  case 0x90B:
                  case 0x90D:
                    v204 = 16;
                    break;
                  default:
                    if (HIDWORD(v202) != 2369)
                      goto LABEL_371;
                    v204 = 48;
                    break;
                }
              }
              if (v201 / v204 < v202 || v201 % v202 >= 0x10)
              {
LABEL_371:
                v217 = v9;
                v218 = *__error();
                _sa_logt();
                v219 = objc_claimAutoreleasedReturnValue();
                v184 = v188;
                if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v341 = 0;
                  v74 = 2;
                  _os_log_error_impl(&dword_1B9BE0000, v219, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", v341, 2u);
                }
                else
                {
                  v74 = 2;
                }
                goto LABEL_380;
              }
LABEL_352:
              if (((v203 - 2311) > 0x3A
                 || ((1 << (v203 - 7)) & 0x400000000000079) == 0)
                && (v203 - 48) >= 2
                && (_DWORD)v203 != 2074)
              {
LABEL_356:
                v206 = 0;
                goto LABEL_357;
              }
            }
            else
            {
              v205 = v201 - ((uint64_t)a2->isa->isa & 0xF);
              if (v201 < (unint64_t)((uint64_t)a2->isa->isa & 0xF))
                goto LABEL_371;
              if (v205 < v202)
                goto LABEL_371;
              v206 = v205 / v202;
              if (v205 % v202)
                goto LABEL_371;
              v203 = (unint64_t)v202 >> 32;
LABEL_357:
              if ((_DWORD)v203 == 2388)
              {
                objb = v189;
                v283 = v9;
                if (!v188)
                  v188 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
                if ((_DWORD)v202)
                {
                  v207 = 0;
                  v208 = v202;
                  v209 = MEMORY[0x1E0C809B0];
                  do
                  {
                    *(_QWORD *)buf = v209;
                    *(_QWORD *)&buf[8] = v85;
                    *(_QWORD *)&buf[16] = __68__SASampleStore_parseKCDataExclavesTextLayoutContainer_textLayouts___block_invoke;
                    v339 = &unk_1E7147110;
                    v210 = v188;
                    v340 = v210;
                    __68__SASampleStore_parseKCDataExclavesTextLayoutContainer_textLayouts___block_invoke((uint64_t)buf, v211, v195 + v207);

                    v207 += v206;
                    --v208;
                  }
                  while (v208);
                  v188 = v210;
                }
                v9 = v283;
                v190 = objb;
              }
            }
            v187 = v307;
LABEL_366:
            objc_autoreleasePoolPop(v190);
            goto LABEL_367;
          }
          if (v194 != 19)
            goto LABEL_366;
          v197 = &v191->cache;
          if ((unint64_t)&v191->cache > v196
            || (v198 = HIDWORD(v191->isa), (unint64_t)v197 + v198 > v196)
            || (v193 != 32 ? (v199 = v192 == 19) : (v199 = 0), v199 ? (v200 = v198 > 3) : (v200 = 0), !v200))
          {
            v217 = v9;
            v218 = *__error();
            _sa_logt();
            v219 = objc_claimAutoreleasedReturnValue();
            v184 = v188;
            if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v341 = 67109120;
              *(_DWORD *)&v341[4] = 2386;
              _os_log_error_impl(&dword_1B9BE0000, v219, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", v341, 8u);
            }
            v74 = 1;
            goto LABEL_380;
          }
          v74 = SkipToContainerEnd((int **)a2, 1);
          objc_autoreleasePoolPop(v190);
          if ((_DWORD)v74)
          {
            v184 = v188;
            goto LABEL_370;
          }
LABEL_367:
          v180 = a2->superclass;
          v212 = (char *)a2->isa + HIDWORD(a2->isa->isa);
          v182 = v212 + 16;
          a2->isa = (__objc2_class *)(v212 + 16);
          v183 = v212 + 32;
          if (v183 > (char *)v180)
            goto LABEL_368;
        }
        if (v194 == 2387)
        {
          v187 = v195;
        }
        else if (v194 == 20)
        {
          v236 = v191->superclass;
          if (v303 != v236)
          {
            v217 = v9;
            v218 = *__error();
            _sa_logt();
            v219 = objc_claimAutoreleasedReturnValue();
            v184 = v188;
            if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v341 = 134218240;
              *(_QWORD *)&v341[4] = v303;
              *(_WORD *)&v341[12] = 2048;
              *(_QWORD *)&v341[14] = v236;
              _os_log_error_impl(&dword_1B9BE0000, v219, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", v341, 0x16u);
            }
            v74 = 7;
LABEL_380:

            *__error() = v218;
            objc_autoreleasePoolPop(v190);
            v9 = v217;
            v17 = &off_1B9CC2000;
            superclass = v319;
            goto LABEL_381;
          }
          objc_autoreleasePoolPop(v189);
          if (!v187)
          {
LABEL_407:
            v184 = v188;
            v17 = &off_1B9CC2000;
            superclass = v319;
LABEL_293:
            v185 = *__error();
            _sa_logt();
            v186 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v186, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v341 = 0;
              _os_log_error_impl(&dword_1B9BE0000, v186, OS_LOG_TYPE_ERROR, "No exclave_textlayout_info in textlayout container", v341, 2u);
            }

            *__error() = v185;
            v74 = 1;
LABEL_381:

            v11 = 0x1E0C99000;
            goto LABEL_402;
          }
LABEL_369:
          v184 = v188;
          v213 = -[SAKCDataExclaveTextLayout initWithInfo:textSegments:]([SAKCDataExclaveTextLayout alloc], v187, v188);
          v214 = (_QWORD *)v187;
          v215 = v213;
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v214);
          v216 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v314, "setObject:forKeyedSubscript:", v215, v216);

          v74 = 0;
LABEL_370:
          v17 = &off_1B9CC2000;
          superclass = v319;
          goto LABEL_381;
        }
        goto LABEL_366;
      }
LABEL_438:
      v265 = *__error();
      _sa_logt();
      v266 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v266, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = v309;
        *(_DWORD *)&buf[4] = cache;
        _os_log_error_impl(&dword_1B9BE0000, v266, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
      }

      *__error() = v265;
      _SASetCrashLogMessage(6323, "bad container type %u", v267, v268, v269, v270, v271, v272, cache);
      _os_crash();
      __break(1u);
LABEL_441:
      v273 = *__error();
      _sa_logt();
      v274 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v274, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = v309;
        *(_DWORD *)&buf[4] = cache;
        _os_log_error_impl(&dword_1B9BE0000, v274, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
      }

      *__error() = v273;
      _SASetCrashLogMessage(6083, "bad container type %u", v275, v276, v277, v278, v279, v280, cache);
      _os_crash();
      __break(1u);
    }
    if (v95 != 2383)
    {
      v74 = SkipToContainerEnd((int **)a2, 1);
      goto LABEL_402;
    }
    v317 = superclass;
    v96 = v9;
    v97 = v300;
    v98 = a2->isa;
    cache = (int)a2->isa->cache;
    if (cache != 2383)
      goto LABEL_432;
    v99 = v97;
    v100 = v98->superclass;
    v101 = a2->superclass;
    v102 = (char *)v98 + HIDWORD(v98->isa);
    v103 = v102 + 16;
    a2->isa = (__objc2_class *)(v102 + 16);
    v104 = v102 + 32;
    if (v104 > (char *)v101)
      goto LABEL_398;
    v305 = v100;
    v105 = 0;
    v312 = 0;
    while (1)
    {
      if (&v104[v103[1]] > (char *)v101 || *v103 == -242132755)
      {
LABEL_164:
        if (!v105)
          goto LABEL_398;
        goto LABEL_165;
      }
      v106 = (void *)MEMORY[0x1BCCCC288]();
      v107 = v106;
      v108 = a2->isa;
      v109 = (int)a2->isa->isa;
      if ((v109 & 0xFFFFFFF0) == 0x20)
        v110 = 17;
      else
        v110 = (int)a2->isa->isa;
      if ((v110 - 1) > 5)
      {
        if (v110 <= 2309)
        {
          if (v110 != 17 && v110 != 19)
            goto LABEL_139;
          v112 = HIDWORD(v108->isa);
          v116 = v112;
LABEL_142:
          v111 = &v108->cache;
          goto LABEL_143;
        }
        if (v110 == 2310)
        {
          v112 = HIDWORD(v108->isa);
          if (v112 == 112 && ((uint64_t)v108->superclass & 0x8F) == 0)
          {
            v116 = 104;
            goto LABEL_142;
          }
        }
        else
        {
          if (v110 != 2312)
          {
LABEL_139:
            v112 = HIDWORD(v108->isa);
            goto LABEL_140;
          }
          v112 = HIDWORD(v108->isa);
          if (v112 == 32 && ((uint64_t)v108->superclass & 0x8F) == 0)
          {
            v116 = 24;
            goto LABEL_142;
          }
        }
LABEL_140:
        v118 = (uint64_t)v108->superclass & 0xF;
        v114 = v112 >= v118;
        v116 = v112 - v118;
        if (!v114)
          v116 = 0;
        goto LABEL_142;
      }
      v111 = &v108[1].superclass;
      v112 = HIDWORD(v108->isa);
      v113 = (uint64_t)v108->superclass & 0xF;
      v114 = v112 >= v113;
      v115 = v112 - v113;
      if (!v114)
        v115 = 0;
      v116 = v115 - 32;
LABEL_143:
      if (v110 > 2383)
      {
        if (v110 == 2385)
        {
          if (*((_BYTE *)v111 + (v116 - 1)))
          {
            v121 = *__error();
            _sa_logt();
            v122 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1B9BE0000, v122, OS_LOG_TYPE_DEFAULT, "WARNING: exclave address space name non NULL-terminated", buf, 2u);
            }

            *__error() = v121;
          }
          else
          {
            v312 = (uint64_t)v111;
          }
        }
        else if (v110 == 2384)
        {
          v105 = v111;
        }
        goto LABEL_162;
      }
      if (v110 != 19)
        break;
      v119 = a2->superclass;
      v120 = (__objc2_class *)&v108->cache;
      if (v120 > v119
        || (__objc2_class *)((char *)v120 + v112) > v119
        || (v109 & 0xFFFFFFF0) == 0x20
        || v109 != 19
        || v112 <= 3)
      {
        v222 = *__error();
        _sa_logt();
        v223 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v223, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = 2383;
          _os_log_error_impl(&dword_1B9BE0000, v223, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
        }
        v74 = 1;
        goto LABEL_414;
      }
      v74 = SkipToContainerEnd((int **)a2, 1);
      objc_autoreleasePoolPop(v107);
      if ((_DWORD)v74)
        goto LABEL_401;
LABEL_163:
      v101 = a2->superclass;
      v123 = (char *)a2->isa + HIDWORD(a2->isa->isa);
      v103 = v123 + 16;
      a2->isa = (__objc2_class *)(v123 + 16);
      v104 = v123 + 32;
      if (v104 > (char *)v101)
        goto LABEL_164;
    }
    if (v110 != 20)
    {
LABEL_162:
      objc_autoreleasePoolPop(v107);
      goto LABEL_163;
    }
    v232 = v108->superclass;
    if (v305 == v232)
    {
      objc_autoreleasePoolPop(v106);
      if (!v105)
      {
LABEL_398:
        v233 = *__error();
        _sa_logt();
        v234 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v234, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1B9BE0000, v234, OS_LOG_TYPE_ERROR, "No exclave_addressspace_info in addressspace container", buf, 2u);
        }

        *__error() = v233;
        v74 = 1;
        goto LABEL_401;
      }
LABEL_165:
      v124 = -[SAKCDataExclaveAddressSpace initWithInfo:name:]([SAKCDataExclaveAddressSpace alloc], (uint64_t)v105, v312);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v105);
      v125 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v99, "setObject:forKeyedSubscript:", v124, v125);

      v74 = 0;
      goto LABEL_401;
    }
    v222 = *__error();
    _sa_logt();
    v223 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v223, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v305;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v232;
      _os_log_error_impl(&dword_1B9BE0000, v223, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
    }
    v74 = 7;
LABEL_414:

    *__error() = v222;
    objc_autoreleasePoolPop(v107);
LABEL_401:
    v11 = 0x1E0C99000;

    v9 = v96;
    superclass = v317;
LABEL_402:
    objc_autoreleasePoolPop(v87);
    if (!(_DWORD)v74)
    {
LABEL_403:
      v13 = a2->superclass;
      v235 = (char *)a2->isa + HIDWORD(a2->isa->isa);
      v15 = v235 + 16;
      a2->isa = (__objc2_class *)(v235 + 16);
      v16 = v235 + 32;
      if (v16 > (char *)v13)
        goto LABEL_3;
      continue;
    }
    break;
  }
LABEL_423:

  return v74;
}

- (uint64_t)addKCDataThreadV4:(uint64_t)a3 threadV2:(uint64_t)a4 deltaThreadV3:(uint64_t)a5 deltaThreadV2:(void *)a6 timestamp:(unint64_t)a7 sampleIndex:(void *)a8 stack:(void *)a9 threadExclavesInfo:(char *)a10 threadName:(id *)a11 dispatchQueueLabel:(uint64_t)a12 waitInfo:(_QWORD *)a13 waitInfoPortLabelInfo:(uint64_t)a14 turnstileInfo:(_QWORD *)a15 turnstileInfoPortLabelInfo:(uint64_t *)a16 instructionCycles:(void *)a17 task:(void *)a18 kernelTask:(char)a19 taskIsSuspended:
{
  id v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  void *v30;
  id *v31;
  _BYTE *v32;
  _BYTE *v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  const char *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  int v42;
  int v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  _BOOL4 v47;
  int v48;
  NSObject *v49;
  void *v50;
  void *v51;
  void *v52;
  int v53;
  unsigned __int8 *v54;
  uint64_t v55;
  id v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  id v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  id v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _DWORD *v80;
  int v81;
  __int16 *v82;
  int v83;
  __int16 *v84;
  int v85;
  _DWORD *v86;
  uint64_t v87;
  _QWORD *v88;
  int v89;
  unsigned __int8 *v90;
  int v91;
  unsigned __int8 *v92;
  int v93;
  unsigned __int8 *v94;
  int v95;
  unsigned __int8 *v96;
  int v97;
  _BYTE *v98;
  const char *v99;
  void *v100;
  const char *v101;
  id Property;
  id v103;
  uint64_t v104;
  uint64_t v105;
  _BOOL8 v106;
  id *v107;
  void *v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  void *v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  void *v116;
  void *v117;
  const char *v118;
  void *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  void *v130;
  _BYTE *v131;
  void *v132;
  const char *v133;
  void *v134;
  void *v135;
  _BYTE *v136;
  _BYTE *v137;
  _BYTE *v138;
  void *v139;
  _BYTE *v140;
  void *v141;
  void *v142;
  void *v143;
  void *v144;
  void *v145;
  uint64_t result;
  int v147;
  NSObject *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  NSObject *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  NSObject *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char v171;
  int v172;
  void *v173;
  int v174;
  int v175;
  id v176;
  void *v177;
  void *v178;
  uint64_t v179;
  void *v180;
  void *v181;
  void *v182;
  uint64_t v183;
  id *v184;
  void *v185;
  void *v187;
  id v188;
  id v189;
  id v190;
  void *v191;
  id v192;
  id v193;
  uint8_t buf[4];
  uint64_t v195;
  uint64_t v196;

  v196 = *MEMORY[0x1E0C80C00];
  v190 = a6;
  v189 = a8;
  v192 = a9;
  v25 = a17;
  v188 = a18;
  v191 = v25;
  if (!a1)
  {
LABEL_258:
    v46 = 0;
    v51 = v189;
    goto LABEL_251;
  }
  if (a2)
    v26 = a2;
  else
    v26 = a3;
  if (a4)
    v27 = a4;
  else
    v27 = a5;
  if (!a4 && !a2 && !a3 && !a5)
  {
    v147 = *__error();
    _sa_logt();
    v148 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v148, OS_LOG_TYPE_ERROR, "no thread snap", buf, 2u);
    }

    *__error() = v147;
    _SASetCrashLogMessage(3060, "no thread snap", v149, v150, v151, v152, v153, v154, v171);
    _os_crash();
    __break(1u);
LABEL_255:
    v155 = *__error();
    _sa_logt();
    v156 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v195 = (uint64_t)a1;
      _os_log_error_impl(&dword_1B9BE0000, v156, OS_LOG_TYPE_ERROR, "dispatchQueueId 0, but dispatchQueueLabel %s", buf, 0xCu);
    }

    *__error() = v155;
    _SASetCrashLogMessage(3340, "dispatchQueueId 0, but dispatchQueueLabel %s", v157, v158, v159, v160, v161, v162, (char)a1);
    _os_crash();
    __break(1u);
    goto LABEL_258;
  }
  v183 = a3;
  v179 = a5;
  if (v26)
    v28 = (uint64_t *)v26;
  else
    v28 = (uint64_t *)v27;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v28);
  v29 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(v25, "threads");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v187 = (void *)v29;
  objc_msgSend(v30, "objectForKeyedSubscript:", v29);
  v31 = (id *)objc_claimAutoreleasedReturnValue();

  v184 = a1;
  if (!v31)
  {
    +[SAThread threadWithId:]((uint64_t)SAThread, *v28);
    v32 = (_BYTE *)objc_claimAutoreleasedReturnValue();
    v33 = v32;
    if (v26)
      v34 = v26 + 64;
    else
      v34 = v27 + 16;
    if (v32)
      v32[16] = *(_BYTE *)(v34 + 1) & 1;
    -[SATask addThread:]((uint64_t)v25, v32);
    if ((*(_BYTE *)(v34 + 1) & 0x20) != 0)
    {
      objc_msgSend(v25, "mainThread");
      v35 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v35)
      {
        if (v33)
          v33[17] = 1;
        if (v25)
          objc_setProperty_atomic(v25, v36, v33, 264);
      }
    }
    if (!objc_msgSend(a1[3], "count"))
      goto LABEL_41;
    if (*((_BYTE *)a1 + 223))
    {
      objc_msgSend(v25, "taskStates");
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      if ((unint64_t)objc_msgSend(v38, "count") < 2)
      {
        objc_msgSend(v25, "taskStates");
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v39, "firstObject");
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v40, "startTimestamp");
        v41 = (void *)objc_claimAutoreleasedReturnValue();
        v42 = objc_msgSend(v41, "lt:", v190);

        a1 = v184;
        if (!v42)
          goto LABEL_41;
      }
      else
      {

      }
    }
    if (*((_BYTE *)a1 + 221))
    {
      v43 = objc_msgSend(v33, "isMainThread");
      if (v43)
        v31 = 0;
      else
        v31 = (id *)v33;
      if (!v33 || (v43 & 1) == 0)
        goto LABEL_42;
    }
    else if (!v33)
    {
      v31 = 0;
      goto LABEL_42;
    }
    objc_setProperty_atomic(v33, v37, v190, 32);
LABEL_41:
    v31 = (id *)v33;
  }
LABEL_42:
  objc_msgSend(v31, "threadStates");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v44, "lastObject");
  v45 = objc_claimAutoreleasedReturnValue();
  v46 = v26 | v45;

  v47 = v45 != 0;
  if (!(v26 | v45))
  {
    v51 = v189;
    v50 = v187;
LABEL_250:

LABEL_251:
    return v46;
  }
  if (v45 && objc_msgSend((id)v45, "endSampleIndex") == a7)
  {
    v48 = *__error();
    _sa_logt();
    v49 = objc_claimAutoreleasedReturnValue();
    v50 = v187;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v195 = objc_msgSend(v31, "threadId");
      _os_log_error_impl(&dword_1B9BE0000, v49, OS_LOG_TYPE_ERROR, "Already saw thread 0x%llx in this stackshot, ignoring second instance", buf, 0xCu);
    }

    v46 = 0;
    *__error() = v48;
    goto LABEL_249;
  }
  v52 = a13;
  if ((a19 & 1) != 0)
  {
    v53 = 1;
  }
  else
  {
    v54 = (unsigned __int8 *)(v26 + 64);
    if (!v26)
      v54 = (unsigned __int8 *)(v27 + 16);
    v53 = (*v54 >> 6) & 1;
  }
  v172 = v53;
  if (v26)
  {
    if (v45)
    {
      objc_msgSend((id)v45, "name");
      v55 = objc_claimAutoreleasedReturnValue();

      v47 = ((unint64_t)a10 | v55) == 0;
      if (a10)
      {
        if (v55)
        {
          objc_msgSend((id)v45, "name");
          v56 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v47 = strcmp(a10, (const char *)objc_msgSend(v56, "UTF8String")) == 0;

        }
      }
    }
  }
  if (a13)
  {
    v57 = (void *)a13[1];
    if (!v57)
    {
      v52 = 0;
      if (v45)
        goto LABEL_63;
LABEL_68:
      v175 = 0;
      goto LABEL_71;
    }
    SANSStringForCString(v57);
    v52 = (void *)objc_claimAutoreleasedReturnValue();
  }
  if (!v45)
    goto LABEL_68;
LABEL_63:
  objc_msgSend((id)v45, "waitInfo");
  v58 = objc_claimAutoreleasedReturnValue();

  v175 = (a12 | v58) == 0;
  if (a12 && v58)
  {
    objc_msgSend((id)v45, "waitInfo");
    v59 = objc_claimAutoreleasedReturnValue();
    v60 = (void *)v59;
    if (a13)
    {
      v61 = *(unsigned __int16 *)(*a13 + 2);
      v62 = *(unsigned __int8 *)(*a13 + 4);
    }
    else
    {
      v61 = 0;
      v62 = 0;
    }
    v175 = -[SAWaitInfo matchesKCDataWaitInfo:portName:flags:domain:](v59, a12, v52, v61, v62);

  }
LABEL_71:
  v173 = v52;
  if (a15 && (v63 = (void *)a15[1]) != 0)
  {
    SANSStringForCString(v63);
    v177 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v177 = 0;
  }
  if (v45)
  {
    objc_msgSend((id)v45, "turnstileInfo");
    v64 = objc_claimAutoreleasedReturnValue();

    v174 = (a14 | v64) == 0;
    if (a14 && v64)
    {
      objc_msgSend((id)v45, "turnstileInfo");
      v65 = objc_claimAutoreleasedReturnValue();
      v66 = (void *)v65;
      if (a15)
      {
        v67 = *(unsigned __int16 *)(*a15 + 2);
        v68 = *(unsigned __int8 *)(*a15 + 4);
      }
      else
      {
        v67 = 0;
        v68 = 0;
      }
      v174 = -[SATurnstileInfo matchesKCDataTurnstileInfo:portName:flags:domain:](v65, a14, v177, v67, v68);

    }
    if (!v26)
      goto LABEL_100;
    v70 = objc_msgSend((id)v45, "userTimeInNs");
    v71 = v184[23];
    if (!(_DWORD)v71 || !HIDWORD(v71))
      goto LABEL_99;
    v72 = v70;
    v73 = *(_QWORD *)(v26 + 48);
    if ((_DWORD)v71 != HIDWORD(v71))
      v73 = __udivti3();
    if (v72 >= v73)
    {
LABEL_99:
      v74 = objc_msgSend((id)v45, "systemTimeInNs");
      v75 = v184[23];
      if (!(_DWORD)v75 || !HIDWORD(v75))
        goto LABEL_269;
      v76 = v74;
      v77 = *(_QWORD *)(v26 + 56);
      if ((_DWORD)v75 != HIDWORD(v75))
        v77 = __udivti3();
      if (v76 >= v77)
      {
LABEL_269:
        if (!a16
          || (v78 = a16[1], v78 == objc_msgSend((id)v45, "cycles"))
          && (v79 = *a16, v79 == objc_msgSend((id)v45, "instructions")))
        {
          if ((*(_BYTE *)(v26 + 65) & 8) == 0)
          {
LABEL_100:
            v69 = *(_DWORD *)(v45 + 40);
LABEL_101:
            v80 = (_DWORD *)(v26 + 88);
            if (!v26)
              v80 = (_DWORD *)(v27 + 32);
            if (v69 == *v80)
            {
              v81 = objc_msgSend((id)v45, "basePriority");
              v82 = (__int16 *)(v26 + 96);
              if (!v26)
                v82 = (__int16 *)(v27 + 40);
              if (v81 == *v82)
              {
                v83 = objc_msgSend((id)v45, "scheduledPriority");
                v84 = (__int16 *)(v26 + 98);
                if (!v26)
                  v84 = (__int16 *)(v27 + 42);
                if (v83 == *v84)
                {
                  v85 = objc_msgSend((id)v45, "schedulerFlags");
                  v86 = (_DWORD *)(v26 + 92);
                  if (!v26)
                    v86 = (_DWORD *)(v27 + 36);
                  if (v85 == *v86)
                  {
                    v87 = objc_msgSend((id)v45, "voucherIdentifier");
                    v88 = (_QWORD *)(v26 + 32);
                    if (!v26)
                      v88 = (_QWORD *)(v27 + 8);
                    if (v87 == *v88)
                    {
                      v89 = objc_msgSend((id)v45, "threadQos");
                      v90 = (unsigned __int8 *)(v26 + 100);
                      if (!v26)
                        v90 = (unsigned __int8 *)(v27 + 44);
                      if (v89 == *v90)
                      {
                        v91 = objc_msgSend((id)v45, "threadRequestedQos");
                        v92 = (unsigned __int8 *)(v26 + 101);
                        if (!v26)
                          v92 = (unsigned __int8 *)(v27 + 45);
                        if (v91 == *v92)
                        {
                          v93 = objc_msgSend((id)v45, "threadRequestedQosOverride");
                          v94 = (unsigned __int8 *)(v26 + 102);
                          if (!v26)
                            v94 = (unsigned __int8 *)(v27 + 46);
                          if (v93 == *v94)
                          {
                            v95 = objc_msgSend((id)v45, "ioTier");
                            v96 = (unsigned __int8 *)(v26 + 103);
                            if (!v26)
                              v96 = (unsigned __int8 *)(v27 + 47);
                            if (v95 == *v96)
                            {
                              v97 = objc_msgSend((id)v45, "isDarwinBG");
                              v98 = (_BYTE *)(v26 ? v26 + 64 : v27 + 16);
                              if (v97 != ((*v98 & 0x10) == 0)
                                && objc_msgSend((id)v45, "isIOPassive") != ((*v98 & 0x20) == 0)
                                && objc_msgSend((id)v45, "isIdleWorkQueue") != ((v98[1] & 0x10) == 0)
                                && objc_msgSend((id)v45, "isRunning") != ((v98[1] & 8) == 0)
                                && v172 == objc_msgSend((id)v45, "isSuspended")
                                && v47
                                && ((v175 ^ 1) & 1) == 0
                                && ((v174 ^ 1) & 1) == 0)
                              {
                                if (v45)
                                  objc_setProperty_atomic((id)v45, v99, v190, 56);
                                -[SAThreadState setEndSampleIndex:](v45, a7);
                                objc_msgSend((id)v45, "dispatchQueue");
                                v100 = (void *)objc_claimAutoreleasedReturnValue();
                                v46 = objc_msgSend(v100, "identifier");

                                v50 = v187;
                                goto LABEL_248;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            objc_msgSend((id)v45, "leafUserFrame");
            v181 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend((id)v45, "leafOfCRootFramesReplacedBySwiftAsync");
            v176 = (id)objc_claimAutoreleasedReturnValue();
            objc_msgSend((id)v45, "leafKernelFrame");
            v180 = (void *)objc_claimAutoreleasedReturnValue();
            if (v45)
              Property = objc_getProperty((id)v45, v101, 176, 1);
            else
              Property = 0;
            v103 = Property;

            v192 = v103;
            v104 = (uint64_t)a16;
            if (!v47)
              goto LABEL_145;
LABEL_157:
            objc_msgSend((id)v45, "name");
            v105 = objc_claimAutoreleasedReturnValue();
            goto LABEL_158;
          }
        }
      }
    }
  }
  else
  {
    if (!v26)
    {
      v174 = 0;
      v69 = 0;
      goto LABEL_101;
    }
    v174 = 0;
  }
  objc_msgSend(v189, "setContinuation:", *(_QWORD *)(v26 + 16));
  v106 = (*(_WORD *)(v26 + 64) & 0x8080) != 0
      || objc_msgSend(v191, "pid") && !objc_msgSend(v189, "hasUserStack");
  objc_msgSend(v189, "setIsUserStackTruncated:", v106);
  objc_msgSend(v189, "setIsSwiftAsyncStackTruncated:", (*(_QWORD *)(v26 + 64) >> 16) & 1);
  objc_msgSend(v189, "setIsKernelStackTruncated:", (*(_QWORD *)(v26 + 64) >> 14) & 1);
  if (objc_msgSend(v191, "pid"))
  {
    v193 = 0;
    -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v191, v189, &v193);
    v181 = (void *)objc_claimAutoreleasedReturnValue();
    v176 = v193;
  }
  else
  {
    v181 = 0;
    v176 = 0;
  }
  v104 = (uint64_t)a16;
  -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v188, v189, 0);
  v180 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    goto LABEL_157;
LABEL_145:
  if (!a10)
  {
    v182 = 0;
    goto LABEL_159;
  }
  SANSStringForCString(a10);
  v105 = objc_claimAutoreleasedReturnValue();
LABEL_158:
  v182 = (void *)v105;
LABEL_159:
  v107 = v184;
  v108 = v176;
  if (v175)
  {
    objc_msgSend((id)v45, "waitInfo");
    v109 = objc_claimAutoreleasedReturnValue();
  }
  else
  {
    if (!a12)
    {
      v112 = 0;
      goto LABEL_168;
    }
    if (a13)
    {
      v110 = *(unsigned __int16 *)(*a13 + 2);
      v111 = *(unsigned __int8 *)(*a13 + 4);
    }
    else
    {
      v110 = 0;
      v111 = 0;
    }
    +[SAWaitInfo waitInfoWithKCDataWaitInfo:portName:flags:domain:]((uint64_t)SAWaitInfo, a12, v52, v110, v111);
    v109 = objc_claimAutoreleasedReturnValue();
  }
  v112 = (void *)v109;
LABEL_168:
  if (v174)
  {
    objc_msgSend((id)v45, "turnstileInfo");
    v113 = objc_claimAutoreleasedReturnValue();
  }
  else
  {
    if (!a14)
    {
      v116 = 0;
      goto LABEL_177;
    }
    if (a15)
    {
      v114 = *(unsigned __int16 *)(*a15 + 2);
      v115 = *(unsigned __int8 *)(*a15 + 4);
    }
    else
    {
      v114 = 0;
      v115 = 0;
    }
    +[SATurnstileInfo turnstileInfoWithKCDataTurnstileInfo:portName:flags:domain:]((uint64_t)SATurnstileInfo, a14, v177, v114, v115);
    v113 = objc_claimAutoreleasedReturnValue();
  }
  v116 = (void *)v113;
LABEL_177:
  v185 = v116;
  if (a2)
  {
    +[SAThreadState stateWithKCDataThreadV4:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:machTimebase:waitInfo:turnstileInfo:threadPolicyVersion:threadInstructionCycles:]((uint64_t)SAThreadState, a2, v190, v190, a7, a7, v182, v181, v176, v180, (uint64_t)v107[23], v112, v116, *((_DWORD *)v107 + 50), v104);
    v117 = (void *)objc_claimAutoreleasedReturnValue();
    goto LABEL_185;
  }
  if (v183)
  {
    +[SAThreadState stateWithKCDataThreadV2:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:machTimebase:waitInfo:turnstileInfo:]((uint64_t)SAThreadState, v183, v190, v190, a7, a7, v182, v181, v176, v180, (uint64_t)v107[23], v112, v116);
    v117 = (void *)objc_claimAutoreleasedReturnValue();
    goto LABEL_185;
  }
  if (a4)
  {
    +[SAThreadState stateWithKCDataDeltaThreadV3:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:oldThreadState:waitInfo:turnstileInfo:threadPolicyVersion:]((uint64_t)SAThreadState, a4, v190, v190, a7, a7, v182, v181, v176, v180, (void *)v45, v112, v116, *((_DWORD *)v107 + 50));
    v117 = (void *)objc_claimAutoreleasedReturnValue();
    goto LABEL_185;
  }
  if (v179)
  {
    +[SAThreadState stateWithKCDataDeltaThreadV2:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:oldThreadState:waitInfo:turnstileInfo:]((uint64_t)SAThreadState, v179, v190, v190, a7, a7, v182, v181, v176, v180, (void *)v45, v112, v116);
    v117 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_185:
    v119 = v117;
    if (v117)
    {
      objc_setProperty_atomic(v117, v118, v192, 176);
      if (v172)
        *((_BYTE *)v119 + 11) |= 0x40u;
    }
    if (v45)
    {
      v120 = objc_msgSend((id)v45, "userTimeInNs");
      if (v120 > objc_msgSend(v119, "userTimeInNs"))
      {
        v121 = objc_msgSend((id)v45, "userTimeInNs");
        if (v119)
          *((_QWORD *)v119 + 17) = v121;
      }
      v122 = objc_msgSend((id)v45, "systemTimeInNs");
      if (v122 > objc_msgSend(v119, "systemTimeInNs"))
      {
        v123 = objc_msgSend((id)v45, "systemTimeInNs");
        if (v119)
          *((_QWORD *)v119 + 18) = v123;
      }
      v124 = objc_msgSend((id)v45, "cycles");
      if (v124 > objc_msgSend(v119, "cycles"))
      {
        v125 = objc_msgSend((id)v45, "cycles");
        if (v119)
          *((_QWORD *)v119 + 20) = v125;
      }
      v126 = objc_msgSend((id)v45, "instructions");
      if (v126 > objc_msgSend(v119, "instructions"))
      {
        v127 = objc_msgSend((id)v45, "instructions");
        if (v119)
          *((_QWORD *)v119 + 19) = v127;
      }
    }
    if (v31)
    {
      objc_msgSend(v31[1], "addObject:", v119);
      v128 = objc_msgSend(v31[1], "count") - 1;
    }
    else
    {
      v128 = 0;
    }
    v178 = v112;
    if (!v26)
    {
      objc_msgSend((id)v45, "dispatchQueue");
      v137 = (_BYTE *)objc_claimAutoreleasedReturnValue();
      v138 = v137;
      if (v137)
      {
        v46 = objc_msgSend(v137, "identifier");
        if (v119)
          objc_storeWeak((id *)v119 + 14, v138);
        +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, v31, v128);
        v139 = (void *)objc_claimAutoreleasedReturnValue();
        if (v138[24])
          v140 = 0;
        else
          v140 = v138 + 24;
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v138, v139, v140);

      }
      else
      {
        v46 = 0;
      }

      objc_msgSend((id)v45, "swiftTask");
      v141 = (void *)objc_claimAutoreleasedReturnValue();
      if (v141)
      {
        if (v119)
          objc_storeWeak((id *)v119 + 15, v141);
        +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, v31, v128);
        v145 = (void *)objc_claimAutoreleasedReturnValue();
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v141, v145, 0);

      }
      goto LABEL_246;
    }
    a1 = a11;
    v46 = *(_QWORD *)(v26 + 40);
    if (v46)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v46);
      v129 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v191, "dispatchQueues");
      v130 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v130, "objectForKeyedSubscript:", v129);
      v131 = (_BYTE *)objc_claimAutoreleasedReturnValue();

      if (!v131)
      {
        +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SADispatchQueue, v46);
        v131 = (_BYTE *)objc_claimAutoreleasedReturnValue();
        -[SATask addDispatchQueue:]((uint64_t)v191, v131);
      }
      if (a11)
      {
        objc_msgSend(v131, "dispatchQueueLabel");
        v132 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v132)
        {
          SANSStringForCString(a11);
          v134 = (void *)objc_claimAutoreleasedReturnValue();
          if (v134 && v131)
            objc_setProperty_atomic_copy(v131, v133, v134, 32);

        }
      }
      if (v119)
        objc_storeWeak((id *)v119 + 14, v131);
      +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, v31, v128);
      v135 = (void *)objc_claimAutoreleasedReturnValue();
      v108 = v176;
      if (v131)
      {
        if (v131[24])
          v136 = 0;
        else
          v136 = v131 + 24;
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v131, v135, v136);
      }

      if (!v176)
      {
        if (!v119)
          goto LABEL_247;
        goto LABEL_240;
      }
LABEL_233:
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", -1);
      v141 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v191, "swiftTasks");
      v142 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v142, "objectForKeyedSubscript:", v141);
      v143 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v143)
      {
        +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, -1);
        v143 = (void *)objc_claimAutoreleasedReturnValue();
        -[SATask addSwiftTask:]((uint64_t)v191, v143);
      }
      if (v119)
        objc_storeWeak((id *)v119 + 15, v143);
      +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, v31, v128);
      v144 = (void *)objc_claimAutoreleasedReturnValue();
      if (v143)
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v143, v144, 0);

LABEL_246:
      goto LABEL_247;
    }
    if (!a11)
    {
      if (v119)
      {
        objc_storeWeak((id *)v119 + 14, 0);
        v108 = v176;
        if (!v176)
        {
LABEL_240:
          objc_storeWeak((id *)v119 + 15, 0);
LABEL_247:
          v50 = v187;

LABEL_248:
LABEL_249:
          v51 = v189;
          goto LABEL_250;
        }
      }
      else
      {
        v108 = v176;
        if (!v176)
        {
          v46 = 0;
          goto LABEL_247;
        }
      }
      goto LABEL_233;
    }
    goto LABEL_255;
  }
  v163 = *__error();
  _sa_logt();
  v164 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1B9BE0000, v164, OS_LOG_TYPE_ERROR, "no thread snap later", buf, 2u);
  }

  *__error() = v163;
  _SASetCrashLogMessage(3286, "no thread snap later", v165, v166, v167, v168, v169, v170, v171);
  result = _os_crash();
  __break(1u);
  return result;
}

- (void)addProcessInfoFromTailspin:(id)a3
{
  id v4;
  _BYTE *v5;
  void *v6;
  int v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  char v18;
  uint64_t v19;
  _BOOL4 v20;
  void *v21;
  void *v22;
  id v23;
  char v24;
  void *v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  objc_msgSend(v4, "objectForKeyedSubscript:", 0x1E714AC10);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  -[SASampleStore lastTaskWithPid:](self, objc_msgSend(v26, "intValue"));
  v5 = (_BYTE *)objc_claimAutoreleasedReturnValue();
  if (v5)
  {
    objc_msgSend(v4, "objectForKeyedSubscript:", 0x1E714AC30);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      v23 = v4;
      if (objc_msgSend(v5, "pid"))
        LOBYTE(v7) = 1;
      else
        v7 = CSArchitectureIsArm64() ^ 1;
      v24 = v7;
      v25 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", objc_msgSend(v6, "count"));
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v22 = v6;
      v8 = v6;
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
      if (v9)
      {
        v10 = v9;
        v11 = *(_QWORD *)v28;
        do
        {
          v12 = 0;
          do
          {
            if (*(_QWORD *)v28 != v11)
              objc_enumerationMutation(v8);
            v13 = *(void **)(*((_QWORD *)&v27 + 1) + 8 * v12);
            objc_msgSend(v8, "objectForKeyedSubscript:", v13, v22);
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            uuidForString(v13);
            v15 = (void *)objc_claimAutoreleasedReturnValue();
            if (v15)
            {
              +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v15, 0);
              v16 = (void *)objc_claimAutoreleasedReturnValue();
              -[SABinary segmentWithCleanName:](v16, CFSTR("__TEXT_EXEC"));
              v17 = (void *)objc_claimAutoreleasedReturnValue();
              v18 = v24;
              if (v17)
                v18 = 1;
              if ((v18 & 1) == 0)
              {
                if (addProcessInfoFromTailspin__onceToken != -1)
                  dispatch_once(&addProcessInfoFromTailspin__onceToken, &__block_literal_global_206);
                +[SASegment segmentWithBinary:name:length:]((uint64_t)SASegment, v16, CFSTR("__TEXT_EXEC"), 0);
                v17 = (void *)objc_claimAutoreleasedReturnValue();
                -[SABinary addSegment:](v16, v17);
              }
              v19 = objc_msgSend(v14, "unsignedLongLongValue");
              v20 = objc_msgSend(v26, "intValue") == 0;
              if (v17)
                +[SABinaryLoadInfo binaryLoadInfoWithSegment:loadAddress:isInKernelAddressSpace:exclave:](SABinaryLoadInfo, v17, v19, v20, 0);
              else
                +[SABinaryLoadInfo binaryLoadInfoWithBinary:loadAddress:isInKernelAddressSpace:exclave:]((uint64_t)SABinaryLoadInfo, v16, v19, v20, 0);
              v21 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v25, "addObject:", v21);

            }
            ++v12;
          }
          while (v10 != v12);
          v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
        }
        while (v10);
      }

      -[SATask addImageInfos:]((uint64_t)v5, v25);
      v5[73] = 1;

      v4 = v23;
      v6 = v22;
    }

  }
}

size_t __44__SASampleStore_addProcessInfoFromTailspin___block_invoke()
{
  return fwrite("Assuming 64-bit arm kernel binaries all have TEXT_EXEC segments...\n", 0x43uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
}

- (unint64_t)addKCDataStackshots:(id)a3 createSeparateSamplePerStackshot:(BOOL)a4
{
  _BOOL4 v4;
  id v6;
  void *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  id v13;
  id v14;
  void *v15;
  uint64_t v16;
  SATimestamp *startTime;
  int v18;
  NSObject *v19;
  const char *v20;
  SATimestamp *v21;
  __int128 v23;
  id *location;
  id *p_endTime;
  id *p_timeWhenTransitionedToSamplingAllThreads;
  id *p_timeWhenTransitionedToSamplingAllProcesses;
  SASampleStore *v28;
  unint64_t v29;
  char v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  const char *v34;
  uint64_t v35;

  v4 = a4;
  v35 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  location = (id *)&self->_startTime;
  p_endTime = (id *)&self->_endTime;
  p_timeWhenTransitionedToSamplingAllThreads = (id *)&self->_timeWhenTransitionedToSamplingAllThreads;
  p_timeWhenTransitionedToSamplingAllProcesses = (id *)&self->_timeWhenTransitionedToSamplingAllProcesses;
  v10 = 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)&v11 = 134218242;
  v23 = v11;
  v28 = self;
  do
  {
    if (v8 >= objc_msgSend(v6, "length", v23))
      break;
    if (v4 || !v7)
    {
      +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, 0.0);
      v12 = objc_claimAutoreleasedReturnValue();

      if (-[SASampleStore dataStyle](self, "dataStyle") == 1)
        v10 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v10 = -[NSMutableArray count](self->_sampleTimestamps, "count");
      v7 = (void *)v12;
    }
    v30 = 0;
    v13 = objc_alloc(MEMORY[0x1E0C99D50]);
    v14 = objc_retainAutorelease(v6);
    v15 = (void *)objc_msgSend(v13, "initWithBytesNoCopy:length:freeWhenDone:", objc_msgSend(v14, "bytes") + v8, objc_msgSend(v14, "length") - v8, 0);
    v16 = -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:]((uint64_t)self, v15, v7, v10, &v30, 0, 0);
    if (!v16 || v30)
    {
      v29 = v10;
      v18 = *__error();
      _sa_logt();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        v20 = ", and should skip";
        if (!v30)
          v20 = "";
        *(_DWORD *)buf = v23;
        v32 = v16;
        v33 = 2080;
        v34 = v20;
        _os_log_debug_impl(&dword_1B9BE0000, v19, OS_LOG_TYPE_DEBUG, "KCData stackshot parsed %ld bytes%s", buf, 0x16u);
      }

      *__error() = v18;
      self = v28;
      v10 = v29;
    }
    else
    {
      ++v9;
      if (v4)
      {
        if (-[SASampleStore dataStyle](self, "dataStyle") == 1)
        {
          startTime = self->_startTime;
          ++self->_numSamples;
          if (!startTime)
            objc_storeStrong(location, v7);
          objc_storeStrong(p_endTime, v7);
        }
        else
        {
          -[NSMutableArray addObject:](self->_sampleTimestamps, "addObject:", v7);
        }
        if (self->_nextSampleIsFirstSamplingAllThreads)
        {
          objc_storeStrong(p_timeWhenTransitionedToSamplingAllThreads, v7);
          self->_nextSampleIsFirstSamplingAllThreads = 0;
        }
        if (self->_nextSampleIsFirstSamplingAllProcesses)
        {
          objc_storeStrong(p_timeWhenTransitionedToSamplingAllProcesses, v7);
          self->_nextSampleIsFirstSamplingAllProcesses = 0;
        }
      }
    }
    v8 += v16;

  }
  while (v16);
  if (!v4 && v9)
  {
    if (-[SASampleStore dataStyle](self, "dataStyle") != 1)
    {
      -[NSMutableArray addObject:](self->_sampleTimestamps, "addObject:", v7);
      v21 = self->_startTime;
      ++self->_numSamples;
      if (!v21)
        objc_storeStrong(location, v7);
      objc_storeStrong(p_endTime, v7);
    }
    if (self->_nextSampleIsFirstSamplingAllThreads)
    {
      objc_storeStrong(p_timeWhenTransitionedToSamplingAllThreads, v7);
      self->_nextSampleIsFirstSamplingAllThreads = 0;
    }
    if (self->_nextSampleIsFirstSamplingAllProcesses)
    {
      objc_storeStrong(p_timeWhenTransitionedToSamplingAllProcesses, v7);
      self->_nextSampleIsFirstSamplingAllProcesses = 0;
    }
  }

  return v9;
}

- (uint64_t)_addKCDataStackshot:(void *)a3 timestamp:(unint64_t)a4 sampleIndex:(_BYTE *)a5 shouldSkipSampleOut:(unsigned int)a6 primaryDataIsKPerf:(char)a7 addStaticInfoOnly:
{
  id v12;
  __objc2_class *v13;
  int v14;
  NSObject *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  __objc2_class *v19;
  int *v20;
  uint64_t v21;
  _DWORD *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t result;
  uint64_t v27;
  void *v28;
  id v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t i;
  uint64_t v33;
  void *v34;
  int *v35;
  id v36;
  char v37;
  uint64_t v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  void *v42;
  int *v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t *v47;
  unsigned int *v48;
  uint64_t v49;
  unsigned int *v50;
  void *v51;
  id v52;
  void *v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  void *v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  __objc2_class *v66;
  __objc2_class *v67;
  BOOL v68;
  uint64_t v69;
  int *v70;
  int *v71;
  uint64_t v72;
  int v73;
  int v74;
  __objc2_class *v75;
  unsigned int v76;
  BOOL v77;
  int v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  NSObject *v82;
  char *v83;
  BOOL v84;
  uint64_t v85;
  int v86;
  NSObject *v87;
  int *v88;
  uint64_t v89;
  unsigned int v90;
  int v91;
  NSObject *v92;
  int *v93;
  __objc2_class *v94;
  int v95;
  NSObject *v96;
  int *v97;
  int v98;
  NSObject *v99;
  int *v100;
  int v101;
  NSObject *v102;
  int *v103;
  int isa_low;
  int *v105;
  __objc2_class *superclass;
  __objc2_class *isa;
  uint64_t isa_high;
  char *v109;
  int v110;
  char v111;
  int v112;
  id v113;
  void *v114;
  void *v115;
  id v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t j;
  void *v120;
  void *v121;
  _BOOL4 v122;
  void *v123;
  void *v124;
  void *v125;
  __objc2_class *v126;
  double v127;
  int v128;
  unsigned int v129;
  int v130;
  _QWORD *v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  char v136;
  uint64_t v137;
  NSObject *v138;
  unsigned int v139;
  int v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  int *v145;
  uint64_t v146;
  BOOL v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  int v151;
  _QWORD *v152;
  uint64_t v153;
  uint64_t v154;
  void *v155;
  void *v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  _BOOL4 v160;
  void *v161;
  void *v162;
  unint64_t v163;
  id v164;
  unint64_t v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  uint64_t v169;
  uint64_t v170;
  unsigned int v171;
  id v172;
  uint64_t v173;
  void *v174;
  id v175;
  id v176;
  int v177;
  NSObject *v178;
  unint64_t v179;
  unint64_t v180;
  unsigned int v181;
  uint64_t v182;
  void *v183;
  uint64_t v184;
  void *v185;
  int v186;
  int v187;
  int v188;
  int v189;
  NSObject *v190;
  int v191;
  int v192;
  int v193;
  __objc2_class *v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  __objc2_class *v198;
  uint64_t v199;
  void *v200;
  id v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  void *v205;
  int v206;
  NSObject *v207;
  unsigned int v208;
  unsigned int v209;
  unsigned int v210;
  unsigned int v211;
  uint64_t v212;
  __objc2_class *v213;
  id v214;
  uint64_t v215;
  uint64_t v216;
  void *v217;
  id v218;
  void *v219;
  uint64_t v220;
  uint64_t v221;
  int v222;
  int v223;
  char *v224;
  int v225;
  NSObject *v226;
  id v227;
  void *v228;
  void *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  void *v233;
  void *v234;
  uint64_t v235;
  uint64_t v236;
  int v237;
  NSObject *v238;
  const char *v239;
  int v240;
  NSObject *v241;
  __objc2_class *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  int v249;
  NSObject *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  unsigned int v258;
  uint64_t v259;
  void *v260;
  uint64_t v261;
  NSObject *v262;
  id obj;
  unint64_t v264;
  NSObject *v265;
  int v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  __objc2_class *v271;
  __objc2_class *v272;
  __objc2_class *v273;
  void *v274;
  id v275;
  int *v276;
  void *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  void *v281;
  id v282;
  unsigned int *v283;
  uint64_t v284;
  SAFrameIterator *v285;
  void *__ptr;
  void *__ptra;
  NSObject *__ptrb;
  char v289;
  id context;
  __objc2_class *contexta;
  __objc2_class *contextb;
  __objc2_class *contextc;
  void *contextd;
  __objc2_class *v295;
  uint64_t v296;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  unsigned int v300;
  char v301;
  void *v302;
  unsigned int v303;
  uint64_t v304;
  void *v306;
  __objc2_class *v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  _QWORD v312[5];
  __int128 v313;
  __int128 v314;
  __int128 v315;
  __int128 v316;
  _QWORD v317[5];
  _QWORD block[5];
  _QWORD v319[8];
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  __int128 v326;
  __int128 v327;
  int *v328;
  unint64_t v329;
  _QWORD v330[5];
  _BYTE v331[128];
  _BYTE v332[128];
  _BYTE v333[128];
  _BYTE v334[128];
  __objc2_class buf;
  id v336;
  uint64_t v337;

  v337 = *MEMORY[0x1E0C80C00];
  v12 = a2;
  v13 = a3;
  v306 = v12;
  if (!a1)
  {
    v25 = 0;
    goto LABEL_19;
  }
  v307 = v13;
  if (!v12 || (unint64_t)objc_msgSend(v12, "length") <= 0xF)
  {
    v14 = *__error();
    _sa_logt();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.isa) = 0;
      _os_log_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_DEFAULT, "WARNING: No buffer", (uint8_t *)&buf, 2u);
    }
LABEL_15:

    *__error() = v14;
    goto LABEL_16;
  }
  v303 = a6;
  v16 = objc_retainAutorelease(v12);
  v17 = objc_msgSend(v16, "bytes");
  v18 = objc_msgSend(v16, "length");
  v295 = (__objc2_class *)v18;
  v19 = (__objc2_class *)(v18 + v17);
  v20 = (int *)(v17 + 16);
  if (v17 + 16 > (unint64_t)(v18 + v17) || (v21 = *(unsigned int *)(v17 + 4), (char *)v20 + v21 > (char *)v19))
  {
LABEL_13:
    v14 = *__error();
    _sa_logt();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.isa) = 134217984;
      *(__objc2_class **)((char *)&buf.isa + 4) = v295;
      _os_log_error_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_ERROR, "Overran kcdata buffer (length %lu)", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_15;
  }
  v22 = (_DWORD *)v17;
  while (*v22 != -242132755)
  {
    v23 = (char *)v22 + v21;
    v24 = v23 + 32;
    if (v23 + 32 <= (char *)v19)
    {
      v22 = v23 + 16;
      v21 = *((unsigned int *)v23 + 5);
      if (&v24[v21] <= (char *)v19)
        continue;
    }
    goto LABEL_13;
  }
  v289 = a7;
  obj = a3;
  v264 = a4;
  v276 = (int *)v17;
  v328 = (int *)v17;
  v329 = v18 + v17;
  if ((v303 & 1) == 0)
  {
    v27 = *(_QWORD *)(a1 + 360);
    *(_QWORD *)(a1 + 352) |= 1uLL;
    if (!v27)
      *(_QWORD *)(a1 + 360) = 2;
  }
  v28 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", objc_msgSend(*(id *)(a1 + 112), "count"));
  v324 = 0u;
  v325 = 0u;
  v326 = 0u;
  v327 = 0u;
  v304 = a1;
  v29 = *(id *)(a1 + 112);
  v30 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v324, v334, 16);
  if (v30)
  {
    v31 = *(_QWORD *)v325;
    do
    {
      for (i = 0; i != v30; ++i)
      {
        if (*(_QWORD *)v325 != v31)
          objc_enumerationMutation(v29);
        v33 = *(_QWORD *)(*((_QWORD *)&v324 + 1) + 8 * i);
        if (v33 && *(_DWORD *)(v33 + 32))
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:");
          v34 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v28, "setObject:forKeyedSubscript:", v33, v34);

        }
      }
      v30 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v324, v334, 16);
    }
    while (v30);
  }

  v282 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  v275 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  if ((v303 & 1) != 0)
  {
    v277 = 0;
    v35 = v276;
    goto LABEL_125;
  }
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  LOBYTE(v41) = 0;
  v42 = 0;
  v296 = -1;
  v43 = v276;
  while (1)
  {
    v44 = v43[1];
    if ((char *)v20 + v44 > (char *)v19 || (v45 = *v43, *v43 == -242132755))
    {
LABEL_123:
      v36 = v36;
      v277 = v36;
      goto LABEL_124;
    }
    if ((v45 & 0xFFFFFFF0) == 0x20)
      v46 = 17;
    else
      v46 = *v43;
    if ((v46 - 1) >= 6)
      v47 = (uint64_t *)(v43 + 4);
    else
      v47 = (uint64_t *)(v43 + 12);
    if ((v41 & 1) != 0)
    {
      LOBYTE(v41) = v46 != 20 || v42 != *((void **)v43 + 1);
      goto LABEL_68;
    }
    LOBYTE(v41) = 0;
    if (v46 > 2308)
    {
      if (v46 != 2309 && v46 != 2352 && v46 != 2368)
        goto LABEL_68;
      LOBYTE(v41) = 0;
      v54 = *v47;
LABEL_67:
      v296 = v54;
      goto LABEL_68;
    }
    if (v46 == 17)
      break;
    if (v46 == 19)
    {
      if (v44 < 4 || v45 != 19)
        goto LABEL_511;
      v58 = v43[4];
      if ((v58 == 2353 || v58 == 2307) && (v37 & 1) == 0)
      {
        LOBYTE(v41) = 0;
        v37 = 1;
        v38 = *((_QWORD *)v43 + 1);
      }
      else
      {
        if ((v37 & 1) != 0)
          v42 = (void *)*((_QWORD *)v43 + 1);
        LOBYTE(v41) = v37;
      }
    }
    else if (v46 == 20)
    {
      if (*((_QWORD *)v43 + 1) != v38)
        goto LABEL_98;
      if (v40 && v39 && v296 != -1)
      {
        __ptr = v42;
        context = v36;
        if (!v36)
        {
          v48 = v39;
          context = objc_alloc_init(MEMORY[0x1E0C99E08]);
          v39 = v48;
        }
        v49 = v40;
        v283 = v39;
        v50 = v39;
        do
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *v50);
          v51 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(context, "objectForKey:", v51);
          v52 = (id)objc_claimAutoreleasedReturnValue();
          if (!v52)
          {
            v52 = objc_alloc_init(MEMORY[0x1E0C99E20]);
            objc_msgSend(context, "setObject:forKey:", v52, v51);
          }
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v296);
          v53 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v52, "addObject:", v53);

          ++v50;
          --v49;
        }
        while (v49);
        v36 = context;
        v39 = v283;
        goto LABEL_107;
      }
      if (v39)
      {
        __ptr = v42;
LABEL_107:
        free(v39);
        LOBYTE(v41) = 0;
        v40 = 0;
        v39 = 0;
        v38 = 0;
        v37 = 0;
        v296 = -1;
        v42 = __ptr;
        goto LABEL_68;
      }
      LOBYTE(v41) = 0;
      v40 = 0;
      v38 = 0;
      v37 = 0;
      v54 = -1;
      goto LABEL_67;
    }
LABEL_68:
    v43 = (int *)((char *)v20 + v43[1]);
    v20 = v43 + 4;
    if (v43 + 4 > (int *)v19)
      goto LABEL_123;
  }
  if (v45 != 17 && (v45 & 0xFFFFFFF0) != 0x20)
    goto LABEL_511;
  v55 = *((_QWORD *)v43 + 1);
  if (!(_DWORD)v55)
  {
    if ((_DWORD)v44)
      goto LABEL_511;
    v56 = HIDWORD(v55);
    if (v45 == 17)
    {
LABEL_115:
      LOBYTE(v41) = 0;
      if ((int)v56 <= 2313)
      {
        if ((v56 - 48) < 2 || (_DWORD)v56 == 2074)
          goto LABEL_68;
        if ((_DWORD)v56 == 2311)
        {
          v59 = 4;
          goto LABEL_93;
        }
      }
      else if ((v56 - 2314) < 4 || (_DWORD)v56 == 2369)
      {
        goto LABEL_68;
      }
    }
    v59 = 0;
    goto LABEL_93;
  }
  if (v45 != 17)
  {
    v60 = v44 - (*v43 & 0xF);
    if (v44 < (*v43 & 0xFu))
      goto LABEL_511;
    if (v60 < v55)
      goto LABEL_511;
    v59 = v60 / v55;
    if (v60 % v55)
      goto LABEL_511;
    v56 = HIDWORD(v55);
LABEL_93:
    if ((((_DWORD)v56 == 2311) & v37) == 1)
    {
      v284 = v38;
      __ptra = v42;
      v39 = (unsigned int *)malloc_type_calloc(*((_QWORD *)v43 + 1), 4uLL, 0x100004052888210uLL);
      v41 = 0;
      if ((_DWORD)v55)
      {
        v61 = 0;
        v38 = v284;
        v42 = __ptra;
        do
        {
          v39[v61++] = *(_DWORD *)((char *)v47 + v41);
          v41 += v59;
          v37 = 1;
        }
        while (v55 != v61);
        LOBYTE(v41) = 0;
        v40 = v55;
      }
      else
      {
        v40 = 0;
        v37 = 1;
        v38 = v284;
        v42 = __ptra;
      }
      goto LABEL_68;
    }
LABEL_98:
    LOBYTE(v41) = 0;
    goto LABEL_68;
  }
  v277 = 0;
  v56 = HIDWORD(v55);
  if (SHIDWORD(v55) <= 2310)
  {
    switch(HIDWORD(v55))
    {
      case 0x30:
        v57 = 20;
        break;
      case 0x31:
        v57 = 24;
        break;
      case 0x81A:
LABEL_105:
        v57 = 8;
        break;
      default:
        goto LABEL_124;
    }
  }
  else
  {
    switch(HIDWORD(v55))
    {
      case 0x907:
        v57 = 4;
        break;
      case 0x908:
      case 0x909:
        goto LABEL_124;
      case 0x90A:
      case 0x90C:
        goto LABEL_105;
      case 0x90B:
      case 0x90D:
        v57 = 16;
        break;
      default:
        if (HIDWORD(v55) != 2369)
          goto LABEL_124;
        v57 = 48;
        break;
    }
  }
  if (v44 / v57 >= v55 && v44 % v55 <= 0xF)
    goto LABEL_115;
LABEL_511:
  v277 = 0;
LABEL_124:

  v35 = v328;
  v19 = (__objc2_class *)v329;
  v20 = v328 + 4;
LABEL_125:
  v285 = objc_alloc_init(SAFrameIterator);
  -[SAFrameIterator setBacktracer:](v285, "setBacktracer:", 2);
  if (v20 <= (int *)v19)
  {
    v63 = 0;
    __ptrb = 0;
    v64 = 0;
    v65 = 0;
    v66 = 0;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = v20;
    v71 = v35;
    while (1)
    {
      v72 = v71[1];
      if ((char *)v70 + v72 > (char *)v19 || (v73 = *v71, *v71 == -242132755))
      {
LABEL_201:
        v62 = 0;
        buf.isa = (__objc2_class *)v35;
        buf.superclass = v19;
        v105 = v20;
        superclass = v19;
        isa = (__objc2_class *)v35;
        v262 = v63;
        while (1)
        {
          isa_high = HIDWORD(isa->isa);
          if ((char *)v105 + isa_high > (char *)superclass || LODWORD(isa->isa) == -242132755)
          {
LABEL_211:
            v265 = __ptrb;
            goto LABEL_212;
          }
          if (LODWORD(isa->isa) == 19 && LODWORD(isa->cache) == 2377)
          {
            if (!v62)
              v62 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 1);
            if (-[SASampleStore parseKCDataExclavesContainer:exclaveInfo:primaryDataIsKPerf:](a1, &buf, v62, (_QWORD **)v303))
            {
              v265 = __ptrb;
              v274 = 0;
              goto LABEL_213;
            }
            isa = buf.isa;
            superclass = buf.superclass;
            isa_high = HIDWORD(buf.isa->isa);
          }
          v109 = (char *)isa + isa_high;
          isa = (__objc2_class *)(v109 + 16);
          buf.isa = (__objc2_class *)(v109 + 16);
          buf.superclass = superclass;
          v105 = (int *)(v109 + 32);
          if (v109 + 32 > (char *)superclass)
            goto LABEL_211;
        }
      }
      v74 = (v73 & 0xFFFFFFF0) == 0x20 ? 17 : *v71;
      if ((v74 - 1) > 5)
        break;
      v75 = (__objc2_class *)(v71 + 12);
      v76 = v71[2] & 0xF;
      v77 = v72 >= v76;
      v78 = v72 - v76;
      if (!v77)
        v78 = 0;
      v79 = v78 - 32;
      if (v68)
      {
LABEL_180:
        v68 = v74 != 20 || v69 != *((_QWORD *)v71 + 1);
        goto LABEL_183;
      }
LABEL_137:
      v68 = 0;
      if (v74 > 2356)
      {
        if (v74 == 2357)
        {
          if ((v64 & 1) != 0)
          {
            v68 = 0;
            v64 = 1;
            v66 = v75;
          }
          else
          {
            contextc = v67;
            v279 = v65;
            v298 = v63;
            v267 = v69;
            v91 = *__error();
            _sa_logt();
            v92 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
            {
              isa_low = SLOWORD(v75->isa);
              LODWORD(buf.isa) = 67109120;
              HIDWORD(buf.isa) = isa_low;
              _os_log_error_impl(&dword_1B9BE0000, v92, OS_LOG_TYPE_ERROR, "Port label info %d not in port label container", (uint8_t *)&buf, 8u);
            }

            v93 = __error();
            v68 = 0;
            v64 = 0;
            *v93 = v91;
            v66 = v75;
            v69 = v267;
            v63 = v298;
            v65 = v279;
            v67 = contextc;
          }
        }
        else if (v74 == 2358)
        {
          if (*((_BYTE *)&v75->isa + (v79 - 1)))
          {
            v266 = v64;
            v272 = v66;
            contextb = v67;
            v278 = v65;
            v297 = v63;
            v85 = v69;
            v86 = *__error();
            _sa_logt();
            v87 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.isa) = 0;
              _os_log_impl(&dword_1B9BE0000, v87, OS_LOG_TYPE_DEFAULT, "WARNING: port name non NULL-terminated", (uint8_t *)&buf, 2u);
            }

            v88 = __error();
            v68 = 0;
            *v88 = v86;
            v69 = v85;
            v63 = v297;
            v65 = v278;
            v67 = contextb;
            v66 = v272;
            v64 = v266;
          }
          else if ((v64 & 1) != 0)
          {
            v68 = 0;
            v64 = 1;
            v67 = v75;
          }
          else
          {
            v269 = v69;
            v273 = v66;
            v280 = v65;
            v300 = v63;
            v98 = *__error();
            _sa_logt();
            v99 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf.isa) = 136315138;
              *(__objc2_class **)((char *)&buf.isa + 4) = v75;
              _os_log_error_impl(&dword_1B9BE0000, v99, OS_LOG_TYPE_ERROR, "Port name %s not in port label container", (uint8_t *)&buf, 0xCu);
            }

            v100 = __error();
            v68 = 0;
            v64 = 0;
            *v100 = v98;
            v67 = v75;
            v69 = v269;
            v66 = v273;
            v63 = v300;
            v65 = v280;
          }
        }
      }
      else if (v74 == 19)
      {
        if (v72 < 4 || v73 != 19)
          goto LABEL_201;
        if ((v64 & 1) != 0)
          v89 = *((_QWORD *)v71 + 1);
        else
          v89 = v69;
        if ((v71[4] != 2356) | v64 & 1)
        {
          v69 = v89;
          v68 = v64;
        }
        else
        {
          v68 = 0;
        }
        if (!((v71[4] != 2356) | v64 & 1))
        {
          v67 = 0;
          v66 = 0;
          v65 = *((_QWORD *)v71 + 1);
          v64 = 1;
        }
      }
      else if (v74 == 20)
      {
        if ((v64 & (*((_QWORD *)v71 + 1) == v65)) == 1)
        {
          v271 = v66;
          if (v66 && v67)
          {
            contexta = v67;
            v80 = v63;
            v81 = v63 + 1;
            v82 = reallocf(__ptrb, 16 * (v63 + 1));
            if (v82)
            {
              v68 = 0;
              v65 = 0;
              v64 = 0;
              __ptrb = v82;
              v83 = (char *)&v82[2 * v80];
              *(_QWORD *)v83 = v271;
              *((_QWORD *)v83 + 1) = contexta;
              v63 = v81;
              v67 = 0;
              v66 = 0;
            }
            else
            {
              v270 = v69;
              v101 = *__error();
              _sa_logt();
              v102 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT))
              {
                LODWORD(buf.isa) = 67109120;
                HIDWORD(buf.isa) = v81;
                _os_log_fault_impl(&dword_1B9BE0000, v102, OS_LOG_TYPE_FAULT, "unable to realloc %u port label infos", (uint8_t *)&buf, 8u);
              }

              v103 = __error();
              v68 = 0;
              v67 = 0;
              v66 = 0;
              v65 = 0;
              v64 = 0;
              __ptrb = 0;
              v63 = 0;
              *v103 = v101;
              v69 = v270;
            }
          }
          else
          {
            v94 = v67;
            v299 = v63;
            v268 = v69;
            v95 = *__error();
            _sa_logt();
            v96 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf.isa) = 67109378;
              HIDWORD(buf.isa) = v271 != 0;
              LOWORD(buf.superclass) = 2080;
              *(__objc2_class **)((char *)&buf.superclass + 2) = v94;
              _os_log_error_impl(&dword_1B9BE0000, v96, OS_LOG_TYPE_ERROR, "Port label without both info (%d) and name (%s)", (uint8_t *)&buf, 0x12u);
            }

            v97 = __error();
            v68 = 0;
            v67 = 0;
            v66 = 0;
            v65 = 0;
            v64 = 0;
            *v97 = v95;
            v69 = v268;
            v63 = v299;
          }
        }
        else
        {
          v68 = 0;
        }
      }
LABEL_183:
      v71 = (int *)((char *)v70 + v71[1]);
      v70 = v71 + 4;
      if (v71 + 4 > (int *)v19)
        goto LABEL_201;
    }
    if (v74 > 2309)
    {
      if (v74 == 2312)
      {
        if ((_DWORD)v72 == 32 && (v71[2] & 0x8F) == 0)
        {
          v79 = 24;
          goto LABEL_179;
        }
      }
      else if (v74 == 2310 && (_DWORD)v72 == 112 && (v71[2] & 0x8F) == 0)
      {
        v79 = 104;
        goto LABEL_179;
      }
    }
    else
    {
      v84 = v74 == 17 || v74 == 19;
      v79 = v71[1];
      if (v84)
        goto LABEL_179;
    }
    v90 = v71[2] & 0xF;
    v77 = v72 >= v90;
    v79 = v72 - v90;
    if (!v77)
      v79 = 0;
LABEL_179:
    v75 = (__objc2_class *)(v71 + 4);
    if (v68)
      goto LABEL_180;
    goto LABEL_137;
  }
  v262 = 0;
  __ptrb = 0;
  v265 = 0;
  v62 = 0;
  buf.isa = (__objc2_class *)v35;
  buf.superclass = v19;
LABEL_212:
  v274 = (void *)objc_msgSend(v62, "copy");
LABEL_213:

  if (qword_1ED1DD5B8 != -1)
    dispatch_once(&qword_1ED1DD5B8, &__block_literal_global_1446);
  if (byte_1ED1DD559 == 1)
  {
    v110 = *__error();
    fwrite("\n\nNEXT STACKSHOT\n\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C20]);
    *__error() = v110;
  }
  v111 = v289;
  if (v20 > (int *)v19)
  {
    v281 = 0;
    v301 = 0;
    goto LABEL_219;
  }
  v301 = 0;
  v261 = 0;
  v281 = 0;
  v127 = *MEMORY[0x1E0C9ADF8];
  while (2)
  {
    if ((char *)v20 + v35[1] > (char *)v19 || *v35 == -242132755)
      goto LABEL_219;
    contextd = (void *)MEMORY[0x1BCCCC288]();
    if ((v301 & 1) != 0)
    {
      v301 = 1;
      goto LABEL_504;
    }
    KCLogIter((unsigned int *)v35, (unint64_t)v19, 0);
    v128 = *v35;
    v129 = *v35 & 0xFFFFFFF0;
    if (v129 == 32)
      v130 = 17;
    else
      v130 = *v35;
    if ((v130 - 1) > 5)
    {
      v136 = v289;
      v137 = v303;
      v138 = __ptrb;
      if (v130 <= 2309)
      {
        if (v130 == 17 || v130 == 19)
        {
          v132 = v35[1];
          v135 = v132;
LABEL_269:
          v131 = v35 + 4;
          goto LABEL_270;
        }
        goto LABEL_266;
      }
      if (v130 == 2310)
      {
        v132 = v35[1];
        if (v132 == 112 && (v35[2] & 0x8F) == 0)
        {
          v135 = 104;
          goto LABEL_269;
        }
      }
      else
      {
        if (v130 != 2312)
        {
LABEL_266:
          v132 = v35[1];
          goto LABEL_267;
        }
        v132 = v35[1];
        if (v132 == 32 && (v35[2] & 0x8F) == 0)
        {
          v135 = 24;
          goto LABEL_269;
        }
      }
LABEL_267:
      v139 = v35[2] & 0xF;
      v77 = v132 >= v139;
      v135 = v132 - v139;
      if (!v77)
        v135 = 0;
      goto LABEL_269;
    }
    v131 = v35 + 12;
    v132 = v35[1];
    v133 = v35[2] & 0xF;
    v77 = v132 >= v133;
    v134 = v132 - v133;
    if (!v77)
      v134 = 0;
    v135 = v134 - 32;
    v136 = v289;
    v137 = v303;
    v138 = __ptrb;
LABEL_270:
    v301 = 0;
    if (v130 > 2311)
    {
      if (v130 <= 2331)
      {
        switch(v130)
        {
          case 2312:
            if (v135 < 0x28)
              goto LABEL_550;
            if (qword_1ED1DD5C0 != -1)
              dispatch_once(&qword_1ED1DD5C0, &__block_literal_global_1450);
            if ((byte_1ED1DD55A & 1) != 0)
            {
LABEL_550:
              if (!uuid_is_null((const unsigned __int8 *)v131 + 8))
              {
                -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)(v131 + 1), *v131, -1);
                v182 = objc_claimAutoreleasedReturnValue();
                v183 = *(void **)(a1 + 1024);
                *(_QWORD *)(a1 + 1024) = v182;

              }
            }
            else if (!objc_msgSend(v28, "count") && !uuid_is_null((const unsigned __int8 *)v131 + 8))
            {
              -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)(v131 + 1), *v131, v131[4]);
              v216 = objc_claimAutoreleasedReturnValue();
              v217 = *(void **)(a1 + 1024);
              *(_QWORD *)(a1 + 1024) = v216;

            }
            break;
          case 2318:
            if (!*(_QWORD *)(a1 + 496))
            {
              SANSStringForCString(v131);
              v184 = objc_claimAutoreleasedReturnValue();
              v185 = *(void **)(a1 + 496);
              *(_QWORD *)(a1 + 496) = v184;

            }
            break;
          case 2319:
            v142 = a1;
            if (!*(_QWORD *)(a1 + 448))
            {
              SANSStringForCString(v131);
              v143 = objc_claimAutoreleasedReturnValue();
              v144 = *(void **)(a1 + 448);
              *(_QWORD *)(a1 + 448) = v143;

              v142 = a1;
            }
            if (!*(_QWORD *)(v142 + 192))
            {
              if (objc_msgSend(*(id *)(v142 + 448), "rangeOfString:options:", CFSTR("X86_64"), 1) == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (objc_msgSend(*(id *)(a1 + 448), "rangeOfString:options:", CFSTR("ARM64"), 1) == 0x7FFFFFFFFFFFFFFFLL)
                {
                  if (objc_msgSend(*(id *)(a1 + 448), "rangeOfString:options:", CFSTR("ARM"), 1) == 0x7FFFFFFFFFFFFFFFLL)
                  {
                    block[0] = MEMORY[0x1E0C809B0];
                    block[1] = 3221225472;
                    block[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_226;
                    block[3] = &unk_1E7146F90;
                    block[4] = a1;
                    if (qword_1ED1DD560 == -1)
                    {
                      v301 = 0;
                      goto LABEL_503;
                    }
                    dispatch_once(&qword_1ED1DD560, block);
                    break;
                  }
                  v301 = 0;
                  v220 = a1;
                  v221 = 12;
                }
                else
                {
                  v301 = 0;
                  v220 = a1;
                  v221 = 16777228;
                }
              }
              else
              {
                v301 = 0;
                v220 = a1;
                v221 = 0x301000007;
              }
              *(_QWORD *)(v220 + 192) = v221;
              goto LABEL_503;
            }
            break;
          default:
            goto LABEL_503;
        }
LABEL_502:
        v301 = 0;
        goto LABEL_503;
      }
      if (v130 <= 2374)
      {
        if (v130 != 2332)
        {
          if (v130 == 2338)
          {
            v301 = 0;
            *(_DWORD *)(a1 + 200) = *(_DWORD *)v131;
          }
          goto LABEL_503;
        }
        if (!uuid_is_null((const unsigned __int8 *)v131 + 8))
        {
          v322 = 0u;
          v323 = 0u;
          v320 = 0u;
          v321 = 0u;
          v201 = *(id *)(a1 + 104);
          v202 = objc_msgSend(v201, "countByEnumeratingWithState:objects:count:", &v320, v333, 16);
          if (v202)
          {
            v203 = *(_QWORD *)v321;
LABEL_441:
            v204 = 0;
            while (1)
            {
              if (*(_QWORD *)v321 != v203)
                objc_enumerationMutation(v201);
              v205 = *(void **)(*((_QWORD *)&v320 + 1) + 8 * v204);
              if ((objc_msgSend(v205, "matchesUUID:loadAddress:", v131 + 1, *v131) & 1) != 0)
                break;
              if (v202 == ++v204)
              {
                v202 = objc_msgSend(v201, "countByEnumeratingWithState:objects:count:", &v320, v333, 16);
                if (v202)
                  goto LABEL_441;
                goto LABEL_447;
              }
            }
            v218 = v205;

            if (v218)
              goto LABEL_472;
          }
          else
          {
LABEL_447:

          }
          uuidForBytes((uint64_t)(v131 + 1));
          v219 = (void *)objc_claimAutoreleasedReturnValue();
          +[SAKernelCache kernelCacheWithUUID:loadAddress:](SAKernelCache, "kernelCacheWithUUID:loadAddress:", v219, *v131);
          v218 = (id)objc_claimAutoreleasedReturnValue();

          objc_msgSend(*(id *)(a1 + 104), "addObject:", v218);
LABEL_472:

          goto LABEL_502;
        }
        v177 = *__error();
        _sa_logt();
        v178 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.isa) = 0;
          _os_log_error_impl(&dword_1B9BE0000, v178, OS_LOG_TYPE_ERROR, "Kernel cache UUID is all zeros", (uint8_t *)&buf, 2u);
        }
LABEL_435:

        v301 = 0;
        *__error() = v177;
        goto LABEL_503;
      }
      if (v130 == 2375)
      {
        if (!*(_QWORD *)(a1 + 480))
        {
          SANSStringForCString(v131);
          v199 = objc_claimAutoreleasedReturnValue();
          v200 = *(void **)(a1 + 480);
          *(_QWORD *)(a1 + 480) = v199;

        }
        goto LABEL_502;
      }
      if (v130 != 1503811591)
        goto LABEL_503;
      v260 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 1000);
      v145 = v35 + 4;
      if (v35 + 4 > (int *)v19)
      {
LABEL_431:
        v164 = 0;
        goto LABEL_432;
      }
      v302 = 0;
      v146 = 0;
      v259 = 0;
      v147 = 0;
      v148 = 0;
LABEL_310:
      v149 = v35[1];
      if ((char *)v145 + v149 > (char *)v19 || (v150 = *v35, *v35 == -242132755))
      {
LABEL_382:
        if (!v302)
          goto LABEL_431;
        v174 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", objc_msgSend(v302, "count"));
        buf.isa = (__objc2_class *)MEMORY[0x1E0C809B0];
        buf.superclass = (__objc2_class *)3221225472;
        buf.cache = __SAKCDataReadAheadJetsamCoalitionInfo_block_invoke_2;
        buf.vtable = &unk_1E7147760;
        buf.info = (__objc2_class_ro *)v260;
        v175 = v174;
        v336 = v175;
        objc_msgSend(v302, "enumerateKeysAndObjectsUsingBlock:", &buf);
        v176 = v336;
        v164 = v175;

LABEL_384:
LABEL_432:

        v301 = 0;
        v281 = v164;
LABEL_503:
        v35 = v328;
        v19 = (__objc2_class *)v329;
LABEL_504:
        objc_autoreleasePoolPop(contextd);
        v224 = (char *)v35 + v35[1];
        v35 = (int *)(v224 + 16);
        v328 = (int *)(v224 + 16);
        v329 = (unint64_t)v19;
        v20 = (int *)(v224 + 32);
        v111 = v289;
        if (v224 + 32 > (char *)v19)
        {
LABEL_219:
          v112 = 1;
          goto LABEL_220;
        }
        continue;
      }
      if ((v150 & 0xFFFFFFF0) == 0x20)
        v151 = 17;
      else
        v151 = *v35;
      if ((v151 - 1) >= 6)
        v152 = v35 + 4;
      else
        v152 = v35 + 12;
      if (v147)
      {
        v147 = v151 != 20 || v148 != *((_QWORD *)v35 + 1);
        goto LABEL_381;
      }
      v147 = 0;
      if (v151 > 19)
      {
        if (v151 == 20)
        {
          v147 = 0;
          v158 = *((_QWORD *)v35 + 1);
          v159 = v259;
          v84 = v158 == v259;
          v160 = v158 != v259;
          if (v84)
            v159 = 0;
          v259 = v159;
          v146 = v160 & v146;
        }
        else
        {
          if (v151 == 2309)
          {
            v153 = v148;
            v154 = v146;
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *((unsigned int *)v152 + 21));
            v161 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v152);
            v162 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v260, "setObject:forKeyedSubscript:", v161, v162);

          }
          else
          {
            if (v151 != 2352)
              goto LABEL_381;
            v153 = v148;
            v154 = v146;
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *((unsigned int *)v152 + 6));
            v155 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v152);
            v156 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v260, "setObject:forKeyedSubscript:", v155, v156);

          }
          v147 = 0;
          v146 = v154;
          v148 = v153;
        }
LABEL_381:
        v35 = (int *)((char *)v145 + v35[1]);
        v145 = v35 + 4;
        if (v35 + 4 > (int *)v19)
          goto LABEL_382;
        goto LABEL_310;
      }
      if (v151 != 17)
      {
        if (v151 == 19)
        {
          if (v149 < 4 || v150 != 19)
            goto LABEL_490;
          v157 = v35[4];
          if ((v157 == 2353 || v157 == 2307) && (v146 & 1) == 0)
          {
            v147 = 0;
            v146 = 1;
            v259 = *((_QWORD *)v35 + 1);
          }
          else
          {
            if ((v146 & 1) != 0)
              v148 = *((_QWORD *)v35 + 1);
            v147 = v146;
          }
        }
        goto LABEL_381;
      }
      if (v150 != 17 && (v150 & 0xFFFFFFF0) != 0x20)
        goto LABEL_490;
      v163 = *((_QWORD *)v35 + 1);
      if ((_DWORD)v163)
      {
        if (v150 == 17)
        {
          v164 = 0;
          v165 = HIDWORD(v163);
          if (SHIDWORD(v163) <= 2310)
          {
            switch(HIDWORD(v163))
            {
              case 0x30:
                v166 = 20;
                break;
              case 0x31:
                v166 = 24;
                break;
              case 0x81A:
LABEL_368:
                v166 = 8;
                break;
              default:
                goto LABEL_384;
            }
          }
          else
          {
            switch(HIDWORD(v163))
            {
              case 0x907:
                v166 = 4;
                break;
              case 0x908:
              case 0x909:
                goto LABEL_384;
              case 0x90A:
              case 0x90C:
                goto LABEL_368;
              case 0x90B:
              case 0x90D:
                v166 = 16;
                break;
              default:
                if (HIDWORD(v163) != 2369)
                  goto LABEL_384;
                v166 = 48;
                break;
            }
          }
          if (v149 / v166 < v163 || v149 % v163 > 0xF)
          {
LABEL_490:
            v164 = 0;
            goto LABEL_384;
          }
LABEL_376:
          if ((v165 - 2311) <= 0x3A && ((1 << (v165 - 7)) & 0x400000000000079) != 0
            || (v165 - 48) < 2
            || (v167 = 0, (_DWORD)v165 == 2074))
          {
LABEL_380:
            v147 = 0;
            goto LABEL_381;
          }
        }
        else
        {
          v168 = v149 - (*v35 & 0xF);
          if (v149 < (*v35 & 0xFu))
            goto LABEL_490;
          if (v168 < v163)
            goto LABEL_490;
          v167 = v168 / v163;
          if (v168 % v163)
            goto LABEL_490;
          v165 = HIDWORD(v163);
        }
      }
      else
      {
        if ((_DWORD)v149)
          goto LABEL_490;
        v165 = HIDWORD(v163);
        if (v150 == 17)
          goto LABEL_376;
        v167 = 0;
      }
      if ((_DWORD)v165 == 2336)
      {
        if (!v302)
        {
          v169 = v148;
          v170 = v146;
          v302 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", *((_QWORD *)v35 + 1));
          v146 = v170;
          v148 = v169;
        }
        if ((_DWORD)v163)
        {
          v257 = v148;
          v258 = v146;
          v171 = 0;
          v163 = v163;
          do
          {
            v330[0] = MEMORY[0x1E0C809B0];
            v330[1] = 3221225472;
            v330[2] = __SAKCDataReadAheadJetsamCoalitionInfo_block_invoke;
            v330[3] = &unk_1E7147738;
            v172 = v302;
            v330[4] = v172;
            __SAKCDataReadAheadJetsamCoalitionInfo_block_invoke((uint64_t)v330, v173, (_QWORD *)((char *)v152 + v171));

            v171 += v167;
            --v163;
          }
          while (v163);
          v147 = 0;
          v302 = v172;
          v146 = v258;
          v148 = v257;
          goto LABEL_381;
        }
      }
      goto LABEL_380;
    }
    break;
  }
  if (v130 > 49)
  {
    switch(v130)
    {
      case '2':
        v186 = *((_DWORD *)v131 + 1);
        if (!v186 || !*(_DWORD *)v131)
        {
          v177 = *__error();
          _sa_logt();
          v178 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v178, OS_LOG_TYPE_DEBUG))
          {
            v222 = *(_DWORD *)v131;
            v223 = *((_DWORD *)v131 + 1);
            LODWORD(buf.isa) = 67109376;
            HIDWORD(buf.isa) = v222;
            LOWORD(buf.superclass) = 1024;
            *(_DWORD *)((char *)&buf.superclass + 2) = v223;
            _os_log_debug_impl(&dword_1B9BE0000, v178, OS_LOG_TYPE_DEBUG, "Bad timebase: %d/%d", (uint8_t *)&buf, 0xEu);
          }
          goto LABEL_435;
        }
        v187 = *(_DWORD *)(a1 + 188);
        if (v187 && v186 != v187 || (v188 = *(_DWORD *)(a1 + 184)) != 0 && *(_DWORD *)v131 != v188)
        {
          v189 = *__error();
          _sa_logt();
          v190 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
          {
            v191 = *(_DWORD *)(a1 + 188);
            v192 = *(_DWORD *)v131;
            v193 = *((_DWORD *)v131 + 1);
            buf.isa = (__objc2_class *)__PAIR64__(*(_DWORD *)(a1 + 184), 67109888);
            LOWORD(buf.superclass) = 1024;
            *(_DWORD *)((char *)&buf.superclass + 2) = v191;
            HIWORD(buf.superclass) = 1024;
            LODWORD(buf.cache) = v192;
            WORD2(buf.cache) = 1024;
            *(_DWORD *)((char *)&buf.cache + 6) = v193;
            _os_log_impl(&dword_1B9BE0000, v190, OS_LOG_TYPE_DEFAULT, "WARNING: Changing mach timebase! %u/%u -> %u/%u", (uint8_t *)&buf, 0x1Au);
          }

          *__error() = v189;
        }
        *(_QWORD *)(a1 + 184) = *v131;
        if (!v261)
        {
          v301 = 0;
          v261 = 0;
          goto LABEL_503;
        }
        v194 = v307;
        if (v307)
          v307->superclass = (__objc2_class *)v261;
        break;
      case '3':
        v194 = v307;
        v261 = *v131;
        if (!*(_DWORD *)(a1 + 188) || !*(_DWORD *)(a1 + 184))
          goto LABEL_502;
        if (v307)
          v307->superclass = (__objc2_class *)*v131;
        break;
      case '5':
        if (v307)
        {
          v301 = 0;
          *(double *)&v307[1].isa = (double)(unint64_t)*v131 / 1000000.0 - v127;
          goto LABEL_503;
        }
        goto LABEL_502;
      default:
        goto LABEL_503;
    }
    v195 = -[__objc2_class machAbsTime](v194, "machAbsTime");
    v196 = 0;
    v197 = *(_QWORD *)(a1 + 184);
    if ((_DWORD)v197)
    {
      v198 = v307;
      if (HIDWORD(v197))
      {
        v196 = v195;
        if ((_DWORD)v197 != HIDWORD(v197))
          v196 = __udivti3();
      }
    }
    else
    {
      v198 = v307;
    }
    if (v198)
    {
      v301 = 0;
      *(double *)&v198->cache = (double)(unint64_t)v196 / 1000000000.0;
      goto LABEL_503;
    }
    goto LABEL_502;
  }
  if (v130 == -568875622)
  {
    if (objc_msgSend(*(id *)(a1 + 24), "count"))
    {
      v301 = 0;
      *(_QWORD *)(a1 + 360) = 4;
    }
    else
    {
      v206 = *__error();
      _sa_logt();
      v207 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v207, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf.isa) = 0;
        _os_log_debug_impl(&dword_1B9BE0000, v207, OS_LOG_TYPE_DEBUG, "Delta before full, ignoring", (uint8_t *)&buf, 2u);
      }

      *__error() = v206;
      v301 = 1;
    }
    goto LABEL_503;
  }
  if (v130 == 17)
  {
    if (v35 + 4 > (int *)v19 || (char *)v35 + v132 + 16 > (char *)v19 || v128 != 17 && v129 != 32)
      goto LABEL_534;
    v179 = *((_QWORD *)v35 + 1);
    if ((_DWORD)v179)
    {
      if (v128 == 17)
      {
        v180 = HIDWORD(v179);
        if (SHIDWORD(v179) <= 2310)
        {
          switch(HIDWORD(v179))
          {
            case 0x30:
              v181 = 20;
              break;
            case 0x31:
              v181 = 24;
              break;
            case 0x81A:
LABEL_486:
              v181 = 8;
              break;
            default:
              goto LABEL_534;
          }
        }
        else
        {
          switch(HIDWORD(v179))
          {
            case 0x907:
              v181 = 4;
              break;
            case 0x908:
            case 0x909:
              goto LABEL_534;
            case 0x90A:
            case 0x90C:
              goto LABEL_486;
            case 0x90B:
            case 0x90D:
              v181 = 16;
              break;
            default:
              if (HIDWORD(v179) != 2369)
                goto LABEL_534;
              v181 = 48;
              break;
          }
        }
        if (v132 / v181 >= v179 && v132 % v179 < 0x10)
          goto LABEL_498;
LABEL_534:
        v237 = *__error();
        _sa_logt();
        v238 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v238, OS_LOG_TYPE_ERROR))
        {
LABEL_537:

          *__error() = v237;
          goto LABEL_538;
        }
        LODWORD(buf.isa) = 134218240;
        *(__objc2_class **)((char *)&buf.isa + 4) = v295;
        WORD2(buf.superclass) = 2048;
        *(__objc2_class **)((char *)&buf.superclass + 6) = (__objc2_class *)((char *)v35 - (char *)v276);
        v239 = "Error parsing kcdata buffer at byte %ld of %lu: array is invalid";
LABEL_540:
        _os_log_error_impl(&dword_1B9BE0000, v238, OS_LOG_TYPE_ERROR, v239, (uint8_t *)&buf, 0x16u);
        goto LABEL_537;
      }
      v209 = *v35 & 0xF;
      v77 = v132 >= v209;
      v210 = v132 - v209;
      if (!v77)
        goto LABEL_534;
      if (v210 < v179)
        goto LABEL_534;
      v208 = v210 / v179;
      if (v210 % v179)
        goto LABEL_534;
      v180 = HIDWORD(v179);
    }
    else
    {
      if (v132)
        goto LABEL_534;
      v180 = HIDWORD(v179);
      if (v128 == 17)
      {
LABEL_498:
        if ((v180 - 2311) <= 0x3A && ((1 << (v180 - 7)) & 0x400000000000079) != 0)
          goto LABEL_502;
        if ((v180 - 48) < 2)
          goto LABEL_502;
        v208 = 0;
        if ((_DWORD)v180 == 2074)
          goto LABEL_502;
        goto LABEL_459;
      }
      v208 = 0;
    }
LABEL_459:
    v301 = 0;
    if ((_DWORD)v180 != 2328 || (v136 & 1) != 0)
      goto LABEL_503;
    if (*(_QWORD *)(a1 + 360) == 1)
    {
      v240 = *__error();
      _sa_logt();
      v241 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR))
      {
        v242 = *(__objc2_class **)(v304 + 360);
        LODWORD(buf.isa) = 67109376;
        HIDWORD(buf.isa) = v179;
        LOWORD(buf.superclass) = 2048;
        *(__objc2_class **)((char *)&buf.superclass + 2) = v242;
        _os_log_error_impl(&dword_1B9BE0000, v241, OS_LOG_TYPE_ERROR, "%d nonrunnable tasks, but _dataStyle %llu", (uint8_t *)&buf, 0x12u);
      }

      *__error() = v240;
      _SASetCrashLogMessage(3916, "%d nonrunnable tasks, but _dataStyle %llu", v243, v244, v245, v246, v247, v248, v179);
      _os_crash();
      __break(1u);
    }
    else if ((v137 & 1) == 0)
    {
      if ((_DWORD)v179)
      {
        v211 = 0;
        v212 = *((_QWORD *)v35 + 1);
        do
        {
          v319[0] = MEMORY[0x1E0C809B0];
          v319[1] = 3221225472;
          v319[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke;
          v319[3] = &unk_1E7146F68;
          v319[4] = a1;
          v213 = v307;
          v319[5] = v213;
          v319[7] = v264;
          v214 = v282;
          v319[6] = v214;
          __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke((uint64_t)v319, v215, (_QWORD *)((char *)v131 + v211));

          v211 += v208;
          --v212;
        }
        while (v212);
      }
      goto LABEL_502;
    }
    v249 = *__error();
    _sa_logt();
    v250 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.isa) = 67109120;
      HIDWORD(buf.isa) = v179;
      _os_log_error_impl(&dword_1B9BE0000, v250, OS_LOG_TYPE_ERROR, "%d nonrunnable tasks when parsing stackshot in kperf", (uint8_t *)&buf, 8u);
    }

    *__error() = v249;
    _SASetCrashLogMessage(3917, "%d nonrunnable tasks when parsing stackshot in kperf", v251, v252, v253, v254, v255, v256, v179);
    result = _os_crash();
    __break(1u);
    return result;
  }
  if (v130 != 19)
    goto LABEL_503;
  if (v35 + 4 > (int *)v19 || (char *)v35 + v132 + 16 > (char *)v19 || v129 == 32 || v128 != 19 || v132 <= 3)
  {
    v237 = *__error();
    _sa_logt();
    v238 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v238, OS_LOG_TYPE_ERROR))
      goto LABEL_537;
    LODWORD(buf.isa) = 134218240;
    *(__objc2_class **)((char *)&buf.isa + 4) = v295;
    WORD2(buf.superclass) = 2048;
    *(__objc2_class **)((char *)&buf.superclass + 6) = (__objc2_class *)((char *)v35 - (char *)v276);
    v239 = "Error parsing kcdata buffer at byte %ld of %lu: container is invalid";
    goto LABEL_540;
  }
  v140 = v35[4];
  if (v140 <= 2355)
  {
    if (v140 != 2307 && v140 != 2353)
      goto LABEL_479;
    v141 = -[SASampleStore _parseKCDataTaskContainer:timestampOfSample:sampleIndex:sharedCaches:frameIterator:primaryDataIsKPerf:addStaticInfoOnly:taskUniquePidsInThisSample:taskPidsInThisSample:importanceDonations:rPidForJetsamCoalitionId:port_label_info_array:exclaveInfo:]((void *)a1, (unsigned int **)&v328, v307, v264, v28, &v285->super, v137, v136, v282, v275, v277, v281, v262, v138, v274);
  }
  else
  {
    switch(v140)
    {
      case 2356:
LABEL_289:
        v141 = SkipToContainerEnd(&v328, 0);
        break;
      case 2370:
        v141 = -[SASampleStore _parseKCDataSharedCacheContainer:sharedCaches:](a1, (unsigned int **)&v328, v28);
        break;
      case 2377:
        goto LABEL_289;
      default:
LABEL_479:
        v141 = SkipToContainerEnd(&v328, 1);
        break;
    }
  }
  if (!v141)
    goto LABEL_502;
LABEL_538:
  objc_autoreleasePoolPop(contextd);
  v301 = 0;
  v112 = 0;
  v111 = v289;
LABEL_220:
  if (v265)
    free(__ptrb);
  if (!v112)
    goto LABEL_510;
  if ((unint64_t)(v328 + 4) > v329
    || (unint64_t)v328 + v328[1] + 16 > v329
    || *v328 != -242132755)
  {
    v225 = *__error();
    _sa_logt();
    v226 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v226, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.isa) = 134217984;
      *(__objc2_class **)((char *)&buf.isa + 4) = v295;
      _os_log_error_impl(&dword_1B9BE0000, v226, OS_LOG_TYPE_ERROR, "Overran kcdata buffer (length %lu)", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v225;
LABEL_510:

LABEL_16:
    v25 = 0;
    if (a5)
      *a5 = 1;
    goto LABEL_18;
  }
  if (!v303)
  {
    if ((~*(_DWORD *)(v304 + 408) & 0x582) == 0)
      -[SASampleStore resampleTruncatedBacktraces](v304);
    v227 = objc_alloc(MEMORY[0x1E0C99E20]);
    objc_msgSend(*(id *)(v304 + 8), "allKeys");
    v228 = (void *)objc_claimAutoreleasedReturnValue();
    v229 = (void *)objc_msgSend(v227, "initWithArray:", v228);

    objc_msgSend(v229, "minusSet:", v282);
    v310 = 0u;
    v311 = 0u;
    v308 = 0u;
    v309 = 0u;
    v116 = v229;
    v230 = objc_msgSend(v116, "countByEnumeratingWithState:objects:count:", &v308, v331, 16);
    if (!v230)
    {
LABEL_528:

      goto LABEL_529;
    }
    v231 = *(_QWORD *)v309;
LABEL_517:
    v232 = 0;
    while (1)
    {
      if (*(_QWORD *)v309 != v231)
        objc_enumerationMutation(v116);
      -[SASampleStore lastTaskWithUniquePid:]((_QWORD *)v304, objc_msgSend(*(id *)(*((_QWORD *)&v308 + 1) + 8 * v232), "unsignedLongLongValue"));
      v233 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v233, "exitTimestamp");
      v234 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v234)
      {
        v235 = *(_QWORD *)(v304 + 360);
        if (!v235)
          goto LABEL_522;
        if (v235 != 1)
        {
          -[SASampleStore task:exitedAtTimestamp:](v304, v233, v307);
          goto LABEL_522;
        }
      }

LABEL_522:
      if (v230 == ++v232)
      {
        v236 = objc_msgSend(v116, "countByEnumeratingWithState:objects:count:", &v308, v331, 16);
        v230 = v236;
        if (!v236)
          goto LABEL_528;
        goto LABEL_517;
      }
    }
  }
  if ((v111 & 1) == 0 && *(_QWORD *)(v304 + 360) == 3)
  {
    v317[0] = MEMORY[0x1E0C809B0];
    v317[1] = 3221225472;
    v317[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_228;
    v317[3] = &__block_descriptor_40_e20_v24__0__SATask_8_B16l;
    v317[4] = v264;
    objc_msgSend((id)v304, "enumerateTasks:", v317);
    v113 = objc_alloc(MEMORY[0x1E0C99E20]);
    objc_msgSend(*(id *)(v304 + 16), "allKeys");
    v114 = (void *)objc_claimAutoreleasedReturnValue();
    v115 = (void *)objc_msgSend(v113, "initWithArray:", v114);

    objc_msgSend(v115, "minusSet:", v275);
    v315 = 0u;
    v316 = 0u;
    v313 = 0u;
    v314 = 0u;
    v116 = v115;
    v117 = objc_msgSend(v116, "countByEnumeratingWithState:objects:count:", &v313, v332, 16);
    if (v117)
    {
      v118 = *(_QWORD *)v314;
      do
      {
        for (j = 0; j != v117; ++j)
        {
          if (*(_QWORD *)v314 != v118)
            objc_enumerationMutation(v116);
          -[SASampleStore lastTaskWithPid:]((_QWORD *)v304, objc_msgSend(*(id *)(*((_QWORD *)&v313 + 1) + 8 * j), "intValue"));
          v120 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v120, "exitTimestamp");
          v121 = (void *)objc_claimAutoreleasedReturnValue();
          v122 = v121 == 0;

          if (v122)
          {
            buf.isa = 0;
            buf.superclass = &buf;
            buf.cache = (void *)0x3032000000;
            buf.vtable = __Block_byref_object_copy__0;
            buf.info = (__objc2_class_ro *)__Block_byref_object_dispose__0;
            objc_msgSend(v120, "taskStates");
            v123 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v123, "lastObject");
            v124 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v124, "endTimestamp");
            v336 = (id)objc_claimAutoreleasedReturnValue();

            objc_msgSend(v120, "threads");
            v125 = (void *)objc_claimAutoreleasedReturnValue();
            v312[0] = MEMORY[0x1E0C809B0];
            v312[1] = 3221225472;
            v312[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_3;
            v312[3] = &unk_1E7147860;
            v312[4] = &buf;
            objc_msgSend(v125, "enumerateKeysAndObjectsUsingBlock:", v312);

            if (buf.superclass[1].isa)
              v126 = buf.superclass[1].isa;
            else
              v126 = v307;
            -[SASampleStore task:exitedAtTimestamp:](v304, v120, v126);
            _Block_object_dispose(&buf, 8);

          }
        }
        v117 = objc_msgSend(v116, "countByEnumeratingWithState:objects:count:", &v313, v332, 16);
      }
      while (v117);
    }
    goto LABEL_528;
  }
LABEL_529:

  if (a5)
    *a5 = v301 & 1;
  if ((v301 & 1) == 0)
    objc_storeStrong((id *)(v304 + 376), obj);
  v25 = (char *)((char *)v328 - (char *)v276 + v328[1] + 16);
LABEL_18:
  v13 = v307;
LABEL_19:

  return (uint64_t)v25;
}

- (unint64_t)addKCDataStackshot:(id)a3 returningTimestamp:(id *)a4
{
  id v6;
  void *v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  SATimestamp *startTime;
  char v13;

  v6 = a3;
  +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, 0.0);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (-[SASampleStore dataStyle](self, "dataStyle") == 1)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v8 = -[NSMutableArray count](self->_sampleTimestamps, "count");
  v13 = 0;
  v9 = -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:]((uint64_t)self, v6, v7, v8, &v13, 0, 0);
  if (v9)
    v10 = v13 == 0;
  else
    v10 = 0;
  if (v10)
  {
    if (-[SASampleStore dataStyle](self, "dataStyle") == 1)
    {
      startTime = self->_startTime;
      ++self->_numSamples;
      if (!startTime)
        objc_storeStrong((id *)&self->_startTime, v7);
      objc_storeStrong((id *)&self->_endTime, v7);
    }
    else
    {
      -[NSMutableArray addObject:](self->_sampleTimestamps, "addObject:", v7);
    }
    if (self->_nextSampleIsFirstSamplingAllThreads)
    {
      objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllThreads, v7);
      self->_nextSampleIsFirstSamplingAllThreads = 0;
    }
    if (self->_nextSampleIsFirstSamplingAllProcesses)
    {
      objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllProcesses, v7);
      self->_nextSampleIsFirstSamplingAllProcesses = 0;
    }
  }
  if (a4)
    *a4 = objc_retainAutorelease(v7);

  return v9;
}

- (unint64_t)addKCDataStackshot:(id)a3
{
  return -[SASampleStore addKCDataStackshot:returningTimestamp:](self, "addKCDataStackshot:returningTimestamp:", a3, 0);
}

- (uint64_t)_parseKCDataTaskContainer:(void *)a3 timestampOfSample:(unint64_t)a4 sampleIndex:(void *)a5 sharedCaches:(NSObject *)a6 frameIterator:(uint64_t)a7 primaryDataIsKPerf:(char)a8 addStaticInfoOnly:(void *)a9 taskUniquePidsInThisSample:(void *)a10 taskPidsInThisSample:(void *)a11 importanceDonations:(void *)a12 rPidForJetsamCoalitionId:(NSObject *)a13 port_label_info_array:(NSObject *)a14 exclaveInfo:(void *)a15
{
  uint64_t v15;
  unint64_t v19;
  unint64_t v20;
  _OWORD *v21;
  char *v22;
  NSObject *v23;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  uint64_t *v30;
  char *v31;
  uint64_t *v32;
  __objc2_class *v33;
  __objc2_class *v34;
  unint64_t v35;
  BOOL v36;
  int v37;
  NSObject *v38;
  NSObject *v39;
  uint64_t v40;
  const char *v42;
  int v43;
  unint64_t v44;
  _QWORD *v45;
  char *v46;
  unsigned int *v47;
  const char *v48;
  BOOL v49;
  unsigned __int8 *v50;
  uint64_t v51;
  int v52;
  int v53;
  unsigned int v54;
  BOOL v55;
  int v56;
  unsigned int v57;
  BOOL v58;
  _QWORD *v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int *v62;
  unint64_t v63;
  unint64_t v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  __int128 v68;
  __int128 v69;
  size_t v70;
  int v71;
  int v72;
  unsigned int v73;
  uint64_t v74;
  __int128 *v75;
  char *v76;
  __int128 v77;
  size_t v78;
  NSObject *v79;
  char *v80;
  NSObject *v81;
  unsigned int v82;
  uint64_t v83;
  __int128 *v84;
  char *v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  size_t v89;
  int v90;
  char *v91;
  int v92;
  unsigned int v93;
  uint64_t v94;
  __int128 *v95;
  char *v96;
  __int128 v97;
  unint64_t v98;
  size_t v99;
  int v100;
  unsigned int v101;
  NSObject *v102;
  __int128 *v103;
  __int128 v104;
  unsigned int v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  size_t v109;
  void *v110;
  unsigned int v111;
  unsigned __int8 *v112;
  const unsigned __int8 *v113;
  unint64_t v114;
  size_t v115;
  int v116;
  unsigned int v117;
  NSObject *v118;
  __int128 *v119;
  __int128 v120;
  unsigned int *v121;
  unint64_t v122;
  int v123;
  NSObject *v124;
  const char *v125;
  NSObject *v126;
  uint32_t v127;
  int v128;
  uint64_t v129;
  char *v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  NSObject *v134;
  void *v135;
  uint64_t v136;
  void *v137;
  void *v138;
  void *v139;
  void *v140;
  int v141;
  NSObject *v142;
  void *v143;
  void *v144;
  char *v145;
  int v146;
  NSObject *v147;
  _BOOL4 v148;
  const char *v149;
  NSObject *v150;
  uint32_t v151;
  void *v152;
  char v153;
  BOOL v154;
  int v155;
  void *v156;
  NSObject *v157;
  void *v158;
  int v159;
  void *v160;
  void *v161;
  const __CFString *v162;
  void *v163;
  int v164;
  uint64_t v165;
  BOOL v166;
  int v167;
  void *v168;
  void *v169;
  int v170;
  void *v171;
  int v172;
  void *v173;
  int v174;
  uint64_t v175;
  NSObject *v176;
  unint64_t v177;
  uint64_t v178;
  void *v179;
  uint64_t v180;
  _BOOL4 v181;
  unsigned int *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  int v189;
  NSObject *v190;
  const char *v191;
  uint64_t v192;
  char v193;
  NSObject *v194;
  void *v195;
  void *v196;
  int v197;
  int v198;
  NSObject *v199;
  void *v200;
  void *v201;
  void *v202;
  NSObject *v203;
  uint64_t v204;
  NSObject *v205;
  uint64_t v206;
  unint64_t v207;
  uint64_t v208;
  uint64_t v209;
  void *v210;
  const char *v211;
  int v212;
  void *v213;
  uint64_t v214;
  void *v215;
  void *v216;
  uint64_t v217;
  void *v218;
  char v219;
  const char *v220;
  void *v221;
  void *v222;
  uint64_t v223;
  int v224;
  char v225;
  void *v226;
  void *v227;
  void *v228;
  uint64_t v229;
  void *v230;
  void *v231;
  void *v232;
  unsigned int *v233;
  char *v234;
  _DWORD *v235;
  char *v236;
  uint8_t *v237;
  unsigned int *v238;
  unsigned int v239;
  unsigned int v240;
  int v241;
  _DWORD *v242;
  uint64_t v243;
  unint64_t v244;
  unsigned int *v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  int v249;
  NSObject *v250;
  uint64_t v251;
  unint64_t v252;
  unint64_t v253;
  unsigned int v254;
  _QWORD *v255;
  id v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  void *v260;
  unsigned int v261;
  id v262;
  void *v263;
  uint64_t v264;
  unsigned int v265;
  uint64_t v266;
  unsigned int v267;
  NSObject *v268;
  NSObject *v269;
  char *v270;
  char *v271;
  id v272;
  uint64_t v273;
  char *v274;
  int v275;
  NSObject *v276;
  uint8_t *v277;
  id v278;
  void *v279;
  void *v280;
  void *v281;
  id v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t i;
  uint64_t v287;
  void *v288;
  void *v289;
  void *v290;
  const char *v291;
  BOOL v292;
  id v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t j;
  uint64_t v298;
  void *v299;
  _BYTE *v300;
  uint64_t v301;
  uint64_t v302;
  void *v303;
  int v304;
  NSObject *v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  int v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  id v319;
  int v320;
  int v321;
  NSObject *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  int v329;
  NSObject *v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  int v337;
  NSObject *v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  int v345;
  NSObject *v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  int v353;
  NSObject *v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  int v361;
  NSObject *v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  NSObject *v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  int v376;
  NSObject *v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  int v384;
  NSObject *v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  int v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  int v400;
  NSObject *v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  int v408;
  NSObject *v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  NSObject *v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  int v424;
  NSObject *v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  int v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  char v439;
  char v440;
  int v441;
  void *v442;
  unint64_t v443;
  int v444;
  char *v445;
  char *v446;
  char *v447;
  void *v448;
  id v449;
  unint64_t v450;
  unsigned int v451;
  unsigned int v452;
  uint64_t __src;
  _OWORD *__srca;
  uint64_t *v455;
  uint64_t *v456;
  uint64_t *v457;
  uint64_t *v458;
  NSObject *v459;
  char *__s1;
  char *__s1b;
  char *__s1a;
  unsigned __int8 *v463;
  unsigned __int8 *v464;
  unsigned __int8 *v465;
  int v466;
  uint64_t v467;
  NSObject *v468;
  _QWORD *self;
  uint64_t v470;
  unsigned int *v471;
  void *v472;
  _QWORD *v474;
  _QWORD *v475;
  _QWORD *v476;
  NSObject *v477;
  void *v478;
  NSObject *v480;
  uint64_t v481;
  id v483;
  id v484;
  id v485;
  id v486;
  id v487;
  char *newValue;
  NSObject *v489;
  NSObject *v490;
  NSObject *v491;
  char *v492;
  NSObject *v493;
  id v494;
  char *v495;
  char *v496;
  char *v497;
  uint8_t *context;
  __int128 v499;
  __int128 v500;
  __int128 v501;
  __int128 v502;
  __int128 v503;
  __int128 v504;
  __int128 v505;
  __int128 v506;
  _QWORD v507[11];
  _QWORD v508[5];
  NSObject *v509;
  char *v510;
  NSObject *v511;
  NSObject *v512;
  id v513;
  NSObject *v514;
  char *v515;
  NSObject *v516;
  NSObject *v517;
  char *v518;
  unint64_t v519;
  int v520;
  int v521;
  int v522;
  char v523;
  __int128 v524;
  __int128 v525;
  __int128 v526;
  __int128 v527;
  _QWORD v528[4];
  char v529;
  uint64_t v530;
  _BYTE v531[128];
  _BYTE v532[128];
  uint8_t v533[128];
  uint8_t buf[4];
  _BYTE v535[28];
  __int128 v536;
  __int128 v537;
  uint64_t v538;
  _OWORD __dst[4];
  uint8_t v540[16];
  __int128 v541;
  __int128 v542;
  __int128 v543;
  __int128 v544;
  _BYTE v545[40];
  uint64_t v546;

  LOBYTE(v20) = (_BYTE)a11;
  v19 = (unint64_t)a12;
  LOBYTE(v21) = (_BYTE)a10;
  v546 = *MEMORY[0x1E0C80C00];
  v22 = a3;
  v484 = a5;
  v489 = a6;
  v23 = a9;
  v487 = a10;
  v485 = a11;
  v486 = a12;
  v483 = a15;
  LODWORD(a6) = (*a2)[4];
  v467 = *((_QWORD *)*a2 + 1);
  if ((_DWORD)a6 != 2307 && (_DWORD)a6 != 2353)
    goto LABEL_643;
  memset(v545, 0, sizeof(v545));
  v543 = 0u;
  v544 = 0u;
  v541 = 0u;
  v542 = 0u;
  *(_OWORD *)v540 = 0u;
  memset(__dst, 0, 60);
  v493 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  v494 = objc_alloc_init(MEMORY[0x1E0CB3550]);
  v25 = *a2;
  v20 = (unint64_t)a2[1];
  v530 = 0;
  v536 = 0u;
  v537 = 0u;
  v538 = 0;
  v26 = v25 + 2;
  v481 = (uint64_t)a1;
  newValue = v22;
  v466 = (int)a6;
  if ((unint64_t)(v25 + 2) > v20
    || (v27 = *((unsigned int *)v25 + 1), v19 = (unint64_t)v26 + v27, (unint64_t)v26 + v27 > v20))
  {
    v28 = *__error();
    _sa_logt();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
LABEL_6:
      v480 = 0;
      v474 = 0;
      v477 = 0;
      v491 = 0;
      v492 = 0;
      v470 = 0;
      v471 = 0;
      v495 = 0;
      context = 0;
      v30 = 0;
      v21 = 0;
      v490 = 0;
      LODWORD(self) = 0;
      v22 = 0;
      v468 = 0;
LABEL_7:

      *__error() = v28;
      goto LABEL_8;
    }
    *(_WORD *)buf = 0;
    v42 = "Bad kcdataiter";
LABEL_36:
    _os_log_error_impl(&dword_1B9BE0000, v29, OS_LOG_TYPE_ERROR, v42, buf, 2u);
    goto LABEL_6;
  }
  if (*(_DWORD *)v25 != 19)
  {
    v28 = *__error();
    _sa_logt();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_6;
    *(_WORD *)buf = 0;
    v42 = "Not a container";
    goto LABEL_36;
  }
  if (v27 <= 3)
  {
    v28 = *__error();
    _sa_logt();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_6;
    *(_WORD *)buf = 0;
    v42 = "invalid container";
    goto LABEL_36;
  }
  v43 = *((_DWORD *)v25 + 4);
  if (v43 != 2307 && v43 != 2353)
  {
    v28 = *__error();
    _sa_logt();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_6;
    *(_WORD *)buf = 0;
    v42 = "Not a task container";
    goto LABEL_36;
  }
  v44 = v19 + 16;
  if (v19 + 16 > v20)
  {
    v480 = 0;
    v45 = 0;
    v491 = 0;
    v492 = 0;
    v470 = 0;
    v46 = 0;
    context = 0;
    v30 = 0;
    v21 = 0;
    v490 = 0;
    LODWORD(self) = 0;
    v47 = 0;
    v22 = 0;
    v468 = 0;
    v477 = 0;
LABEL_32:
    v471 = v47;
    v474 = v45;
    v495 = v46;
    v28 = *__error();
    _sa_logt();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    *(_WORD *)buf = 0;
    v48 = "Hit end of kcdata before end of container";
LABEL_34:
    _os_log_error_impl(&dword_1B9BE0000, v29, OS_LOG_TYPE_ERROR, v48, buf, 2u);
    goto LABEL_7;
  }
  v480 = 0;
  v45 = 0;
  v491 = 0;
  v492 = 0;
  v470 = 0;
  v46 = 0;
  context = 0;
  v30 = 0;
  v21 = 0;
  v490 = 0;
  LODWORD(self) = 0;
  v47 = 0;
  v22 = 0;
  v468 = 0;
  v477 = 0;
  v32 = 0;
  v49 = 0;
  __src = v25[1];
  v50 = (unsigned __int8 *)&v536 + 8;
  v31 = (char *)&v537 + 8;
  v33 = SASharedCache;
  v34 = SASharedCache;
  while (1)
  {
    v51 = *(unsigned int *)(v19 + 4);
    if (v44 + v51 > v20)
      goto LABEL_32;
    v52 = *(_DWORD *)v19;
    if (*(_DWORD *)v19 == -242132755)
      goto LABEL_32;
    v53 = (v52 & 0xFFFFFFF0) == 0x20 ? 17 : *(_DWORD *)v19;
    if ((v53 - 1) <= 5)
      break;
    if (v53 > 2309)
    {
      if (v53 == 2312)
      {
        if ((_DWORD)v51 == 32 && (*(_BYTE *)(v19 + 8) & 0x8F) == 0)
        {
          v57 = 24;
          goto LABEL_90;
        }
      }
      else if (v53 == 2310 && (_DWORD)v51 == 112 && (*(_BYTE *)(v19 + 8) & 0x8F) == 0)
      {
        v57 = 104;
        goto LABEL_90;
      }
    }
    else
    {
      v58 = v53 == 17 || v53 == 19;
      v57 = *(_DWORD *)(v19 + 4);
      if (v58)
        goto LABEL_90;
    }
    v61 = *(_DWORD *)(v19 + 8) & 0xF;
    v55 = v51 >= v61;
    v57 = v51 - v61;
    if (!v55)
      v57 = 0;
LABEL_90:
    v35 = v19 + 16;
    if (!v49)
      goto LABEL_49;
LABEL_91:
    if (v53 == 2310)
    {
      if ((*(_BYTE *)(v35 + 65) & 0x20) != 0)
        v480 = *(NSObject **)v35;
LABEL_96:
      v49 = 1;
      goto LABEL_97;
    }
    if (v53 != 20)
      goto LABEL_96;
    v49 = v32 != *(uint64_t **)(v19 + 8);
LABEL_97:
    v19 = v44 + *(unsigned int *)(v19 + 4);
    v44 = v19 + 16;
    if (v19 + 16 > v20)
      goto LABEL_32;
  }
  v35 = v19 + 48;
  v54 = *(_DWORD *)(v19 + 8) & 0xF;
  v55 = v51 >= v54;
  v56 = v51 - v54;
  if (!v55)
    v56 = 0;
  v57 = v56 - 32;
  if (v49)
    goto LABEL_91;
LABEL_49:
  if (v53 > 2338)
  {
    if (v53 <= 2351)
    {
      if ((_DWORD)a7)
        v59 = v45;
      else
        v59 = (_QWORD *)v35;
      if (v53 == 2346)
        v60 = (unsigned int *)v35;
      else
        v60 = v47;
      if (v53 == 2339)
        v45 = v59;
      else
        v47 = v60;
      v49 = 0;
      goto LABEL_97;
    }
    switch(v53)
    {
      case 2352:
        v49 = 0;
        v21 = (_OWORD *)v35;
        break;
      case 2368:
        v49 = 0;
        v30 = (uint64_t *)v35;
        break;
      case 2373:
        v49 = 0;
        LODWORD(self) = *(_DWORD *)v35;
        break;
      default:
        goto LABEL_185;
    }
    goto LABEL_97;
  }
  if (v53 > 2308)
  {
    switch(v53)
    {
      case 2309:
        v49 = 0;
        context = (uint8_t *)v35;
        break;
      case 2312:
        if (v57 < 0x28)
          goto LABEL_104;
        if (v33[36].info != (__objc2_class_ro *)-1)
        {
          v497 = v46;
          v476 = v45;
          v447 = v22;
          __s1a = v31;
          v465 = v50;
          v457 = v32;
          v121 = v47;
          v122 = v35;
          dispatch_once(&qword_1ED1DD5C0, &__block_literal_global_1450);
          v35 = v122;
          v47 = v121;
          v34 = SASharedCache;
          v33 = SASharedCache;
          v32 = v457;
          v31 = __s1a;
          v50 = v465;
          v45 = v476;
          v22 = v447;
          v46 = v497;
        }
        if ((BYTE2(v34[34].superclass) & 1) != 0)
        {
LABEL_104:
          v456 = v32;
          __s1b = v31;
          v464 = v50;
          v475 = v45;
          v496 = v46;
          *(_QWORD *)&v536 = *(_QWORD *)v35;
          v62 = v47;
          uuid_copy(v50, (const unsigned __int8 *)(v35 + 8));
          v47 = v62;
          v34 = SASharedCache;
          v33 = SASharedCache;
          v32 = v456;
          v31 = __s1b;
          v50 = v464;
          v45 = v475;
          v46 = v496;
          v49 = 0;
          *(_QWORD *)__s1b = -1;
          *((_QWORD *)__s1b + 1) = -1;
        }
        else
        {
          v49 = 0;
          v68 = *(_OWORD *)v35;
          v69 = *(_OWORD *)(v35 + 16);
          v538 = *(_QWORD *)(v35 + 32);
          v537 = v69;
          v536 = v68;
        }
        goto LABEL_97;
      case 2337:
        v49 = 0;
        v477 = *(NSObject **)v35;
        break;
      default:
        goto LABEL_185;
    }
    goto LABEL_97;
  }
  if (v53 != 17)
  {
    if (v53 != 19)
    {
      if (v53 == 20)
      {
        v495 = v46;
        if (*(_QWORD *)(v19 + 8) != __src)
        {
          v471 = v47;
          v474 = v45;
          v28 = *__error();
          _sa_logt();
          v29 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            goto LABEL_7;
          *(_WORD *)buf = 0;
          v48 = "Unmatched end container";
          goto LABEL_34;
        }
        LODWORD(v20) = v30 == 0;
        v36 = v21 == 0;
        if (context || v30 || v21)
        {
          v471 = v47;
          v474 = v45;
          if (!context)
          {
            v37 = 1;
            goto LABEL_225;
          }
          v128 = 0;
          v129 = *((unsigned int *)context + 21);
          if (context[88])
            v130 = (char *)(context + 88);
          else
            v130 = 0;
          v132 = *(_QWORD *)context;
          v131 = *((_QWORD *)context + 1);
          goto LABEL_247;
        }
        v123 = *__error();
        _sa_logt();
        v124 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)v535 = v467;
          v125 = "No task struct for task container %llu, treating as an unknown container";
          v126 = v124;
          v127 = 12;
          goto LABEL_402;
        }
        goto LABEL_292;
      }
LABEL_185:
      v49 = 0;
      goto LABEL_97;
    }
    if (v51 < 4 || v52 != 19)
      goto LABEL_210;
    v32 = *(uint64_t **)(v19 + 8);
    goto LABEL_96;
  }
  if (v52 != 17 && (v52 & 0xFFFFFFF0) != 0x20)
    goto LABEL_210;
  v63 = *(_QWORD *)(v19 + 8);
  if (!(_DWORD)v63)
  {
    if ((_DWORD)v51)
      goto LABEL_210;
    v64 = HIDWORD(v63);
    if (v52 == 17)
      goto LABEL_135;
LABEL_117:
    v66 = 0;
LABEL_138:
    v49 = 0;
    if ((int)v64 <= 2332)
    {
      if ((_DWORD)v64 == 48)
      {
        LODWORD(v450) = v66;
        v455 = v32;
        __s1 = v31;
        v463 = v50;
        goto LABEL_187;
      }
      if ((_DWORD)v64 == 49)
      {
        LODWORD(v450) = v66;
        v455 = v32;
        __s1 = v31;
        v463 = v50;
        goto LABEL_193;
      }
      if ((_DWORD)v64 != 57)
        goto LABEL_97;
      LODWORD(v450) = v66;
      v443 = v35;
      v455 = v32;
      __s1 = v31;
      v463 = v50;
      v471 = v47;
      v474 = v45;
      v495 = v46;
      if (v22)
        goto LABEL_652;
      v78 = *(_QWORD *)(v19 + 8);
      v79 = *(NSObject **)(v19 + 8);
      v80 = (char *)malloc_type_calloc(v78, 0x38uLL, 0x100004021716A34uLL);
      v81 = v79;
      v22 = v80;
      if ((_DWORD)v81)
      {
        v82 = 0;
        v83 = 0;
        v46 = v495;
        v45 = v474;
        v47 = v471;
        do
        {
          v84 = (__int128 *)(v443 + v82);
          v85 = &v22[v83];
          v86 = *v84;
          v87 = v84[1];
          v88 = v84[2];
          *((_QWORD *)v85 + 6) = *((_QWORD *)v84 + 6);
          *((_OWORD *)v85 + 1) = v87;
          *((_OWORD *)v85 + 2) = v88;
          *(_OWORD *)v85 = v86;
          v83 += 56;
          v82 += v450;
        }
        while (56 * v78 != v83);
        v49 = 0;
        v468 = v81;
        goto LABEL_202;
      }
      v468 = 0;
      v49 = 0;
      v46 = v495;
    }
    else
    {
      if ((int)v64 > 2349)
      {
        if ((_DWORD)v64 != 2350)
        {
          if ((_DWORD)v64 != 2369)
            goto LABEL_97;
          goto LABEL_180;
        }
        LODWORD(v450) = v66;
        v455 = v32;
        v459 = v23;
        __s1 = v31;
        v463 = v50;
        v471 = v47;
        v474 = v45;
        v445 = v22;
        v495 = v46;
        if (v490)
          goto LABEL_655;
        v98 = v35;
        v99 = *(_QWORD *)(v19 + 8);
        v100 = *(_QWORD *)(v19 + 8);
        v490 = malloc_type_calloc(v99, 0x18uLL, 0x1000040504FFAC1uLL);
        if (v100)
        {
          v101 = 0;
          v102 = v490;
          do
          {
            v103 = (__int128 *)(v98 + v101);
            v104 = *v103;
            v102[2].isa = (Class)v103[1];
            *(_OWORD *)&v102->isa = v104;
            v102 += 3;
            v101 += v450;
            --v99;
          }
          while (v99);
        }
        v49 = 0;
        LODWORD(v530) = v100;
        goto LABEL_198;
      }
      v471 = v47;
      v474 = v45;
      v445 = v22;
      if ((_DWORD)v64 == 2333)
      {
        v452 = v66;
        v443 = v35;
        v455 = v32;
        __s1 = v31;
        v463 = v50;
        v495 = v46;
        v89 = *(_QWORD *)(v19 + 8);
        v90 = *(_QWORD *)(v19 + 8);
        v91 = (char *)malloc_type_calloc(v89, 0x1FuLL, 0x1000040B50B66BDuLL);
        v92 = v90;
        v492 = v91;
        if (v90)
        {
          v93 = 0;
          v94 = 0;
          v46 = v495;
          v22 = v445;
          v45 = v474;
          v47 = v471;
          v31 = __s1;
          v50 = v463;
          v32 = v455;
          v33 = SASharedCache;
          v34 = SASharedCache;
          do
          {
            v95 = (__int128 *)(v443 + v93);
            v96 = &v492[v94];
            v97 = *v95;
            if (v452 < 0x1F)
            {
              *(_OWORD *)(v96 + 9) = *(__int128 *)((char *)v95 + 9);
              *(_OWORD *)v96 = v97;
              *(_WORD *)(v96 + 25) = 0;
              *(_DWORD *)(v96 + 27) = 0;
            }
            else
            {
              *(_OWORD *)(v96 + 15) = *(__int128 *)((char *)v95 + 15);
              *(_OWORD *)v96 = v97;
            }
            v94 += 31;
            v93 += v452;
          }
          while (31 * v89 != v94);
          v49 = 0;
          HIDWORD(v470) = v92;
          goto LABEL_97;
        }
        HIDWORD(v470) = 0;
        v49 = 0;
        goto LABEL_199;
      }
      if ((_DWORD)v64 != 2345)
        goto LABEL_97;
      v451 = v66;
      v443 = v35;
      v455 = v32;
      __s1 = v31;
      v463 = v50;
      v70 = *(_QWORD *)(v19 + 8);
      v71 = *(_QWORD *)(v19 + 8);
      v46 = (char *)malloc_type_calloc(v70, 0x1CuLL, 0x100004027586B93uLL);
      v72 = v71;
      if (v71)
      {
        v73 = 0;
        v74 = 0;
        v22 = v445;
        v45 = v474;
        v47 = v471;
        v31 = __s1;
        v50 = v463;
        v32 = v455;
        v33 = SASharedCache;
        v34 = SASharedCache;
        do
        {
          v75 = (__int128 *)(v443 + v73);
          v76 = &v46[v74];
          v77 = *v75;
          if (v451 < 0x1C)
          {
            *(_OWORD *)(v76 + 10) = *(__int128 *)((char *)v75 + 10);
            *(_OWORD *)v76 = v77;
            *((_WORD *)v76 + 13) = 0;
          }
          else
          {
            *(_OWORD *)(v76 + 12) = *(__int128 *)((char *)v75 + 12);
            *(_OWORD *)v76 = v77;
          }
          v74 += 28;
          v73 += v451;
        }
        while (28 * v70 != v74);
        v49 = 0;
        LODWORD(v470) = v72;
        goto LABEL_97;
      }
      LODWORD(v470) = 0;
      v49 = 0;
LABEL_200:
      v22 = v445;
    }
    v45 = v474;
    v47 = v471;
LABEL_202:
    v31 = __s1;
    v50 = v463;
LABEL_203:
    v32 = v455;
    v33 = SASharedCache;
    v34 = SASharedCache;
    goto LABEL_97;
  }
  if (v52 != 17)
  {
    v67 = v51 - (*(_DWORD *)v19 & 0xF);
    if (v51 < (*(_DWORD *)v19 & 0xFu))
      goto LABEL_210;
    if (v67 < v63)
      goto LABEL_210;
    v66 = v67 / v63;
    if (v67 % v63)
      goto LABEL_210;
    v64 = HIDWORD(v63);
    goto LABEL_138;
  }
  v64 = HIDWORD(v63);
  if (SHIDWORD(v63) <= 2310)
  {
    switch(HIDWORD(v63))
    {
      case 0x30:
        v65 = 20;
        break;
      case 0x31:
        v65 = 24;
        break;
      case 0x81A:
        v65 = 8;
        break;
      default:
        goto LABEL_210;
    }
  }
  else
  {
    v471 = v47;
    v474 = v45;
    v495 = v46;
    switch(HIDWORD(v63))
    {
      case 0x907:
        v65 = 4;
        break;
      case 0x908:
      case 0x909:
        goto LABEL_8;
      case 0x90A:
      case 0x90C:
        v65 = 8;
        break;
      case 0x90B:
      case 0x90D:
        v65 = 16;
        break;
      default:
        if (HIDWORD(v63) != 2369)
          goto LABEL_210;
        v65 = 48;
        break;
    }
  }
  if (v51 / v65 >= v63 && v51 % v63 <= 0xF)
  {
LABEL_135:
    v49 = 0;
    if ((int)v64 > 2310)
    {
      v66 = 8;
      switch((int)v64)
      {
        case 2311:
          goto LABEL_97;
        case 2312:
        case 2313:
          goto LABEL_117;
        case 2314:
        case 2316:
          goto LABEL_138;
        case 2315:
        case 2317:
          v66 = 16;
          goto LABEL_138;
        default:
          if ((_DWORD)v64 != 2369)
            goto LABEL_117;
          v66 = 48;
          break;
      }
LABEL_180:
      if ((_DWORD)v63)
      {
        v105 = 0;
        v106 = *(_QWORD *)(v19 + 8);
        do
        {
          v107 = v35 + v105;
          if ((*(_BYTE *)(v107 + 17) & 0x20) != 0)
            v480 = *(NSObject **)v107;
          v105 += v66;
          --v106;
        }
        while (v106);
      }
      goto LABEL_185;
    }
    if ((_DWORD)v64 != 48)
    {
      if ((_DWORD)v64 != 49)
      {
        if ((_DWORD)v64 == 2074)
          goto LABEL_97;
        goto LABEL_117;
      }
      v455 = v32;
      __s1 = v31;
      v463 = v50;
      LODWORD(v450) = 24;
LABEL_193:
      v445 = v22;
      v471 = v47;
      v474 = v45;
      v495 = v46;
      v459 = v23;
      if (v491)
        goto LABEL_631;
      v114 = v35;
      v115 = *(_QWORD *)(v19 + 8);
      v116 = *(_QWORD *)(v19 + 8);
      v491 = malloc_type_calloc(v115, 0x18uLL, 0x1000040504FFAC1uLL);
      if (v116)
      {
        v117 = 0;
        v118 = v491;
        do
        {
          v119 = (__int128 *)(v114 + v117);
          v120 = *v119;
          v118[2].isa = (Class)v119[1];
          *(_OWORD *)&v118->isa = v120;
          v118 += 3;
          v117 += v450;
          --v115;
        }
        while (v115);
      }
      v49 = 0;
      HIDWORD(v530) = v116;
LABEL_198:
      v23 = v459;
LABEL_199:
      v46 = v495;
      goto LABEL_200;
    }
    v455 = v32;
    __s1 = v31;
    v463 = v50;
    LODWORD(v450) = 20;
LABEL_187:
    v443 = v44;
    v446 = v22;
    v471 = v47;
    v474 = v45;
    v495 = v46;
    v459 = v23;
    if (!v491)
    {
      v108 = v35;
      v109 = *(_QWORD *)(v19 + 8);
      v110 = *(void **)(v19 + 8);
      v491 = malloc_type_calloc(v109, 0x18uLL, 0x1000040504FFAC1uLL);
      v442 = v110;
      if ((_DWORD)v110)
      {
        v111 = 0;
        v112 = (unsigned __int8 *)&v491[1];
        do
        {
          v113 = (const unsigned __int8 *)(v108 + v111);
          *((_QWORD *)v112 - 1) = *(unsigned int *)v113;
          uuid_copy(v112, v113 + 4);
          v112 += 24;
          v111 += v450;
          --v109;
        }
        while (v109);
      }
      v49 = 0;
      v44 = v443;
      HIDWORD(v530) = (_DWORD)v442;
      v23 = v459;
      v31 = __s1;
      v46 = v495;
      v22 = v446;
      v45 = v474;
      v47 = v471;
      v50 = v463;
      goto LABEL_203;
    }
    v361 = *__error();
    _sa_logt();
    v362 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v362, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v362, OS_LOG_TYPE_ERROR, "multiple load_info arrays for task", buf, 2u);
    }

    *__error() = v361;
    _SASetCrashLogMessage(2441, "multiple load_info arrays for task", v363, v364, v365, v366, v367, v368, v439);
    _os_crash();
    __break(1u);
LABEL_631:
    LODWORD(v252) = *__error();
    _sa_logt();
    v369 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v369, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v369, OS_LOG_TYPE_ERROR, "multiple load_info arrays for task", buf, 2u);
    }

    *__error() = v252;
    _SASetCrashLogMessage(2459, "multiple load_info arrays for task", v370, v371, v372, v373, v374, v375, v439);
    _os_crash();
    __break(1u);
LABEL_634:
    v376 = *__error();
    _sa_logt();
    v377 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v535 = v252;
      _os_log_error_impl(&dword_1B9BE0000, v377, OS_LOG_TYPE_ERROR, "%d delta threads when parsing stackshot in kperf", buf, 8u);
    }

    *__error() = v376;
    _SASetCrashLogMessage(4766, "%d delta threads when parsing stackshot in kperf", v378, v379, v380, v381, v382, v383, v252);
    _os_crash();
    __break(1u);
LABEL_637:
    v384 = *__error();
    _sa_logt();
    v385 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v385, OS_LOG_TYPE_ERROR))
    {
      v386 = *(_QWORD *)(v481 + 360);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v535 = v252;
      *(_WORD *)&v535[4] = 2048;
      *(_QWORD *)&v535[6] = v386;
      _os_log_error_impl(&dword_1B9BE0000, v385, OS_LOG_TYPE_ERROR, "%d delta threads when dataStyle %llu", buf, 0x12u);
    }

    *__error() = v384;
    _SASetCrashLogMessage(4767, "%d delta threads when dataStyle %llu", v387, v388, v389, v390, v391, v392, v252);
    _os_crash();
    __break(1u);
LABEL_640:
    v393 = *__error();
    _sa_logt();
    a6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(a6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v535 = __s1;
      _os_log_error_impl(&dword_1B9BE0000, a6, OS_LOG_TYPE_ERROR, "no task nor transitioning task, but have p_comm %s", buf, 0xCu);
    }

    *__error() = v393;
    _SASetCrashLogMessage(4387, "no task nor transitioning task, but have p_comm %s", v394, v395, v396, v397, v398, v399, (char)__s1);
    _os_crash();
    __break(1u);
LABEL_643:
    v400 = (int)a6;
    LODWORD(v252) = *__error();
    _sa_logt();
    v401 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v401, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v540 = 67109120;
      *(_DWORD *)&v540[4] = v400;
      _os_log_error_impl(&dword_1B9BE0000, v401, OS_LOG_TYPE_ERROR, "bad container type %u", v540, 8u);
    }

    *__error() = v252;
    _SASetCrashLogMessage(4168, "bad container type %u", v402, v403, v404, v405, v406, v407, v400);
    _os_crash();
    __break(1u);
    while (2)
    {
      v408 = *__error();
      _sa_logt();
      v409 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v409, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v535 = v252;
        _os_log_error_impl(&dword_1B9BE0000, v409, OS_LOG_TYPE_ERROR, "%d nonrunnable tids when parsing stackshot in kperf", buf, 8u);
      }

      *__error() = v408;
      _SASetCrashLogMessage(4856, "%d nonrunnable tids when parsing stackshot in kperf", v410, v411, v412, v413, v414, v415, v252);
      _os_crash();
      __break(1u);
LABEL_649:
      v66 = *__error();
      _sa_logt();
      v416 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v416, OS_LOG_TYPE_ERROR))
      {
        v417 = *(_QWORD *)(v481 + 360);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v535 = v252;
        *(_WORD *)&v535[4] = 2048;
        *(_QWORD *)&v535[6] = v417;
        _os_log_error_impl(&dword_1B9BE0000, v416, OS_LOG_TYPE_ERROR, "%d nonrunnable tids when dataStyle %llu", buf, 0x12u);
      }

      *__error() = v66;
      _SASetCrashLogMessage(4857, "%d nonrunnable tids when dataStyle %llu", v418, v419, v420, v421, v422, v423, v252);
      _os_crash();
      __break(1u);
LABEL_652:
      v424 = *__error();
      _sa_logt();
      v425 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v425, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B9BE0000, v425, OS_LOG_TYPE_ERROR, "multiple aot_info arrays for task", buf, 2u);
      }

      *__error() = v424;
      _SASetCrashLogMessage(2497, "multiple aot_info arrays for task", v426, v427, v428, v429, v430, v431, v439);
      _os_crash();
      __break(1u);
LABEL_655:
      v432 = *__error();
      _sa_logt();
      v165 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v165, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B9BE0000, (os_log_t)v165, OS_LOG_TYPE_ERROR, "multiple text_exec_load_info arrays for task", buf, 2u);
      }

      *__error() = v432;
      _SASetCrashLogMessage(2480, "multiple text_exec_load_info arrays for task", v433, v434, v435, v436, v437, v438, v439);
      _os_crash();
      __break(1u);
LABEL_658:
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v535 = (_DWORD)self;
      _os_log_fault_impl(&dword_1B9BE0000, v23, OS_LOG_TYPE_FAULT, "No shared cache with id %u", buf, 8u);
LABEL_599:

      *__error() = v66;
      LODWORD(v23) = (_DWORD)v468;
      v177 = v19;
LABEL_600:
      if (uuid_is_null((const unsigned __int8 *)&v536 + 8))
      {
        v19 = (unint64_t)context;
        if ((context & 0x40000000) != 0)
        {
          v449 = *(id *)(v481 + 1024);
          v181 = 0;
          v182 = v471;
        }
        else if ((context & 0x80000000) != 0)
        {
          v320 = *__error();
          _sa_logt();
          v23 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)v535 = __s1;
            *(_WORD *)&v535[8] = 1024;
            *(_DWORD *)&v535[10] = (_DWORD)v463;
            _os_log_error_impl(&dword_1B9BE0000, v23, OS_LOG_TYPE_ERROR, "Task %s [%d] is using non-system shared cache, but stackshot has no shared cache info", buf, 0x12u);
          }

          v449 = 0;
          v181 = 0;
          *__error() = v320;
          v182 = v471;
          LODWORD(v23) = (_DWORD)v468;
        }
        else
        {
          v182 = v471;
          if ((context & 0x20000000) != 0)
          {
            v449 = 0;
            v181 = (v450 & 8 | __src) == 0;
          }
          else
          {
            v181 = 0;
            v449 = 0;
            if (v165 && (v177 & 1) == 0)
            {
              v319 = *(id *)(v481 + 1024);
              v182 = v471;
              v449 = v319;
              v181 = 0;
            }
          }
        }
LABEL_334:
        if (v182)
        {
          v183 = *v182 | ((unint64_t)(v182[1] & 0xFFFFFF) << 32);
          if ((v19 & 0x10000000) != 0)
            v183 = SAArchitectureForTranslatedTask(v183);
        }
        else
        {
          v183 = 0;
        }
        if (v165)
        {
          v184 = (v19 >> 28) & 1;
          if ((_DWORD)v23)
            LOBYTE(v184) = 0;
          -[SASampleStore taskForKCDataTask:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:]((void *)v481, v165, v491, HIDWORD(v530), v443, v490, v530, (char)v21, v183, newValue, v449, v184);
          v185 = objc_claimAutoreleasedReturnValue();
          goto LABEL_347;
        }
        if ((v20 & 1) == 0)
        {
          v192 = (v19 >> 28) & 1;
          if ((_DWORD)v23)
            LOBYTE(v192) = 0;
          v193 = (char)v21;
          v187 = (uint64_t)v455;
          -[SASampleStore taskForKCDataDeltaTask:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:timestamp:sharedCache:needAOTInfo:]((void *)v481, *v455, v491, HIDWORD(v530), v443, v490, v530, v193, newValue, v449, v192);
          v23 = objc_claimAutoreleasedReturnValue();
          if (v181)
            goto LABEL_348;
          goto LABEL_359;
        }
        if (!__src)
          goto LABEL_625;
        v186 = (v19 >> 28) & 1;
        if ((_DWORD)v23)
          LOBYTE(v186) = 0;
        -[SASampleStore taskForKCDataTransitioningTask:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:]((void *)v481, __src, v491, HIDWORD(v530), v443, v490, v530, (char)v21, newValue, v449, v186);
        v185 = objc_claimAutoreleasedReturnValue();
LABEL_347:
        v23 = v185;
        v187 = (uint64_t)v455;
        if (v181)
        {
LABEL_348:
          -[NSObject sharedCache](v23, "sharedCache");
          v188 = (void *)objc_claimAutoreleasedReturnValue();

          if (v188)
          {
            v189 = *__error();
            _sa_logt();
            v190 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v190, OS_LOG_TYPE_FAULT))
            {
              -[NSObject sharedCache](v23, "sharedCache");
              v471 = (unsigned int *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v471, "debugDescription");
              self = (_QWORD *)objc_claimAutoreleasedReturnValue();
              -[NSObject debugDescription](v23, "debugDescription");
              v302 = objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              *(_QWORD *)v535 = self;
              *(_WORD *)&v535[8] = 2112;
              *(_QWORD *)&v535[10] = v302;
              v303 = (void *)v302;
              _os_log_fault_impl(&dword_1B9BE0000, v190, OS_LOG_TYPE_FAULT, "shared cache previously %@, though task %@ now has no shared cache", buf, 0x16u);

            }
            *__error() = v189;
            v187 = (uint64_t)v455;
            if (v23)
            {
              objc_setProperty_atomic(v23, v191, 0, 256);
              goto LABEL_358;
            }
          }
          else if (v23)
          {
LABEL_358:
            LOBYTE(v23[9].isa) = 1;
          }
        }
LABEL_359:
        v194 = v477;
        if (v486 && v477)
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v477);
          v195 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v486, "objectForKeyedSubscript:", v195);
          v196 = (void *)objc_claimAutoreleasedReturnValue();

          if (v196)
          {
            v197 = objc_msgSend(v196, "intValue");
            if (v197 != -1 && v23)
              HIDWORD(v23[10].isa) = v197;
          }
          else
          {
            LODWORD(v443) = v177;
            v198 = *__error();
            _sa_logt();
            v199 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT))
            {
              -[NSObject debugDescription](v23, "debugDescription");
              v200 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              *(_QWORD *)v535 = v200;
              *(_WORD *)&v535[8] = 2048;
              *(_QWORD *)&v535[10] = v477;
              _os_log_impl(&dword_1B9BE0000, v199, OS_LOG_TYPE_DEFAULT, "WARNING: Task %@ has jetsam coalition id %llu, but stackshot has no info for that coalition", buf, 0x16u);

            }
            *__error() = v198;
            v187 = (uint64_t)v455;
            v177 = v443;
          }

        }
        if (!objc_msgSend(*(id *)(v481 + 24), "count", v194))
          goto LABEL_374;
        -[NSObject taskStates](v23, "taskStates");
        v201 = (void *)objc_claimAutoreleasedReturnValue();
        if (!objc_msgSend(v201, "count"))
        {
          -[NSObject execTimestamp](v23, "execTimestamp");
          v202 = (void *)objc_claimAutoreleasedReturnValue();
          if (v202)
            goto LABEL_372;
          if ((a7 & 1) != 0)
          {
            v472 = *(void **)(v481 + 16);
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v23, "pid"));
            v478 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v472, "objectForKeyedSubscript:", v478);
            v210 = (void *)objc_claimAutoreleasedReturnValue();
            v471 = (unsigned int *)objc_msgSend(v210, "count");

            if ((unint64_t)v471 >= 2 && v23)
LABEL_400:
              objc_setProperty_atomic(v23, v211, newValue, 224);
LABEL_374:
            LODWORD(v471) = (v19 & 0x10) != 0
                         || v165 && *(_DWORD *)(v165 + 56)
                         || (v20 & 1) == 0 && *(_DWORD *)(v187 + 48);
            if ((a8 & 1) != 0)
            {
              v477 = 0;
              v20 = (unint64_t)v489;
              v203 = v490;
              v204 = v481;
              v205 = v491;
              goto LABEL_439;
            }
            if ((_DWORD)a7)
            {
              if (v165)
              {
                if (a4)
                {
                  v206 = 0;
                  if (a4 == 0x7FFFFFFFFFFFFFFFLL)
                    v207 = 0x7FFFFFFFFFFFFFFFLL;
                  else
                    v207 = a4 - 1;
                  v208 = *(_QWORD *)(v481 + 184);
                  if ((_DWORD)v208)
                  {
                    v209 = 0;
                    if (HIDWORD(v208))
                    {
                      v206 = *(_QWORD *)(v165 + 16);
                      if ((_DWORD)v208 == HIDWORD(v208))
                      {
                        v209 = *(_QWORD *)(v165 + 24);
                      }
                      else
                      {
                        v206 = __udivti3();
                        v187 = (uint64_t)v455;
                        v209 = __udivti3();
                      }
                    }
                  }
                  else
                  {
                    v209 = 0;
                  }
                  v212 = *(_DWORD *)(v165 + 8);
                  -[SASampleStore backfillTask:lastSampleIndex:timestamp:haveSnap:terminatedThreadsUserTimeInNs:terminatedThreadsSystemTimeInNs:terminatedThreadsCycles:terminatedThreadsInstructions:suspendCount:pageins:isDarwinBG:isForeground:isBoosted:isDirty:haveWQFlags:wqExceededTotalThreadLimit:wqExceededConstrainedThreadLimit:haveMem:taskSizeInBytes:haveLatencyQos:latencyQos:]((void *)v481, v23, v207, newValue, 1, v206, v209, 0, 0, *(_DWORD *)(v165 + 56), *(_DWORD *)(v165 + 64), (v212 & 0x40) != 0, (v212 & 0x400) != 0, (v212 & 0x800) != 0, BYTE2(v212) & 1, (v212 & 0x80000) != 0, (v212 & 0x40000) != 0, (v212 & 0x20000) != 0, *(_QWORD *)(v165 + 40) != 0,
                    *(_QWORD *)(v165 + 40),
                    1,
                    *(_DWORD *)(v165 + 80));
                }
                goto LABEL_410;
              }
LABEL_622:
              v345 = *__error();
              _sa_logt();
              v346 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v346, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl(&dword_1B9BE0000, v346, OS_LOG_TYPE_ERROR, "no task_struct when backfilling kperf", buf, 2u);
              }

              *__error() = v345;
              _SASetCrashLogMessage(4572, "no task_struct when backfilling kperf", v347, v348, v349, v350, v351, v352, v440);
              _os_crash();
              __break(1u);
LABEL_625:
              v353 = *__error();
              _sa_logt();
              v354 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v354, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl(&dword_1B9BE0000, v354, OS_LOG_TYPE_ERROR, "no task_struct, task_delta_struct, nor task_transitioning_struct", buf, 2u);
              }

              *__error() = v353;
              _SASetCrashLogMessage(4524, "no task_struct, task_delta_struct, nor task_transitioning_struct", v355, v356, v357, v358, v359, v360, v439);
              _os_crash();
              __break(1u);
            }
LABEL_410:
            -[NSObject taskStates](v23, "taskStates");
            v213 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v213, "lastObject");
            v214 = objc_claimAutoreleasedReturnValue();

            self = (_QWORD *)v214;
            if (v214)
            {
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v23, "pid"));
              v215 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v485, "objectForKeyedSubscript:", v215);
              v216 = (void *)objc_claimAutoreleasedReturnValue();
              v217 = *(_QWORD *)(v481 + 184);
              v19 = v177;
              if (v165)
              {
                v218 = v215;
                v219 = -[SATaskState correspondsToKCDataTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:]((uint64_t)self, v165, v474, v217, v216);

                if ((v219 & 1) != 0)
                  goto LABEL_422;
LABEL_415:
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v23, "pid"));
                v221 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v485, "objectForKeyedSubscript:", v221);
                v222 = (void *)objc_claimAutoreleasedReturnValue();
                v204 = v481;
                +[SATaskState stateWithKCDataTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, v165, v474, *(_QWORD *)(v481 + 184), v222, newValue, newValue, a4, a4);
                v223 = objc_claimAutoreleasedReturnValue();
LABEL_424:
                v226 = (void *)v223;

                v20 = (unint64_t)v489;
                if (v23)
                {
                  -[objc_class addObject:](v23[1].isa, "addObject:", v226);
                  -[objc_class count](v23[1].isa, "count");
                }

LABEL_427:
                if ((_DWORD)v19)
                {
                  v477 = v23;
                  -[NSObject binaryLoadInfos](v477, "binaryLoadInfos");
                  v227 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend((id)v20, "setKernelBinaryLoadInfos:", v227);

                }
                else
                {
                  -[NSObject binaryLoadInfos](v23, "binaryLoadInfos");
                  v228 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend((id)v20, "setUserBinaryLoadInfos:", v228);

                  if (v23)
                    v229 = BYTE1(v23[9].isa) & 1;
                  else
                    v229 = 0;
                  objc_msgSend((id)v20, "setAssumeUserBinaryLoadInfosContainMainBinary:", v229);
                  -[NSObject sharedCache](v23, "sharedCache");
                  v230 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend((id)v20, "setSharedCache:", v230);

                  if ((context & 0x10000000) != 0)
                  {
                    -[SASampleStore addressTranslationsForPid:](v204, -[NSObject pid](v23, "pid"));
                    v231 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend((id)v20, "setAddressTranslations:", v231);

                  }
                  -[SASampleStore lastTaskWithPid:]((_QWORD *)v204, 0);
                  v477 = objc_claimAutoreleasedReturnValue();
                  if (!v477)
                  {
                    +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, a7 << 63 >> 63, 0, 0);
                    v477 = objc_claimAutoreleasedReturnValue();
                    -[SASampleStore addTask:](v204, v477);
                  }
                }
                v203 = v490;
                v205 = v491;
                if (*(_BYTE *)(v204 + 220) && !v480)
                {
                  -[NSObject mainThread](v23, "mainThread");
                  v232 = (void *)objc_claimAutoreleasedReturnValue();
                  v480 = objc_msgSend(v232, "threadId");

                }
LABEL_439:
                if (v205)
                  free(v205);
                HIDWORD(v530) = 0;
                if (v203)
                  free(v203);
                LODWORD(v530) = 0;
                if (v22)
                  free(v22);
                v233 = a2[1];
                v234 = (char *)*a2 + (*a2)[1];
                v235 = v234 + 16;
                *a2 = (unsigned int *)(v234 + 16);
                v236 = v234 + 32;
                v22 = newValue;
                if (v236 > (char *)v233)
                {
LABEL_446:
                  v40 = 0;
LABEL_551:
                  if (!(_DWORD)v40 && (a8 & 1) == 0)
                  {
                    if ((a7 & 1) == 0)
                    {
                      v278 = objc_alloc(MEMORY[0x1E0C99E20]);
                      -[NSObject threads](v23, "threads");
                      v279 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v279, "allKeys");
                      v280 = (void *)objc_claimAutoreleasedReturnValue();
                      v281 = (void *)objc_msgSend(v278, "initWithArray:", v280);

                      objc_msgSend(v281, "minusSet:", v493);
                      v505 = 0u;
                      v506 = 0u;
                      v503 = 0u;
                      v504 = 0u;
                      v282 = v281;
                      v283 = objc_msgSend(v282, "countByEnumeratingWithState:objects:count:", &v503, v532, 16);
                      if (v283)
                      {
                        v284 = v283;
                        v285 = *(_QWORD *)v504;
                        do
                        {
                          for (i = 0; i != v284; ++i)
                          {
                            if (*(_QWORD *)v504 != v285)
                              objc_enumerationMutation(v282);
                            v287 = *(_QWORD *)(*((_QWORD *)&v503 + 1) + 8 * i);
                            -[NSObject threads](v23, "threads");
                            v288 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v288, "objectForKeyedSubscript:", v287);
                            v289 = (void *)objc_claimAutoreleasedReturnValue();

                            objc_msgSend(v289, "exitTimestamp");
                            v290 = (void *)objc_claimAutoreleasedReturnValue();

                            if (v290)
                              v292 = 1;
                            else
                              v292 = v289 == 0;
                            if (!v292)
                              objc_setProperty_atomic(v289, v291, v22, 40);

                          }
                          v284 = objc_msgSend(v282, "countByEnumeratingWithState:objects:count:", &v503, v532, 16);
                        }
                        while (v284);
                      }

                    }
                    v501 = 0u;
                    v502 = 0u;
                    v499 = 0u;
                    v500 = 0u;
                    v293 = v494;
                    v294 = objc_msgSend(v293, "countByEnumeratingWithState:objects:count:", &v499, v531, 16);
                    if (v294)
                    {
                      v295 = v294;
                      v296 = *(_QWORD *)v500;
                      do
                      {
                        for (j = 0; j != v295; ++j)
                        {
                          if (*(_QWORD *)v500 != v296)
                            objc_enumerationMutation(v293);
                          v298 = *(_QWORD *)(*((_QWORD *)&v499 + 1) + 8 * j);
                          if ((unint64_t)objc_msgSend(v293, "countForObject:", v298) >= 2)
                          {
                            -[NSObject dispatchQueues](v23, "dispatchQueues");
                            v299 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v299, "objectForKeyedSubscript:", v298);
                            v300 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                            if (v300)
                              v300[24] = 1;

                          }
                        }
                        v295 = objc_msgSend(v293, "countByEnumeratingWithState:objects:count:", &v499, v531, 16);
                      }
                      while (v295);
                    }

                    v40 = 0;
                    v20 = (unint64_t)v489;
                  }
LABEL_579:
                  if (v492)
                    free(v492);
                  if (v495)
                    free(v495);
                  objc_msgSend((id)v20, "clearTaskData");

                  v23 = v459;
                  goto LABEL_21;
                }
                v491 = a14;
                v490 = a13;
LABEL_448:
                if (&v236[v235[1]] > (char *)v233 || *v235 == -242132755)
                  goto LABEL_446;
                v237 = (uint8_t *)MEMORY[0x1BCCCC288]();
                KCLogIter(*a2, (unint64_t)a2[1], 0);
                v238 = *a2;
                v239 = **a2;
                v240 = v239 & 0xFFFFFFF0;
                if ((v239 & 0xFFFFFFF0) == 0x20)
                  v241 = 17;
                else
                  v241 = **a2;
                v242 = v238 + 4;
                if ((v241 - 1) >= 6)
                  v243 = (uint64_t)(v238 + 4);
                else
                  v243 = (uint64_t)(*a2 + 12);
                context = v237;
                if (v241 > 19)
                {
                  if (v241 == 2332)
                  {
                    v248 = v243 + 8;
                    if (uuid_is_null((const unsigned __int8 *)(v243 + 8)))
                    {
                      v249 = *__error();
                      _sa_logt();
                      v250 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_error_impl(&dword_1B9BE0000, v250, OS_LOG_TYPE_ERROR, "Kernel cache UUID is all zeros", buf, 2u);
                      }

                      *__error() = v249;
                    }
                    else
                    {
                      v255 = (_QWORD *)v243;
                      v526 = 0u;
                      v527 = 0u;
                      v524 = 0u;
                      v525 = 0u;
                      v256 = *(id *)(v204 + 104);
                      v257 = objc_msgSend(v256, "countByEnumeratingWithState:objects:count:", &v524, v533, 16);
                      if (v257)
                      {
                        v258 = v257;
                        v259 = *(_QWORD *)v525;
LABEL_485:
                        v19 = 0;
                        while (1)
                        {
                          if (*(_QWORD *)v525 != v259)
                            objc_enumerationMutation(v256);
                          v260 = *(void **)(*((_QWORD *)&v524 + 1) + 8 * v19);
                          if ((objc_msgSend(v260, "matchesUUID:loadAddress:", v248, *v255) & 1) != 0)
                            break;
                          if (v258 == ++v19)
                          {
                            v258 = objc_msgSend(v256, "countByEnumeratingWithState:objects:count:", &v524, v533, 16);
                            if (v258)
                              goto LABEL_485;
                            goto LABEL_491;
                          }
                        }
                        v262 = v260;

                        v204 = v481;
                        if (v262)
                          goto LABEL_506;
                      }
                      else
                      {
LABEL_491:

                        v204 = v481;
                      }
                      uuidForBytes(v248);
                      v263 = (void *)objc_claimAutoreleasedReturnValue();
                      +[SAKernelCache kernelCacheWithUUID:loadAddress:](SAKernelCache, "kernelCacheWithUUID:loadAddress:", v263, *v255);
                      v262 = (id)objc_claimAutoreleasedReturnValue();

                      objc_msgSend(*(id *)(v204 + 104), "addObject:", v262);
LABEL_506:

                      v22 = newValue;
                    }
                  }
                  else if (v241 == 20)
                  {
                    v301 = *((_QWORD *)v238 + 1);
                    if (v467 == v301)
                    {
                      v40 = 0;
                      v277 = context;
                    }
                    else
                    {
                      v275 = *__error();
                      _sa_logt();
                      v276 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v276, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134218240;
                        *(_QWORD *)v535 = v467;
                        *(_WORD *)&v535[8] = 2048;
                        *(_QWORD *)&v535[10] = v301;
                        _os_log_error_impl(&dword_1B9BE0000, v276, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
                      }
                      v40 = 7;
LABEL_549:
                      v277 = context;

                      *__error() = v275;
                    }
                    objc_autoreleasePoolPop(v277);
                    goto LABEL_551;
                  }
                  goto LABEL_539;
                }
                v244 = (unint64_t)a2[1];
                if (v241 != 17)
                {
                  if (v241 == 19)
                  {
                    v245 = v238 + 4;
                    if ((unint64_t)(v238 + 4) > v244
                      || (v246 = v238[1], (unint64_t)v245 + v246 > v244)
                      || v240 == 32
                      || v239 != 19
                      || v246 <= 3)
                    {
                      v275 = *__error();
                      _sa_logt();
                      v276 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v276, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 67109120;
                        *(_DWORD *)v535 = v466;
                        _os_log_error_impl(&dword_1B9BE0000, v276, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
                      }
                      v40 = 1;
                      goto LABEL_549;
                    }
                    if (*v242 == 2356)
                    {
                      v40 = SkipToContainerEnd((int **)a2, 0);
                    }
                    else
                    {
                      if (*v242 == 2308)
                        v247 = -[SASampleStore _parseKCDataThreadContainer:timestampOfSample:sampleIndex:task:kernelTask:frameIterator:mainThreadID:primaryDataIsKPerf:addStaticInfoOnly:threadIDsInThisTaskThisSample:dispatchQueueIDsInThisTaskThisSample:taskIsSuspended:waitInfos:numWaitInfos:turnstileInfos:numTurnstileInfos:port_label_info_array:exclaveInfo:]((_BYTE *)v204, (int **)a2, v22, a4, v23, v477, (void *)v20, v480, a7, a8, v493, v494, (char)v471, (uint64_t)v492, HIDWORD(v470), (uint64_t)v495, v470, v441, a13,
                                 a14,
                                 v483);
                      else
                        v247 = SkipToContainerEnd((int **)a2, 1);
                      v40 = v247;
                    }
                    objc_autoreleasePoolPop(v237);
                    if ((_DWORD)v40)
                      goto LABEL_579;
                    goto LABEL_540;
                  }
                  goto LABEL_539;
                }
                if ((unint64_t)(v238 + 4) > v244)
                  goto LABEL_544;
                v251 = v238[1];
                if ((unint64_t)v238 + v251 + 16 > v244 || v239 != 17 && v240 != 32)
                  goto LABEL_544;
                v252 = *((_QWORD *)v238 + 1);
                if ((_DWORD)v252)
                {
                  if (v239 == 17)
                  {
                    v253 = HIDWORD(v252);
                    if (SHIDWORD(v252) <= 2310)
                    {
                      switch(HIDWORD(v252))
                      {
                        case 0x30:
                          v254 = 20;
                          break;
                        case 0x31:
                          v254 = 24;
                          break;
                        case 0x81A:
LABEL_510:
                          v254 = 8;
                          break;
                        default:
                          goto LABEL_544;
                      }
                    }
                    else
                    {
                      switch(HIDWORD(v252))
                      {
                        case 0x907:
                          v254 = 4;
                          break;
                        case 0x908:
                        case 0x909:
                          goto LABEL_544;
                        case 0x90A:
                        case 0x90C:
                          goto LABEL_510;
                        case 0x90B:
                        case 0x90D:
                          v254 = 16;
                          break;
                        default:
                          if (HIDWORD(v252) != 2369)
                            goto LABEL_544;
                          v254 = 48;
                          break;
                      }
                    }
                    if (v251 / v254 < v252
                      || v251 % v252 >= 0x10)
                    {
LABEL_544:
                      v275 = *__error();
                      _sa_logt();
                      v276 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v276, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        v40 = 2;
                        _os_log_error_impl(&dword_1B9BE0000, v276, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", buf, 2u);
                      }
                      else
                      {
                        v40 = 2;
                      }
                      goto LABEL_549;
                    }
LABEL_518:
                    if ((int)v253 > 2310)
                    {
                      LODWORD(v21) = 8;
                      switch((int)v253)
                      {
                        case 2311:
                          goto LABEL_539;
                        case 2312:
                        case 2313:
                          goto LABEL_494;
                        case 2314:
                        case 2316:
                          goto LABEL_521;
                        case 2315:
                        case 2317:
                          LODWORD(v21) = 16;
                          goto LABEL_521;
                        default:
                          if ((_DWORD)v253 != 2369)
                            goto LABEL_494;
                          LODWORD(v21) = 48;
                          break;
                      }
                      goto LABEL_523;
                    }
                    if ((v253 - 48) < 2 || (_DWORD)v253 == 2074)
                      goto LABEL_539;
LABEL_494:
                    LODWORD(v21) = 0;
                  }
                  else
                  {
                    v261 = v251 - (**a2 & 0xF);
                    if (v251 < (**a2 & 0xF))
                      goto LABEL_544;
                    if (v261 < v252)
                      goto LABEL_544;
                    LODWORD(v21) = v261 / v252;
                    if (v261 % v252)
                      goto LABEL_544;
                    v253 = HIDWORD(v252);
                  }
LABEL_521:
                  if ((_DWORD)v253 == 2327)
                  {
                    if ((a8 & 1) == 0)
                    {
                      if ((_DWORD)a7)
                        continue;
                      if (*(_QWORD *)(v204 + 360) == 1)
                        goto LABEL_649;
                      v474 = (_QWORD *)v243;
                      if ((_DWORD)v252)
                      {
                        v267 = 0;
                        v19 = v252;
                        do
                        {
                          v507[0] = MEMORY[0x1E0C809B0];
                          v507[1] = v15;
                          v507[2] = __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_279;
                          v507[3] = &unk_1E71470A0;
                          v507[4] = v204;
                          v507[9] = v480;
                          v268 = v493;
                          v507[5] = v268;
                          v269 = v23;
                          v507[6] = v269;
                          v270 = v22;
                          v271 = v22;
                          v507[7] = v271;
                          v507[10] = a4;
                          v272 = v494;
                          v507[8] = v272;
                          __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_279((uint64_t)v507, v273, (_QWORD *)((char *)v474 + v267));

                          v204 = v481;
                          v22 = v270;
                          v20 = (unint64_t)v489;

                          v267 += v21;
                          --v19;
                        }
                        while (v19);
                      }
                    }
                    goto LABEL_539;
                  }
                  if ((_DWORD)v253 != 2369)
                  {
LABEL_539:
                    objc_autoreleasePoolPop(context);
LABEL_540:
                    v233 = a2[1];
                    v274 = (char *)*a2 + (*a2)[1];
                    v235 = v274 + 16;
                    *a2 = (unsigned int *)(v274 + 16);
                    v236 = v274 + 32;
                    if (v236 > (char *)v233)
                      goto LABEL_446;
                    goto LABEL_448;
                  }
LABEL_523:
                  if ((a8 & 1) == 0)
                  {
                    if ((_DWORD)a7)
                      goto LABEL_634;
                    if (*(_QWORD *)(v204 + 360) == 1)
                      goto LABEL_637;
                    if ((_DWORD)v252)
                    {
                      v264 = v243;
                      v265 = 0;
                      v252 = v252;
                      do
                      {
                        v508[0] = MEMORY[0x1E0C809B0];
                        v508[1] = v15;
                        v508[2] = __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_275;
                        v508[3] = &unk_1E7147078;
                        v508[4] = v204;
                        v514 = v480;
                        v520 = (int)v21;
                        v521 = HIDWORD(v470);
                        v515 = v492;
                        v516 = a13;
                        v522 = v470;
                        v517 = a14;
                        v518 = v495;
                        v509 = v493;
                        v510 = v22;
                        v519 = a4;
                        v511 = v23;
                        v512 = v477;
                        v523 = (char)v471;
                        v513 = v494;
                        __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_275((uint64_t)v508, v266, (uint64_t *)(v264 + v265));

                        v265 += v21;
                        --v252;
                      }
                      while (v252);
                    }
                  }
                  goto LABEL_539;
                }
                if ((_DWORD)v251)
                  goto LABEL_544;
                v253 = HIDWORD(v252);
                if (v239 == 17)
                  goto LABEL_518;
                goto LABEL_494;
              }
              if ((v20 & 1) != 0)
              {
                v224 = -[SATaskState correspondsToKCDataTransitioningTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:]((uint64_t)self, __src, v474, v217, v216);

                if (v224)
                {
LABEL_422:
                  objc_setProperty_atomic(self, v220, newValue, 40);
                  self[7] = a4;
                  v20 = (unint64_t)v489;
                  v204 = v481;
                  goto LABEL_427;
                }
LABEL_420:
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v23, "pid"));
                v221 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v485, "objectForKeyedSubscript:", v221);
                v222 = (void *)objc_claimAutoreleasedReturnValue();
                v204 = v481;
                +[SATaskState stateWithKCDataTransitioningTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, __src, (uint64_t)v474, *(_QWORD *)(v481 + 184), v222, newValue, newValue, a4, a4);
                v223 = objc_claimAutoreleasedReturnValue();
                goto LABEL_424;
              }
              v225 = -[SATaskState correspondsToKCDataDeltaTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:]((uint64_t)self, v187, v474, v217, v216);

              if ((v225 & 1) != 0)
                goto LABEL_422;
            }
            else
            {
              v19 = v177;
              if (v165)
                goto LABEL_415;
              if ((v20 & 1) != 0)
                goto LABEL_420;
            }
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", -[NSObject pid](v23, "pid"));
            v221 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v485, "objectForKeyedSubscript:", v221);
            v222 = (void *)objc_claimAutoreleasedReturnValue();
            v204 = v481;
            +[SATaskState stateWithKCDataDeltaTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, v187, v474, *(_QWORD *)(v481 + 184), v222, newValue, newValue, a4, a4);
            v223 = objc_claimAutoreleasedReturnValue();
            goto LABEL_424;
          }
          if (!*(_BYTE *)(v481 + 222) && !*(_BYTE *)(v481 + 223))
          {

            if (v23)
              goto LABEL_400;
            goto LABEL_374;
          }
LABEL_372:

        }
        goto LABEL_374;
      }
      break;
    }
    -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](v481, (uint64_t)&v536 + 8, v536, v538);
    v449 = (id)objc_claimAutoreleasedReturnValue();
    v181 = 0;
    v182 = v471;
LABEL_333:
    v19 = (unint64_t)context;
    goto LABEL_334;
  }
LABEL_210:
  v471 = v47;
  v474 = v45;
  v495 = v46;
LABEL_8:
  LODWORD(v20) = v30 == 0;
  v36 = v21 == 0;
  v37 = (int)context;
  if (context)
  {
LABEL_9:
    v20 = (unint64_t)v489;
    v38 = v490;
    v39 = v491;
    goto LABEL_10;
  }
LABEL_225:
  if ((_DWORD)v20)
  {
    if (v36)
    {
      if (!v37)
        goto LABEL_9;
      v131 = 0;
      v130 = 0;
      v129 = 0xFFFFFFFFLL;
      v133 = 1;
      v132 = -1;
    }
    else
    {
      if (*((_BYTE *)v21 + 28))
        v130 = (char *)v21 + 28;
      else
        v130 = 0;
      if ((v37 & 1) == 0)
        goto LABEL_9;
      v133 = 0;
      v129 = *((unsigned int *)v21 + 6);
      v132 = *(_QWORD *)v21;
      v131 = *((_QWORD *)v21 + 1);
    }
  }
  else
  {
    v132 = *v30;
    if (v36)
    {
      if ((v37 & 1) == 0)
        goto LABEL_9;
      v130 = 0;
      v131 = v30[1];
      v129 = 0xFFFFFFFFLL;
      v133 = 1;
    }
    else
    {
      if (*((_BYTE *)v21 + 28))
        v130 = (char *)v21 + 28;
      else
        v130 = 0;
      if ((v37 & 1) == 0)
        goto LABEL_9;
      v133 = 0;
      v129 = *((unsigned int *)v21 + 6);
      v131 = v30[1];
    }
  }
  if ((_DWORD)a7)
  {
    v123 = *__error();
    _sa_logt();
    v134 = objc_claimAutoreleasedReturnValue();
    v124 = v134;
    if (v133)
    {
      v20 = (unint64_t)v489;
      if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)v535 = v467;
        _os_log_error_impl(&dword_1B9BE0000, v124, OS_LOG_TYPE_ERROR, "no task_struct for task container %llu when primary data is kperf", buf, 0xCu);
      }
    }
    else
    {
      v20 = (unint64_t)v489;
      if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)v535 = v467;
        _os_log_debug_impl(&dword_1B9BE0000, v124, OS_LOG_TYPE_DEBUG, "Only transitioning task task container %llu when primary data is kperf", buf, 0xCu);
      }
    }
    goto LABEL_293;
  }
  context = 0;
  v128 = 1;
LABEL_247:
  LODWORD(v463) = v129;
  if ((int)v129 < -1 || v132 <= -2)
  {
    v145 = v130;
    v123 = *__error();
    _sa_logt();
    v124 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)v535 = v145;
      *(_WORD *)&v535[8] = 1024;
      *(_DWORD *)&v535[10] = (_DWORD)v463;
      *(_WORD *)&v535[14] = 2048;
      *(_QWORD *)&v535[16] = v132;
      _os_log_debug_impl(&dword_1B9BE0000, v124, OS_LOG_TYPE_DEBUG, "Ignoring task with negative pid %s [%d] unique pid %llu", buf, 0x1Cu);
    }
    goto LABEL_292;
  }
  __s1 = v130;
  v450 = v131;
  if (v21 && v132 == -1)
  {
    v459 = v23;
    if ((_DWORD)v129 == -1)
    {
      v132 = --_parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo__next_fake_unique_pid;
      v146 = *__error();
      _sa_logt();
      v147 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v535 = __s1;
        *(_WORD *)&v535[8] = 2048;
        *(_QWORD *)&v535[10] = v132;
        _os_log_impl(&dword_1B9BE0000, v147, OS_LOG_TYPE_DEFAULT, "WARNING: transitioning task %s with no uniquepid and no pid, faking uniquepid:%llu", buf, 0x16u);
      }

      *__error() = v146;
      v129 = v463;
    }
    else
    {
      __srca = v21;
      v458 = v30;
      objc_msgSend(a1, "tasksByPid", v31, v32, v33, v34, v35);
      v135 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v129);
      v136 = v129;
      v137 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v135, "objectForKeyedSubscript:", v137);
      v138 = (void *)objc_claimAutoreleasedReturnValue();

      v448 = v138;
      objc_msgSend(v138, "lastObject");
      v139 = (void *)objc_claimAutoreleasedReturnValue();
      v140 = v139;
      if (v139)
      {
        v132 = objc_msgSend(v139, "uniquePid");
        v141 = *__error();
        _sa_logt();
        v142 = objc_claimAutoreleasedReturnValue();
        v143 = v140;
        if (os_log_type_enabled(v142, OS_LOG_TYPE_INFO))
        {
          objc_msgSend(v140, "debugDescription");
          v144 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)v535 = __s1;
          *(_WORD *)&v535[8] = 2112;
          *(_QWORD *)&v535[10] = v144;
          *(_WORD *)&v535[18] = 2048;
          *(_QWORD *)&v535[20] = v132;
          _os_log_impl(&dword_1B9BE0000, v142, OS_LOG_TYPE_INFO, "transitioning task %s with no uniquepid, assuming it's the predecessor with matching pid %@: using uniquepid %llu", buf, 0x20u);

        }
        v129 = v463;
      }
      else
      {
        v143 = 0;
        v132 = v136 + 10000000000;
        v444 = *__error();
        _sa_logt();
        v142 = objc_claimAutoreleasedReturnValue();
        v129 = v136;
        if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)v535 = __s1;
          *(_WORD *)&v535[8] = 2048;
          *(_QWORD *)&v535[10] = v136 + 10000000000;
          _os_log_impl(&dword_1B9BE0000, v142, OS_LOG_TYPE_DEFAULT, "WARNING: transitioning task %s with no uniquepid and no predecessor task, faking uniquepid %llu", buf, 0x16u);
        }
        v141 = v444;
      }

      *__error() = v141;
      v21 = __srca;
      v30 = v458;
    }
    v23 = v459;
    if (__dst != v21)
      memmove(__dst, v21, 0x3CuLL);
    *(_QWORD *)&__dst[0] = v132;
    v21 = __dst;
  }
  if ((a7 & 1) != 0 || v132 != -1)
  {
    __src = (uint64_t)v21;
    v455 = v30;
    if ((_DWORD)a7)
    {
      v21 = v23;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v129, v32, v33, v34, v35);
      v152 = (void *)objc_claimAutoreleasedReturnValue();
      v153 = objc_msgSend(v487, "containsObject:", v152);

      if ((v153 & 1) == 0)
      {
        if ((_DWORD)v463)
          v154 = v132 == 0;
        else
          v154 = 1;
        v155 = v154;
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:");
        v156 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v487, "addObject:", v156);

        if (v128)
        {
          v321 = *__error();
          _sa_logt();
          v322 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v322, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1B9BE0000, v322, OS_LOG_TYPE_ERROR, "no task_struct when backfilling kperf", buf, 2u);
          }

          *__error() = v321;
          _SASetCrashLogMessage(4330, "no task_struct when backfilling kperf", v323, v324, v325, v326, v327, v328, v439);
          _os_crash();
          __break(1u);
        }
        else
        {
          if (v540 != context)
            memmove(v540, context, 0x78uLL);
          LODWORD(v443) = v155;
          v19 = *(_QWORD *)&v540[8] & 0x1FFCFF0C40;
          *(_QWORD *)v540 = -1;
          *(_QWORD *)&v540[8] &= 0x1FFCFF0C40uLL;
          HIDWORD(v543) = 0;
          DWORD1(v544) = 0;
          if (!v474)
          {
            v157 = v477;
            v23 = v468;
            if (!v485)
            {
              objc_msgSend((id)v481, "osProductName");
              v158 = (void *)objc_claimAutoreleasedReturnValue();
              v159 = objc_msgSend(v158, "isEqualToString:", CFSTR("Mac OS X"));

              if (v159)
              {
                objc_msgSend((id)v481, "osBuildVersion");
                v160 = (void *)objc_claimAutoreleasedReturnValue();
                v161 = v160;
                v162 = CFSTR("18A230");
              }
              else
              {
                objc_msgSend((id)v481, "osProductName");
                v169 = (void *)objc_claimAutoreleasedReturnValue();
                v170 = objc_msgSend(v169, "isEqualToString:", CFSTR("iPhone OS"));

                if (v170)
                {
                  objc_msgSend((id)v481, "osBuildVersion");
                  v160 = (void *)objc_claimAutoreleasedReturnValue();
                  v161 = v160;
                  v162 = CFSTR("16A230");
                }
                else
                {
                  objc_msgSend((id)v481, "osProductName");
                  v171 = (void *)objc_claimAutoreleasedReturnValue();
                  v172 = objc_msgSend(v171, "isEqualToString:", CFSTR("Watch OS"));

                  if (v172)
                  {
                    objc_msgSend((id)v481, "osBuildVersion");
                    v160 = (void *)objc_claimAutoreleasedReturnValue();
                    v161 = v160;
                    v162 = CFSTR("16R230");
                  }
                  else
                  {
                    objc_msgSend((id)v481, "osProductName");
                    v173 = (void *)objc_claimAutoreleasedReturnValue();
                    v174 = objc_msgSend(v173, "isEqualToString:", CFSTR("Apple TVOS"));

                    if (!v174)
                    {
LABEL_316:
                      v165 = (uint64_t)v540;
                      goto LABEL_317;
                    }
                    objc_msgSend((id)v481, "osBuildVersion");
                    v160 = (void *)objc_claimAutoreleasedReturnValue();
                    v161 = v160;
                    v162 = CFSTR("16J230");
                  }
                }
              }
              v175 = objc_msgSend(v160, "compare:options:", v162, 65);

              if (v175 == -1)
              {
                *((_QWORD *)&v542 + 1) = 0;
                *(_QWORD *)&v543 = 0;
              }
              goto LABEL_316;
            }
LABEL_619:
            v337 = *__error();
            _sa_logt();
            v338 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v338, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_1B9BE0000, v338, OS_LOG_TYPE_ERROR, "importanceDonations non-NULL when primary data is kperf", buf, 2u);
            }

            *__error() = v337;
            _SASetCrashLogMessage(4346, "importanceDonations non-NULL when primary data is kperf", v339, v340, v341, v342, v343, v344, v439);
            _os_crash();
            __break(1u);
            goto LABEL_622;
          }
        }
        v329 = *__error();
        _sa_logt();
        v330 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1B9BE0000, v330, OS_LOG_TYPE_ERROR, "taskTerminatedThreadsInstructionCycles non-NULL when primary data is kperf", buf, 2u);
        }

        *__error() = v329;
        _SASetCrashLogMessage(4345, "taskTerminatedThreadsInstructionCycles non-NULL when primary data is kperf", v331, v332, v333, v334, v335, v336, v439);
        _os_crash();
        __break(1u);
        goto LABEL_619;
      }
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v132, v32, v33, v34, v35);
      v163 = (void *)objc_claimAutoreleasedReturnValue();
      v21 = v23;
      v164 = -[NSObject containsObject:](v23, "containsObject:", v163);

      v165 = (uint64_t)context;
      if (!v164)
      {
        if ((_DWORD)v463)
          v166 = v132 == 0;
        else
          v166 = 1;
        v167 = v166;
        LODWORD(v443) = v167;
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v132);
        v168 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v21, "addObject:", v168);

        v19 = v450;
        v157 = v477;
        v23 = v468;
LABEL_317:
        v477 = v157;
        if (__s1)
        {
          if (!strcmp(__s1, "unknown"))
          {
            if (!v165)
            {
              if (!__src)
                goto LABEL_640;
              v176 = v21;
              v177 = v443;
              if (__dst != (_OWORD *)__src)
                memmove(__dst, (const void *)__src, 0x3CuLL);
              v165 = 0;
              __s1 = 0;
              memset((char *)&__dst[1] + 12, 0, 32);
              __src = (uint64_t)__dst;
LABEL_326:
              v528[0] = MEMORY[0x1E0C809B0];
              v15 = 3221225472;
              v528[1] = 3221225472;
              v528[2] = __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke;
              v528[3] = &__block_descriptor_33_e38_B24__0__dyld_uuid_info_64_Q_16C__8_I16l;
              v529 = v177;
              v178 = MEMORY[0x1BCCCC450](v528);
              LOBYTE(v443) = (*(uint64_t (**)(uint64_t, NSObject *, char *))(v178 + 16))(v178, v491, (char *)&v530 + 4);
              v442 = (void *)v178;
              LOBYTE(v21) = (*(uint64_t (**)(uint64_t, NSObject *, uint64_t *))(v178 + 16))(v178, v490, &v530);
              if ((_DWORD)v23)
              {
                if (!v22)
                  goto LABEL_595;
                mergesort_b(v22, v23, 0x38uLL, &__block_literal_global_267);
              }
              context = (uint8_t *)v19;
              if (*(_QWORD *)(v481 + 192))
              {
                v459 = v176;
                if (!(_DWORD)self)
                  goto LABEL_600;
                v19 = v177;
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:");
                v179 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v484, "objectForKeyedSubscript:", v179);
                v180 = objc_claimAutoreleasedReturnValue();

                v449 = (id)v180;
                if (v180)
                {
                  v181 = 0;
                  v182 = v471;
                  v177 = v19;
                  goto LABEL_333;
                }
LABEL_598:
                v66 = *__error();
                _sa_logt();
                v23 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
                  goto LABEL_658;
                goto LABEL_599;
              }
              v304 = *__error();
              _sa_logt();
              v305 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v305, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl(&dword_1B9BE0000, v305, OS_LOG_TYPE_ERROR, "Unknown system architecture when parsing task", buf, 2u);
              }

              *__error() = v304;
              _SASetCrashLogMessage(4466, "Unknown system architecture when parsing task", v306, v307, v308, v309, v310, v311, v439);
              _os_crash();
              __break(1u);
LABEL_595:
              v312 = *__error();
              _sa_logt();
              v165 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled((os_log_t)v165, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)v535 = (_DWORD)v468;
                _os_log_error_impl(&dword_1B9BE0000, (os_log_t)v165, OS_LOG_TYPE_ERROR, "%d aot infos, but NULL array", buf, 8u);
              }

              *__error() = v312;
              _SASetCrashLogMessage(4450, "%d aot infos, but NULL array", v313, v314, v315, v316, v317, v318, (char)v468);
              _os_crash();
              __break(1u);
              goto LABEL_598;
            }
            if (v540 != (uint8_t *)v165)
              memmove(v540, (const void *)v165, 0x78uLL);
            v176 = v21;
            __s1 = 0;
            memset(&v545[8], 0, 32);
            v165 = (uint64_t)v540;
          }
          else
          {
            v176 = v21;
          }
        }
        else
        {
          v176 = v21;
          __s1 = 0;
        }
        v177 = v443;
        goto LABEL_326;
      }
    }
    v123 = *__error();
    _sa_logt();
    v124 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v535 = __s1;
      *(_WORD *)&v535[8] = 2048;
      *(_QWORD *)&v535[10] = v132;
      _os_log_error_impl(&dword_1B9BE0000, v124, OS_LOG_TYPE_ERROR, "Already saw task %s unique pid %llu in this stackshot, ignoring second container", buf, 0x16u);
    }
    v20 = (unint64_t)v489;
    v23 = v21;
LABEL_293:
    v38 = v490;
    v39 = v491;
    goto LABEL_294;
  }
  v123 = *__error();
  _sa_logt();
  v124 = objc_claimAutoreleasedReturnValue();
  v148 = os_log_type_enabled(v124, OS_LOG_TYPE_ERROR);
  if ((v128 & 1) == 0)
  {
    if (v148)
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)v535 = __s1;
      *(_WORD *)&v535[8] = 1024;
      *(_DWORD *)&v535[10] = (_DWORD)v463;
      *(_WORD *)&v535[14] = 2048;
      *(_QWORD *)&v535[16] = v467;
      v125 = "No uniquepid for task %s [%d] in task container %llu";
      v126 = v124;
      v127 = 28;
LABEL_402:
      _os_log_error_impl(&dword_1B9BE0000, v126, OS_LOG_TYPE_ERROR, v125, buf, v127);
    }
LABEL_292:
    v20 = (unint64_t)v489;
    goto LABEL_293;
  }
  if ((v20 & 1) != 0)
  {
    v38 = v490;
    v39 = v491;
    if (v148)
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)v535 = __s1;
      *(_WORD *)&v535[8] = 1024;
      *(_DWORD *)&v535[10] = (_DWORD)v463;
      *(_WORD *)&v535[14] = 2048;
      *(_QWORD *)&v535[16] = v467;
      v149 = "No uniquepid for transitioning task %s [%d] in task container %llu";
      v150 = v124;
      v151 = 28;
      goto LABEL_585;
    }
  }
  else
  {
    v38 = v490;
    v39 = v491;
    if (v148)
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v535 = v467;
      v149 = "No uniquepid for delta task in task container %llu";
      v150 = v124;
      v151 = 12;
LABEL_585:
      _os_log_error_impl(&dword_1B9BE0000, v150, OS_LOG_TYPE_ERROR, v149, buf, v151);
    }
  }
  v20 = (unint64_t)v489;
LABEL_294:

  *__error() = v123;
LABEL_10:
  if (v492)
    free(v492);
  if (v495)
    free(v495);
  if (v39)
    free(v39);
  if (v38)
    free(v38);
  if (v22)
    free(v22);
  objc_msgSend((id)v20, "clearTaskData");
  v40 = SkipToContainerEnd((int **)a2, 1);
  v22 = newValue;
LABEL_21:

  return v40;
}

- (uint64_t)_parseKCDataSharedCacheContainer:(void *)a3 sharedCaches:
{
  unsigned int *v3;
  int v4;
  NSObject *v7;
  unsigned int *v8;
  uint64_t v9;
  NSObject *v10;
  unsigned int *v11;
  uint64_t v12;
  char *v13;
  _DWORD *v14;
  char *v15;
  void *v16;
  unsigned int *v17;
  unsigned int v18;
  int v19;
  unint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  char *v26;
  void *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  int v34;
  NSObject *v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  void *v47;
  uint8_t buf[4];
  _BYTE v49[10];
  _BYTE v50[10];
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  unsigned int v56;
  __int16 v57;
  void *v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  v8 = *a2;
  v9 = (*a2)[4];
  if ((_DWORD)v9 == 2370)
  {
    v10 = v7;
    v11 = a2[1];
    v12 = *((_QWORD *)v8 + 1);
    v13 = (char *)v8 + v8[1];
    v14 = v13 + 16;
    *a2 = (unsigned int *)(v13 + 16);
    v15 = v13 + 32;
    if (v15 > (char *)v11)
      goto LABEL_45;
    v3 = 0;
    while (1)
    {
      if (&v15[v14[1]] > (char *)v11 || *v14 == -242132755)
      {
LABEL_28:
        if (!v3)
          goto LABEL_45;
        goto LABEL_29;
      }
      v16 = (void *)MEMORY[0x1BCCCC288]();
      KCLogIter(*a2, (unint64_t)a2[1], 0);
      v17 = *a2;
      v18 = **a2;
      if ((v18 & 0xFFFFFFF0) == 0x20)
        v19 = 17;
      else
        v19 = **a2;
      switch(v19)
      {
        case 19:
          v20 = (unint64_t)a2[1];
          v21 = v17 + 4;
          if ((unint64_t)(v17 + 4) > v20
            || (v22 = v17[1], (unint64_t)v21 + v22 > v20)
            || ((v18 & 0xFFFFFFF0) != 0x20 ? (v23 = v18 == 19) : (v23 = 0),
                v23 ? (v24 = v22 > 3) : (v24 = 0),
                !v24))
          {
            v29 = *__error();
            _sa_logt();
            v30 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v49 = 2370;
              _os_log_error_impl(&dword_1B9BE0000, v30, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
            }
            v25 = 1;
            goto LABEL_36;
          }
          v25 = SkipToContainerEnd((int **)a2, 1);
          objc_autoreleasePoolPop(v16);
          if ((_DWORD)v25)
            goto LABEL_48;
          break;
        case 2371:
          v3 = v17 + 4;
          break;
        case 20:
          v33 = *((_QWORD *)v17 + 1);
          if (v12 != v33)
          {
            v29 = *__error();
            _sa_logt();
            v30 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)v49 = v12;
              *(_WORD *)&v49[8] = 2048;
              *(_QWORD *)v50 = v33;
              _os_log_error_impl(&dword_1B9BE0000, v30, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
            }
            v25 = 7;
LABEL_36:

            *__error() = v29;
            objc_autoreleasePoolPop(v16);
            goto LABEL_48;
          }
          objc_autoreleasePoolPop(v16);
          if (!v3)
          {
LABEL_45:
            v34 = *__error();
            _sa_logt();
            v35 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_1B9BE0000, v35, OS_LOG_TYPE_ERROR, "no shared cache info at shared cache container end", buf, 2u);
            }

            v25 = 0;
            *__error() = v34;
            goto LABEL_48;
          }
LABEL_29:
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v3[10]);
          v27 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject objectForKeyedSubscript:](v10, "objectForKeyedSubscript:", v27);
          v9 = objc_claimAutoreleasedReturnValue();

          a2 = (unsigned int **)(v3 + 2);
          if (v9)
          {
            if ((objc_msgSend((id)v9, "matchesUUID:slide:slidBaseAddress:", v3 + 2, *(_QWORD *)v3, *((_QWORD *)v3 + 4)) & 1) == 0)
            {
              v4 = *__error();
              _sa_logt();
              v28 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled((os_log_t)v28, OS_LOG_TYPE_FAULT))
                goto LABEL_55;
              goto LABEL_32;
            }
          }
          else
          {
            -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)(v3 + 2), *(_QWORD *)v3, *((_QWORD *)v3 + 4));
            v31 = objc_claimAutoreleasedReturnValue();
            v9 = v31;
            if (v31)
            {
              *(_DWORD *)(v31 + 28) = v3[11];
              *(_DWORD *)(v31 + 32) = v3[10];
            }
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v3[10]);
            v32 = (void *)objc_claimAutoreleasedReturnValue();
            -[NSObject setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v9, v32);

          }
          if ((v3[11] & 1) != 0)
            objc_storeStrong((id *)(a1 + 1024), (id)v9);
          goto LABEL_42;
        default:
          objc_autoreleasePoolPop(v16);
          break;
      }
      v11 = a2[1];
      v26 = (char *)*a2 + (*a2)[1];
      v14 = v26 + 16;
      *a2 = (unsigned int *)(v26 + 16);
      v15 = v26 + 32;
      if (v15 > (char *)v11)
        goto LABEL_28;
    }
  }
  v28 = *__error();
  _sa_logt();
  v10 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)v49 = v9;
    _os_log_error_impl(&dword_1B9BE0000, v10, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
  }

  *__error() = v28;
  _SASetCrashLogMessage(5638, "bad container type %u", v37, v38, v39, v40, v41, v42, v9);
  _os_crash();
  __break(1u);
LABEL_55:
  v43 = *((_QWORD *)v3 + 4);
  v44 = *(_QWORD *)v3;
  v46 = v3[10];
  v45 = v3[11];
  objc_msgSend((id)v9, "debugDescription");
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 67110658;
  *(_DWORD *)v49 = v46;
  *(_WORD *)&v49[4] = 1040;
  *(_DWORD *)&v49[6] = 16;
  *(_WORD *)v50 = 2096;
  *(_QWORD *)&v50[2] = a2;
  v51 = 2048;
  v52 = v43;
  v53 = 2048;
  v54 = v44;
  v55 = 1024;
  v56 = v45;
  v57 = 2114;
  v58 = v47;
  _os_log_fault_impl(&dword_1B9BE0000, (os_log_t)v28, OS_LOG_TYPE_FAULT, "Shared cache info id %d: %{uuid_t}.16P slid base address 0x%llx, slide 0x%llx, flags 0x%x doesn't match existing %{public}@", buf, 0x3Cu);

LABEL_32:
  *__error() = v4;
LABEL_42:

  v25 = 0;
LABEL_48:

  return v25;
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  void *v5;
  void *v6;
  void *v7;
  _QWORD *v8;
  const char *v9;
  void *v10;
  id v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t, void *);
  void *v21;
  id v22;
  uint64_t v23;
  uint8_t buf[4];
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  -[SASampleStore lastTaskWithUniquePid:](*(_QWORD **)(a1 + 32), *a3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if (v5)
  {
    objc_msgSend(v5, "taskStates");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "lastObject");
    v8 = (_QWORD *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      objc_setProperty_atomic(v8, v9, *(id *)(a1 + 40), 40);
      v8[7] = *(_QWORD *)(a1 + 56);
    }
    objc_msgSend(v6, "threads");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v18 = MEMORY[0x1E0C809B0];
    v19 = 3221225472;
    v20 = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2;
    v21 = &unk_1E7146F40;
    v11 = *(id *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 56);
    v22 = v11;
    v23 = v12;
    objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", &v18);

  }
  else
  {
    v13 = *__error();
    _sa_logt();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v17 = *a3;
      *(_DWORD *)buf = 134217984;
      v25 = v17;
      _os_log_error_impl(&dword_1B9BE0000, v14, OS_LOG_TYPE_ERROR, "Non-runnable task %llu from stackshot before any regular task struct", buf, 0xCu);
    }

    *__error() = v13;
  }
  v15 = *(void **)(a1 + 48);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *a3, v18, v19, v20, v21);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "addObject:", v16);

}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  const char *v8;
  id v9;

  v9 = a3;
  objc_msgSend(v9, "exitTimestamp");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v5 = v9;
  if (!v4)
  {
    objc_msgSend(v9, "threadStates");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "lastObject");
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    if (v7)
    {
      objc_setProperty_atomic(v7, v8, *(id *)(a1 + 32), 56);
      -[SAThreadState setEndSampleIndex:]((uint64_t)v7, *(_QWORD *)(a1 + 40));
    }

    v5 = v9;
  }

}

uint64_t __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_226(uint64_t a1)
{
  return fprintf((FILE *)*MEMORY[0x1E0C80C10], "Warning: Unable to infer machine architecture from kernel version %s\n", (const char *)objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 448), "UTF8String"));
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_228(uint64_t a1, void *a2)
{
  id v3;
  _QWORD v4[5];

  objc_msgSend(a2, "threads");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2_229;
  v4[3] = &__block_descriptor_40_e35_v32__0__NSNumber_8__SAThread_16_B24l;
  v4[4] = *(_QWORD *)(a1 + 32);
  objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);

}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2_229(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  const char *v8;
  void *v9;
  id self;

  self = a3;
  objc_msgSend(self, "exitTimestamp");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v5 = self;
  if (!v4)
  {
    objc_msgSend(self, "threadStates");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "lastObject");
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    if (v7 && (unint64_t)objc_msgSend(v7, "endSampleIndex") < *(_QWORD *)(a1 + 32))
    {
      objc_msgSend(v7, "endTimestamp");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      if (self)
        objc_setProperty_atomic(self, v8, v9, 40);

    }
    v5 = self;
  }

}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  id v9;

  v9 = a3;
  objc_msgSend(v9, "exitTimestamp");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
    goto LABEL_3;
  objc_msgSend(v9, "threadStates");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "lastObject");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "endTimestamp");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
LABEL_3:
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v8 = *(void **)(v7 + 40);
    if (!v8)
    {
LABEL_6:
      objc_storeStrong((id *)(v7 + 40), v4);
      goto LABEL_7;
    }
    if (objc_msgSend(v8, "lt:", v4))
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      goto LABEL_6;
    }
  }
LABEL_7:

}

BOOL __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke(uint64_t a1, unsigned __int8 *__base, unsigned int *a3)
{
  unsigned int v3;
  unint64_t v7;
  unsigned int v8;
  const unsigned __int8 *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  _BOOL8 v12;

  v3 = *a3;
  if (!*a3)
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = __base + 8;
  do
  {
    v10 = *((_QWORD *)v9 - 1);
    if (v10)
    {
      if (v7 != v8)
      {
        v11 = &__base[24 * v8];
        *(_QWORD *)v11 = v10;
        uuid_copy(v11 + 8, v9);
        v3 = *a3;
      }
      ++v8;
    }
    ++v7;
    v9 += 24;
  }
  while (v7 < v3);
  if (v3 == v8)
  {
    v12 = 0;
    if (!v8)
      return v12;
  }
  else
  {
    v12 = v8 != 0;
    *a3 = v8;
    if (!v8)
      return v12;
  }
  if (!*(_BYTE *)(a1 + 32))
    mergesort_b(__base, v8, 0x18uLL, &__block_literal_global_261);
  return v12;
}

uint64_t __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_2(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int v3;

  if (*a3 <= *a2)
    v3 = 0;
  else
    v3 = -1;
  if (*a3 < *a2)
    return 1;
  else
    return v3;
}

uint64_t __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_266(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unsigned int v6;

  v3 = *(_QWORD *)(a3 + 8);
  v4 = *(_QWORD *)(a2 + 8);
  v5 = v3 >= v4;
  if (v3 <= v4)
    v6 = 0;
  else
    v6 = -1;
  if (v5)
    return v6;
  else
    return 1;
}

- (id)addressTranslationsForPid:(uint64_t)a1
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;

  if (a1)
  {
    v4 = *(void **)(a1 + 304);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "objectForKeyedSubscript:", v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v6)
    {
      if (!*(_QWORD *)(a1 + 304))
      {
        v7 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 1);
        v8 = *(void **)(a1 + 304);
        *(_QWORD *)(a1 + 304) = v7;

      }
      v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 8);
      v9 = *(void **)(a1 + 304);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "setObject:forKeyedSubscript:", v6, v10);

    }
  }
  else
  {
    v6 = 0;
  }
  return v6;
}

void __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_275(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  id v19;

  if (*(_DWORD *)(a1 + 128) <= 0x3Fu)
    v5 = 0;
  else
    v5 = (uint64_t)a3;
  v6 = *a3;
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 220) || v6 == *(_QWORD *)(a1 + 80))
  {
    v7 = *(unsigned int *)(a1 + 132);
    if ((_DWORD)v7)
    {
      v8 = *(_QWORD *)(a1 + 88);
      while (*(_QWORD *)(v8 + 8) != v6)
      {
        v8 += 31;
        if (!--v7)
          goto LABEL_10;
      }
      if (*(_WORD *)(v8 + 25))
      {
        v17 = *(unsigned int *)(a1 + 96);
        if ((_DWORD)v17)
        {
          v9 = *(_QWORD **)(a1 + 104);
          while (*(unsigned __int16 *)*v9 != *(unsigned __int16 *)(v8 + 25))
          {
            v9 += 2;
            if (!--v17)
              goto LABEL_11;
          }
LABEL_12:
          v10 = *(unsigned int *)(a1 + 136);
          if ((_DWORD)v10)
          {
            v11 = *(_QWORD *)(a1 + 112);
            while (*(_QWORD *)v11 != v6)
            {
              v11 += 28;
              if (!--v10)
                goto LABEL_16;
            }
            if (*(_WORD *)(v11 + 26))
            {
              v18 = *(unsigned int *)(a1 + 96);
              if ((_DWORD)v18)
              {
                v12 = *(_QWORD **)(a1 + 104);
                while (*(unsigned __int16 *)*v12 != *(unsigned __int16 *)(v11 + 26))
                {
                  v12 += 2;
                  if (!--v18)
                    goto LABEL_17;
                }
                goto LABEL_18;
              }
            }
          }
          else
          {
LABEL_16:
            v11 = 0;
          }
LABEL_17:
          v12 = 0;
LABEL_18:
          v13 = *(void **)(a1 + 40);
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v6);
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v13, "addObject:", v14);

          v15 = -[SASampleStore addKCDataThreadV4:threadV2:deltaThreadV3:deltaThreadV2:timestamp:sampleIndex:stack:threadExclavesInfo:threadName:dispatchQueueLabel:waitInfo:waitInfoPortLabelInfo:turnstileInfo:turnstileInfoPortLabelInfo:instructionCycles:task:kernelTask:taskIsSuspended:](*(id **)(a1 + 32), 0, 0, v5, (uint64_t)a3, *(void **)(a1 + 48), *(_QWORD *)(a1 + 120), 0, 0, 0, 0, v8, v9, v11, v12, 0, *(void **)(a1 + 56), *(void **)(a1 + 64), *(_BYTE *)(a1 + 140));
          if (v15)
          {
            v16 = *(void **)(a1 + 72);
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v15);
            v19 = (id)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v16, "addObject:", v19);

          }
          return;
        }
      }
    }
    else
    {
LABEL_10:
      v8 = 0;
    }
LABEL_11:
    v9 = 0;
    goto LABEL_12;
  }
}

void __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_279(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  const char *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  id v18;

  v5 = *a3;
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 220) || v5 == *(_QWORD *)(a1 + 72))
  {
    v6 = *(void **)(a1 + 40);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v5);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "addObject:", v7);

    objc_msgSend(*(id *)(a1 + 48), "threads");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *a3);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "objectForKeyedSubscript:", v9);
    v18 = (id)objc_claimAutoreleasedReturnValue();

    v10 = v18;
    if (v18)
    {
      objc_msgSend(v18, "threadStates");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "lastObject");
      v12 = (void *)objc_claimAutoreleasedReturnValue();

      if (v12)
      {
        objc_setProperty_atomic(v12, v13, *(id *)(a1 + 56), 56);
        -[SAThreadState setEndSampleIndex:]((uint64_t)v12, *(_QWORD *)(a1 + 80));
        objc_msgSend(v12, "dispatchQueue");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = objc_msgSend(v14, "identifier");

        if (v15)
        {
          v16 = *(void **)(a1 + 64);
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v15);
          v17 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v16, "addObject:", v17);

        }
      }

      v10 = v18;
    }

  }
}

- (uint64_t)_parseKCDataThreadContainer:(void *)a3 timestampOfSample:(unint64_t)a4 sampleIndex:(void *)a5 task:(void *)a6 kernelTask:(void *)a7 frameIterator:(NSObject *)a8 mainThreadID:(char)a9 primaryDataIsKPerf:(char)a10 addStaticInfoOnly:(NSObject *)a11 threadIDsInThisTaskThisSample:(void *)a12 dispatchQueueIDsInThisTaskThisSample:(char)a13 taskIsSuspended:(uint64_t)a14 waitInfos:(unsigned int)a15 numWaitInfos:(uint64_t)a16 turnstileInfos:(unsigned int)a17 numTurnstileInfos:(int)a18 port_label_info_array:(unsigned int)a19 exclaveInfo:(_QWORD *)a20
{
  NSObject *v27;
  id v28;
  id v29;
  id v30;
  NSObject *v31;
  NSObject *v32;
  int *v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  char *v37;
  _DWORD *v38;
  char *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t p_dst;
  int v43;
  NSObject *v44;
  int **v45;
  int *v46;
  int v47;
  unsigned int v48;
  int v49;
  unsigned int *v50;
  unsigned int v51;
  unsigned int v52;
  BOOL v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v57;
  int v58;
  NSObject *v59;
  int v60;
  NSObject *v61;
  NSObject *v62;
  const char *v63;
  uint32_t v64;
  unint64_t v65;
  int *v66;
  uint64_t v67;
  unsigned int *v68;
  unint64_t v69;
  unint64_t v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  uint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  unsigned int v78;
  _QWORD *v79;
  uint64_t v80;
  _QWORD *v81;
  unsigned int v82;
  _QWORD *v83;
  uint64_t v84;
  _QWORD *v85;
  unsigned int v86;
  _QWORD *v87;
  uint64_t v88;
  _QWORD *v89;
  _QWORD *v90;
  unsigned int v91;
  _QWORD *v92;
  uint64_t v93;
  _QWORD *v94;
  unsigned int v95;
  _QWORD *v96;
  uint64_t v97;
  _QWORD *v98;
  unsigned int v99;
  _QWORD *v100;
  uint64_t v101;
  _QWORD *v102;
  unsigned int v103;
  _QWORD *v104;
  uint64_t v105;
  _QWORD *v106;
  unsigned int v107;
  _QWORD *v108;
  uint64_t v109;
  _QWORD *v110;
  unsigned int v111;
  _QWORD *v112;
  char *v113;
  uint64_t *v114;
  uint64_t v115;
  void *v116;
  void *v117;
  SAThreadExclavesInfo *v118;
  _QWORD *v119;
  _QWORD *v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  void *v124;
  void *v125;
  void *v126;
  void *v127;
  const char *v128;
  void *v129;
  void *v130;
  void *v131;
  _BYTE *v132;
  uint64_t v133;
  void *v134;
  const char *v135;
  void *v136;
  uint64_t v137;
  unint64_t v138;
  void *v139;
  const char *v140;
  void *v141;
  uint64_t v142;
  _BOOL8 v143;
  uint64_t v144;
  void *v145;
  id v146;
  void *v147;
  int v148;
  int v149;
  NSObject *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  int v159;
  int v160;
  int v161;
  char v162;
  char v163;
  char v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  _QWORD *v169;
  unsigned int v170;
  uint64_t v171;
  _QWORD *v172;
  int v173;
  uint64_t v174;
  int v175;
  NSObject *v176;
  uint64_t v177;
  void *v178;
  uint64_t v179;
  _QWORD *v180;
  int v181;
  uint64_t v182;
  int v183;
  NSObject *v184;
  void *v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  int v196;
  NSObject *v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int v204;
  NSObject *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  char v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  unint64_t v216;
  void *v217;
  uint64_t v218;
  char v219;
  _BYTE *v220;
  unsigned int *v221;
  unsigned int *v222;
  NSObject *v223;
  NSObject *v224;
  uint64_t *v225;
  unsigned int *v226;
  void *v227;
  NSObject *v228;
  void *v229;
  unint64_t v231;
  uint64_t v232;
  id self;
  uint64_t v234;
  _BYTE *v235;
  id v236;
  id v237;
  uint8_t buf[4];
  NSObject *v239;
  __int16 v240;
  NSObject *v241;
  __int128 __dst;
  __int128 v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  uint64_t v250;

  v27 = a11;
  v250 = *MEMORY[0x1E0C80C00];
  v28 = a3;
  v29 = a5;
  v235 = a6;
  v30 = a7;
  v31 = a11;
  v32 = a12;
  v236 = a21;
  v33 = *a2;
  v34 = (*a2)[4];
  if ((_DWORD)v34 != 2308)
  {
    v144 = *__error();
    _sa_logt();
    v150 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__dst) = 67109120;
      DWORD1(__dst) = v34;
      _os_log_error_impl(&dword_1B9BE0000, v150, OS_LOG_TYPE_ERROR, "bad container type %u", (uint8_t *)&__dst, 8u);
    }

    *__error() = v144;
    _SASetCrashLogMessage(5049, "bad container type %u", v190, v191, v192, v193, v194, v195, v34);
    _os_crash();
    __break(1u);
    goto LABEL_320;
  }
  v35 = a2[1];
  v27 = *((_QWORD *)v33 + 1);
  if (a1[220] && v27 != a8)
  {
    v36 = SkipToContainerEnd(a2, 1);
    a1 = v235;
    goto LABEL_313;
  }
  v228 = v32;
  v229 = v28;
  self = v29;
  v248 = 0u;
  v249 = 0u;
  v246 = 0u;
  v247 = 0u;
  v244 = 0u;
  v245 = 0u;
  __dst = 0u;
  v243 = 0u;
  v37 = (char *)v33 + v33[1];
  v38 = v37 + 16;
  *a2 = (int *)(v37 + 16);
  v39 = v37 + 32;
  v220 = a1;
  if (v39 > (char *)v35)
  {
    v231 = 0;
    v40 = 0;
    v41 = 0;
    v234 = 0;
    v219 = 0;
    v221 = 0;
    v222 = 0;
    v225 = 0;
    v226 = 0;
LABEL_7:
    p_dst = v231;
    if (!(v40 | v231) && !v234 && !v41)
    {
      v43 = *__error();
      _sa_logt();
      v44 = objc_claimAutoreleasedReturnValue();
      a1 = v235;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B9BE0000, v44, OS_LOG_TYPE_ERROR, "no thread_snap at thread container end", buf, 2u);
      }

      *__error() = v43;
      objc_msgSend(v30, "clearThreadData");
      v36 = 2;
      v32 = v228;
      v28 = v229;
      v29 = self;
      goto LABEL_313;
    }
    v224 = v31;
    v114 = (uint64_t *)v234;
    v218 = (uint64_t)v41;
    if (!v234)
      v114 = v41;
    if (v231)
      v114 = (uint64_t *)v231;
    if (v40)
      v114 = (uint64_t *)v40;
    v115 = *v114;
    if (v226)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)v226);
      v116 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v236, "objectForKeyedSubscript:", v116);
      v117 = (void *)objc_claimAutoreleasedReturnValue();

      v118 = [SAThreadExclavesInfo alloc];
      if (v118)
      {
        v119 = -[SAThreadExclavesInfo initWithCallstacks:](v118, v117);
        v120 = v119;
        if (v119)
          *((_DWORD *)v119 + 2) = v226[3];
      }
      else
      {
        v120 = 0;
      }

    }
    else
    {
      v120 = 0;
    }
    v121 = objc_msgSend(v30, "exclaveInsertionIndex");
    if (v121 == objc_msgSend(v30, "numKernelFrames"))
      objc_msgSend(v30, "setExclaveInsertionIndex:", 0);
    v227 = v120;
    if (!a9)
      goto LABEL_277;
    if (v40 | v231)
    {
      if (!v40 || &__dst == (__int128 *)v40)
      {
        if (v231 && &__dst != (__int128 *)v231)
        {
          v248 = 0u;
          v249 = 0u;
          v246 = 0u;
          v247 = 0u;
          v244 = 0u;
          v245 = 0u;
          __dst = 0u;
          v243 = 0u;
          memmove(&__dst, (const void *)v231, 0x68uLL);
          p_dst = (uint64_t)&__dst;
        }
      }
      else
      {
        memmove(&__dst, (const void *)v40, 0x80uLL);
        v40 = (uint64_t)&__dst;
      }
      v249 &= 0xE000000u;
      *(_QWORD *)&v244 = 0;
      *(_QWORD *)&v246 = v246 & 0x1EFFC;
      *((_QWORD *)&v247 + 1) = DWORD2(v247) & 0xFFFFFFFB;
      if (v40 | p_dst)
      {
        if (v40)
          v122 = v40;
        else
          v122 = p_dst;
        v123 = *(_QWORD *)(v122 + 40);
        if (v222)
        {
          objc_msgSend(self, "dispatchQueues");
          v124 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v123);
          v125 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v124, "objectForKeyedSubscript:", v125);
          v126 = (void *)objc_claimAutoreleasedReturnValue();

          if (v126)
          {
            objc_msgSend(v126, "dispatchQueueLabel");
            v127 = (void *)objc_claimAutoreleasedReturnValue();

            if (!v127)
            {
              SANSStringForCString(v222);
              v129 = (void *)objc_claimAutoreleasedReturnValue();
              if (v129)
                objc_setProperty_atomic_copy(v126, v128, v129, 32);

            }
          }

        }
        v232 = v123;
        objc_msgSend(self, "threads");
        v130 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v115);
        v131 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v130, "objectForKeyedSubscript:", v131);
        v132 = (_BYTE *)objc_claimAutoreleasedReturnValue();

        if (!v132 && (a10 & 1) == 0)
        {
          +[SAThread threadWithId:]((uint64_t)SAThread, v115);
          v132 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          v133 = (uint64_t)self;
          objc_msgSend(self, "execTimestamp");
          v134 = (void *)objc_claimAutoreleasedReturnValue();

          if (v134)
          {
            objc_msgSend(self, "execTimestamp");
            v136 = (void *)objc_claimAutoreleasedReturnValue();
            if (v132)
              objc_setProperty_atomic(v132, v135, v136, 32);

            v133 = (uint64_t)self;
          }
          -[SATask addThread:](v133, v132);
        }
        if (v40)
          v137 = v40;
        else
          v137 = p_dst;
        v138 = *(_QWORD *)(v137 + 64);
        if (v132)
        {
          if ((v138 & 0x2000) != 0)
          {
            objc_msgSend(self, "mainThread");
            v139 = (void *)objc_claimAutoreleasedReturnValue();

            if (!v139)
            {
              v132[17] = 1;
              if (self)
                objc_setProperty_atomic(self, v140, v132, 264);
            }
          }
        }
        if (a10)
        {
          objc_msgSend(v30, "clearThreadData");

          v32 = v228;
          v28 = v229;
          v29 = self;
          a1 = v235;
          v31 = v224;
          v141 = v227;
LABEL_312:

          v36 = 0;
          goto LABEL_313;
        }
        if (v40)
          v142 = v40;
        else
          v142 = p_dst;
        objc_msgSend(v30, "setContinuation:", *(_QWORD *)(v142 + 16));
        v143 = (v138 & 0x8080) != 0
            || objc_msgSend(self, "pid") && !objc_msgSend(v30, "hasUserStack");
        objc_msgSend(v30, "setIsUserStackTruncated:", v143);
        objc_msgSend(v30, "setIsSwiftAsyncStackTruncated:", (v138 >> 16) & 1);
        objc_msgSend(v30, "setIsKernelStackTruncated:", (v138 >> 14) & 1);
        if (objc_msgSend(self, "pid"))
        {
          v237 = 0;
          -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)self, v30, &v237);
          v145 = (void *)objc_claimAutoreleasedReturnValue();
          v146 = v237;
        }
        else
        {
          v145 = 0;
          v146 = 0;
        }
        -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v235, v30, 0);
        v147 = (void *)objc_claimAutoreleasedReturnValue();
        if (v40)
        {
          v148 = *((_DWORD *)v220 + 50);
          LOBYTE(v149) = 125;
          switch(v148)
          {
            case 0:
              break;
            case 4:
            case 5:
            case 6:
            case 7:
              v149 = (*(_DWORD *)(v40 + 112) >> 25) & 7;
              break;
            default:
              SAComplainAboutUnknownThreadPolicyVersion(v148);
              goto LABEL_247;
          }
        }
        else
        {
LABEL_247:
          LOBYTE(v149) = 125;
        }
        if (v146)
          v151 = -1;
        else
          v151 = 0;
        if (a4)
        {
          v215 = v151;
          v217 = v147;
          v152 = 0;
          v153 = a4 - 1;
          if (a4 == 0x7FFFFFFFFFFFFFFFLL)
            v153 = 0x7FFFFFFFFFFFFFFFLL;
          v216 = v153;
          if (v40)
            v154 = v40;
          else
            v154 = p_dst;
          v155 = *((_QWORD *)v220 + 23);
          if ((_DWORD)v155)
          {
            v156 = 0;
            if (HIDWORD(v155))
            {
              v152 = *(_QWORD *)(v154 + 56);
              if ((_DWORD)v155 == HIDWORD(v155))
              {
                if (v40)
                  v157 = v40;
                else
                  v157 = p_dst;
                v156 = *(_QWORD *)(v157 + 48);
              }
              else
              {
                v152 = __udivti3();
                v156 = __udivti3();
              }
            }
          }
          else
          {
            v156 = 0;
          }
          if (v40)
            v158 = v40;
          else
            v158 = p_dst;
          v159 = *(__int16 *)(v158 + 96);
          v160 = *(__int16 *)(v158 + 98);
          v161 = *(_DWORD *)(v158 + 88);
          v162 = *(_BYTE *)(v158 + 100);
          v163 = *(_BYTE *)(v158 + 101);
          v164 = *(_BYTE *)(v158 + 102);
          if (v225)
          {
            v165 = *v225;
            v166 = v225[1];
          }
          else
          {
            v165 = 0;
            v166 = 0;
          }
          if (v40)
            v167 = v40;
          else
            v167 = p_dst;
          v214 = v152;
          v147 = v217;
          -[SASampleStore backfillThread:inTask:lastSampleIndex:timestamp:haveName:name:haveDispatchQueueId:dispatchQueueId:dispatchQueueLabel:leafKernelFrame:hasExclaveInKernelStack:haveUserStack:leafUserFrame:swiftTaskId:leafOfCRootFramesReplacedBySwiftAsync:threadExclavesInfo:haveSched:systemCpuTimeNs:userCpuTimeNs:basePriority:scheduledPriority:state:threadQos:threadRequestedQos:threadRequestedQosOverride:threadQosPromote:haveCycIns:instructions:cycles:haveSnap:ioTier:isIOPassive:isDarwinBG:isSuspended:isGlobalForcedIdle:isIdleWorkQueue:lastMadeRunnableTime:isOnCore:isOnCoreForLastSampleIndex:cpuNum:](v220, v132, self, v216, v229, v219 & 1, v221, 1, v232, v222, v217, v227 != 0, 1, v145, v215, v146, v227, 1, v214,
            v156,
            v159,
            v160,
            v161,
            v162,
            v163,
            v164,
            v149,
            v225 != 0,
            v165,
            v166,
            1,
            *(_BYTE *)(v167 + 103),
            (*(_DWORD *)(v137 + 64) & 0x20) != 0,
            (*(_DWORD *)(v137 + 64) & 0x10) != 0,
            a13 | ((*(_DWORD *)(v137 + 64) & 0x40u) >> 6),
            BYTE1(*(_DWORD *)(v137 + 64)) & 1,
            0,
            0,
            0,
            0,
            0xFFFFFFFF);
        }

LABEL_277:
        v168 = 0;
        v170 = a19;
        v169 = a20;
        if (a14)
        {
          v171 = a15;
          v172 = 0;
          if (a15)
          {
            v168 = a14;
            while (*(_QWORD *)(v168 + 8) != v115)
            {
              v168 += 31;
              if (!--v171)
              {
                v168 = 0;
LABEL_291:
                v172 = 0;
                goto LABEL_293;
              }
            }
            v173 = *(__int16 *)(v168 + 25);
            if (!*(_WORD *)(v168 + 25))
              goto LABEL_291;
            if (a19)
            {
              v174 = a19;
              v172 = a20;
              while (*(unsigned __int16 *)*v172 != (unsigned __int16)v173)
              {
                v172 += 2;
                if (!--v174)
                  goto LABEL_288;
              }
            }
            else
            {
LABEL_288:
              v175 = *__error();
              _sa_logt();
              v176 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109120;
                LODWORD(v239) = v173;
                _os_log_error_impl(&dword_1B9BE0000, v176, OS_LOG_TYPE_ERROR, "No port label info for id %d", buf, 8u);
              }

              v172 = 0;
              *__error() = v175;
              v169 = a20;
              v170 = a19;
            }
          }
        }
        else
        {
          v172 = 0;
        }
LABEL_293:
        v177 = 0;
        v178 = v30;
        if (a16)
        {
          v179 = a17;
          v180 = 0;
          if (a17)
          {
            v177 = a16;
            while (*(_QWORD *)v177 != v115)
            {
              v177 += 28;
              if (!--v179)
              {
                v177 = 0;
LABEL_307:
                v180 = 0;
                goto LABEL_309;
              }
            }
            v181 = *(__int16 *)(v177 + 26);
            if (!*(_WORD *)(v177 + 26))
              goto LABEL_307;
            if (v170)
            {
              v182 = v170;
              v180 = v169;
              while (*(unsigned __int16 *)*v180 != (unsigned __int16)v181)
              {
                v180 += 2;
                if (!--v182)
                  goto LABEL_304;
              }
            }
            else
            {
LABEL_304:
              v183 = *__error();
              _sa_logt();
              v184 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109120;
                LODWORD(v239) = v181;
                _os_log_error_impl(&dword_1B9BE0000, v184, OS_LOG_TYPE_ERROR, "No port label info for id %d", buf, 8u);
              }

              v180 = 0;
              *__error() = v183;
            }
          }
        }
        else
        {
          v180 = 0;
        }
LABEL_309:
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v115);
        v185 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSObject addObject:](v224, "addObject:", v185);

        a1 = v235;
        v213 = v168;
        v141 = v227;
        v186 = p_dst;
        v28 = v229;
        v187 = -[SASampleStore addKCDataThreadV4:threadV2:deltaThreadV3:deltaThreadV2:timestamp:sampleIndex:stack:threadExclavesInfo:threadName:dispatchQueueLabel:waitInfo:waitInfoPortLabelInfo:turnstileInfo:turnstileInfoPortLabelInfo:instructionCycles:task:kernelTask:taskIsSuspended:]((id *)v220, v40, v186, v234, v218, v229, a4, v178, v227, (char *)v221, (id *)v222, v213, v172, v177, v180, v225, self, v235, a13);
        v32 = v228;
        if (v187)
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v187);
          v188 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject addObject:](v228, "addObject:", v188);

        }
        v30 = v178;
        objc_msgSend(v178, "clearThreadData");
        v29 = self;
        v31 = v224;
        goto LABEL_312;
      }
    }
    else
    {
      v196 = *__error();
      _sa_logt();
      v197 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B9BE0000, v197, OS_LOG_TYPE_ERROR, "no thread_snap when primary data is kperf", buf, 2u);
      }

      *__error() = v196;
      _SASetCrashLogMessage(5366, "no thread_snap when primary data is kperf", v198, v199, v200, v201, v202, v203, v212);
      _os_crash();
      __break(1u);
    }
    v204 = *__error();
    _sa_logt();
    v205 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v205, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v205, OS_LOG_TYPE_ERROR, "no thread_snap when backfilling kperf", buf, 2u);
    }

    *__error() = v204;
    _SASetCrashLogMessage(5385, "no thread_snap when backfilling kperf", v206, v207, v208, v209, v210, v211, v212);
    _os_crash();
    __break(1u);
  }
  v231 = 0;
  v40 = 0;
  v41 = 0;
  v234 = 0;
  v219 = 0;
  v221 = 0;
  v222 = 0;
  v225 = 0;
  v226 = 0;
  v45 = a2;
  while (1)
  {
    if (&v39[v38[1]] > (char *)v35 || *v38 == -242132755)
      goto LABEL_7;
    v34 = MEMORY[0x1BCCCC288]();
    KCLogIter((unsigned int *)*a2, (unint64_t)a2[1], 0);
    v46 = *a2;
    v47 = **a2;
    v48 = v47 & 0xFFFFFFF0;
    if ((v47 & 0xFFFFFFF0) == 0x20)
      v49 = 17;
    else
      v49 = **a2;
    if ((v49 - 1) > 5)
    {
      if (v49 <= 2309)
      {
        if (v49 != 17 && v49 != 19)
          goto LABEL_38;
        v51 = v46[1];
        v55 = v51;
LABEL_41:
        v50 = (unsigned int *)(v46 + 4);
        goto LABEL_42;
      }
      if (v49 == 2310)
      {
        v51 = v46[1];
        if (v51 == 112 && (v46[2] & 0x8F) == 0)
        {
          v55 = 104;
          goto LABEL_41;
        }
      }
      else
      {
        if (v49 != 2312)
        {
LABEL_38:
          v51 = v46[1];
          goto LABEL_39;
        }
        v51 = v46[1];
        if (v51 == 32 && (v46[2] & 0x8F) == 0)
        {
          v55 = 24;
          goto LABEL_41;
        }
      }
LABEL_39:
      v57 = v46[2] & 0xF;
      v53 = v51 >= v57;
      v55 = v51 - v57;
      if (!v53)
        v55 = 0;
      goto LABEL_41;
    }
    v50 = (unsigned int *)(v46 + 12);
    v51 = v46[1];
    v52 = v46[2] & 0xF;
    v53 = v51 >= v52;
    v54 = v51 - v52;
    if (!v53)
      v54 = 0;
    v55 = v54 - 32;
LABEL_42:
    if (v49 > 2338)
    {
      if (v49 > 2353)
      {
        switch(v49)
        {
          case 2354:
            objc_msgSend(v30, "setSwiftAsyncStitchIndex:", *v50);
            break;
          case 2369:
            v67 = v234;
            if (v55 > 0x3F)
              v67 = (uint64_t)v50;
            v234 = v67;
            if (v55 <= 0x3F)
              v41 = (uint64_t *)v50;
            break;
          case 2376:
            objc_msgSend(v30, "setExclaveInsertionIndex:", v50[2]);
            v226 = v50;
            break;
        }
        goto LABEL_167;
      }
      if (v49 == 2339)
      {
        v225 = (uint64_t *)v50;
      }
      else if (v49 == 2344)
      {
        if (v55)
        {
          if (!*((_BYTE *)v50 + v55 - 1))
          {
            if (*(_BYTE *)v50)
            {
              v222 = v50;
              goto LABEL_167;
            }
            v60 = *__error();
            _sa_logt();
            v61 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              goto LABEL_96;
            *(_WORD *)buf = 0;
            v62 = v61;
            v63 = "WARNING: Empty dispatch queue label";
            goto LABEL_61;
          }
          v60 = *__error();
          _sa_logt();
          v61 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            v62 = v61;
            v63 = "WARNING: dispatch queue label non NULL-terminated";
LABEL_61:
            v64 = 2;
LABEL_95:
            _os_log_impl(&dword_1B9BE0000, v62, OS_LOG_TYPE_DEFAULT, v63, buf, v64);
          }
        }
        else
        {
          v60 = *__error();
          _sa_logt();
          v61 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            LODWORD(v239) = 0;
            v62 = v61;
            v63 = "WARNING: invalid dispatch queue label (size %d)";
            v64 = 8;
            goto LABEL_95;
          }
        }
LABEL_96:

        *__error() = v60;
      }
LABEL_167:
      objc_autoreleasePoolPop((void *)v34);
      a2 = v45;
      goto LABEL_168;
    }
    if (v49 > 19)
    {
      if (v49 == 2310)
      {
        if (v55 > 0x7F)
          v40 = (uint64_t)v50;
        v68 = (unsigned int *)v231;
        if (v55 <= 0x7F)
          v68 = v50;
        v231 = (unint64_t)v68;
        goto LABEL_167;
      }
      if (v49 == 2313)
      {
        if (*((_BYTE *)v50 + v55 - 1))
        {
          v58 = *__error();
          _sa_logt();
          v59 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B9BE0000, v59, OS_LOG_TYPE_DEFAULT, "WARNING: thread name non NULL-terminated", buf, 2u);
          }

          *__error() = v58;
          v219 = 1;
        }
        else
        {
          v219 = 1;
          v221 = v50;
        }
        goto LABEL_167;
      }
      if (v49 != 20)
        goto LABEL_167;
      v150 = *((_QWORD *)v46 + 1);
      if (v27 == v150)
      {
        objc_autoreleasePoolPop((void *)v34);
        goto LABEL_7;
      }
      v32 = v31;
      LODWORD(a2) = *__error();
      _sa_logt();
      v144 = objc_claimAutoreleasedReturnValue();
      a1 = v235;
      if (!os_log_type_enabled((os_log_t)v144, OS_LOG_TYPE_ERROR))
      {
LABEL_315:
        v36 = 7;
        v28 = v229;
        v29 = self;
        goto LABEL_242;
      }
LABEL_320:
      *(_DWORD *)buf = 134218240;
      v239 = v27;
      v240 = 2048;
      v241 = v150;
      _os_log_error_impl(&dword_1B9BE0000, (os_log_t)v144, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
      goto LABEL_315;
    }
    v65 = (unint64_t)a2[1];
    if (v49 == 17)
    {
      if ((unint64_t)(v46 + 4) > v65 || (unint64_t)v46 + v51 + 16 > v65 || v47 != 17 && v48 != 32)
        goto LABEL_227;
      v69 = *((_QWORD *)v46 + 1);
      if ((_DWORD)v69)
      {
        if (v47 == 17)
        {
          v70 = HIDWORD(v69);
          if (SHIDWORD(v69) <= 2310)
          {
            switch(HIDWORD(v69))
            {
              case 0x30:
                v71 = 20;
                break;
              case 0x31:
                v71 = 24;
                break;
              case 0x81A:
LABEL_112:
                v71 = 8;
                break;
              default:
                goto LABEL_227;
            }
          }
          else
          {
            switch(HIDWORD(v69))
            {
              case 0x907:
                v71 = 4;
                break;
              case 0x908:
              case 0x909:
                goto LABEL_227;
              case 0x90A:
              case 0x90C:
                goto LABEL_112;
              case 0x90B:
              case 0x90D:
                v71 = 16;
                break;
              default:
                if (HIDWORD(v69) != 2369)
                  goto LABEL_227;
                v71 = 48;
                break;
            }
          }
          if (v51 / v71 < v69 || v51 % v69 >= 0x10)
          {
LABEL_227:
            v32 = v31;
            LODWORD(a2) = *__error();
            _sa_logt();
            v144 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v144, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              v36 = 2;
              _os_log_error_impl(&dword_1B9BE0000, (os_log_t)v144, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", buf, 2u);
            }
            else
            {
              v36 = 2;
            }
            goto LABEL_241;
          }
          goto LABEL_122;
        }
        v73 = **a2 & 0xF;
        v53 = v51 >= v73;
        v74 = v51 - v73;
        if (!v53)
          goto LABEL_227;
        if (v74 < v69)
          goto LABEL_227;
        v72 = v74 / v69;
        if (v74 % v69)
          goto LABEL_227;
        v70 = HIDWORD(v69);
      }
      else
      {
        if (v51)
          goto LABEL_227;
        v70 = HIDWORD(v69);
        if (v47 == 17)
        {
LABEL_122:
          if ((int)v70 > 2310)
          {
            v72 = 8;
            switch((int)v70)
            {
              case 2311:
                goto LABEL_167;
              case 2312:
              case 2313:
                goto LABEL_99;
              case 2314:
              case 2316:
                goto LABEL_125;
              case 2315:
              case 2317:
                v72 = 16;
                goto LABEL_125;
              default:
                if ((_DWORD)v70 != 2369)
                  goto LABEL_99;
                break;
            }
            goto LABEL_167;
          }
          if ((v70 - 48) < 2 || (_DWORD)v70 == 2074)
            goto LABEL_167;
        }
LABEL_99:
        v72 = 0;
      }
LABEL_125:
      v223 = v31;
      switch((int)v70)
      {
        case 2314:
          v75 = v69;
          v76 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v77 = v76;
          if ((_DWORD)v69)
          {
            v78 = 0;
            v79 = v76;
            do
            {
              *v79++ = *(unsigned int *)((char *)v50 + v78);
              v78 += v72;
              --v75;
            }
            while (v75);
          }
          goto LABEL_157;
        case 2315:
          v84 = v69;
          v85 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v77 = v85;
          if ((_DWORD)v69)
          {
            v86 = 0;
            v87 = v85;
            do
            {
              *v87++ = *(_QWORD *)((char *)v50 + v86);
              v86 += v72;
              --v84;
            }
            while (v84);
          }
          goto LABEL_157;
        case 2316:
          v88 = v69;
          v89 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v90 = v89;
          if ((_DWORD)v69)
          {
            v91 = 0;
            v92 = v89;
            do
            {
              *v92++ = *(unsigned int *)((char *)v50 + v91);
              v91 += v72;
              --v88;
            }
            while (v88);
          }
          goto LABEL_165;
        case 2317:
          v93 = v69;
          v94 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v90 = v94;
          if ((_DWORD)v69)
          {
            v95 = 0;
            v96 = v94;
            do
            {
              *v96++ = *(_QWORD *)((char *)v50 + v95);
              v95 += v72;
              --v93;
            }
            while (v93);
          }
          goto LABEL_165;
        case 2318:
        case 2319:
        case 2320:
        case 2321:
        case 2322:
          goto LABEL_167;
        case 2323:
          v97 = v69;
          v98 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v77 = v98;
          if ((_DWORD)v69)
          {
            v99 = 0;
            v100 = v98;
            do
            {
              *v100++ = *(unsigned int *)((char *)v50 + v99);
              v99 += v72;
              --v97;
            }
            while (v97);
          }
          goto LABEL_157;
        case 2324:
          v101 = v69;
          v102 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v77 = v102;
          if ((_DWORD)v69)
          {
            v103 = 0;
            v104 = v102;
            do
            {
              *v104++ = *(_QWORD *)((char *)v50 + v103);
              v103 += v72;
              --v101;
            }
            while (v101);
          }
LABEL_157:
          objc_msgSend(v30, "setKernelFrames:", v77);
          objc_msgSend(v30, "setNumKernelFrames:", v69);
          goto LABEL_166;
        case 2325:
          v105 = v69;
          v106 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v90 = v106;
          if ((_DWORD)v69)
          {
            v107 = 0;
            v108 = v106;
            do
            {
              *v108++ = *(unsigned int *)((char *)v50 + v107);
              v107 += v72;
              --v105;
            }
            while (v105);
          }
          goto LABEL_165;
        case 2326:
          v109 = v69;
          v110 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          v90 = v110;
          if ((_DWORD)v69)
          {
            v111 = 0;
            v112 = v110;
            do
            {
              *v112++ = *(_QWORD *)((char *)v50 + v111);
              v111 += v72;
              --v109;
            }
            while (v109);
          }
LABEL_165:
          objc_msgSend(v30, "setUserFrames:", v90);
          objc_msgSend(v30, "setNumUserFrames:", v69);
          goto LABEL_166;
        default:
          if ((_DWORD)v70 != 2355)
            goto LABEL_167;
          v80 = v69;
          v81 = malloc_type_calloc(v69, 8uLL, 0x100004000313F17uLL);
          if ((_DWORD)v69)
          {
            v82 = 0;
            v83 = v81;
            do
            {
              *v83++ = *(_QWORD *)((char *)v50 + v82);
              v82 += v72;
              --v80;
            }
            while (v80);
          }
          objc_msgSend(v30, "setSwiftAsyncFrames:", v81);
          objc_msgSend(v30, "setNumSwiftAsyncFrames:", v69);
LABEL_166:
          v31 = v223;
          break;
      }
      goto LABEL_167;
    }
    if (v49 != 19)
      goto LABEL_167;
    v66 = v46 + 4;
    if ((unint64_t)v66 > v65 || (unint64_t)v66 + v51 > v65 || v48 == 32 || v47 != 19 || v51 <= 3)
      break;
    v36 = SkipToContainerEnd(a2, 1);
    objc_autoreleasePoolPop((void *)v34);
    if ((_DWORD)v36)
    {
      v28 = v229;
      v29 = self;
      a1 = v235;
      goto LABEL_243;
    }
LABEL_168:
    v35 = a2[1];
    v113 = (char *)*a2 + (*a2)[1];
    v38 = v113 + 16;
    *a2 = (int *)(v113 + 16);
    v39 = v113 + 32;
    if (v39 > (char *)v35)
      goto LABEL_7;
  }
  v32 = v31;
  LODWORD(a2) = *__error();
  _sa_logt();
  v144 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled((os_log_t)v144, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v239) = 2308;
    _os_log_error_impl(&dword_1B9BE0000, (os_log_t)v144, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
  }
  v36 = 1;
LABEL_241:
  v28 = v229;
  v29 = self;
  a1 = v235;
LABEL_242:

  *__error() = (int)a2;
  objc_autoreleasePoolPop((void *)v34);
  v31 = v32;
LABEL_243:
  objc_msgSend(v30, "clearThreadData");
  v32 = v228;
LABEL_313:

  return v36;
}

BOOL __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke(uint64_t a1, void *a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = objc_msgSend(a2, "address");
  v6 = *(_QWORD *)(a1 + 32);
  if (v5 == v6)
    *a3 = 1;
  return v5 == v6;
}

BOOL __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke_301(uint64_t a1, void *a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = objc_msgSend(a2, "address");
  v6 = *(_QWORD *)(a1 + 32);
  if (v5 == v6)
    *a3 = 1;
  return v5 == v6;
}

void __65__SASampleStore_parseKCDataExclavesIPCStackContainer_callstacks___block_invoke(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void *v3;
  int v4;
  NSObject *v5;
  id v6;
  uint8_t buf[16];

  if (*a3)
  {
    v3 = *(void **)(a1 + 32);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:");
    v6 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "insertObject:atIndex:", v6, 0);

  }
  else
  {
    v4 = *__error();
    _sa_logt();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v5, OS_LOG_TYPE_ERROR, "0 frame in exclave stack, ignoring", buf, 2u);
    }

    *__error() = v4;
  }
}

void __68__SASampleStore_parseKCDataExclavesTextLayoutContainer_textLayouts___block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD *v4;

  v3 = *(void **)(a1 + 32);
  v4 = -[SAKCDataExclaveTextLayoutSegment initWithInfo:]([SAKCDataExclaveTextLayoutSegment alloc], a3);
  objc_msgSend(v3, "addObject:", v4);

}

void __44__SASampleStore_resampleTruncatedBacktraces__block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  _BYTE *v7;
  void *v8;
  pid_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  pid_t v18;
  void *v19;
  _BYTE *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, void *, const void *, uint64_t);
  void *v26;
  id v27;
  id v28;
  uint64_t *v29;
  uint64_t v30;
  _QWORD v31[5];
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t (*v35)(uint64_t, uint64_t);
  void (*v36)(uint64_t);
  id v37;
  uint64_t dest;

  v5 = a2;
  v6 = a3;
  objc_msgSend(v6, "lastObject");
  v7 = (_BYTE *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v7, "pid") != -1 && objc_msgSend(v7, "pid"))
  {
    objc_msgSend(v7, "exitTimestamp");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    if (v8 || (v9 = getpid(), v9 == objc_msgSend(v7, "pid")))
    {

      goto LABEL_6;
    }
    if (_AvoidSuspendingPid(objc_msgSend(v7, "pid")))
      goto LABEL_6;
    v32 = 0;
    v33 = &v32;
    v34 = 0x3032000000;
    v35 = __Block_byref_object_copy__0;
    v36 = __Block_byref_object_dispose__0;
    v37 = 0;
    objc_msgSend(v7, "threads");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = MEMORY[0x1E0C809B0];
    v31[0] = MEMORY[0x1E0C809B0];
    v31[1] = 3221225472;
    v31[2] = __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_2;
    v31[3] = &unk_1E7147860;
    v31[4] = &v32;
    objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", v31);

    if (!v33[5])
    {
LABEL_20:
      _Block_object_dispose(&v32, 8);

      goto LABEL_6;
    }
    objc_msgSend(v7, "binaryLoadInfos");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(a1 + 32), "setUserBinaryLoadInfos:", v12);

    if (v7)
      v13 = v7[73] & 1;
    else
      v13 = 0;
    objc_msgSend(*(id *)(a1 + 32), "setAssumeUserBinaryLoadInfosContainMainBinary:", v13);
    objc_msgSend(v7, "sharedCache");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(a1 + 32), "setSharedCache:", v14);

    v15 = *(_QWORD *)(a1 + 40);
    if (v15)
    {
      v16 = *(_QWORD *)(v15 + 192);
      if (v7)
      {
LABEL_13:
        objc_copyStruct(&dest, v7 + 288, 8, 1, 0);
        if (v16)
        {
          if (dest)
          {
            CSArchitectureGetFamily();
            CSArchitectureGetFamily();
            if ((CSArchitectureMatchesArchitecture() & 1) == 0)
            {
              -[SASampleStore addressTranslationsForPid:](*(_QWORD *)(a1 + 40), objc_msgSend(v7, "pid"));
              v17 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(*(id *)(a1 + 32), "setAddressTranslations:", v17);

            }
          }
        }
      }
    }
    else
    {
      v16 = 0;
      if (v7)
        goto LABEL_13;
    }
    v18 = objc_msgSend(v7, "pid");
    objc_msgSend((id)v33[5], "allKeys");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = v11;
    v24 = 3221225472;
    v25 = __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_3;
    v26 = &unk_1E7147138;
    v29 = &v32;
    v27 = *(id *)(a1 + 32);
    v20 = v7;
    v21 = *(_QWORD *)(a1 + 48);
    v28 = v20;
    v30 = v21;
    v22 = SAResampleThreads(v18, v19, &v23);

    if (!v22)
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
    objc_msgSend(*(id *)(a1 + 32), "clearTaskData", v23, v24, v25, v26);

    goto LABEL_20;
  }
LABEL_6:

}

void __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5;
  const char *v6;
  void *v7;
  const char *v8;
  _QWORD *v9;
  id Property;
  id v11;
  void *v12;
  void *v13;
  void *i;
  id v15;
  void *v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  _QWORD *v20;
  void *v21;
  id v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  id v28;

  v28 = a2;
  v5 = a3;
  v7 = v5;
  if (!v5)
  {
    Property = 0;
LABEL_5:
    v11 = Property;

    if (v11)
      goto LABEL_6;
    objc_msgSend(v7, "threadStates");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "lastObject");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "leafUserFrame");
    v9 = (_QWORD *)objc_claimAutoreleasedReturnValue();

    if (v9)
    {
LABEL_8:
      for (i = (void *)v9[4]; ; i = 0)
      {
        v15 = i;

        if (!v15)
          break;
        if (v9)
          v16 = (void *)v9[4];
        else
          v16 = 0;
        v17 = v16;

        v9 = v17;
        if (v17)
          goto LABEL_8;
      }
      if ((objc_msgSend(v9, "isTruncatedBacktraceFrame") & 1) != 0)
        goto LABEL_26;
    }
    objc_msgSend(v7, "threadStates");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v18, "lastObject");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "leafOfCRootFramesReplacedBySwiftAsync");
    v20 = (_QWORD *)objc_claimAutoreleasedReturnValue();

    if (!v20)
    {
      v9 = 0;
      goto LABEL_3;
    }
    while (1)
    {
      v9 = v20;
      v21 = v20 ? (void *)v20[4] : 0;
      v22 = v21;

      if (!v22)
        break;
      if (v9)
        v23 = (void *)v9[4];
      else
        v23 = 0;
      v20 = v23;

    }
    if (!objc_msgSend(v9, "isTruncatedBacktraceFrame"))
      goto LABEL_3;
LABEL_26:
    v24 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
    if (!v24)
    {
      v25 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 8);
      v26 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v27 = *(void **)(v26 + 40);
      *(_QWORD *)(v26 + 40) = v25;

      v24 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
    }
    objc_msgSend(v24, "setObject:forKeyedSubscript:", v7, v28);
    goto LABEL_3;
  }
  v9 = objc_getProperty(v5, v6, 48, 1);
  if (!v9)
  {
    Property = objc_getProperty(v7, v8, 56, 1);
    goto LABEL_5;
  }
LABEL_3:

LABEL_6:
}

void __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_3(uint64_t a1, void *a2, const void *a3, uint64_t a4)
{
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  const char *v14;
  id v15;
  SEL v16;
  int v17;
  NSObject *v18;
  void *v19;
  void *v20;
  unsigned int v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  uint8_t buf[4];
  void *v32;
  __int16 v33;
  void *v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "objectForKeyedSubscript:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v10)
  {
    v22 = *__error();
    _sa_logt();
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v32 = a2;
      _os_log_error_impl(&dword_1B9BE0000, v23, OS_LOG_TYPE_ERROR, "bad tid 0x%llx", buf, 0xCu);
    }

    *__error() = v22;
    _SASetCrashLogMessage(6685, "bad tid 0x%llx", v24, v25, v26, v27, v28, v29, (char)a2);
    _os_crash();
    __break(1u);
  }
  objc_msgSend(*(id *)(a1 + 32), "setUserFrames:", malloc_type_calloc(a4, 8uLL, 0x100004000313F17uLL));
  memcpy((void *)objc_msgSend(*(id *)(a1 + 32), "userFrames"), a3, 8 * a4);
  objc_msgSend(*(id *)(a1 + 32), "setNumUserFrames:", a4);
  v12 = *(void **)(a1 + 32);
  v11 = *(_QWORD *)(a1 + 40);
  v30 = 0;
  -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:](v11, v12, &v30);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = v30;
  if (v13)
  {
    objc_setProperty_atomic(v10, v14, v13, 48);
    objc_setProperty_atomic(v10, v16, v15, 56);
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  }
  else
  {
    v17 = *__error();
    _sa_logt();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(*(id *)(a1 + 40), "debugDescription");
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "debugDescription");
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      v21 = objc_msgSend(*(id *)(a1 + 32), "numUserFrames");
      *(_DWORD *)buf = 138412802;
      v32 = v19;
      v33 = 2112;
      v34 = v20;
      v35 = 2048;
      v36 = v21;
      _os_log_error_impl(&dword_1B9BE0000, v18, OS_LOG_TYPE_ERROR, "%@ %@ unable to add resampled stack with %lu frames", buf, 0x20u);

    }
    *__error() = v17;
  }
  objc_msgSend(*(id *)(a1 + 32), "clearThreadData");

}

- (int)addMicrostackshotsFromFile:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8
{
  return -[SASampleStore addMicrostackshotsFromFile:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:](self, "addMicrostackshotsFromFile:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:", a3, *(_QWORD *)&a4, *(_QWORD *)&a7, a8, 0, a5, a6);
}

- (int)addMicrostackshotsFromFile:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8 statistics:(id)a9
{
  id v16;
  id v17;
  const char *v18;
  int v19;
  gzFile v20;
  gzFile_s *v21;
  char *v22;
  char *v23;
  int v24;
  int v25;
  size_t v26;
  uint64_t v27;
  size_t v28;
  unint64_t v29;
  int64_t v30;
  char *v31;
  int v32;
  NSObject *v33;
  const char *v34;
  int v35;
  NSObject *v36;
  uint32_t v37;
  int v38;
  const char *v39;
  int v40;
  NSObject *v41;
  _BOOL4 v42;
  const char *v43;
  const char *v44;
  NSObject *v45;
  uint32_t v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  id v71;
  int v72;
  gzFile_s *v73;
  size_t __size;
  id v75;
  int errnum;
  uint8_t buf[4];
  _BYTE v78[18];
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v16 = a3;
  v75 = a9;
  v17 = objc_retainAutorelease(v16);
  v18 = (const char *)objc_msgSend(v17, "UTF8String");
  if (!v18)
  {
    *__error() = 22;
    v32 = *__error();
    _sa_logt();
    v33 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v34 = "Unable to convert microstackshots path to C string";
LABEL_31:
      v36 = v33;
      v37 = 2;
      goto LABEL_32;
    }
LABEL_33:

    *__error() = v32;
    v25 = -1;
    goto LABEL_48;
  }
  v19 = open(v18, 0);
  if (v19 == -1)
  {
    v32 = *__error();
    _sa_logt();
    v33 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v35 = *__error();
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v78 = v35;
      v34 = "Unable to open microstackshots file: %{errno}d";
      v36 = v33;
      v37 = 8;
LABEL_32:
      _os_log_error_impl(&dword_1B9BE0000, v36, OS_LOG_TYPE_ERROR, v34, buf, v37);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v20 = gzdopen(v19, "r");
  if (!v20)
  {
    v32 = *__error();
    _sa_logt();
    v33 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v34 = "Unable to gzdopen microstackshots file";
      goto LABEL_31;
    }
    goto LABEL_33;
  }
  v21 = v20;
  v71 = v17;
  v22 = (char *)malloc_type_calloc(1uLL, 0x20000uLL, 0x286E7691uLL);
  if (!v22)
    goto LABEL_57;
  v23 = v22;
  v24 = gzread(v21, v22, 0x20000u);
  if (v24 < 1)
  {
    v25 = 0;
    goto LABEL_39;
  }
  v25 = 0;
  v26 = 0;
  v27 = 0x20000;
  v73 = v21;
  while (1)
  {
    v28 = v26 + v24;
    if (v28)
      break;
    v26 = 0;
LABEL_22:
    v24 = gzread(v21, &v23[v26], v27 - v26);
    if (v24 <= 0)
    {
      if (v26)
        goto LABEL_38;
      goto LABEL_39;
    }
  }
  v72 = v24;
  __size = v27;
  v29 = 0;
  while (1)
  {
    v26 = v28 - v29;
    v21 = (gzFile_s *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytesNoCopy:length:freeWhenDone:", &v23[v29], v28 - v29, 0);
    v30 = -[SASampleStore _addMicrostackshotFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:]((uint64_t)self, v21, a4, a7, a8, v75, a5, a6);
    if (v30 <= 0)
      break;
    v29 += v30;
    if (v28 < v29)
    {
      v25 = *__error();
      _sa_logt();
      v41 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)v78 = v29;
        *(_WORD *)&v78[8] = 2048;
        *(_QWORD *)&v78[10] = v28;
        _os_log_error_impl(&dword_1B9BE0000, v41, OS_LOG_TYPE_ERROR, "parsed beyond end of microstackshots buffer: %lu > %lu", buf, 0x16u);
      }

      *__error() = v25;
      _SASetCrashLogMessage(6779, "parsed beyond end of microstackshots buffer: %lu > %lu", v48, v49, v50, v51, v52, v53, v29);
      _os_crash();
      __break(1u);
LABEL_52:
      v54 = *__error();
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v78 = v54;
      v44 = "Error while reading microstackshots file: %{errno}d";
      v45 = v41;
      v46 = 8;
LABEL_53:
      _os_log_error_impl(&dword_1B9BE0000, v45, OS_LOG_TYPE_ERROR, v44, buf, v46);
      goto LABEL_46;
    }
    ++v25;

    v26 = v28 - v29;
    if (v28 <= v29)
      goto LABEL_16;
  }
  if ((v30 & 0x8000000000000000) == 0)
  {

LABEL_16:
    v21 = v73;
    if (!v26)
      goto LABEL_19;
    if (v29)
    {
      memmove(v23, &v23[v29], v26);
LABEL_19:
      v27 = __size;
      goto LABEL_22;
    }
    v27 = 2 * __size;
    v31 = (char *)reallocf(v23, 2 * __size);
    if (v31)
    {
      v23 = v31;
      goto LABEL_22;
    }
    v55 = *__error();
    _sa_logt();
    v56 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v78 = 2 * __size;
      _os_log_error_impl(&dword_1B9BE0000, v56, OS_LOG_TYPE_ERROR, "realloc of size %lu failed", buf, 0xCu);
    }

    *__error() = v55;
    _SASetCrashLogMessage(6792, "realloc of size %lu failed", v57, v58, v59, v60, v61, v62, 2 * __size);
    _os_crash();
    __break(1u);
LABEL_57:
    v63 = *__error();
    _sa_logt();
    v64 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v78 = 0x20000;
      _os_log_error_impl(&dword_1B9BE0000, v64, OS_LOG_TYPE_ERROR, "calloc of %d failed", buf, 8u);
    }

    *__error() = v63;
    _SASetCrashLogMessage(6745, "calloc of %d failed", v65, v66, v67, v68, v69, v70, 0);
    _os_crash();
    __break(1u);
  }
  if (!v25)
    v25 = -1;

  v26 = v28;
  v21 = v73;
  v24 = v72;
LABEL_38:
  v38 = v24;
  objc_msgSend(v75, "setBytes_not_microstackshots:", objc_msgSend(v75, "bytes_not_microstackshots") + v26);
  v24 = v38;
LABEL_39:
  if (v24 == -1)
  {
    errnum = 0;
    v39 = gzerror(v21, &errnum);
    v40 = errnum;
    LODWORD(v29) = *__error();
    _sa_logt();
    v41 = objc_claimAutoreleasedReturnValue();
    v42 = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
    if (v40 == -1)
    {
      if (v42)
        goto LABEL_52;
    }
    else if (v42)
    {
      v43 = "";
      if (v39)
        v43 = v39;
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)v78 = errnum;
      *(_WORD *)&v78[4] = 2080;
      *(_QWORD *)&v78[6] = v43;
      v44 = "Error while reading microstackshots file: %d %s";
      v45 = v41;
      v46 = 18;
      goto LABEL_53;
    }
LABEL_46:

    *__error() = v29;
  }
  free(v23);
  gzclose(v21);
  v17 = v71;
LABEL_48:

  return v25;
}

- (unint64_t)_addMicrostackshotFromData:(int)a3 ofTypes:(int)a4 inTimeRangeStart:(uint64_t)a5 end:(void *)a6 onlyPid:(double)a7 onlyTid:(double)a8 statistics:
{
  id v15;
  _QWORD *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v24;
  int v25;
  char v26;
  unsigned int v27;
  int v28;
  NSObject *v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  unint64_t v37;
  unint64_t v38;
  unsigned int v39;
  unint64_t v40;
  uint64_t *v41;
  char *v42;
  char v43;
  char v44;
  unint64_t v45;
  unint64_t v46;
  double v47;
  NSObject *v48;
  int v49;
  NSObject *v50;
  unint64_t v51;
  unint64_t v52;
  NSObject *v53;
  BOOL v54;
  void *v55;
  void *v56;
  id *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  char v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  size_t v67;
  unsigned __int8 *v68;
  unsigned int v69;
  const unsigned __int8 *v70;
  unsigned __int8 *v71;
  uint64_t v72;
  uint64_t v73;
  const unsigned __int8 *v74;
  uint64_t v75;
  unsigned __int8 *v76;
  _BOOL4 v78;
  FILE **v79;
  int v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  int v84;
  NSObject *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  void *v93;
  void *v94;
  SAFrameIterator *v95;
  int v96;
  void *v97;
  uint64_t v98;
  void *v99;
  unsigned int v100;
  uint64_t v101;
  size_t v102;
  size_t v103;
  void *v104;
  void *v105;
  unsigned int *v106;
  _QWORD *v107;
  size_t v108;
  unsigned int v109;
  void *v110;
  void *v111;
  char *v112;
  _QWORD *v113;
  size_t v114;
  unsigned int v115;
  uint64_t v116;
  size_t v117;
  void *v118;
  void *v119;
  uint64_t v120;
  unsigned int *v121;
  _QWORD *v122;
  unsigned int v123;
  uint64_t v124;
  uint64_t v125;
  id *v126;
  uint64_t v127;
  void *v128;
  void *v129;
  _BYTE *v130;
  void *v131;
  _BYTE *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  double v137;
  uint64_t v138;
  int v139;
  void *v140;
  __CFString *v141;
  BOOL v142;
  char v143;
  uint64_t v144;
  id *location;
  int locationa;
  void *__base;
  unsigned __int8 *__basea;
  id obj;
  id obja;
  unsigned int v151;
  void *v152;
  char v153;
  int v154;
  void *v155;
  char *v156;
  uint64_t *v157;
  NSObject *__src;
  id *__srca;
  int v160;
  size_t v161;
  id v162;
  uint64_t v163;
  void *v164;
  size_t count;
  int counta;
  SAFrameIterator *countb;
  void *context;
  id v169;
  uint8_t v170[4];
  uint8_t *v171;
  __int16 v172;
  int v173;
  __int16 v174;
  uint64_t v175;
  __int16 v176;
  double v177;
  uint8_t buf[4];
  unint64_t v179;
  uint64_t v180;

  v180 = *MEMORY[0x1E0C80C00];
  v15 = a2;
  v16 = a6;
  if (!a1)
  {
    v22 = 0;
    goto LABEL_7;
  }
  context = (void *)MEMORY[0x1BCCCC288]();
  v17 = objc_retainAutorelease(v15);
  v18 = objc_msgSend(v17, "bytes");
  v19 = objc_msgSend(v17, "length");
  v20 = v19;
  if (!*(_QWORD *)(a1 + 360))
    *(_QWORD *)(a1 + 360) = 1;
  *(_QWORD *)(a1 + 352) |= 4uLL;
  v21 = v18 + v19;
  if (v18 + v19 < (unint64_t)(v18 + 27))
    goto LABEL_5;
  if (*(_DWORD *)v18 != 835010577)
  {
    v28 = *__error();
    _sa_logt();
    v29 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v29, OS_LOG_TYPE_ERROR, "Microstackshot buffer doesn't start with micro_snapshot", buf, 2u);
    }

    *__error() = v28;
    v30 = v20 - 1;
    if (v20 - 1 >= 5)
    {
      v31 = 0;
      while (*(_DWORD *)(v18 + 1 + v31) != 835010577)
      {
        if (v20 - 5 == ++v31)
          goto LABEL_22;
      }
      v30 = v31;
    }
LABEL_22:
    v22 = v30 + 1;
    v32 = *__error();
    _sa_logt();
    v33 = objc_claimAutoreleasedReturnValue();
    v34 = v33;
    if (v22 < v20)
    {
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
LABEL_26:

        *__error() = v32;
        objc_msgSend(v16, "setBytes_not_microstackshots:", objc_msgSend(v16, "bytes_not_microstackshots") + v22);
        goto LABEL_6;
      }
      *(_DWORD *)buf = 134217984;
      v179 = v22;
LABEL_25:
      _os_log_impl(&dword_1B9BE0000, v34, OS_LOG_TYPE_INFO, "Skipping %lu bytes until next microstackshot in the buffer", buf, 0xCu);
      goto LABEL_26;
    }
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    *(_DWORD *)buf = 134217984;
    v179 = v20;
LABEL_72:
    _os_log_error_impl(&dword_1B9BE0000, v34, OS_LOG_TYPE_ERROR, "Remaining %lu bytes do not contain any microstackshots", buf, 0xCu);
    goto LABEL_28;
  }
  v24 = v18 + 320;
  if (v21 < v18 + 320)
    goto LABEL_5;
  if (*(_DWORD *)(v18 + 27) != -557122643)
  {
    v35 = *__error();
    _sa_logt();
    v36 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v36, OS_LOG_TYPE_ERROR, "Microstackshot buffer doesn't contain task_snapshot after micro_snapshot", buf, 2u);
    }

    *__error() = v35;
    v37 = v20 - 1;
    if (v20 - 1 >= 5)
    {
      v38 = 0;
      while (*(_DWORD *)(v18 + 1 + v38) != 835010577)
      {
        if (v20 - 5 == ++v38)
          goto LABEL_59;
      }
      v37 = v38;
    }
LABEL_59:
    v22 = v37 + 1;
    v32 = *__error();
    _sa_logt();
    v48 = objc_claimAutoreleasedReturnValue();
    v34 = v48;
    if (v22 < v20)
    {
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
        goto LABEL_26;
      *(_DWORD *)buf = 134217984;
      v179 = v22;
      goto LABEL_25;
    }
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    *(_DWORD *)buf = 134217984;
    v179 = v20;
    goto LABEL_72;
  }
  v25 = *(_DWORD *)(v18 + 107);
  if (!*(_DWORD *)(v18 + 31))
  {
    if ((v25 & 2) == 0)
      goto LABEL_13;
LABEL_37:
    v26 = 1;
    v27 = 24;
    goto LABEL_38;
  }
  if ((v25 & 1) != 0)
    goto LABEL_37;
LABEL_13:
  v26 = 0;
  v27 = 20;
LABEL_38:
  v39 = *(_DWORD *)(v18 + 83);
  v40 = v24 + v27 * (unint64_t)v39;
  if (v21 >= v40 && v21 >= v40 + 316)
  {
    if (*(_DWORD *)v40 == -17958194)
    {
      v22 = 0;
      if ((*(_BYTE *)(v40 + 68) & 4) != 0)
        v41 = (uint64_t *)(v40 + 316);
      else
        v41 = 0;
      if ((*(_BYTE *)(v40 + 68) & 4) != 0)
        v42 = (char *)(v40 + 324);
      else
        v42 = (char *)(v40 + 316);
      v43 = 2;
      if ((*(_BYTE *)(v40 + 68) & 2) != 0)
        v44 = 3;
      else
        v44 = 2;
      v45 = (unint64_t)*(unsigned int *)(v40 + 4) << v44;
      if ((*(_BYTE *)(v40 + 68) & 1) != 0)
        v43 = 3;
      v46 = (unint64_t)&v42[v45 + ((unint64_t)*(unsigned int *)(v40 + 8) << v43)];
      if (v21 < v46)
        goto LABEL_6;
      v151 = v27;
      v153 = v26;
      v163 = v24 + v27 * (unint64_t)v39;
      count = *(unsigned int *)(v18 + 83);
      v157 = v41;
      __src = (v18 + 320);
      v160 = *(_DWORD *)(v18 + 107);
      v155 = v42;
      v156 = &v42[v45];
      if (__strlcpy_chk() == 16)
        __strlcpy_chk();
      v47 = (double)*(unint64_t *)(v18 + 8)
          - *MEMORY[0x1E0C9ADF8]
          + (double)*(unint64_t *)(v18 + 16) / 1000000.0;
      if (a8 != 0.0 && v47 > a8)
      {
        v22 = -2;
        goto LABEL_6;
      }
      v22 = v46 - v18;
      if (a7 != 0.0 && v47 < a7
        || (a3 & 0xFFFFFFFB) != 0 && (a3 & 0xFB & *(_BYTE *)(v18 + 24)) == 0
        || (a4 & 0x80000000) == 0 && *(_DWORD *)(v18 + 31) != a4
        || a5 && *(_QWORD *)(v163 + 28) != a5)
      {
        objc_msgSend(v16, "setNum_microstackshots_filtered_out:", objc_msgSend(v16, "num_microstackshots_filtered_out") + 1);
        objc_msgSend(v16, "setBytes_microstackshots_filtered_out:", objc_msgSend(v16, "bytes_microstackshots_filtered_out") + v22);
        goto LABEL_6;
      }
      v54 = (*(_BYTE *)(a1 + 408) & 1) != 0 && v47 > SATimeOfBootForLiveMachine();
      +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, v47);
      v55 = (void *)objc_claimAutoreleasedReturnValue();
      v57 = (id *)(a1 + 48);
      v56 = *(void **)(a1 + 48);
      if (v56 && objc_msgSend(v56, "ge:", v55))
      {
        v142 = v54;
        -[SASampleStore taskWithPid:atTimestamp:](a1, *(unsigned int *)(v18 + 31), v55);
        __base = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(__base, "threads");
        v58 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(v163 + 28));
        v59 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v58, "objectForKeyedSubscript:", v59);
        v60 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v60, "firstThreadStateOnOrAfterTime:sampleIndex:", v55, 0x7FFFFFFFFFFFFFFFLL);
        v61 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v61, "endTimestamp");
        v62 = (void *)objc_claimAutoreleasedReturnValue();
        obj = v55;
        v63 = objc_msgSend(v62, "eq:", v55);

        if ((v63 & 1) != 0)
        {
          v64 = 2;
        }
        else
        {
          v65 = *__error();
          _sa_logt();
          v66 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          {
            v139 = *(_DWORD *)(v18 + 31);
            v141 = objc_retainAutorelease((id)_CopyStringForTime(3, v47));
            v138 = -[__CFString UTF8String](v141, "UTF8String");
            objc_msgSend(*(id *)(a1 + 48), "wallTime");
            *(_DWORD *)v170 = 136315906;
            v171 = buf;
            v172 = 1024;
            v173 = v139;
            v174 = 2080;
            v175 = v138;
            v176 = 2048;
            v177 = v137 - v47;
            _os_log_error_impl(&dword_1B9BE0000, v66, OS_LOG_TYPE_ERROR, "Not including microstackshot for %s [%d] at %s due being out of order (before previous by %fs)", v170, 0x26u);

          }
          *__error() = v65;
          v64 = 4;
        }

        v55 = obj;
        v54 = v142;
        v57 = (id *)(a1 + 48);
      }
      else
      {
        v64 = 0;
      }
      if ((_DWORD)count || (objc_msgSend((id)a1, "keepMicrostackshotsWithoutLoadInfo") & 1) != 0)
      {
        if (!v64)
        {
          location = v57;
          v143 = v54;
          obja = v55;
          -[SAMicrostackshotStatistics addMicro:task:thread:size:errors:](v16, v18, v18 + 27, v163, v22, 0);
          v140 = 0;
          if (!uuid_is_null((const unsigned __int8 *)(v18 + 59)))
          {
            -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, v18 + 59, *(_QWORD *)(v18 + 75), -1);
            v140 = (void *)objc_claimAutoreleasedReturnValue();
          }
          if ((_DWORD)count)
          {
            v67 = count;
            v68 = (unsigned __int8 *)malloc_type_calloc(count, 0x18uLL, 0x1000040504FFAC1uLL);
            __basea = v68;
            if ((v153 & 1) != 0)
            {
              memmove(v68, __src, v151 * (unint64_t)count);
            }
            else
            {
              v70 = (const unsigned __int8 *)(v18 + 324);
              v71 = v68 + 8;
              do
              {
                *((_QWORD *)v71 - 1) = *((unsigned int *)v70 - 1);
                uuid_copy(v71, v70);
                v70 += 20;
                v71 += 24;
                --v67;
              }
              while (v67);
            }
            v72 = 0;
            v69 = 0;
            if (count <= 1)
              v73 = 1;
            else
              v73 = count;
            v74 = __basea + 8;
            do
            {
              if (!uuid_is_null(v74))
              {
                v75 = *((_QWORD *)v74 - 1);
                if (v75)
                {
                  if (v72 != v69)
                  {
                    v76 = &__basea[24 * v69];
                    *(_QWORD *)v76 = v75;
                    uuid_copy(v76 + 8, v74);
                  }
                  ++v69;
                }
              }
              ++v72;
              v74 += 24;
            }
            while (v73 != v72);
            v78 = (_DWORD)count != v69 && v69 != 0;
            counta = v78;
            if (v69 && *(_DWORD *)(v18 + 31))
            {
              mergesort_b(__basea, v69, 0x18uLL, &__block_literal_global_323);
              __src = __basea;
            }
            else
            {
              __src = __basea;
            }
          }
          else
          {
            v69 = 0;
            __basea = 0;
            counta = 0;
          }
          if ((*(_BYTE *)(a1 + 408) & 1) != 0)
          {
            if (!*(_QWORD *)(a1 + 192))
              objc_msgSend((id)a1, "gatherMachineArchitecture");
            if (!*(_DWORD *)(a1 + 184) || !*(_DWORD *)(a1 + 188))
              mach_timebase_info((mach_timebase_info_t)(a1 + 184));
            if (!*(_DWORD *)(a1 + 344) || !*(_DWORD *)(a1 + 348))
            {
              -[SASampleStore gatherHWPageSize]((int *)a1);
              -[SASampleStore gatherVMPageSize]((int *)a1);
            }
          }
          else if (!*(_BYTE *)(a1 + 288))
          {
            v79 = (FILE **)MEMORY[0x1E0C80C10];
            if (!*(_QWORD *)(a1 + 192))
            {
              v80 = *__error();
              _sa_logt();
              v81 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v170 = 0;
                _os_log_impl(&dword_1B9BE0000, v81, OS_LOG_TYPE_DEFAULT, "WARNING: Machine architecture unknown for microstackshots, task architectures will be unknown", v170, 2u);
              }

              *__error() = v80;
              fwrite("Machine architecture unknown for microstackshots, task architectures will be unknown\n", 0x55uLL, 1uLL, *v79);
              *(_BYTE *)(a1 + 288) = 1;
            }
            if (!*(_DWORD *)(a1 + 184) || !*(_DWORD *)(a1 + 188))
            {
              v82 = *__error();
              _sa_logt();
              v83 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v170 = 0;
                _os_log_impl(&dword_1B9BE0000, v83, OS_LOG_TYPE_DEFAULT, "WARNING: Mach timebase unknown for microstackshots, cpu times will be unknown", v170, 2u);
              }

              *__error() = v82;
              fwrite("Mach timebase unknown for microstackshots, cpu times will be unknown\n", 0x45uLL, 1uLL, *v79);
              *(_BYTE *)(a1 + 288) = 1;
            }
            if (!*(_DWORD *)(a1 + 344) || !*(_DWORD *)(a1 + 348))
            {
              v84 = *__error();
              _sa_logt();
              v85 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v170 = 0;
                _os_log_impl(&dword_1B9BE0000, v85, OS_LOG_TYPE_DEFAULT, "WARNING: Page sizes unknown for microstackshots, task footprints will be unknown", v170, 2u);
              }

              *__error() = v84;
              fwrite("Page sizes unknown for microstackshots, task footprints will be unknown\n", 0x48uLL, 1uLL, *v79);
              *(_BYTE *)(a1 + 288) = 1;
            }
          }
          if ((v160 & 0x10000000) != 0 && (v86 = *(_QWORD *)(a1 + 192)) != 0)
            v87 = SAArchitectureForTranslatedTask(v86);
          else
            v87 = 0;
          if (!*(_QWORD *)(a1 + 40))
            objc_storeStrong((id *)(a1 + 40), obja);
          objc_storeStrong(location, obja);
          ++*(_QWORD *)(a1 + 32);
          -[SASampleStore taskForMicrostackshotTask:taskName:loadInfos:numLoadInfos:sharedCache:loadInfosIsPartial:timestamp:architecture:needAOTInfo:isFromCurrentBoot:](a1, v18 + 27, (char *)buf, __src, v69, v140, counta, obja, v87, (v160 & 0x10000000) != 0, v143);
          v88 = objc_claimAutoreleasedReturnValue();
          v89 = v88;
          v90 = *(_QWORD *)(v18 + 111);
          v154 = *(_DWORD *)(v18 + 119);
          locationa = *(_DWORD *)(v18 + 123);
          if (v90 && v88)
            *(_QWORD *)(v88 + 144) = v90;
          +[SATaskState stateWithStackshotTaskV1:machTimebase:hwPageSize:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, v18 + 27, *(_QWORD *)(a1 + 184), *(_DWORD *)(a1 + 344), obja, obja, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL);
          v91 = objc_claimAutoreleasedReturnValue();
          if (v89)
          {
            objc_msgSend(*(id *)(v89 + 8), "addObject:", v91);
            objc_msgSend(*(id *)(v89 + 8), "count");
          }
          v152 = (void *)v91;
          objc_msgSend((id)v89, "threads");
          v92 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(v163 + 28));
          v93 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v92, "objectForKeyedSubscript:", v93);
          v94 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v94)
          {
            +[SAThread threadWithId:]((uint64_t)SAThread, *(_QWORD *)(v163 + 28));
            v94 = (void *)objc_claimAutoreleasedReturnValue();
            -[SATask addThread:](v89, v94);
          }
          __srca = (id *)v94;
          v95 = objc_alloc_init(SAFrameIterator);
          -[SAFrameIterator setBacktracer:](v95, "setBacktracer:", 2);
          v96 = *(_DWORD *)(v18 + 31);
          objc_msgSend((id)v89, "binaryLoadInfos");
          v97 = (void *)objc_claimAutoreleasedReturnValue();
          countb = v95;
          if (v96)
          {
            -[SAFrameIterator setUserBinaryLoadInfos:](v95, "setUserBinaryLoadInfos:", v97);

            if (v89)
              v98 = *(_BYTE *)(v89 + 73) & 1;
            else
              v98 = 0;
            -[SAFrameIterator setAssumeUserBinaryLoadInfosContainMainBinary:](v95, "setAssumeUserBinaryLoadInfosContainMainBinary:", v98);
            objc_msgSend((id)v89, "sharedCache");
            v99 = (void *)objc_claimAutoreleasedReturnValue();
            -[SAFrameIterator setSharedCache:](v95, "setSharedCache:", v99);

            if ((v160 & 0x10000000) == 0)
            {
LABEL_178:
              v100 = *(_DWORD *)(v163 + 8);
              if (v100)
              {
                v101 = *(unsigned __int16 *)(v163 + 74);
                v144 = (uint64_t)((unint64_t)(((v101 - 1) < 0xFFFE) & (v100 > v101)) << 63) >> 63;
                if ((v101 - 1) < 0xFFFE && v100 > v101)
                  v102 = *(unsigned __int16 *)(v163 + 74);
                else
                  v102 = v100;
                if ((v101 - 1) < 0xFFFE && v100 > v101)
                  v103 = v100 - v101;
                else
                  v103 = 0;
                v161 = v103;
                v104 = malloc_type_calloc(v102, 8uLL, 0x100004000313F17uLL);
                v105 = v104;
                if ((*(_BYTE *)(v163 + 68) & 1) != 0)
                {
                  memcpy(v104, v156, 8 * v102);
                }
                else if ((_DWORD)v102)
                {
                  v106 = (unsigned int *)v156;
                  v107 = v104;
                  v108 = v102;
                  do
                  {
                    v109 = *v106++;
                    *v107++ = v109;
                    --v108;
                  }
                  while (v108);
                }
                -[SAFrameIterator setUserFrames:](v95, "setUserFrames:", v105);
                -[SAFrameIterator setNumUserFrames:](v95, "setNumUserFrames:", v102);
                if ((_DWORD)v161)
                {
                  v110 = malloc_type_calloc(v161, 8uLL, 0x100004000313F17uLL);
                  v111 = v110;
                  if ((*(_BYTE *)(v163 + 68) & 1) != 0)
                  {
                    memcpy(v110, &v156[8 * v101], 8 * v161);
                  }
                  else
                  {
                    v112 = &v156[4 * v101];
                    v113 = v110;
                    v114 = v161;
                    do
                    {
                      v115 = *(_DWORD *)v112;
                      v112 += 4;
                      *v113++ = v115;
                      --v114;
                    }
                    while (v114);
                  }
                  -[SAFrameIterator setSwiftAsyncFrames:](v95, "setSwiftAsyncFrames:", v111);
                  -[SAFrameIterator setNumSwiftAsyncFrames:](v95, "setNumSwiftAsyncFrames:", v161);
                  -[SAFrameIterator setSwiftAsyncStitchIndex:](v95, "setSwiftAsyncStitchIndex:", v102);
                }
              }
              else
              {
                v144 = 0;
              }
              v116 = v163;
              v117 = *(unsigned int *)(v163 + 4);
              if ((_DWORD)v117)
              {
                v118 = malloc_type_calloc(v117, 8uLL, 0x100004000313F17uLL);
                v119 = v118;
                v120 = *(unsigned int *)(v163 + 4);
                if ((*(_BYTE *)(v163 + 68) & 2) != 0)
                {
                  memcpy(v118, v155, 8 * v120);
                }
                else
                {
                  v121 = (unsigned int *)v155;
                  if ((_DWORD)v120)
                  {
                    v122 = v118;
                    do
                    {
                      v123 = *v121++;
                      *v122++ = v123;
                      --v120;
                    }
                    while (v120);
                  }
                }
                -[SAFrameIterator setKernelFrames:](v95, "setKernelFrames:", v119);
                v116 = v163;
                -[SAFrameIterator setNumKernelFrames:](v95, "setNumKernelFrames:", *(unsigned int *)(v163 + 4));
              }
              v169 = 0;
              -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:](v89, v95, &v169);
              v124 = objc_claimAutoreleasedReturnValue();
              v162 = v169;
              v164 = (void *)v124;
              +[SAThreadStateMicrostackshot stateWithMicrostackshot:thread:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:machTimebase:](SAThreadStateMicrostackshot, "stateWithMicrostackshot:thread:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:machTimebase:", v18, v116, obja, obja, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL, v124, v162, 0, *(_QWORD *)(a1 + 184));
              v125 = objc_claimAutoreleasedReturnValue();
              v126 = (id *)v125;
              if (v154 != -1)
              {
                if (!v125)
                {
LABEL_214:
                  v127 = (uint64_t)__srca;
                  if (__srca)
                  {
                    objc_msgSend(__srca[1], "addObject:", v125);
                    v127 = objc_msgSend(__srca[1], "count") - 1;
                  }
                  if (v157)
                  {
                    objc_msgSend((id)v89, "dispatchQueues");
                    v128 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *v157);
                    v129 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v128, "objectForKeyedSubscript:", v129);
                    v130 = (_BYTE *)objc_claimAutoreleasedReturnValue();

                    if (!v130)
                    {
                      +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SADispatchQueue, *v157);
                      v130 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                      -[SATask addDispatchQueue:](v89, v130);
                    }
                    +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, __srca, v127);
                    v131 = (void *)objc_claimAutoreleasedReturnValue();
                    if (v130)
                    {
                      if (v130[24])
                        v132 = 0;
                      else
                        v132 = v130 + 24;
                      -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v130, v131, v132);
                    }

                  }
                  if (v144)
                  {
                    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", -1);
                    v133 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend((id)v89, "swiftTasks");
                    v134 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v134, "objectForKeyedSubscript:", v133);
                    v135 = (void *)objc_claimAutoreleasedReturnValue();

                    if (!v135)
                    {
                      +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, -1);
                      v135 = (void *)objc_claimAutoreleasedReturnValue();
                      -[SATask addSwiftTask:](v89, v135);
                    }
                    if (v126)
                      objc_storeWeak(v126 + 15, v135);
                    +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, __srca, v127);
                    v136 = (void *)objc_claimAutoreleasedReturnValue();
                    if (v135)
                      -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v135, v136, 0);

                  }
                  else if (v126)
                  {
                    objc_storeWeak(v126 + 15, 0);
                  }
                  if (__basea)
                    free(__basea);

                  v55 = obja;
                  goto LABEL_238;
                }
                *(_DWORD *)(v125 + 28) = v154;
              }
              if (locationa != -1 && v125)
                *(_DWORD *)(v125 + 32) = locationa;
              goto LABEL_214;
            }
            -[SASampleStore addressTranslationsForPid:](a1, objc_msgSend((id)v89, "pid"));
            v97 = (void *)objc_claimAutoreleasedReturnValue();
            -[SAFrameIterator setAddressTranslations:](v95, "setAddressTranslations:", v97);
          }
          else
          {
            -[SAFrameIterator setKernelBinaryLoadInfos:](v95, "setKernelBinaryLoadInfos:", v97);
          }

          goto LABEL_178;
        }
      }
      else
      {
        ++*(_QWORD *)(a1 + 280);
        v64 |= 8uLL;
      }
      -[SAMicrostackshotStatistics addMicro:task:thread:size:errors:](v16, v18, v18 + 27, v163, v22, v64);
LABEL_238:

      goto LABEL_6;
    }
    v49 = *__error();
    _sa_logt();
    v50 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v50, OS_LOG_TYPE_ERROR, "Microstackshot buffer doesn't contain thread_snapshot after task_snapshot", buf, 2u);
    }

    *__error() = v49;
    v51 = v20 - 1;
    if (v20 - 1 >= 5)
    {
      v52 = 0;
      while (*(_DWORD *)(v18 + 1 + v52) != 835010577)
      {
        if (v20 - 5 == ++v52)
          goto LABEL_74;
      }
      v51 = v52;
    }
LABEL_74:
    v22 = v51 + 1;
    v32 = *__error();
    _sa_logt();
    v53 = objc_claimAutoreleasedReturnValue();
    v34 = v53;
    if (v22 < v20)
    {
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
        goto LABEL_26;
      *(_DWORD *)buf = 134217984;
      v179 = v22;
      goto LABEL_25;
    }
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v179 = v20;
      goto LABEL_72;
    }
LABEL_28:

    *__error() = v32;
    objc_msgSend(v16, "setBytes_not_microstackshots:", objc_msgSend(v16, "bytes_not_microstackshots") + v20);
    v22 = -1;
    goto LABEL_6;
  }
LABEL_5:
  v22 = 0;
LABEL_6:
  objc_autoreleasePoolPop(context);
LABEL_7:

  return v22;
}

- (int64_t)addMicrostackshotsFromData:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8 statistics:(id)a9
{
  id v16;
  id v17;
  unint64_t v18;
  id v19;
  id v20;
  void *v21;
  int64_t v22;
  unint64_t v23;
  BOOL v24;

  v16 = a3;
  v17 = a9;
  v18 = 0;
  if (objc_msgSend(v16, "length"))
  {
    while (1)
    {
      v19 = objc_alloc(MEMORY[0x1E0C99D50]);
      v20 = objc_retainAutorelease(v16);
      v21 = (void *)objc_msgSend(v19, "initWithBytesNoCopy:length:freeWhenDone:", objc_msgSend(v20, "bytes") + v18, objc_msgSend(v20, "length") - v18, 0);
      v22 = -[SASampleStore _addMicrostackshotFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:]((uint64_t)self, v21, a4, a7, a8, v17, a5, a6);
      v23 = v22;
      if (v22 <= 0)
        break;
      v18 += v22;

      if (v18 >= objc_msgSend(v20, "length"))
        goto LABEL_10;
    }

    if (v23)
      v24 = v18 == 0;
    else
      v24 = 0;
    if (v24)
      v18 = v23;
  }
LABEL_10:

  return v18;
}

uint64_t __100__SASampleStore__addMicrostackshotFromData_ofTypes_inTimeRangeStart_end_onlyPid_onlyTid_statistics___block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int v3;

  if (*a3 <= *a2)
    v3 = 0;
  else
    v3 = -1;
  if (*a3 < *a2)
    return 1;
  else
    return v3;
}

- (void)addUserCallstack:(unint64_t *)a3 numUserFrames:(unsigned int)a4 swiftAsyncCallstack:(unint64_t *)a5 numSwiftAsyncFrames:(unsigned int)a6 swiftAsyncStartIndex:(unsigned int)a7 kernelCallstack:(unint64_t *)a8 numKernelFrames:(unsigned int)a9 uniquePid:(unint64_t)a10 pid:(int)a11 tid:(unint64_t)a12 timestamp:(id)a13
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  LODWORD(v16) = a11;
  LODWORD(v15) = 0;
  LODWORD(v14) = 0;
  LODWORD(v13) = a9;
  -[SASampleStore addUserCallstack:numUserFrames:swiftAsyncCallstack:numSwiftAsyncFrames:swiftAsyncStartIndex:kernelCallstack:numKernelFrames:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:uniquePid:pid:processName:tid:timestamp:sharedCache:](self, "addUserCallstack:numUserFrames:swiftAsyncCallstack:numSwiftAsyncFrames:swiftAsyncStartIndex:kernelCallstack:numKernelFrames:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:uniquePid:pid:processName:tid:timestamp:sharedCache:", a3, *(_QWORD *)&a4, a5, *(_QWORD *)&a6, *(_QWORD *)&a7, a8, v13, 0, v14, 0, v15, a10, v16, 0, a12, a13,
    0);
}

- (void)addUserCallstack:(unint64_t *)a3 numUserFrames:(unsigned int)a4 swiftAsyncCallstack:(unint64_t *)a5 numSwiftAsyncFrames:(unsigned int)a6 swiftAsyncStartIndex:(unsigned int)a7 kernelCallstack:(unint64_t *)a8 numKernelFrames:(unsigned int)a9 loadInfos:(const dyld_uuid_info_64 *)a10 numLoadInfos:(unsigned int)a11 textExecLoadInfos:(const dyld_uuid_info_64 *)a12 numTextExecLoadInfos:(unsigned int)a13 uniquePid:(unint64_t)a14 pid:(int)a15 processName:(id)a16 tid:(unint64_t)a17 timestamp:(id)a18 sharedCache:(id)a19
{
  uint64_t v19;
  uint64_t v20;
  id v22;
  uint64_t v23;
  FILE **v24;
  int v25;
  NSObject *v26;
  int v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  _BYTE *v31;
  void *v32;
  void *v33;
  id *v34;
  SAFrameIterator *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  id v42;
  void *v43;
  uint64_t v44;
  id *v45;
  const char *v46;
  id *v47;
  SEL v48;
  SEL v49;
  uint64_t v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v61;
  void *v62;
  void *v63;
  id v64;
  void *v65;
  id v66;
  id v67;
  id v68;
  uint8_t v69[16];
  uint8_t v70[16];
  uint8_t buf[16];

  v19 = *(_QWORD *)&a6;
  v20 = *(_QWORD *)&a4;
  v22 = a16;
  v67 = a18;
  v66 = a19;
  v23 = MEMORY[0x1BCCCC288]();
  self->_dataSource |= 0x10uLL;
  v65 = (void *)v23;
  if ((self->_dataGatheringOptions & 1) != 0)
  {
    if (!*(_QWORD *)&self->_arch)
      -[SASampleStore gatherMachineArchitecture](self, "gatherMachineArchitecture");
    if (!self->_machTimebase.numer || !self->_machTimebase.denom)
      mach_timebase_info(&self->_machTimebase);
    if (!self->_hwPageSize || !self->_vmPageSize)
    {
      -[SASampleStore gatherHWPageSize]((int *)self);
      -[SASampleStore gatherVMPageSize]((int *)self);
    }
  }
  else if (!self->_reportedMissingMachineInfoForCustomCallstacks)
  {
    v24 = (FILE **)MEMORY[0x1E0C80C10];
    if (!*(_QWORD *)&self->_arch)
    {
      v25 = *__error();
      _sa_logt();
      v26 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B9BE0000, v26, OS_LOG_TYPE_DEFAULT, "WARNING: Machine architecture unknown, task architectures will be unknown", buf, 2u);
      }

      *__error() = v25;
      fwrite("Machine architecture unknown, task architectures will be unknown\n", 0x41uLL, 1uLL, *v24);
      self->_reportedMissingMachineInfoForCustomCallstacks = 1;
    }
    if (!self->_machTimebase.numer || !self->_machTimebase.denom)
    {
      v27 = *__error();
      _sa_logt();
      v28 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v70 = 0;
        _os_log_impl(&dword_1B9BE0000, v28, OS_LOG_TYPE_DEFAULT, "WARNING: Mach timebase unknown, cpu times will be unknown", v70, 2u);
      }

      *__error() = v27;
      fwrite("Mach timebase unknown, cpu times will be unknown\n", 0x31uLL, 1uLL, *v24);
      self->_reportedMissingMachineInfoForCustomCallstacks = 1;
    }
    if (!self->_hwPageSize || !self->_vmPageSize)
    {
      v29 = *__error();
      _sa_logt();
      v30 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v69 = 0;
        _os_log_impl(&dword_1B9BE0000, v30, OS_LOG_TYPE_DEFAULT, "WARNING: Page sizes unknown, task footprints will be unknown", v69, 2u);
      }

      *__error() = v29;
      fwrite("Page sizes unknown, task footprints will be unknown\n", 0x34uLL, 1uLL, *v24);
      self->_reportedMissingMachineInfoForCustomCallstacks = 1;
    }
  }
  if (!self->_startTime)
    objc_storeStrong((id *)&self->_startTime, a18);
  objc_storeStrong((id *)&self->_endTime, a18);
  ++self->_numSamples;
  v64 = objc_retainAutorelease(v22);
  -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](self, a15, a14, (char *)objc_msgSend(v64, "UTF8String"), 0, a10, a11, 0, a12, a13, 0, 0, v67, v66, 0);
  v31 = (_BYTE *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v31, "threads");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a17);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v32, "objectForKeyedSubscript:", v33);
  v34 = (id *)objc_claimAutoreleasedReturnValue();

  if (!v34)
  {
    +[SAThread threadWithId:]((uint64_t)SAThread, a17);
    v34 = (id *)objc_claimAutoreleasedReturnValue();
    -[SATask addThread:]((uint64_t)v31, v34);
  }
  v35 = objc_alloc_init(SAFrameIterator);
  -[SAFrameIterator setBacktracer:](v35, "setBacktracer:", 0);
  objc_msgSend(v31, "binaryLoadInfos");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  if (a15)
  {
    -[SAFrameIterator setUserBinaryLoadInfos:](v35, "setUserBinaryLoadInfos:", v36);

    if (v31)
      v37 = v31[73] & 1;
    else
      v37 = 0;
    -[SAFrameIterator setAssumeUserBinaryLoadInfosContainMainBinary:](v35, "setAssumeUserBinaryLoadInfosContainMainBinary:", v37);
    objc_msgSend(v31, "sharedCache");
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    -[SAFrameIterator setSharedCache:](v35, "setSharedCache:", v38);

    -[SASampleStore lastTaskWithPid:](self, 0);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v39)
    {
      if (a14 == -1)
        v40 = -1;
      else
        v40 = 0;
      +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v40, 0, 0);
      v39 = (void *)objc_claimAutoreleasedReturnValue();
      -[SASampleStore addTask:]((uint64_t)self, v39);
    }
  }
  else
  {
    -[SAFrameIterator setKernelBinaryLoadInfos:](v35, "setKernelBinaryLoadInfos:", v36);

    v39 = 0;
  }
  if ((_DWORD)v20)
  {
    -[SAFrameIterator setUserFrames:](v35, "setUserFrames:", malloc_type_malloc(8 * v20, 0x100004000313F17uLL));
    memmove(-[SAFrameIterator userFrames](v35, "userFrames"), a3, 8 * v20);
    -[SAFrameIterator setNumUserFrames:](v35, "setNumUserFrames:", v20);
  }
  if ((_DWORD)v19)
  {
    -[SAFrameIterator setSwiftAsyncFrames:](v35, "setSwiftAsyncFrames:", malloc_type_malloc(8 * v19, 0x100004000313F17uLL));
    memmove(-[SAFrameIterator swiftAsyncFrames](v35, "swiftAsyncFrames"), a5, 8 * v19);
    -[SAFrameIterator setNumSwiftAsyncFrames:](v35, "setNumSwiftAsyncFrames:", v19);
    -[SAFrameIterator setSwiftAsyncStitchIndex:](v35, "setSwiftAsyncStitchIndex:", a7);
  }
  if (a9)
  {
    -[SAFrameIterator setKernelFrames:](v35, "setKernelFrames:", malloc_type_malloc(8 * a9, 0x100004000313F17uLL));
    memmove(-[SAFrameIterator kernelFrames](v35, "kernelFrames"), a8, 8 * a9);
    -[SAFrameIterator setNumKernelFrames:](v35, "setNumKernelFrames:", a9);
  }
  if (a15)
  {
    v68 = 0;
    -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v31, v35, &v68);
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    v42 = v68;
  }
  else
  {
    v42 = 0;
    v41 = 0;
  }
  -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v39, v35, 0);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  if ((_DWORD)v19)
    v44 = -1;
  else
    v44 = 0;
  +[SAThreadState stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:](SAThreadState, "stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:", v67, v67, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL);
  v45 = (id *)objc_claimAutoreleasedReturnValue();
  v47 = v45;
  if (v45)
  {
    objc_setProperty_atomic(v45, v46, v41, 64);
    objc_setProperty_atomic(v47, v48, v42, 72);
    objc_setProperty_atomic(v47, v49, v43, 80);
  }
  v63 = v39;
  if (v34)
  {
    objc_msgSend(v34[1], "addObject:", v47);
    v50 = objc_msgSend(v34[1], "count") - 1;
    if ((_DWORD)v19)
    {
LABEL_54:
      v61 = v42;
      v62 = v41;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v44);
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v31, "swiftTasks");
      v52 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v52, "objectForKeyedSubscript:", v51);
      v53 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v53)
      {
        +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, v44);
        v53 = (void *)objc_claimAutoreleasedReturnValue();
        -[SATask addSwiftTask:]((uint64_t)v31, v53);
      }
      if (v47)
        objc_storeWeak(v47 + 15, v53);
      +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, v34, v50);
      v54 = (void *)objc_claimAutoreleasedReturnValue();
      v42 = v61;
      if (v53)
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v53, v54, 0);

      v56 = v64;
      v55 = v65;
      v41 = v62;
      goto LABEL_64;
    }
  }
  else
  {
    v50 = 0;
    if ((_DWORD)v19)
      goto LABEL_54;
  }
  v56 = v64;
  v55 = v65;
  if (v47)
    objc_storeWeak(v47 + 15, 0);
LABEL_64:

  objc_autoreleasePoolPop(v55);
}

- (BOOL)findCpuSignalHandlerStackLeafKernelFrame
{
  BOOL v2;
  uint64_t v4;
  void *v5;
  const char *v6;
  id Property;
  SAFrame **p_cpuSignalHandlerStackLeafKernelFrame;
  id v9;
  BOOL v10;
  char *v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *v16;
  id v17;
  int v19;
  NSObject *v20;
  const char *ClassName;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[5];
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  void (*v34)(uint64_t);
  id v35;
  uint8_t buf[4];
  const char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (!self->_cpuSignalHandlerStackLeafKernelFrame)
  {
    -[SASampleStore lastTaskWithPid:](self, 0);
    v4 = objc_claimAutoreleasedReturnValue();
    v5 = (void *)v4;
    if (v4)
    {
      v30 = 0;
      v31 = &v30;
      v32 = 0x3032000000;
      v33 = __Block_byref_object_copy__0;
      v34 = __Block_byref_object_dispose__0;
      v35 = 0;
      v29[0] = MEMORY[0x1E0C809B0];
      v29[1] = 3221225472;
      v29[2] = __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke;
      v29[3] = &unk_1E7147838;
      v29[4] = &v30;
      -[SATask enumerateFrames:](v4, v29);
      Property = (id)v31[5];
      if (Property)
      {
        p_cpuSignalHandlerStackLeafKernelFrame = &self->_cpuSignalHandlerStackLeafKernelFrame;
LABEL_6:
        Property = objc_getProperty(Property, v6, 40, 1);
        while (1)
        {
          v9 = Property;
          v10 = v9 == 0;

          v11 = (char *)v31[5];
          if (v10)
            break;
          if (v11)
            v12 = objc_getProperty((id)v31[5], v11, 40, 1);
          else
            v12 = 0;
          v13 = v12;
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            v14 = v13;
            objc_msgSend(v14, "anyObject");
            v15 = objc_claimAutoreleasedReturnValue();
            v16 = (void *)v31[5];
            v31[5] = v15;

          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              v19 = *__error();
              _sa_logt();
              v20 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                ClassName = object_getClassName(v13);
                *(_DWORD *)buf = 136315138;
                v37 = ClassName;
                _os_log_error_impl(&dword_1B9BE0000, v20, OS_LOG_TYPE_ERROR, "child is %s", buf, 0xCu);
              }

              *__error() = v19;
              v22 = object_getClassName(v13);
              _SASetCrashLogMessage(7591, "child is %s", v23, v24, v25, v26, v27, v28, v22);
              _os_crash();
              __break(1u);
            }
            v17 = v13;
            v14 = (id)v31[5];
            v31[5] = (uint64_t)v17;
          }

          Property = (id)v31[5];
          if (Property)
            goto LABEL_6;
        }
        objc_storeStrong((id *)p_cpuSignalHandlerStackLeafKernelFrame, v11);
        _Block_object_dispose(&v30, 8);

        v2 = 1;
        goto LABEL_20;
      }
      _Block_object_dispose(&v30, 8);

    }
    v2 = 0;
LABEL_20:

    return v2;
  }
  return 1;
}

void __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  void *v7;
  uint64_t v8;
  id v9;
  _QWORD v10[4];
  id v11;
  uint64_t v12;
  uint64_t v13;

  v6 = a2;
  objc_msgSend(v6, "instruction");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke_2;
  v10[3] = &unk_1E71471A8;
  v8 = *(_QWORD *)(a1 + 32);
  v11 = v6;
  v12 = v8;
  v13 = a4;
  v9 = v6;
  objc_msgSend(v7, "enumerateSymbols:", v10);

}

void __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke_2(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  int v5;
  void *v6;

  objc_msgSend(a2, "name");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (v3)
  {
    v6 = v3;
    if ((objc_msgSend(v3, "isEqualToString:", CFSTR("cpu_signal_handler")) & 1) != 0
      || (v5 = objc_msgSend(v6, "isEqualToString:", CFSTR("sync_iss_to_iks")), v4 = v6, v5))
    {
      objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(id *)(a1 + 32));
      v4 = v6;
      **(_BYTE **)(a1 + 48) = 1;
    }
  }

}

- (void)symbolicate
{
  SASampleStore *v2;
  uint64_t v3;
  double v4;
  int v5;
  NSObject *v6;
  void *v7;
  unsigned int v8;
  void *v9;
  char v10;
  __int128 v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  void *v17;
  NSMutableArray *idsToUseDsymForUUID;
  char v19;
  id Property;
  id v21;
  id v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  void *v36;
  int v37;
  NSObject *v38;
  char v39;
  int v40;
  NSObject *v41;
  NSObject *v42;
  double v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  double v48;
  void *v49;
  void *v50;
  void *v51;
  double v52;
  void *v53;
  void *v54;
  void *v55;
  int v56;
  NSObject *v57;
  uint64_t v58;
  double v59;
  __int128 v60;
  id v61;
  unsigned int v62;
  void *v63;
  SASampleStore *v64;
  char v65;
  uint64_t v66;
  NSMutableArray *obj;
  NSMutableArray *v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  _QWORD v72[5];
  _QWORD v73[5];
  id v74;
  char v75;
  _QWORD v76[5];
  id v77;
  char v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  _QWORD v87[4];
  id v88;
  SASampleStore *v89;
  uint8_t buf[4];
  double v91;
  __int16 v92;
  unsigned int v93;
  __int16 v94;
  void *v95;
  _BYTE v96[128];
  _BYTE v97[128];
  uint64_t v98;

  v2 = self;
  v98 = *MEMORY[0x1E0C80C00];
  if ((self->_dataGatheringOptions & 0x78) == 0 && !self->_idsToUseDsymForUUID && !self->_namesToUseDsymForUUID)
    return;
  v3 = mach_absolute_time();
  v4 = SASecondsFromMachTimeUsingLiveTimebase(v3);
  v5 = *__error();
  _sa_logt();
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B9BE0000, v6, OS_LOG_TYPE_INFO, "Symbolication starting", buf, 2u);
  }

  v7 = 0;
  v8 = 0;
  *__error() = v5;
  v66 = v2->_dataGatheringOptions & 8;
  v9 = (void *)((v2->_dataGatheringOptions >> 3) & 1);
  v10 = 1;
  *(_QWORD *)&v11 = 134218498;
  v60 = v11;
  v64 = v2;
  v65 = (char)v9;
  do
  {
    v62 = v8;
    if ((v10 & 1) == 0)
      break;
    v63 = v7;
    v12 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 2000);
    v13 = MEMORY[0x1E0C809B0];
    v87[0] = MEMORY[0x1E0C809B0];
    v87[1] = 3221225472;
    v87[2] = __28__SASampleStore_symbolicate__block_invoke;
    v87[3] = &unk_1E71471D0;
    v61 = v12;
    v88 = v61;
    v89 = v2;
    v70 = (void *)MEMORY[0x1BCCCC450](v87);
    v83 = 0u;
    v84 = 0u;
    v85 = 0u;
    v86 = 0u;
    obj = v2->_exclaves;
    v14 = v66;
    v71 = -[NSMutableArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v83, v97, 16);
    if (!v71)
      goto LABEL_42;
    v69 = *(_QWORD *)v84;
    do
    {
      v16 = 0;
      do
      {
        if (*(_QWORD *)v84 != v69)
          objc_enumerationMutation(obj);
        v17 = *(void **)(*((_QWORD *)&v83 + 1) + 8 * v16);
        if (v14)
        {
LABEL_18:
          v19 = 1;
          goto LABEL_19;
        }
        idsToUseDsymForUUID = v2->_idsToUseDsymForUUID;
        if (!idsToUseDsymForUUID && !v2->_namesToUseDsymForUUID)
          goto LABEL_35;
        if ((-[NSMutableArray containsObject:](idsToUseDsymForUUID, "containsObject:", &unk_1E71677C8, v60) & 1) != 0
          || (-[NSMutableArray containsObject:](v2->_namesToUseDsymForUUID, "containsObject:", CFSTR("exclaves")) & 1) != 0)
        {
          goto LABEL_18;
        }
        if (v2->_namesToUseDsymForUUID)
        {
          -[SASampleStore lastTaskWithPid:](v2, 0);
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          v19 = (char)v9;
          if (v23)
          {
            v81 = 0u;
            v82 = 0u;
            v79 = 0u;
            v80 = 0u;
            v68 = v2->_namesToUseDsymForUUID;
            v24 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v68, "countByEnumeratingWithState:objects:count:", &v79, v96, 16);
            v19 = (char)v9;
            if (v24)
            {
              v25 = v24;
              v26 = *(_QWORD *)v80;
              while (2)
              {
                for (i = 0; i != v25; ++i)
                {
                  if (*(_QWORD *)v80 != v26)
                    objc_enumerationMutation(v68);
                  v28 = *(_QWORD *)(*((_QWORD *)&v79 + 1) + 8 * i);
                  objc_msgSend(v23, "name");
                  v29 = objc_claimAutoreleasedReturnValue();
                  if (v29)
                  {
                    v30 = (void *)v29;
                    objc_msgSend(v23, "name");
                    v31 = (void *)objc_claimAutoreleasedReturnValue();
                    v19 = 1;
                    v32 = objc_msgSend(v31, "rangeOfString:options:", v28, 1);

                    if (v32 != 0x7FFFFFFFFFFFFFFFLL)
                    {
                      v2 = v64;
                      LOBYTE(v9) = v65;
                      goto LABEL_37;
                    }
                  }
                }
                v25 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v68, "countByEnumeratingWithState:objects:count:", &v79, v96, 16);
                if (v25)
                  continue;
                break;
              }
              v2 = v64;
              LOBYTE(v9) = v65;
              v19 = v65;
LABEL_37:
              v14 = v66;
              v13 = MEMORY[0x1E0C809B0];
            }

          }
        }
        else
        {
LABEL_35:
          v19 = 0;
        }
LABEL_19:
        if (v17)
          Property = objc_getProperty(v17, v15, 40, 1);
        else
          Property = 0;
        v21 = Property;
        v76[0] = v13;
        v76[1] = 3221225472;
        v76[2] = __28__SASampleStore_symbolicate__block_invoke_341;
        v76[3] = &unk_1E71471F8;
        v22 = v70;
        v76[4] = v2;
        v77 = v22;
        v78 = v19;
        +[SAFrame enumerateFrameTree:block:]((uint64_t)SAFrame, v21, v76);

        ++v16;
      }
      while (v16 != v71);
      v33 = -[NSMutableArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v83, v97, 16);
      v71 = v33;
    }
    while (v33);
LABEL_42:
    v34 = v13;
    v8 = v62 + 1;

    v73[0] = v34;
    v73[1] = 3221225472;
    v73[2] = __28__SASampleStore_symbolicate__block_invoke_2;
    v73[3] = &unk_1E7147270;
    v73[4] = v2;
    v75 = (char)v9;
    v35 = v70;
    v74 = v35;
    -[SASampleStore enumerateTasks:](v2, "enumerateTasks:", v73);
    v72[0] = v34;
    v72[1] = 3221225472;
    v72[2] = __28__SASampleStore_symbolicate__block_invoke_5;
    v72[3] = &unk_1E71472B8;
    v72[4] = v2;
    v36 = v61;
    objc_msgSend(v61, "enumerateKeysAndObjectsUsingBlock:", v72);
    -[SASampleStore fixupAllFrames]((id *)&v2->super.isa);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v9, "count"))
    {
      if (v63 && objc_msgSend(v63, "isEqualToSet:", v9))
      {
        v37 = *__error();
        _sa_logt();
        v38 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
        {
          v52 = COERCE_DOUBLE(objc_msgSend(v9, "count"));
          objc_msgSend(v9, "anyObject");
          v53 = (void *)objc_claimAutoreleasedReturnValue();
          +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v53, 0);
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v54, "debugDescription");
          v55 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = v60;
          v91 = v52;
          v92 = 1024;
          v93 = v62 + 1;
          v94 = 2112;
          v95 = v55;
          _os_log_fault_impl(&dword_1B9BE0000, v38, OS_LOG_TYPE_FAULT, "Symbolication loop has same set of UUIDs to symbolicate! %lu binaries need more symbolication after iteration %d (including %@)", buf, 0x1Cu);

          v2 = v64;
          v36 = v61;

        }
        v39 = 0;
        v10 = 0;
        *__error() = v37;
      }
      else
      {
        v40 = *__error();
        _sa_logt();
        v41 = objc_claimAutoreleasedReturnValue();
        v42 = v41;
        if (v62 < 0x63)
        {
          if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
          {
            v43 = COERCE_DOUBLE(objc_msgSend(v9, "count"));
            objc_msgSend(v9, "anyObject");
            v44 = (void *)objc_claimAutoreleasedReturnValue();
            +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v44, 0);
            v45 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v45, "debugDescription");
            v46 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = v60;
            v91 = v43;
            v92 = 1024;
            v93 = v62 + 1;
            v94 = 2112;
            v95 = v46;
            _os_log_impl(&dword_1B9BE0000, v42, OS_LOG_TYPE_INFO, "%lu binaries need more symbolication after iteration %d (including %@)", buf, 0x1Cu);

            v2 = v64;
          }

          *__error() = v40;
          v47 = v9;

          v39 = 1;
          v63 = v47;
          v10 = 1;
        }
        else
        {
          if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
          {
            v48 = COERCE_DOUBLE(objc_msgSend(v9, "count"));
            objc_msgSend(v9, "anyObject");
            v49 = (void *)objc_claimAutoreleasedReturnValue();
            +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v49, 0);
            v50 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v50, "debugDescription");
            v51 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = v60;
            v91 = v48;
            v92 = 1024;
            v93 = v62 + 1;
            v94 = 2112;
            v95 = v51;
            _os_log_fault_impl(&dword_1B9BE0000, v42, OS_LOG_TYPE_FAULT, "Hit symbolication loop count limit! %lu binaries need more symbolication after iteration %d (including %@)", buf, 0x1Cu);

            v2 = v64;
          }

          v39 = 0;
          v10 = 0;
          *__error() = v40;
        }
        v36 = v61;
      }
    }
    else
    {
      v10 = 0;
      v39 = 1;
    }

    v7 = v63;
    LOBYTE(v9) = v65;
  }
  while ((v39 & 1) != 0);
  v56 = *__error();
  _sa_logt();
  v57 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
  {
    v58 = mach_absolute_time();
    v59 = SASecondsFromMachTimeUsingLiveTimebase(v58);
    *(_DWORD *)buf = 134218240;
    v91 = v59 - v4;
    v92 = 1024;
    v93 = v8;
    _os_log_impl(&dword_1B9BE0000, v57, OS_LOG_TYPE_INFO, "Symbolication done (took %.3f seconds, %d iterations)", buf, 0x12u);
  }

  *__error() = v56;
}

void __28__SASampleStore_symbolicate__block_invoke(uint64_t a1, void *a2, int a3, _BOOL4 a4, int a5)
{
  id v9;
  uint64_t v10;
  SAUUIDToSymbolicate *v11;
  id v12;
  id v13;
  uint64_t v14;
  NSMutableArray *binaries;
  id v16;

  v9 = a2;
  objc_msgSend(v9, "uuid");
  v16 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:");
  v10 = objc_claimAutoreleasedReturnValue();
  if (!v10)
  {
    v13 = v9;
    objc_opt_self();
    v11 = objc_alloc_init(SAUUIDToSymbolicate);
    v14 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithObjects:", v13, 0);

    binaries = v11->_binaries;
    v11->_binaries = (NSMutableArray *)v14;

    v11->_livePid = -1;
    v11->_dataGatheringOptions = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 408);
    v11->_livePid = a3;
    v11->_isInExclave = a4;
    objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", v11, v16);
    goto LABEL_11;
  }
  v11 = (SAUUIDToSymbolicate *)v10;
  v12 = v9;
  if ((-[NSMutableArray containsObject:](v11->_binaries, "containsObject:", v12) & 1) == 0)
    -[NSMutableArray addObject:](v11->_binaries, "addObject:", v12);

  if (a3 != -1 && v11->_livePid == -1)
  {
    v11->_livePid = a3;
    if (!a4)
      goto LABEL_11;
    goto LABEL_10;
  }
  if (a4)
LABEL_10:
    v11->_isInExclave = 1;
LABEL_11:
  if (a5)
    v11->_dataGatheringOptions |= 0x48uLL;

}

void __28__SASampleStore_symbolicate__block_invoke_341(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;

  objc_msgSend(a2, "instruction");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "binary");
  v5 = (id)objc_claimAutoreleasedReturnValue();

  v4 = v5;
  if (v5)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    v4 = v5;
  }

}

void __28__SASampleStore_symbolicate__block_invoke_2(uint64_t a1, void *a2)
{
  void *v2;
  id v4;
  void *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  void *v10;
  id v11;
  uint64_t v12;
  int v13;
  void *v14;
  void *v15;
  void *v16;
  char v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  int v29;
  _QWORD v30[5];
  id v31;
  char v32;
  _QWORD v33[4];
  id v34;
  int v35;
  char v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = v4;
  if ((~*(_DWORD *)(*(_QWORD *)(a1 + 32) + 408) & 0x402) != 0 || kill(objc_msgSend(v4, "pid"), 0))
    v6 = -1;
  else
    v6 = objc_msgSend(v5, "pid");
  if (*(_BYTE *)(a1 + 48))
    goto LABEL_5;
  v12 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v12 + 264))
  {
    v13 = objc_msgSend(v5, "pid");
    if (v13 == -1)
    {
      if (objc_msgSend(v5, "uniquePid") == -1)
        goto LABEL_25;
    }
    else
    {
      v14 = *(void **)(*(_QWORD *)(a1 + 32) + 264);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(v5, "pid"));
      v2 = (void *)objc_claimAutoreleasedReturnValue();
      if (objc_msgSend(v14, "containsObject:", v2))
      {

LABEL_5:
        v7 = 1;
        goto LABEL_6;
      }
      if (objc_msgSend(v5, "uniquePid") == -1)
      {

        goto LABEL_25;
      }
    }
    v15 = *(void **)(*(_QWORD *)(a1 + 32) + 264);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v5, "uniquePid"));
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v15, "containsObject:", v16);

    if (v13 != -1)
    if ((v17 & 1) != 0)
      goto LABEL_5;
  }
  else if (!*(_QWORD *)(v12 + 256))
  {
    goto LABEL_37;
  }
LABEL_25:
  v18 = *(void **)(*(_QWORD *)(a1 + 32) + 256);
  if (!v18)
  {
LABEL_37:
    v7 = 0;
    goto LABEL_6;
  }
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v19 = v18;
  v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v37, v41, 16);
  if (v20)
  {
    v21 = v20;
    v29 = v6;
    v22 = *(_QWORD *)v38;
LABEL_28:
    v23 = 0;
    while (1)
    {
      if (*(_QWORD *)v38 != v22)
        objc_enumerationMutation(v19);
      v24 = *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * v23);
      objc_msgSend(v5, "name");
      v25 = objc_claimAutoreleasedReturnValue();
      if (v25)
      {
        v26 = (void *)v25;
        objc_msgSend(v5, "name");
        v27 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = 1;
        v28 = objc_msgSend(v27, "rangeOfString:options:", v24, 1);

        if (v28 != 0x7FFFFFFFFFFFFFFFLL)
          break;
      }
      if (v21 == ++v23)
      {
        v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v37, v41, 16);
        if (v21)
          goto LABEL_28;
        v7 = 0;
        break;
      }
    }
    v6 = v29;
  }
  else
  {
    v7 = 0;
  }

LABEL_6:
  v8 = MEMORY[0x1E0C809B0];
  v33[0] = MEMORY[0x1E0C809B0];
  v33[1] = 3221225472;
  v33[2] = __28__SASampleStore_symbolicate__block_invoke_3;
  v33[3] = &unk_1E7147220;
  v34 = *(id *)(a1 + 40);
  v35 = v6;
  v36 = v7;
  -[SATask enumerateFrames:]((uint64_t)v5, v33);
  v9 = objc_msgSend(v5, "pid");
  if (v7 && v9)
  {
    objc_msgSend(v5, "threads");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v30[0] = v8;
    v30[1] = 3221225472;
    v30[2] = __28__SASampleStore_symbolicate__block_invoke_4;
    v30[3] = &unk_1E7147248;
    v11 = *(id *)(a1 + 40);
    v30[4] = *(_QWORD *)(a1 + 32);
    v31 = v11;
    v32 = 1;
    objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", v30);

  }
}

void __28__SASampleStore_symbolicate__block_invoke_3(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;

  objc_msgSend(a2, "instruction");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "binary");
  v5 = (id)objc_claimAutoreleasedReturnValue();

  v4 = v5;
  if (v5)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    v4 = v5;
  }

}

void __28__SASampleStore_symbolicate__block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  const char *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;
  _QWORD *v13;
  id Property;
  const char *v15;
  void *v16;
  id v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  id obj;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];
  _BYTE v42[128];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  objc_msgSend(a3, "threadStates");
  obj = (id)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
  if (v4)
  {
    v5 = v4;
    v32 = *(_QWORD *)v38;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v38 != v32)
          objc_enumerationMutation(obj);
        v7 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * v6);
        objc_msgSend(v7, "leafKernelFrame");
        v9 = (_QWORD *)objc_claimAutoreleasedReturnValue();
        if (v9)
        {
          do
          {
            objc_msgSend(v9, "instruction");
            v10 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v10, "binary");
            v11 = (void *)objc_claimAutoreleasedReturnValue();

            if (v11)
              (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

            v12 = (void *)v9[4];
            v13 = v12;

            v9 = v13;
          }
          while (v12);
        }
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        if (v7)
        {
          Property = objc_getProperty(v7, v8, 176, 1);
          v16 = Property;
          if (Property)
            Property = objc_getProperty(Property, v15, 16, 1);
        }
        else
        {
          v16 = 0;
          Property = 0;
        }
        v17 = Property;

        v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
        if (v18)
        {
          v20 = v18;
          v21 = *(_QWORD *)v34;
          do
          {
            v22 = 0;
            do
            {
              if (*(_QWORD *)v34 != v21)
                objc_enumerationMutation(v17);
              v23 = *(void **)(*((_QWORD *)&v33 + 1) + 8 * v22);
              if (v23)
              {
                v24 = objc_getProperty(v23, v19, 16, 1);
                if (v24)
                {
                  do
                  {
                    objc_msgSend(v24, "instruction");
                    v25 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v25, "binary");
                    v26 = (void *)objc_claimAutoreleasedReturnValue();

                    if (v26)
                      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

                    v27 = (void *)v24[4];
                    v28 = v27;

                    v24 = v28;
                  }
                  while (v27);
                }
              }
              ++v22;
            }
            while (v22 != v20);
            v29 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
            v20 = v29;
          }
          while (v29);
        }

        ++v6;
      }
      while (v6 != v5);
      v30 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
      v5 = v30;
    }
    while (v30);
  }

}

void __28__SASampleStore_symbolicate__block_invoke_5(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id Property;
  const char *v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  const char *v18;
  id v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  NSObject *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  Property = a3;
  v8 = Property;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  if (Property)
    Property = objc_getProperty(Property, v7, 16, 1);
  v9 = Property;
  v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v30, v35, 16);
  if (v10)
  {
    v11 = v10;
    v12 = *(_QWORD *)v31;
    do
    {
      v13 = 0;
      do
      {
        if (*(_QWORD *)v31 != v12)
          objc_enumerationMutation(v9);
        if (v8)
        {
          v14 = *((_QWORD *)v8 + 3);
          v15 = *((_DWORD *)v8 + 3);
          v16 = *((_BYTE *)v8 + 8) & 1;
        }
        else
        {
          v15 = 0;
          v14 = 0;
          v16 = 0;
        }
        -[SABinary symbolicateAllInstructionsWithOptions:pid:checkExclave:onlyDsym:additionalCSSymbolicatorFlags:](*(void **)(*((_QWORD *)&v30 + 1) + 8 * v13++), v14, v15, v16, 0, *(_DWORD *)(*(_QWORD *)(a1 + 32) + 328));
      }
      while (v11 != v13);
      v17 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v30, v35, 16);
      v11 = v17;
    }
    while (v17);
  }

  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  if (v8)
    v19 = objc_getProperty(v8, v18, 16, 1);
  else
    v19 = 0;
  v20 = v19;
  v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v26, v34, 16);
  if (v21)
  {
    v22 = v21;
    v23 = *(_QWORD *)v27;
    do
    {
      for (i = 0; i != v22; ++i)
      {
        if (*(_QWORD *)v27 != v23)
          objc_enumerationMutation(v20);
        objc_msgSend(*(id *)(*((_QWORD *)&v26 + 1) + 8 * i), "clearCoreSymbolicationCache", (_QWORD)v26);
      }
      v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v26, v34, 16);
    }
    while (v22);
  }

  +[SABinary dataFillingQueue]();
  v25 = objc_claimAutoreleasedReturnValue();
  dispatch_sync(v25, &__block_literal_global_342);

}

- (void)addAddressTranslations:(uint64_t)a1
{
  id v3;
  uint64_t v4;
  void *v5;
  id v6;
  id v7;
  _QWORD v8[5];

  v3 = a2;
  if (a1)
  {
    v6 = v3;
    if (!*(_QWORD *)(a1 + 304))
    {
      v4 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", objc_msgSend(v3, "count"));
      v5 = *(void **)(a1 + 304);
      *(_QWORD *)(a1 + 304) = v4;

    }
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __40__SASampleStore_addAddressTranslations___block_invoke;
    v8[3] = &unk_1E7147308;
    v8[4] = a1;
    objc_msgSend(v6, "enumerateKeysAndObjectsUsingBlock:", v8, v6);
    v3 = v7;
  }

}

void __40__SASampleStore_addAddressTranslations___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  id v7;
  void *v8;
  uint64_t v9;
  id v10;
  id v11;
  _QWORD v12[4];
  id v13;
  uint64_t v14;
  id v15;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = a3;
  -[SASampleStore addressTranslationsForPid:](v6, objc_msgSend(v5, "intValue"));
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = __40__SASampleStore_addAddressTranslations___block_invoke_2;
  v12[3] = &unk_1E71472E0;
  v9 = *(_QWORD *)(a1 + 32);
  v13 = v8;
  v14 = v9;
  v15 = v5;
  v10 = v5;
  v11 = v8;
  objc_msgSend(v7, "enumerateKeysAndObjectsUsingBlock:", v12);

}

void __40__SASampleStore_addAddressTranslations___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  char v11;
  int v12;
  NSObject *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  int v19;
  void *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  if (!objc_msgSend(v6, "unsignedLongLongValue"))
    goto LABEL_10;
  objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v5);
  v7 = objc_claimAutoreleasedReturnValue();
  if (!v7)
    goto LABEL_9;
  v8 = (void *)v7;
  objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v5);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(v9, "unsignedLongLongValue"))
  {

    goto LABEL_9;
  }
  objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v5);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v10, "isEqual:", v6);

  if ((v11 & 1) != 0)
  {
LABEL_9:
    objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", v6, v5);
    goto LABEL_10;
  }
  v12 = *__error();
  _sa_logt();
  v13 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
  {
    -[SASampleStore lastTaskWithPid:](*(_QWORD **)(a1 + 40), objc_msgSend(*(id *)(a1 + 48), "intValue"));
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "debugDescription");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = objc_msgSend(v5, "unsignedLongLongValue");
    v17 = objc_msgSend(v6, "unsignedLongLongValue");
    objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v5);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v19 = 138413058;
    v20 = v15;
    v21 = 2048;
    v22 = v16;
    v23 = 2048;
    v24 = v17;
    v25 = 2048;
    v26 = objc_msgSend(v18, "unsignedLongLongValue");
    _os_log_fault_impl(&dword_1B9BE0000, v13, OS_LOG_TYPE_FAULT, "%@: libktrace translation 0x%llx -> 0x%llx mismatch with existing translation -> 0x%llx", (uint8_t *)&v19, 0x2Au);

  }
  *__error() = v12;
LABEL_10:

}

void __31__SASampleStore_gatherKextStat__block_invoke()
{
  dispatch_block_t v0;
  qos_class_t v1;
  NSObject *v2;
  dispatch_time_t v3;
  int v4;
  NSObject *v5;
  uint8_t v6[16];

  v0 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, &__block_literal_global_347);
  v1 = qos_class_self();
  dispatch_get_global_queue(v1, 0);
  v2 = objc_claimAutoreleasedReturnValue();
  dispatch_async(v2, v0);

  v3 = dispatch_time(0, 2000000000);
  if (dispatch_block_wait(v0, v3))
  {
    v4 = *__error();
    _sa_logt();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl(&dword_1B9BE0000, v5, OS_LOG_TYPE_DEFAULT, "WARNING: Timed out waiting for kextstat", v6, 2u);
    }

    *__error() = v4;
  }

}

void __31__SASampleStore_gatherKextStat__block_invoke_2()
{
  int v0;
  pid_t v1;
  id v2;
  void *v3;
  _QWORD *v4;
  ssize_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int v10;
  NSObject *v11;
  int v12;
  int *v13;
  char *v14;
  _QWORD block[5];
  int v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  char *v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v16 = -1;
  v21 = xmmword_1E7147368;
  v0 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/sbin/kextstat", "com.apple.kextstat", (char *const *)&v21, 0, 0, 0, &v16, 0, 0, 0, 0);
  if (v0 < 1)
  {
    v10 = *__error();
    _sa_logt();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = *__error();
      v13 = __error();
      v14 = strerror(*v13);
      *(_DWORD *)buf = 67109378;
      v18 = v12;
      v19 = 2080;
      v20 = v14;
      _os_log_debug_impl(&dword_1B9BE0000, v11, OS_LOG_TYPE_DEBUG, "Unable to run kextstat: %d %s", buf, 0x12u);
    }

    *__error() = v10;
  }
  else
  {
    v1 = v0;
    v2 = objc_alloc_init(MEMORY[0x1E0CB37A0]);
    v3 = malloc_type_calloc(0x40uLL, 0x400uLL, 0x1AC36368uLL);
    v4 = (_QWORD *)MEMORY[0x1E0C85AD8];
    v5 = read(v16, v3, *MEMORY[0x1E0C85AD8] - 1);
    if (v5 >= 1)
    {
      v6 = MEMORY[0x1E0C809B0];
      do
      {
        *((_BYTE *)v3 + v5) = 0;
        SANSStringForCString(v3);
        v7 = (void *)objc_claimAutoreleasedReturnValue();
        if (v7)
        {
          objc_msgSend(v2, "appendString:", v7);
        }
        else
        {
          block[0] = v6;
          block[1] = 3221225472;
          block[2] = __31__SASampleStore_gatherKextStat__block_invoke_3;
          block[3] = &__block_descriptor_40_e5_v8__0l;
          block[4] = v3;
          if (qword_1ED1DD578 != -1)
            dispatch_once(&qword_1ED1DD578, block);
        }

        v5 = read(v16, v3, *v4 - 1);
      }
      while (v5 > 0);
    }
    waitpid(v1, 0, 0);
    free(v3);
    if (objc_msgSend(v2, "length"))
    {
      v8 = objc_msgSend(v2, "copy");
      v9 = (void *)qword_1ED1DD568;
      qword_1ED1DD568 = v8;

    }
  }
}

int *__31__SASampleStore_gatherKextStat__block_invoke_3(uint64_t a1)
{
  int v2;
  NSObject *v3;
  int *result;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  _sa_logt();
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = 136315138;
    v7 = v5;
    _os_log_error_impl(&dword_1B9BE0000, v3, OS_LOG_TYPE_ERROR, "Unable to convert kextstat output to NSString: %s", (uint8_t *)&v6, 0xCu);
  }

  result = __error();
  *result = v2;
  return result;
}

- (NSString)machineArchitecture
{
  void *arch;

  arch = (void *)self->_arch;
  if (arch)
  {
    arch = (void *)CSArchitectureGetFamilyName();
    if (arch)
    {
      SANSStringForCString(arch);
      arch = (void *)objc_claimAutoreleasedReturnValue();
    }
  }
  return (NSString *)arch;
}

- (void)setMachineArchitecture:(id)a3
{
  uint64_t ArchitectureForName;
  id v5;

  v5 = objc_retainAutorelease(a3);
  ArchitectureForName = objc_msgSend(v5, "UTF8String");
  if (ArchitectureForName)
  {
    objc_msgSend(objc_retainAutorelease(v5), "UTF8String");
    ArchitectureForName = CSArchitectureGetArchitectureForName();
  }
  self->_arch = (_CSArchitecture)ArchitectureForName;

}

- (void)gatherMachineArchitecture
{
  self->_arch = (_CSArchitecture)MEMORY[0x1BCCCB7F0](self, a2);
}

- (mach_timebase_info)machTimebase
{
  return self->_machTimebase;
}

- (void)setMachTimebase:(mach_timebase_info)a3
{
  self->_machTimebase = a3;
}

intptr_t __36__SASampleStore_gatherHardwareModel__block_invoke_2(uint64_t a1)
{
  const void *v2;
  const void *v3;
  CFTypeID v4;
  void *v5;
  int v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  CFTypeID v11;
  __CFString *v12;
  uint8_t buf[4];
  __CFString *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = (const void *)MGCopyAnswerWithError();
  if (v2)
  {
    v3 = v2;
    v4 = CFGetTypeID(v2);
    if (v4 == CFStringGetTypeID())
    {
      v5 = (void *)qword_1ED1DD580;
      qword_1ED1DD580 = (uint64_t)v3;

    }
    else
    {
      v8 = *__error();
      _sa_logt();
      v9 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        v11 = CFGetTypeID(v3);
        v12 = (__CFString *)CFCopyTypeIDDescription(v11);
        *(_DWORD *)buf = 138412290;
        v14 = v12;
        _os_log_fault_impl(&dword_1B9BE0000, v9, OS_LOG_TYPE_FAULT, "Product type not a string (%@)", buf, 0xCu);

      }
      *__error() = v8;
      CFRelease(v3);
    }
  }
  else
  {
    v6 = *__error();
    _sa_logt();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v14) = 0;
      _os_log_fault_impl(&dword_1B9BE0000, v7, OS_LOG_TYPE_FAULT, "Unable to get product type: %d", buf, 8u);
    }

    *__error() = v6;
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

- (void)_populateFromKtraceMachineInfo:(int)a3 is64bit:
{
  void *v5;
  void *v6;
  void *v7;
  uint64_t active;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  const char *v21;
  void *v22;
  void *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  __int128 v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  NSObject *v33;
  NSObject *v34;
  const char *v35;
  int v36;
  int v37;
  void *v38;
  void *v39;
  const char *v40;
  __int128 v41;
  uint8_t buf[4];
  int v43;
  __int16 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    objc_msgSend((id)a1, "hardwareModel");
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v5)
    {
      v6 = (void *)ktrace_machine_model();
      if (v6)
      {
        SANSStringForCString(v6);
        v7 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)a1, "setHardwareModel:", v7);

      }
    }
    if (!objc_msgSend((id)a1, "numActiveCPUs"))
    {
      active = ktrace_machine_active_cpus();
      if ((_DWORD)active)
        objc_msgSend((id)a1, "setNumActiveCPUs:", active);
    }
    if (!objc_msgSend((id)a1, "hwPageSize"))
    {
      v9 = ktrace_machine_hw_page_size();
      if ((_DWORD)v9)
        objc_msgSend((id)a1, "setHwPageSize:", v9);
    }
    if (!objc_msgSend((id)a1, "vmPageSize"))
    {
      v10 = ktrace_machine_vm_page_size();
      if ((_DWORD)v10)
        objc_msgSend((id)a1, "setVmPageSize:", v10);
    }
    objc_msgSend((id)a1, "osProductName");
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v11)
    {
      v12 = (void *)ktrace_machine_os_name();
      if (v12)
      {
        SANSStringForCString(v12);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)a1, "setOsProductName:", v13);

      }
    }
    objc_msgSend((id)a1, "osProductVersion");
    v14 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v14)
    {
      v15 = (void *)ktrace_machine_os_version();
      if (v15)
      {
        SANSStringForCString(v15);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)a1, "setOsProductVersion:", v16);

      }
    }
    objc_msgSend((id)a1, "osProductVersionExtra");
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v17)
    {
      v18 = (void *)ktrace_machine_os_version_extra();
      if (v18)
      {
        SANSStringForCString(v18);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)a1, "setOsProductVersionExtra:", v19);

      }
    }
    objc_msgSend((id)a1, "osBuildVersion");
    v20 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v20)
    {
      v22 = (void *)ktrace_machine_os_build();
      if (v22)
      {
        SANSStringForCString(v22);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)a1, "setOsBuildVersion:", v23);

      }
    }
    if (!*(_QWORD *)(a1 + 192))
    {
      v24 = ktrace_machine_cpu_type();
      v25 = ktrace_machine_cpu_subtype();
      v26 = v24 & 0xFEFFFFFF;
      if (a3)
        v26 |= 0x1000000uLL;
      *(_QWORD *)(a1 + 192) = v26 | ((unint64_t)(v25 & 0xFFFFFF) << 32);
    }
    if (!objc_getProperty((id)a1, v21, 1032, 1))
    {
      v27 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", *(unsigned int *)(a1 + 340));
      if (*(_DWORD *)(a1 + 340))
      {
        v29 = 0;
        *(_QWORD *)&v28 = 67109376;
        v41 = v28;
        do
        {
          v30 = ktrace_machine_cpu_cluster();
          if (v30)
          {
            v31 = v30;
            v32 = *__error();
            _sa_logt();
            v33 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = v41;
              v43 = v29;
              v44 = 1024;
              v45 = v31;
              v34 = v33;
              v35 = "Unable to determine cluster for cpu %u: %{errno}d";
LABEL_43:
              _os_log_error_impl(&dword_1B9BE0000, v34, OS_LOG_TYPE_ERROR, v35, buf, 0xEu);
            }
          }
          else
          {
            v36 = ktrace_machine_cluster_flags();
            if (!v36)
            {
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", 0);
              v38 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v29);
              v39 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v27, "setObject:forKeyedSubscript:", v38, v39);

              goto LABEL_39;
            }
            v37 = v36;
            v32 = *__error();
            _sa_logt();
            v33 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = v41;
              v43 = 0;
              v44 = 1024;
              v45 = v37;
              v34 = v33;
              v35 = "Unable to determine flags for cluster %u: %{errno}d";
              goto LABEL_43;
            }
          }

          *__error() = v32;
LABEL_39:
          v29 = (v29 + 1);
        }
        while (v29 < *(_DWORD *)(a1 + 340));
      }
      if (objc_msgSend(v27, "count", v41))
        objc_setProperty_atomic_copy((id)a1, v40, v27, 1032);

    }
  }
}

void __45__SASampleStore_gatherNonDefaultFeatureFlags__block_invoke()
{
  id v0;
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  id obj;
  uint64_t v25;
  uint64_t v26;
  void *context;
  uint64_t v28;
  id v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[128];
  _BYTE v40[128];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (objc_opt_class())
  {
    v0 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    v1 = (void *)qword_1ED1DD598;
    qword_1ED1DD598 = (uint64_t)v0;

    objc_msgSend(MEMORY[0x1E0D20F30], "shared");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    objc_msgSend(v2, "domains");
    obj = (id)objc_claimAutoreleasedReturnValue();
    v26 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v35, v40, 16);
    if (v26)
    {
      v25 = *(_QWORD *)v36;
      do
      {
        v3 = 0;
        do
        {
          if (*(_QWORD *)v36 != v25)
            objc_enumerationMutation(obj);
          v28 = v3;
          v4 = *(_QWORD *)(*((_QWORD *)&v35 + 1) + 8 * v3);
          context = (void *)MEMORY[0x1BCCCC288]();
          objc_msgSend(v2, "featuresForDomain:", v4);
          v5 = (void *)objc_claimAutoreleasedReturnValue();
          v31 = 0u;
          v32 = 0u;
          v33 = 0u;
          v34 = 0u;
          v29 = v5;
          v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v31, v39, 16);
          if (v6)
          {
            v7 = v6;
            v8 = *(_QWORD *)v32;
            do
            {
              for (i = 0; i != v7; ++i)
              {
                if (*(_QWORD *)v32 != v8)
                  objc_enumerationMutation(v29);
                v10 = *(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * i);
                objc_msgSend(v2, "stateForFeature:domain:level:", v10, v4, 4);
                v11 = (void *)objc_claimAutoreleasedReturnValue();
                if (v11)
                {
                  objc_msgSend(v2, "defaultStateForFeature:domain:", v10, v4);
                  v12 = (void *)objc_claimAutoreleasedReturnValue();
                  v13 = v12;
                  if (!v12 || (v14 = objc_msgSend(v12, "value"), v14 != objc_msgSend(v11, "value")))
                  {
                    v15 = objc_msgSend(v11, "value");
                    v16 = MEMORY[0x1E0C9AAA0];
                    if (v15 == 1)
                      v16 = MEMORY[0x1E0C9AAB0];
                    v30 = v16;
                    v17 = v7;
                    v18 = v8;
                    v19 = v2;
                    v20 = qword_1ED1DD598;
                    v21 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%@.%@"), v4, v10);
                    v22 = (void *)v20;
                    v2 = v19;
                    v8 = v18;
                    v7 = v17;
                    objc_msgSend(v22, "setObject:forKeyedSubscript:", v30, v21);

                  }
                }

              }
              v7 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v31, v39, 16);
            }
            while (v7);
          }

          objc_autoreleasePoolPop(context);
          v3 = v28 + 1;
        }
        while (v28 + 1 != v26);
        v26 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v35, v40, 16);
      }
      while (v26);
    }

    objc_msgSend(v2, "invalidateCache");
    if (!objc_msgSend((id)qword_1ED1DD598, "count"))
    {
      v23 = (void *)qword_1ED1DD598;
      qword_1ED1DD598 = 0;

    }
  }
}

intptr_t __29__SASampleStore_gatherTrials__block_invoke(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  id v7;
  char v8;
  id v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  id v14;
  id v15;
  char v16;
  id v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  void *v24;
  void *v25;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(uint64_t, void *);
  void *v30;
  id v31;
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  __int128 buf;
  Class (*v41)(uint64_t);
  void *v42;
  uint64_t *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v36 = 0;
  v37 = &v36;
  v38 = 0x2050000000;
  v2 = (void *)qword_1ED1DD5D0;
  v39 = qword_1ED1DD5D0;
  if (!qword_1ED1DD5D0)
  {
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3221225472;
    v41 = __getTRIAllocationStatusClass_block_invoke;
    v42 = &unk_1E71477A0;
    v43 = &v36;
    __getTRIAllocationStatusClass_block_invoke((uint64_t)&buf);
    v2 = (void *)v37[3];
  }
  v3 = objc_retainAutorelease(v2);
  _Block_object_dispose(&v36, 8);
  if (objc_opt_class())
  {
    objc_msgSend(v3, "defaultProvider");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v35 = 0;
    v6 = MEMORY[0x1E0C809B0];
    v33[0] = MEMORY[0x1E0C809B0];
    v33[1] = 3221225472;
    v33[2] = __29__SASampleStore_gatherTrials__block_invoke_2;
    v33[3] = &unk_1E71473C0;
    v7 = v5;
    v34 = v7;
    v8 = objc_msgSend(v4, "enumerateActiveExperimentsForEnvironment:error:block:", 0, &v35, v33);
    v9 = v35;
    v10 = *__error();
    _sa_logt();
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = v11;
    if ((v8 & 1) != 0)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v13 = objc_msgSend(v7, "count");
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = v13;
        _os_log_debug_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_DEBUG, "Found %lu active trial experiments", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v9;
      _os_log_error_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_ERROR, "Unable to determine active trial experiments: %@", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v10;
    v14 = objc_alloc_init(MEMORY[0x1E0C99DE8]);

    v32 = 0;
    v27 = v6;
    v28 = 3221225472;
    v29 = __29__SASampleStore_gatherTrials__block_invoke_372;
    v30 = &unk_1E7147410;
    v15 = v14;
    v31 = v15;
    v16 = objc_msgSend(v4, "enumerateActiveRolloutsWithError:block:", &v32, &v27);
    v17 = v32;
    v18 = *__error();
    _sa_logt();
    v19 = objc_claimAutoreleasedReturnValue();
    v20 = v19;
    if ((v16 & 1) != 0)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        v21 = objc_msgSend(v15, "count", v27, v28, v29, v30);
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = v21;
        _os_log_debug_impl(&dword_1B9BE0000, v20, OS_LOG_TYPE_DEBUG, "Found %lu active trial rollouts", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v17;
      _os_log_error_impl(&dword_1B9BE0000, v20, OS_LOG_TYPE_ERROR, "Unable to determine active trial rollouts: %@", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v18;
    v22 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 2);
    objc_msgSend(v22, "setObject:forKeyedSubscript:", v7, 0x1E714CB70);
    objc_msgSend(v22, "setObject:forKeyedSubscript:", v15, 0x1E714CB90);
    v24 = (void *)objc_msgSend(v22, "copy");
    v25 = *(void **)(a1 + 32);
    if (v25)
      objc_setProperty_atomic(v25, v23, v24, 528);

  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __29__SASampleStore_gatherTrials__block_invoke_2(uint64_t a1, void *a2)
{
  id v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  v3 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  objc_msgSend(v2, "experimentId");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)objc_msgSend(v4, "copy");
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v5, 0x1E714CBB0);

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(v2, "deploymentId"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v6, 0x1E714CBD0);

  objc_msgSend(v2, "treatmentId");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = (void *)objc_msgSend(v7, "copy");
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v8, 0x1E714CC10);

  v9 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  objc_msgSend(v2, "namespaces");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
  if (v11)
  {
    v12 = v11;
    v13 = *(_QWORD *)v23;
    do
    {
      for (i = 0; i != v12; ++i)
      {
        if (*(_QWORD *)v23 != v13)
          objc_enumerationMutation(v10);
        v15 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * i);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend(v15, "compatibilityVersion"));
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "name");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v16, v17);

      }
      v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
    }
    while (v12);
  }

  v18 = (void *)objc_msgSend(v9, "copy");
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v18, 0x1E714CBF0);

  v19 = *(void **)(a1 + 32);
  v20 = (void *)objc_msgSend(v3, "copy");
  objc_msgSend(v19, "addObject:", v20);

}

void __29__SASampleStore_gatherTrials__block_invoke_372(uint64_t a1, void *a2)
{
  objc_class *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  _QWORD v17[4];
  id v18;

  v3 = (objc_class *)MEMORY[0x1E0C99E08];
  v4 = a2;
  v16 = objc_alloc_init(v3);
  objc_msgSend(v4, "rolloutId");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = (void *)objc_msgSend(v5, "copy");
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v6, 0x1E714CC30);

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(v4, "deploymentId"));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v7, 0x1E714CBD0);

  objc_msgSend(v4, "rampId");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = (void *)objc_msgSend(v8, "copy");
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v9, 0x1E714CC50);

  v10 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  objc_msgSend(v4, "factorPackIds");
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v17[2] = __29__SASampleStore_gatherTrials__block_invoke_2_373;
  v17[3] = &unk_1E71473E8;
  v18 = v10;
  v12 = v10;
  objc_msgSend(v11, "enumerateKeysAndObjectsUsingBlock:", v17);

  v13 = (void *)objc_msgSend(v12, "copy");
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v13, 0x1E714CC70);

  v14 = *(void **)(a1 + 32);
  v15 = (void *)objc_msgSend(v16, "copy");
  objc_msgSend(v14, "addObject:", v15);

}

uint64_t __29__SASampleStore_gatherTrials__block_invoke_2_373(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", a3, a2);
}

uint64_t __40__SASampleStore_addPowerModeTransition___block_invoke(uint64_t a1, void *a2)
{
  void *v3;
  double v4;
  double v5;
  double v6;
  uint64_t v7;

  objc_msgSend(a2, "timestamp");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "wallTime");
  v5 = v4;

  v6 = *(double *)(a1 + 32);
  if (v5 <= v6)
    v7 = 0;
  else
    v7 = -1;
  if (v5 < v6)
    return 1;
  else
    return v7;
}

uint64_t __30__SASampleStore_gatherGPUInfo__block_invoke(_QWORD *a1)
{
  const __CFString *Group;
  const void *ChannelName;
  uint64_t v4;

  Group = (const __CFString *)IOReportChannelGetGroup();
  if (IOReportChannelGetFormat() == 1
    && CFStringCompare(Group, CFSTR("Internal Statistics"), 0) == kCFCompareEqualTo)
  {
    ChannelName = (const void *)IOReportChannelGetChannelName();
    if (CFEqual(ChannelName, CFSTR("GPU Restart Count")))
    {
      *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = IOReportSimpleGetIntegerValue();
      v4 = a1[5];
LABEL_7:
      *(_BYTE *)(*(_QWORD *)(v4 + 8) + 24) = 1;
      goto LABEL_8;
    }
    if (CFEqual(ChannelName, CFSTR("Last GPU Restart")))
    {
      *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = IOReportSimpleGetIntegerValue();
      v4 = a1[7];
      goto LABEL_7;
    }
  }
LABEL_8:
  if (*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) && *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24))
    return 273;
  else
    return 0;
}

void __42__SASampleStore_gatherUnknownProcessNames__block_invoke(uint64_t a1, void *a2)
{
  void *v3;
  _QWORD v4[4];
  __int128 v5;

  objc_msgSend(a2, "threads");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __42__SASampleStore_gatherUnknownProcessNames__block_invoke_2;
  v4[3] = &unk_1E71474D0;
  v5 = *(_OWORD *)(a1 + 32);
  objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);

}

void __42__SASampleStore_gatherUnknownProcessNames__block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void (**v11)(_QWORD, _QWORD);
  _QWORD v12[4];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  objc_msgSend(a3, "threadStates");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v15;
    v8 = MEMORY[0x1E0C809B0];
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v15 != v7)
          objc_enumerationMutation(v4);
        v10 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * v9);
        v12[0] = v8;
        v12[1] = 3221225472;
        v12[2] = __42__SASampleStore_gatherUnknownProcessNames__block_invoke_3;
        v12[3] = &unk_1E71474A8;
        v13 = *(_OWORD *)(a1 + 32);
        v11 = (void (**)(_QWORD, _QWORD))MEMORY[0x1BCCCC450](v12);
        v11[2](v11, objc_msgSend(v10, "originPid"));
        v11[2](v11, objc_msgSend(v10, "proximatePid"));

        ++v9;
      }
      while (v6 != v9);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    }
    while (v6);
  }

}

void __42__SASampleStore_gatherUnknownProcessNames__block_invoke_3(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  _OWORD v11[2];
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2 != -1)
  {
    objc_msgSend(*(id *)(a1 + 32), "tasksByPid");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "objectForKeyedSubscript:", v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = objc_msgSend(v6, "count");

    if (!v7)
    {
      v12 = 0;
      memset(v11, 0, sizeof(v11));
      if (qword_1ED1DD5A0 != -1)
        dispatch_once(&qword_1ED1DD5A0, &__block_literal_global_393);
      if ((_MergedGlobals_3 & 1) == 0)
      {
        proc_name(a2, v11, 0x21u);
        if (LOBYTE(v11[0]))
        {
          SANSStringForCString(v11);
          v8 = (void *)objc_claimAutoreleasedReturnValue();
          v9 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v9, "setObject:forKeyedSubscript:", v8, v10);

        }
      }
    }
  }
}

void __52__SASampleStore_gatherUnknownResourceCoalitionNames__block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  void *v8;
  void *v9;
  void *v10;
  const char *v11;
  void *v12;
  void *v13;
  const char *string;
  char *v15;
  int v16;
  NSObject *v17;
  const char *v18;
  int v19;
  NSObject *v20;
  _BOOL4 v21;
  void *v22;
  const char *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  _BYTE v28[24];
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = objc_msgSend(v3, "resourceCoalitionID");
  if (v4)
  {
    v5 = v4;
    objc_msgSend(v3, "resourceCoalitionName");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    if (v6)
    {

      goto LABEL_26;
    }
    if (!-[SATask isFromCurrentBootCycle](v3, v7))
      goto LABEL_26;
    v8 = *(void **)(a1 + 32);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v5);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "objectForKeyedSubscript:", v9);
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    if (v10)
    {
      if (v3)
        objc_setProperty_atomic(v3, v11, v10, 152);
      goto LABEL_25;
    }
    v12 = (void *)xpc_coalition_copy_info();
    v13 = v12;
    if (!v12)
    {
      v19 = *__error();
      _sa_logt();
      v20 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v3, "name");
        v27 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)v28 = 134218498;
        *(_QWORD *)&v28[4] = v5;
        *(_WORD *)&v28[12] = 2112;
        *(_QWORD *)&v28[14] = v27;
        *(_WORD *)&v28[22] = 1024;
        v29 = objc_msgSend(v3, "pid");
        _os_log_debug_impl(&dword_1B9BE0000, v20, OS_LOG_TYPE_DEBUG, "No info for rcid %llu (used by %@ [%d])", v28, 0x1Cu);

      }
      *__error() = v19;
      goto LABEL_24;
    }
    string = xpc_dictionary_get_string(v12, (const char *)*MEMORY[0x1E0C80910]);
    if (string)
    {
      v15 = (char *)string;
      v16 = *__error();
      _sa_logt();
      v17 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        goto LABEL_17;
      *(_DWORD *)v28 = 134218242;
      *(_QWORD *)&v28[4] = v5;
      *(_WORD *)&v28[12] = 2080;
      *(_QWORD *)&v28[14] = v15;
      v18 = "RCID %llu has bundleid:%s";
    }
    else
    {
      v15 = (char *)xpc_dictionary_get_string(v13, (const char *)*MEMORY[0x1E0C80918]);
      v16 = *__error();
      _sa_logt();
      v17 = objc_claimAutoreleasedReturnValue();
      v21 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
      if (!v15)
      {
        if (v21)
        {
          *(_DWORD *)v28 = 134217984;
          *(_QWORD *)&v28[4] = v5;
          _os_log_debug_impl(&dword_1B9BE0000, v17, OS_LOG_TYPE_DEBUG, "RCID %llu has no bundleid/name", v28, 0xCu);
        }

        *__error() = v16;
        goto LABEL_24;
      }
      if (!v21)
      {
LABEL_17:

        *__error() = v16;
        SANSStringForCString(v15);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        if (v22)
        {
          v24 = v22;
          if (v3)
            objc_setProperty_atomic(v3, v23, v22, 152);
          v25 = *(void **)(a1 + 32);
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v5, *(_OWORD *)v28, *(_QWORD *)&v28[16]);
          v26 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v25, "setObject:forKeyedSubscript:", v24, v26);

        }
LABEL_24:

LABEL_25:
        goto LABEL_26;
      }
      *(_DWORD *)v28 = 134218242;
      *(_QWORD *)&v28[4] = v5;
      *(_WORD *)&v28[12] = 2080;
      *(_QWORD *)&v28[14] = v15;
      v18 = "RCID %llu has name:%s";
    }
    _os_log_debug_impl(&dword_1B9BE0000, v17, OS_LOG_TYPE_DEBUG, v18, v28, 0x16u);
    goto LABEL_17;
  }
LABEL_26:

}

void __43__SASampleStore_gatherOSCryptexFileExtents__block_invoke()
{
  void *v0;
  void *v1;
  id v2;
  id v3;
  const char *v4;
  __darwin_ino64_t v5;
  int v6;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  int v11;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  off_t st_size;
  off_t v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  NSObject *v25;
  int v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  int v30;
  int v31;
  id v32;
  int v33;
  off_t v34;
  off_t v35;
  uint8_t buf[4];
  __darwin_ino64_t v37;
  __int16 v38;
  off_t v39;
  stat v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (objc_opt_class())
  {
    objc_msgSend(MEMORY[0x1E0D46970], "sharedDataAccessor");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    v32 = 0;
    v1 = (void *)objc_msgSend(v0, "copyPathForPersonalizedData:error:", 11, &v32);
    v2 = v32;

    if (v1)
    {
      v3 = objc_retainAutorelease(v1);
      v4 = (const char *)objc_msgSend(v3, "fileSystemRepresentation");
      if (!v4)
      {
        v14 = *__error();
        _sa_logt();
        v15 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v40.st_dev = 138412290;
          *(_QWORD *)&v40.st_mode = v3;
          _os_log_error_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_ERROR, "Unable to get fileSystemRepresentation for cryptex path %@", (uint8_t *)&v40, 0xCu);
        }

        *__error() = v14;
        goto LABEL_23;
      }
      v5 = (__darwin_ino64_t)v4;
      v6 = open(v4, 0, 0);
      if (v6 < 0)
      {
        v16 = *__error();
        _sa_logt();
        v17 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          v31 = *__error();
          v40.st_dev = 136315394;
          *(_QWORD *)&v40.st_mode = v5;
          WORD2(v40.st_ino) = 1024;
          *(_DWORD *)((char *)&v40.st_ino + 6) = v31;
          _os_log_error_impl(&dword_1B9BE0000, v17, OS_LOG_TYPE_ERROR, "FileExtent: error opening \"%s\": %{errno}d", (uint8_t *)&v40, 0x12u);
        }

        v11 = 0;
        *__error() = v16;
        goto LABEL_20;
      }
      v7 = v6;
      memset(&v40, 0, sizeof(v40));
      if (fstat(v6, &v40))
      {
        v8 = *__error();
        _sa_logt();
        v9 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          goto LABEL_7;
        v30 = *__error();
        *(_DWORD *)buf = 136315394;
        v37 = v5;
        v38 = 1024;
        LODWORD(v39) = v30;
        v22 = "FileExtent: failed to get file size for \"%s\": %{errno}d";
        v23 = v9;
        v24 = 18;
      }
      else
      {
        st_size = v40.st_size;
        if (v40.st_size)
        {
          if (v40.st_size < 1)
          {
            v11 = 0;
            goto LABEL_9;
          }
          v21 = 0;
          v11 = 0;
          while (1)
          {
            v33 = 0;
            v34 = st_size - v21;
            v35 = v21;
            if (fcntl(v7, 65, &v33))
            {
              v8 = *__error();
              _sa_logt();
              v25 = objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                goto LABEL_38;
              v26 = *__error();
              *(_DWORD *)buf = 67109120;
              LODWORD(v37) = v26;
              v27 = "FileExtent: error in fcntl(): %{errno}d";
              v28 = v25;
              v29 = 8;
              goto LABEL_42;
            }
            if (!v34)
              break;
            v21 += v34;
            ++v11;
            if (v21 >= st_size)
              goto LABEL_9;
          }
          v8 = *__error();
          _sa_logt();
          v25 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            goto LABEL_38;
          *(_DWORD *)buf = 134218240;
          v37 = v21;
          v38 = 2048;
          v39 = st_size;
          v27 = "FileExtent: 0 contigbytes fcntl() at offset %lld out of %lld";
          v28 = v25;
          v29 = 22;
LABEL_42:
          _os_log_error_impl(&dword_1B9BE0000, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
LABEL_38:

          v10 = __error();
LABEL_8:
          *v10 = v8;
LABEL_9:
          close(v7);
LABEL_20:
          qword_1ED1DD5B0 = v11;
          v18 = *__error();
          _sa_logt();
          v19 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            v40.st_dev = 67109378;
            *(_DWORD *)&v40.st_mode = qword_1ED1DD5B0;
            LOWORD(v40.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v40.st_ino + 2) = v5;
            _os_log_impl(&dword_1B9BE0000, v19, OS_LOG_TYPE_INFO, "Shared cache fragmentation OS Cryptex File Extents count is %d for file: (\"%s\")", (uint8_t *)&v40, 0x12u);
          }

          *__error() = v18;
LABEL_23:

          goto LABEL_24;
        }
        v8 = *__error();
        _sa_logt();
        v9 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
LABEL_7:

          v10 = __error();
          v11 = 0;
          goto LABEL_8;
        }
        *(_DWORD *)buf = 136315138;
        v37 = v5;
        v22 = "FileExtent: no extents for \"%s\" (empty file)\n";
        v23 = v9;
        v24 = 12;
      }
      _os_log_error_impl(&dword_1B9BE0000, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
      goto LABEL_7;
    }
  }
  else
  {
    v2 = 0;
  }
  v12 = *__error();
  _sa_logt();
  v13 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v40.st_dev = 138412290;
    *(_QWORD *)&v40.st_mode = v2;
    _os_log_impl(&dword_1B9BE0000, v13, OS_LOG_TYPE_INFO, "Unable to get path for MSUDA_CRYPTEX1_OS_CRYPTEX: (%@)", (uint8_t *)&v40, 0xCu);
  }

  *__error() = v12;
LABEL_24:

}

void __40__SASampleStore_gatherRootInstalledInfo__block_invoke(uint64_t a1)
{
  id v2;
  int v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  int v19;
  NSObject *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  id v25;
  id v26;
  uint8_t buf[4];
  void *v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = objc_alloc_init(*(Class *)(a1 + 48));
  v26 = 0;
  v3 = objc_msgSend(v2, "openAndReturnError:", &v26);
  v4 = v26;
  v5 = v4;
  if (v3)
  {
    v25 = v4;
    objc_msgSend(v2, "allInstalledRootsAndReturnError:", &v25);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v25;

    v8 = objc_alloc_init(MEMORY[0x1E0C99E10]);
    if (v6)
    {
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v9 = v6;
      v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
      if (v10)
      {
        v11 = v10;
        v12 = *(_QWORD *)v22;
        do
        {
          v13 = 0;
          do
          {
            if (*(_QWORD *)v22 != v12)
              objc_enumerationMutation(v9);
            objc_msgSend(*(id *)(*((_QWORD *)&v21 + 1) + 8 * v13), "name", (_QWORD)v21);
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "addObject:", v14);

            ++v13;
          }
          while (v11 != v13);
          v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
        }
        while (v11);
      }

    }
    v15 = (id)objc_msgSend(v2, "closeAndReturnError:", 0, (_QWORD)v21);
    objc_msgSend(v8, "array");
    v16 = objc_claimAutoreleasedReturnValue();
    v17 = *(_QWORD *)(a1 + 32);
    v18 = *(void **)(v17 + 552);
    *(_QWORD *)(v17 + 552) = v16;

    if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 552), "count"))
      *(_BYTE *)(*(_QWORD *)(a1 + 32) + 317) = 1;

    v5 = v7;
  }
  else
  {
    v19 = *__error();
    _sa_logt();
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v28 = v5;
      _os_log_error_impl(&dword_1B9BE0000, v20, OS_LOG_TYPE_ERROR, "Error opening Darwinup session: %@", buf, 0xCu);
    }

    *__error() = v19;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));

}

void __32__SASampleStore_gatherModelInfo__block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t j;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t k;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  id v33;
  id v34;
  id obj;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _BYTE v48[128];
  _BYTE v49[128];
  uint8_t v50[128];
  uint8_t buf[4];
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = *__error();
  _sa_logt();
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = v8;
  if (v5)
  {
    v33 = v6;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      v52 = objc_msgSend(v5, "count");
      _os_log_impl(&dword_1B9BE0000, v9, OS_LOG_TYPE_INFO, "Got information on %lu models", buf, 0xCu);
    }

    *__error() = v7;
    v44 = 0u;
    v45 = 0u;
    v46 = 0u;
    v47 = 0u;
    v34 = v5;
    obj = v5;
    v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v44, v50, 16);
    if (v10)
    {
      v11 = v10;
      v12 = *(_QWORD *)v45;
      do
      {
        for (i = 0; i != v11; ++i)
        {
          if (*(_QWORD *)v45 != v12)
            objc_enumerationMutation(obj);
          v14 = *(void **)(*((_QWORD *)&v44 + 1) + 8 * i);
          v40 = 0u;
          v41 = 0u;
          v42 = 0u;
          v43 = 0u;
          objc_msgSend(v14, "loadedChanges");
          v15 = (void *)objc_claimAutoreleasedReturnValue();
          v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v40, v49, 16);
          if (v16)
          {
            v17 = v16;
            v18 = *(_QWORD *)v41;
            do
            {
              for (j = 0; j != v17; ++j)
              {
                if (*(_QWORD *)v41 != v18)
                  objc_enumerationMutation(v15);
                objc_msgSend(*(id *)(*((_QWORD *)&v40 + 1) + 8 * j), "timestamp");
                v20 = (void *)objc_claimAutoreleasedReturnValue();
                -[SATimestamp applyMachTimebase:]((uint64_t)v20, objc_msgSend(*(id *)(a1 + 32), "machTimebase"));

              }
              v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v40, v49, 16);
            }
            while (v17);
          }

          v38 = 0u;
          v39 = 0u;
          v36 = 0u;
          v37 = 0u;
          objc_msgSend(v14, "executions");
          v21 = (void *)objc_claimAutoreleasedReturnValue();
          v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v36, v48, 16);
          if (v22)
          {
            v23 = v22;
            v24 = *(_QWORD *)v37;
            do
            {
              for (k = 0; k != v23; ++k)
              {
                if (*(_QWORD *)v37 != v24)
                  objc_enumerationMutation(v21);
                v26 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * k);
                objc_msgSend(v26, "startTime");
                v27 = (void *)objc_claimAutoreleasedReturnValue();
                -[SATimestamp applyMachTimebase:]((uint64_t)v27, objc_msgSend(*(id *)(a1 + 32), "machTimebase"));

                objc_msgSend(v26, "endTime");
                v28 = (void *)objc_claimAutoreleasedReturnValue();
                -[SATimestamp applyMachTimebase:]((uint64_t)v28, objc_msgSend(*(id *)(a1 + 32), "machTimebase"));

              }
              v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v36, v48, 16);
            }
            while (v23);
          }

        }
        v11 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v44, v50, 16);
      }
      while (v11);
    }

    v29 = objc_msgSend(obj, "copy");
    v30 = *(_QWORD *)(a1 + 32);
    v31 = *(void **)(v30 + 536);
    *(_QWORD *)(v30 + 536) = v29;

    v6 = v33;
    v5 = v34;
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(v6, "debugDescription");
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v52 = (uint64_t)v32;
      _os_log_error_impl(&dword_1B9BE0000, v9, OS_LOG_TYPE_ERROR, "Unable to get model information: %@", buf, 0xCu);

    }
    *__error() = v7;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));

}

void __38__SASampleStore_iterateAllTimestamps___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  _QWORD v21[4];
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_msgSend(v3, "execTimestamp");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 32);
    objc_msgSend(v3, "execTimestamp");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);

  }
  objc_msgSend(v3, "exitTimestamp");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 32);
    objc_msgSend(v3, "exitTimestamp");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void *))(v8 + 16))(v8, v9);

  }
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  objc_msgSend(v3, "taskStates");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
  if (v11)
  {
    v12 = v11;
    v13 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v12; ++i)
      {
        if (*(_QWORD *)v24 != v13)
          objc_enumerationMutation(v10);
        v15 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * i);
        v16 = *(_QWORD *)(a1 + 32);
        objc_msgSend(v15, "startTimestamp");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        (*(void (**)(uint64_t, void *))(v16 + 16))(v16, v17);

        v18 = *(_QWORD *)(a1 + 32);
        objc_msgSend(v15, "endTimestamp");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        (*(void (**)(uint64_t, void *))(v18 + 16))(v18, v19);

      }
      v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
    }
    while (v12);
  }

  objc_msgSend(v3, "threads");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = __38__SASampleStore_iterateAllTimestamps___block_invoke_2;
  v21[3] = &unk_1E7147598;
  v22 = *(id *)(a1 + 32);
  objc_msgSend(v20, "enumerateKeysAndObjectsUsingBlock:", v21);

}

void __38__SASampleStore_iterateAllTimestamps___block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  objc_msgSend(v4, "creationTimestamp");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    v6 = *(_QWORD *)(a1 + 32);
    objc_msgSend(v4, "creationTimestamp");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);

  }
  objc_msgSend(v4, "exitTimestamp");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 32);
    objc_msgSend(v4, "exitTimestamp");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);

  }
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  objc_msgSend(v4, "threadStates", 0);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
  if (v12)
  {
    v13 = v12;
    v14 = *(_QWORD *)v25;
    do
    {
      for (i = 0; i != v13; ++i)
      {
        if (*(_QWORD *)v25 != v14)
          objc_enumerationMutation(v11);
        v16 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * i);
        v17 = *(_QWORD *)(a1 + 32);
        objc_msgSend(v16, "startTimestamp");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        (*(void (**)(uint64_t, void *))(v17 + 16))(v17, v18);

        v19 = *(_QWORD *)(a1 + 32);
        objc_msgSend(v16, "endTimestamp");
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        (*(void (**)(uint64_t, void *))(v19 + 16))(v19, v20);

        objc_msgSend(v16, "timestampLastMadeRunnable");
        v21 = (void *)objc_claimAutoreleasedReturnValue();

        if (v21)
        {
          v22 = *(_QWORD *)(a1 + 32);
          objc_msgSend(v16, "timestampLastMadeRunnable");
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          (*(void (**)(uint64_t, void *))(v22 + 16))(v22, v23);

        }
      }
      v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
    }
    while (v13);
  }

}

- (id)callTreeForTask:(id)a3 options:(id)a4
{
  id v6;
  id v7;
  SASamplePrinter *v8;
  void *v9;

  v6 = a4;
  v7 = a3;
  v8 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v8, "setOptions:", v6);

  -[SASamplePrinter callTreeForTask:](v8, "callTreeForTask:", v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

- (id)callTreesForThreadsInTask:(id)a3 options:(id)a4
{
  id v6;
  id v7;
  SASamplePrinter *v8;
  void *v9;

  v6 = a4;
  v7 = a3;
  v8 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v8, "setOptions:", v6);

  -[SASamplePrinter callTreesForThreadsInTask:](v8, "callTreesForThreadsInTask:", v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

- (id)callTreeForThread:(id)a3 inTask:(id)a4 options:(id)a5
{
  id v8;
  id v9;
  id v10;
  SASamplePrinter *v11;
  void *v12;

  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v11, "setOptions:", v8);

  -[SASamplePrinter callTreeForThread:inTask:](v11, "callTreeForThread:inTask:", v10, v9);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  return v12;
}

- (id)callTreeForDispatchQueue:(id)a3 andThread:(id)a4 inTask:(id)a5 options:(id)a6
{
  id v10;
  id v11;
  id v12;
  id v13;
  SASamplePrinter *v14;
  void *v15;

  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v14, "setOptions:", v10);

  -[SASamplePrinter callTreeForDispatchQueue:andThread:inTask:](v14, "callTreeForDispatchQueue:andThread:inTask:", v13, v12, v11);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

- (id)callTreeForSwiftTask:(id)a3 thread:(id)a4 inTask:(id)a5 options:(id)a6
{
  id v10;
  id v11;
  id v12;
  id v13;
  SASamplePrinter *v14;
  void *v15;

  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v14, "setOptions:", v10);

  -[SASamplePrinter callTreeForSwiftTask:thread:inTask:](v14, "callTreeForSwiftTask:thread:inTask:", v13, v12, v11);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

- (id)callTreeForDispatchQueue:(id)a3 swiftTask:(id)a4 thread:(id)a5 inTask:(id)a6 options:(id)a7
{
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  SASamplePrinter *v17;
  void *v18;

  v12 = a7;
  v13 = a6;
  v14 = a5;
  v15 = a4;
  v16 = a3;
  v17 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v17, "setOptions:", v12);

  -[SASamplePrinter callTreeForDispatchQueue:swiftTask:thread:inTask:](v17, "callTreeForDispatchQueue:swiftTask:thread:inTask:", v16, v15, v14, v13);
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  return v18;
}

- (id)callTreeForExecutable:(id)a3 options:(id)a4
{
  id v6;
  id v7;
  SASamplePrinter *v8;
  void *v9;

  v6 = a4;
  v7 = a3;
  v8 = -[SASamplePrinter initWithSampleStore:]([SASamplePrinter alloc], "initWithSampleStore:", self);
  -[SASamplePrinter setOptions:](v8, "setOptions:", v6);

  -[SASamplePrinter callTreeForExecutable:](v8, "callTreeForExecutable:", v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

- (NSDictionary)tasksByPid
{
  return (NSDictionary *)objc_getProperty(self, a2, 16, 1);
}

- (NSArray)sampleTimestamps
{
  return (NSArray *)objc_getProperty(self, a2, 24, 1);
}

- (NSArray)hidEvents
{
  return (NSArray *)objc_getProperty(self, a2, 56, 1);
}

- (NSArray)ioEvents
{
  return (NSArray *)objc_getProperty(self, a2, 88, 1);
}

- (NSArray)memoryPressureEvents
{
  return (NSArray *)objc_getProperty(self, a2, 96, 1);
}

- (NSArray)kernelCaches
{
  return (NSArray *)objc_getProperty(self, a2, 104, 1);
}

- (NSArray)exclaves
{
  return (NSArray *)objc_getProperty(self, a2, 120, 1);
}

- (NSArray)powerModeTransitions
{
  return (NSArray *)objc_getProperty(self, a2, 80, 1);
}

- (unint64_t)dataSource
{
  return self->_dataSource;
}

- (unint64_t)dataStyle
{
  return self->_dataStyle;
}

- (double)attemptedSamplingInterval
{
  return self->_attemptedSamplingInterval;
}

- (void)setAttemptedSamplingInterval:(double)a3
{
  self->_attemptedSamplingInterval = a3;
}

- (SATimestamp)timestampOfLastStackshot
{
  return (SATimestamp *)objc_getProperty(self, a2, 376, 1);
}

- (NSString)reason
{
  return (NSString *)objc_getProperty(self, a2, 384, 1);
}

- (void)setReason:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 384);
}

- (double)lastWakeTime
{
  return self->_lastWakeTime;
}

- (SAMountStatusTracker)mountStatusTracker
{
  return (SAMountStatusTracker *)objc_getProperty(self, a2, 400, 1);
}

- (BOOL)keepMicrostackshotsWithoutLoadInfo
{
  return self->_keepMicrostackshotsWithoutLoadInfo;
}

- (void)setKeepMicrostackshotsWithoutLoadInfo:(BOOL)a3
{
  self->_keepMicrostackshotsWithoutLoadInfo = a3;
}

- (unsigned)additionalCSSymbolicatorFlags
{
  return self->_additionalCSSymbolicatorFlags;
}

- (void)setAdditionalCSSymbolicatorFlags:(unsigned int)a3
{
  self->_additionalCSSymbolicatorFlags = a3;
}

- (SATimestamp)timeWhenTransitionedToSamplingAllThreads
{
  return (SATimestamp *)objc_getProperty(self, a2, 424, 1);
}

- (SATimestamp)timeWhenTransitionedToSamplingAllProcesses
{
  return (SATimestamp *)objc_getProperty(self, a2, 432, 1);
}

- (BOOL)sanitizePaths
{
  return self->_sanitizePaths;
}

- (void)setSanitizePaths:(BOOL)a3
{
  self->_sanitizePaths = a3;
}

- (BOOL)omitSensitiveStrings
{
  return self->_omitSensitiveStrings;
}

- (void)setOmitSensitiveStrings:(BOOL)a3
{
  self->_omitSensitiveStrings = a3;
}

- (BOOL)shouldGatherKextStat
{
  return self->_shouldGatherKextStat;
}

- (void)setShouldGatherKextStat:(BOOL)a3
{
  self->_shouldGatherKextStat = a3;
}

- (NSString)kernelVersion
{
  return (NSString *)objc_getProperty(self, a2, 448, 1);
}

- (NSString)osProductName
{
  return (NSString *)objc_getProperty(self, a2, 456, 1);
}

- (void)setOsProductName:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 456);
}

- (NSString)osProductVersion
{
  return (NSString *)objc_getProperty(self, a2, 464, 1);
}

- (void)setOsProductVersion:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 464);
}

- (NSString)osProductVersionExtra
{
  return (NSString *)objc_getProperty(self, a2, 472, 1);
}

- (void)setOsProductVersionExtra:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 472);
}

- (NSString)osBuildVersion
{
  return (NSString *)objc_getProperty(self, a2, 480, 1);
}

- (void)setOsBuildVersion:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 480);
}

- (unsigned)workQueueSoftThreadLimit
{
  return self->_workQueueSoftThreadLimit;
}

- (unsigned)workQueueHardThreadLimit
{
  return self->_workQueueHardThreadLimit;
}

- (NSString)hardwareModel
{
  return (NSString *)objc_getProperty(self, a2, 488, 1);
}

- (void)setHardwareModel:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 488);
}

- (unsigned)numActiveCPUs
{
  return self->_numActiveCPUs;
}

- (void)setNumActiveCPUs:(unsigned int)a3
{
  self->_numActiveCPUs = a3;
}

- (unsigned)hwPageSize
{
  return self->_hwPageSize;
}

- (void)setHwPageSize:(unsigned int)a3
{
  self->_hwPageSize = a3;
}

- (unsigned)vmPageSize
{
  return self->_vmPageSize;
}

- (void)setVmPageSize:(unsigned int)a3
{
  self->_vmPageSize = a3;
}

- (NSString)bootArgs
{
  return (NSString *)objc_getProperty(self, a2, 496, 1);
}

- (void)setBootArgs:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 496);
}

- (NSDictionary)systemAdvisoryLevels
{
  return (NSDictionary *)objc_getProperty(self, a2, 504, 1);
}

- (NSDictionary)homeVolumeSpace
{
  return (NSDictionary *)objc_getProperty(self, a2, 512, 1);
}

- (NSDictionary)nonDefaultFeatureFlags
{
  return (NSDictionary *)objc_getProperty(self, a2, 520, 1);
}

- (NSDictionary)activeTrials
{
  return (NSDictionary *)objc_getProperty(self, a2, 528, 1);
}

- (NSArray)models
{
  return (NSArray *)objc_getProperty(self, a2, 536, 1);
}

- (int64_t)numOSCryptexFileExtents
{
  return self->_numOSCryptexFileExtents;
}

- (BOOL)isRootInstalled
{
  return self->_isRootInstalled;
}

- (NSArray)installedRootNames
{
  return (NSArray *)objc_getProperty(self, a2, 552, 1);
}

- (BOOL)isAppleInternal
{
  return self->_isAppleInternal;
}

- (BOOL)appleInternalIsKnown
{
  return self->_appleInternalIsKnown;
}

- (BOOL)isInternalCarryDevice
{
  return self->_isInternalCarryDevice;
}

- (BOOL)hasInternalCarryDeviceDistinction
{
  return self->_hasInternalCarryDeviceDistinction;
}

- (NSString)automatedDeviceGroup
{
  return (NSString *)objc_getProperty(self, a2, 560, 1);
}

- (NSArray)keyboardLanguages
{
  return (NSArray *)objc_getProperty(self, a2, 568, 1);
}

- (NSArray)preferredLanguages
{
  return (NSArray *)objc_getProperty(self, a2, 576, 1);
}

- (NSString)countryCode
{
  return (NSString *)objc_getProperty(self, a2, 584, 1);
}

- (BOOL)hasHardwareKeyboardInfo
{
  return self->_hasHardwareKeyboardInfo;
}

- (BOOL)hardwareKeyboard
{
  return self->_hardwareKeyboard;
}

- (unint64_t)gpuRestartCount
{
  return self->_gpuRestartCount;
}

- (unint64_t)gpuRestartLastMachAbs
{
  return self->_gpuRestartLastMachAbs;
}

- (BOOL)hasEnterprisePersona
{
  return self->_hasEnterprisePersona;
}

- (unint64_t)targetHIDEventEndMachAbs
{
  return self->_targetHIDEventEndMachAbs;
}

- (void)setTargetHIDEventEndMachAbs:(unint64_t)a3
{
  self->_targetHIDEventEndMachAbs = a3;
}

- (NSString)customOutput
{
  return (NSString *)objc_getProperty(self, a2, 616, 1);
}

- (void)setCustomOutput:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 616);
}

- (double)cpuUsed
{
  return self->_cpuUsed;
}

- (void)setCpuUsed:(double)a3
{
  self->_cpuUsed = a3;
}

- (double)cpuDuration
{
  return self->_cpuDuration;
}

- (void)setCpuDuration:(double)a3
{
  self->_cpuDuration = a3;
}

- (double)cpuLimit
{
  return self->_cpuLimit;
}

- (void)setCpuLimit:(double)a3
{
  self->_cpuLimit = a3;
}

- (double)cpuLimitDuration
{
  return self->_cpuLimitDuration;
}

- (void)setCpuLimitDuration:(double)a3
{
  self->_cpuLimitDuration = a3;
}

- (unint64_t)numWakeups
{
  return self->_numWakeups;
}

- (void)setNumWakeups:(unint64_t)a3
{
  self->_numWakeups = a3;
}

- (double)wakeupsDuration
{
  return self->_wakeupsDuration;
}

- (void)setWakeupsDuration:(double)a3
{
  self->_wakeupsDuration = a3;
}

- (unint64_t)numWakeupsLimit
{
  return self->_numWakeupsLimit;
}

- (void)setNumWakeupsLimit:(unint64_t)a3
{
  self->_numWakeupsLimit = a3;
}

- (double)wakeupsLimitDuration
{
  return self->_wakeupsLimitDuration;
}

- (void)setWakeupsLimitDuration:(double)a3
{
  self->_wakeupsLimitDuration = a3;
}

- (unint64_t)bytesWritten
{
  return self->_bytesWritten;
}

- (void)setBytesWritten:(unint64_t)a3
{
  self->_bytesWritten = a3;
}

- (double)writeDuration
{
  return self->_writeDuration;
}

- (void)setWriteDuration:(double)a3
{
  self->_writeDuration = a3;
}

- (unint64_t)bytesWrittenLimit
{
  return self->_bytesWrittenLimit;
}

- (void)setBytesWrittenLimit:(unint64_t)a3
{
  self->_bytesWrittenLimit = a3;
}

- (double)writeLimitDuration
{
  return self->_writeLimitDuration;
}

- (void)setWriteLimitDuration:(double)a3
{
  self->_writeLimitDuration = a3;
}

- (NSString)event
{
  return (NSString *)objc_getProperty(self, a2, 720, 1);
}

- (void)setEvent:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 720);
}

- (void)setEventNote:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 728);
}

- (SATimeRange)eventTimeRange
{
  return (SATimeRange *)objc_getProperty(self, a2, 736, 1);
}

- (void)setEventTimeRange:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 736);
}

- (NSString)signature
{
  return (NSString *)objc_getProperty(self, a2, 744, 1);
}

- (void)setSignature:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 744);
}

- (NSString)actionTaken
{
  return (NSString *)objc_getProperty(self, a2, 752, 1);
}

- (void)setActionTaken:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 752);
}

- (double)extraDuration
{
  return self->_extraDuration;
}

- (void)setExtraDuration:(double)a3
{
  self->_extraDuration = a3;
}

- (NSString)durationNote
{
  return (NSString *)objc_getProperty(self, a2, 768, 1);
}

- (void)setDurationNote:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 768);
}

- (NSString)stepsNote
{
  return (NSString *)objc_getProperty(self, a2, 776, 1);
}

- (void)setStepsNote:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 776);
}

- (double)reportTimeThreshold
{
  return self->_reportTimeThreshold;
}

- (void)setReportTimeThreshold:(double)a3
{
  self->_reportTimeThreshold = a3;
}

- (NSString)wrWorkflowName
{
  return (NSString *)objc_getProperty(self, a2, 792, 1);
}

- (void)setWrWorkflowName:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 792);
}

- (NSError)wrError
{
  return (NSError *)objc_getProperty(self, a2, 800, 1);
}

- (void)setWrError:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 800);
}

- (NSString)wrDiagnosticName
{
  return (NSString *)objc_getProperty(self, a2, 808, 1);
}

- (void)setWrDiagnosticName:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 808);
}

- (double)wrWorkflowTimeoutDuration
{
  return self->_wrWorkflowTimeoutDuration;
}

- (void)setWrWorkflowTimeoutDuration:(double)a3
{
  self->_wrWorkflowTimeoutDuration = a3;
}

- (double)wrWorkflowDurationThreshold
{
  return self->_wrWorkflowDurationThreshold;
}

- (void)setWrWorkflowDurationThreshold:(double)a3
{
  self->_wrWorkflowDurationThreshold = a3;
}

- (double)wrWorkflowDuration
{
  return self->_wrWorkflowDuration;
}

- (void)setWrWorkflowDuration:(double)a3
{
  self->_wrWorkflowDuration = a3;
}

- (double)wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold
{
  return self->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold;
}

- (void)setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:(double)a3
{
  self->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold = a3;
}

- (double)wrWorkflowDurationOmittingNetworkBoundIntervals
{
  return self->_wrWorkflowDurationOmittingNetworkBoundIntervals;
}

- (void)setWrWorkflowDurationOmittingNetworkBoundIntervals:(double)a3
{
  self->_wrWorkflowDurationOmittingNetworkBoundIntervals = a3;
}

- (NSString)wrSignpostName
{
  return (NSString *)objc_getProperty(self, a2, 856, 1);
}

- (void)setWrSignpostName:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 856);
}

- (NSString)wrSignpostSubsystem
{
  return (NSString *)objc_getProperty(self, a2, 864, 1);
}

- (void)setWrSignpostSubsystem:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 864);
}

- (NSString)wrSignpostCategory
{
  return (NSString *)objc_getProperty(self, a2, 872, 1);
}

- (void)setWrSignpostCategory:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 872);
}

- (NSString)wrTriggeringSignpostName
{
  return (NSString *)objc_getProperty(self, a2, 880, 1);
}

- (void)setWrTriggeringSignpostName:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 880);
}

- (NSString)wrTriggeringSignpostSubsystem
{
  return (NSString *)objc_getProperty(self, a2, 888, 1);
}

- (void)setWrTriggeringSignpostSubsystem:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 888);
}

- (NSString)wrTriggeringSignpostCategory
{
  return (NSString *)objc_getProperty(self, a2, 896, 1);
}

- (void)setWrTriggeringSignpostCategory:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 896);
}

- (unint64_t)wrSignpostCountThreshold
{
  return self->_wrSignpostCountThreshold;
}

- (void)setWrSignpostCountThreshold:(unint64_t)a3
{
  self->_wrSignpostCountThreshold = a3;
}

- (unint64_t)wrSignpostCount
{
  return self->_wrSignpostCount;
}

- (void)setWrSignpostCount:(unint64_t)a3
{
  self->_wrSignpostCount = a3;
}

- (double)wrSignpostDurationUnionThreshold
{
  return self->_wrSignpostDurationUnionThreshold;
}

- (void)setWrSignpostDurationUnionThreshold:(double)a3
{
  self->_wrSignpostDurationUnionThreshold = a3;
}

- (double)wrSignpostDurationUnion
{
  return self->_wrSignpostDurationUnion;
}

- (void)setWrSignpostDurationUnion:(double)a3
{
  self->_wrSignpostDurationUnion = a3;
}

- (double)wrSignpostDurationSumThreshold
{
  return self->_wrSignpostDurationSumThreshold;
}

- (void)setWrSignpostDurationSumThreshold:(double)a3
{
  self->_wrSignpostDurationSumThreshold = a3;
}

- (double)wrSignpostDurationSum
{
  return self->_wrSignpostDurationSum;
}

- (void)setWrSignpostDurationSum:(double)a3
{
  self->_wrSignpostDurationSum = a3;
}

- (double)wrSignpostDurationSingleThreshold
{
  return self->_wrSignpostDurationSingleThreshold;
}

- (void)setWrSignpostDurationSingleThreshold:(double)a3
{
  self->_wrSignpostDurationSingleThreshold = a3;
}

- (double)wrSignpostDurationSingle
{
  return self->_wrSignpostDurationSingle;
}

- (void)setWrSignpostDurationSingle:(double)a3
{
  self->_wrSignpostDurationSingle = a3;
}

- (void).cxx_destruct
{
  objc_storeStrong((id *)&self->_clusterFlagsForCPUNumMapping, 0);
  objc_storeStrong((id *)&self->_mostRecentNativeSharedCache, 0);
  objc_storeStrong((id *)&self->_previousSAVersions, 0);
  objc_storeStrong((id *)&self->_processNameForUnknownPids, 0);
  objc_storeStrong((id *)&self->_ioEventsByTid, 0);
  objc_storeStrong((id *)&self->_wrTriggeringSignpostCategory, 0);
  objc_storeStrong((id *)&self->_wrTriggeringSignpostSubsystem, 0);
  objc_storeStrong((id *)&self->_wrTriggeringSignpostName, 0);
  objc_storeStrong((id *)&self->_wrSignpostCategory, 0);
  objc_storeStrong((id *)&self->_wrSignpostSubsystem, 0);
  objc_storeStrong((id *)&self->_wrSignpostName, 0);
  objc_storeStrong((id *)&self->_wrDiagnosticName, 0);
  objc_storeStrong((id *)&self->_wrError, 0);
  objc_storeStrong((id *)&self->_wrWorkflowName, 0);
  objc_storeStrong((id *)&self->_stepsNote, 0);
  objc_storeStrong((id *)&self->_durationNote, 0);
  objc_storeStrong((id *)&self->_actionTaken, 0);
  objc_storeStrong((id *)&self->_signature, 0);
  objc_storeStrong((id *)&self->_eventTimeRange, 0);
  objc_storeStrong((id *)&self->_eventNote, 0);
  objc_storeStrong((id *)&self->_event, 0);
  objc_storeStrong((id *)&self->_customOutput, 0);
  objc_storeStrong((id *)&self->_countryCode, 0);
  objc_storeStrong((id *)&self->_preferredLanguages, 0);
  objc_storeStrong((id *)&self->_keyboardLanguages, 0);
  objc_storeStrong((id *)&self->_automatedDeviceGroup, 0);
  objc_storeStrong((id *)&self->_installedRootNames, 0);
  objc_storeStrong((id *)&self->_models, 0);
  objc_storeStrong((id *)&self->_activeTrials, 0);
  objc_storeStrong((id *)&self->_nonDefaultFeatureFlags, 0);
  objc_storeStrong((id *)&self->_homeVolumeSpace, 0);
  objc_storeStrong((id *)&self->_systemAdvisoryLevels, 0);
  objc_storeStrong((id *)&self->_bootArgs, 0);
  objc_storeStrong((id *)&self->_hardwareModel, 0);
  objc_storeStrong((id *)&self->_osBuildVersion, 0);
  objc_storeStrong((id *)&self->_osProductVersionExtra, 0);
  objc_storeStrong((id *)&self->_osProductVersion, 0);
  objc_storeStrong((id *)&self->_osProductName, 0);
  objc_storeStrong((id *)&self->_kernelVersion, 0);
  objc_storeStrong((id *)&self->_kextStat, 0);
  objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllProcesses, 0);
  objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllThreads, 0);
  objc_storeStrong((id *)&self->_cpuSignalHandlerStackLeafKernelFrame, 0);
  objc_storeStrong((id *)&self->_mountStatusTracker, 0);
  objc_storeStrong((id *)&self->_reason, 0);
  objc_storeStrong((id *)&self->_timestampOfLastStackshot, 0);
  objc_storeStrong((id *)&self->_processAddressTranslations, 0);
  objc_storeStrong((id *)&self->_idsToUseDsymForUUID, 0);
  objc_storeStrong((id *)&self->_namesToUseDsymForUUID, 0);
  objc_storeStrong((id *)&self->_kperfTriggers, 0);
  objc_storeStrong((id *)&self->_targetProcess, 0);
  objc_storeStrong((id *)&self->_pidsToTrack, 0);
  objc_storeStrong((id *)&self->_binaryLocator, 0);
  objc_storeStrong((id *)&self->_wsDataStore, 0);
  objc_storeStrong((id *)&self->_exclaves, 0);
  objc_storeStrong((id *)&self->_sharedCaches, 0);
  objc_storeStrong((id *)&self->_kernelCaches, 0);
  objc_storeStrong((id *)&self->_memoryPressureEvents, 0);
  objc_storeStrong((id *)&self->_ioEvents, 0);
  objc_storeStrong((id *)&self->_powerModeTransitions, 0);
  objc_storeStrong((id *)&self->_fanSpeeds, 0);
  objc_storeStrong((id *)&self->_gestures, 0);
  objc_storeStrong((id *)&self->_hidEvents, 0);
  objc_storeStrong((id *)&self->_endTime, 0);
  objc_storeStrong((id *)&self->_startTime, 0);
  objc_storeStrong((id *)&self->_sampleTimestamps, 0);
  objc_storeStrong((id *)&self->_tasksByPid, 0);
  objc_storeStrong((id *)&self->_tasksByUniquePid, 0);
}

+ (BOOL)supportsSecureCoding
{
  return 1;
}

- (void)encodeWithCoder:(id)a3
{
  id v4;
  void *v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  const char *v13;
  void *v14;
  id Property;
  id v16;
  unint64_t v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  void *v22;
  unint64_t v23;
  NSMutableArray *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t j;
  void *v28;
  unint64_t v29;
  NSMutableArray *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t k;
  void *v34;
  unint64_t v35;
  NSMutableArray *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t m;
  void *v40;
  unint64_t v41;
  NSMutableArray *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t n;
  void *v46;
  unint64_t v47;
  NSMutableArray *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t ii;
  void *v52;
  unint64_t v53;
  NSMutableArray *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t jj;
  void *v58;
  unint64_t v59;
  NSMutableArray *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t kk;
  void *v64;
  unint64_t v65;
  NSMutableArray *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t mm;
  void *v70;
  unint64_t v71;
  NSMutableArray *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t nn;
  void *v76;
  unint64_t v77;
  NSArray *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t i1;
  void *v82;
  unint64_t v83;
  NSArray *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t i2;
  void *v88;
  SAMountStatusTracker *v89;
  SAMountStatusTracker *v90;
  SAWSUpdateDataStore *v91;
  SAWSUpdateDataStore *v92;
  SATimestamp *v93;
  SATimestamp *v94;
  SATimestamp *v95;
  SATimestamp *v96;
  SAFrame *v97;
  SAFrame *v98;
  SATimeRange *v99;
  SATimeRange *v100;
  SATimestamp *v101;
  SATimestamp *v102;
  unint64_t v103;
  NSMutableArray *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t i3;
  void *v108;
  int v109;
  NSObject *v110;
  SATimestamp *v111;
  SATimestamp *v112;
  SATimestamp *v113;
  SATimestamp *v114;
  void *v115;
  SEL v116;
  id v117;
  NSString *wrWorkflowName;
  NSArray *previousSAVersions;
  uint64_t v120;
  void *v121;
  void *v122;
  void *v123;
  void *v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  void *v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  _QWORD v185[4];
  id v186;
  _QWORD *v187;
  void *v188;
  _QWORD v189[4];
  _QWORD v190[5];
  uint8_t buf[8];
  uint8_t *v192;
  uint64_t v193;
  uint64_t v194;
  _BYTE v195[128];
  _BYTE v196[128];
  _BYTE v197[128];
  _BYTE v198[128];
  _BYTE v199[128];
  _BYTE v200[128];
  _BYTE v201[128];
  _BYTE v202[128];
  _BYTE v203[128];
  _BYTE v204[128];
  _BYTE v205[128];
  _BYTE v206[128];
  _BYTE v207[128];
  uint64_t v208;

  v208 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  if (v4)
  {
    v5 = (void *)MEMORY[0x1BCCCC288]();
    -[SASampleStore symbolicate](self, "symbolicate");
    objc_autoreleasePoolPop(v5);
    v6 = (void *)MEMORY[0x1BCCCC288]();
    objc_msgSend(v4, "encodeInteger:forKey:", 36, CFSTR("_PASampleTimeSeriesDataStore_Serialized_Version"));
    objc_msgSend(v4, "encodeInteger:forKey:", 36, CFSTR("_SASampleStore_Serialized_Version"));
    v7 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    *(_QWORD *)buf = 0;
    v192 = buf;
    v193 = 0x2020000000;
    v8 = MEMORY[0x1E0C809B0];
    v194 = 0;
    v190[0] = MEMORY[0x1E0C809B0];
    v190[1] = 3221225472;
    v190[2] = __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke;
    v190[3] = &unk_1E71475E8;
    v190[4] = buf;
    -[SASampleStore enumerateTasks:](self, "enumerateTasks:", v190);
    v9 = *((_QWORD *)v192 + 3);
    if (v9)
    {
      v10 = 8 * v9;
      v11 = malloc_type_malloc(8 * v9, 0x8A1BF267uLL);
      v189[0] = 0;
      v189[1] = v189;
      v189[2] = 0x2020000000;
      v189[3] = 0;
      v185[0] = v8;
      v185[1] = 3221225472;
      v185[2] = __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke_2;
      v185[3] = &unk_1E7146E90;
      v188 = v11;
      v186 = v7;
      v187 = v189;
      -[SASampleStore enumerateTasks:](self, "enumerateTasks:", v185);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v11, v10, CFSTR("_tasks"));
      free(v11);

      _Block_object_dispose(v189, 8);
    }
    -[SASampleStore lastTaskWithPid:](self, 0);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v12;
    if (v12)
      Property = objc_getProperty(v12, v13, 280, 1);
    else
      Property = 0;
    v16 = Property;

    if (v16)
    {
      v17 = objc_msgSend(v16, "count");
      if (v17)
      {
        v183 = 0u;
        v184 = 0u;
        v181 = 0u;
        v182 = 0u;
        v18 = v16;
        v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v181, v207, 16);
        if (v19)
        {
          v20 = *(_QWORD *)v182;
          do
          {
            for (i = 0; i != v19; ++i)
            {
              if (*(_QWORD *)v182 != v20)
                objc_enumerationMutation(v18);
              objc_msgSend(*(id *)(*((_QWORD *)&v181 + 1) + 8 * i), "addSelfToSerializationDictionary:", v7);
            }
            v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v181, v207, 16);
          }
          while (v19);
        }

        v22 = malloc_type_malloc(8 * v17, 0x1207B8B7uLL);
        SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v22, v17, v18, v7);
        objc_msgSend(v4, "encodeBytes:length:forKey:", v22, 8 * v17, CFSTR("_rootKernelFrames"));
        free(v22);
      }
    }
    v23 = -[NSMutableArray count](self->_fanSpeeds, "count");
    if (v23)
    {
      v179 = 0u;
      v180 = 0u;
      v177 = 0u;
      v178 = 0u;
      v24 = self->_fanSpeeds;
      v25 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v24, "countByEnumeratingWithState:objects:count:", &v177, v206, 16);
      if (v25)
      {
        v26 = *(_QWORD *)v178;
        do
        {
          for (j = 0; j != v25; ++j)
          {
            if (*(_QWORD *)v178 != v26)
              objc_enumerationMutation(v24);
            objc_msgSend(*(id *)(*((_QWORD *)&v177 + 1) + 8 * j), "addSelfToSerializationDictionary:", v7);
          }
          v25 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v24, "countByEnumeratingWithState:objects:count:", &v177, v206, 16);
        }
        while (v25);
      }

      v28 = malloc_type_malloc(8 * v23, 0xD4A6C391uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v28, v23, self->_fanSpeeds, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v28, 8 * v23, CFSTR("_fanSpeeds"));
      free(v28);
    }
    v29 = -[NSMutableArray count](self->_powerModeTransitions, "count");
    if (v29)
    {
      v175 = 0u;
      v176 = 0u;
      v173 = 0u;
      v174 = 0u;
      v30 = self->_powerModeTransitions;
      v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v30, "countByEnumeratingWithState:objects:count:", &v173, v205, 16);
      if (v31)
      {
        v32 = *(_QWORD *)v174;
        do
        {
          for (k = 0; k != v31; ++k)
          {
            if (*(_QWORD *)v174 != v32)
              objc_enumerationMutation(v30);
            objc_msgSend(*(id *)(*((_QWORD *)&v173 + 1) + 8 * k), "addSelfToSerializationDictionary:", v7);
          }
          v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v30, "countByEnumeratingWithState:objects:count:", &v173, v205, 16);
        }
        while (v31);
      }

      v34 = malloc_type_malloc(8 * v29, 0xA32F8ABEuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v34, v29, self->_powerModeTransitions, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v34, 8 * v29, CFSTR("_powerModeTransitions"));
      free(v34);
    }
    v35 = -[NSMutableArray count](self->_hidEvents, "count");
    if (v35)
    {
      v171 = 0u;
      v172 = 0u;
      v169 = 0u;
      v170 = 0u;
      v36 = self->_hidEvents;
      v37 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v36, "countByEnumeratingWithState:objects:count:", &v169, v204, 16);
      if (v37)
      {
        v38 = *(_QWORD *)v170;
        do
        {
          for (m = 0; m != v37; ++m)
          {
            if (*(_QWORD *)v170 != v38)
              objc_enumerationMutation(v36);
            objc_msgSend(*(id *)(*((_QWORD *)&v169 + 1) + 8 * m), "addSelfToSerializationDictionary:", v7);
          }
          v37 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v36, "countByEnumeratingWithState:objects:count:", &v169, v204, 16);
        }
        while (v37);
      }

      v40 = malloc_type_malloc(8 * v35, 0x6BE5B8BFuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v40, v35, self->_hidEvents, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v40, 8 * v35, CFSTR("_hidEvents"));
      free(v40);
    }
    v41 = -[NSMutableArray count](self->_gestures, "count");
    if (v41)
    {
      v167 = 0u;
      v168 = 0u;
      v165 = 0u;
      v166 = 0u;
      v42 = self->_gestures;
      v43 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v42, "countByEnumeratingWithState:objects:count:", &v165, v203, 16);
      if (v43)
      {
        v44 = *(_QWORD *)v166;
        do
        {
          for (n = 0; n != v43; ++n)
          {
            if (*(_QWORD *)v166 != v44)
              objc_enumerationMutation(v42);
            objc_msgSend(*(id *)(*((_QWORD *)&v165 + 1) + 8 * n), "addSelfToSerializationDictionary:", v7);
          }
          v43 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v42, "countByEnumeratingWithState:objects:count:", &v165, v203, 16);
        }
        while (v43);
      }

      v46 = malloc_type_malloc(8 * v41, 0x9258C014uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v46, v41, self->_gestures, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v46, 8 * v41, CFSTR("_gestures"));
      free(v46);
    }
    v47 = -[NSMutableArray count](self->_ioEvents, "count");
    if (v47)
    {
      v163 = 0u;
      v164 = 0u;
      v161 = 0u;
      v162 = 0u;
      v48 = self->_ioEvents;
      v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v48, "countByEnumeratingWithState:objects:count:", &v161, v202, 16);
      if (v49)
      {
        v50 = *(_QWORD *)v162;
        do
        {
          for (ii = 0; ii != v49; ++ii)
          {
            if (*(_QWORD *)v162 != v50)
              objc_enumerationMutation(v48);
            objc_msgSend(*(id *)(*((_QWORD *)&v161 + 1) + 8 * ii), "addSelfToSerializationDictionary:", v7);
          }
          v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v48, "countByEnumeratingWithState:objects:count:", &v161, v202, 16);
        }
        while (v49);
      }

      v52 = malloc_type_malloc(8 * v47, 0x6B826165uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v52, v47, self->_ioEvents, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v52, 8 * v47, CFSTR("_ioEvents"));
      free(v52);
    }
    v53 = -[NSMutableArray count](self->_memoryPressureEvents, "count");
    if (v53)
    {
      v159 = 0u;
      v160 = 0u;
      v157 = 0u;
      v158 = 0u;
      v54 = self->_memoryPressureEvents;
      v55 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v54, "countByEnumeratingWithState:objects:count:", &v157, v201, 16);
      if (v55)
      {
        v56 = *(_QWORD *)v158;
        do
        {
          for (jj = 0; jj != v55; ++jj)
          {
            if (*(_QWORD *)v158 != v56)
              objc_enumerationMutation(v54);
            objc_msgSend(*(id *)(*((_QWORD *)&v157 + 1) + 8 * jj), "addSelfToSerializationDictionary:", v7);
          }
          v55 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v54, "countByEnumeratingWithState:objects:count:", &v157, v201, 16);
        }
        while (v55);
      }

      v58 = malloc_type_malloc(8 * v53, 0x54FBB9B2uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v58, v53, self->_memoryPressureEvents, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v58, 8 * v53, CFSTR("_memoryPressureEvents"));
      free(v58);
    }
    v59 = -[NSMutableArray count](self->_sharedCaches, "count");
    if (v59)
    {
      v155 = 0u;
      v156 = 0u;
      v153 = 0u;
      v154 = 0u;
      v60 = self->_sharedCaches;
      v61 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v60, "countByEnumeratingWithState:objects:count:", &v153, v200, 16);
      if (v61)
      {
        v62 = *(_QWORD *)v154;
        do
        {
          for (kk = 0; kk != v61; ++kk)
          {
            if (*(_QWORD *)v154 != v62)
              objc_enumerationMutation(v60);
            objc_msgSend(*(id *)(*((_QWORD *)&v153 + 1) + 8 * kk), "addSelfToSerializationDictionary:", v7);
          }
          v61 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v60, "countByEnumeratingWithState:objects:count:", &v153, v200, 16);
        }
        while (v61);
      }

      v64 = malloc_type_malloc(8 * v59, 0x6CE3C19AuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v64, v59, self->_sharedCaches, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v64, 8 * v59, CFSTR("_sharedCaches"));
      free(v64);
    }
    v65 = -[NSMutableArray count](self->_kernelCaches, "count");
    if (v65)
    {
      v151 = 0u;
      v152 = 0u;
      v149 = 0u;
      v150 = 0u;
      v66 = self->_kernelCaches;
      v67 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v66, "countByEnumeratingWithState:objects:count:", &v149, v199, 16);
      if (v67)
      {
        v68 = *(_QWORD *)v150;
        do
        {
          for (mm = 0; mm != v67; ++mm)
          {
            if (*(_QWORD *)v150 != v68)
              objc_enumerationMutation(v66);
            objc_msgSend(*(id *)(*((_QWORD *)&v149 + 1) + 8 * mm), "addSelfToSerializationDictionary:", v7);
          }
          v67 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v66, "countByEnumeratingWithState:objects:count:", &v149, v199, 16);
        }
        while (v67);
      }

      v70 = malloc_type_malloc(8 * v65, 0x8C6DE26DuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v70, v65, self->_kernelCaches, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v70, 8 * v65, CFSTR("_kernelCaches"));
      free(v70);
    }
    v71 = -[NSMutableArray count](self->_exclaves, "count");
    if (v71)
    {
      v147 = 0u;
      v148 = 0u;
      v145 = 0u;
      v146 = 0u;
      v72 = self->_exclaves;
      v73 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v72, "countByEnumeratingWithState:objects:count:", &v145, v198, 16);
      if (v73)
      {
        v74 = *(_QWORD *)v146;
        do
        {
          for (nn = 0; nn != v73; ++nn)
          {
            if (*(_QWORD *)v146 != v74)
              objc_enumerationMutation(v72);
            objc_msgSend(*(id *)(*((_QWORD *)&v145 + 1) + 8 * nn), "addSelfToSerializationDictionary:", v7);
          }
          v73 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v72, "countByEnumeratingWithState:objects:count:", &v145, v198, 16);
        }
        while (v73);
      }

      v76 = malloc_type_malloc(8 * v71, 0x851BCC00uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v76, v71, self->_exclaves, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v76, 8 * v71, CFSTR("_exclaves"));
      free(v76);
    }
    v77 = -[NSArray count](self->_kperfTriggers, "count");
    if (v77)
    {
      v143 = 0u;
      v144 = 0u;
      v141 = 0u;
      v142 = 0u;
      v78 = self->_kperfTriggers;
      v79 = -[NSArray countByEnumeratingWithState:objects:count:](v78, "countByEnumeratingWithState:objects:count:", &v141, v197, 16);
      if (v79)
      {
        v80 = *(_QWORD *)v142;
        do
        {
          for (i1 = 0; i1 != v79; ++i1)
          {
            if (*(_QWORD *)v142 != v80)
              objc_enumerationMutation(v78);
            objc_msgSend(*(id *)(*((_QWORD *)&v141 + 1) + 8 * i1), "addSelfToSerializationDictionary:", v7);
          }
          v79 = -[NSArray countByEnumeratingWithState:objects:count:](v78, "countByEnumeratingWithState:objects:count:", &v141, v197, 16);
        }
        while (v79);
      }

      v82 = malloc_type_malloc(8 * v77, 0xF2CFFBEBuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v82, v77, self->_kperfTriggers, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v82, 8 * v77, CFSTR("_kperfTriggers"));
      free(v82);
    }
    v83 = -[NSArray count](self->_models, "count");
    if (v83)
    {
      v139 = 0u;
      v140 = 0u;
      v137 = 0u;
      v138 = 0u;
      v84 = self->_models;
      v85 = -[NSArray countByEnumeratingWithState:objects:count:](v84, "countByEnumeratingWithState:objects:count:", &v137, v196, 16);
      if (v85)
      {
        v86 = *(_QWORD *)v138;
        do
        {
          for (i2 = 0; i2 != v85; ++i2)
          {
            if (*(_QWORD *)v138 != v86)
              objc_enumerationMutation(v84);
            objc_msgSend(*(id *)(*((_QWORD *)&v137 + 1) + 8 * i2), "addSelfToSerializationDictionary:", v7);
          }
          v85 = -[NSArray countByEnumeratingWithState:objects:count:](v84, "countByEnumeratingWithState:objects:count:", &v137, v196, 16);
        }
        while (v85);
      }

      v88 = malloc_type_malloc(8 * v83, 0x4632903EuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v88, v83, self->_models, v7);
      objc_msgSend(v4, "encodeBytes:length:forKey:", v88, 8 * v83, CFSTR("_models"));
      free(v88);
    }
    v89 = self->_mountStatusTracker;
    v90 = v89;
    if (v89)
    {
      -[SAMountStatusTracker addSelfToSerializationDictionary:](v89, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v90, v7), CFSTR("_mountStatusTracker"));
    }

    v91 = self->_wsDataStore;
    v92 = v91;
    if (v91)
    {
      -[SAWSUpdateDataStore addSelfToSerializationDictionary:](v91, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v92, v7), CFSTR("_wsDataStore"));
    }

    v93 = self->_timeWhenTransitionedToSamplingAllProcesses;
    v94 = v93;
    if (v93)
    {
      -[SATimestamp addSelfToSerializationDictionary:](v93, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v94, v7), CFSTR("_timeWhenTransitionedToSamplingAllProcesses"));
    }

    v95 = self->_timeWhenTransitionedToSamplingAllThreads;
    v96 = v95;
    if (v95)
    {
      -[SATimestamp addSelfToSerializationDictionary:](v95, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v96, v7), CFSTR("_timeWhenTransitionedToSamplingAllThreads"));
    }

    v97 = self->_cpuSignalHandlerStackLeafKernelFrame;
    v98 = v97;
    if (v97)
    {
      -[SAFrame addSelfToSerializationDictionary:](v97, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v98, v7), CFSTR("_cpuSignalHandlerStackLeafKernelFrame"));
    }

    v99 = self->_eventTimeRange;
    v100 = v99;
    if (v99)
    {
      -[SATimeRange addSelfToSerializationDictionary:](v99, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v100, v7), CFSTR("_eventTimeRange"));
    }

    v101 = self->_timestampOfLastStackshot;
    v102 = v101;
    if (v101)
    {
      -[SATimestamp addSelfToSerializationDictionary:](v101, "addSelfToSerializationDictionary:", v7);
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v102, v7), CFSTR("_timestampOfLastStackshot"));
    }

    if (-[NSMutableArray count](self->_sampleTimestamps, "count"))
    {
      v103 = -[NSMutableArray count](self->_sampleTimestamps, "count");
      if (v103)
      {
        v135 = 0u;
        v136 = 0u;
        v133 = 0u;
        v134 = 0u;
        v104 = self->_sampleTimestamps;
        v105 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v104, "countByEnumeratingWithState:objects:count:", &v133, v195, 16);
        if (v105)
        {
          v106 = *(_QWORD *)v134;
          do
          {
            for (i3 = 0; i3 != v105; ++i3)
            {
              if (*(_QWORD *)v134 != v106)
                objc_enumerationMutation(v104);
              objc_msgSend(*(id *)(*((_QWORD *)&v133 + 1) + 8 * i3), "addSelfToSerializationDictionary:", v7);
            }
            v105 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v104, "countByEnumeratingWithState:objects:count:", &v133, v195, 16);
          }
          while (v105);
        }

        v108 = malloc_type_malloc(8 * v103, 0x87D51222uLL);
        SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v108, v103, self->_sampleTimestamps, v7);
        objc_msgSend(v4, "encodeBytes:length:forKey:", v108, 8 * v103, CFSTR("_sampleTimestamps"));
        free(v108);
      }
    }
    else
    {
      objc_msgSend(v4, "encodeInt64:forKey:", self->_numSamples, CFSTR("_numSamples"));
      v111 = self->_startTime;
      v112 = v111;
      if (v111)
      {
        -[SATimestamp addSelfToSerializationDictionary:](v111, "addSelfToSerializationDictionary:", v7);
        objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v112, v7), CFSTR("_startTime"));
      }

      v113 = self->_endTime;
      v114 = v113;
      if (v113)
      {
        -[SATimestamp addSelfToSerializationDictionary:](v113, "addSelfToSerializationDictionary:", v7);
        objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v114, v7), CFSTR("_endTime"));
      }

    }
    SASerializableNewDataBufferDictionaryFromSerializationDictionary(v7);
    v115 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v4, "encodeObject:forKey:", v115, CFSTR("SerializedDataDictionary"));
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_lastWakeTime"), self->_lastWakeTime);
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_attemptedSamplingInterval"), self->_attemptedSamplingInterval);
    objc_msgSend(v4, "encodeObject:forKey:", self->_kextStat, CFSTR("_kextStat"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_customOutput, CFSTR("_customOutput"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_kernelVersion, CFSTR("_kernelVersion"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_osProductName, CFSTR("_osProductName"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_osProductVersion, CFSTR("_osProductVersion"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_osProductVersionExtra, CFSTR("_osProductVersionExtra"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_osBuildVersion, CFSTR("_osBuildVersion"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_arch.cpu_type, CFSTR("cpu_type"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_arch.cpu_subtype, CFSTR("cpu_subtype"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_machTimebase.numer, CFSTR("_machTimebase_numer"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_machTimebase.denom, CFSTR("_machTimebase_denom"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_workQueueSoftThreadLimit, CFSTR("_workQueueSoftThreadLimit"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_workQueueHardThreadLimit, CFSTR("_workQueueHardThreadLimit"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_hardwareModel, CFSTR("_hardwareModel"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_numActiveCPUs, CFSTR("_numActiveCPUs"));
    v117 = objc_getProperty(self, v116, 1032, 1);
    objc_msgSend(v4, "encodeObject:forKey:", v117, CFSTR("_clusterFlagsForCPUNumMapping"));

    objc_msgSend(v4, "encodeInt32:forKey:", self->_hwPageSize, CFSTR("_hwPageSize"));
    objc_msgSend(v4, "encodeInt32:forKey:", self->_vmPageSize, CFSTR("_vmPageSize"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_bootArgs, CFSTR("_bootArgs"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_systemAdvisoryLevels, CFSTR("_systemAdvisoryLevels"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_homeVolumeSpace, CFSTR("_homeVolumeSpace"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_nonDefaultFeatureFlags, CFSTR("_nonDefaultFeatureFlags"));
    objc_msgSend(v4, "encodeInt32:forKey:", LODWORD(self->_numOSCryptexFileExtents), CFSTR("_numOSCryptexFileExtents"));
    objc_msgSend(v4, "encodeBool:forKey:", self->_isRootInstalled, CFSTR("_isRootInstalled"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_installedRootNames, CFSTR("_installedRootNames"));
    if (self->_appleInternalIsKnown)
    {
      objc_msgSend(v4, "encodeBool:forKey:", self->_isAppleInternal, CFSTR("_isAppleInternal"));
      if (self->_hasInternalCarryDeviceDistinction)
        objc_msgSend(v4, "encodeBool:forKey:", self->_isInternalCarryDevice, CFSTR("_isInternalCarryDevice"));
    }
    objc_msgSend(v4, "encodeObject:forKey:", self->_automatedDeviceGroup, CFSTR("_automatedDeviceGroup"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_keyboardLanguages, CFSTR("_keyboardLanguages"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_preferredLanguages, CFSTR("_preferredLanguages"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_countryCode, CFSTR("_countryCode"));
    if (self->_hasHardwareKeyboardInfo)
      objc_msgSend(v4, "encodeBool:forKey:", self->_hardwareKeyboard, CFSTR("_hardwareKeyboard"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_numVnodesAllocated, CFSTR("_numVnodesAllocated"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_numVnodesFree, CFSTR("_numVnodesFree"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_numVnodesSoftLimit, CFSTR("_numVnodesSoftLimit"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_numVnodesHardLimit, CFSTR("_numVnodesHardLimit"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_activeTrials, CFSTR("_activeTrials"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_event, CFSTR("_event"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_eventNote, CFSTR("_eventNote"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_signature, CFSTR("_signature"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_actionTaken, CFSTR("_actionTaken"));
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_extraDuration"), self->_extraDuration);
    objc_msgSend(v4, "encodeObject:forKey:", self->_durationNote, CFSTR("_durationNote"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_stepsNote, CFSTR("_stepsNote"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_targetThreadId, CFSTR("_targetThreadId"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_targetDispatchQueueId, CFSTR("_targetDispatchQueueId"));
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_cpuUsed"), self->_cpuUsed);
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_cpuDuration"), self->_cpuDuration);
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_cpuLimit"), self->_cpuLimit);
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_cpuLimitDuration"), self->_cpuLimitDuration);
    objc_msgSend(v4, "encodeInt64:forKey:", self->_numWakeups, CFSTR("_numWakeups"));
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wakeupsDuration"), self->_wakeupsDuration);
    objc_msgSend(v4, "encodeInt64:forKey:", self->_numWakeupsLimit, CFSTR("_numWakeupsLimit"));
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wakeupsLimitDuration"), self->_wakeupsLimitDuration);
    objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_reportTimeThreshold"), self->_reportTimeThreshold);
    wrWorkflowName = self->_wrWorkflowName;
    if (wrWorkflowName)
    {
      objc_msgSend(v4, "encodeObject:forKey:", wrWorkflowName, CFSTR("_wrWorkflowName"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrError, CFSTR("_wrError"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrDiagnosticName, CFSTR("_wrDiagnosticName"));
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrWorkflowTimeoutDuration"), self->_wrWorkflowTimeoutDuration);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrWorkflowDurationThreshold"), self->_wrWorkflowDurationThreshold);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrWorkflowDuration"), self->_wrWorkflowDuration);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold"), self->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrWorkflowDurationOmittingNetworkBoundIntervals"), self->_wrWorkflowDurationOmittingNetworkBoundIntervals);
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrSignpostName, CFSTR("_wrSignpostName"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrSignpostSubsystem, CFSTR("_wrSignpostSubsystem"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrSignpostCategory, CFSTR("_wrSignpostCategory"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrTriggeringSignpostName, CFSTR("_wrTriggeringSignpostName"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrTriggeringSignpostSubsystem, CFSTR("_wrTriggeringSignpostSubsystem"));
      objc_msgSend(v4, "encodeObject:forKey:", self->_wrTriggeringSignpostCategory, CFSTR("_wrTriggeringSignpostCategory"));
      objc_msgSend(v4, "encodeInt64:forKey:", self->_wrSignpostCountThreshold, CFSTR("_wrSignpostCountThreshold"));
      objc_msgSend(v4, "encodeInt64:forKey:", self->_wrSignpostCount, CFSTR("_wrSignpostCount"));
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrSignpostDurationUnionThreshold"), self->_wrSignpostDurationUnionThreshold);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrSignpostDurationUnion"), self->_wrSignpostDurationUnion);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrSignpostDurationSumThreshold"), self->_wrSignpostDurationSumThreshold);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrSignpostDurationSum"), self->_wrSignpostDurationSum);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrSignpostDurationSingleThreshold"), self->_wrSignpostDurationSingleThreshold);
      objc_msgSend(v4, "encodeDouble:forKey:", CFSTR("_wrSignpostDurationSingle"), self->_wrSignpostDurationSingle);
    }
    objc_msgSend(v4, "encodeInt32:forKey:", self->_targetProcessId, CFSTR("_targetProcessId"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_targetHIDEventMachAbs, CFSTR("_targetHIDEventMachAbs"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_targetHIDEventEndMachAbs, CFSTR("_targetHIDEventEndMachAbs"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_dataSource, CFSTR("_dataSource"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_dataStyle, CFSTR("_dataStyle"));
    objc_msgSend(v4, "encodeObject:forKey:", self->_reason, CFSTR("_reason"));
    objc_msgSend(v4, "encodeBool:forKey:", self->_hidEventsHaveHighFidelityTimelines, CFSTR("_hidEventsHaveHighFidelityTimelines"));
    previousSAVersions = self->_previousSAVersions;
    if (previousSAVersions)
    {
      v120 = -[NSArray mutableCopy](previousSAVersions, "mutableCopy");
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", 1);
      v120 = objc_claimAutoreleasedReturnValue();
    }
    v121 = (void *)v120;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", 379.0);
    v122 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v121, "addObject:", v122);

    objc_msgSend(v4, "encodeObject:forKey:", v121, CFSTR("_previousSAVersions"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_gpuRestartCount, CFSTR("_gpuRestartCount"));
    objc_msgSend(v4, "encodeInt64:forKey:", self->_gpuRestartLastMachAbs, CFSTR("_gpuRestartLastMachAbs"));
    objc_msgSend(v4, "encodeBool:forKey:", self->_hasEnterprisePersona, CFSTR("_hasEnterprisePersona"));
    -[SATask bundleBuildVersion](self->_targetProcess, "bundleBuildVersion");
    v123 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v123, CFSTR("_targetProcessBundleVersion"));

    -[SATask bundleShortVersion](self->_targetProcess, "bundleShortVersion");
    v124 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v124, CFSTR("_targetProcessBundleShortVersion"));

    -[SATask bundleBuildVersion](self->_targetProcess, "bundleBuildVersion");
    v125 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v125, CFSTR("_targetProcessBundleBuildVersion"));

    -[SATask bundleProjectName](self->_targetProcess, "bundleProjectName");
    v126 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v126, CFSTR("_targetProcessBundleProjectName"));

    -[SATask bundleSourceVersion](self->_targetProcess, "bundleSourceVersion");
    v127 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v127, CFSTR("_targetProcessBundleSourceVersion"));

    -[SATask bundleProductBuildVersion](self->_targetProcess, "bundleProductBuildVersion");
    v128 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v128, CFSTR("_targetProcessBundleProductBuildVersion"));

    -[SATask bundleIdentifier](self->_targetProcess, "bundleIdentifier");
    v129 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v129, CFSTR("_targetProcessBundleId"));

    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%llu"), -[SATask adamID](self->_targetProcess, "adamID"));
    v130 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v130, CFSTR("_targetProcessCommerceAppID"));

    -[SATask installerVersionID](self->_targetProcess, "installerVersionID");
    v131 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v131, CFSTR("_targetProcessCommerceExternalID"));

    -[SATask vendorID](self->_targetProcess, "vendorID");
    v132 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "encodeObject:forKey:", v132, CFSTR("_targetProcessVendorID"));

    _Block_object_dispose(buf, 8);
    objc_autoreleasePoolPop(v6);
  }
  else
  {
    v109 = *__error();
    _sa_logt();
    v110 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v110, OS_LOG_TYPE_ERROR, "Invalid encoder", buf, 2u);
    }

    *__error() = v109;
  }

}

uint64_t __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke(uint64_t result)
{
  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
  return result;
}

void __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke_2(uint64_t *a1, void *a2)
{
  uint64_t v3;
  id v4;
  uint64_t v5;

  v3 = a1[4];
  v4 = a2;
  objc_msgSend(v4, "addSelfToSerializationDictionary:", v3);
  v5 = SASerializableIndexForPointerFromSerializationDictionary(v4, (void *)a1[4]);

  *(_QWORD *)(a1[6] + 8 * (*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24))++) = v5;
}

- (SASampleStore)initWithCoder:(id)a3
{
  id v4;
  uint64_t v5;
  NSString *osProductVersion;
  uint64_t v7;
  NSString *osProductVersionExtra;
  uint64_t v9;
  NSString *osBuildVersion;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSArray *previousSAVersions;
  void *v16;
  void *v17;
  uint64_t v18;
  NSArray *v19;
  uint64_t v20;
  NSString *osProductName;
  char v22;
  uint64_t v23;
  NSString *reason;
  double v25;
  double v26;
  uint64_t v27;
  NSString *kextStat;
  uint64_t v29;
  NSString *customOutput;
  uint64_t v31;
  NSString *kernelVersion;
  uint64_t v33;
  NSString *hardwareModel;
  void *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  NSDictionary *clusterFlagsForCPUNumMapping;
  uint64_t v40;
  NSString *bootArgs;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  NSDictionary *systemAdvisoryLevels;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  NSDictionary *homeVolumeSpace;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  NSDictionary *nonDefaultFeatureFlags;
  void *v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  NSArray *keyboardLanguages;
  void *v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  NSArray *preferredLanguages;
  uint64_t v70;
  NSString *countryCode;
  void *v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  NSArray *installedRootNames;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  NSDictionary *activeTrials;
  uint64_t v84;
  NSString *automatedDeviceGroup;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  uint64_t v93;
  NSString *event;
  uint64_t v95;
  NSString *eventNote;
  uint64_t v97;
  NSString *signature;
  uint64_t v99;
  NSString *actionTaken;
  double v101;
  uint64_t v102;
  NSString *durationNote;
  uint64_t v104;
  NSString *stepsNote;
  int v106;
  NSObject *v107;
  SASampleStore *v108;
  _BYTE *IsEmbedded;
  uint64_t *v110;
  void *v111;
  id v112;
  uint64_t v113;
  NSString *v114;
  void *v115;
  int v116;
  char v117;
  char v118;
  SASampleStore *v119;
  uint64_t v120;
  uint64_t v121;
  NSString *v122;
  double v123;
  double v124;
  uint64_t v125;
  NSString *v126;
  uint64_t v127;
  NSString *v128;
  uint64_t v129;
  NSString *v130;
  uint64_t v131;
  NSString *v132;
  uint64_t v133;
  NSString *v134;
  uint64_t v135;
  NSString *v136;
  uint64_t v137;
  NSString *v138;
  unsigned int v139;
  int v140;
  uint64_t v141;
  NSString *v142;
  uint64_t v143;
  NSString *v144;
  SATimeRange *v145;
  SATimestamp *v146;
  uint64_t v147;
  NSString *v148;
  NSString *v149;
  double v150;
  uint64_t v151;
  NSString *v152;
  uint64_t v153;
  NSString *v154;
  double v155;
  uint64_t v156;
  SATimestamp *v157;
  void *v158;
  uint64_t v159;
  uint64_t v160;
  void *v161;
  id v162;
  uint64_t v163;
  uint64_t v164;
  id v165;
  id v166;
  id v167;
  id v168;
  unint64_t v169;
  uint64_t v170;
  NSMutableDictionary *v171;
  uint64_t v172;
  NSMutableDictionary *v173;
  unint64_t v174;
  void *v175;
  void *v176;
  id v177;
  const char *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t m;
  id v182;
  id v183;
  unint64_t v184;
  void *v185;
  void *v186;
  void *v187;
  id v188;
  const char *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t n;
  id v193;
  id v194;
  const char *v195;
  void *v196;
  uint64_t v197;
  void *v198;
  void *v199;
  const char *v200;
  void *v201;
  void *v202;
  void *v203;
  const char *v204;
  void *v205;
  const char *v206;
  void *v207;
  SATask *v208;
  const char *v209;
  void *v210;
  SATask *v211;
  const char *v212;
  void *v213;
  SATask *v214;
  const char *v215;
  void *v216;
  SATask *v217;
  void *v218;
  void *v219;
  const char *v220;
  void *v221;
  void *v222;
  id v223;
  void *v224;
  void *v225;
  uint64_t v226;
  SATask *v227;
  uint64_t v228;
  NSString *wrWorkflowName;
  uint64_t v230;
  NSError *wrError;
  uint64_t v232;
  NSString *wrDiagnosticName;
  double v234;
  double v235;
  double v236;
  double v237;
  double v238;
  uint64_t v239;
  NSString *wrSignpostName;
  uint64_t v241;
  NSString *wrSignpostSubsystem;
  uint64_t v243;
  NSString *wrSignpostCategory;
  uint64_t v245;
  NSString *wrTriggeringSignpostName;
  uint64_t v247;
  NSString *wrTriggeringSignpostSubsystem;
  uint64_t v249;
  NSString *wrTriggeringSignpostCategory;
  double v251;
  double v252;
  double v253;
  double v254;
  double v255;
  double v256;
  void *v257;
  uint64_t v258;
  uint64_t v259;
  void *v260;
  id v261;
  uint64_t v262;
  unint64_t v263;
  uint64_t v264;
  NSMutableDictionary *tasksByPid;
  uint64_t v266;
  NSMutableDictionary *tasksByUniquePid;
  void *v268;
  NSMutableDictionary *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t i;
  void *v273;
  uint64_t v274;
  NSMutableDictionary *v275;
  uint64_t v276;
  void *v277;
  const char *v278;
  void *v279;
  id Property;
  id v281;
  _BOOL4 v282;
  uint64_t v283;
  unint64_t v284;
  void *v285;
  const char *v286;
  void *v287;
  uint64_t v288;
  void *v289;
  void *v290;
  const char *v291;
  void *v292;
  void *v293;
  void *v294;
  const char *v295;
  void *v296;
  const char *v297;
  void *v298;
  SATask *targetProcess;
  const char *v300;
  void *v301;
  SATask *v302;
  const char *v303;
  void *v304;
  SATask *v305;
  const char *v306;
  void *v307;
  SATask *v308;
  void *v309;
  void *v310;
  const char *v311;
  void *v312;
  void *v313;
  id v314;
  void *v315;
  void *v316;
  uint64_t v317;
  SATask *v318;
  int v319;
  NSObject *v320;
  const char *v321;
  void *v322;
  SATask *v323;
  unint64_t v324;
  uint64_t v325;
  NSMutableArray *v326;
  void *v327;
  void *v328;
  id v329;
  const char *v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t ii;
  id v334;
  NSMutableArray *v335;
  id v336;
  unint64_t v337;
  uint64_t v338;
  NSMutableArray *v339;
  void *v340;
  void *v341;
  id v342;
  const char *v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t jj;
  id v347;
  NSMutableArray *v348;
  id v349;
  uint64_t v350;
  NSMutableArray *v351;
  unint64_t v352;
  void *v353;
  void *v354;
  id v355;
  const char *v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t kk;
  id v360;
  NSMutableArray *v361;
  id v362;
  NSMutableArray *v363;
  NSMutableArray *v364;
  unint64_t v365;
  void *v366;
  void *v367;
  unint64_t v368;
  void *v369;
  void *v370;
  const char *v371;
  void *v372;
  id v373;
  unint64_t v374;
  void *v375;
  uint64_t v376;
  SAWSUpdateDataStore *v377;
  SABinaryLocator *v378;
  SABinaryLocator *v379;
  uint64_t v380;
  const char *v381;
  id v382;
  id v383;
  const char *v384;
  id v385;
  id v386;
  id v387;
  uint64_t v388;
  NSMutableArray *v389;
  id v390;
  id v391;
  void *v392;
  int v393;
  NSObject *v394;
  const char *v395;
  void *v396;
  SATask *v397;
  const char *v398;
  void *v399;
  SATask *v400;
  id v401;
  uint64_t v402;
  unint64_t v403;
  void *v404;
  uint64_t v405;
  NSMutableArray *fanSpeeds;
  id v407;
  uint64_t v408;
  unint64_t v409;
  void *v410;
  uint64_t v411;
  NSMutableArray *powerModeTransitions;
  uint64_t v413;
  unint64_t v414;
  void *v415;
  uint64_t v416;
  NSMutableArray *hidEvents;
  id v418;
  uint64_t v419;
  unint64_t v420;
  void *v421;
  uint64_t v422;
  NSMutableArray *gestures;
  NSMutableArray *v424;
  NSMutableArray *v425;
  uint64_t v426;
  unint64_t v427;
  void *v428;
  uint64_t v429;
  NSMutableArray *ioEvents;
  NSMutableDictionary *v431;
  NSMutableDictionary *ioEventsByTid;
  NSMutableArray *v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t j;
  void *v437;
  NSMutableDictionary *v438;
  void *v439;
  void *v440;
  void *v441;
  NSMutableDictionary *v442;
  void *v443;
  id v444;
  uint64_t v445;
  unint64_t v446;
  void *v447;
  uint64_t v448;
  NSMutableArray *memoryPressureEvents;
  id v450;
  uint64_t v451;
  unint64_t v452;
  void *v453;
  uint64_t v454;
  NSMutableArray *sharedCaches;
  id v456;
  uint64_t v457;
  unint64_t v458;
  void *v459;
  uint64_t v460;
  NSMutableArray *kernelCaches;
  id v462;
  uint64_t v463;
  unint64_t v464;
  void *v465;
  uint64_t v466;
  NSMutableArray *exclaves;
  NSMutableArray *v468;
  NSMutableArray *v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t k;
  id v473;
  uint64_t v474;
  unint64_t v475;
  void *v476;
  uint64_t v477;
  NSArray *kperfTriggers;
  uint64_t v479;
  NSArray *v480;
  id v481;
  uint64_t v482;
  unint64_t v483;
  void *v484;
  uint64_t v485;
  NSArray *models;
  uint64_t v487;
  NSArray *v488;
  unint64_t v489;
  void *v490;
  SAMountStatusTracker *v491;
  SAMountStatusTracker *mountStatusTracker;
  unint64_t v493;
  void *v494;
  uint64_t v495;
  SAWSUpdateDataStore *wsDataStore;
  unint64_t v497;
  void *v498;
  uint64_t v499;
  SATimestamp *timeWhenTransitionedToSamplingAllProcesses;
  unint64_t v501;
  void *v502;
  uint64_t v503;
  SATimestamp *timeWhenTransitionedToSamplingAllThreads;
  unint64_t v505;
  void *v506;
  uint64_t v507;
  SAFrame *cpuSignalHandlerStackLeafKernelFrame;
  unint64_t v509;
  void *v510;
  uint64_t v511;
  SATimeRange *eventTimeRange;
  unint64_t v513;
  void *v514;
  uint64_t v515;
  SATimestamp *timestampOfLastStackshot;
  id v517;
  uint64_t v518;
  unint64_t v519;
  void *v520;
  uint64_t v521;
  NSMutableArray *sampleTimestamps;
  SASampleStore *v523;
  unint64_t v524;
  void *v525;
  uint64_t v526;
  SATimestamp *startTime;
  unint64_t v528;
  void *v529;
  uint64_t v530;
  SATimestamp *endTime;
  uint64_t v532;
  SABinaryLocator *v533;
  SABinaryLocator *binaryLocator;
  int v536;
  NSObject *v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  id v544;
  id v545;
  id v546;
  const __CFString *v547;
  id v548;
  id v549;
  _BYTE *v550;
  uint64_t *v551;
  void *context;
  _BYTE *v553;
  uint64_t v554;
  id v555;
  id v556;
  uint64_t *v557;
  uint64_t v558;
  uint64_t v559;
  id v560;
  void *v561;
  uint64_t v562;
  id v563;
  void *v564;
  void *v565;
  id v566;
  SASampleStore *v567;
  SASampleStore *v568;
  _QWORD v569[4];
  SASampleStore *v570;
  __int128 v571;
  __int128 v572;
  __int128 v573;
  __int128 v574;
  __int128 v575;
  __int128 v576;
  __int128 v577;
  __int128 v578;
  __int128 v579;
  __int128 v580;
  __int128 v581;
  __int128 v582;
  objc_super v583;
  _QWORD v584[5];
  id v585;
  __int128 *v586;
  _QWORD v587[5];
  __int128 v588;
  __int128 v589;
  __int128 v590;
  __int128 v591;
  __int128 v592;
  __int128 v593;
  __int128 v594;
  __int128 v595;
  __int128 v596;
  __int128 v597;
  __int128 v598;
  __int128 v599;
  __int128 v600;
  __int128 v601;
  __int128 v602;
  __int128 v603;
  __int128 v604;
  __int128 v605;
  __int128 v606;
  __int128 v607;
  unint64_t v608;
  unint64_t v609;
  unint64_t v610;
  unint64_t v611;
  unint64_t v612;
  _BYTE v613[128];
  _BYTE v614[128];
  uint8_t v615[128];
  __int128 v616;
  uint64_t v617;
  uint64_t (*v618)(uint64_t, uint64_t);
  void (*v619)(uint64_t);
  id v620;
  _BYTE v621[128];
  _BYTE v622[128];
  _BYTE v623[128];
  uint8_t v624[128];
  uint8_t buf[136];
  uint64_t v626;

  v626 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v561 = (void *)MEMORY[0x1BCCCC288]();
  v566 = v4;
  if (!v4)
  {
    v568 = self;
    v106 = *__error();
    _sa_logt();
    v107 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v107, OS_LOG_TYPE_ERROR, "Invalid decoder", buf, 2u);
    }

    v108 = 0;
    *__error() = v106;
    goto LABEL_193;
  }
  v583.receiver = self;
  v583.super_class = (Class)SASampleStore;
  v567 = -[SASampleStore init](&v583, sel_init);

  if (!v567)
  {
    gSASerializationEncodedVersionBeingDecoded();
    IsEmbedded = (_BYTE *)gSASerializationEncodedDataIsEmbedded();
    v111 = v561;
LABEL_300:
    *v110 = 0;
    *IsEmbedded = 0;
    v108 = v567;
    v568 = v108;
    goto LABEL_301;
  }
  v567->_dataGatheringOptions = 0;
  objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osProductVersion"));
  v5 = objc_claimAutoreleasedReturnValue();
  osProductVersion = v567->_osProductVersion;
  v567->_osProductVersion = (NSString *)v5;

  objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osProductVersionExtra"));
  v7 = objc_claimAutoreleasedReturnValue();
  osProductVersionExtra = v567->_osProductVersionExtra;
  v567->_osProductVersionExtra = (NSString *)v7;

  objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osBuildVersion"));
  v9 = objc_claimAutoreleasedReturnValue();
  osBuildVersion = v567->_osBuildVersion;
  v567->_osBuildVersion = (NSString *)v9;

  if (objc_msgSend(v4, "containsValueForKey:", CFSTR("_SASampleStore_Serialized_Version")))
  {
    v559 = objc_msgSend(v4, "decodeIntegerForKey:", CFSTR("_SASampleStore_Serialized_Version"));
    v557 = (uint64_t *)gSASerializationEncodedVersionBeingDecoded();
    *v557 = v559;
    v567->_dataSource = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_dataSource"));
    v567->_dataStyle = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_dataStyle"));
    v11 = (void *)MEMORY[0x1E0C99E60];
    v12 = objc_opt_class();
    objc_msgSend(v11, "setWithObjects:", v12, objc_opt_class(), 0);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeArrayOfObjectsOfClasses:forKey:", v13, CFSTR("_previousSAVersions"));
    v14 = objc_claimAutoreleasedReturnValue();
    previousSAVersions = v567->_previousSAVersions;
    v567->_previousSAVersions = (NSArray *)v14;

    if (!v567->_previousSAVersions)
    {
      v16 = (void *)MEMORY[0x1E0C99D20];
      objc_msgSend(MEMORY[0x1E0C99E38], "null");
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "arrayWithObject:", v17);
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = v567->_previousSAVersions;
      v567->_previousSAVersions = (NSArray *)v18;

    }
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osProductName"));
    v20 = objc_claimAutoreleasedReturnValue();
    osProductName = v567->_osProductName;
    v567->_osProductName = (NSString *)v20;

    SAIsEmbeddedPlatform(v567->_osProductName);
    v553 = (_BYTE *)gSASerializationEncodedDataIsEmbedded();
    *v553 = v22;
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_reason"));
    v23 = objc_claimAutoreleasedReturnValue();
    reason = v567->_reason;
    v567->_reason = (NSString *)v23;

    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_lastWakeTime"));
    v567->_lastWakeTime = v25;
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_attemptedSamplingInterval"));
    v567->_attemptedSamplingInterval = v26;
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_kextStat"));
    v27 = objc_claimAutoreleasedReturnValue();
    kextStat = v567->_kextStat;
    v567->_kextStat = (NSString *)v27;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_customOutput"));
    v29 = objc_claimAutoreleasedReturnValue();
    customOutput = v567->_customOutput;
    v567->_customOutput = (NSString *)v29;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_kernelVersion"));
    v31 = objc_claimAutoreleasedReturnValue();
    kernelVersion = v567->_kernelVersion;
    v567->_kernelVersion = (NSString *)v31;

    v567->_arch.cpu_type = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("cpu_type"));
    v567->_arch.cpu_subtype = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("cpu_subtype"));
    v567->_machTimebase.numer = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_machTimebase_numer"));
    v567->_machTimebase.denom = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_machTimebase_denom"));
    v567->_workQueueSoftThreadLimit = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_workQueueSoftThreadLimit"));
    v567->_workQueueHardThreadLimit = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_workQueueHardThreadLimit"));
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_hardwareModel"));
    v33 = objc_claimAutoreleasedReturnValue();
    hardwareModel = v567->_hardwareModel;
    v567->_hardwareModel = (NSString *)v33;

    v567->_numActiveCPUs = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_numActiveCPUs"));
    v35 = (void *)MEMORY[0x1E0C99E60];
    v36 = objc_opt_class();
    objc_msgSend(v35, "setWithObjects:", v36, objc_opt_class(), 0);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v37, CFSTR("_clusterFlagsForCPUNumMapping"));
    v38 = objc_claimAutoreleasedReturnValue();
    clusterFlagsForCPUNumMapping = v567->_clusterFlagsForCPUNumMapping;
    v567->_clusterFlagsForCPUNumMapping = (NSDictionary *)v38;

    v567->_hwPageSize = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_hwPageSize"));
    v567->_vmPageSize = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_vmPageSize"));
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_bootArgs"));
    v40 = objc_claimAutoreleasedReturnValue();
    bootArgs = v567->_bootArgs;
    v567->_bootArgs = (NSString *)v40;

    v42 = (void *)MEMORY[0x1E0C99E60];
    v43 = objc_opt_class();
    v44 = objc_opt_class();
    objc_msgSend(v42, "setWithObjects:", v43, v44, objc_opt_class(), 0);
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v45, CFSTR("_systemAdvisoryLevels"));
    v46 = objc_claimAutoreleasedReturnValue();
    systemAdvisoryLevels = v567->_systemAdvisoryLevels;
    v567->_systemAdvisoryLevels = (NSDictionary *)v46;

    v48 = (void *)MEMORY[0x1E0C99E60];
    v49 = objc_opt_class();
    v50 = objc_opt_class();
    objc_msgSend(v48, "setWithObjects:", v49, v50, objc_opt_class(), 0);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v51, CFSTR("_homeVolumeSpace"));
    v52 = objc_claimAutoreleasedReturnValue();
    homeVolumeSpace = v567->_homeVolumeSpace;
    v567->_homeVolumeSpace = (NSDictionary *)v52;

    v54 = (void *)MEMORY[0x1E0C99E60];
    v55 = objc_opt_class();
    v56 = objc_opt_class();
    objc_msgSend(v54, "setWithObjects:", v55, v56, objc_opt_class(), 0);
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v57, CFSTR("_nonDefaultFeatureFlags"));
    v58 = objc_claimAutoreleasedReturnValue();
    nonDefaultFeatureFlags = v567->_nonDefaultFeatureFlags;
    v567->_nonDefaultFeatureFlags = (NSDictionary *)v58;

    v567->_numOSCryptexFileExtents = (int)objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_numOSCryptexFileExtents"));
    v60 = (void *)MEMORY[0x1E0C99E60];
    v61 = objc_opt_class();
    objc_msgSend(v60, "setWithObjects:", v61, objc_opt_class(), 0);
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v62, CFSTR("_keyboardLanguages"));
    v63 = objc_claimAutoreleasedReturnValue();
    keyboardLanguages = v567->_keyboardLanguages;
    v567->_keyboardLanguages = (NSArray *)v63;

    v65 = (void *)MEMORY[0x1E0C99E60];
    v66 = objc_opt_class();
    objc_msgSend(v65, "setWithObjects:", v66, objc_opt_class(), 0);
    v67 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v67, CFSTR("_preferredLanguages"));
    v68 = objc_claimAutoreleasedReturnValue();
    preferredLanguages = v567->_preferredLanguages;
    v567->_preferredLanguages = (NSArray *)v68;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_countryCode"));
    v70 = objc_claimAutoreleasedReturnValue();
    countryCode = v567->_countryCode;
    v567->_countryCode = (NSString *)v70;

    v567->_isRootInstalled = objc_msgSend(v4, "decodeBoolForKey:", CFSTR("_isRootInstalled"));
    v72 = (void *)MEMORY[0x1E0C99E60];
    v73 = objc_opt_class();
    objc_msgSend(v72, "setWithObjects:", v73, objc_opt_class(), 0);
    v74 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v74, CFSTR("_installedRootNames"));
    v75 = objc_claimAutoreleasedReturnValue();
    installedRootNames = v567->_installedRootNames;
    v567->_installedRootNames = (NSArray *)v75;

    if (-[NSArray count](v567->_installedRootNames, "count"))
      v567->_isRootInstalled = 1;
    v77 = (void *)MEMORY[0x1E0C99E60];
    v78 = objc_opt_class();
    v79 = objc_opt_class();
    v80 = objc_opt_class();
    objc_msgSend(v77, "setWithObjects:", v78, v79, v80, objc_opt_class(), 0);
    v81 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v81, CFSTR("_activeTrials"));
    v82 = objc_claimAutoreleasedReturnValue();
    activeTrials = v567->_activeTrials;
    v567->_activeTrials = (NSDictionary *)v82;

    if (objc_msgSend(v4, "containsValueForKey:", CFSTR("_isAppleInternal")))
    {
      v567->_appleInternalIsKnown = 1;
      v567->_isAppleInternal = objc_msgSend(v4, "decodeBoolForKey:", CFSTR("_isAppleInternal"));
      if (objc_msgSend(v4, "containsValueForKey:", CFSTR("_isInternalCarryDevice")))
      {
        v567->_hasInternalCarryDeviceDistinction = 1;
        v567->_isInternalCarryDevice = objc_msgSend(v4, "decodeBoolForKey:", CFSTR("_isInternalCarryDevice"));
      }
    }
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_automatedDeviceGroup"));
    v84 = objc_claimAutoreleasedReturnValue();
    automatedDeviceGroup = v567->_automatedDeviceGroup;
    v567->_automatedDeviceGroup = (NSString *)v84;

    if (objc_msgSend(v4, "containsValueForKey:", CFSTR("_hardwareKeyboard")))
    {
      v567->_hardwareKeyboard = objc_msgSend(v4, "decodeBoolForKey:", CFSTR("_hardwareKeyboard"));
      v567->_hasHardwareKeyboardInfo = 1;
    }
    v567->_numVnodesAllocated = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_numVnodesAllocated"));
    v567->_numVnodesFree = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_numVnodesFree"));
    v567->_numVnodesSoftLimit = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_numVnodesSoftLimit"));
    v567->_numVnodesHardLimit = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_numVnodesHardLimit"));
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_cpuUsed"));
    v567->_cpuUsed = v86;
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_cpuDuration"));
    v567->_cpuDuration = v87;
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_cpuLimit"));
    v567->_cpuLimit = v88;
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_cpuLimitDuration"));
    v567->_cpuLimitDuration = v89;
    v567->_numWakeups = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_numWakeups"));
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wakeupsDuration"));
    v567->_wakeupsDuration = v90;
    v567->_numWakeupsLimit = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_numWakeupsLimit"));
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wakeupsLimitDuration"));
    v567->_wakeupsLimitDuration = v91;
    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_reportTimeThreshold"));
    v567->_reportTimeThreshold = v92;
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_event"));
    v93 = objc_claimAutoreleasedReturnValue();
    event = v567->_event;
    v567->_event = (NSString *)v93;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_eventNote"));
    v95 = objc_claimAutoreleasedReturnValue();
    eventNote = v567->_eventNote;
    v567->_eventNote = (NSString *)v95;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_signature"));
    v97 = objc_claimAutoreleasedReturnValue();
    signature = v567->_signature;
    v567->_signature = (NSString *)v97;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_actionTaken"));
    v99 = objc_claimAutoreleasedReturnValue();
    actionTaken = v567->_actionTaken;
    v567->_actionTaken = (NSString *)v99;

    objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_extraDuration"));
    v567->_extraDuration = v101;
    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_durationNote"));
    v102 = objc_claimAutoreleasedReturnValue();
    durationNote = v567->_durationNote;
    v567->_durationNote = (NSString *)v102;

    objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_stepsNote"));
    v104 = objc_claimAutoreleasedReturnValue();
    stepsNote = v567->_stepsNote;
    v567->_stepsNote = (NSString *)v104;

    v567->_targetProcessId = objc_msgSend(v4, "decodeInt32ForKey:", CFSTR("_targetProcessId"));
    v567->_targetHIDEventMachAbs = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_targetHIDEventMachAbs"));
    v567->_targetHIDEventEndMachAbs = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_targetHIDEventEndMachAbs"));
    v567->_targetThreadId = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_targetThreadId"));
    v567->_targetDispatchQueueId = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_targetDispatchQueueId"));
    if (objc_msgSend(v4, "containsValueForKey:", CFSTR("_hidEventsHaveHighFidelityTimelines")))
    {
      v567->_hidEventsHaveHighFidelityTimelines = objc_msgSend(v4, "decodeBoolForKey:", CFSTR("_hidEventsHaveHighFidelityTimelines"));
    }
    else
    {
      -[SASampleStore osProductName](v567, "osProductName");
      v115 = (void *)objc_claimAutoreleasedReturnValue();
      v116 = SAIsEmbeddedPlatform(v115);

      if (v116)
        v567->_hidEventsHaveHighFidelityTimelines = 0;
      else
        v567->_hidEventsHaveHighFidelityTimelines = 1;
    }
    if (objc_msgSend(v4, "containsValueForKey:", CFSTR("_wrWorkflowName")))
    {
      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrWorkflowName"));
      v228 = objc_claimAutoreleasedReturnValue();
      wrWorkflowName = v567->_wrWorkflowName;
      v567->_wrWorkflowName = (NSString *)v228;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrError"));
      v230 = objc_claimAutoreleasedReturnValue();
      wrError = v567->_wrError;
      v567->_wrError = (NSError *)v230;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrDiagnosticName"));
      v232 = objc_claimAutoreleasedReturnValue();
      wrDiagnosticName = v567->_wrDiagnosticName;
      v567->_wrDiagnosticName = (NSString *)v232;

      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrWorkflowTimeoutDuration"));
      v567->_wrWorkflowTimeoutDuration = v234;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrWorkflowDurationThreshold"));
      v567->_wrWorkflowDurationThreshold = v235;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrWorkflowDuration"));
      v567->_wrWorkflowDuration = v236;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold"));
      v567->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold = v237;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrWorkflowDurationOmittingNetworkBoundIntervals"));
      v567->_wrWorkflowDurationOmittingNetworkBoundIntervals = v238;
      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrSignpostName"));
      v239 = objc_claimAutoreleasedReturnValue();
      wrSignpostName = v567->_wrSignpostName;
      v567->_wrSignpostName = (NSString *)v239;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrSignpostSubsystem"));
      v241 = objc_claimAutoreleasedReturnValue();
      wrSignpostSubsystem = v567->_wrSignpostSubsystem;
      v567->_wrSignpostSubsystem = (NSString *)v241;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrSignpostCategory"));
      v243 = objc_claimAutoreleasedReturnValue();
      wrSignpostCategory = v567->_wrSignpostCategory;
      v567->_wrSignpostCategory = (NSString *)v243;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrTriggeringSignpostName"));
      v245 = objc_claimAutoreleasedReturnValue();
      wrTriggeringSignpostName = v567->_wrTriggeringSignpostName;
      v567->_wrTriggeringSignpostName = (NSString *)v245;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrTriggeringSignpostSubsystem"));
      v247 = objc_claimAutoreleasedReturnValue();
      wrTriggeringSignpostSubsystem = v567->_wrTriggeringSignpostSubsystem;
      v567->_wrTriggeringSignpostSubsystem = (NSString *)v247;

      objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_wrTriggeringSignpostCategory"));
      v249 = objc_claimAutoreleasedReturnValue();
      wrTriggeringSignpostCategory = v567->_wrTriggeringSignpostCategory;
      v567->_wrTriggeringSignpostCategory = (NSString *)v249;

      v567->_wrSignpostCountThreshold = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_wrSignpostCountThreshold"));
      v567->_wrSignpostCount = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_wrSignpostCount"));
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrSignpostDurationUnionThreshold"));
      v567->_wrSignpostDurationUnionThreshold = v251;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrSignpostDurationUnion"));
      v567->_wrSignpostDurationUnion = v252;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrSignpostDurationSumThreshold"));
      v567->_wrSignpostDurationSumThreshold = v253;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrSignpostDurationSum"));
      v567->_wrSignpostDurationSum = v254;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrSignpostDurationSingleThreshold"));
      v567->_wrSignpostDurationSingleThreshold = v255;
      objc_msgSend(v4, "decodeDoubleForKey:", CFSTR("_wrSignpostDurationSingle"));
      v567->_wrSignpostDurationSingle = v256;
    }
    v567->_gpuRestartCount = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_gpuRestartCount"));
    v567->_gpuRestartLastMachAbs = objc_msgSend(v4, "decodeInt64ForKey:", CFSTR("_gpuRestartLastMachAbs"));
    v567->_hasEnterprisePersona = objc_msgSend(v4, "decodeBoolForKey:", CFSTR("_hasEnterprisePersona"));
    v257 = (void *)MEMORY[0x1E0C99E60];
    v258 = objc_opt_class();
    v259 = objc_opt_class();
    objc_msgSend(v257, "setWithObjects:", v258, v259, objc_opt_class(), 0);
    v260 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "decodeObjectOfClasses:forKey:", v260, CFSTR("SerializedDataDictionary"));
    v565 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v565)
    {
      +[SAException exceptionWithName:reason:userInfo:](SAException, "exceptionWithName:reason:userInfo:", CFSTR("Decoding failure"), CFSTR("nil dataDictionary"), 0);
      v545 = (id)objc_claimAutoreleasedReturnValue();
      objc_exception_throw(v545);
    }
    v563 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    *(_QWORD *)buf = 0;
    v261 = objc_retainAutorelease(v4);
    v262 = objc_msgSend(v261, "decodeBytesForKey:returnedLength:", CFSTR("_tasks"), buf);
    if (v262)
    {
      v263 = *(_QWORD *)buf;
      v264 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", *(_QWORD *)buf >> 3);
      tasksByPid = v567->_tasksByPid;
      v567->_tasksByPid = (NSMutableDictionary *)v264;

      v266 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", v263 >> 3);
      tasksByUniquePid = v567->_tasksByUniquePid;
      v567->_tasksByUniquePid = (NSMutableDictionary *)v266;

      v268 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v262, v263 >> 3, v563, v565, v268);
      v581 = 0u;
      v582 = 0u;
      v579 = 0u;
      v580 = 0u;
      v269 = (NSMutableDictionary *)(id)objc_claimAutoreleasedReturnValue();
      v270 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:](v269, "countByEnumeratingWithState:objects:count:", &v579, v615, 16);
      if (v270)
      {
        v271 = *(_QWORD *)v580;
        do
        {
          for (i = 0; i != v270; ++i)
          {
            if (*(_QWORD *)v580 != v271)
              objc_enumerationMutation(v269);
            v273 = *(void **)(*((_QWORD *)&v579 + 1) + 8 * i);
            -[SASampleStore addTask:]((uint64_t)v567, v273);
            -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:]((id *)v273, v567->_dataGatheringOptions, 0, 0, 0, v567->_additionalCSSymbolicatorFlags);
          }
          v270 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:](v269, "countByEnumeratingWithState:objects:count:", &v579, v615, 16);
        }
        while (v270);
      }

    }
    else
    {
      v274 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 0);
      v275 = v567->_tasksByPid;
      v567->_tasksByPid = (NSMutableDictionary *)v274;

      v276 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 0);
      v269 = v567->_tasksByUniquePid;
      v567->_tasksByUniquePid = (NSMutableDictionary *)v276;
    }

    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)v567, 0);
    -[SASampleStore lastTaskWithPid:](v567, 0);
    v277 = (void *)objc_claimAutoreleasedReturnValue();
    v279 = v277;
    if (v277)
      Property = objc_getProperty(v277, v278, 280, 1);
    else
      Property = 0;
    v281 = Property;
    v282 = objc_msgSend(v281, "count") == 0;

    if (v282)
    {
      *(_QWORD *)buf = 0;
      v283 = objc_msgSend(objc_retainAutorelease(v261), "decodeBytesForKey:returnedLength:", CFSTR("_rootKernelFrames"), buf);
      if (v283)
      {
        v284 = *(_QWORD *)buf;
        v285 = (void *)objc_opt_class();
        SASerializableNewMutableSetFromIndexList(v283, v284 >> 3, v563, v565, v285);
        v287 = (void *)objc_claimAutoreleasedReturnValue();
        if (v279
          || (-[NSMutableDictionary count](v567->_tasksByUniquePid, "count") ? (v288 = 0) : (v288 = -1),
              +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v288, 0, 0),
              v279 = (void *)objc_claimAutoreleasedReturnValue(),
              -[SASampleStore addTask:]((uint64_t)v567, v279),
              v279))
        {
          objc_setProperty_atomic(v279, v286, v287, 280);
        }
        -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:]((id *)v279, v567->_dataGatheringOptions, 0, 0, 0, v567->_additionalCSSymbolicatorFlags);

      }
    }

    if (v559 <= 19 && v567->_targetProcess)
    {
      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleVersion"));
      v289 = (void *)objc_claimAutoreleasedReturnValue();
      -[SATask mainBinary](v567->_targetProcess, "mainBinary");
      v290 = (void *)objc_claimAutoreleasedReturnValue();
      v292 = v290;
      if (v290)
        objc_setProperty_atomic_copy(v290, v291, v289, 96);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleShortVersion"));
      v293 = (void *)objc_claimAutoreleasedReturnValue();
      -[SATask mainBinary](v567->_targetProcess, "mainBinary");
      v294 = (void *)objc_claimAutoreleasedReturnValue();
      v296 = v294;
      if (v294)
        objc_setProperty_atomic_copy(v294, v295, v293, 104);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleBuildVersion"));
      v298 = (void *)objc_claimAutoreleasedReturnValue();
      targetProcess = v567->_targetProcess;
      if (targetProcess)
        objc_setProperty_atomic_copy(targetProcess, v297, v298, 112);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleProjectName"));
      v301 = (void *)objc_claimAutoreleasedReturnValue();
      v302 = v567->_targetProcess;
      if (v302)
        objc_setProperty_atomic_copy(v302, v300, v301, 120);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleSourceVersion"));
      v304 = (void *)objc_claimAutoreleasedReturnValue();
      v305 = v567->_targetProcess;
      if (v305)
        objc_setProperty_atomic_copy(v305, v303, v304, 128);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleProductBuildVersion"));
      v307 = (void *)objc_claimAutoreleasedReturnValue();
      v308 = v567->_targetProcess;
      if (v308)
        objc_setProperty_atomic_copy(v308, v306, v307, 136);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleId"));
      v309 = (void *)objc_claimAutoreleasedReturnValue();
      -[SATask mainBinary](v567->_targetProcess, "mainBinary");
      v310 = (void *)objc_claimAutoreleasedReturnValue();
      v312 = v310;
      if (v310)
        objc_setProperty_atomic_copy(v310, v311, v309, 88);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessCommerceAppID"));
      v313 = (void *)objc_claimAutoreleasedReturnValue();
      if (v313)
      {
        v314 = objc_alloc_init(MEMORY[0x1E0CB37F0]);
        objc_msgSend(v314, "numberFromString:", v313);
        v315 = (void *)objc_claimAutoreleasedReturnValue();
        v316 = v315;
        if (v315)
        {
          v317 = objc_msgSend(v315, "unsignedLongLongValue");
          v318 = v567->_targetProcess;
          if (v318)
            v318->_adamID = v317;
        }
        else
        {
          v393 = *__error();
          _sa_logt();
          v394 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v394, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v313;
            _os_log_fault_impl(&dword_1B9BE0000, v394, OS_LOG_TYPE_FAULT, "Unable to parse commerceAppID %@", buf, 0xCu);
          }

          *__error() = v393;
        }

      }
      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessCommerceExternalID"));
      v396 = (void *)objc_claimAutoreleasedReturnValue();
      v397 = v567->_targetProcess;
      if (v397)
        objc_setProperty_atomic_copy(v397, v395, v396, 168);

      objc_msgSend(v261, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessVendorID"));
      v399 = (void *)objc_claimAutoreleasedReturnValue();
      v400 = v567->_targetProcess;
      if (v400)
        objc_setProperty_atomic_copy(v400, v398, v399, 176);

    }
    *(_QWORD *)buf = 0;
    v401 = objc_retainAutorelease(v261);
    v402 = objc_msgSend(v401, "decodeBytesForKey:returnedLength:", CFSTR("_fanSpeeds"), buf);
    if (v402)
    {
      v403 = *(_QWORD *)buf;
      v404 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v402, v403 >> 3, v563, v565, v404);
      v405 = objc_claimAutoreleasedReturnValue();
      fanSpeeds = v567->_fanSpeeds;
      v567->_fanSpeeds = (NSMutableArray *)v405;
    }
    else
    {
      fanSpeeds = v567->_fanSpeeds;
      v567->_fanSpeeds = 0;
    }

    *(_QWORD *)buf = 0;
    v407 = objc_retainAutorelease(v401);
    v408 = objc_msgSend(v407, "decodeBytesForKey:returnedLength:", CFSTR("_powerModeTransitions"), buf);
    if (v408)
    {
      v409 = *(_QWORD *)buf;
      v410 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v408, v409 >> 3, v563, v565, v410);
      v411 = objc_claimAutoreleasedReturnValue();
      powerModeTransitions = v567->_powerModeTransitions;
      v567->_powerModeTransitions = (NSMutableArray *)v411;
    }
    else
    {
      powerModeTransitions = v567->_powerModeTransitions;
      v567->_powerModeTransitions = 0;
    }

    if (*v557 <= 33 && *v553)
    {
      *(_QWORD *)buf = 0;
      v413 = objc_msgSend(objc_retainAutorelease(v407), "decodeBytesForKey:returnedLength:", CFSTR("_hidEvents"), buf);
      if (!v413)
      {
        hidEvents = v567->_hidEvents;
        v567->_hidEvents = 0;
        goto LABEL_216;
      }
    }
    else
    {
      *(_QWORD *)buf = 0;
      v413 = objc_msgSend(objc_retainAutorelease(v407), "decodeBytesForKey:returnedLength:", CFSTR("_hidEvents"), buf);
      if (!v413)
      {
        hidEvents = v567->_hidEvents;
        v567->_hidEvents = 0;
        goto LABEL_216;
      }
    }
    v414 = *(_QWORD *)buf;
    v415 = (void *)objc_opt_class();
    SASerializableNewMutableArrayFromIndexList(v413, v414 >> 3, v563, v565, v415);
    v416 = objc_claimAutoreleasedReturnValue();
    hidEvents = v567->_hidEvents;
    v567->_hidEvents = (NSMutableArray *)v416;
LABEL_216:

    *(_QWORD *)buf = 0;
    v418 = objc_retainAutorelease(v407);
    v419 = objc_msgSend(v418, "decodeBytesForKey:returnedLength:", CFSTR("_gestures"), buf);
    if (v419)
    {
      v420 = *(_QWORD *)buf;
      v421 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v419, v420 >> 3, v563, v565, v421);
      v422 = objc_claimAutoreleasedReturnValue();
      gestures = v567->_gestures;
      v567->_gestures = (NSMutableArray *)v422;
    }
    else
    {
      gestures = v567->_gestures;
      v567->_gestures = 0;
    }

    if (!v567->_gestures)
    {
      v424 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
      v425 = v567->_gestures;
      v567->_gestures = v424;

    }
    *(_QWORD *)buf = 0;
    v556 = objc_retainAutorelease(v418);
    v426 = objc_msgSend(v556, "decodeBytesForKey:returnedLength:", CFSTR("_ioEvents"), buf);
    if (v426)
    {
      v427 = *(_QWORD *)buf;
      v428 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v426, v427 >> 3, v563, v565, v428);
      v429 = objc_claimAutoreleasedReturnValue();
      ioEvents = v567->_ioEvents;
      v567->_ioEvents = (NSMutableArray *)v429;
    }
    else
    {
      ioEvents = v567->_ioEvents;
      v567->_ioEvents = 0;
    }

    v431 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
    ioEventsByTid = v567->_ioEventsByTid;
    v567->_ioEventsByTid = v431;

    v577 = 0u;
    v578 = 0u;
    v575 = 0u;
    v576 = 0u;
    v433 = v567->_ioEvents;
    v434 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v433, "countByEnumeratingWithState:objects:count:", &v575, v614, 16);
    if (v434)
    {
      v435 = *(_QWORD *)v576;
      do
      {
        for (j = 0; j != v434; ++j)
        {
          if (*(_QWORD *)v576 != v435)
            objc_enumerationMutation(v433);
          v437 = *(void **)(*((_QWORD *)&v575 + 1) + 8 * j);
          v438 = v567->_ioEventsByTid;
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v437, "threadID"));
          v439 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSMutableDictionary objectForKeyedSubscript:](v438, "objectForKeyedSubscript:", v439);
          v440 = (void *)objc_claimAutoreleasedReturnValue();

          if (v440)
          {
            objc_msgSend(v440, "addObject:", v437);
          }
          else
          {
            v441 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithObjects:", v437, 0);
            v442 = v567->_ioEventsByTid;
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v437, "threadID"));
            v443 = (void *)objc_claimAutoreleasedReturnValue();
            -[NSMutableDictionary setObject:forKeyedSubscript:](v442, "setObject:forKeyedSubscript:", v441, v443);

          }
        }
        v434 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v433, "countByEnumeratingWithState:objects:count:", &v575, v614, 16);
      }
      while (v434);
    }

    *(_QWORD *)buf = 0;
    v444 = objc_retainAutorelease(v556);
    v445 = objc_msgSend(v444, "decodeBytesForKey:returnedLength:", CFSTR("_memoryPressureEvents"), buf);
    if (v445)
    {
      v446 = *(_QWORD *)buf;
      v447 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v445, v446 >> 3, v563, v565, v447);
      v448 = objc_claimAutoreleasedReturnValue();
      memoryPressureEvents = v567->_memoryPressureEvents;
      v567->_memoryPressureEvents = (NSMutableArray *)v448;
    }
    else
    {
      memoryPressureEvents = v567->_memoryPressureEvents;
      v567->_memoryPressureEvents = 0;
    }

    *(_QWORD *)buf = 0;
    v450 = objc_retainAutorelease(v444);
    v451 = objc_msgSend(v450, "decodeBytesForKey:returnedLength:", CFSTR("_sharedCaches"), buf);
    if (v451)
    {
      v452 = *(_QWORD *)buf;
      v453 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v451, v452 >> 3, v563, v565, v453);
      v454 = objc_claimAutoreleasedReturnValue();
      sharedCaches = v567->_sharedCaches;
      v567->_sharedCaches = (NSMutableArray *)v454;
    }
    else
    {
      sharedCaches = v567->_sharedCaches;
      v567->_sharedCaches = 0;
    }

    *(_QWORD *)buf = 0;
    v456 = objc_retainAutorelease(v450);
    v457 = objc_msgSend(v456, "decodeBytesForKey:returnedLength:", CFSTR("_kernelCaches"), buf);
    if (v457)
    {
      v458 = *(_QWORD *)buf;
      v459 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v457, v458 >> 3, v563, v565, v459);
      v460 = objc_claimAutoreleasedReturnValue();
      kernelCaches = v567->_kernelCaches;
      v567->_kernelCaches = (NSMutableArray *)v460;
    }
    else
    {
      kernelCaches = v567->_kernelCaches;
      v567->_kernelCaches = 0;
    }

    *(_QWORD *)buf = 0;
    v462 = objc_retainAutorelease(v456);
    v463 = objc_msgSend(v462, "decodeBytesForKey:returnedLength:", CFSTR("_exclaves"), buf);
    if (v463)
    {
      v464 = *(_QWORD *)buf;
      v465 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v463, v464 >> 3, v563, v565, v465);
      v466 = objc_claimAutoreleasedReturnValue();
      exclaves = v567->_exclaves;
      v567->_exclaves = (NSMutableArray *)v466;
    }
    else
    {
      exclaves = v567->_exclaves;
      v567->_exclaves = 0;
    }

    v468 = v567->_exclaves;
    if (v468)
    {
      v573 = 0u;
      v574 = 0u;
      v571 = 0u;
      v572 = 0u;
      v469 = v468;
      v470 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v469, "countByEnumeratingWithState:objects:count:", &v571, v613, 16);
      if (v470)
      {
        v471 = *(_QWORD *)v572;
        do
        {
          for (k = 0; k != v470; ++k)
          {
            if (*(_QWORD *)v572 != v471)
              objc_enumerationMutation(v469);
            -[SAExclave fixupFrameInstructionsWithNewInstructions:foundNewBinaryInfo:](*(_QWORD *)(*((_QWORD *)&v571 + 1) + 8 * k), 0, 0);
          }
          v470 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v469, "countByEnumeratingWithState:objects:count:", &v571, v613, 16);
        }
        while (v470);
      }

    }
    *(_QWORD *)buf = 0;
    v473 = objc_retainAutorelease(v462);
    v474 = objc_msgSend(v473, "decodeBytesForKey:returnedLength:", CFSTR("_kperfTriggers"), buf);
    if (v474)
    {
      v475 = *(_QWORD *)buf;
      v476 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v474, v475 >> 3, v563, v565, v476);
      v477 = objc_claimAutoreleasedReturnValue();
      kperfTriggers = v567->_kperfTriggers;
      v567->_kperfTriggers = (NSArray *)v477;
    }
    else
    {
      kperfTriggers = v567->_kperfTriggers;
      v567->_kperfTriggers = 0;
    }

    v479 = -[NSArray copy](v567->_kperfTriggers, "copy");
    v480 = v567->_kperfTriggers;
    v567->_kperfTriggers = (NSArray *)v479;

    *(_QWORD *)buf = 0;
    v481 = objc_retainAutorelease(v473);
    v482 = objc_msgSend(v481, "decodeBytesForKey:returnedLength:", CFSTR("_models"), buf);
    if (v482)
    {
      v483 = *(_QWORD *)buf;
      v484 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v482, v483 >> 3, v563, v565, v484);
      v485 = objc_claimAutoreleasedReturnValue();
      models = v567->_models;
      v567->_models = (NSArray *)v485;
    }
    else
    {
      models = v567->_models;
      v567->_models = 0;
    }

    v487 = -[NSArray copy](v567->_models, "copy");
    v488 = v567->_models;
    v567->_models = (NSArray *)v487;

    if (!objc_msgSend(v481, "containsValueForKey:", CFSTR("_mountStatusTracker"))
      || (v489 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_mountStatusTracker")), v489 == -1))
    {
      v491 = objc_alloc_init(SAMountStatusTracker);
    }
    else
    {
      v490 = (void *)objc_opt_class();
      SASerializableNonnullInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v489, v563, v565, v490);
      v491 = (SAMountStatusTracker *)objc_claimAutoreleasedReturnValue();
    }
    mountStatusTracker = v567->_mountStatusTracker;
    v567->_mountStatusTracker = v491;

    if (objc_msgSend(v481, "containsValueForKey:", CFSTR("_wsDataStore")))
    {
      v493 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_wsDataStore"));
      v494 = (void *)objc_opt_class();
      _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v493, v563, v565, v494, 0);
      v495 = objc_claimAutoreleasedReturnValue();
      wsDataStore = v567->_wsDataStore;
      v567->_wsDataStore = (SAWSUpdateDataStore *)v495;
    }
    else
    {
      wsDataStore = v567->_wsDataStore;
      v567->_wsDataStore = 0;
    }

    if (objc_msgSend(v481, "containsValueForKey:", CFSTR("_timeWhenTransitionedToSamplingAllProcesses")))
    {
      v497 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_timeWhenTransitionedToSamplingAllProcesses"));
      v498 = (void *)objc_opt_class();
      _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v497, v563, v565, v498, 0);
      v499 = objc_claimAutoreleasedReturnValue();
      timeWhenTransitionedToSamplingAllProcesses = v567->_timeWhenTransitionedToSamplingAllProcesses;
      v567->_timeWhenTransitionedToSamplingAllProcesses = (SATimestamp *)v499;
    }
    else
    {
      timeWhenTransitionedToSamplingAllProcesses = v567->_timeWhenTransitionedToSamplingAllProcesses;
      v567->_timeWhenTransitionedToSamplingAllProcesses = 0;
    }

    if (objc_msgSend(v481, "containsValueForKey:", CFSTR("_timeWhenTransitionedToSamplingAllThreads")))
    {
      v501 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_timeWhenTransitionedToSamplingAllThreads"));
      v502 = (void *)objc_opt_class();
      _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v501, v563, v565, v502, 0);
      v503 = objc_claimAutoreleasedReturnValue();
      timeWhenTransitionedToSamplingAllThreads = v567->_timeWhenTransitionedToSamplingAllThreads;
      v567->_timeWhenTransitionedToSamplingAllThreads = (SATimestamp *)v503;
    }
    else
    {
      timeWhenTransitionedToSamplingAllThreads = v567->_timeWhenTransitionedToSamplingAllThreads;
      v567->_timeWhenTransitionedToSamplingAllThreads = 0;
    }

    if (objc_msgSend(v481, "containsValueForKey:", CFSTR("_cpuSignalHandlerStackLeafKernelFrame")))
    {
      v505 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_cpuSignalHandlerStackLeafKernelFrame"));
      v506 = (void *)objc_opt_class();
      _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v505, v563, v565, v506, 0);
      v507 = objc_claimAutoreleasedReturnValue();
      cpuSignalHandlerStackLeafKernelFrame = v567->_cpuSignalHandlerStackLeafKernelFrame;
      v567->_cpuSignalHandlerStackLeafKernelFrame = (SAFrame *)v507;
    }
    else
    {
      cpuSignalHandlerStackLeafKernelFrame = v567->_cpuSignalHandlerStackLeafKernelFrame;
      v567->_cpuSignalHandlerStackLeafKernelFrame = 0;
    }

    if (objc_msgSend(v481, "containsValueForKey:", CFSTR("_eventTimeRange")))
    {
      v509 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_eventTimeRange"));
      v510 = (void *)objc_opt_class();
      _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v509, v563, v565, v510, 0);
      v511 = objc_claimAutoreleasedReturnValue();
      eventTimeRange = v567->_eventTimeRange;
      v567->_eventTimeRange = (SATimeRange *)v511;
    }
    else
    {
      eventTimeRange = v567->_eventTimeRange;
      v567->_eventTimeRange = 0;
    }

    if (objc_msgSend(v481, "containsValueForKey:", CFSTR("_timestampOfLastStackshot")))
    {
      v513 = objc_msgSend(v481, "decodeInt64ForKey:", CFSTR("_timestampOfLastStackshot"));
      v514 = (void *)objc_opt_class();
      _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v513, v563, v565, v514, 0);
      v515 = objc_claimAutoreleasedReturnValue();
      timestampOfLastStackshot = v567->_timestampOfLastStackshot;
      v567->_timestampOfLastStackshot = (SATimestamp *)v515;
    }
    else
    {
      timestampOfLastStackshot = v567->_timestampOfLastStackshot;
      v567->_timestampOfLastStackshot = 0;
    }

    *(_QWORD *)buf = 0;
    v517 = objc_retainAutorelease(v481);
    v518 = objc_msgSend(v517, "decodeBytesForKey:returnedLength:", CFSTR("_sampleTimestamps"), buf);
    if (v518)
    {
      v519 = *(_QWORD *)buf;
      v520 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v518, v519 >> 3, v563, v565, v520);
      v521 = objc_claimAutoreleasedReturnValue();
      sampleTimestamps = v567->_sampleTimestamps;
      v567->_sampleTimestamps = (NSMutableArray *)v521;
    }
    else
    {
      sampleTimestamps = v567->_sampleTimestamps;
      v567->_sampleTimestamps = 0;
    }

    v523 = v567;
    if (!v567->_sampleTimestamps)
    {
      if (objc_msgSend(v517, "containsValueForKey:", CFSTR("_startTime")))
      {
        v524 = objc_msgSend(v517, "decodeInt64ForKey:", CFSTR("_startTime"));
        v525 = (void *)objc_opt_class();
        _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v524, v563, v565, v525, 0);
        v526 = objc_claimAutoreleasedReturnValue();
        startTime = v567->_startTime;
        v567->_startTime = (SATimestamp *)v526;
      }
      else
      {
        startTime = v567->_startTime;
        v567->_startTime = 0;
      }

      if (objc_msgSend(v517, "containsValueForKey:", CFSTR("_endTime")))
      {
        v528 = objc_msgSend(v517, "decodeInt64ForKey:", CFSTR("_endTime"));
        v529 = (void *)objc_opt_class();
        _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v528, v563, v565, v529, 0);
        v530 = objc_claimAutoreleasedReturnValue();
        endTime = v567->_endTime;
        v567->_endTime = (SATimestamp *)v530;
      }
      else
      {
        endTime = v567->_endTime;
        v567->_endTime = 0;
      }

      v532 = objc_msgSend(v517, "decodeInt64ForKey:", CFSTR("_numSamples"));
      v523 = v567;
      v567->_numSamples = v532;
    }
    v523->_sampleOnlyMainThreads = 0;
    v523->_shouldGatherKextStat = 0;
    v533 = +[SABinaryLocator sharedBinaryLocator](SABinaryLocator, "sharedBinaryLocator");
    binaryLocator = v567->_binaryLocator;
    v567->_binaryLocator = v533;

    if (v567->_machTimebase.denom && v567->_machTimebase.numer)
    {
      v569[0] = MEMORY[0x1E0C809B0];
      v569[1] = 3221225472;
      v569[2] = __54__SASampleStore_SASampleStoreNSCoding__initWithCoder___block_invoke;
      v569[3] = &unk_1E7147610;
      v570 = v567;
      -[SASampleStore iterateAllTimestamps:]((uint64_t)v570, v569);

    }
    objc_msgSend(v563, "enumerateKeysAndObjectsUsingBlock:", &__block_literal_global_7);

    if (v559 >= 37)
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "WARNING: Binary version %lu is newer than SASampleStore's decoder version %lu. Some data in the original report may not be available in the reparsed report\n", v559, 36);
    v111 = v561;
    v110 = v557;
    IsEmbedded = v553;
    goto LABEL_300;
  }
  v112 = v4;
  context = (void *)MEMORY[0x1BCCCC288]();
  v567->_dataGatheringOptions = 0;
  if ((objc_msgSend(v112, "containsValueForKey:", CFSTR("_PASampleTimeSeriesDataStore_Serialized_Version")) & 1) == 0)
  {
    *(_QWORD *)gSASerializationEncodedVersionBeingDecoded() = 1;
    goto LABEL_306;
  }
  v562 = objc_msgSend(v112, "decodeIntegerForKey:", CFSTR("_PASampleTimeSeriesDataStore_Serialized_Version"));
  if (v562 >= 16)
  {
    v536 = *__error();
    _sa_logt();
    v537 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v537, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v616) = 134217984;
      *(_QWORD *)((char *)&v616 + 4) = v562;
      _os_log_error_impl(&dword_1B9BE0000, v537, OS_LOG_TYPE_ERROR, "encodedVersion %ld for PAStyleCoder", (uint8_t *)&v616, 0xCu);
    }

    *__error() = v536;
    _SASetCrashLogMessage(11214, "encodedVersion %ld for PAStyleCoder", v538, v539, v540, v541, v542, v543, v562);
    _os_crash();
    __break(1u);
  }
  v551 = (uint64_t *)gSASerializationEncodedVersionBeingDecoded();
  *v551 = v562;
  if (v562 <= 7)
  {
LABEL_306:
    +[SAException exceptionWithName:reason:userInfo:](SAException, "exceptionWithName:reason:userInfo:", CFSTR("Decoding failure"), CFSTR("Encoded version too old"), 0);
    v544 = (id)objc_claimAutoreleasedReturnValue();
    objc_exception_throw(v544);
  }
  if (objc_msgSend(v112, "containsValueForKey:", CFSTR("_osProductName")))
  {
    objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osProductName"));
    v113 = objc_claimAutoreleasedReturnValue();
    v114 = v567->_osProductName;
    v567->_osProductName = (NSString *)v113;
  }
  else
  {
    v114 = v567->_osProductName;
    v567->_osProductName = (NSString *)CFSTR("Mac OS X");
  }

  SAIsEmbeddedPlatform(v567->_osProductName);
  v550 = (_BYTE *)gSASerializationEncodedDataIsEmbedded();
  *v550 = v117;
  if (!objc_msgSend(v112, "containsValueForKey:", CFSTR("_dataSource")))
  {
    v120 = 1;
    v119 = v567;
    goto LABEL_33;
  }
  v118 = objc_msgSend(v112, "decodeInt64ForKey:", CFSTR("_dataSource"));
  if ((v118 & 2) != 0)
    v567->_dataSource |= 1uLL;
  v119 = v567;
  if ((v118 & 4) != 0)
  {
    v120 = v567->_dataSource | 2;
LABEL_33:
    v119->_dataSource = v120;
  }
  v119->_dataStyle = 2;
  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_reason"));
  v121 = objc_claimAutoreleasedReturnValue();
  v122 = v567->_reason;
  v567->_reason = (NSString *)v121;

  v123 = 0.0;
  if ((unint64_t)v562 >= 0xD)
    objc_msgSend(v112, "decodeDoubleForKey:", CFSTR("_lastWakeTime"), 0.0);
  v567->_lastWakeTime = v123;
  objc_msgSend(v112, "decodeDoubleForKey:", CFSTR("_attemptedSamplingInterval"));
  v567->_attemptedSamplingInterval = v124;
  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_kextStat"));
  v125 = objc_claimAutoreleasedReturnValue();
  v126 = v567->_kextStat;
  v567->_kextStat = (NSString *)v125;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_kernelVersion"));
  v127 = objc_claimAutoreleasedReturnValue();
  v128 = v567->_kernelVersion;
  v567->_kernelVersion = (NSString *)v127;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osProductVersion"));
  v129 = objc_claimAutoreleasedReturnValue();
  v130 = v567->_osProductVersion;
  v567->_osProductVersion = (NSString *)v129;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osProductVersionExtra"));
  v131 = objc_claimAutoreleasedReturnValue();
  v132 = v567->_osProductVersionExtra;
  v567->_osProductVersionExtra = (NSString *)v131;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_osBuildVersion"));
  v133 = objc_claimAutoreleasedReturnValue();
  v134 = v567->_osBuildVersion;
  v567->_osBuildVersion = (NSString *)v133;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_machineArchitecture"));
  v560 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  objc_msgSend(v560, "UTF8String");
  v567->_arch = (_CSArchitecture)CSArchitectureGetArchitectureForName();
  v567->_workQueueSoftThreadLimit = objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_workQueueSoftThreadLimit"));
  v567->_workQueueHardThreadLimit = objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_workQueueHardThreadLimit"));
  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_hardwareModel"));
  v135 = objc_claimAutoreleasedReturnValue();
  v136 = v567->_hardwareModel;
  v567->_hardwareModel = (NSString *)v135;

  v567->_numActiveCPUs = objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_numActiveCPUs"));
  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_bootArgs"));
  v137 = objc_claimAutoreleasedReturnValue();
  v138 = v567->_bootArgs;
  v567->_bootArgs = (NSString *)v137;

  v567->_targetThreadId = objc_msgSend(v112, "decodeInt64ForKey:", CFSTR("_targetThreadId"));
  v139 = objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_cpuPercent"));
  v140 = objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_cpuDuration"));
  v567->_cpuDuration = (double)v140;
  v567->_cpuUsed = (double)v139 * (double)v140 / 100.0;
  v567->_numWakeups = (int)objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_wakeupsPerSec"));
  v567->_wakeupsDuration = (double)(int)objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_wakeupsDuration"));
  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_event"));
  v141 = objc_claimAutoreleasedReturnValue();
  v142 = v567->_event;
  v567->_event = (NSString *)v141;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_eventNote"));
  v143 = objc_claimAutoreleasedReturnValue();
  v144 = v567->_eventNote;
  v567->_eventNote = (NSString *)v143;

  v145 = v567->_eventTimeRange;
  v567->_eventTimeRange = 0;

  v146 = v567->_timestampOfLastStackshot;
  v567->_timestampOfLastStackshot = 0;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_signature"));
  v147 = objc_claimAutoreleasedReturnValue();
  v148 = v567->_signature;
  v567->_signature = (NSString *)v147;

  v149 = v567->_actionTaken;
  v567->_actionTaken = 0;

  objc_msgSend(v112, "decodeDoubleForKey:", CFSTR("_extraDuration"));
  v567->_extraDuration = v150;
  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_durationNote"));
  v151 = objc_claimAutoreleasedReturnValue();
  v152 = v567->_durationNote;
  v567->_durationNote = (NSString *)v151;

  objc_msgSend(v112, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_stepsNote"));
  v153 = objc_claimAutoreleasedReturnValue();
  v154 = v567->_stepsNote;
  v567->_stepsNote = (NSString *)v153;

  v567->_targetProcessId = objc_msgSend(v112, "decodeInt32ForKey:", CFSTR("_targetProcessId"));
  objc_msgSend(v112, "decodeDoubleForKey:", CFSTR("_timeWhenTransitionedToSamplingAllProcesses"));
  if (v155 != 0.0)
  {
    +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, v155, 0.0, 0.0);
    v156 = objc_claimAutoreleasedReturnValue();
    v157 = v567->_timeWhenTransitionedToSamplingAllThreads;
    v567->_timeWhenTransitionedToSamplingAllThreads = (SATimestamp *)v156;

  }
  v158 = (void *)MEMORY[0x1E0C99E60];
  v159 = objc_opt_class();
  v160 = objc_opt_class();
  objc_msgSend(v158, "setWithObjects:", v159, v160, objc_opt_class(), 0);
  v161 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v112, "decodeObjectOfClasses:forKey:", v161, CFSTR("SerializedDataDictionary"));
  v564 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v564)
  {
    +[SAException exceptionWithName:reason:userInfo:](SAException, "exceptionWithName:reason:userInfo:", CFSTR("Decoding failure"), CFSTR("nil dataDictionary"), 0);
    v546 = (id)objc_claimAutoreleasedReturnValue();
    objc_exception_throw(v546);
  }
  v612 = 0;
  v611 = 0;
  v610 = 0;
  v609 = 0;
  v608 = 0;
  v162 = objc_retainAutorelease(v112);
  v163 = objc_msgSend(v162, "decodeBytesForKey:returnedLength:", CFSTR("TimeInsensitiveTaskIndices"), &v612);
  if (objc_msgSend(v162, "containsValueForKey:", CFSTR("RootKernelFrames")))
  {
    v164 = objc_msgSend(objc_retainAutorelease(v162), "decodeBytesForKey:returnedLength:", CFSTR("RootKernelFrames"), &v611);
  }
  else
  {
    v164 = 0;
    v611 = 0;
  }
  v165 = objc_retainAutorelease(v162);
  v554 = objc_msgSend(v165, "decodeBytesForKey:returnedLength:", CFSTR("SampleDataIndices"), &v610);
  v166 = objc_retainAutorelease(v165);
  v558 = objc_msgSend(v166, "decodeBytesForKey:returnedLength:", CFSTR("FanSpeedIndices"), &v609);
  v167 = objc_retainAutorelease(v166);
  v555 = (id)objc_msgSend(v167, "decodeBytesForKey:returnedLength:", CFSTR("HIDEventIndices"), &v608);
  if ((v612 & 7) != 0)
  {
    v547 = CFSTR("Unexpected task index array length");
    goto LABEL_313;
  }
  if ((v610 & 7) != 0)
  {
    v547 = CFSTR("Unexpected sample index array length");
    goto LABEL_313;
  }
  if ((v609 & 7) != 0)
  {
    v547 = CFSTR("Unexpected fan index array length");
    goto LABEL_313;
  }
  if ((v608 & 7) != 0)
  {
    v547 = CFSTR("Unexpected hid event array length");
LABEL_313:
    +[SAException exceptionWithName:reason:userInfo:](SAException, "exceptionWithName:reason:userInfo:", CFSTR("Decoding failure"), v547, 0);
    v548 = (id)objc_claimAutoreleasedReturnValue();
    objc_exception_throw(v548);
  }
  v168 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  if (v163)
  {
    v169 = v612;
    if (v612)
    {
      v170 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", v612 >> 3);
      v171 = v567->_tasksByPid;
      v567->_tasksByPid = (NSMutableDictionary *)v170;

      v172 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", v169 >> 3);
      v173 = v567->_tasksByUniquePid;
      v567->_tasksByUniquePid = (NSMutableDictionary *)v172;

      v174 = v612;
      v175 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v163, v174 >> 3, v168, v564, v175);
      v176 = (void *)objc_claimAutoreleasedReturnValue();
      v606 = 0u;
      v607 = 0u;
      v604 = 0u;
      v605 = 0u;
      v177 = v176;
      v179 = objc_msgSend(v177, "countByEnumeratingWithState:objects:count:", &v604, buf, 16);
      if (v179)
      {
        v180 = *(_QWORD *)v605;
        do
        {
          for (m = 0; m != v179; ++m)
          {
            if (*(_QWORD *)v605 != v180)
              objc_enumerationMutation(v177);
            v182 = *(id *)(*((_QWORD *)&v604 + 1) + 8 * m);
            if (v182)
              v182 = objc_getProperty(v182, v178, 8, 1);
            v183 = v182;
            -[SASampleStore addTask:]((uint64_t)v567, v183);

          }
          v179 = objc_msgSend(v177, "countByEnumeratingWithState:objects:count:", &v604, buf, 16);
        }
        while (v179);
      }

      -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)v567, 0);
    }
  }
  if (v164)
  {
    v184 = v611;
    v185 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E20]), "initWithCapacity:", v611 >> 3);
    v186 = (void *)objc_opt_class();
    SASerializableNewMutableSetFromIndexList(v164, v184 >> 3, v168, v564, v186);
    v187 = (void *)objc_claimAutoreleasedReturnValue();
    v602 = 0u;
    v603 = 0u;
    v600 = 0u;
    v601 = 0u;
    v188 = v187;
    v190 = objc_msgSend(v188, "countByEnumeratingWithState:objects:count:", &v600, v624, 16);
    if (v190)
    {
      v191 = *(_QWORD *)v601;
      do
      {
        for (n = 0; n != v190; ++n)
        {
          if (*(_QWORD *)v601 != v191)
            objc_enumerationMutation(v188);
          v193 = *(id *)(*((_QWORD *)&v600 + 1) + 8 * n);
          if (v193)
            v193 = objc_getProperty(v193, v189, 8, 1);
          v194 = v193;
          objc_msgSend(v185, "addObject:", v194);

        }
        v190 = objc_msgSend(v188, "countByEnumeratingWithState:objects:count:", &v600, v624, 16);
      }
      while (v190);
    }

    -[SASampleStore lastTaskWithPid:](v567, 0);
    v196 = (void *)objc_claimAutoreleasedReturnValue();
    if (v196
      || (-[NSMutableDictionary count](v567->_tasksByUniquePid, "count") ? (v197 = 0) : (v197 = -1),
          +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v197, 0, 0),
          v196 = (void *)objc_claimAutoreleasedReturnValue(),
          -[SASampleStore addTask:]((uint64_t)v567, v196),
          v196))
    {
      objc_setProperty_atomic(v196, v195, v185, 280);
    }

  }
  if (v567->_targetProcess)
  {
    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleVersion"));
    v198 = (void *)objc_claimAutoreleasedReturnValue();
    -[SATask mainBinary](v567->_targetProcess, "mainBinary");
    v199 = (void *)objc_claimAutoreleasedReturnValue();
    v201 = v199;
    if (v199)
      objc_setProperty_atomic_copy(v199, v200, v198, 96);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleShortVersion"));
    v202 = (void *)objc_claimAutoreleasedReturnValue();
    -[SATask mainBinary](v567->_targetProcess, "mainBinary");
    v203 = (void *)objc_claimAutoreleasedReturnValue();
    v205 = v203;
    if (v203)
      objc_setProperty_atomic_copy(v203, v204, v202, 104);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleBuildVersion"));
    v207 = (void *)objc_claimAutoreleasedReturnValue();
    v208 = v567->_targetProcess;
    if (v208)
      objc_setProperty_atomic_copy(v208, v206, v207, 112);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleProjectName"));
    v210 = (void *)objc_claimAutoreleasedReturnValue();
    v211 = v567->_targetProcess;
    if (v211)
      objc_setProperty_atomic_copy(v211, v209, v210, 120);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleSourceVersion"));
    v213 = (void *)objc_claimAutoreleasedReturnValue();
    v214 = v567->_targetProcess;
    if (v214)
      objc_setProperty_atomic_copy(v214, v212, v213, 128);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleProductBuildVersion"));
    v216 = (void *)objc_claimAutoreleasedReturnValue();
    v217 = v567->_targetProcess;
    if (v217)
      objc_setProperty_atomic_copy(v217, v215, v216, 136);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessBundleId"));
    v218 = (void *)objc_claimAutoreleasedReturnValue();
    -[SATask mainBinary](v567->_targetProcess, "mainBinary");
    v219 = (void *)objc_claimAutoreleasedReturnValue();
    v221 = v219;
    if (v219)
      objc_setProperty_atomic_copy(v219, v220, v218, 88);

    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessCommerceAppID"));
    v222 = (void *)objc_claimAutoreleasedReturnValue();
    if (v222)
    {
      v223 = objc_alloc_init(MEMORY[0x1E0CB37F0]);
      objc_msgSend(v223, "numberFromString:", v222);
      v224 = (void *)objc_claimAutoreleasedReturnValue();
      v225 = v224;
      if (v224)
      {
        v226 = objc_msgSend(v224, "unsignedLongLongValue");
        v227 = v567->_targetProcess;
        if (v227)
          v227->_adamID = v226;
      }
      else
      {
        v319 = *__error();
        _sa_logt();
        v320 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v320, OS_LOG_TYPE_FAULT))
        {
          LODWORD(v616) = 138412290;
          *(_QWORD *)((char *)&v616 + 4) = v222;
          _os_log_fault_impl(&dword_1B9BE0000, v320, OS_LOG_TYPE_FAULT, "Unable to parse commerceAppID %@", (uint8_t *)&v616, 0xCu);
        }

        *__error() = v319;
      }

    }
    objc_msgSend(v167, "decodeObjectOfClass:forKey:", objc_opt_class(), CFSTR("_targetProcessCommerceExternalID"));
    v322 = (void *)objc_claimAutoreleasedReturnValue();
    v323 = v567->_targetProcess;
    if (v323)
      objc_setProperty_atomic_copy(v323, v321, v322, 168);

  }
  if (v554)
  {
    v324 = v610;
    if (v610)
    {
      v325 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", v610 >> 3);
      v326 = v567->_sampleTimestamps;
      v567->_sampleTimestamps = (NSMutableArray *)v325;

      v327 = (void *)objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v554, v324 >> 3, v168, v564, v327);
      v328 = (void *)objc_claimAutoreleasedReturnValue();
      v598 = 0u;
      v599 = 0u;
      v596 = 0u;
      v597 = 0u;
      v329 = v328;
      v331 = objc_msgSend(v329, "countByEnumeratingWithState:objects:count:", &v596, v623, 16);
      if (v331)
      {
        v332 = *(_QWORD *)v597;
        do
        {
          for (ii = 0; ii != v331; ++ii)
          {
            if (*(_QWORD *)v597 != v332)
              objc_enumerationMutation(v329);
            v334 = *(id *)(*((_QWORD *)&v596 + 1) + 8 * ii);
            v335 = v567->_sampleTimestamps;
            if (v334)
              v334 = objc_getProperty(v334, v330, 8, 1);
            v336 = v334;
            -[NSMutableArray addObject:](v335, "addObject:", v336);

          }
          v331 = objc_msgSend(v329, "countByEnumeratingWithState:objects:count:", &v596, v623, 16);
        }
        while (v331);
      }

    }
  }
  if (v558)
  {
    v337 = v609;
    v338 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", v609 >> 3);
    v339 = v567->_fanSpeeds;
    v567->_fanSpeeds = (NSMutableArray *)v338;

    v340 = (void *)objc_opt_class();
    SASerializableNewMutableArrayFromIndexList(v558, v337 >> 3, v168, v564, v340);
    v341 = (void *)objc_claimAutoreleasedReturnValue();
    v594 = 0u;
    v595 = 0u;
    v592 = 0u;
    v593 = 0u;
    v342 = v341;
    v344 = objc_msgSend(v342, "countByEnumeratingWithState:objects:count:", &v592, v622, 16);
    if (v344)
    {
      v345 = *(_QWORD *)v593;
      do
      {
        for (jj = 0; jj != v344; ++jj)
        {
          if (*(_QWORD *)v593 != v345)
            objc_enumerationMutation(v342);
          v347 = *(id *)(*((_QWORD *)&v592 + 1) + 8 * jj);
          v348 = v567->_fanSpeeds;
          if (v347)
            v347 = objc_getProperty(v347, v343, 8, 1);
          v349 = v347;
          -[NSMutableArray addObject:](v348, "addObject:", v349);

        }
        v344 = objc_msgSend(v342, "countByEnumeratingWithState:objects:count:", &v592, v622, 16);
      }
      while (v344);
    }

  }
  if (v555)
  {
    v350 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", v608 >> 3);
    v351 = v567->_hidEvents;
    v567->_hidEvents = (NSMutableArray *)v350;

    v352 = v608;
    v353 = (void *)objc_opt_class();
    SASerializableNewMutableArrayFromIndexList((uint64_t)v555, v352 >> 3, v168, v564, v353);
    v354 = (void *)objc_claimAutoreleasedReturnValue();
    v590 = 0u;
    v591 = 0u;
    v588 = 0u;
    v589 = 0u;
    v355 = v354;
    v357 = objc_msgSend(v355, "countByEnumeratingWithState:objects:count:", &v588, v621, 16);
    if (v357)
    {
      v358 = *(_QWORD *)v589;
      do
      {
        for (kk = 0; kk != v357; ++kk)
        {
          if (*(_QWORD *)v589 != v358)
            objc_enumerationMutation(v355);
          v360 = *(id *)(*((_QWORD *)&v588 + 1) + 8 * kk);
          v361 = v567->_hidEvents;
          if (v360)
            v360 = objc_getProperty(v360, v356, 8, 1);
          v362 = v360;
          -[NSMutableArray addObject:](v361, "addObject:", v362);

        }
        v357 = objc_msgSend(v355, "countByEnumeratingWithState:objects:count:", &v588, v621, 16);
      }
      while (v357);
    }

  }
  v363 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v364 = v567->_gestures;
  v567->_gestures = v363;

  v365 = objc_msgSend(v167, "decodeInt64ForKey:", CFSTR("SymbolDataStoreIndex"));
  v366 = (void *)objc_opt_class();
  _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v365, v168, v564, v366, 0);
  v367 = (void *)objc_claimAutoreleasedReturnValue();
  v368 = objc_msgSend(v167, "decodeInt64ForKey:", CFSTR("MountStatusTrackerIndex"));
  v369 = (void *)objc_opt_class();
  _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v368, v168, v564, v369, 0);
  v370 = (void *)objc_claimAutoreleasedReturnValue();
  v372 = v370;
  if (!v370)
  {
    +[SAException exceptionWithName:reason:userInfo:](SAException, "exceptionWithName:reason:userInfo:", CFSTR("Decoding failure"), CFSTR("Could not deserialize mount status"), 0);
    v549 = (id)objc_claimAutoreleasedReturnValue();
    objc_exception_throw(v549);
  }
  v373 = objc_getProperty(v370, v371, 8, 1);
  objc_storeStrong((id *)&v567->_mountStatusTracker, v373);
  if (objc_msgSend(v167, "containsValueForKey:", CFSTR("WSUpdateDataStoreIndex")))
  {
    v374 = objc_msgSend(v167, "decodeInt64ForKey:", CFSTR("WSUpdateDataStoreIndex"));
    v375 = (void *)objc_opt_class();
    _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v374, v168, v564, v375, 0);
    v376 = objc_claimAutoreleasedReturnValue();
    v377 = v567->_wsDataStore;
    v567->_wsDataStore = (SAWSUpdateDataStore *)v376;
  }
  else
  {
    v377 = v567->_wsDataStore;
    v567->_wsDataStore = 0;
  }

  v567->_sampleOnlyMainThreads = 0;
  v567->_shouldGatherKextStat = 0;
  v378 = +[SABinaryLocator sharedBinaryLocator](SABinaryLocator, "sharedBinaryLocator");
  v379 = v567->_binaryLocator;
  v567->_binaryLocator = v378;

  v380 = MEMORY[0x1E0C809B0];
  v567->_machTimebase = (mach_timebase_info)0x100000001;
  v587[0] = v380;
  v587[1] = 3221225472;
  v587[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke;
  v587[3] = &unk_1E7147610;
  v587[4] = v567;
  -[SASampleStore iterateAllTimestamps:]((uint64_t)v567, v587);
  if (v367)
    v382 = objc_getProperty(v367, v381, 24, 1);
  else
    v382 = 0;
  v383 = v382;

  if (v383)
  {
    v385 = objc_alloc(MEMORY[0x1E0C99DE8]);
    if (v367)
      v386 = objc_getProperty(v367, v384, 24, 1);
    else
      v386 = 0;
    v387 = v386;
    v388 = objc_msgSend(v385, "initWithObjects:", v387, 0);
    v389 = v567->_kernelCaches;
    v567->_kernelCaches = (NSMutableArray *)v388;

  }
  *(_QWORD *)&v616 = 0;
  *((_QWORD *)&v616 + 1) = &v616;
  v617 = 0x3032000000;
  v618 = __Block_byref_object_copy__0;
  v619 = __Block_byref_object_dispose__0;
  v620 = 0;
  v584[0] = v380;
  v584[1] = 3221225472;
  v584[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_2;
  v584[3] = &unk_1E71476B0;
  v584[4] = v567;
  v390 = v367;
  v585 = v390;
  v586 = &v616;
  -[SASampleStore enumerateTasks:](v567, "enumerateTasks:", v584);
  if (*(_QWORD *)(*((_QWORD *)&v616 + 1) + 40))
  {
    v391 = objc_alloc(MEMORY[0x1E0C99E60]);
    v392 = (void *)objc_msgSend(v391, "initWithObjects:", *(_QWORD *)(*((_QWORD *)&v616 + 1) + 40), 0);
    +[SAFrame enumerateFrameTree:block:]((uint64_t)SAFrame, v392, &__block_literal_global_1434);

  }
  objc_msgSend(v168, "enumerateKeysAndObjectsUsingBlock:", &__block_literal_global_7);

  _Block_object_dispose(&v616, 8);
  objc_autoreleasePoolPop(context);
  *v551 = 0;
  *v550 = 0;

  v108 = v567;
  v568 = v108;
LABEL_193:
  v111 = v561;
LABEL_301:
  objc_autoreleasePoolPop(v111);

  return v108;
}

uint64_t __54__SASampleStore_SASampleStoreNSCoding__initWithCoder___block_invoke(uint64_t a1, uint64_t a2)
{
  return -[SATimestamp applyMachTimebase:](a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184));
}

uint64_t __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke(uint64_t a1, uint64_t a2)
{
  return -[SATimestamp applyMachTimebase:](a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184));
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_2(_QWORD *a1, void *a2)
{
  char *v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  char v7;
  id Property;
  const char *v9;
  id v10;
  void *v11;
  uint64_t v12;
  id *v13;
  uint64_t v14;
  _QWORD v15[6];
  _QWORD v16[6];
  _QWORD v17[4];
  uint64_t dest;

  v3 = a2;
  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x2020000000;
  v17[3] = 0;
  v4 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_3;
  v16[3] = &unk_1E7147638;
  v16[4] = a1[4];
  v16[5] = v17;
  objc_msgSend(v3, "enumerateTaskStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", 0, 0x7FFFFFFFFFFFFFFFLL, 0, 0x7FFFFFFFFFFFFFFFLL, 0, v16);
  objc_msgSend(v3, "threads");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v15[0] = v4;
  v15[1] = 3221225472;
  v15[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_4;
  v15[3] = &unk_1E7147688;
  v15[4] = a1[4];
  v15[5] = v17;
  objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v15);

  if (v3 && (objc_copyStruct(&dest, v3 + 288, 8, 1, 0), dest)
    || (-[SATask guessArchitectureGivenMachineArchitecture:dataSource:]((uint64_t)v3, *(id *)(a1[4] + 192), *(_QWORD *)(a1[4] + 352)), v3))
  {
    objc_copyStruct(&dest, v3 + 288, 8, 1, 0);
  }
  v7 = CSArchitectureIs32Bit();
  Property = (id)a1[5];
  if ((v7 & 1) != 0)
  {
    if (Property)
      Property = objc_getProperty(Property, v6, 16, 1);
    v10 = Property;
    if (v3)
LABEL_13:
      objc_setProperty_atomic(v3, v9, v10, 256);
  }
  else
  {
    if (Property)
      Property = objc_getProperty(Property, v6, 8, 1);
    v10 = Property;
    if (v3)
      goto LABEL_13;
  }

  -[SATask removeStacksOutsideThisProcess]((uint64_t)v3);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (v11)
  {
    v12 = *(_QWORD *)(a1[6] + 8);
    v14 = *(_QWORD *)(v12 + 40);
    v13 = (id *)(v12 + 40);
    if (!v14)
      objc_storeStrong(v13, v11);
  }
  -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:]((id *)v3, *(_QWORD *)(a1[4] + 408), 0, 0, 0, *(_DWORD *)(a1[4] + 328));

  _Block_object_dispose(v17, 8);
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_3(uint64_t a1, void *a2)
{
  _QWORD *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *i;

  v3 = a2;
  for (i = v3; ; v3 = i)
  {
    objc_msgSend(v3, "startTimestamp");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 24), "objectAtIndexedSubscript:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v7 = *(_QWORD *)(v6 + 24);
    if (v4 == v5)
      break;
    *(_QWORD *)(v6 + 24) = v7 + 1;
  }
  v8 = i;
  if (i)
    i[6] = v7;
  while (1)
  {
    objc_msgSend(v8, "endTimestamp");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 24), "objectAtIndexedSubscript:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v12 = *(_QWORD *)(v11 + 24);
    if (v9 == v10)
      break;
    *(_QWORD *)(v11 + 24) = v12 + 1;
    v8 = i;
  }
  if (i)
    i[7] = v12;

}

uint64_t __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD v4[4];
  __int128 v5;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_5;
  v4[3] = &unk_1E7147660;
  v5 = *(_OWORD *)(a1 + 32);
  return objc_msgSend(a3, "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", 0, 0x7FFFFFFFFFFFFFFFLL, 0, 0x7FFFFFFFFFFFFFFFLL, 0, v4);
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_5(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  id v11;

  v11 = a2;
  while (1)
  {
    objc_msgSend(v11, "startTimestamp");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 24), "objectAtIndexedSubscript:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v4 = (void *)objc_claimAutoreleasedReturnValue();

    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v6 = *(_QWORD *)(v5 + 24);
    if (v3 == v4)
      break;
    *(_QWORD *)(v5 + 24) = v6 + 1;
  }
  -[SAThreadState setStartSampleIndex:]((uint64_t)v11, v6);
  while (1)
  {
    objc_msgSend(v11, "endTimestamp");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 24), "objectAtIndexedSubscript:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v10 = *(_QWORD *)(v9 + 24);
    if (v7 == v8)
      break;
    *(_QWORD *)(v9 + 24) = v10 + 1;
  }
  -[SAThreadState setEndSampleIndex:]((uint64_t)v11, v10);

}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_6(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 32) = 0;
}

- (BOOL)keepStateBetweenSampleIndexes
{
  return 0;
}

- (void)setKeepStateBetweenSampleIndexes:(BOOL)a3
{
  int v3;
  NSObject *v4;
  uint8_t v5[16];

  if (a3)
  {
    v3 = *__error();
    _sa_logt();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_fault_impl(&dword_1B9BE0000, v4, OS_LOG_TYPE_FAULT, "keepStateBetweenSampleIndexes is no longer supported", v5, 2u);
    }

    *__error() = v3;
  }
}

- (id)tidToPidDict
{
  id v3;
  id v4;
  _QWORD v6[4];
  id v7;

  v3 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __36__SASampleStore_KPerf__tidToPidDict__block_invoke;
  v6[3] = &unk_1E71478F8;
  v4 = v3;
  v7 = v4;
  -[SASampleStore enumerateTasks:](self, "enumerateTasks:", v6);

  return v4;
}

void __36__SASampleStore_KPerf__tidToPidDict__block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  _QWORD v6[4];
  id v7;
  id v8;

  v3 = a2;
  objc_msgSend(v3, "threads");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __36__SASampleStore_KPerf__tidToPidDict__block_invoke_2;
  v6[3] = &unk_1E71478D0;
  v7 = *(id *)(a1 + 32);
  v5 = v3;
  v8 = v5;
  objc_msgSend(v4, "enumerateKeysAndObjectsUsingBlock:", v6);

}

void __36__SASampleStore_KPerf__tidToPidDict__block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  void *v5;
  void *v6;
  id v7;

  v7 = a3;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(*(id *)(a1 + 40), "pid"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = *(void **)(a1 + 32);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", objc_msgSend(v7, "threadId"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v6);

}

- (id)tidsForPid:(int)a3
{
  uint64_t v3;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v3 = *(_QWORD *)&a3;
  v20 = *MEMORY[0x1E0C80C00];
  v5 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  -[SASampleStore tasksByPid](self, "tasksByPid", 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v3);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKeyedSubscript:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v9)
  {
    v10 = *(_QWORD *)v16;
    do
    {
      v11 = 0;
      do
      {
        if (*(_QWORD *)v16 != v10)
          objc_enumerationMutation(v8);
        objc_msgSend(*(id *)(*((_QWORD *)&v15 + 1) + 8 * v11), "threads");
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v12, "allKeys");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "addObjectsFromArray:", v13);

        ++v11;
      }
      while (v9 != v11);
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    }
    while (v9);
  }

  return v5;
}

- (id)idleThreadSet
{
  id v3;
  id v4;
  _QWORD v6[4];
  id v7;

  v3 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __37__SASampleStore_KPerf__idleThreadSet__block_invoke;
  v6[3] = &unk_1E71478F8;
  v4 = v3;
  v7 = v4;
  -[SASampleStore enumerateTasks:](self, "enumerateTasks:", v6);

  return v4;
}

void __37__SASampleStore_KPerf__idleThreadSet__block_invoke(uint64_t a1, void *a2)
{
  void *v3;
  _QWORD v4[4];
  id v5;

  objc_msgSend(a2, "threads");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __37__SASampleStore_KPerf__idleThreadSet__block_invoke_2;
  v4[3] = &unk_1E7147920;
  v5 = *(id *)(a1 + 32);
  objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);

}

void __37__SASampleStore_KPerf__idleThreadSet__block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  id v8;

  v8 = a2;
  v5 = a3;
  objc_msgSend(v5, "threadStates");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "count");

  if (v7 == 1)
    objc_msgSend(*(id *)(a1 + 32), "addObject:", v8);

}

- (_QWORD)existingTaskForEvent:(uint64_t)a3 inSession:(_DWORD *)a4 returningPid:
{
  _QWORD *v4;
  uint64_t v7;
  int pid_for_thread;
  _QWORD *v9;

  v4 = a1;
  if (a1)
  {
    v7 = *(unsigned int *)(a2 + 88);
    if ((v7 & 0x80000000) != 0)
    {
      pid_for_thread = ktrace_get_pid_for_thread();
      v7 = pid_for_thread < 0 ? 0xFFFFFFFFLL : pid_for_thread;
      if (pid_for_thread < 0 && !*(_QWORD *)(a2 + 40))
      {
        v4 = 0;
        if (!a4)
          return v4;
        goto LABEL_11;
      }
    }
    -[SASampleStore lastTaskWithPid:orTid:](v4, v7, *(_QWORD *)(a2 + 40));
    v9 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    v4 = v9;
    if (v9)
      LODWORD(v7) = objc_msgSend(v9, "pid");
    if (a4)
LABEL_11:
      *a4 = v7;
  }
  return v4;
}

- (id)taskForPid:(void *)a3 andName:(void *)a4 didExecAtTimestamp:
{
  id v7;
  id v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;
  const char *v13;
  id v14;
  void *v15;
  int v16;
  void *v17;
  void *v18;
  char v19;

  v7 = a3;
  v8 = a4;
  if (!a1)
  {
    v14 = 0;
    goto LABEL_23;
  }
  -[SASampleStore lastTaskWithPid:](a1, a2);
  v9 = (_QWORD *)objc_claimAutoreleasedReturnValue();
  v10 = v9;
  if (v9)
  {
    if (!v8)
    {
      if (v7)
      {
        if (!v9[7])
        {
          objc_msgSend(v9, "name");
          v17 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v17
            || (objc_msgSend(v10, "name"),
                v18 = (void *)objc_claimAutoreleasedReturnValue(),
                v19 = objc_msgSend(v18, "hasPrefix:", v7),
                v18,
                v17,
                (v19 & 1) == 0))
          {
            -[SATask setName:]((uint64_t)v10, v7);
          }
        }
      }
      v14 = v10;
      goto LABEL_22;
    }
    objc_msgSend(v9, "exitTimestamp");
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v11)
      -[SASampleStore task:exitedAtTimestamp:]((uint64_t)a1, v10, v8);
  }
  +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, a2, -1, v7, 0);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = v12;
  if (v12)
    objc_setProperty_atomic(v12, v13, v8, 224);
  -[SASampleStore addTask:]((uint64_t)a1, v14);
  if ((objc_msgSend(a1, "dataGatheringOptions") & 2) != 0)
  {
    if ((objc_msgSend(a1, "dataGatheringOptions") & 0x80) != 0)
    {
      objc_msgSend(v14, "binaryLoadInfos");
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      if (!objc_msgSend(v15, "count"))
      {

LABEL_20:
        -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v14, objc_msgSend(a1, "dataGatheringOptions"), objc_msgSend(a1, "additionalCSSymbolicatorFlags"));
        goto LABEL_21;
      }
      v16 = objc_msgSend(v14, "pid");

      if (!v16)
        goto LABEL_20;
    }
LABEL_21:
    -[SATask _gatherDataFromLiveProcessIsLate:mainBinaryPath:]((uint64_t)v14, 0, 0);
  }
LABEL_22:

LABEL_23:
  return v14;
}

BOOL __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke(uint64_t a1, void *a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = objc_msgSend(a2, "address");
  v6 = *(_QWORD *)(a1 + 32);
  if (v5 == v6)
    *a3 = 1;
  return v5 == v6;
}

BOOL __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_67(uint64_t a1, void *a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = objc_msgSend(a2, "address");
  v6 = *(_QWORD *)(a1 + 32);
  if (v5 == v6)
    *a3 = 1;
  return v5 == v6;
}

void __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_72(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7;
  const char *v8;
  int v9;
  FILE *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  id Property;
  const char *v15;
  uint64_t v16;
  id v17;
  id v18;
  void *v19;
  const char *v20;
  void *v21;
  id v22;
  int v23;
  id v24;
  int v25;
  int v27;
  FILE *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  id v32;
  const char *v33;
  uint64_t v34;
  id v35;
  void *v36;
  const char *v37;
  void *v38;
  id v39;
  id v40;
  int v41;
  id v42;
  id v43;
  id v44;
  id v45;

  v45 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v7 = v45;
    if (objc_msgSend(v7, "needsExclave"))
    {
      objc_msgSend(v7, "setNeedsExclave:", 0);
      if (v7)
        objc_setProperty_atomic(v7, v8, *(id *)(a1 + 40), 176);
      if (!a3 && qword_1ED1DD618)
      {
        v9 = *__error();
        v10 = (FILE *)qword_1ED1DD618;
        v11 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v13 = objc_msgSend(*(id *)(a1 + 32), "threadId");
        Property = *(id *)(a1 + 40);
        if (Property)
          Property = objc_getProperty(Property, v12, 16, 1);
        v43 = Property;
        v16 = objc_msgSend(v43, "count");
        v17 = *(id *)(a1 + 40);
        if (v17)
          v17 = objc_getProperty(v17, v15, 16, 1);
        v18 = v17;
        objc_msgSend(v18, "lastObject");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = v19;
        if (v19)
        {
          v22 = objc_getProperty(v19, v20, 16, 1);
          v23 = v9;
        }
        else
        {
          v23 = v9;
          v22 = 0;
        }
        v24 = v22;
        fprintf(v10, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to all (%d) thread states (indexes %lu-%lu)\n", v11, v13, v16, objc_msgSend(v24, "address"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));

        *__error() = v23;
      }
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    }
    else
    {
      if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
      {
        v27 = *__error();
        v28 = (FILE *)qword_1ED1DD618;
        v29 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v31 = objc_msgSend(*(id *)(a1 + 32), "threadId");
        v32 = *(id *)(a1 + 40);
        if (v32)
          v32 = objc_getProperty(v32, v30, 16, 1);
        v44 = v32;
        v34 = objc_msgSend(v44, "count");
        v35 = *(id *)(a1 + 40);
        if (v35)
          v35 = objc_getProperty(v35, v33, 16, 1);
        v42 = v35;
        objc_msgSend(v42, "lastObject");
        v36 = (void *)objc_claimAutoreleasedReturnValue();
        v38 = v36;
        v41 = v27;
        if (v36)
          v39 = objc_getProperty(v36, v37, 16, 1);
        else
          v39 = 0;
        v40 = v39;
        fprintf(v28, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to %d thread states (indexes %lu-%lu)\n", v29, v31, v34, objc_msgSend(v40, "address"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + a3);

        *__error() = v41;
      }
      *a4 = 1;
    }

  }
  else
  {
    if (qword_1ED1DD618)
    {
      v25 = *__error();
      fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx ran into non-kperf state at index %lu, stopping\n", *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8), objc_msgSend(*(id *)(a1 + 32), "threadId"), a3);
      *__error() = v25;
    }
    *a4 = 1;
  }

}

- (void)kperfRecord:(void *)a3 state:(void *)a4 frameIterator:
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  id v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  id *p_isa;
  void *v32;
  const char *v33;
  void *v34;
  void *v35;
  id v36;
  id v37;
  id *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  _QWORD *v48;
  int v49;
  NSObject *v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  NSObject *v57;
  void *v58;
  void *v59;
  int v60;
  NSObject *v61;
  FILE *v62;
  int v63;
  uint64_t *v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  int v68;
  unint64_t absolute_from_timestamp;
  const char *v70;
  unint64_t v71;
  unint64_t v72;
  id v73;
  const char *v74;
  void *v75;
  id v76;
  unint64_t v77;
  int v78;
  int v79;
  FILE *v80;
  uint64_t v81;
  uint64_t v82;
  const char *v83;
  uint64_t pid_for_thread;
  int *v85;
  int v86;
  int *v87;
  int v88;
  _BYTE *v89;
  _BYTE *execname_for_thread;
  void *v91;
  uint64_t v92;
  void *v93;
  uint64_t v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  uint64_t v100;
  id v101;
  int v102;
  int *v103;
  int v104;
  NSObject *v105;
  const char *ClassName;
  char v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  FILE *v116;
  uint64_t v117;
  SEL v118;
  id v119;
  void *v120;
  const char *v121;
  void *v122;
  void *v123;
  uint64_t v124;
  void *v125;
  void *v126;
  void *v127;
  const char *v128;
  id Property;
  id v130;
  void *v131;
  id v132;
  const char *v133;
  id v134;
  unint64_t v135;
  id v136;
  id v137;
  int v138;
  int v139;
  unsigned __int8 v140;
  id v141;
  const char *v142;
  id v143;
  id v144;
  id v145;
  int v146;
  FILE *v147;
  uint64_t v148;
  const char *v149;
  uint64_t v150;
  id v151;
  id v152;
  int v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  id v158;
  void *v159;
  void *v160;
  void *v161;
  uint64_t v162;
  NSObject *v163;
  id v164;
  uint64_t v165;
  void *v166;
  void *v167;
  id v168;
  uint64_t v169;
  id v170;
  id v171;
  char v172;
  void *v173;
  id v174;
  id v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  void *v182;
  void *v183;
  int v184;
  uint64_t v185;
  uint64_t ns_from_timestamp;
  uint64_t v187;
  int v188;
  unint64_t v189;
  uint64_t v190;
  int v191;
  char v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  char v197;
  uint64_t v198;
  uint64_t v199;
  char v200;
  int v201;
  _BYTE *name_for_thread;
  _BYTE *v203;
  BOOL v204;
  uint64_t v205;
  void *v206;
  uint64_t v207;
  BOOL v208;
  size_t v209;
  unsigned int v210;
  uint64_t v211;
  void *v212;
  _BYTE *execname_for_pid;
  void *v214;
  void *v215;
  size_t v216;
  int v217;
  void *v218;
  uint64_t v219;
  int v220;
  uint64_t v221;
  uint64_t v222;
  char v223;
  unsigned int v224;
  int v225;
  unsigned int v226;
  uint64_t v227;
  uint64_t v228;
  char v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  char v233;
  unint64_t v234;
  char v235;
  uint64_t v236;
  uint64_t v237;
  char v238;
  void *v239;
  int v240;
  NSObject *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  int v248;
  NSObject *v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  int v256;
  NSObject *v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  int v264;
  NSObject *v265;
  int v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  char v273;
  uint64_t v274;
  uint64_t v275;
  unsigned __int8 v276;
  char v277;
  int v278;
  uint64_t v279;
  int v280;
  int v281;
  _BYTE *v282;
  char v283;
  void *v284;
  uint64_t v285;
  char v286;
  unsigned __int8 v287;
  unint64_t v288;
  unsigned int v289;
  void *v290;
  id v291;
  void *v292;
  void *v293;
  void *v294;
  void *v295;
  unint64_t v296;
  void *v297;
  _QWORD *v298;
  id v299;
  void *context;
  id v301;
  _QWORD *self;
  uint64_t v303;
  void *v304;
  int v305;
  _QWORD *v306;
  int *v307;
  _BYTE *v308;
  uint64_t v309;
  _BYTE *v310;
  id v311;
  uint64_t v312;
  uint64_t *v313;
  uint64_t v314;
  int v315;
  _QWORD v316[5];
  _QWORD v317[5];
  uint8_t v318[4];
  void *v319;
  __int16 v320;
  void *v321;
  _BYTE buf[24];
  void *v323;
  __int128 v324;
  uint64_t *v325;
  uint64_t v326;
  uint64_t v327;

  v327 = *MEMORY[0x1E0C80C00];
  self = a3;
  v301 = a4;
  v306 = a1;
  if (a1)
  {
    context = (void *)MEMORY[0x1BCCCC288]();
    if ((*(_QWORD *)a2 & 0x200000000) == 0)
    {
      if ((~*(_WORD *)a2 & 0x2005) == 0)
      {
        v7 = *(_QWORD *)(a2 + 16);
        if (!v7)
        {
          v240 = *__error();
          _sa_logt();
          v241 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1B9BE0000, v241, OS_LOG_TYPE_ERROR, "0 tid", buf, 2u);
          }

          *__error() = v240;
          _SASetCrashLogMessage(773, "0 tid", v242, v243, v244, v245, v246, v247, v273);
          _os_crash();
          __break(1u);
          goto LABEL_267;
        }
        v8 = objc_msgSend(a1, "dataSource");
        v9 = *(_QWORD *)a2;
        if (v8 == 2)
        {
          if ((v9 & 0x20) == 0)
          {
            if (!qword_1ED1DD618)
              goto LABEL_262;
            v10 = __error();
            if ((*(_BYTE *)a2 & 2) != 0)
              v11 = *(_DWORD *)(a2 + 24);
            else
              v11 = -1;
            v102 = *v10;
            fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Thread 0x%llx core %d ignoring record without thread info\n", *(_QWORD *)(a2 + 8), v7, v11);
            v103 = __error();
LABEL_131:
            *v103 = v102;
            goto LABEL_262;
          }
        }
        else if ((v9 & 0x1000000C0) == 0)
        {
          if (!qword_1ED1DD618)
            goto LABEL_262;
          v87 = __error();
          if ((*(_BYTE *)a2 & 2) != 0)
            v88 = *(_DWORD *)(a2 + 24);
          else
            v88 = -1;
          v102 = *v87;
          fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Thread 0x%llx core %d ignoring record without a stack\n", *(_QWORD *)(a2 + 8), v7, v88);
          v103 = __error();
          goto LABEL_131;
        }
        if (self
          && (v58 = (void *)self[1],
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v7),
              v59 = (void *)objc_claimAutoreleasedReturnValue(),
              LODWORD(v58) = objc_msgSend(v58, "containsObject:", v59),
              v59,
              (_DWORD)v58))
        {
          -[SAKPerfState nextSampleForThread:isOnCore:]((uint64_t)self, v7, 0);
          v305 = 1;
        }
        else
        {
          v305 = 0;
        }
        if (objc_msgSend(v306, "dataStyle") != 1)
        {
          if (objc_msgSend(v306, "dataStyle"))
          {
            objc_msgSend(v306, "sampleTimestamps");
            v66 = (void *)objc_claimAutoreleasedReturnValue();
            v67 = objc_msgSend(v66, "count");

            if (!v67)
            {
              if (!qword_1ED1DD618)
                goto LABEL_262;
              v102 = *__error();
              fprintf((FILE *)qword_1ED1DD618, "%'llu No sampling point before kperfdata\n", *(_QWORD *)(a2 + 8));
              v103 = __error();
              goto LABEL_131;
            }
          }
        }
        if ((*(_BYTE *)a2 & 2) != 0)
          v68 = *(_DWORD *)(a2 + 24);
        else
          v68 = -1;
        v289 = v68;
        absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
        v71 = absolute_from_timestamp;
        if (self)
        {
          v72 = self[4];
          if (absolute_from_timestamp > v72)
          {
LABEL_88:
            v72 = absolute_from_timestamp;
            goto LABEL_94;
          }
          if ((v305 & 1) == 0)
          {
            v73 = objc_getProperty(self, v70, 40, 1);
            if (v73)
            {
              v75 = v73;
              v76 = objc_getProperty(self, v74, 40, 1);
              v77 = objc_msgSend(v76, "machAbsTime");

              if (v71 <= v77)
              {
                if (qword_1ED1DD618)
                {
                  v115 = *__error();
                  v116 = (FILE *)qword_1ED1DD618;
                  v117 = *(_QWORD *)(a2 + 8);
                  v119 = objc_getProperty(self, v118, 40, 1);
                  fprintf(v116, "%'llu Adjusting forward record timestamp %lld to %lld, and making on-core for most recent timer %lld \n", v117, v71, v72, objc_msgSend(v119, "machAbsTime"));

                  *__error() = v115;
                  v305 = 1;
LABEL_94:
                  if (qword_1ED1DD618)
                  {
                    v79 = *__error();
                    v80 = (FILE *)qword_1ED1DD618;
                    v82 = *(_QWORD *)a2;
                    v81 = *(_QWORD *)(a2 + 8);
                    StringForKPDecodeContentBits((uint64_t *)a2);
                    v83 = "off";
                    if (v305)
                      v83 = "on";
                    fprintf(v80, "%'llu Thread 0x%llx core %d parsing %s-core kperf with content 0x%llx: %s\n", v81, v7, v289, v83, v82, (const char *)&qword_1ED1DD628);
                    *__error() = v79;
                  }
                  goto LABEL_98;
                }
                v305 = 1;
LABEL_98:
                pid_for_thread = ktrace_get_pid_for_thread();
                if ((pid_for_thread & 0x80000000) != 0)
                {
                  if ((*(_BYTE *)a2 & 0x20) == 0)
                  {
                    if (!qword_1ED1DD618)
                      goto LABEL_262;
                    v85 = __error();
                    if ((*(_BYTE *)a2 & 2) != 0)
                      v86 = *(_DWORD *)(a2 + 24);
                    else
                      v86 = -1;
                    v102 = *v85;
                    fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Thread 0x%llx core %d unable to determine pid for thread: %d\n", *(_QWORD *)(a2 + 8), v7, v86, pid_for_thread);
                    v103 = __error();
                    goto LABEL_131;
                  }
                  pid_for_thread = *(unsigned int *)(a2 + 88);
                  if ((pid_for_thread & 0x80000000) != 0)
                  {
LABEL_273:
                    v264 = *__error();
                    _sa_logt();
                    v265 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v265, OS_LOG_TYPE_ERROR))
                    {
                      v266 = *(_DWORD *)(a2 + 88);
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v266;
                      _os_log_error_impl(&dword_1B9BE0000, v265, OS_LOG_TYPE_ERROR, "rec->thread_info.pid is %d", buf, 8u);
                    }

                    *__error() = v264;
                    _SASetCrashLogMessage(838, "rec->thread_info.pid is %d", v267, v268, v269, v270, v271, v272, *(_DWORD *)(a2 + 88));
                    _os_crash();
                    __break(1u);
                  }
                }
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v7);
                v297 = (void *)objc_claimAutoreleasedReturnValue();
                -[SASampleStore lastTaskWithPid:](v306, pid_for_thread);
                v89 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                if (!v89)
                {
                  execname_for_thread = (_BYTE *)ktrace_get_execname_for_thread();
                  if (execname_for_thread && *execname_for_thread)
                  {
                    SANSStringForCString(execname_for_thread);
                    v91 = (void *)objc_claimAutoreleasedReturnValue();
                  }
                  else
                  {
                    v91 = 0;
                  }
                  -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v306, pid_for_thread, v91, 0);
                  v92 = objc_claimAutoreleasedReturnValue();

                  v89 = (_BYTE *)v92;
                }
                v310 = v89;
                objc_msgSend(v89, "threads");
                v93 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v93, "objectForKeyedSubscript:", v297);
                v94 = objc_claimAutoreleasedReturnValue();

                v308 = (_BYTE *)v94;
                if (v94)
                {
LABEL_139:
                  objc_msgSend(v310, "binaryLoadInfos");
                  v123 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v301, "setUserBinaryLoadInfos:", v123);

                  if (v310)
                    v124 = v310[73] & 1;
                  else
                    v124 = 0;
                  objc_msgSend(v301, "setAssumeUserBinaryLoadInfosContainMainBinary:", v124);
                  objc_msgSend(v310, "sharedCache");
                  v125 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v301, "setSharedCache:", v125);

                  objc_msgSend(v306, "sampleTimestamps");
                  v126 = (void *)objc_claimAutoreleasedReturnValue();
                  if (objc_msgSend(v126, "count"))
                  {
                    objc_msgSend(v306, "sampleTimestamps");
                    v127 = (void *)objc_claimAutoreleasedReturnValue();
                    v288 = objc_msgSend(v127, "count") - 1;

                  }
                  else
                  {
                    v288 = 0x7FFFFFFFFFFFFFFFLL;
                  }

                  if (!v305)
                    goto LABEL_156;
                  Property = self;
                  if (self)
                    Property = objc_getProperty(self, v128, 40, 1);
                  v130 = Property;

                  if (!v130)
                  {
LABEL_156:
                    +[SATimestamp timestampWithMachAbsTime:fromKtraceSession:]((uint64_t)SATimestamp, v72);
                    v299 = (id)objc_claimAutoreleasedReturnValue();
                    v140 = 0;
                    goto LABEL_188;
                  }
                  objc_msgSend(v306, "sampleTimestamps");
                  v131 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v131, "lastObject");
                  v132 = (id)objc_claimAutoreleasedReturnValue();

                  if (!v132)
                    goto LABEL_152;
                  if (self)
                  {
                    v134 = objc_getProperty(self, v133, 40, 1);
                    if (v132 == v134)
                    {

                      v141 = v132;
                      v143 = self;
                      goto LABEL_160;
                    }
                  }
                  else
                  {
                    v134 = 0;
                  }
                  v135 = objc_msgSend(v132, "machAbsTime");

                  if (v135 < v71)
                  {
LABEL_152:
                    v136 = self;
                    if (self)
                      v136 = objc_getProperty(self, v133, 40, 1);
                    v137 = v136;
                    if (qword_1ED1DD618)
                    {
                      v138 = *__error();
                      fprintf((FILE *)qword_1ED1DD618, "%'llu Adjusting backward record timestamp %lld to %lld, to match the non-PET timer that triggered it\n", *(_QWORD *)(a2 + 8), v71, objc_msgSend(v137, "machAbsTime"));
                      v139 = 0;
                      *__error() = v138;
                    }
                    else
                    {
                      v139 = 0;
                    }
LABEL_170:
                    v295 = v137;
                    objc_msgSend(v308, "threadStates");
                    v154 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v154, "lastObject");
                    v155 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v155, "endTimestamp");
                    v156 = (void *)objc_claimAutoreleasedReturnValue();
                    v157 = v156;
                    if (v156)
                    {
                      v158 = v156;
                    }
                    else
                    {
                      objc_msgSend(v308, "creationTimestamp");
                      v158 = (id)objc_claimAutoreleasedReturnValue();

                    }
                    if (v158 && objc_msgSend(v158, "gt:", v295))
                    {
                      if (v139)
                      {
                        objc_msgSend(v308, "threadStates");
                        v159 = (void *)objc_claimAutoreleasedReturnValue();
                        if (objc_msgSend(v159, "count"))
                        {
                          objc_msgSend(v308, "threadStates");
                          v160 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v160, "lastObject");
                          v161 = (void *)objc_claimAutoreleasedReturnValue();
                          v162 = objc_msgSend(v161, "endSampleIndex");

                          if (v162 != v288)
                          {
                            v293 = v132;
                            a2 = *__error();
                            _sa_logt();
                            v163 = objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
                            {
                              objc_msgSend(v308, "debugDescription");
                              v164 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                              v165 = objc_msgSend(v164, "UTF8String");
                              objc_msgSend(v308, "threadStates");
                              v166 = (void *)objc_claimAutoreleasedReturnValue();
                              objc_msgSend(v166, "lastObject");
                              v167 = (void *)objc_claimAutoreleasedReturnValue();
                              objc_msgSend(v167, "debugDescription");
                              v168 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                              v169 = objc_msgSend(v168, "UTF8String");
                              objc_msgSend(v293, "debugDescription");
                              v170 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                              *(_DWORD *)buf = 136315906;
                              *(_QWORD *)&buf[4] = v165;
                              *(_WORD *)&buf[12] = 2080;
                              *(_QWORD *)&buf[14] = v169;
                              *(_WORD *)&buf[22] = 2048;
                              v323 = (void *)v288;
                              LOWORD(v324) = 2080;
                              *(_QWORD *)((char *)&v324 + 2) = objc_msgSend(v170, "UTF8String");
                              _os_log_error_impl(&dword_1B9BE0000, v163, OS_LOG_TYPE_ERROR, "Thread %s state %s vs last sample index %lu timestamp %s", buf, 0x2Au);

                            }
                            *__error() = a2;
                            objc_msgSend(v308, "debugDescription");
                            v171 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v172 = objc_msgSend(v171, "UTF8String");
                            objc_msgSend(v308, "threadStates");
                            v173 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v173, "lastObject");
                            pid_for_thread = objc_claimAutoreleasedReturnValue();
                            objc_msgSend((id)pid_for_thread, "debugDescription");
                            v174 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v139 = objc_msgSend(v174, "UTF8String");
                            objc_msgSend(v293, "debugDescription");
                            v175 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            objc_msgSend(v175, "UTF8String");
                            _SASetCrashLogMessage(914, "Thread %s state %s vs last sample index %lu timestamp %s", v176, v177, v178, v179, v180, v181, v172);

                            v132 = v293;
                            _os_crash();
                            __break(1u);
                            goto LABEL_181;
                          }
                        }
                        else
                        {

                        }
                        v139 = 0;
                      }
                      v299 = v158;

                      if (qword_1ED1DD618)
                      {
                        v184 = *__error();
                        fprintf((FILE *)qword_1ED1DD618, "%'llu Adjusting forward record timestamp %lld to %lld, to match the last thread state\n", *(_QWORD *)(a2 + 8), v71, objc_msgSend(v299, "machAbsTime"));
                        *__error() = v184;
                      }
                      goto LABEL_187;
                    }
LABEL_181:
                    v299 = v295;
LABEL_187:

                    v140 = v139 != 0;
LABEL_188:
                    v185 = *(_QWORD *)a2;
                    if ((*(_QWORD *)a2 & 0x200000) != 0)
                    {
                      ns_from_timestamp = ktrace_get_ns_from_timestamp();
                      v187 = ktrace_get_ns_from_timestamp();
                      v188 = *(_DWORD *)(a2 + 6640);
                      v189 = *(_QWORD *)(a2 + 6632);
                      v190 = (v189 >> 1) & 1;
                      v191 = *(_DWORD *)(a2 + 6644);
                      v192 = v189 & 1;
                      v193 = (v189 >> 2) & 1;
                      v194 = (v189 >> 3) & 1;
                      if ((v189 & 0x10) != 0)
                      {
                        v195 = (v189 >> 5) & 1;
                        v196 = (v189 >> 6) & 1;
                        v197 = 1;
                        goto LABEL_195;
                      }
                    }
                    else
                    {
                      if ((v185 & 0x1000) == 0 || (*(_BYTE *)(a2 + 6560) & 1) != 0)
                        goto LABEL_204;
                      ns_from_timestamp = 0;
                      v187 = 0;
                      v188 = 0;
                      v191 = 0;
                      v192 = 0;
                      LOBYTE(v190) = 0;
                      LOBYTE(v193) = 0;
                      LOBYTE(v194) = 0;
                    }
                    v197 = 0;
                    LOBYTE(v195) = 0;
                    LOBYTE(v196) = 0;
LABEL_195:
                    v198 = *(_QWORD *)a2;
                    if ((*(_QWORD *)a2 & 0x1000) == 0 || (*(_BYTE *)(a2 + 6560) & 1) != 0)
                    {
                      v200 = 0;
                      v199 = 0;
                    }
                    else
                    {
                      v199 = *(_QWORD *)(a2 + 6568);
                      v200 = 1;
                    }
                    if ((v198 & 0x100000) != 0)
                    {
                      v201 = (*(unsigned __int16 *)(a2 + 6624) >> 9) & 7;
                      if (v201)
                        v201 |= 0xFF0000u;
                    }
                    else
                    {
                      v201 = 0;
                    }
                    -[SASampleStore backfillTask:lastSampleIndex:timestamp:haveSnap:terminatedThreadsUserTimeInNs:terminatedThreadsSystemTimeInNs:terminatedThreadsCycles:terminatedThreadsInstructions:suspendCount:pageins:isDarwinBG:isForeground:isBoosted:isDirty:haveWQFlags:wqExceededTotalThreadLimit:wqExceededConstrainedThreadLimit:haveMem:taskSizeInBytes:haveLatencyQos:latencyQos:](v306, v310, v288, v299, (v185 & 0x200000) != 0, ns_from_timestamp, v187, 0, 0, v188, v191, v192, v190, v193, v194, v197, v195, v196, v200,
                      v199,
                      (v198 & 0x100000) != 0,
                      v201);
LABEL_204:
                    name_for_thread = (_BYTE *)ktrace_get_name_for_thread();
                    v203 = name_for_thread;
                    if (name_for_thread)
                      v204 = *name_for_thread != 0;
                    else
                      v204 = 0;
                    v296 = *(_QWORD *)a2;
                    if ((*(_QWORD *)a2 & 0x800000) != 0)
                    {
                      v205 = *(_QWORD *)(a2 + 6688);
                      if ((*(_QWORD *)a2 & 0x10000000) != 0)
                      {
                        if (*(_BYTE *)(a2 + 7088))
                          v206 = (void *)(a2 + 7088);
                        else
                          v206 = 0;
                        goto LABEL_214;
                      }
                    }
                    else
                    {
                      v205 = 0;
                    }
                    v206 = 0;
LABEL_214:
                    if ((v296 & 0x40) == 0)
                    {
                      v294 = 0;
                      v287 = 0;
                      if ((v296 & 0x80) == 0)
                      {
LABEL_216:
                        v290 = 0;
                        v291 = 0;
                        v207 = 0;
                        v208 = objc_msgSend(v310, "pid") == 0;
LABEL_247:
                        v219 = *(_QWORD *)a2;
                        if ((*(_QWORD *)a2 & 0x100000) != 0)
                        {
                          objc_msgSend(v306, "setHaveKPerfSched:", 1);
                          v220 = v219;
                          v219 = ktrace_get_ns_from_timestamp();
                          v221 = ktrace_get_ns_from_timestamp();
                          v222 = v219;
                          LODWORD(v219) = v220;
                          v223 = v204;
                          v224 = *(_DWORD *)(a2 + 6616) & 0xFFFFFFFB;
                          v225 = *(__int16 *)(a2 + 6620);
                          v226 = *(unsigned __int16 *)(a2 + 6624);
                          BYTE4(v279) = v226 & 7;
                          v280 = *(__int16 *)(a2 + 6622);
                          v278 = (v226 >> 6) & 7;
                          LODWORD(v279) = (v226 >> 3) & 7;
                          v227 = a2;
                          a2 = *(_QWORD *)a2;
                          v228 = v227;
                          if ((a2 & 0x8000000) != 0)
                            v229 = *(_BYTE *)(v227 + 7080) & 7;
                          else
                            v229 = 0;
                        }
                        else
                        {
                          v223 = v204;
                          v228 = a2;
                          v221 = 0;
                          v222 = 0;
                          v225 = 0;
                          v280 = 0;
                          v224 = 0;
                          v279 = 0;
                          LOBYTE(v278) = 0;
                          v229 = 0;
                          LODWORD(a2) = *(_QWORD *)a2;
                        }
                        v286 = v223;
                        v284 = v206;
                        v285 = v205;
                        v283 = v208;
                        v281 = v225;
                        v277 = v229;
                        if ((a2 & 0x4000000) != 0)
                        {
                          v230 = *(_QWORD *)(v228 + 7064);
                          v231 = *(_QWORD *)(v228 + 7072);
                        }
                        else
                        {
                          v230 = 0;
                          v231 = 0;
                        }
                        v232 = v207;
                        v282 = v203;
                        if ((a2 & 0x400000) != 0)
                        {
                          v274 = v221;
                          v275 = v222;
                          v276 = v140;
                          v233 = *(_BYTE *)(v228 + 6682);
                          v234 = *(_QWORD *)(v228 + 6664);
                          v235 = *(__int16 *)(v228 + 6680) > 0;
                          if ((v234 & 4) != 0 && v308)
                            v308[16] = 1;
                          +[SATimestamp timestampWithMachAbsTime:fromKtraceSession:]((uint64_t)SATimestamp, *(_QWORD *)(v228 + 6672));
                          v236 = objc_claimAutoreleasedReturnValue();
                          v237 = (v234 >> 1) & 1;
                          v238 = v234 & 1;
                          v239 = (void *)v236;
                          v140 = v276;
                          v221 = v274;
                          v222 = v275;
                        }
                        else
                        {
                          v233 = 0;
                          LOBYTE(v237) = 0;
                          v238 = 0;
                          v235 = 0;
                          v239 = 0;
                        }
                        -[SASampleStore backfillThread:inTask:lastSampleIndex:timestamp:haveName:name:haveDispatchQueueId:dispatchQueueId:dispatchQueueLabel:leafKernelFrame:hasExclaveInKernelStack:haveUserStack:leafUserFrame:swiftTaskId:leafOfCRootFramesReplacedBySwiftAsync:threadExclavesInfo:haveSched:systemCpuTimeNs:userCpuTimeNs:basePriority:scheduledPriority:state:threadQos:threadRequestedQos:threadRequestedQosOverride:threadQosPromote:haveCycIns:instructions:cycles:haveSnap:ioTier:isIOPassive:isDarwinBG:isSuspended:isGlobalForcedIdle:isIdleWorkQueue:lastMadeRunnableTime:isOnCore:isOnCoreForLastSampleIndex:cpuNum:](v306, v308, v310, v288, v299, v286, v282, (v296 >> 23) & 1, v285, v284, v294, v287, v283, v290, v232, v291, 0, (v219 & 0x100000) != 0, v221,
                          v222,
                          v281,
                          v280,
                          v224,
                          SBYTE4(v279),
                          v279,
                          v278,
                          v277,
                          (a2 & 0x4000000) != 0,
                          v230,
                          v231,
                          (a2 & 0x400000) != 0,
                          v233,
                          v237,
                          v238,
                          v235,
                          0,
                          0,
                          v239,
                          v305,
                          v140,
                          v289);
                        objc_msgSend(v301, "clearThreadData");
                        objc_msgSend(v301, "clearTaskData");

                        goto LABEL_262;
                      }
                      goto LABEL_232;
                    }
                    v209 = *(unsigned int *)(a2 + 2164);
                    if ((_DWORD)v209)
                    {
                      objc_msgSend(v301, "setKernelFrames:", malloc_type_calloc(v209, 8uLL, 0x100004000313F17uLL));
                      memcpy((void *)objc_msgSend(v301, "kernelFrames"), (const void *)(a2 + 2168), 8 * *(unsigned int *)(a2 + 2164));
                      objc_msgSend(v301, "setNumKernelFrames:", *(unsigned int *)(a2 + 2164));
                      v210 = *(_DWORD *)(a2 + 7376);
                      v287 = v210 != 0;
                      if (v210)
                      {
                        if (v210 == *(_DWORD *)(a2 + 2164))
                          v211 = 0;
                        else
                          v211 = v210;
                        objc_msgSend(v301, "setExclaveInsertionIndex:", v211);
                      }
                      if ((*(_BYTE *)(a2 + 2160) & 0x10) != 0)
                        objc_msgSend(v301, "setIsKernelStackTruncated:", 1);
                      -[SASampleStore lastTaskWithPid:](v306, 0);
                      v212 = (void *)objc_claimAutoreleasedReturnValue();
                      if (!v212)
                      {
                        execname_for_pid = (_BYTE *)ktrace_get_execname_for_pid();
                        if (execname_for_pid && *execname_for_pid)
                        {
                          SANSStringForCString(execname_for_pid);
                          v214 = (void *)objc_claimAutoreleasedReturnValue();
                        }
                        else
                        {
                          v214 = 0;
                        }
                        -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v306, 0, v214, 0);
                        v212 = (void *)objc_claimAutoreleasedReturnValue();

                      }
                      objc_msgSend(v212, "binaryLoadInfos");
                      v215 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v301, "setKernelBinaryLoadInfos:", v215);

                      -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v212, v301, 0);
                      v294 = (void *)objc_claimAutoreleasedReturnValue();

                      if ((*(_QWORD *)a2 & 0x80) == 0)
                        goto LABEL_216;
LABEL_232:
                      v216 = *(unsigned int *)(a2 + 108);
                      if ((_DWORD)v216)
                      {
                        objc_msgSend(v301, "setUserFrames:", malloc_type_calloc(v216, 8uLL, 0x100004000313F17uLL));
                        memcpy((void *)objc_msgSend(v301, "userFrames"), (const void *)(a2 + 112), 8 * *(unsigned int *)(a2 + 108));
                        objc_msgSend(v301, "setNumUserFrames:", *(unsigned int *)(a2 + 108));
                        if ((*(_BYTE *)(a2 + 104) & 0x10) != 0)
                        {
                          if ((*(_BYTE *)(a2 + 4) & 1) == 0
                            || (objc_msgSend(v301, "setIsSwiftAsyncStackTruncated:", 1), !*(_DWORD *)(a2 + 7328)))
                          {
                            objc_msgSend(v301, "setIsUserStackTruncated:", 1);
                          }
                        }
                        v217 = *(_DWORD *)(a2 + 104);
                        if ((v217 & 0x80) != 0)
                        {
                          -[SASampleStore addressTranslationsForPid:]((uint64_t)v306, pid_for_thread);
                          v218 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v301, "setAddressTranslations:", v218);

                          v217 = *(_DWORD *)(a2 + 104);
                        }
                        if ((v217 & 0x100) != 0)
                          objc_msgSend(v301, "setCheckLR:", 1);
                        if ((*(_BYTE *)(a2 + 4) & 1) != 0)
                        {
                          objc_msgSend(v301, "setSwiftAsyncFrames:", malloc_type_calloc(*(unsigned int *)(a2 + 7328), 8uLL, 0x100004000313F17uLL));
                          memcpy((void *)objc_msgSend(v301, "swiftAsyncFrames"), (const void *)(a2 + 112 + 8 * *(unsigned int *)(a2 + 7324)), 8 * *(unsigned int *)(a2 + 7328));
                          objc_msgSend(v301, "setNumSwiftAsyncFrames:", *(unsigned int *)(a2 + 7328));
                          objc_msgSend(v301, "setSwiftAsyncStitchIndex:", *(unsigned int *)(a2 + 7320));
                          if (objc_msgSend(v301, "numSwiftAsyncFrames"))
                            v207 = -1;
                          else
                            v207 = 0;
                        }
                        else
                        {
                          v207 = 0;
                        }
                        v311 = 0;
                        -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v310, v301, &v311);
                        v290 = (void *)objc_claimAutoreleasedReturnValue();
                        v291 = v311;
                        v208 = 1;
                        goto LABEL_247;
                      }
                      goto LABEL_270;
                    }
LABEL_267:
                    v248 = *__error();
                    _sa_logt();
                    v249 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v249, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_1B9BE0000, v249, OS_LOG_TYPE_ERROR, "0 rec->kstack.nframes", buf, 2u);
                    }

                    *__error() = v248;
                    _SASetCrashLogMessage(1051, "0 rec->kstack.nframes", v250, v251, v252, v253, v254, v255, v273);
                    _os_crash();
                    __break(1u);
LABEL_270:
                    v256 = *__error();
                    _sa_logt();
                    v257 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v257, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_1B9BE0000, v257, OS_LOG_TYPE_ERROR, "0 rec->ustack.nframes", buf, 2u);
                    }

                    *__error() = v256;
                    _SASetCrashLogMessage(1091, "0 rec->ustack.nframes", v258, v259, v260, v261, v262, v263, v273);
                    _os_crash();
                    __break(1u);
                    goto LABEL_273;
                  }
                  v144 = v132;
                  v143 = self;
                  if (!self)
                  {
LABEL_161:
                    v145 = v143;

                    if (v132 == v145)
                    {
                      if (qword_1ED1DD618)
                      {
                        v153 = *__error();
                        fprintf((FILE *)qword_1ED1DD618, "%'llu Adjusting backward record timestamp %lld to %lld, to match the PET sample that triggered it\n", *(_QWORD *)(a2 + 8), v71, objc_msgSend(v132, "machAbsTime"));
                        *__error() = v153;
                      }
                    }
                    else if (qword_1ED1DD618)
                    {
                      v292 = v132;
                      v146 = *__error();
                      v147 = (FILE *)qword_1ED1DD618;
                      v148 = *(_QWORD *)(a2 + 8);
                      v150 = objc_msgSend(v292, "machAbsTime");
                      v151 = self;
                      if (self)
                        v151 = objc_getProperty(self, v149, 40, 1);
                      v152 = v151;
                      fprintf(v147, "%'llu Adjusting backward record timestamp %lld to %lld, to match the PET sample it straddles, even though the most recent on-cpu sample was at %lld\n", v148, v71, v150, objc_msgSend(v152, "machAbsTime"));

                      *__error() = v146;
                      v139 = 1;
                      v132 = v292;
                      goto LABEL_169;
                    }
                    v139 = 1;
LABEL_169:
                    v137 = v132;
                    goto LABEL_170;
                  }
LABEL_160:
                  v143 = objc_getProperty(v143, v142, 40, 1);
                  goto LABEL_161;
                }
                objc_msgSend(v306, "tasksByPid");
                v95 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", pid_for_thread);
                v96 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v95, "objectForKeyedSubscript:", v96);
                v97 = (void *)objc_claimAutoreleasedReturnValue();

                if ((unint64_t)objc_msgSend(v97, "count") >= 2)
                {
                  objc_msgSend(v97, "objectAtIndexedSubscript:", objc_msgSend(v97, "count") - 2);
                  v98 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v98, "threads");
                  v99 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v99, "objectForKeyedSubscript:", v297);
                  v100 = objc_claimAutoreleasedReturnValue();

                  v308 = (_BYTE *)v100;
                  if (v100)
                  {
                    v101 = v98;

                    v310 = v101;
LABEL_138:

                    goto LABEL_139;
                  }

                }
                +[SAThread threadWithId:]((uint64_t)SAThread, v7);
                v308 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v310, "execTimestamp");
                v120 = (void *)objc_claimAutoreleasedReturnValue();

                if (v120)
                {
                  objc_msgSend(v310, "execTimestamp");
                  v122 = (void *)objc_claimAutoreleasedReturnValue();
                  if (v308)
                    objc_setProperty_atomic(v308, v121, v122, 32);

                }
                -[SATask addThread:]((uint64_t)v310, v308);
                goto LABEL_138;
              }
            }
          }
        }
        else
        {
          if (absolute_from_timestamp)
            goto LABEL_88;
          v72 = 0;
        }
        if (qword_1ED1DD618)
        {
          v78 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Adjusting forward record timestamp %lld to %lld\n", *(_QWORD *)(a2 + 8), v71, v72);
          *__error() = v78;
          goto LABEL_94;
        }
        goto LABEL_98;
      }
      if (!qword_1ED1DD618)
        goto LABEL_262;
      v51 = __error();
      v52 = *(_QWORD *)a2;
      if ((*(_QWORD *)a2 & 4) != 0)
      {
        v53 = *(_QWORD *)(a2 + 16);
        if ((v52 & 2) != 0)
        {
LABEL_59:
          v54 = *(_DWORD *)(a2 + 24);
          if ((v52 & 0x10) != 0)
          {
LABEL_60:
            v55 = *(_DWORD *)(a2 + 48);
LABEL_78:
            v62 = (FILE *)qword_1ED1DD618;
            v63 = *v51;
            v64 = (uint64_t *)a2;
            v65 = *(_QWORD *)(a2 + 8);
            StringForKPDecodeContentBits(v64);
            fprintf(v62, "%'llu Thread 0x%llx core %d event 0x%x skipping kperf content 0x%llx: %s\n", v65, v53, v54, v55, v52, (const char *)&qword_1ED1DD628);
            *__error() = v63;
            goto LABEL_262;
          }
LABEL_77:
          v55 = 0;
          goto LABEL_78;
        }
      }
      else
      {
        v53 = 0;
        if ((v52 & 2) != 0)
          goto LABEL_59;
      }
      v54 = -1;
      if ((v52 & 0x10) != 0)
        goto LABEL_60;
      goto LABEL_77;
    }
    if (objc_msgSend(a1, "dataStyle") != 1)
    {
      if (objc_msgSend(a1, "dataStyle"))
      {
        objc_msgSend(a1, "sampleTimestamps");
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = objc_msgSend(v12, "count");

        if (!v13)
          goto LABEL_262;
      }
    }
    v298 = self;
    v304 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", *(_QWORD *)(a2 + 7360));
    if (*(_QWORD *)(a2 + 7360))
    {
      v14 = 0;
      v303 = a2;
      while (1)
      {
        -[SASampleStore exclaveWithIdentifier:]((uint64_t)v306, *(_QWORD *)(*(_QWORD *)(a2 + 7368) + 2064 * v14));
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        v309 = *(_QWORD *)(a2 + 7368);
        v17 = v309 + 2064 * v14;
        v18 = *(_DWORD *)(v17 + 12);
        v307 = (int *)(v17 + 12);
        if (v18)
          break;
        v26 = 0;
LABEL_48:
        v38 = -[SAExclaveCallstack initWithExclave:leafFrame:]((id *)[SAExclaveCallstack alloc], v16, v26);
        objc_msgSend(v304, "addObject:", v38);
        a2 = v303;

        if ((unint64_t)++v14 >= *(_QWORD *)(v303 + 7360))
          goto LABEL_49;
      }
      v19 = 0;
      a2 = 0;
      v20 = -1;
      while (1)
      {
        v21 = *(_QWORD *)(v309 + 2064 * v14 + 8 * (v18 + v20) + 16);
        if (v19)
        {
          v22 = objc_getProperty(v19, v15, 40, 1);
          if (!v22)
            goto LABEL_30;
          v23 = v22;
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            v24 = v23;
            v317[0] = MEMORY[0x1E0C809B0];
            v317[1] = 3221225472;
            v317[2] = __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke;
            v317[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
            v317[4] = v21;
            -[NSObject objectsPassingTest:](v24, "objectsPassingTest:", v317);
            v25 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v25, "anyObject");
            v26 = objc_claimAutoreleasedReturnValue();

          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              v104 = *__error();
              _sa_logt();
              v105 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
              {
                ClassName = object_getClassName(v23);
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = ClassName;
                _os_log_error_impl(&dword_1B9BE0000, v105, OS_LOG_TYPE_ERROR, "child is %s", buf, 0xCu);
              }

              *__error() = v104;
              v107 = object_getClassName(v23);
              _SASetCrashLogMessage(647, "child is %s", v108, v109, v110, v111, v112, v113, v107);
              _os_crash();
              __break(1u);
LABEL_124:
              v114 = *(_QWORD *)a2;
              *(_DWORD *)buf = 134217984;
              *(_QWORD *)&buf[4] = v114;
              _os_log_fault_impl(&dword_1B9BE0000, v23, OS_LOG_TYPE_FAULT, "Exclave callstack provided with other stack info: 0x%llx", buf, 0xCu);
LABEL_74:

              *__error() = (int)v19;
              goto LABEL_262;
            }
            v29 = v23;
            if (v21 == -[NSObject address](v29, "address"))
              v26 = v29;
            else
              v26 = 0;
          }
          v28 = v23;
        }
        else
        {
          if (v16)
            v27 = objc_getProperty(v16, v15, 40, 1);
          else
            v27 = 0;
          v28 = v27;
          v316[0] = MEMORY[0x1E0C809B0];
          v316[1] = 3221225472;
          v316[2] = __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_67;
          v316[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
          v316[4] = v21;
          -[NSObject objectsPassingTest:](v28, "objectsPassingTest:", v316);
          v23 = objc_claimAutoreleasedReturnValue();
          -[NSObject anyObject](v23, "anyObject");
          v26 = objc_claimAutoreleasedReturnValue();
        }

        if (!v26)
        {
LABEL_30:
          v30 = -[SAExclaveFrame initWithExclave:]([SAExclaveFrame alloc], v16);
          p_isa = (id *)&v30->isa;
          v26 = v30;
          if (v30)
            v30[2].isa = (Class)v21;
          objc_msgSend(v16, "loadInfos");
          v32 = (void *)objc_claimAutoreleasedReturnValue();

          if (v32)
          {
            objc_msgSend(v16, "loadInfos");
            v34 = (void *)objc_claimAutoreleasedReturnValue();
            +[SABinaryLoadInfo binaryLoadInfoForAddress:inBinaryLoadInfos:](SABinaryLoadInfo, "binaryLoadInfoForAddress:inBinaryLoadInfos:", v21, v34);
            v35 = (void *)objc_claimAutoreleasedReturnValue();
            if (v26)
              objc_storeWeak(p_isa + 3, v35);

          }
          if (v26)
            v26[4].isa = (Class)v19;
          if (v19)
          {
            -[SAFrame _addChildFrame:]((uint64_t)v19, v26);
          }
          else
          {
            if (v16)
              v36 = objc_getProperty(v16, v33, 40, 1);
            else
              v36 = 0;
            v37 = v36;
            objc_msgSend(v37, "addObject:", v26);

          }
        }

        a2 = (a2 + 1);
        v18 = *v307;
        --v20;
        v19 = v26;
        if (a2 >= *v307)
          goto LABEL_48;
      }
    }
LABEL_49:
    v39 = -[SAThreadExclavesInfo initWithCallstacks:]([SAThreadExclavesInfo alloc], v304);
    v40 = *(_QWORD *)(a2 + 7344);
    v41 = ktrace_get_pid_for_thread();
    if ((v41 & 0x80000000) != 0)
    {
      v56 = *__error();
      _sa_logt();
      v57 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v41;
        *(_WORD *)&buf[8] = 2048;
        *(_QWORD *)&buf[10] = v40;
        _os_log_error_impl(&dword_1B9BE0000, v57, OS_LOG_TYPE_ERROR, "Invalid pid [%d] for exclave info tid 0x%llu", buf, 0x12u);
      }

      *__error() = v56;
    }
    else
    {
      -[SASampleStore lastTaskWithPid:](v306, v41);
      v42 = (void *)objc_claimAutoreleasedReturnValue();
      v43 = v42;
      if (v42)
      {
        objc_msgSend(v42, "threads");
        v44 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v40);
        v45 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v44, "objectForKeyedSubscript:", v45);
        v46 = (void *)objc_claimAutoreleasedReturnValue();

        v312 = 0;
        v313 = &v312;
        v314 = 0x2020000000;
        v315 = 0;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_72;
        v323 = &unk_1E7147948;
        v326 = a2;
        v47 = v46;
        *(_QWORD *)&v324 = v47;
        v48 = v39;
        *((_QWORD *)&v324 + 1) = v48;
        v325 = &v312;
        objc_msgSend(v47, "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", 0, 0x7FFFFFFFFFFFFFFFLL, 0, 0x7FFFFFFFFFFFFFFFLL, 1, buf);
        if (!*((_DWORD *)v313 + 6))
        {
          v49 = *__error();
          _sa_logt();
          v50 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v47, "debugDescription");
            v182 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v48, "debugDescription");
            v183 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v318 = 138412546;
            v319 = v182;
            v320 = 2112;
            v321 = v183;
            _os_log_error_impl(&dword_1B9BE0000, v50, OS_LOG_TYPE_ERROR, "No thread states in %@ need exclave info %@", v318, 0x16u);

          }
          *__error() = v49;
        }

        _Block_object_dispose(&v312, 8);
      }
      else
      {
        v60 = *__error();
        _sa_logt();
        v61 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v41;
          *(_WORD *)&buf[8] = 2048;
          *(_QWORD *)&buf[10] = v40;
          _os_log_error_impl(&dword_1B9BE0000, v61, OS_LOG_TYPE_ERROR, "No task with pid [%d] for exclave info tid 0x%llx", buf, 0x12u);
        }

        *__error() = v60;
      }

    }
    if ((*(_QWORD *)a2 & 0x1000000C0) != 0)
    {
      LODWORD(v19) = *__error();
      _sa_logt();
      v23 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
        goto LABEL_124;
      goto LABEL_74;
    }
LABEL_262:
    objc_autoreleasePoolPop(context);
  }

}

- (void)backfillTask:(unint64_t)a3 lastSampleIndex:(void *)a4 timestamp:(char)a5 haveSnap:(uint64_t)a6 terminatedThreadsUserTimeInNs:(uint64_t)a7 terminatedThreadsSystemTimeInNs:(uint64_t)a8 terminatedThreadsCycles:(uint64_t)a9 terminatedThreadsInstructions:(int)a10 suspendCount:(int)a11 pageins:(char)a12 isDarwinBG:(char)a13 isForeground:(char)a14 isBoosted:(char)a15 isDirty:(char)a16 haveWQFlags:(char)a17 wqExceededTotalThreadLimit:(char)a18 wqExceededConstrainedThreadLimit:(char)a19 haveMem:(uint64_t)a20 taskSizeInBytes:(char)a21 haveLatencyQos:(int)a22 latencyQos:
{
  id *v25;
  id v26;
  void *v27;
  void *v28;
  char v29;
  const char *v30;
  char v31;
  id v32;
  unint64_t v33;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  uint64_t v41;
  int v42;
  void *v43;
  uint64_t v44;
  FILE *v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  int v53;
  FILE *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  void *v58;
  int v59;
  void *v60;
  void *v65;
  id *v66;
  void *v67;
  _QWORD v68[4];
  id v69;
  id *v70;
  void *v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  char v84;
  char v85;
  char v86;
  char v87;
  char v88;
  char v89;
  char v90;
  _QWORD v91[3];
  int v92;
  _QWORD v93[3];
  char v94;
  _QWORD v95[3];
  char v96;
  _QWORD v97[3];
  char v98;

  v25 = a2;
  v26 = a4;
  v65 = a1;
  if (a1)
  {
    v66 = v25;
    v67 = v26;
    objc_msgSend(v25, "exitTimestamp");
    v27 = (void *)objc_claimAutoreleasedReturnValue();

    if (v27)
    {
      objc_msgSend(v25, "exitTimestamp");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = objc_msgSend(v28, "lt:", v26);

      v31 = v29 ^ 1;
      if (!v25)
        v31 = 1;
      if ((v31 & 1) == 0)
        objc_setProperty_atomic(v25, v30, v26, 232);
    }
    if (a3 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v32 = v26;
      v33 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_25:
      +[SATaskState stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:](SATaskStateKPerf, "stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:", v32, v26, v33, a3);
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      v60 = v32;
      if (v25)
      {
        objc_msgSend(v25[1], "addObject:", v43);
        v44 = objc_msgSend(v25[1], "count") - 1;
      }
      else
      {
        v44 = 0;
      }
      if (qword_1ED1DD618)
      {
        v59 = *__error();
        v45 = (FILE *)qword_1ED1DD618;
        v46 = objc_msgSend(v67, "machAbsTime");
        v47 = objc_msgSend(v25, "pid");
        v48 = objc_msgSend(v43, "startSampleIndex");
        v49 = objc_msgSend(v43, "endSampleIndex");
        objc_msgSend(v43, "startTimestamp");
        v50 = (void *)objc_claimAutoreleasedReturnValue();
        v51 = objc_msgSend(v50, "machAbsTime");
        objc_msgSend(v43, "endTimestamp");
        v52 = (void *)objc_claimAutoreleasedReturnValue();
        fprintf(v45, "%'llu Created taskState (index %lu) for task [%d] (sample index %ld-%ld, machabs %llu-%llu)\n", v46, v44, v47, v48, v49, v51, objc_msgSend(v52, "machAbsTime"));

        *__error() = v59;
      }

LABEL_30:
      v97[0] = 0;
      v97[1] = v97;
      v97[2] = 0x2020000000;
      v98 = a5;
      v95[0] = 0;
      v95[1] = v95;
      v95[2] = 0x2020000000;
      v96 = a19;
      v93[0] = 0;
      v93[1] = v93;
      v93[2] = 0x2020000000;
      v94 = a21;
      v91[0] = 0;
      v91[1] = v91;
      v91[2] = 0x2020000000;
      v92 = 0;
      v68[0] = MEMORY[0x1E0C809B0];
      v68[1] = 3221225472;
      v68[2] = __380__SASampleStore_KPerfPrivate__backfillTask_lastSampleIndex_timestamp_haveSnap_terminatedThreadsUserTimeInNs_terminatedThreadsSystemTimeInNs_terminatedThreadsCycles_terminatedThreadsInstructions_suspendCount_pageins_isDarwinBG_isForeground_isBoosted_isDirty_haveWQFlags_wqExceededTotalThreadLimit_wqExceededConstrainedThreadLimit_haveMem_taskSizeInBytes_haveLatencyQos_latencyQos___block_invoke;
      v68[3] = &unk_1E7147E68;
      v69 = v67;
      v76 = a6;
      v77 = a7;
      v78 = a8;
      v79 = a9;
      v81 = a10;
      v82 = a11;
      v84 = a12;
      v85 = a13;
      v86 = a14;
      v87 = a15;
      v88 = a16;
      v89 = a17;
      v90 = a18;
      v72 = v97;
      v73 = v91;
      v80 = a20;
      v74 = v95;
      v75 = v93;
      v83 = a22;
      v70 = v66;
      v71 = v65;
      objc_msgSend(v70, "enumerateTaskStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", 0, 0x7FFFFFFFFFFFFFFFLL, 0, 0x7FFFFFFFFFFFFFFFLL, 1, v68);

      _Block_object_dispose(v91, 8);
      _Block_object_dispose(v93, 8);
      _Block_object_dispose(v95, 8);
      _Block_object_dispose(v97, 8);

      v25 = v66;
      v26 = v67;
      goto LABEL_31;
    }
    objc_msgSend(v25, "taskStates");
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v34, "lastObject");
    v35 = (void *)objc_claimAutoreleasedReturnValue();

    if (v35)
    {
      if (objc_msgSend(v35, "endSampleIndex") == 0x7FFFFFFFFFFFFFFFLL)
      {
        v33 = 0;
LABEL_18:
        objc_msgSend(v65, "sampleTimestamps");
        v38 = (id)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v38, "objectAtIndexedSubscript:", v33);
        v32 = (id)objc_claimAutoreleasedReturnValue();
        goto LABEL_21;
      }
      v33 = objc_msgSend(v35, "endSampleIndex") + 1;
      if (v33 <= a3)
        goto LABEL_18;
      v38 = v26;
    }
    else
    {
      objc_msgSend(v25, "execTimestamp");
      v36 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v36)
      {
        objc_msgSend(v65, "sampleTimestamps");
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v39, "objectAtIndexedSubscript:", 0);
        v32 = (id)objc_claimAutoreleasedReturnValue();

        v33 = 0;
        goto LABEL_25;
      }
      v33 = objc_msgSend(v65, "indexOfFirstSampleOnOrAfterTimestamp:", v36);
      v37 = v36;
      v38 = v37;
      if (v33 <= a3)
      {
        v32 = v37;
LABEL_21:

        if (v33 != 0x7FFFFFFFFFFFFFFFLL)
          goto LABEL_25;
LABEL_22:
        objc_msgSend(v25, "taskStates");
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        v41 = objc_msgSend(v40, "count");

        v60 = v32;
        if (v41)
        {
          if (qword_1ED1DD618)
          {
            v42 = *__error();
            fprintf((FILE *)qword_1ED1DD618, "%'llu Not creating taskState for task [%d] at machabs %llu due to already having a task state for sample index %lu\n", objc_msgSend(v67, "machAbsTime"), objc_msgSend(v25, "pid"), objc_msgSend(v67, "machAbsTime"), a3);
            *__error() = v42;
          }
        }
        else if (qword_1ED1DD618)
        {
          v53 = *__error();
          v54 = (FILE *)qword_1ED1DD618;
          v55 = objc_msgSend(v26, "machAbsTime");
          v56 = objc_msgSend(v25, "pid");
          v57 = objc_msgSend(v26, "machAbsTime");
          objc_msgSend(v25, "execTimestamp");
          v58 = (void *)objc_claimAutoreleasedReturnValue();
          fprintf(v54, "%'llu Not creating taskState for task [%d] at machabs %llu due to the task being created after sample index %lu at machabs %llu\n", v55, v56, v57, a3, objc_msgSend(v58, "machAbsTime"));

          *__error() = v53;
        }
        goto LABEL_30;
      }

      v35 = 0;
    }

    v32 = v38;
    goto LABEL_22;
  }
LABEL_31:

}

- (void)backfillThread:(void *)a3 inTask:(unint64_t)a4 lastSampleIndex:(void *)a5 timestamp:(char)a6 haveName:(_BYTE *)a7 name:(int)a8 haveDispatchQueueId:(uint64_t)a9 dispatchQueueId:(void *)a10 dispatchQueueLabel:(void *)a11 leafKernelFrame:(unsigned __int8)a12 hasExclaveInKernelStack:(char)a13 haveUserStack:(void *)a14 leafUserFrame:(uint64_t)a15 swiftTaskId:(void *)a16 leafOfCRootFramesReplacedBySwiftAsync:(void *)a17 threadExclavesInfo:(char)a18 haveSched:(uint64_t)a19 systemCpuTimeNs:(uint64_t)a20 userCpuTimeNs:(int)a21 basePriority:(int)a22 scheduledPriority:(int)a23 state:(char)a24 threadQos:(char)a25 threadRequestedQos:(char)a26 threadRequestedQosOverride:(char)a27 threadQosPromote:(char)a28 haveCycIns:(uint64_t)a29 instructions:(uint64_t)a30 cycles:(char)a31 haveSnap:(char)a32 ioTier:(char)a33 isIOPassive:(char)a34 isDarwinBG:(char)a35 isSuspended:(char)a36 isGlobalForcedIdle:(char)a37 isIdleWorkQueue:(void *)a38 lastMadeRunnableTime:(char)a39 isOnCore:(unsigned __int8)a40 isOnCoreForLastSampleIndex:(unsigned int)a41 cpuNum:
{
  void *v45;
  const char *v46;
  void *v47;
  void *v48;
  char v49;
  const char *v50;
  char v51;
  unint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  id v57;
  void *v58;
  const char *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  void *v64;
  uint64_t v65;
  int v66;
  int v67;
  _BYTE *v68;
  const char *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  _BOOL4 v83;
  const char *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  _BYTE *v89;
  id v90;
  id v91;
  id v92;
  _BYTE *v93;
  int v94;
  FILE *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  int v100;
  NSObject *v101;
  id v102;
  uint64_t v103;
  id v104;
  id v105;
  char v106;
  id v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  id v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  id v118;
  uint64_t v119;
  int v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  FILE *v124;
  FILE *v125;
  uint64_t v126;
  uint64_t v127;
  void *v130;
  void *v131;
  id v133;
  id v134;
  id v135;
  id v136;
  void *v137;
  id v138;
  id newValue;
  id v140;
  id v141;
  id v142;
  id *v143;
  _QWORD v144[4];
  id v145;
  id *v146;
  id v147;
  id v148;
  id v149;
  id v150;
  id v151;
  id v152;
  id v153;
  id v154;
  id v155;
  void *v156;
  _BYTE *v157;
  _QWORD *v158;
  _QWORD *v159;
  _QWORD *v160;
  _QWORD *v161;
  _QWORD *v162;
  _QWORD *v163;
  _QWORD *v164;
  _QWORD *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  int v171;
  int v172;
  int v173;
  char v174;
  char v175;
  char v176;
  char v177;
  char v178;
  char v179;
  char v180;
  char v181;
  char v182;
  char v183;
  _QWORD v184[3];
  int v185;
  _QWORD v186[3];
  BOOL v187;
  _QWORD v188[3];
  char v189;
  _QWORD v190[3];
  char v191;
  _QWORD v192[3];
  char v193;
  _QWORD v194[3];
  char v195;
  _QWORD v196[3];
  BOOL v197;
  _QWORD v198[3];
  char v199;
  _BYTE buf[24];
  char v201;
  uint64_t v202;

  v202 = *MEMORY[0x1E0C80C00];
  v143 = a2;
  v141 = a3;
  v142 = a5;
  newValue = a11;
  v138 = a14;
  v134 = a16;
  v140 = a17;
  v135 = a38;
  v131 = a1;
  if (!a1)
    goto LABEL_99;
  objc_msgSend(v143, "exitTimestamp");
  v45 = (void *)objc_claimAutoreleasedReturnValue();

  if (v143 && v45)
    objc_setProperty_atomic(v143, v46, v142, 40);
  objc_msgSend(v141, "exitTimestamp");
  v47 = (void *)objc_claimAutoreleasedReturnValue();

  if (v47)
  {
    objc_msgSend(v141, "exitTimestamp");
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v49 = objc_msgSend(v48, "lt:", v142);

    v51 = v49 ^ 1;
    if (!v141)
      v51 = 1;
    if ((v51 & 1) == 0)
      objc_setProperty_atomic(v141, v50, v142, 232);
  }
  if (a4 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v136 = v142;
    v52 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_48;
  }
  objc_msgSend(v143, "threadStates");
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v53, "lastObject");
  v54 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v54)
  {
    objc_msgSend(v143, "creationTimestamp");
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    if (v55)
    {
      v52 = objc_msgSend(a1, "indexOfFirstSampleOnOrAfterTimestamp:", v55);
      if (v52 > a4)
      {
        v136 = v142;

        v54 = 0;
        goto LABEL_20;
      }
      objc_msgSend(v131, "sampleTimestamps");
      v56 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v56, "objectAtIndexedSubscript:", v52);
      v136 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      objc_msgSend(a1, "sampleTimestamps");
      v56 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v56, "objectAtIndexedSubscript:", 0);
      v136 = (id)objc_claimAutoreleasedReturnValue();
      v55 = 0;
      v52 = 0;
    }

    goto LABEL_25;
  }
  if (objc_msgSend(v54, "endSampleIndex") != 0x7FFFFFFFFFFFFFFFLL)
  {
    v52 = objc_msgSend(v54, "endSampleIndex") + 1;
    if (v52 <= a4)
      goto LABEL_21;
    v136 = v142;
LABEL_20:

    goto LABEL_45;
  }
  v52 = 0;
LABEL_21:
  objc_msgSend(v131, "sampleTimestamps");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v55, "objectAtIndexedSubscript:", v52);
  v136 = (id)objc_claimAutoreleasedReturnValue();
LABEL_25:

  if (!a39 || v52 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v57 = v136;
    goto LABEL_44;
  }
  if (v52 < a4 || (a40 & 1) == 0)
  {
    +[SAThreadState stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:](SAThreadStateKPerf, "stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:", v136, v142, v52, a4 - a40);
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    v60 = v58;
    if (v58)
      objc_setProperty_atomic(v58, v59, newValue, 80);
    if (a12)
      objc_msgSend(v60, "setNeedsExclave:", 1);
    -[SAThreadState setCpuNum:]((uint64_t)v60, a41);
    if (v143)
    {
      objc_msgSend(v143[1], "addObject:", v60);
      v126 = objc_msgSend(v143[1], "count") - 1;
    }
    else
    {
      v126 = 0;
    }
    if (a40)
      v52 = a4;
    else
      v52 = 0x7FFFFFFFFFFFFFFFLL;
    v57 = v142;

    if (qword_1ED1DD618)
    {
      v120 = *__error();
      v124 = (FILE *)qword_1ED1DD618;
      v122 = objc_msgSend(v57, "machAbsTime");
      v119 = objc_msgSend(v143, "threadId");
      v117 = objc_msgSend(v60, "startSampleIndex");
      v116 = objc_msgSend(v60, "endSampleIndex");
      objc_msgSend(v60, "startTimestamp");
      v137 = (void *)objc_claimAutoreleasedReturnValue();
      v115 = objc_msgSend(v137, "machAbsTime");
      objc_msgSend(v60, "endTimestamp");
      v61 = (void *)objc_claimAutoreleasedReturnValue();
      v62 = objc_msgSend(v61, "machAbsTime");
      objc_msgSend(v60, "leafKernelFrame");
      v63 = (void *)objc_claimAutoreleasedReturnValue();
      fprintf(v124, "%'llu Created off-core threadState (index %lu) for thread 0x%llx (sample index %ld-%ld, machabs %llu-%llu) with kernel stack (leaf frame 0x%llx) exclaves:%d due to on-core thread state applying to multiple sample indexes\n", v122, v126, v119, v117, v116, v115, v62, objc_msgSend(v63, "address"), a12);

      *__error() = v120;
    }

LABEL_44:
    v136 = v57;
    if (v52 != 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_48;
LABEL_45:
    objc_msgSend(v143, "threadStates");
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    v65 = objc_msgSend(v64, "count");

    if (v65)
    {
      if (qword_1ED1DD618)
      {
        v66 = *__error();
        fprintf((FILE *)qword_1ED1DD618, "%'llu Not creating threadState for thread 0x%llx at machabs %llu due to already having a thread state for sample index %lu (kernel leaf frame 0x%llx, user leaf frame 0x%llx)\n", objc_msgSend(v142, "machAbsTime"), objc_msgSend(v143, "threadId"), objc_msgSend(v142, "machAbsTime"), a4, objc_msgSend(newValue, "address"), objc_msgSend(v138, "address"));
        *__error() = v66;
      }
    }
    else if (qword_1ED1DD618)
    {
      v94 = *__error();
      v95 = (FILE *)qword_1ED1DD618;
      v96 = objc_msgSend(v142, "machAbsTime");
      v97 = objc_msgSend(v143, "threadId");
      v98 = objc_msgSend(v142, "machAbsTime");
      objc_msgSend(v143, "creationTimestamp");
      v99 = (void *)objc_claimAutoreleasedReturnValue();
      fprintf(v95, "%'llu Not creating threadState for thread 0x%llx at machabs %llu due to the thread being created after sample index %lu at machabs %llu (kernel leaf frame 0x%llx, user leaf frame 0x%llx)\n", v96, v97, v98, a4, objc_msgSend(v99, "machAbsTime"), objc_msgSend(newValue, "address"), objc_msgSend(v138, "address"));

      *__error() = v94;
    }
    goto LABEL_68;
  }
  if (!objc_msgSend(v136, "eq:", v142))
  {
    v100 = *__error();
    _sa_logt();
    v101 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(v136, "debugDescription");
      v102 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v103 = objc_msgSend(v102, "UTF8String");
      objc_msgSend(v142, "debugDescription");
      v104 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v103;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = objc_msgSend(v104, "UTF8String");
      _os_log_error_impl(&dword_1B9BE0000, v101, OS_LOG_TYPE_ERROR, "Start timestamp %s vs %s", buf, 0x16u);

    }
    *__error() = v100;
    objc_msgSend(v136, "debugDescription");
    v105 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v106 = objc_msgSend(v105, "UTF8String");
    objc_msgSend(v142, "debugDescription");
    v107 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    objc_msgSend(v107, "UTF8String");
    _SASetCrashLogMessage(3973, "Start timestamp %s vs %s", v108, v109, v110, v111, v112, v113, v106);

    _os_crash();
    __break(1u);
  }

LABEL_48:
  if (newValue || !v140 || a39)
  {
    +[SAThreadState stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:](SAThreadStateKPerf, "stateWithStartTimestamp:endTimestamp:startSampleIndex:endSampleIndex:", v136, v142, v52, a4);
    v68 = (_BYTE *)objc_claimAutoreleasedReturnValue();
    -[SAThreadState setCpuNum:]((uint64_t)v68, a41);
    if (a39)
    {
      if (v68)
      {
        v68[19] |= 0x40u;
LABEL_57:
        objc_setProperty_atomic(v68, v69, newValue, 80);
      }
    }
    else if (v68)
    {
      goto LABEL_57;
    }
    if (a12)
      objc_msgSend(v68, "setNeedsExclave:", 1);
    if (v143)
    {
      objc_msgSend(v143[1], "addObject:", v68);
      v127 = objc_msgSend(v143[1], "count") - 1;
    }
    else
    {
      v127 = 0;
    }
    if (qword_1ED1DD618)
    {
      v121 = *__error();
      v125 = (FILE *)qword_1ED1DD618;
      v123 = objc_msgSend(v142, "machAbsTime");
      if (objc_msgSend(v68, "isRunning"))
        v70 = "on";
      else
        v70 = "off";
      v71 = objc_msgSend(v143, "threadId");
      v72 = objc_msgSend(v68, "startSampleIndex");
      v73 = objc_msgSend(v68, "endSampleIndex");
      objc_msgSend(v68, "startTimestamp");
      v74 = (void *)objc_claimAutoreleasedReturnValue();
      v75 = objc_msgSend(v74, "machAbsTime");
      objc_msgSend(v68, "endTimestamp");
      v76 = (void *)objc_claimAutoreleasedReturnValue();
      v77 = objc_msgSend(v76, "machAbsTime");
      objc_msgSend(v68, "leafKernelFrame");
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      fprintf(v125, "%'llu Created %s-core threadState (index %lu) for thread 0x%llx (sample index %ld-%ld, machabs %llu-%llu) with kernel leaf frame 0x%llx) exclaves:%d\n", v123, v70, v127, v71, v72, v73, v75, v77, objc_msgSend(v78, "address"), a12);

      *__error() = v121;
    }

    goto LABEL_68;
  }
  if (qword_1ED1DD618)
  {
    v67 = *__error();
    fprintf((FILE *)qword_1ED1DD618, "%'llu Not creating threadState for thread 0x%llx at machabs %llu due to only have exclave info to backfill\n", objc_msgSend(v142, "machAbsTime"), objc_msgSend(v143, "threadId"), objc_msgSend(v142, "machAbsTime"));
    *__error() = v67;
  }
LABEL_68:
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2020000000;
  v201 = a6;
  if (a7 && *a7)
  {
    SANSStringForCString(a7);
    v130 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v130 = 0;
  }
  v79 = 0;
  v198[0] = 0;
  v198[1] = v198;
  v198[2] = 0x2020000000;
  v199 = a8;
  if (a9)
  {
    v133 = 0;
    if (a8)
    {
      objc_msgSend(v141, "dispatchQueues");
      v80 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a9);
      v81 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v80, "objectForKeyedSubscript:", v81);
      v79 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v79)
      {
        +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SADispatchQueue, a9);
        v79 = (void *)objc_claimAutoreleasedReturnValue();
        -[SATask addDispatchQueue:]((uint64_t)v141, v79);
      }
      if (a10)
      {
        objc_msgSend(v79, "dispatchQueueLabel");
        v82 = (void *)objc_claimAutoreleasedReturnValue();
        v83 = v82 == 0;

        if (v83)
        {
          SANSStringForCString(a10);
          v85 = (void *)objc_claimAutoreleasedReturnValue();
          if (v85 && v79)
            objc_setProperty_atomic_copy(v79, v84, v85, 32);

        }
      }
      v133 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    }
  }
  else
  {
    v133 = 0;
  }
  v196[0] = 0;
  v196[1] = v196;
  v196[2] = 0x2020000000;
  v197 = a15 != 0;
  if (a15)
  {
    objc_msgSend(v141, "swiftTasks");
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a15);
    v87 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v86, "objectForKeyedSubscript:", v87);
    v88 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v88)
    {
      +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, a15);
      v88 = (void *)objc_claimAutoreleasedReturnValue();
      -[SATask addSwiftTask:]((uint64_t)v141, v88);
    }
    v118 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  }
  else
  {
    v88 = 0;
    v118 = 0;
  }
  v194[0] = 0;
  v194[1] = v194;
  v194[2] = 0x2020000000;
  v195 = a13;
  v192[0] = 0;
  v192[1] = v192;
  v192[2] = 0x2020000000;
  v193 = a18;
  v190[0] = 0;
  v190[1] = v190;
  v190[2] = 0x2020000000;
  v191 = a28;
  v188[0] = 0;
  v188[1] = v188;
  v188[2] = 0x2020000000;
  v189 = a31;
  v186[0] = 0;
  v186[1] = v186;
  v186[2] = 0x2020000000;
  v187 = v140 != 0;
  v184[0] = 0;
  v184[1] = v184;
  v184[2] = 0x2020000000;
  v185 = 0;
  v144[0] = MEMORY[0x1E0C809B0];
  v144[1] = 3221225472;
  v144[2] = __616__SASampleStore_KPerfPrivate__backfillThread_inTask_lastSampleIndex_timestamp_haveName_name_haveDispatchQueueId_dispatchQueueId_dispatchQueueLabel_leafKernelFrame_hasExclaveInKernelStack_haveUserStack_leafUserFrame_swiftTaskId_leafOfCRootFramesReplacedBySwiftAsync_threadExclavesInfo_haveSched_systemCpuTimeNs_userCpuTimeNs_basePriority_scheduledPriority_state_threadQos_threadRequestedQos_threadRequestedQosOverride_threadQosPromote_haveCycIns_instructions_cycles_haveSnap_ioTier_isIOPassive_isDarwinBG_isSuspended_isGlobalForcedIdle_isIdleWorkQueue_lastMadeRunnableTime_isOnCore_isOnCoreForLastSampleIndex_cpuNum___block_invoke;
  v144[3] = &unk_1E7147E40;
  v145 = v142;
  v146 = v143;
  v157 = buf;
  v114 = v130;
  v147 = v114;
  v158 = v184;
  v159 = v198;
  v89 = v79;
  v148 = v89;
  v90 = v133;
  v149 = v90;
  v160 = v194;
  v150 = v138;
  v151 = v134;
  v161 = v196;
  v166 = a15;
  v91 = v88;
  v152 = v91;
  v92 = v118;
  v153 = v92;
  v162 = v192;
  v167 = a19;
  v168 = a20;
  v171 = a23;
  v172 = a21;
  v173 = a22;
  v174 = a24;
  v175 = a25;
  v176 = a26;
  v177 = a27;
  v169 = a29;
  v170 = a30;
  v163 = v190;
  v164 = v188;
  v178 = a32;
  v179 = a33;
  v180 = a35;
  v181 = a34;
  v182 = a37;
  v183 = a36;
  v154 = v135;
  v165 = v186;
  v155 = v140;
  v156 = v131;
  objc_msgSend(v146, "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", 0, 0x7FFFFFFFFFFFFFFFLL, 0, 0x7FFFFFFFFFFFFFFFLL, 1, v144);
  if (v89 && objc_msgSend(v90, "count"))
  {
    if (v89[24])
      v93 = 0;
    else
      v93 = v89 + 24;
    -[SARecipe addStates:hasConcurrentExecution:]((uint64_t)v89, v90, v93);
  }
  if (v91 && objc_msgSend(v92, "count"))
    -[SARecipe addStates:hasConcurrentExecution:]((uint64_t)v91, v92, 0);

  _Block_object_dispose(v184, 8);
  _Block_object_dispose(v186, 8);
  _Block_object_dispose(v188, 8);
  _Block_object_dispose(v190, 8);
  _Block_object_dispose(v192, 8);
  _Block_object_dispose(v194, 8);

  _Block_object_dispose(v196, 8);
  _Block_object_dispose(v198, 8);

  _Block_object_dispose(buf, 8);
LABEL_99:

}

- (id)applySharedCacheToTask:(uint64_t)a3 uuid:(uint64_t)a4 slide:(uint64_t)a5 slidBaseAddress:
{
  _BYTE *v9;
  _BYTE *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  const char *v14;
  _QWORD *v15;
  void *v16;
  int v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  void *v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  int v32;
  _BYTE v33[24];
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  void *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  v10 = v9;
  if (!a1)
  {
    v21 = 0;
    goto LABEL_25;
  }
  objc_msgSend(v9, "sharedCache");
  v11 = (_QWORD *)objc_claimAutoreleasedReturnValue();
  v12 = v11;
  if (v11)
  {
    if ((objc_msgSend(v11, "matchesUUID:slide:slidBaseAddress:", a3, a4, a5) & 1) != 0)
    {
      v13 = 0;
LABEL_22:
      v15 = v12;
      goto LABEL_23;
    }
    uuidForBytes(a3);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "uuid");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "isEqual:", v13);

    if (v17)
    {
      v18 = objc_msgSend(v12, "slidBaseAddress");
      if (a5 != -1 && v18 == -1)
      {
        -[SASharedCache setSlidBaseAddress:](v12, a5);
        goto LABEL_22;
      }
      v22 = objc_msgSend(v12, "slide");
      if (a4 != -1 && v22 == -1)
      {
        -[SASharedCache setSlide:](v12, a4);
        goto LABEL_22;
      }
      v23 = *__error();
      _sa_logt();
      v24 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        objc_msgSend(v10, "sharedCache");
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v28, "debugDescription");
        v29 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = 68158722;
        *(_DWORD *)v33 = 16;
        *(_WORD *)&v33[4] = 2096;
        *(_QWORD *)&v33[6] = a3;
        *(_WORD *)&v33[14] = 2048;
        *(_QWORD *)&v33[16] = a4;
        v34 = 2048;
        v35 = a5;
        v36 = 2112;
        v37 = v29;
        _os_log_fault_impl(&dword_1B9BE0000, v24, OS_LOG_TYPE_FAULT, "Mismatching shared cache %{uuid_t}.16P slide 0x%llx slideBaseAddress 0x%llx, but task already has %@", (uint8_t *)&v32, 0x30u);

      }
    }
    else
    {
      v23 = *__error();
      _sa_logt();
      v24 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        objc_msgSend(v10, "sharedCache");
        v30 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v30, "debugDescription");
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = 68158722;
        *(_DWORD *)v33 = 16;
        *(_WORD *)&v33[4] = 2096;
        *(_QWORD *)&v33[6] = a3;
        *(_WORD *)&v33[14] = 2048;
        *(_QWORD *)&v33[16] = a4;
        v34 = 2048;
        v35 = a5;
        v36 = 2112;
        v37 = v31;
        _os_log_fault_impl(&dword_1B9BE0000, v24, OS_LOG_TYPE_FAULT, "Mismatching shared cache %{uuid_t}.16P slide 0x%llx slideBaseAddress 0x%llx, but task already has %@", (uint8_t *)&v32, 0x30u);

      }
    }

    *__error() = v23;
    goto LABEL_22;
  }
  -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, a3, a4, a5);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (v10)
  {
    if ((v10[72] & 1) != 0)
    {
      v19 = *__error();
      _sa_logt();
      v20 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
      {
        objc_msgSend(v13, "debugDescription");
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "debugDescription");
        v27 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = 138412546;
        *(_QWORD *)v33 = v26;
        *(_WORD *)&v33[8] = 2112;
        *(_QWORD *)&v33[10] = v27;
        _os_log_fault_impl(&dword_1B9BE0000, v20, OS_LOG_TYPE_FAULT, "shared cache %@, though task %@ has no shared cache", (uint8_t *)&v32, 0x16u);

      }
      v21 = 0;
      *__error() = v19;
      goto LABEL_24;
    }
    objc_setProperty_atomic(v10, v14, v13, 256);
  }
  v15 = v13;
  v13 = v15;
LABEL_23:
  v21 = v15;
LABEL_24:

LABEL_25:
  return v21;
}

- (uint64_t)checkDyldInfoCompletion:(uint64_t)a1
{
  unint64_t *v3;
  const char *v4;
  unint64_t *v5;
  uint64_t v6;
  id v7;
  const char *v8;
  const char *v9;
  int v10;
  FILE *v11;
  id v12;
  id v13;
  unint64_t v14;
  SEL v15;
  id v16;
  void *v17;
  void *v18;
  const char *v19;
  void *v20;
  const char *v21;
  id v22;
  uint64_t v23;
  const char *v24;
  id Property;
  id v26;
  id v27;
  unint64_t v28;
  int v29;
  NSObject *v30;
  id v31;
  void *v32;
  void *v33;
  void *v34;
  const char *v35;
  void *v36;
  id v38;
  uint8_t buf[24];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v5 = v3;
  v6 = 0;
  if (a1 && v3)
  {
    if (*((_BYTE *)v3 + 9) && (*((_BYTE *)v3 + 10) || v3[5] + 1 < 2))
    {
      v7 = objc_getProperty(v3, v4, 48, 1);
      if (v7 || v5[5] + 1 < 2)
      {

      }
      else
      {
        v27 = objc_getProperty(v5, v8, 24, 1);
        if (v27)
        {
          v28 = v5[4];

          if (v28)
          {
            v29 = *__error();
            _sa_logt();
            v30 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              objc_msgSend(v5, "debugDescription");
              v38 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = objc_msgSend(v38, "UTF8String");
              _os_log_error_impl(&dword_1B9BE0000, v30, OS_LOG_TYPE_ERROR, "bad complete dyld info: %s", buf, 0xCu);

            }
            *__error() = v29;
            goto LABEL_37;
          }
        }
      }
      if (qword_1ED1DD618)
      {
        v10 = *__error();
        v11 = (FILE *)qword_1ED1DD618;
        objc_msgSend(v5, "debugDescription");
        v12 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        fprintf(v11, "%'llu %s\n\n", 0, (const char *)objc_msgSend(v12, "UTF8String"));

        *__error() = v10;
      }
      v13 = objc_getProperty(v5, v9, 16, 1);
      v14 = v5[4];
      v16 = objc_getProperty(v5, v15, 24, 1);
      v17 = v16;
      if ((v5[1] & 1) != 0)
      {
        *(_OWORD *)buf = 0uLL;
        objc_msgSend(v16, "getUUIDBytes:", buf);
        v26 = -[SASampleStore applySharedCacheToTask:uuid:slide:slidBaseAddress:](a1, v13, (uint64_t)buf, -1, v14);
      }
      else
      {
        objc_msgSend(v13, "sharedCache");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        v20 = v18;
        if (!v18
          || objc_msgSend(v18, "startAddress") == -1
          || v14 < objc_msgSend(v20, "startAddress")
          || v14 >= objc_msgSend(v20, "endAddress"))
        {
          v22 = objc_getProperty(v5, v19, 48, 1);
          if (v22)
          {
            v23 = objc_msgSend(objc_getProperty(v5, v21, 48, 1), "length");

            if (v23)
            {
              Property = objc_getProperty(v5, v24, 48, 1);
              SACachedNSString(Property);
              v22 = (id)objc_claimAutoreleasedReturnValue();
            }
            else
            {
              v22 = 0;
            }
          }
          if (objc_msgSend(v22, "isAbsolutePath"))
            v31 = v22;
          else
            v31 = 0;
          +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v17, v31);
          v32 = (void *)objc_claimAutoreleasedReturnValue();
          +[SABinaryLoadInfo binaryLoadInfoWithBinary:loadAddress:isInKernelAddressSpace:exclave:]((uint64_t)SABinaryLoadInfo, v32, v14, objc_msgSend(v13, "pid") == 0, 0);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v32, "path");
          v34 = (void *)objc_claimAutoreleasedReturnValue();

          if (v22 && !v34 && v32)
            objc_setProperty_atomic_copy(v32, v35, v22, 80);
          v36 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithObjects:", v33, 0);
          -[SATask addImageInfos:]((uint64_t)v13, v36);

        }
      }

LABEL_37:
      v6 = 1;
      goto LABEL_38;
    }
    v6 = 0;
  }
LABEL_38:

  return v6;
}

- (void)_addKPerfDataFromKTraceSession:(uint64_t)a3 beforeMachAbsTime:(int)a4 petTimerID:
{
  SAFrameIterator *v8;
  SAKPerfState *v9;
  _QWORD *v10;
  _QWORD *v11;
  id v12;
  void *v13;
  id v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  id v21;
  id v22;
  void *v23;
  char v24;
  id v25;
  SAFrameIterator *v26;
  void *v27;
  id v28;
  id v29;
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[10];
  id v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, _QWORD *);
  void *v40;
  _BYTE *v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t);
  void *v48;
  id v49;
  _BYTE *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t *);
  void *v57;
  id v58;
  _BYTE *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void (*v65)(_QWORD *, uint64_t);
  void *v66;
  id v67;
  _BYTE *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void (*v74)(uint64_t, uint64_t);
  void *v75;
  _BYTE *v76;
  id v77;
  id v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(uint64_t, uint64_t);
  void *v85;
  _BYTE *v86;
  _QWORD *v87;
  uint64_t v88;
  uint64_t v89;
  void (*v90)(uint64_t, _BYTE *);
  void *v91;
  _BYTE *v92;
  _QWORD *v93;
  SAFrameIterator *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void (*v99)(_QWORD *, uint64_t);
  void *v100;
  id v101;
  _BYTE *v102;
  _QWORD *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void (*v107)(uint64_t, uint64_t);
  void *v108;
  _BYTE *v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  void (*v115)(uint64_t, uint64_t *);
  void *v116;
  _BYTE *v117;
  _QWORD *v118;
  objc_super *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  objc_super v123;
  uint64_t v124;
  uint64_t v125;

  v8 = objc_alloc_init(SAFrameIterator);
  -[SAFrameIterator setBacktracer:](v8, "setBacktracer:", 1);
  objc_opt_self();
  v9 = [SAKPerfState alloc];
  if (v9)
  {
    v123.receiver = v9;
    v123.super_class = (Class)SAKPerfState;
    v10 = objc_msgSendSuper2(&v123, sel_init);
    v11 = v10;
    if (v10)
    {
      v10[3] = a2;
      *((_DWORD *)v10 + 5) = a4;
      v12 = objc_alloc_init(MEMORY[0x1E0C99E20]);
      v13 = (void *)v11[1];
      v11[1] = v12;

    }
  }
  else
  {
    v11 = 0;
  }
  v14 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v123.receiver = 0;
  v123.super_class = (Class)&v123;
  v124 = 0x2020000000;
  v125 = 0;
  objc_msgSend(a1, "kPerfPETSampleIntervalLimit");
  v16 = v15;
  v17 = objc_msgSend(a1, "machTimebase");
  v18 = 0;
  if ((_DWORD)v17)
  {
    if (HIDWORD(v17))
    {
      v18 = (unint64_t)(v16 * 1000000000.0);
      if (HIDWORD(v17) != (_DWORD)v17)
        v18 = __udivti3();
    }
  }
  v19 = MEMORY[0x1E0C809B0];
  v113 = MEMORY[0x1E0C809B0];
  v114 = 3221225472;
  v115 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke;
  v116 = &unk_1E7147970;
  v120 = a2;
  v121 = a3;
  v122 = v18;
  v119 = &v123;
  v117 = a1;
  v118 = v11;
  ktrace_events_single();
  v105 = v19;
  v106 = 3221225472;
  v107 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2;
  v108 = &unk_1E7147998;
  v112 = a3;
  v111 = a2;
  v109 = a1;
  v110 = v118;
  ktrace_events_single();
  v97 = v19;
  v98 = 3221225472;
  v99 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3;
  v100 = &unk_1E71479C0;
  v101 = v14;
  v102 = a1;
  v103 = v110;
  v104 = a2;
  ktrace_events_single();
  v88 = v19;
  v89 = 3221225472;
  v90 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_128;
  v91 = &unk_1E71479E8;
  v96 = a3;
  v95 = a2;
  v92 = a1;
  v93 = v103;
  v26 = v8;
  v94 = v26;
  ktrace_kperf();
  v82 = v19;
  v83 = 3221225472;
  v84 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_132;
  v85 = &unk_1E7147A10;
  v86 = a1;
  v87 = v93;
  ktrace_events_single();
  v27 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 1);
  v72 = v19;
  v73 = 3221225472;
  v74 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2_133;
  v75 = &unk_1E7147A38;
  v81 = a3;
  v80 = a2;
  v76 = a1;
  v77 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 1);
  v78 = v27;
  v79 = v87;
  ktrace_events_single();
  v63 = v19;
  v64 = 3221225472;
  v65 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3_136;
  v66 = &unk_1E7147A60;
  v70 = a2;
  v71 = a3;
  v25 = v78;
  v67 = v25;
  v68 = a1;
  v69 = v79;
  ktrace_events_single();
  v54 = v19;
  v55 = 3221225472;
  v56 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_4;
  v57 = &unk_1E7147A60;
  v61 = a2;
  v62 = a3;
  v58 = v77;
  v59 = a1;
  v60 = v69;
  ktrace_events_single();
  v45 = v19;
  v46 = 3221225472;
  v47 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_5;
  v48 = &unk_1E7147A60;
  v52 = a2;
  v53 = a3;
  v20 = v58;
  v49 = v20;
  v50 = a1;
  v51 = v60;
  ktrace_events_single();
  v37 = v19;
  v38 = 3221225472;
  v39 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_6;
  v40 = &unk_1E7147998;
  v43 = a2;
  v44 = a3;
  v41 = a1;
  v42 = v51;
  ktrace_events_single();
  v32[5] = v19;
  v32[6] = 3221225472;
  v32[7] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_7;
  v32[8] = &unk_1E7147A60;
  v35 = a2;
  v36 = a3;
  v32[9] = a1;
  v21 = v42;
  v33 = v21;
  v22 = v101;
  v34 = v22;
  ktrace_events_range();
  objc_msgSend(a1, "osProductName");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = SAIsEmbeddedPlatform(v23);

  if (a1)
    a1[325] = v24 ^ 1;
  v32[0] = v19;
  v32[1] = 3221225472;
  v32[2] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_8;
  v32[3] = &unk_1E7147A88;
  v32[4] = a1;
  +[SAGesture parseKTrace:embedded:findingGestureAndHIDEvents:]((uint64_t)SAGesture, a2, v24, v32);
  v31[0] = v19;
  v31[1] = 3221225472;
  v31[2] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_9;
  v31[3] = &unk_1E7147AB0;
  v31[4] = a1;
  +[SAIOEvent parseKTrace:findingIOEvents:]((uint64_t)SAIOEvent, a2, v31);
  v30[0] = v19;
  v30[1] = 3221225472;
  v30[2] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_10;
  v30[3] = &unk_1E7147AD8;
  v30[4] = a1;
  +[SAMemoryPressureEvent parseKTrace:findingMemoryPressureEvents:]((uint64_t)SAMemoryPressureEvent, a2, v30);
  v28 = v21;
  v29 = v22;
  ktrace_events_single();

  _Block_object_dispose(&v123, 8);
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke(uint64_t a1, uint64_t *a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  BOOL v12;
  uint64_t v13;
  const char *v14;
  void *v15;
  const char *v16;
  id v17;
  void *v18;
  const char *v19;
  id Property;
  id v21;
  int *v22;
  const char *v23;
  FILE *v24;
  int v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  id v30;
  id v31;
  const char *v32;
  const char *v33;
  uint64_t v34;
  int v35;

  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 64))
  {
    v5 = absolute_from_timestamp;
    if (a2[2] && (v6 = *(_QWORD *)(a1 + 72)) != 0)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
      v8 = *(_QWORD *)(v7 + 24);
      if (absolute_from_timestamp >= v8)
      {
        if (!v8)
        {
          *(_QWORD *)(v7 + 24) = absolute_from_timestamp;
          v6 = *(_QWORD *)(a1 + 72);
          v7 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
          v8 = *(_QWORD *)(v7 + 24);
        }
        v35 = 0;
        *(_QWORD *)(v7 + 24) = v6 + v8;
      }
      else
      {
        v35 = 1;
      }
    }
    else
    {
      v35 = 0;
    }
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(id *)(a1 + 40);
    v11 = v10;
    if (!v9)
      goto LABEL_47;
    if (a2[2])
    {
      v12 = 1;
      if (!v10)
        goto LABEL_20;
    }
    else
    {
      if (!v10)
      {
        v12 = 1;
        goto LABEL_20;
      }
      v13 = *((unsigned int *)v10 + 5);
      v12 = (v13 & 0x80000000) == 0 && a2[1] == v13;
    }
    v10[16] = v12;
    v12 = 0;
LABEL_20:
    +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, (uint64_t)a2);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v12)
      objc_setProperty_atomic(v11, v14, v15, 40);

    if ((v35 & 1) != 0)
      goto LABEL_38;
    if (objc_msgSend((id)v9, "dataStyle") == 1 || !objc_msgSend((id)v9, "dataStyle"))
    {
      *(_QWORD *)(v9 + 32) = objc_msgSend((id)v9, "numSamples") + 1;
      objc_msgSend((id)v9, "startTime");
      v18 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v18)
      {
        if (v12)
          Property = 0;
        else
          Property = objc_getProperty(v11, v19, 40, 1);
        -[SASampleStore setStartTime:](v9, Property);
      }
      if (v12)
        v21 = 0;
      else
        v21 = objc_getProperty(v11, v19, 40, 1);
      -[SASampleStore setEndTime:](v9, v21);
      goto LABEL_38;
    }
    if (!v12 && (v11[16] & 1) != 0)
      goto LABEL_29;
    if (objc_msgSend((id)v9, "dataSource") == 2)
      goto LABEL_38;
    if (v12)
      v17 = 0;
    else
LABEL_29:
      v17 = objc_getProperty(v11, v16, 40, 1);
    objc_msgSend(*(id *)(v9 + 24), "addObject:", v17);
LABEL_38:
    if (qword_1ED1DD618)
    {
      v22 = __error();
      v23 = "non-PET";
      if (!v12 && (v11[16] & 1) != 0)
        v23 = "PET";
      v24 = (FILE *)qword_1ED1DD618;
      v25 = *v22;
      v26 = *a2;
      objc_msgSend((id)v9, "sampleTimestamps");
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = objc_msgSend(v27, "count");
      if (v12)
        v30 = 0;
      else
        v30 = objc_getProperty(v11, v28, 40, 1);
      objc_msgSend(v30, "debugDescription");
      v31 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v32 = (const char *)objc_msgSend(v31, "UTF8String");
      v33 = "";
      if (v35)
        v33 = " (ignored)";
      fprintf(v24, "%'llu \n\n%s Sample %ld at %s%s\n\n", v26, v23, v29 - 1, v32, v33);

      *__error() = v25;
    }
LABEL_47:

    v34 = *(_QWORD *)(a1 + 40);
    if (v34)
      *(_QWORD *)(v34 + 32) = v5;
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2(uint64_t a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;

  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 56))
  {
    v5 = absolute_from_timestamp;
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(id *)(a1 + 40);
    v8 = v7;
    if (v6)
    {
      -[SAKPerfState nextSampleForThread:isOnCore:]((uint64_t)v7, *(_QWORD *)(a2 + 40), 1);
      if (qword_1ED1DD618)
      {
        v9 = *__error();
        fprintf((FILE *)qword_1ED1DD618, "%'llu PERF_TMR_Handler on thread 0x%llx core %d\n", *(_QWORD *)a2, *(_QWORD *)(a2 + 40), *(_DWORD *)(a2 + 52));
        *__error() = v9;
      }
    }

    v10 = *(_QWORD *)(a1 + 40);
    if (v10)
      *(_QWORD *)(v10 + 32) = v5;
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3(_QWORD *a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  const char *v7;
  int v8;
  const char *v9;
  void *v10;
  void *v11;
  void *v12;
  BOOL v13;
  id *v14;
  int v15;
  FILE *v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  _BYTE *execname_for_thread;
  void *v27;
  int v28;
  void *v29;
  void *v30;
  char v31;
  const char *v32;
  id v33;
  int v34;
  FILE *v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  const char *v39;
  int v40;
  NSObject *v41;
  const char *v42;
  void *v43;
  void *v44;
  id Property;
  uint8_t buf[4];
  id v47;
  __int16 v48;
  id v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v4 = (void *)a1[4];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKeyedSubscript:", v5);
  v6 = objc_claimAutoreleasedReturnValue();

  v8 = *(_DWORD *)(a2 + 48);
  if ((v8 & 1) == 0)
  {
    if (!v6)
      goto LABEL_49;
    if (objc_getProperty((id)v6, v7, 48, 1))
    {
      KTraceStringFromArguments(a1[7], a2, 1u);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      if (v10)
      {
        objc_msgSend(objc_getProperty((id)v6, v9, 48, 1), "appendString:", v10);
      }
      else if (qword_1ED1DD618)
      {
        v15 = *__error();
        v16 = (FILE *)qword_1ED1DD618;
        v17 = *(_QWORD *)a2;
        v18 = *(_QWORD *)(a2 + 40);
        objc_msgSend((id)v6, "debugDescription");
        v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        fprintf(v16, "%'llu WARNING: Continuation for dyld info is empty string on thread 0x%llx: %s\n", v17, v18, (const char *)objc_msgSend(v19, "UTF8String"));

        *__error() = v15;
      }

    }
    goto LABEL_45;
  }
  if ((!*(_QWORD *)(a2 + 8) || (*(_QWORD *)(a2 + 8) & 0xFFFF0000) == 0x1F050000)
    && ((v8 & 2) == 0 || *(_QWORD *)(a2 + 24)))
  {
    v11 = *(void **)(a2 + 16);
    if (v6)
    {
      v12 = *(void **)(v6 + 40);
      if (v12)
        v13 = v12 == v11;
      else
        v13 = 1;
      if (v13)
      {
        v14 = (id *)v6;
        goto LABEL_33;
      }
      v20 = (void *)a1[4];
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v20, "setObject:forKeyedSubscript:", 0, v21);

    }
    *(_DWORD *)buf = -1;
    v22 = a1[6];
    if (v22)
      v23 = *(_QWORD *)(v22 + 24);
    else
      v23 = 0;
    -[SASampleStore existingTaskForEvent:inSession:returningPid:]((_QWORD *)a1[5], a2, v23, buf);
    v24 = objc_claimAutoreleasedReturnValue();
    v25 = (void *)v24;
    if ((*(_DWORD *)buf & 0x80000000) == 0)
    {
      if (!v24)
      {
        execname_for_thread = (_BYTE *)ktrace_get_execname_for_thread();
        if (execname_for_thread && *execname_for_thread)
        {
          SANSStringForCString(execname_for_thread);
          v27 = (void *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          v27 = 0;
        }
        -[SASampleStore taskForPid:andName:didExecAtTimestamp:]((_QWORD *)a1[5], *(unsigned int *)buf, v27, 0);
        v25 = (void *)objc_claimAutoreleasedReturnValue();

      }
      v14 = -[SADyldInfo initWithTask:]((id *)[SADyldInfo alloc], v25);
      v29 = (void *)a1[4];
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v29, "setObject:forKeyedSubscript:", v14, v30);

      if (!v14)
      {
        v6 = 0;
        v31 = 1;
        goto LABEL_34;
      }
LABEL_33:
      v31 = 0;
      v14[5] = v11;
      v6 = (uint64_t)v14;
LABEL_34:
      KTraceStringFromArguments(a1[7], a2, 3u);
      v33 = (id)objc_claimAutoreleasedReturnValue();
      if (!v33)
      {
        if (qword_1ED1DD618)
        {
          v34 = *__error();
          v35 = (FILE *)qword_1ED1DD618;
          v36 = *(_QWORD *)a2;
          v37 = *(_QWORD *)(a2 + 40);
          objc_msgSend((id)v6, "debugDescription");
          v38 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          fprintf(v35, "%'llu WARNING: Start for dyld info is empty string on thread 0x%llx: %s\n", v36, v37, (const char *)objc_msgSend(v38, "UTF8String"));

          *__error() = v34;
        }
        v33 = objc_alloc_init(MEMORY[0x1E0CB37A0]);
      }
      if ((v31 & 1) == 0)
      {
        if (objc_getProperty((id)v6, v32, 48, 1))
        {
          v40 = *__error();
          _sa_logt();
          v41 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            Property = objc_getProperty((id)v6, v42, 48, 1);
            *(_DWORD *)buf = 138412546;
            v47 = Property;
            v48 = 2112;
            v49 = v33;
            _os_log_debug_impl(&dword_1B9BE0000, v41, OS_LOG_TYPE_DEBUG, "Throwing out previous path %@ for new path %@", buf, 0x16u);
          }

          *__error() = v40;
        }
        objc_setProperty_atomic((id)v6, v39, v33, 48);
        *(_BYTE *)(v6 + 10) = 0;
      }

LABEL_45:
      if ((*(_BYTE *)(a2 + 48) & 2) != 0)
      {
        if (v6)
        {
          *(_BYTE *)(v6 + 10) = 1;
          if (-[SASampleStore checkDyldInfoCompletion:](a1[5], (void *)v6))
          {
            v43 = (void *)a1[4];
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
            v44 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v43, "setObject:forKeyedSubscript:", 0, v44);

          }
        }
      }
      goto LABEL_49;
    }
    if (qword_1ED1DD618)
    {
      v28 = *__error();
      fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Unable to determine pid for dyld string on thread 0x%llx: %d\n", *(_QWORD *)a2, *(_QWORD *)(a2 + 40), *(_DWORD *)buf);
      *__error() = v28;
    }

    v6 = 0;
  }
LABEL_49:

}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_128(uint64_t a1, _BYTE *a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint8_t v15[16];

  if (a2)
  {
    if ((*a2 & 1) != 0)
    {
      absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
      if (absolute_from_timestamp < *(_QWORD *)(a1 + 64))
      {
        v5 = absolute_from_timestamp;
        -[SASampleStore kperfRecord:state:frameIterator:](*(_QWORD **)(a1 + 32), (uint64_t)a2, *(void **)(a1 + 40), *(void **)(a1 + 48));
        v6 = *(_QWORD *)(a1 + 40);
        if (v6)
        {
          if (v5 > *(_QWORD *)(v6 + 32))
            *(_QWORD *)(v6 + 32) = v5;
        }
      }
    }
  }
  else
  {
    v7 = *__error();
    _sa_logt();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v15 = 0;
      _os_log_error_impl(&dword_1B9BE0000, v8, OS_LOG_TYPE_ERROR, "NULL rec", v15, 2u);
    }

    *__error() = v7;
    _SASetCrashLogMessage(1851, "NULL rec", v9, v10, v11, v12, v13, v14, v15[0]);
    _os_crash();
    __break(1u);
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_132(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  int v13;
  FILE *v14;
  uint64_t v15;
  id v16;
  _QWORD *v17;

  if ((*(_BYTE *)(a2 + 8) & 1) == 0)
  {
    v3 = *(_QWORD **)(a1 + 32);
    v4 = *(id *)(a1 + 40);
    if (v3)
    {
      v17 = v4;
      if (v4)
        v5 = v4[3];
      else
        v5 = 0;
      -[SASampleStore existingTaskForEvent:inSession:returningPid:](v3, a2, v5, 0);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      if (v6)
      {
        objc_msgSend(v6, "threads");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "objectForKeyedSubscript:", v9);
        v10 = (void *)objc_claimAutoreleasedReturnValue();

        if (v10)
        {
          objc_msgSend(v10, "threadStates");
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v11, "lastObject");
          v12 = (void *)objc_claimAutoreleasedReturnValue();

          if (v12)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0 && (objc_msgSend(v12, "filledUserStack") & 1) == 0)
            {
              if (qword_1ED1DD618)
              {
                v13 = *__error();
                v14 = (FILE *)qword_1ED1DD618;
                v15 = *(_QWORD *)a2;
                objc_msgSend(v7, "debugDescription");
                v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                fprintf(v14, "%'llu WARNING: KPerf had an error getting user stack for task %s thread 0x%llx\n", v15, (const char *)objc_msgSend(v16, "UTF8String"), *(_QWORD *)(a2 + 40));

                *__error() = v13;
              }
              objc_msgSend(v12, "setFilledUserStack:", 1);
            }
          }

        }
      }

      v4 = v17;
    }

  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2_133(uint64_t a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  id v6;
  unsigned int v7;
  unint64_t v8;
  int v9;
  SANewThreadInfo *v10;
  void *v11;
  void *v12;
  void *v13;
  const char *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;

  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 72))
  {
    v5 = absolute_from_timestamp;
    v19 = -1;
    v6 = -[SASampleStore existingTaskForEvent:inSession:returningPid:](*(_QWORD **)(a1 + 32), a2, *(_QWORD *)(a1 + 64), &v19);
    v7 = v19;
    if ((v19 & 0x80000000) != 0)
    {
      if (qword_1ED1DD618)
      {
        v18 = *__error();
        fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Unable to determine old pid for TRACE_DATA_NEWTHREAD on thread 0x%llx: %d\n", *(_QWORD *)a2, *(_QWORD *)(a2 + 40), v19);
        *__error() = v18;
      }
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_DWORD *)(a2 + 16);
      if (v19 == v9 && *(_QWORD *)(a2 + 24))
      {
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v19);
        v10 = (SANewThreadInfo *)objc_claimAutoreleasedReturnValue();
        v11 = *(void **)(a1 + 40);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v8);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v11, "setObject:forKeyedSubscript:", v10, v12);
      }
      else
      {
        v10 = objc_alloc_init(SANewThreadInfo);
        +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, a2);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = v13;
        if (v10)
        {
          objc_setProperty_atomic(v10, v14, v13, 16);

          v10->_newTid = v8;
          v10->_oldPid = v7;
          v10->_newPid = v9;
        }
        else
        {

        }
        v16 = *(void **)(a1 + 48);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v16, "setObject:forKeyedSubscript:", v10, v12);
      }

      v17 = *(_QWORD *)(a1 + 56);
      if (v17)
        *(_QWORD *)(v17 + 32) = v5;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3_136(_QWORD *a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  _QWORD *v11;
  uint64_t *v12;
  const char *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  FILE *v19;
  uint64_t v20;
  id v21;
  void *v22;
  uint64_t v23;
  void *v24;
  _DWORD *v25;
  int v26;
  id v27;
  char v28;
  int v29;
  FILE *v30;
  uint64_t v31;
  id v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  const char *v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  int v42;
  BOOL v43;
  void *v44;
  void *v45;
  uint64_t v46;
  id newValue;
  id v48;

  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp >= a1[8])
    return;
  v5 = absolute_from_timestamp;
  v6 = (void *)a1[4];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKeyedSubscript:", v7);
  v48 = (id)objc_claimAutoreleasedReturnValue();

  if (v48)
  {
    KTraceStringFromArguments(a1[7], a2, 1u);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = v8;
    if (v8)
    {
      SACachedNSString(v8);
      v10 = (void *)objc_claimAutoreleasedReturnValue();

    }
    else
    {
      v10 = 0;
    }
    v11 = (_QWORD *)a1[5];
    v12 = (uint64_t *)v48;
    v14 = v10;
    if (!v11)
    {
LABEL_36:

      v39 = (void *)a1[4];
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v39, "setObject:forKeyedSubscript:", 0, v40);

      goto LABEL_37;
    }
    v46 = v12[3];
    v16 = *((unsigned int *)v12 + 2);
    v15 = *((unsigned int *)v12 + 3);
    newValue = objc_getProperty(v12, v13, 16, 1);
    if ((_DWORD)v16 == (_DWORD)v15)
    {
      -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v11, v16, v14, 0);
      v17 = objc_claimAutoreleasedReturnValue();
      if (!qword_1ED1DD618)
      {
        v25 = (_DWORD *)v17;
LABEL_31:
        objc_msgSend(v25, "threads");
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v46);
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v33, "objectForKeyedSubscript:", v34);
        v35 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v35)
        {
          +[SAThread threadWithId:]((uint64_t)SAThread, v46);
          v36 = (void *)objc_claimAutoreleasedReturnValue();
          v38 = v36;
          if (v36)
            objc_setProperty_atomic(v36, v37, newValue, 32);
          -[SATask addThread:]((uint64_t)v25, v38);

        }
        goto LABEL_36;
      }
      v44 = (void *)v17;
      v18 = *__error();
      v19 = (FILE *)qword_1ED1DD618;
      v20 = objc_msgSend(newValue, "machAbsTime");
      objc_msgSend(v44, "debugDescription");
      v21 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      fprintf(v19, "%'llu %s creating thread 0x%llx\n", v20, (const char *)objc_msgSend(v21, "UTF8String"), v46);

      *__error() = v18;
LABEL_30:
      v25 = v44;
      goto LABEL_31;
    }
    -[SASampleStore lastTaskWithPid:](v11, v15);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = (uint64_t)v22;
    if (v22)
    {
      objc_msgSend(v22, "exitTimestamp");
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      if (v24)
      {

        if ((_DWORD)v15)
        {
          v45 = (void *)v23;
          v43 = (_DWORD)v16 == 0;
          goto LABEL_19;
        }
      }
    }
    else
    {
      if ((_DWORD)v15)
      {
        v45 = 0;
        if (!(_DWORD)v16)
        {
          if (qword_1ED1DD618)
          {
            v42 = *__error();
            fprintf((FILE *)qword_1ED1DD618, "%'llu kernel creating thread 0x%llx in process [%d]\n", objc_msgSend(newValue, "machAbsTime"), v46, v15);
            v27 = 0;
            *__error() = v42;
          }
          else
          {
            v27 = 0;
          }
          v43 = 1;
LABEL_22:
          -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v11, v15, v14, v27);
          v25 = (_DWORD *)objc_claimAutoreleasedReturnValue();

          v28 = v43;
          if (!v25)
            v28 = 1;
          if ((v28 & 1) == 0)
            v25[20] = v16;

          goto LABEL_31;
        }
        v43 = 0;
LABEL_19:
        if (qword_1ED1DD618)
        {
          v26 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu [%d] creating thread 0x%llx in new process [%d]\n", objc_msgSend(newValue, "machAbsTime"), v16, v46, v15);
          *__error() = v26;
        }
        v27 = newValue;
        goto LABEL_22;
      }
      -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v11, 0, v14, 0);
      v23 = objc_claimAutoreleasedReturnValue();
    }
    if (!qword_1ED1DD618)
    {
      v25 = (_DWORD *)v23;
      goto LABEL_31;
    }
    v44 = (void *)v23;
    v29 = *__error();
    v30 = (FILE *)qword_1ED1DD618;
    v31 = objc_msgSend(newValue, "machAbsTime");
    objc_msgSend(v44, "debugDescription");
    v32 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    fprintf(v30, "%'llu Task [%d] creating thread 0x%llx in other process %s\n", v31, v16, v46, (const char *)objc_msgSend(v32, "UTF8String"));

    *__error() = v29;
    goto LABEL_30;
  }
LABEL_37:
  v41 = a1[6];
  if (v41)
    *(_QWORD *)(v41 + 32) = v5;

}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_4(uint64_t a1, uint64_t *a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  void *v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  _DWORD *v18;
  int v19;
  _BYTE *v20;
  const char *v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  id v25;
  const char *v26;
  id v27;
  int v28;
  void *v29;
  void *v30;
  uint64_t v31;
  int v32;
  FILE *v33;
  void *v34;
  void *v35;
  id newValue;
  id v37;
  unsigned int v38;

  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 64))
  {
    v5 = absolute_from_timestamp;
    v6 = *(void **)(a1 + 32);
    v7 = 0x1E0CB3000uLL;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", a2[5]);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v8);
    v37 = (id)objc_claimAutoreleasedReturnValue();

    if (v37)
      v9 = objc_msgSend(v37, "intValue");
    else
      v9 = 0xFFFFFFFFLL;
    v10 = *(_QWORD **)(a1 + 40);
    v11 = *(id *)(a1 + 48);
    v12 = v11;
    v38 = v9;
    if (v10)
    {
      if ((_DWORD)v9 == -1)
      {
        if (v11)
          v14 = v11[3];
        else
          v14 = 0;
        -[SASampleStore existingTaskForEvent:inSession:returningPid:](v10, (uint64_t)a2, v14, &v38);
        v13 = objc_claimAutoreleasedReturnValue();
      }
      else
      {
        -[SASampleStore lastTaskWithPid:](v10, v9);
        v13 = objc_claimAutoreleasedReturnValue();
      }
      v15 = (void *)v13;
      if ((v38 & 0x80000000) != 0)
      {
        if (qword_1ED1DD618)
        {
          v28 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Unable to determine pid for exec on thread 0x%llx: %d\n", *a2, a2[5], v38);
          *__error() = v28;
        }
      }
      else
      {
        if (v12)
          v16 = v12[3];
        else
          v16 = 0;
        KTraceStringFromArguments(v16, (uint64_t)a2, 1u);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, (uint64_t)a2);
        newValue = (id)objc_claimAutoreleasedReturnValue();
        -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v10, v38, v17, newValue);
        v18 = (_DWORD *)objc_claimAutoreleasedReturnValue();
        if (v15)
        {
          v19 = objc_msgSend(v15, "ppid");
          if (v18)
            v18[20] = v19;
        }
        +[SAThread threadWithId:]((uint64_t)SAThread, a2[5]);
        v20 = (_BYTE *)objc_claimAutoreleasedReturnValue();
        v22 = v20;
        if (v20)
        {
          v20[17] = 1;
          objc_setProperty_atomic(v20, v21, newValue, 32);
        }
        -[SATask addThread:]((uint64_t)v18, v22);
        if (v18)
          objc_setProperty_atomic(v18, v23, v22, 264);
        if (qword_1ED1DD618)
        {
          v34 = v17;
          v35 = v15;
          v32 = *__error();
          v33 = (FILE *)qword_1ED1DD618;
          v24 = *a2;
          objc_msgSend(v15, "debugDescription");
          v25 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v26 = (const char *)objc_msgSend(v25, "UTF8String");
          objc_msgSend(v18, "debugDescription");
          v27 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          fprintf(v33, "%'llu %s exec'ed %s\n", v24, v26, (const char *)objc_msgSend(v27, "UTF8String"));

          v15 = v35;
          *__error() = v32;
          v7 = 0x1E0CB3000;
          v17 = v34;
        }

      }
    }

    v29 = *(void **)(a1 + 32);
    objc_msgSend(*(id *)(v7 + 2024), "numberWithUnsignedLongLong:", a2[5]);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v29, "setObject:forKeyedSubscript:", 0, v30);

    v31 = *(_QWORD *)(a1 + 48);
    if (v31)
      *(_QWORD *)(v31 + 32) = v5;

  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_5(uint64_t a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  int v18;
  NSObject *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  int v26;
  uint64_t v27;
  __int16 v28;
  void *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 64))
  {
    v5 = absolute_from_timestamp;
    v6 = *(void **)(a1 + 32);
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectForKeyedSubscript:", v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      v9 = *(void **)(a1 + 32);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 40));
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "setObject:forKeyedSubscript:", 0, v10);

      goto LABEL_23;
    }
    v11 = *(_QWORD **)(a1 + 40);
    v12 = *(id *)(a1 + 48);
    if (!v11)
    {
LABEL_22:

LABEL_23:
      v22 = *(_QWORD *)(a1 + 48);
      if (v22)
        *(_QWORD *)(v22 + 32) = v5;
      return;
    }
    -[SASampleStore lastTaskWithPid:orTid:](v11, 0xFFFFFFFFLL, *(_QWORD *)(a2 + 40));
    v13 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    if (!v13)
    {
      v18 = *__error();
      _sa_logt();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        if (v12)
          v23 = v12[3];
        else
          v23 = 0;
        v24 = *(_QWORD *)(a2 + 40);
        KTraceStringFromArguments(v23, a2, 1u);
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        v26 = 134218242;
        v27 = v24;
        v28 = 2112;
        v29 = v25;
        _os_log_debug_impl(&dword_1B9BE0000, v19, OS_LOG_TYPE_DEBUG, "No task with thread 0x%llx at exit for name %@", (uint8_t *)&v26, 0x16u);

      }
      *__error() = v18;
      goto LABEL_21;
    }
    if (v12)
      v14 = v12[3];
    else
      v14 = 0;
    KTraceStringFromArguments(v14, a2, 1u);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "name");
    v16 = objc_claimAutoreleasedReturnValue();
    v17 = (void *)v16;
    if (v15)
    {
      if (v13[7] && v16)
      {
        if ((objc_msgSend(v15, "hasPrefix:", v16) & 1) == 0)
          goto LABEL_18;
      }
      else if (!v16)
      {
LABEL_17:
        -[SATask setName:]((uint64_t)v13, v15);
        goto LABEL_18;
      }
      if ((objc_msgSend(v17, "hasPrefix:", v15) & 1) == 0)
        goto LABEL_17;
    }
LABEL_18:
    objc_msgSend(v13, "exitTimestamp");
    v20 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v20)
    {
      +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, a2);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      -[SASampleStore task:exitedAtTimestamp:]((uint64_t)v11, v13, v21);

    }
LABEL_21:

    goto LABEL_22;
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_6(uint64_t a1, _QWORD *a2)
{
  unint64_t absolute_from_timestamp;
  unint64_t v5;
  _QWORD *v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  const char *v16;
  int v17;
  uint64_t v18;

  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 56))
  {
    v5 = absolute_from_timestamp;
    v6 = *(_QWORD **)(a1 + 32);
    v7 = *(id *)(a1 + 40);
    if (v6)
    {
      v8 = a2[1];
      +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, (uint64_t)a2);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      -[SASampleStore lastTaskWithPid:orTid:](v6, 0xFFFFFFFFLL, v8);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = v10;
      if (v10)
      {
        objc_msgSend(v10, "exitTimestamp");
        v12 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v12)
        {
          objc_msgSend(v11, "threads");
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v8);
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v13, "objectForKeyedSubscript:", v14);
          v15 = (void *)objc_claimAutoreleasedReturnValue();

          if (v15)
            objc_setProperty_atomic(v15, v16, v9, 40);

        }
      }
      else if (qword_1ED1DD618)
      {
        v17 = *__error();
        fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx exited, but we don't have a task with that thread!\n", *a2, v8);
        *__error() = v17;
      }

    }
    v18 = *(_QWORD *)(a1 + 40);
    if (v18)
      *(_QWORD *)(v18 + 32) = v5;
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_7(uint64_t a1, __int32 *a2)
{
  unint64_t absolute_from_timestamp;
  id v5;
  _QWORD *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  const char *v10;
  char v11;
  int v12;
  int v13;
  int v14;
  int v15;
  id v16;
  char v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  char v22;
  uint64_t v23;
  const char *v24;
  int v25;
  int *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  _BYTE *v31;
  void *v32;
  const char *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  _BYTE *execname_for_thread;
  void *v39;
  id v40;
  char v41;
  NSObject *v42;
  int v43;
  int v44;
  int v45;
  void *v46;
  int v47;
  void *v48;
  int v49;
  int v50;
  NSObject *v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  id *v68;
  void *v69;
  void *v70;
  const char *v71;
  void *v72;
  id *v73;
  void *v74;
  const char *v75;
  void *v76;
  void *v77;
  uint64_t v78;
  __int32 v79;
  _QWORD *v80;
  id v81;
  uint8_t buf[4];
  uint64_t v83;
  int32x4_t uu;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(_QWORD *)(a1 + 64))
  {
    v5 = (id)absolute_from_timestamp;
    v6 = *(_QWORD **)(a1 + 32);
    v7 = *(void **)(a1 + 48);
    v80 = *(id *)(a1 + 40);
    v81 = v7;
    if (!v6)
      goto LABEL_97;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *((_QWORD *)a2 + 5));
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v81, "objectForKeyedSubscript:", v8);
    v9 = objc_claimAutoreleasedReturnValue();

    v11 = 0;
    v12 = 0;
    LOBYTE(v13) = 0;
    v14 = 0;
    v15 = 0;
    switch((unsigned __int16)a2[12] >> 2)
    {
      case 0:
      case 5:
        goto LABEL_36;
      case 1:
      case 6:
        if (!v9)
          goto LABEL_59;
        goto LABEL_7;
      case 2:
      case 7:
        goto LABEL_23;
      case 3:
      case 8:
        goto LABEL_49;
      case 4:
      case 9:
        goto LABEL_14;
      case 10:
        v11 = 1;
LABEL_36:
        uu = *(int32x4_t *)(a2 + 2);
        if (uuid_is_null((const unsigned __int8 *)&uu))
        {
          if (!qword_1ED1DD618)
            goto LABEL_96;
          goto LABEL_25;
        }
        if (v9 && !objc_getProperty((id)v9, v33, 24, 1))
          goto LABEL_80;
        *(_DWORD *)buf = -1;
        if (v80)
          v35 = v80[3];
        else
          v35 = 0;
        -[SASampleStore existingTaskForEvent:inSession:returningPid:](v6, (uint64_t)a2, v35, buf);
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = (void *)v36;
        if ((*(_DWORD *)buf & 0x80000000) == 0)
        {
          if (!v36)
          {
            execname_for_thread = (_BYTE *)ktrace_get_execname_for_thread();
            if (execname_for_thread && *execname_for_thread)
            {
              SANSStringForCString(execname_for_thread);
              v39 = (void *)objc_claimAutoreleasedReturnValue();
            }
            else
            {
              v39 = 0;
            }
            -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v6, *(unsigned int *)buf, v39, 0);
            v37 = (void *)objc_claimAutoreleasedReturnValue();

          }
          v73 = -[SADyldInfo initWithTask:]((id *)[SADyldInfo alloc], v37);

          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *((_QWORD *)a2 + 5));
          v74 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v81, "setObject:forKeyedSubscript:", v73, v74);

          v9 = (uint64_t)v73;
          goto LABEL_92;
        }
        if (qword_1ED1DD618)
        {
          v48 = (void *)v36;
          v49 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Unable to determine pid for dyld on thread 0x%llx: %d\n", *(_QWORD *)a2, *((_QWORD *)a2 + 5), *(_DWORD *)buf);
          *__error() = v49;
          v37 = v48;
        }

        goto LABEL_96;
      case 11:
        v12 = 1;
        if (!v9)
          goto LABEL_59;
LABEL_7:
        v16 = objc_getProperty((id)v9, v10, 24, 1);
        if (!v16)
          goto LABEL_59;
        v17 = *(_BYTE *)(v9 + 8);

        if (v12)
        {
          if ((v17 & 1) != 0)
          {
LABEL_10:
            v19 = *((_QWORD *)a2 + 2);
            v20 = *(_QWORD *)(v9 + 40);
            if (!v20 || v20 == v19)
              goto LABEL_21;
            goto LABEL_20;
          }
        }
        else if ((v17 & 1) == 0)
        {
          goto LABEL_10;
        }
LABEL_59:
        if (qword_1ED1DD618)
        {
          v43 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Missing first dyld tracepoint on thread 0x%llx\n", *(_QWORD *)a2, *((_QWORD *)a2 + 5));
          *__error() = v43;
        }
        goto LABEL_69;
      case 12:
        LOBYTE(v13) = 1;
LABEL_23:
        uu = vuzp1q_s32(*(int32x4_t *)(a2 + 2), *(int32x4_t *)(a2 + 6));
        if (uuid_is_null((const unsigned __int8 *)&uu))
        {
          if (qword_1ED1DD618)
          {
LABEL_25:
            v25 = *__error();
            fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: null UUID in dyld tracepoint on thread 0x%llx\n", *(_QWORD *)a2, *((_QWORD *)a2 + 5));
            v26 = __error();
LABEL_57:
            *v26 = v25;
          }
          goto LABEL_96;
        }
        if (v9 && !objc_getProperty((id)v9, v24, 24, 1))
        {
          if (objc_getProperty((id)v9, v27, 48, 1))
            goto LABEL_87;
          v50 = *__error();
          _sa_logt();
          v51 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend((id)v9, "debugDescription");
            a2 = (__int32 *)objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            *(_DWORD *)buf = 136315138;
            v83 = objc_msgSend(a2, "UTF8String");
            _os_log_error_impl(&dword_1B9BE0000, v51, OS_LOG_TYPE_ERROR, "No uuid and no path for dyld info %s", buf, 0xCu);

          }
          *__error() = v50;
          objc_msgSend((id)v9, "debugDescription");
          v5 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v52 = objc_msgSend(v5, "UTF8String");
          _SASetCrashLogMessage(1548, "No uuid and no path for dyld info %s", v53, v54, v55, v56, v57, v58, v52);

          _os_crash();
          __break(1u);
LABEL_80:
          if (objc_getProperty((id)v9, v34, 48, 1))
          {
LABEL_92:
            uuidForBytes((uint64_t)&uu);
            v70 = (void *)objc_claimAutoreleasedReturnValue();
            v76 = v70;
            if (v9)
            {
              objc_setProperty_atomic((id)v9, v75, v70, 24);

              *(_QWORD *)(v9 + 32) = *((_QWORD *)a2 + 3);
              *(_BYTE *)(v9 + 8) = v11;
              goto LABEL_94;
            }
            goto LABEL_102;
          }
          v13 = *__error();
          _sa_logt();
          v59 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend((id)v9, "debugDescription");
            a2 = (__int32 *)objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v60 = objc_msgSend(a2, "UTF8String");
            *(_DWORD *)buf = 136315138;
            v83 = v60;
            _os_log_error_impl(&dword_1B9BE0000, v59, OS_LOG_TYPE_ERROR, "No uuid and no path for dyld info %s", buf, 0xCu);

          }
          *__error() = v13;
          objc_msgSend((id)v9, "debugDescription");
          v5 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v61 = objc_msgSend(v5, "UTF8String");
          _SASetCrashLogMessage(1473, "No uuid and no path for dyld info %s", v62, v63, v64, v65, v66, v67, v61);

          _os_crash();
          __break(1u);
        }
        else
        {
          *(_DWORD *)buf = -1;
          if (v80)
            v28 = v80[3];
          else
            v28 = 0;
          -[SASampleStore existingTaskForEvent:inSession:returningPid:](v6, (uint64_t)a2, v28, buf);
          v29 = objc_claimAutoreleasedReturnValue();
          v30 = (void *)v29;
          if ((*(_DWORD *)buf & 0x80000000) != 0)
          {
            if (qword_1ED1DD618)
            {
              v47 = *__error();
              fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Unable to determine pid for dyld on thread 0x%llx: %d\n", *(_QWORD *)a2, *((_QWORD *)a2 + 5), *(_DWORD *)buf);
              *__error() = v47;
            }

LABEL_96:
LABEL_97:

            v78 = *(_QWORD *)(a1 + 40);
            if (v78)
              *(_QWORD *)(v78 + 32) = v5;
            return;
          }
          if (v29)
            goto LABEL_86;
          v31 = (_BYTE *)ktrace_get_execname_for_thread();
          if (v31 && *v31)
          {
            SANSStringForCString(v31);
            v32 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_85:
            -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v6, *(unsigned int *)buf, v32, 0);
            v30 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_86:
            v68 = -[SADyldInfo initWithTask:]((id *)[SADyldInfo alloc], v30);

            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *((_QWORD *)a2 + 5));
            v69 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v81, "setObject:forKeyedSubscript:", v68, v69);

            v9 = (uint64_t)v68;
LABEL_87:
            uuidForBytes((uint64_t)&uu);
            v70 = (void *)objc_claimAutoreleasedReturnValue();
            v72 = v70;
            if (v9)
            {
              objc_setProperty_atomic((id)v9, v71, v70, 24);

              *(_BYTE *)(v9 + 8) = v13;
              goto LABEL_94;
            }
LABEL_102:

            goto LABEL_94;
          }
        }
        v32 = 0;
        goto LABEL_85;
      case 13:
        v14 = 1;
LABEL_49:
        if (!v9)
          goto LABEL_67;
        v40 = objc_getProperty((id)v9, v10, 24, 1);
        if (!v40)
          goto LABEL_67;
        v41 = *(_BYTE *)(v9 + 8);

        if (v14)
        {
          if ((v41 & 1) != 0)
          {
LABEL_53:
            *(_QWORD *)(v9 + 32) = *((_QWORD *)a2 + 1);
            goto LABEL_94;
          }
        }
        else if ((v41 & 1) == 0)
        {
          goto LABEL_53;
        }
LABEL_67:
        if (qword_1ED1DD618)
        {
          v45 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Missing first dyld tracepoint on thread 0x%llx\n", *(_QWORD *)a2, *((_QWORD *)a2 + 5));
          *__error() = v45;
        }
LABEL_69:
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *((_QWORD *)a2 + 5));
        v46 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v81, "setObject:forKeyedSubscript:", 0, v46);

        goto LABEL_96;
      case 14:
        v15 = 1;
LABEL_14:
        if (!v9)
          goto LABEL_63;
        v21 = objc_getProperty((id)v9, v10, 24, 1);
        if (!v21)
          goto LABEL_63;
        v22 = *(_BYTE *)(v9 + 8);

        if (v15)
        {
          if ((v22 & 1) != 0)
          {
LABEL_18:
            v19 = *((_QWORD *)a2 + 2);
            v23 = *(_QWORD *)(v9 + 40);
            if (!v23 || v23 == v19)
              goto LABEL_21;
LABEL_20:
            objc_setProperty_atomic((id)v9, v18, 0, 48);
            *(_BYTE *)(v9 + 10) = 0;
LABEL_21:
            *(_QWORD *)(v9 + 40) = v19;
            *(_BYTE *)(v9 + 9) = 1;
LABEL_94:
            if (-[SASampleStore checkDyldInfoCompletion:]((uint64_t)v6, (void *)v9))
            {
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *((_QWORD *)a2 + 5));
              v77 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v81, "setObject:forKeyedSubscript:", 0, v77);

            }
            goto LABEL_96;
          }
        }
        else if ((v22 & 1) == 0)
        {
          goto LABEL_18;
        }
LABEL_63:
        if (qword_1ED1DD618)
        {
          v44 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu WARNING: Missing first dyld tracepoint on thread 0x%llx\n", *(_QWORD *)a2, *((_QWORD *)a2 + 5));
          *__error() = v44;
        }
        goto LABEL_69;
      case 15:
      case 16:
        goto LABEL_94;
      default:
        v25 = *__error();
        _sa_logt();
        v42 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
        {
          v79 = a2[12];
          uu.i32[0] = 67109120;
          uu.i32[1] = v79;
          _os_log_fault_impl(&dword_1B9BE0000, v42, OS_LOG_TYPE_FAULT, "Unknown dyld tracepoint 0x%x", (uint8_t *)&uu, 8u);
        }

        v26 = __error();
        goto LABEL_57;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_8(uint64_t a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  id v8;

  v8 = a2;
  v5 = a3;
  if (v8)
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
      objc_msgSend(*(id *)(v6 + 64), "addObject:", v8);
  }
  if (v5)
  {
    v7 = *(_QWORD *)(a1 + 32);
    if (v7)
      objc_msgSend(*(id *)(v7 + 56), "addObject:", v5);
  }

}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_9(uint64_t a1, void *a2)
{
  -[SASampleStore addIOEvent:](*(_QWORD *)(a1 + 32), a2);
}

uint64_t __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_10(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 32);
  if (v2)
    return objc_msgSend(*(id *)(v2 + 96), "addObject:", a2);
  return result;
}

unint64_t __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_11(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v5;
  _QWORD *v6;
  id v7;
  void *v8;
  void *v9;
  long double v10;
  void *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  FILE *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  const char *v24;
  uint64_t absolute_from_timestamp;
  uint64_t continuous_from_timestamp;
  uint64_t v27;
  uint64_t v28;
  FILE *v29;
  __CFString *v30;

  result = ktrace_get_absolute_from_timestamp();
  if (result < *(_QWORD *)(a1 + 64))
  {
    v5 = result;
    v6 = *(_QWORD **)(a1 + 32);
    v7 = *(id *)(a1 + 40);
    if (v6)
    {
      objc_msgSend(v6, "startTime");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (v8)
      {
        +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, a2);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v9, "wallTime");
        v30 = (__CFString *)_CopyStringForTime(3, v10);
        if (objc_msgSend(v6, "dataStyle") == 1 || !objc_msgSend(v6, "dataStyle"))
        {
          v19 = (FILE *)*MEMORY[0x1E0C80C10];
          objc_msgSend(v9, "machAbsTimeSeconds");
          v21 = v20;
          objc_msgSend(v8, "machAbsTimeSeconds");
          v23 = v22;
          v24 = (const char *)-[__CFString UTF8String](objc_retainAutorelease(v30), "UTF8String");
          absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
          continuous_from_timestamp = ktrace_get_continuous_from_timestamp();
          fprintf(v19, "Warning: Lost trace events, dropping all samples (%.2fs) before %s (machabs %llu / machcont %llu)\n", v21 - v23, v24, absolute_from_timestamp, continuous_from_timestamp);
        }
        else
        {
          v29 = (FILE *)*MEMORY[0x1E0C80C10];
          objc_msgSend(v6, "sampleTimestamps");
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          v28 = objc_msgSend(v11, "count");
          objc_msgSend(v9, "machAbsTimeSeconds");
          v13 = v12;
          objc_msgSend(v8, "machAbsTimeSeconds");
          v15 = v14;
          v16 = (const char *)-[__CFString UTF8String](objc_retainAutorelease(v30), "UTF8String");
          v17 = ktrace_get_absolute_from_timestamp();
          v18 = ktrace_get_continuous_from_timestamp();
          fprintf(v29, "Warning: Lost trace events, dropping first %lu samples (%.2fs) before %s (machabs %llu / machcont %llu)\n", v28, v13 - v15, v16, v17, v18);

        }
      }
      -[SASampleStore removeAllData](v6);

    }
    result = objc_msgSend(*(id *)(a1 + 48), "removeAllObjects");
    v27 = *(_QWORD *)(a1 + 40);
    if (v27)
      *(_QWORD *)(v27 + 32) = v5;
  }
  return result;
}

- (id)loadInfosForKTSymbolOwners:(int)a3 isKernelSpace:(uint64_t)a4 excludeRange:(unint64_t)a5
{
  unsigned int *v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  void *v9;
  int *v10;
  unsigned __int16 *v11;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  void *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  void *v24;
  unsigned __int16 *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  BOOL v31;
  int v32;
  const char *v33;
  int v34;
  NSObject *v35;
  void *v36;
  const char *v37;
  uint64_t v38;
  char *v39;
  void *v40;
  void *v41;
  _BOOL4 v42;
  void *v43;
  char v44;
  int v45;
  NSObject *v46;
  int v47;
  NSObject *v48;
  unsigned __int16 *v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  SEL v53;
  unsigned __int16 *v54;
  unsigned int v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  char *v65;
  unsigned int v66;
  uint64_t v67;
  char *v68;
  unsigned int *v69;
  int v70;
  NSObject *v71;
  void *v72;
  _QWORD *v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  int v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  char *v84;
  uint64_t v85;
  int v86;
  NSObject *v87;
  int v88;
  NSObject *v89;
  void *v90;
  int v91;
  NSObject *v92;
  char *v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  unint64_t v104;
  int v105;
  NSObject *v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  int v110;
  NSObject *v111;
  unsigned __int16 *v112;
  uint64_t v113;
  int v114;
  uint64_t v116;
  uint64_t v117;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  NSObject *v123;
  void *v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  void *v132;
  void *v133;
  uint64_t v134;
  char *v135;
  uint64_t v136;
  uint64_t v137;
  void *v138;
  uint64_t v139;
  uint64_t v140;
  void *v141;
  char *v142;
  uint64_t v143;
  NSObject *v144;
  void *v145;
  uint64_t v146;
  void *v147;
  int v148;
  NSObject *v149;
  unsigned int *v150;
  id v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t i;
  void *v155;
  id v156;
  _BOOL4 v157;
  uint64_t v158;
  int v159;
  NSObject *v160;
  int v161;
  NSObject *v162;
  void *v163;
  int v164;
  NSObject *v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  void *v171;
  unsigned int *v172;
  int v173;
  NSObject *v174;
  void *v175;
  os_log_t log;
  uint64_t v178;
  BOOL v179;
  char *v180;
  char v181;
  uint64_t v184;
  void *v185;
  void *v186;
  uint64_t v187;
  int v188;
  int v189;
  uint64_t v190;
  void *v191;
  uint64_t v193;
  int v194;
  uint64_t v195;
  void *v196;
  const char *v197;
  char *v198;
  id self;
  unsigned int *v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  unsigned __int8 v205[128];
  _BYTE uu[24];
  _BYTE v207[10];
  char *v208;
  uint8_t buf[4];
  void *v210;
  uint64_t v211;

  v211 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v5 = a2;
  v196 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", *a2);
  v7 = v5 + 1;
  v6 = *v5;
  if ((_DWORD)v6)
  {
    v194 = 0;
    v189 = 0;
    v200 = &v7[v6];
    while (1)
    {
      v8 = *v7;
      v9 = (void *)MEMORY[0x1BCCCC288]();
      v10 = (int *)((char *)v7 + v8);
      v11 = (unsigned __int16 *)((char *)v7 + v8 - *(int *)((char *)v7 + v8));
      v12 = *v11;
      if (v12 < 5
        || !v11[2]
        || (v12 >= 7 ? (v13 = *((_BYTE *)v10 + v11[2]) == 1) : (v13 = 0), !v13 || (v14 = v11[3]) == 0))
      {
        if (_MergedGlobals_4[0] == 1)
        {
          v20 = *__error();
          _sa_logt();
          v21 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
          {
            v25 = (unsigned __int16 *)((char *)v10 - *v10);
            if (*v25 >= 0xBu && (v26 = v25[5]) != 0)
              v27 = *(_QWORD *)((char *)v10 + v26);
            else
              v27 = -1;
            *(_DWORD *)uu = 134217984;
            *(_QWORD *)&uu[4] = v27;
            _os_log_debug_impl(&dword_1B9BE0000, v21, OS_LOG_TYPE_DEBUG, "SAKTSYM No macho for symbol owner at 0x%llx", uu, 0xCu);
          }

          *__error() = v20;
        }
        goto LABEL_20;
      }
      v197 = (char *)v10 + v14 + *(unsigned int *)((char *)v10 + v14);
      v15 = &v197[-*(int *)v197];
      if (*(unsigned __int16 *)v15 < 5u || (v16 = *((unsigned __int16 *)v15 + 2)) == 0)
      {
        if (_MergedGlobals_4[0] == 1)
        {
          v22 = *__error();
          _sa_logt();
          v23 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            v49 = (unsigned __int16 *)((char *)v10 - *v10);
            if (*v49 >= 0xBu && (v50 = v49[5]) != 0)
              v51 = *(_QWORD *)((char *)v10 + v50);
            else
              v51 = -1;
            *(_DWORD *)uu = 134217984;
            *(_QWORD *)&uu[4] = v51;
            _os_log_debug_impl(&dword_1B9BE0000, v23, OS_LOG_TYPE_DEBUG, "SAKTSYM No UUID for symbol owner at 0x%llx", uu, 0xCu);
          }

          v24 = 0;
          *__error() = v22;
        }
        else
        {
          v24 = 0;
        }
        goto LABEL_242;
      }
      *(_QWORD *)uu = 0;
      *(_QWORD *)&uu[8] = 0;
      uuid_parse(&v197[v16 + 4 + *(unsigned int *)&v197[v16]], uu);
      v17 = &v197[-*(int *)v197];
      if (*(unsigned __int16 *)v17 >= 7u && (v18 = *((unsigned __int16 *)v17 + 3)) != 0)
      {
        SANSStringForCString((void *)&v197[v18 + 4 + *(unsigned int *)&v197[v18]]);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v19 = 0;
      }
      uuidForBytes((uint64_t)uu);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      if (objc_msgSend(v19, "isAbsolutePath"))
        v29 = v19;
      else
        v29 = 0;
      +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v28, v29, log);
      self = (id)objc_claimAutoreleasedReturnValue();

      objc_msgSend(self, "path");
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      if (v30)
        v31 = 1;
      else
        v31 = v19 == 0;
      v32 = !v31;

      if (v32)
      {
        if (self)
          objc_setProperty_atomic_copy(self, v33, v19, 80);
        if (_MergedGlobals_4[0] == 1)
        {
          v34 = *__error();
          _sa_logt();
          v35 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            objc_msgSend(self, "debugDescription");
            v36 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138412290;
            v210 = v36;
            _os_log_impl(&dword_1B9BE0000, v35, OS_LOG_TYPE_DEFAULT, "WARNING: SAKTSYM Used relative path for binary %@", buf, 0xCu);

          }
          *__error() = v34;
        }
      }

      v24 = self;
      if (!self)
        goto LABEL_242;
      v37 = &v197[-*(int *)v197];
      if (*(unsigned __int16 *)v37 >= 0x15u)
      {
        v38 = *((unsigned __int16 *)v37 + 10);
        if (v38)
        {
          v39 = (char *)&v197[v38 + 4 + *(unsigned int *)&v197[v38]];
          SANSStringForCString(v39);
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          if (v40)
          {
            objc_msgSend(self, "bundleIdentifier");
            v41 = (void *)objc_claimAutoreleasedReturnValue();
            v42 = v41 == 0;

            if (v42)
            {
              SANSStringForCString(v39);
              v52 = (void *)objc_claimAutoreleasedReturnValue();
              objc_setProperty_atomic_copy(self, v53, v52, 88);

            }
            else
            {
              objc_msgSend(self, "bundleIdentifier");
              v43 = (void *)objc_claimAutoreleasedReturnValue();
              v44 = objc_msgSend(v43, "isEqualToString:", v40);

              if ((v44 & 1) == 0)
              {
                v45 = *__error();
                _sa_logt();
                v46 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
                {
                  objc_msgSend(self, "debugDescription");
                  v169 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)uu = 136315394;
                  *(_QWORD *)&uu[4] = v39;
                  *(_WORD *)&uu[12] = 2112;
                  *(_QWORD *)&uu[14] = v169;
                  _os_log_fault_impl(&dword_1B9BE0000, v46, OS_LOG_TYPE_FAULT, "SAKTSYM Mismatched bundle id %s with existing binary %@", uu, 0x16u);

                }
                *__error() = v45;
              }
            }
          }
          else
          {
            v47 = *__error();
            _sa_logt();
            v48 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)uu = 136315138;
              *(_QWORD *)&uu[4] = v39;
              _os_log_fault_impl(&dword_1B9BE0000, v48, OS_LOG_TYPE_FAULT, "SAKTSYM Unable to get string for bundle id %s", uu, 0xCu);
            }

            *__error() = v47;
          }

          v24 = self;
        }
      }
      v54 = (unsigned __int16 *)((char *)v10 - *v10);
      v55 = *v54;
      if (v55 < 0xD)
      {
        v181 = 1;
        if (v55 < 9)
          break;
        v56 = 0;
      }
      else
      {
        v56 = v54[6] && *((_BYTE *)v10 + v54[6]) != 0;
        v181 = !v56;
      }
      v57 = v54[4];
      if (!v57)
        break;
      if (!*(int *)((char *)v10 + v57 + *(unsigned int *)((char *)v10 + v57)))
      {
        if (_MergedGlobals_4[0] != 1)
        {
LABEL_218:
          v190 = -1;
          v193 = -1;
LABEL_223:
          if ((v181 & 1) != 0)
            goto LABEL_242;
          goto LABEL_224;
        }
        v148 = *__error();
        _sa_logt();
        v149 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(self, "debugDescription");
          v168 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)uu = 138412290;
          *(_QWORD *)&uu[4] = v168;
          _os_log_debug_impl(&dword_1B9BE0000, v149, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but has zero segments", uu, 0xCu);

        }
        goto LABEL_216;
      }
      v178 = objc_msgSend(v196, "count");
      v179 = v56;
      v58 = *(unsigned __int16 *)((char *)v10 - *v10 + 8);
      v59 = *(unsigned int *)((char *)v10 + v58);
      v60 = *(unsigned int *)((char *)v10 + v58 + v59);
      if ((_DWORD)v60)
      {
        v61 = 0;
        v188 = 0;
        v195 = 4 * v60;
        v198 = (char *)v5 + v58 + v8 + v59;
        v193 = -1;
        v190 = -1;
        while (1)
        {
          v62 = *(unsigned int *)&v198[v61 + 8];
          v63 = &v198[v61 + v62];
          v64 = v62 - *((int *)v63 + 2);
          v65 = &v198[v61 + v64];
          v66 = *((unsigned __int16 *)v65 + 4);
          if (v66 >= 5 && (v67 = *((unsigned __int16 *)v65 + 6)) != 0)
            v68 = &v198[v61 + 12 + v62 + v67 + *(unsigned int *)&v198[v61 + 8 + v62 + v67]];
          else
            v68 = 0;
          v69 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8));
          if (*(unsigned int *)((char *)v69 + *v69) != 1)
            goto LABEL_84;
          if (v193 != -1)
            break;
          if (v66 >= 7 && (v77 = *(unsigned __int16 *)&v198[v61 + 14 + v64]) != 0)
            v78 = *(_QWORD *)&v198[v61 + 8 + v62 + v77];
          else
            v78 = -1;
          v193 = v78;
          if (v68)
            goto LABEL_85;
LABEL_99:
          if (!a3
            || !CSArchitectureIsArm64()
            || (v79 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8)),
                *(unsigned int *)((char *)v79 + *v79) != 1))
          {
            if (_MergedGlobals_4[0] == 1)
            {
              v82 = *__error();
              _sa_logt();
              v83 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
              {
                v125 = &v198[v61 + v62 - *((int *)v63 + 2)];
                if (*((unsigned __int16 *)v125 + 4) >= 0xFu && (v126 = *((unsigned __int16 *)v125 + 11)) != 0)
                  v127 = *(_QWORD *)&v198[v61 + 8 + v62 + v126];
                else
                  v127 = -1;
                objc_msgSend(self, "debugDescription", log);
                v133 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)uu = 134218242;
                *(_QWORD *)&uu[4] = v127;
                *(_WORD *)&uu[12] = 2112;
                *(_QWORD *)&uu[14] = v133;
                _os_log_debug_impl(&dword_1B9BE0000, v83, OS_LOG_TYPE_DEBUG, "SAKTSYM No name for segment at offset 0x%llx into %@", uu, 0x16u);

              }
              *__error() = v82;
              goto LABEL_183;
            }
            goto LABEL_184;
          }
          if (qword_1ED1DD620 != -1)
            dispatch_once(&qword_1ED1DD620, &__block_literal_global_2);
          v68 = "__TEXT_EXEC";
          if (_MergedGlobals_4[0] == 1)
          {
            v80 = *__error();
            _sa_logt();
            v81 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
            {
              v135 = &v198[v61 + v62 - *((int *)v63 + 2)];
              if (*((unsigned __int16 *)v135 + 4) >= 0xFu && (v136 = *((unsigned __int16 *)v135 + 11)) != 0)
                v137 = *(_QWORD *)&v198[v61 + 8 + v62 + v136];
              else
                v137 = -1;
              v187 = v137;
              objc_msgSend(self, "debugDescription", log);
              v147 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)uu = 134218242;
              *(_QWORD *)&uu[4] = v187;
              *(_WORD *)&uu[12] = 2112;
              *(_QWORD *)&uu[14] = v147;
              _os_log_debug_impl(&dword_1B9BE0000, v81, OS_LOG_TYPE_DEBUG, "SAKTSYM No name for segment at offset 0x%llx into %@, assuming TEXT_EXEC", uu, 0x16u);

            }
            *__error() = v80;
            v68 = "__TEXT_EXEC";
            v24 = self;
          }
LABEL_85:
          if (!SAShouldIgnoreSegmentWithCName(v68))
          {
            if (strncmp(v68, "__TEXT", 6uLL))
              goto LABEL_88;
            v84 = &v198[v61 + v62 - *((int *)v63 + 2)];
            if (*((unsigned __int16 *)v84 + 4) < 7u
              || (v85 = *((unsigned __int16 *)v84 + 7)) == 0
              || (v184 = *(_QWORD *)&v198[v61 + 8 + v62 + v85], v184 == -1))
            {
              if (_MergedGlobals_4[0] == 1)
              {
                v86 = *__error();
                _sa_logt();
                v87 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
                {
                  objc_msgSend(self, "debugDescription");
                  v130 = objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)uu = 138412290;
                  *(_QWORD *)&uu[4] = v130;
                  v186 = (void *)v130;
                  _os_log_debug_impl(&dword_1B9BE0000, v87, OS_LOG_TYPE_DEBUG, "SAKTSYM TEXT segment has no address for %@", uu, 0xCu);

                }
                *__error() = v86;
                v184 = v190;
                v24 = self;
              }
              else
              {
LABEL_88:
                v184 = v190;
              }
            }
            SANSStringForCString(v68);
            v72 = (void *)objc_claimAutoreleasedReturnValue();
            v191 = v72;
            if (v72)
            {
              -[SABinary segmentWithCleanName:](v24, v72);
              v73 = (_QWORD *)objc_claimAutoreleasedReturnValue();
              if (!v73)
              {
                v74 = &v198[v61 + v62 - *((int *)v63 + 2)];
                if (*((unsigned __int16 *)v74 + 4) >= 9u && (v75 = *((unsigned __int16 *)v74 + 8)) != 0)
                  v76 = *(_QWORD *)&v198[v61 + 8 + v62 + v75];
                else
                  v76 = 0;
                +[SASegment segmentWithBinary:name:length:]((uint64_t)SASegment, self, v191, v76);
                v90 = (void *)objc_claimAutoreleasedReturnValue();
                -[SABinary addSegment:](self, v90);
                if (_MergedGlobals_4[0] == 1)
                {
                  v91 = *__error();
                  _sa_logt();
                  v92 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                  {
                    objc_msgSend(v90, "debugDescription");
                    v134 = objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)uu = 138412290;
                    *(_QWORD *)&uu[4] = v134;
                    log = (os_log_t)v134;
                    _os_log_debug_impl(&dword_1B9BE0000, v92, OS_LOG_TYPE_DEBUG, "SAKTSYM new segment %@", uu, 0xCu);

                  }
                  *__error() = v91;
                }
                v73 = v90;
              }
              v93 = &v198[v61 + v62 - *((int *)v63 + 2)];
              v180 = &v198[v61 + v62];
              if (*((unsigned __int16 *)v93 + 4) >= 9u)
              {
                v94 = *((unsigned __int16 *)v93 + 8);
                if (v94)
                {
                  if (*(_QWORD *)&v198[v61 + 8 + v62 + v94])
                  {
                    if (objc_msgSend(v73, "length"))
                    {
                      v95 = objc_msgSend(v73, "length");
                      v96 = &v198[v61 + v62 - *((int *)v63 + 2)];
                      if (*((unsigned __int16 *)v96 + 4) < 9u)
                      {
                        v97 = 0;
                      }
                      else
                      {
                        v97 = *((unsigned __int16 *)v96 + 8);
                        if (v97)
                          v97 = *(_QWORD *)&v198[v61 + 8 + v62 + v97];
                      }
                      if (v95 != v97 && _MergedGlobals_4[0] == 1)
                      {
                        v105 = *__error();
                        _sa_logt();
                        v106 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
                        {
                          log = v106;
                          objc_msgSend(v73, "debugDescription");
                          v140 = objc_claimAutoreleasedReturnValue();
                          v141 = (void *)v140;
                          v142 = &v198[v61 + v62 - *((int *)v180 + 2)];
                          if (*((unsigned __int16 *)v142 + 4) < 9u)
                          {
                            v143 = 0;
                            v144 = log;
                          }
                          else
                          {
                            v143 = *((unsigned __int16 *)v142 + 8);
                            v144 = log;
                            if (v143)
                              v143 = *(_QWORD *)&v198[v61 + 8 + v62 + v143];
                          }
                          *(_DWORD *)uu = 138412546;
                          *(_QWORD *)&uu[4] = v140;
                          *(_WORD *)&uu[12] = 2048;
                          *(_QWORD *)&uu[14] = v143;
                          _os_log_debug_impl(&dword_1B9BE0000, v144, OS_LOG_TYPE_DEBUG, "SAKTSYM segment %@ length mismatch 0x%llx", uu, 0x16u);

                          v106 = log;
                        }
                        goto LABEL_147;
                      }
                    }
                    else
                    {
                      v102 = &v198[v61 + v62 - *((int *)v63 + 2)];
                      if (*((unsigned __int16 *)v102 + 4) >= 9u && (v103 = *((unsigned __int16 *)v102 + 8)) != 0)
                        v104 = *(_QWORD *)&v198[v61 + 8 + v62 + v103];
                      else
                        v104 = 0;
                      -[SASegment setLength:](v73, v104);
                      if (_MergedGlobals_4[0] == 1)
                      {
                        v105 = *__error();
                        _sa_logt();
                        v106 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
                        {
                          log = v106;
                          objc_msgSend(v73, "debugDescription");
                          v138 = (void *)objc_claimAutoreleasedReturnValue();
                          v139 = objc_msgSend(v73, "length");
                          *(_DWORD *)uu = 138412546;
                          *(_QWORD *)&uu[4] = v138;
                          *(_WORD *)&uu[12] = 2048;
                          *(_QWORD *)&uu[14] = v139;
                          _os_log_debug_impl(&dword_1B9BE0000, log, OS_LOG_TYPE_DEBUG, "SAKTSYM segment %@ added length 0x%llx", uu, 0x16u);

                          v106 = log;
                        }
LABEL_147:

                        *__error() = v105;
                        v63 = &v198[v61 + v62];
                      }
                    }
                  }
                }
              }
              v107 = v62 - *((int *)v63 + 2);
              v108 = *(unsigned __int16 *)&v198[v61 + 8 + v107];
              if (v108 < 0xF
                || !*(_WORD *)&v198[v61 + 22 + v107]
                || (v109 = *(_QWORD *)&v198[v61 + 8 + v62 + *(unsigned __int16 *)&v198[v61 + 22 + v107]], v109 == -1))
              {
                v112 = (unsigned __int16 *)((char *)v10 - *v10);
                if (*v112 >= 0xDu)
                {
                  v113 = v112[6];
                  if (v113)
                  {
                    v114 = *((unsigned __int8 *)v10 + v113);
                    if (v108 >= 7 && v114 != 0)
                    {
                      v116 = *(unsigned __int16 *)&v198[v61 + 14 + v107];
                      if (v116)
                      {
                        v117 = *(_QWORD *)&v198[v61 + 8 + v62 + v116];
                        if (v117 != -1 && v184 != -1)
                        {
                          v109 = v117 - v184;
                          goto LABEL_151;
                        }
                      }
                    }
                  }
                }
              }
              else
              {
LABEL_151:
                if (v109 != 0x7FFFFFFFFFFFFFFFLL && (objc_msgSend(v73, "hasOffsetIntoBinary") & 1) == 0)
                {
                  if (v73)
                    v73[5] = v109;
                  if (_MergedGlobals_4[0] == 1)
                  {
                    v110 = *__error();
                    _sa_logt();
                    v111 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                    {
                      objc_msgSend(v73, "debugDescription");
                      v145 = (void *)objc_claimAutoreleasedReturnValue();
                      v146 = objc_msgSend(v73, "offsetIntoBinary");
                      *(_DWORD *)uu = 138412546;
                      *(_QWORD *)&uu[4] = v145;
                      *(_WORD *)&uu[12] = 2048;
                      *(_QWORD *)&uu[14] = v146;
                      _os_log_debug_impl(&dword_1B9BE0000, v111, OS_LOG_TYPE_DEBUG, "SAKTSYM segment %@ added offsetIntoBinary 0x%llx", uu, 0x16u);

                    }
                    *__error() = v110;
                  }
                }
              }
              if (!v179)
              {
                v119 = v62 - *((int *)v180 + 2);
                if (*(unsigned __int16 *)&v198[v61 + 8 + v119] < 7u
                  || (v120 = *(unsigned __int16 *)&v198[v61 + 14 + v119]) == 0
                  || (v121 = *(_QWORD *)&v198[v61 + 8 + v62 + v120], v121 == -1))
                {
                  if (_MergedGlobals_4[0] == 1)
                  {
                    v122 = *__error();
                    _sa_logt();
                    v123 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
                    {
                      objc_msgSend(self, "debugDescription");
                      v131 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v73, "debugDescription");
                      v132 = (void *)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)uu = 138412546;
                      *(_QWORD *)&uu[4] = v131;
                      *(_WORD *)&uu[12] = 2112;
                      *(_QWORD *)&uu[14] = v132;
                      _os_log_debug_impl(&dword_1B9BE0000, v123, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but segment %@ has no load address", uu, 0x16u);

                    }
                    *__error() = v122;
                  }
                }
                else if (v121 - a4 >= a5)
                {
                  +[SABinaryLoadInfo binaryLoadInfoWithSegment:loadAddress:isInKernelAddressSpace:exclave:](SABinaryLoadInfo, v73, v121, a3, 0);
                  v124 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v196, "addObject:", v124);

                }
                else
                {
                  ++v194;
                }
              }

            }
            else
            {
              v88 = *__error();
              _sa_logt();
              v89 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
              {
                v128 = &v197[-*(int *)v197];
                if (*(unsigned __int16 *)v128 < 7u)
                {
                  v129 = 0;
                }
                else
                {
                  v129 = *((unsigned __int16 *)v128 + 3);
                  if (v129)
                    v129 += (uint64_t)&v197[*(unsigned int *)&v197[v129]];
                }
                *(_DWORD *)uu = 136315138;
                *(_QWORD *)&uu[4] = v129 + 4;
                _os_log_fault_impl(&dword_1B9BE0000, v89, OS_LOG_TYPE_FAULT, "SAKTSYM Unable to get string for symbol owner path %s", uu, 0xCu);
              }

              *__error() = v88;
            }

            v190 = v184;
LABEL_183:
            v24 = self;
            goto LABEL_184;
          }
          ++v188;
LABEL_184:
          v61 += 4;
          if (v195 == v61)
            goto LABEL_220;
        }
        v70 = *__error();
        _sa_logt();
        v71 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
        {
          objc_msgSend(self, "debugDescription");
          v98 = objc_claimAutoreleasedReturnValue();
          v99 = &v198[v61 + v62 - *((int *)v63 + 2)];
          if (*((unsigned __int16 *)v99 + 4) >= 7u && (v100 = *((unsigned __int16 *)v99 + 7)) != 0)
            v101 = *(_QWORD *)&v198[v61 + 8 + v62 + v100];
          else
            v101 = -1;
          *(_DWORD *)uu = 138413058;
          *(_QWORD *)&uu[4] = v98;
          *(_WORD *)&uu[12] = 2048;
          *(_QWORD *)&uu[14] = v193;
          *(_WORD *)&uu[22] = 2048;
          *(_QWORD *)v207 = v101;
          *(_WORD *)&v207[8] = 2082;
          v208 = v68;
          v185 = (void *)v98;
          _os_log_fault_impl(&dword_1B9BE0000, v71, OS_LOG_TYPE_FAULT, "SAKTSYM %@: ktrace claimed 1 segment, but after 0x%llx here's another: 0x%llx %{public}s", uu, 0x2Au);

        }
        *__error() = v70;
        v24 = self;
LABEL_84:
        if (v68)
          goto LABEL_85;
        goto LABEL_99;
      }
      v188 = 0;
      v190 = -1;
      v193 = -1;
LABEL_220:
      if (v179)
        goto LABEL_223;
      if (v178 != objc_msgSend(v196, "count"))
        goto LABEL_223;
      v150 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8));
      if (*(unsigned int *)((char *)v150 + *v150) == v188)
        goto LABEL_223;
      if (_MergedGlobals_4[0] == 1)
      {
        v164 = *__error();
        _sa_logt();
        v165 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(self, "debugDescription");
          v171 = (void *)objc_claimAutoreleasedReturnValue();
          v172 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8));
          LODWORD(v172) = *(unsigned int *)((char *)v172 + *v172);
          *(_DWORD *)uu = 138412546;
          *(_QWORD *)&uu[4] = v171;
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = (_DWORD)v172;
          _os_log_debug_impl(&dword_1B9BE0000, v165, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but no segments (of %d) have name/load addresses", uu, 0x12u);

        }
        *__error() = v164;
      }
LABEL_224:
      v203 = 0u;
      v204 = 0u;
      v201 = 0u;
      v202 = 0u;
      v151 = v196;
      v152 = objc_msgSend(v151, "countByEnumeratingWithState:objects:count:", &v201, v205, 16);
      if (v152)
      {
        v153 = *(_QWORD *)v202;
        while (2)
        {
          for (i = 0; i != v152; ++i)
          {
            if (*(_QWORD *)v202 != v153)
              objc_enumerationMutation(v151);
            v155 = *(void **)(*((_QWORD *)&v201 + 1) + 8 * i);
            objc_msgSend(v155, "binary", log);
            v156 = (id)objc_claimAutoreleasedReturnValue();
            v157 = v156 == self;

            if (v157)
            {
              v159 = *__error();
              _sa_logt();
              v160 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
              {
                objc_msgSend(v155, "debugDescription");
                v166 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)uu = 138412290;
                *(_QWORD *)&uu[4] = v166;
                _os_log_error_impl(&dword_1B9BE0000, v160, OS_LOG_TYPE_ERROR, "SAKTSYM symbol owner contiguous, but already have binary in load infos: %@", uu, 0xCu);

              }
              *__error() = v159;

              goto LABEL_241;
            }
          }
          v152 = objc_msgSend(v151, "countByEnumeratingWithState:objects:count:", &v201, v205, 16);
          if (v152)
            continue;
          break;
        }
      }

      if (v190 == -1)
        v158 = v193;
      else
        v158 = v190;
      if (v158 == -1)
      {
        v24 = self;
        if (_MergedGlobals_4[0] != 1)
          goto LABEL_242;
        v161 = *__error();
        _sa_logt();
        v162 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(self, "debugDescription");
          v170 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)uu = 138412290;
          *(_QWORD *)&uu[4] = v170;
          _os_log_debug_impl(&dword_1B9BE0000, v162, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ contiguous, but has no load address", uu, 0xCu);

        }
        *__error() = v161;
        goto LABEL_241;
      }
      v24 = self;
      if (v158 - a4 >= a5)
      {
        +[SABinaryLoadInfo binaryLoadInfoWithBinary:loadAddress:isInKernelAddressSpace:exclave:]((uint64_t)SABinaryLoadInfo, self, v158, a3, 0);
        v163 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v151, "addObject:", v163);

LABEL_241:
        v24 = self;
        goto LABEL_242;
      }
      ++v189;
LABEL_242:

LABEL_20:
      objc_autoreleasePoolPop(v9);
      ++v7;
      ++v5;
      if (v7 == v200)
        goto LABEL_255;
    }
    if (_MergedGlobals_4[0] != 1)
      goto LABEL_218;
    v148 = *__error();
    _sa_logt();
    v149 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
    {
      objc_msgSend(self, "debugDescription");
      v167 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)uu = 138412290;
      *(_QWORD *)&uu[4] = v167;
      _os_log_debug_impl(&dword_1B9BE0000, v149, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but has no segments", uu, 0xCu);

    }
LABEL_216:

    *__error() = v148;
    if ((v181 & 1) != 0)
      goto LABEL_241;
    v193 = -1;
    v190 = -1;
    goto LABEL_224;
  }
  v189 = 0;
  v194 = 0;
LABEL_255:
  if ((v194 > 0 || v189 > 0) && _MergedGlobals_4[0] == 1)
  {
    v173 = *__error();
    _sa_logt();
    v174 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uu = 67109888;
      *(_DWORD *)&uu[4] = v194;
      *(_WORD *)&uu[8] = 1024;
      *(_DWORD *)&uu[10] = v189;
      *(_WORD *)&uu[14] = 2048;
      *(_QWORD *)&uu[16] = a4;
      *(_WORD *)v207 = 2048;
      *(_QWORD *)&v207[2] = a4 + a5;
      _os_log_debug_impl(&dword_1B9BE0000, v174, OS_LOG_TYPE_DEBUG, "SAKTSYM %d segments and %d binaries excluded due to range 0x%llx-0x%llx", uu, 0x22u);
    }

    *__error() = v173;
  }
  +[SABinaryLoadInfo sortBinaryLoadInfos:]((uint64_t)SABinaryLoadInfo, v196);
  v175 = (void *)objc_msgSend(v196, "copy");

  return v175;
}

size_t __78__SASampleStore_KPerf__loadInfosForKTSymbolOwners_isKernelSpace_excludeRange___block_invoke()
{
  return fwrite("Ktrace load info for 64-bit arm kernel binary segment has no name, assuming TEXT_EXEC segment...\n", 0x61uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
}

void __116__SASampleStore_KPerf__addLoadInfoFromKTrace_lastKTraceEventTimestamp_checkForNewLoadInfosEvenWithExistingLoadInfo___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  char *v7;
  char *v8;
  void *v9;
  int v10;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  void *v15;
  void *v16;
  id v17;
  const char *v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  NSObject *v22;
  int *v23;
  NSObject *v24;
  unint64_t v25;
  const unsigned __int8 *v26;
  const unsigned __int8 *v27;
  uint64_t v28;
  const unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  unsigned int *v35;
  unsigned int v36;
  FlatbufferSymbols::DyldSharedCacheMetadata *v37;
  int v38;
  unsigned __int16 *v40;
  uint64_t v41;
  const unsigned __int8 *v42;
  const unsigned __int8 *v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unsigned __int16 *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 *v49;
  uint64_t v50;
  const unsigned __int8 *v51;
  const unsigned __int8 *v52;
  unsigned int v53;
  uint64_t v54;
  unsigned __int16 *v55;
  uint64_t v56;
  unsigned __int16 *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const unsigned __int8 *v61;
  unsigned int v62;
  FlatbufferSymbols::MachoMetadata *v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const unsigned __int8 *v71;
  unsigned __int16 *v72;
  uint64_t v73;
  const unsigned __int8 *v74;
  unsigned int v75;
  unsigned __int16 *v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  uint64_t v85;
  unsigned __int16 *v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  uint64_t v90;
  const unsigned __int8 *v91;
  uint64_t v92;
  unsigned __int16 *v93;
  uint64_t v94;
  unsigned __int16 *v95;
  uint64_t v96;
  _DWORD *v97;
  unsigned __int16 *v98;
  uint64_t v99;
  unsigned __int16 *v100;
  uint64_t v101;
  _DWORD *v102;
  uint64_t v103;
  unsigned __int16 *v104;
  unsigned __int16 *v105;
  uint64_t v106;
  unsigned __int16 *v107;
  uint64_t v108;
  flatbuffers::Table *v109;
  const unsigned __int8 *v110;
  flatbuffers::Table *v111;
  char *v112;
  unsigned int v113;
  flatbuffers::Table *v114;
  flatbuffers::Table *v115;
  char *v116;
  FlatbufferSymbols::DyldSharedCacheMetadata *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  const unsigned __int8 *v121;
  uint64_t v122;
  const unsigned __int8 *v123;
  uint64_t v124;
  unint64_t v125;
  const unsigned __int8 *v126;
  const unsigned __int8 *v127;
  uint64_t v128;
  unsigned __int8 *v129;
  unsigned int v130;
  uint64_t v131;
  const unsigned __int8 *v132;
  unsigned int *v133;
  uint64_t v134;
  uint64_t v135;
  unsigned int *v136;
  uint64_t v137;
  unsigned int *v138;
  uint64_t v139;
  unsigned int *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned __int16 *v144;
  unsigned int v145;
  uint64_t v147;
  int *v148;
  unsigned __int16 *v149;
  uint64_t v150;
  uint64_t v151;
  unsigned __int16 *v152;
  uint64_t v153;
  char *v154;
  void *v155;
  BOOL v156;
  void *v157;
  void *v158;
  char v159;
  int v160;
  NSObject *v161;
  int v162;
  NSObject *v163;
  unsigned __int16 *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  void *v168;
  char *v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  char *v173;
  unsigned int v174;
  uint64_t v175;
  int v176;
  BOOL v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  char *v181;
  unsigned int v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  int v189;
  NSObject *v190;
  int *v191;
  void *v192;
  int v193;
  uint64_t v194;
  int v195;
  int v196;
  char *v197;
  uint64_t v198;
  uint64_t v199;
  id v200;
  void *v201;
  int v202;
  int v203;
  char *v204;
  uint64_t v205;
  uint64_t v206;
  int v207;
  char *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  void *v212;
  int v213;
  NSObject *v214;
  unsigned __int16 *v215;
  unsigned int v216;
  uint64_t v218;
  int *v219;
  unsigned __int16 *v220;
  unsigned int v221;
  int *v222;
  void *v223;
  int v224;
  unsigned __int16 *v225;
  uint64_t v226;
  void *v227;
  int v228;
  unsigned __int16 *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  int *v233;
  unsigned __int16 *v234;
  uint64_t v235;
  int v236;
  int v237;
  NSObject *v238;
  unsigned __int16 *v239;
  void *v240;
  void *v241;
  uint64_t v242;
  uint64_t v243;
  unint64_t v244;
  int v245;
  NSObject *v246;
  void *v247;
  unsigned __int16 *v248;
  uint64_t v249;
  unsigned int *v250;
  flatbuffers::Table *v251;
  int v252;
  NSObject *v253;
  uint64_t v254;
  uint64_t v255;
  void *v256;
  void *v257;
  void *v258;
  int v259;
  void *v260;
  void *v261;
  void *v262;
  _BOOL4 v263;
  void *v264;
  _BOOL4 v265;
  int v266;
  NSObject *v267;
  int v268;
  NSObject *v269;
  unsigned __int16 *v270;
  unsigned int v271;
  uint64_t v273;
  int *v274;
  unsigned __int16 *v275;
  uint64_t v276;
  char *v277;
  int v278;
  NSObject *v279;
  unsigned __int16 *v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t i;
  void *v285;
  void *v286;
  id v287;
  void *v288;
  BOOL v289;
  int v290;
  NSObject *v291;
  void *v292;
  int v293;
  int *v294;
  char v295;
  uint64_t v296;
  uint64_t v297;
  unsigned __int16 *v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  int v302;
  NSObject *v303;
  unsigned __int16 *v304;
  uint64_t v305;
  uint64_t v306;
  unsigned __int16 *v307;
  uint64_t v308;
  unsigned int *v309;
  void *v310;
  void *v311;
  int v312;
  NSObject *v313;
  int v314;
  NSObject *v315;
  int *v316;
  void *v317;
  int v318;
  unsigned __int16 *v319;
  uint64_t v320;
  void *v321;
  int v322;
  int *v323;
  void *v324;
  int v325;
  unsigned __int16 *v326;
  uint64_t v327;
  int v328;
  void *v329;
  int v330;
  void *v331;
  void *v332;
  int v333;
  uint64_t v334;
  unsigned int *v335;
  void *v336;
  int v337;
  uint64_t v338;
  unsigned int *v339;
  void *v340;
  void *v341;
  void *v342;
  int v343;
  unsigned __int16 *v344;
  uint64_t v345;
  int v346;
  unsigned __int16 *v347;
  uint64_t v348;
  char *v349;
  void *v350;
  int v351;
  uint64_t FamilyName;
  void *v353;
  int v354;
  unsigned __int16 *v355;
  uint64_t v356;
  void *v357;
  int v358;
  void *v359;
  unsigned int *v360;
  uint64_t v361;
  unsigned int *v362;
  uint64_t v363;
  void *v364;
  unsigned __int16 *v365;
  uint64_t v366;
  uint64_t v367;
  void *v368;
  int v369;
  int v370;
  void *v371;
  void *v372;
  void *v373;
  int v374;
  NSObject *v375;
  unsigned __int16 *v376;
  uint64_t v377;
  int v378;
  id v379;
  uint64_t v380;
  unsigned __int16 *v381;
  uint64_t v382;
  int v383;
  id v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  char *v391;
  uint64_t v392;
  uint64_t v393;
  unsigned int v394;
  char *v395;
  char *v396;
  flatbuffers::Table *v397;
  flatbuffers::Table *v398;
  uint64_t v399;
  uint64_t v400;
  int v401;
  void *v402;
  _DWORD *v403;
  void *v404;
  void *v405;
  os_log_t oslog;
  NSObject *osloga;
  os_log_t oslogb;
  os_log_t oslogc;
  char *v410;
  uint64_t v411;
  NSObject *v412;
  char *v413;
  unint64_t v414;
  char *v415;
  char *v416;
  uint64_t v417;
  uint64_t v418;
  unsigned __int16 *v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  void *v423;
  flatbuffers::Table *v424;
  flatbuffers::Table *v425;
  flatbuffers::Table *v426;
  flatbuffers::Table *v427;
  uint64_t v428;
  _DWORD *v429;
  unint64_t v430;
  char *v431;
  uint64_t v432;
  unsigned __int8 *v433;
  char *v434;
  unsigned int v435;
  const unsigned __int8 *v436;
  char *v437;
  uint64_t v438;
  const unsigned __int8 *v439;
  const unsigned __int8 *v440;
  unsigned __int16 *v441;
  uint64_t v442;
  unsigned __int16 *v443;
  flatbuffers::Table *v444;
  int64_t v445;
  unsigned int *v446;
  unsigned int *v447;
  os_log_t log;
  char loga;
  NSObject *logb;
  os_log_t logc;
  const unsigned __int8 *src;
  _BYTE *srca;
  void *srcb;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  int *v458;
  void *v459;
  int v460;
  int v461;
  id obj;
  id obja;
  id objb;
  id objc;
  id objg;
  id obje;
  id objf;
  id objh;
  id objd;
  char *v471;
  const unsigned __int8 *v472;
  void *v473;
  void *v474;
  char *v475;
  uint64_t v476;
  unsigned int *v477;
  char *v478;
  unint64_t v479;
  unsigned int *v480;
  flatbuffers::Table *v481;
  unsigned int v482;
  flatbuffers::Table *v483;
  flatbuffers::Table *v484;
  flatbuffers::Table *v485;
  flatbuffers::Table *v486;
  flatbuffers::Table *v487;
  flatbuffers::Table *v488;
  flatbuffers::Table *v489;
  flatbuffers::Table *v490;
  flatbuffers::Table *v491;
  flatbuffers::Table *v492;
  __int128 v493;
  __int128 v494;
  __int128 v495;
  __int128 v496;
  __int128 v497;
  __int128 v498;
  __int128 v499;
  __int128 v500;
  flatbuffers::Table *v501;
  unint64_t v502;
  __int128 v503;
  uint64_t v504;
  char v505;
  _BYTE v506[128];
  uint8_t v507[128];
  _BYTE buf[28];
  __int16 v509;
  uint64_t v510;
  __int16 v511;
  os_log_t v512;
  __int16 v513;
  uint64_t v514;
  uuid_t uu;
  uint64_t v516;

  v516 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  -[SASampleStore _lastTaskOnOrBeforeTimestamp:inTasks:](*(_QWORD *)(a1 + 32), *(void **)(a1 + 40), v6);
  v7 = (char *)objc_claimAutoreleasedReturnValue();
  v8 = v7;
  if (!v7)
  {
    if (_MergedGlobals_4[0] == 1)
    {
      v13 = *__error();
      _sa_logt();
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v370 = objc_msgSend(v5, "intValue");
        objc_msgSend(*(id *)(a1 + 40), "debugDescription");
        v371 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v370;
        *(_WORD *)&buf[8] = 2112;
        *(_QWORD *)&buf[10] = v371;
        _os_log_debug_impl(&dword_1B9BE0000, v14, OS_LOG_TYPE_DEBUG, "SAKTSYM No tasks with pid %d before last ktrace timestamp %@", buf, 0x12u);

      }
      *__error() = v13;
    }
    goto LABEL_27;
  }
  if (objc_msgSend(v7, "pid"))
  {
    objc_msgSend(v8, "binaryLoadInfos");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v9, "count"))
    {
      v10 = *(unsigned __int8 *)(a1 + 56);

      if (!v10)
      {
        if (_MergedGlobals_4[0] == 1)
        {
          v11 = *__error();
          _sa_logt();
          v12 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            objc_msgSend(v8, "name");
            v373 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138412546;
            *(_QWORD *)&buf[4] = v373;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = objc_msgSend(v8, "pid");
            _os_log_debug_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Already have load info, not checking libktrace", buf, 0x12u);

          }
          *__error() = v11;
        }
LABEL_27:

        return;
      }
    }
    else
    {

    }
  }
  objc_msgSend(v8, "pid");
  v15 = (void *)ktrace_dumpbuffer_address_space_pid();
  v16 = v15;
  if (!v15)
  {
    if (_MergedGlobals_4[0] == 1)
    {
      v21 = *__error();
      _sa_logt();
      v24 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v8, "name");
        v372 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v372;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = objc_msgSend(v8, "pid");
        _os_log_debug_impl(&dword_1B9BE0000, v24, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] libktrace doesn't have load info", buf, 0x12u);

      }
      v23 = __error();
      goto LABEL_25;
    }
LABEL_26:

    goto LABEL_27;
  }
  v17 = objc_retainAutorelease(v15);
  v18 = (const char *)objc_msgSend(v17, "bytes");
  v19 = objc_msgSend(v17, "length");
  v20 = v19;
  v501 = (flatbuffers::Table *)v18;
  v502 = v19;
  v503 = xmmword_1B9CC2B20;
  v504 = 0;
  v505 = 1;
  if (v19 >= 0x7FFFFFFF)
    __assert_rtn("Verifier", "flatbuffers.h", 2280, "size_ < FLATBUFFERS_MAX_BUFFER_SIZE");
  if (v19 < 8)
    goto LABEL_18;
  if (strncmp(v18 + 4, "SYMB", 4uLL))
    goto LABEL_18;
  v25 = *(unsigned int *)v18;
  if ((int)v25 < 1)
    goto LABEL_18;
  if (v20 - 1 < v25)
    goto LABEL_18;
  v26 = (const unsigned __int8 *)&v18[v25];
  if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)&v18[v25])
    || !flatbuffers::Table::VerifyOffset((flatbuffers::Table *)&v18[v25], (const flatbuffers::Verifier *)&v501, 4u))
  {
    goto LABEL_18;
  }
  v27 = &v26[-*(int *)v26];
  if (*(unsigned __int16 *)v27 >= 5u)
  {
    v28 = *((unsigned __int16 *)v27 + 2);
    if (v28)
    {
      if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, &v26[v28 + *(unsigned int *)&v26[v28]], 4uLL, 0))goto LABEL_18;
      v29 = &v26[-*(int *)v26];
      if (*(unsigned __int16 *)v29 >= 5u)
      {
        v30 = *((unsigned __int16 *)v29 + 2);
        if (v30)
        {
          v31 = *(unsigned int *)&v26[v30];
          log = (os_log_t)&v26[v30 + v31];
          if (LODWORD(log->isa))
          {
            v32 = 0;
            v33 = &v18[v25 + v31 + v30];
            v34 = &v18[v25 + v30 + v31];
            v471 = (char *)(v34 + 8);
            v475 = (char *)(v34 + 16);
            obj = (id)(v33 + 8);
            v478 = (char *)(v33 + 16);
            do
            {
              v35 = (unsigned int *)&log->isa + v32 + 1;
              src = (const unsigned __int8 *)*v35;
              v455 = v32;
              v488 = (flatbuffers::Table *)&src[(_QWORD)v35];
              if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, &src[(_QWORD)v35]))
                goto LABEL_18;
              v481 = (flatbuffers::Table *)((char *)v488 - *(int *)v488);
              v36 = *(unsigned __int16 *)v481;
              if (v36 >= 5
                && *((_WORD *)v481 + 2)
                && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v488 + *((unsigned __int16 *)v481 + 2)) - v501))
              {
                goto LABEL_18;
              }
              if (!flatbuffers::Table::VerifyOffset(v488, (const flatbuffers::Verifier *)&v501, 6u))
                goto LABEL_18;
              if (v36 < 7)
              {
                if (v36 < 5)
                  goto LABEL_124;
              }
              else if (*((_WORD *)v481 + 3))
              {
                v37 = (flatbuffers::Table *)((char *)v488
                                           + *((unsigned __int16 *)v481 + 3)
                                           + *(unsigned int *)((char *)v488 + *((unsigned __int16 *)v481 + 3)));
                goto LABEL_50;
              }
              v37 = 0;
LABEL_50:
              if (*((_WORD *)v481 + 2))
              {
                v38 = *((unsigned __int8 *)v488 + *((unsigned __int16 *)v481 + 2));
                if (v38 == 3)
                {
                  if (v37 && !FlatbufferSymbols::DyldSharedCacheMetadata::Verify(v37, (flatbuffers::Verifier *)&v501))
                    goto LABEL_18;
                }
                else if (v38 == 2)
                {
                  if (v37 && !FlatbufferSymbols::MachoMetadata::Verify(v37, (flatbuffers::Verifier *)&v501))
                    goto LABEL_18;
                }
                else if (v38 == 1 && v37 != 0)
                {
                  if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v37)|| !flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 4u))
                  {
                    goto LABEL_18;
                  }
                  v40 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  if (*v40 >= 5u && (v41 = v40[2]) != 0)
                    v42 = (const unsigned __int8 *)v37 + v41 + *(unsigned int *)((char *)v37 + v41);
                  else
                    v42 = 0;
                  if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v42))
                    goto LABEL_18;
                  v441 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  v482 = *v441;
                  if (v482 >= 7
                    && (v441[3]
                     && (v502 < 9
                      || v502 - 8 < (FlatbufferSymbols::DyldSharedCacheMetadata *)((char *)v37 + v441[3]) - v501)
                     || v482 >= 9
                     && v441[4]
                     && (v502 < 9
                      || v502 - 8 < (FlatbufferSymbols::DyldSharedCacheMetadata *)((char *)v37 + v441[4]) - v501)))
                  {
                    goto LABEL_18;
                  }
                  if (!flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 0xAu))
                    goto LABEL_18;
                  v43 = v482 >= 0xB && v441[5]
                      ? (const unsigned __int8 *)v37 + v441[5] + *(unsigned int *)((char *)v37 + v441[5])
                      : 0;
                  if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v43)
                    || !flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 0xCu))
                  {
                    goto LABEL_18;
                  }
                  v44 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  if (*v44 >= 0xDu)
                  {
                    v45 = v44[6];
                    if (v45)
                    {
                      if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v37 + v45 + *(unsigned int *)((char *)v37 + v45), 4uLL, 0))goto LABEL_18;
                      v46 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                      if (*v46 >= 0xDu)
                      {
                        v47 = v46[6];
                        if (v47)
                        {
                          v413 = (char *)v37 + v47;
                          v442 = *(unsigned int *)((char *)v37 + v47);
                          if (*(_DWORD *)((char *)v37 + v47 + v442))
                          {
                            v417 = 0;
                            v431 = v413 + 4;
                            v483 = (FlatbufferSymbols::DyldSharedCacheMetadata *)((char *)v37 + v47);
                            while (1)
                            {
                              v434 = (char *)v483 + v442;
                              v438 = *(unsigned int *)((char *)v483 + v442 + 4);
                              v424 = (flatbuffers::Table *)((char *)v483 + v442 + v438 + 4);
                              if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v424))break;
                              v428 = v438 - *(int *)&v434[v438 + 4];
                              v435 = *(unsigned __int16 *)&v434[v428 + 4];
                              if (v435 >= 5
                                && (*(_WORD *)((char *)v483 + v442 + v428 + 8)
                                 && (v502 < 9
                                  || v502 - 8 < (unint64_t)&v431[v442
                                                                      + v438
                                                                      + *(unsigned __int16 *)((char *)v483
                                                                                            + v442
                                                                                            + v428
                                                                                            + 8)
                                                                      - (_QWORD)v501])
                                 || v435 >= 7
                                 && (*(_WORD *)((char *)v483 + v442 + v428 + 10)
                                  && (v502 < 9
                                   || v502 - 8 < (unint64_t)&v431[v442
                                                                       + v438
                                                                       + *(unsigned __int16 *)((char *)v483
                                                                                             + v442
                                                                                             + v428
                                                                                             + 10)
                                                                       - (_QWORD)v501])
                                  || v435 >= 9
                                  && *(_WORD *)((char *)v483 + v442 + v428 + 12)
                                  && (v502 < 9
                                   || v502 - 8 < (unint64_t)&v431[v442
                                                                       + v438
                                                                       + *(unsigned __int16 *)((char *)v483
                                                                                             + v442
                                                                                             + v428
                                                                                             + 12)
                                                                       - (_QWORD)v501]))))
                              {
                                break;
                              }
                              if (!flatbuffers::Table::VerifyOffset(v424, (const flatbuffers::Verifier *)&v501, 0xAu))
                                break;
                              if (v435 >= 0xB)
                              {
                                if (*(_WORD *)((char *)v483 + v442 + v428 + 14))
                                {
                                  v48 = *(unsigned __int16 *)((char *)v483 + v442 + v428 + 14);
                                  if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v483+ v442+ v438+ v48+ *(unsigned int *)((char *)v483 + v442 + v438 + v48 + 4)+ 4, 1uLL, 0))break;
                                }
                              }
                              LODWORD(v503) = v503 - 1;
                              v431 += 4;
                              v483 = (flatbuffers::Table *)((char *)v483 + 4);
                              if (++v417 >= (unint64_t)*(unsigned int *)&v413[v442])
                                goto LABEL_110;
                            }
LABEL_18:
                            v21 = *__error();
                            _sa_logt();
                            v22 = objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                            {
                              objc_msgSend(v8, "name");
                              v368 = (void *)objc_claimAutoreleasedReturnValue();
                              v369 = objc_msgSend(v8, "pid");
                              *(_DWORD *)buf = 138412546;
                              *(_QWORD *)&buf[4] = v368;
                              *(_WORD *)&buf[12] = 1024;
                              *(_DWORD *)&buf[14] = v369;
                              _os_log_error_impl(&dword_1B9BE0000, v22, OS_LOG_TYPE_ERROR, "SAKTSYM %@ [%d] libktrace load info failed verification", buf, 0x12u);

                            }
                            v23 = __error();
LABEL_25:
                            *v23 = v21;
                            goto LABEL_26;
                          }
                        }
                      }
                    }
                  }
LABEL_110:
                  if (!flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 0xEu))
                    goto LABEL_18;
                  v49 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  if (*v49 >= 0xFu)
                  {
                    v50 = v49[7];
                    if (v50)
                    {
                      v51 = (const unsigned __int8 *)v37 + v50 + *(unsigned int *)((char *)v37 + v50);
                      if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, v51))
                        goto LABEL_18;
                      v52 = &v51[-*(int *)v51];
                      v53 = *(unsigned __int16 *)v52;
                      if (v53 >= 5)
                      {
                        if (*((_WORD *)v52 + 2)
                          && (v502 < 9 || v502 - 8 < &v51[*((unsigned __int16 *)v52 + 2)]
                                                   - (const unsigned __int8 *)v501))
                        {
                          goto LABEL_18;
                        }
                        if (v53 >= 7)
                        {
                          v54 = *((unsigned __int16 *)v52 + 3);
                          if (v54)
                          {
                            if (v502 < 9 || v502 - 8 < &v51[v54] - (const unsigned __int8 *)v501)
                              goto LABEL_18;
                          }
                        }
                      }
                      LODWORD(v503) = v503 - 1;
                    }
                  }
                  LODWORD(v503) = v503 - 1;
                }
              }
LABEL_124:
              if (!flatbuffers::Table::VerifyOffset(v488, (const flatbuffers::Verifier *)&v501, 8u))
                goto LABEL_18;
              v55 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
              if (*v55 >= 9u)
              {
                v56 = v55[4];
                if (v56)
                {
                  if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v488 + v56 + *(unsigned int *)((char *)v488 + v56), 4uLL, 0))goto LABEL_18;
                  v57 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
                  if (*v57 >= 9u)
                  {
                    v58 = v57[4];
                    if (v58)
                    {
                      v59 = *(unsigned int *)((char *)v488 + v58);
                      v429 = (_DWORD *)((char *)v488 + v58 + v59);
                      if (*v429)
                      {
                        v60 = 0;
                        v439 = &src[(_QWORD)v478 + v59 + v58];
                        v436 = &src[(_QWORD)v475 + v58 + v59];
                        while (1)
                        {
                          v432 = v60;
                          v61 = (const unsigned __int8 *)&v429[v60 + 1];
                          v418 = *(unsigned int *)v61;
                          v484 = (flatbuffers::Table *)&v61[v418];
                          if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, &v61[v418]))
                            goto LABEL_18;
                          v443 = (unsigned __int16 *)((char *)v484 - *(int *)v484);
                          v62 = *v443;
                          if (v62 >= 5
                            && v443[2]
                            && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v484 + v443[2]) - v501))
                          {
                            goto LABEL_18;
                          }
                          if (!flatbuffers::Table::VerifyOffset(v484, (const flatbuffers::Verifier *)&v501, 6u))
                            goto LABEL_18;
                          if (v62 < 7)
                            break;
                          if (!v443[3])
                            goto LABEL_142;
                          v63 = (flatbuffers::Table *)((char *)v484 + v443[3]
                                                                    + *(unsigned int *)((char *)v484 + v443[3]));
LABEL_143:
                          if (v443[2]
                            && v63
                            && *((_BYTE *)v484 + v443[2]) == 1
                            && !FlatbufferSymbols::MachoMetadata::Verify(v63, (flatbuffers::Verifier *)&v501))
                          {
                            goto LABEL_18;
                          }
LABEL_147:
                          if (!flatbuffers::Table::VerifyOffset(v484, (const flatbuffers::Verifier *)&v501, 8u))
                            goto LABEL_18;
                          v64 = *(int *)v484;
                          v65 = *(unsigned __int16 *)((char *)v484 - v64);
                          if (v65 < 9)
                            goto LABEL_267;
                          if (!*(_WORD *)((char *)v484 - v64 + 8))
                          {
                            v68 = -v64;
                            goto LABEL_251;
                          }
                          if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v484+ *(unsigned __int16 *)((char *)v484 - v64 + 8)+ *(unsigned int *)((char *)v484 + *(unsigned __int16 *)((char *)v484 - v64 + 8)), 4uLL, 0))goto LABEL_18;
                          v66 = *(int *)v484;
                          v67 = (char *)v484 - v66;
                          v65 = *(unsigned __int16 *)((char *)v484 - v66);
                          if (v65 < 9)
                            goto LABEL_267;
                          v68 = -v66;
                          v69 = *((unsigned __int16 *)v67 + 4);
                          if (!v69)
                            goto LABEL_251;
                          v70 = *(unsigned int *)((char *)v484 + v69);
                          v403 = (_DWORD *)((char *)v484 + v69 + v70);
                          if (!*v403)
                            goto LABEL_251;
                          v410 = (char *)&v439[v418 + v70 + v69];
                          v414 = 0;
                          oslog = (os_log_t)&v436[v418 + v69 + v70];
                          do
                          {
                            v71 = (const unsigned __int8 *)&v403[v414 + 1];
                            v399 = *(unsigned int *)v71;
                            v444 = (flatbuffers::Table *)&v71[v399];
                            if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, &v71[v399])
                              || !flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 4u))
                            {
                              goto LABEL_18;
                            }
                            v72 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v72 >= 5u && (v73 = v72[2]) != 0)
                              v74 = (const unsigned __int8 *)v444 + v73 + *(unsigned int *)((char *)v444 + v73);
                            else
                              v74 = 0;
                            if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v74))
                              goto LABEL_18;
                            v419 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            v75 = *v419;
                            if (v75 >= 7
                              && (v419[3]
                               && (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v444 + v419[3]) - v501)
                               || v75 >= 9
                               && v419[4]
                               && (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v444 + v419[4]) - v501)))
                            {
                              goto LABEL_18;
                            }
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0xAu))
                              goto LABEL_18;
                            if (v75 >= 0xB && v419[5])
                            {
                              if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444+ v419[5]+ *(unsigned int *)((char *)v444 + v419[5]), 4uLL, 0))goto LABEL_18;
                              v76 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                              if (*v76 >= 0xBu)
                              {
                                v77 = v76[5];
                                if (v77)
                                {
                                  v395 = (char *)v444 + v77;
                                  v397 = (flatbuffers::Table *)*(unsigned int *)((char *)v444 + v77);
                                  if (*(_DWORD *)((char *)v397 + (_QWORD)v444 + v77))
                                  {
                                    v420 = 0;
                                    v78 = &v410[v399 + (_QWORD)v397 + v77];
                                    while ((FlatbufferSymbols::Symbol::Verify((FlatbufferSymbols::Symbol *)&v78[*(unsigned int *)v78], (flatbuffers::Verifier *)&v501) & 1) != 0)
                                    {
                                      v78 += 4;
                                      if (++v420 >= (unint64_t)*(unsigned int *)((char *)v397 + (_QWORD)v395))
                                        goto LABEL_180;
                                    }
                                    goto LABEL_18;
                                  }
                                }
                              }
                            }
LABEL_180:
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0xCu))
                              goto LABEL_18;
                            v79 = *(int *)v444;
                            v80 = *(unsigned __int16 *)((char *)v444 - v79);
                            if (v80 >= 0xD)
                            {
                              if (*(_WORD *)((char *)v444 - v79 + 12))
                              {
                                if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444+ *(unsigned __int16 *)((char *)v444 - v79 + 12)+ *(unsigned int *)((char *)v444 + *(unsigned __int16 *)((char *)v444 - v79 + 12)), 1uLL, 0))goto LABEL_18;
                                v81 = *(int *)v444;
                                v82 = -v81;
                                v80 = *(unsigned __int16 *)((char *)v444 - v81);
                                LODWORD(v79) = *(_DWORD *)v444;
                              }
                              else
                              {
                                v82 = -v79;
                              }
                              if (v80 >= 0xF)
                              {
                                v83 = (unsigned __int16 *)((char *)v444 + v82);
                                if (v83[7])
                                {
                                  if (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v444 + v83[7]) - v501)
                                    goto LABEL_18;
                                }
                                if (v80 >= 0x11
                                  && (v83[8]
                                   && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v444 + v83[8]) - v501)
                                   || v80 >= 0x13
                                   && (v83[9]
                                    && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v444 + v83[9]) - v501)
                                    || v80 >= 0x15
                                    && v83[10]
                                    && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v444 + v83[10]) - v501))))
                                {
                                  goto LABEL_18;
                                }
                              }
                            }
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0x16u))
                              goto LABEL_18;
                            v84 = (unsigned __int16 *)((char *)v444 - (int)v79);
                            if (*v84 >= 0x17u)
                            {
                              v85 = v84[11];
                              if (v85)
                              {
                                if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444 + v85 + *(unsigned int *)((char *)v444 + v85), 4uLL, 0))goto LABEL_18;
                                v86 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                                if (*v86 >= 0x17u)
                                {
                                  v87 = v86[11];
                                  if (v87)
                                  {
                                    v391 = (char *)v444 + v87;
                                    v421 = *(unsigned int *)((char *)v444 + v87);
                                    if (*(_DWORD *)((char *)v444 + v87 + v421))
                                    {
                                      v392 = 0;
                                      v88 = &v410[v87 + v399];
                                      v396 = (char *)oslog + v399 + v87;
                                      do
                                      {
                                        v398 = (flatbuffers::Table *)&v88[v421 + *(unsigned int *)&v88[v421]];
                                        v400 = *(unsigned int *)&v88[v421];
                                        if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v398)|| !flatbuffers::Table::VerifyOffset(v398, (const flatbuffers::Verifier *)&v501, 4u))
                                        {
                                          goto LABEL_18;
                                        }
                                        v89 = v400 - *(int *)&v88[v421 + v400];
                                        if (*(unsigned __int16 *)&v88[v421 + v89] >= 5u
                                          && (v90 = *(unsigned __int16 *)&v88[v421 + 4 + v89]) != 0)
                                        {
                                          v91 = (const unsigned __int8 *)&v88[v421
                                                                            + v400
                                                                            + v90
                                                                            + *(unsigned int *)&v88[v421 + v400 + v90]];
                                        }
                                        else
                                        {
                                          v91 = 0;
                                        }
                                        if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v91))
                                          goto LABEL_18;
                                        v393 = v400 - *(int *)&v88[v421 + v400];
                                        v394 = *(unsigned __int16 *)&v88[v421 + v393];
                                        if (v394 >= 7
                                          && (*(_WORD *)&v88[v421 + 6 + v393]
                                           && (v502 < 9
                                            || v502 - 8 < (unint64_t)&v396[v421
                                                                                + v400
                                                                                + *(unsigned __int16 *)&v88[v421 + 6 + v393]
                                                                                - (_QWORD)v501])
                                           || v394 >= 9
                                           && *(_WORD *)&v88[v421 + 8 + v393]
                                           && (v502 < 9
                                            || v502 - 8 < (unint64_t)&v396[v421
                                                                                + v400
                                                                                + *(unsigned __int16 *)&v88[v421 + 8 + v393]
                                                                                - (_QWORD)v501])))
                                        {
                                          goto LABEL_18;
                                        }
                                        if (!flatbuffers::Table::VerifyOffset(v398, (const flatbuffers::Verifier *)&v501, 0xAu))goto LABEL_18;
                                        if (v394 >= 0xB)
                                        {
                                          if (*(_WORD *)&v88[v421 + 10 + v393])
                                          {
                                            v92 = *(unsigned __int16 *)&v88[v421 + 10 + v393];
                                            if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)&v88[v421+ v400+ v92+ *(unsigned int *)&v88[v421 + v400 + v92]], 1uLL, 0))goto LABEL_18;
                                          }
                                        }
                                        LODWORD(v503) = v503 - 1;
                                        v88 += 4;
                                        v396 += 4;
                                      }
                                      while (++v392 < (unint64_t)*(unsigned int *)&v391[v421]);
                                    }
                                  }
                                }
                              }
                            }
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0x18u))
                              goto LABEL_18;
                            v93 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v93 < 0x19u)
                              goto LABEL_237;
                            v94 = v93[12];
                            if (!v94)
                              goto LABEL_237;
                            if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444 + v94 + *(unsigned int *)((char *)v444 + v94), 4uLL, 0))goto LABEL_18;
                            v95 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v95 >= 0x19u && (v96 = v95[12]) != 0)
                              v97 = (_DWORD *)((char *)v444 + v96 + *(unsigned int *)((char *)v444 + v96));
                            else
LABEL_237:
                              v97 = 0;
                            if (!flatbuffers::Verifier::VerifyVectorOfTables<FlatbufferSymbols::SymbolNameEntry>((flatbuffers::Verifier *)&v501, v97)|| !flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0x1Au))
                            {
                              goto LABEL_18;
                            }
                            v98 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v98 < 0x1Bu)
                              goto LABEL_246;
                            v99 = v98[13];
                            if (!v99)
                              goto LABEL_246;
                            if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444 + v99 + *(unsigned int *)((char *)v444 + v99), 4uLL, 0))goto LABEL_18;
                            v100 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v100 >= 0x1Bu && (v101 = v100[13]) != 0)
                              v102 = (_DWORD *)((char *)v444 + v101 + *(unsigned int *)((char *)v444 + v101));
                            else
LABEL_246:
                              v102 = 0;
                            if ((flatbuffers::Verifier::VerifyVectorOfTables<FlatbufferSymbols::SymbolNameEntry>((flatbuffers::Verifier *)&v501, v102) & 1) == 0)goto LABEL_18;
                            LODWORD(v503) = v503 - 1;
                            oslog = (os_log_t)((char *)oslog + 4);
                            v410 += 4;
                            ++v414;
                          }
                          while (v414 < *v403);
                          v103 = *(int *)v484;
                          v68 = -v103;
                          v65 = *(unsigned __int16 *)((char *)v484 - v103);
LABEL_251:
                          if (v65 >= 0xB)
                          {
                            v104 = (unsigned __int16 *)((char *)v484 + v68);
                            if (v104[5])
                            {
                              if (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v484 + v104[5]) - v501)
                                goto LABEL_18;
                            }
                            if (v65 >= 0xD
                              && (v104[6]
                               && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v484 + v104[6]) - v501)
                               || v65 >= 0xF
                               && (v104[7]
                                && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v484 + v104[7]) - v501)
                                || v65 >= 0x11
                                && v104[8]
                                && (v502 < 5 || v502 - 4 < (flatbuffers::Table *)((char *)v484 + v104[8]) - v501))))
                            {
                              goto LABEL_18;
                            }
                          }
LABEL_267:
                          LODWORD(v503) = v503 - 1;
                          v60 = v432 + 1;
                          v439 += 4;
                          v436 += 4;
                          if (v432 + 1 >= (unint64_t)*v429)
                            goto LABEL_268;
                        }
                        if (v62 < 5)
                          goto LABEL_147;
LABEL_142:
                        v63 = 0;
                        goto LABEL_143;
                      }
                    }
                  }
                }
              }
LABEL_268:
              if (!flatbuffers::Table::VerifyOffset(v488, (const flatbuffers::Verifier *)&v501, 0xAu))
                goto LABEL_18;
              v105 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
              if (*v105 >= 0xBu)
              {
                v106 = v105[5];
                if (v106)
                {
                  if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v488 + v106 + *(unsigned int *)((char *)v488 + v106), 4uLL, 0))goto LABEL_18;
                  v107 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
                  if (*v107 >= 0xBu)
                  {
                    v108 = v107[5];
                    if (v108)
                    {
                      v109 = (flatbuffers::Table *)*(unsigned int *)((char *)v488 + v108);
                      v415 = (char *)v488 + v108;
                      if (*(_DWORD *)((char *)v109 + (_QWORD)v488 + v108))
                      {
                        v430 = 0;
                        v440 = &src[(_QWORD)v471 + v108];
                        v110 = &src[v108];
                        v111 = (flatbuffers::Table *)&v110[(_QWORD)obj];
                        v437 = (char *)&v110[(_QWORD)v478];
                        v485 = v109;
                        do
                        {
                          v489 = v111;
                          v112 = (char *)v109 + (_QWORD)v111;
                          srca = (_BYTE *)*(unsigned int *)((char *)v109 + (_QWORD)v111);
                          v433 = (unsigned __int8 *)v109 + (_QWORD)v111 + (unint64_t)srca;
                          if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, v433))
                            goto LABEL_18;
                          v425 = (flatbuffers::Table *)*(int *)((char *)v489 + (unint64_t)&srca[(_QWORD)v485]);
                          v445 = srca - (_BYTE *)v425;
                          v113 = *(unsigned __int16 *)&v112[srca - (_BYTE *)v425];
                          if (v113 >= 5
                            && *(_WORD *)((char *)v485 + (_QWORD)v489 + v445 + 4)
                            && (v502 < 2
                             || (const unsigned __int8 *)(v502 - 1) < &v440[(_QWORD)v485
                                                                          + &srca[*(unsigned __int16 *)((char *)v485 + (_QWORD)v489 + v445 + 4)]
                                                                          - (_BYTE *)v501]))
                          {
                            goto LABEL_18;
                          }
                          if (!flatbuffers::Table::VerifyOffset((flatbuffers::Table *)v433, (const flatbuffers::Verifier *)&v501, 6u))goto LABEL_18;
                          if (v113 < 7)
                          {
                            if (v113 < 5)
                              goto LABEL_297;
                            v117 = 0;
                            v114 = v485;
                            v115 = v489;
                          }
                          else
                          {
                            v114 = v485;
                            v115 = v489;
                            if (*(_WORD *)((char *)v485 + (_QWORD)v489 + v445 + 6))
                            {
                              v116 = &srca[*(unsigned __int16 *)((char *)v485 + (_QWORD)v489 + v445 + 6)];
                              v117 = (flatbuffers::Table *)((char *)v485
                                                          + (_QWORD)v489
                                                          + (unint64_t)&v116[*(unsigned int *)((char *)v489 + (unint64_t)&v116[(_QWORD)v485])]);
                            }
                            else
                            {
                              v117 = 0;
                            }
                          }
                          v118 = -(uint64_t)v425;
                          if (*(_WORD *)((char *)v114 + (_QWORD)v115 + v445 + 4)
                            && v117
                            && *((_BYTE *)v115
                               + (unint64_t)&srca[*(unsigned __int16 *)((char *)v114 + (_QWORD)v115 + v445 + 4)
                                                       + (_QWORD)v114]) == 1)
                          {
                            if (!FlatbufferSymbols::DyldSharedCacheMetadata::Verify(v117, (flatbuffers::Verifier *)&v501))goto LABEL_18;
                            v119 = *(int *)((char *)v489 + (unint64_t)&srca[(_QWORD)v485]);
                            v118 = -v119;
                            v113 = *(unsigned __int16 *)((char *)v489 + (unint64_t)&srca[(_QWORD)v485 - v119]);
                          }
                          if (v113 >= 9)
                          {
                            v120 = *(unsigned __int16 *)&v437[(unint64_t)&srca[v118 + (_QWORD)v485]];
                            if (v120)
                            {
                              if (v502 < 9
                                || (const unsigned __int8 *)(v502 - 8) < &v440[(_QWORD)v485
                                                                             + &srca[v120]
                                                                             - (_BYTE *)v501])
                              {
                                goto LABEL_18;
                              }
                            }
                          }
LABEL_297:
                          LODWORD(v503) = v503 - 1;
                          v109 = v485;
                          v440 += 4;
                          v111 = (flatbuffers::Table *)((char *)v489 + 4);
                          v437 += 4;
                          ++v430;
                        }
                        while (v430 < *(unsigned int *)((char *)v485 + (_QWORD)v415));
                      }
                    }
                  }
                }
              }
              LODWORD(v503) = v503 - 1;
              v32 = v455 + 1;
              v475 += 4;
              v478 += 4;
              obj = (char *)obj + 4;
              v471 += 4;
            }
            while (v455 + 1 < (unint64_t)LODWORD(log->isa));
          }
        }
      }
    }
  }
  if (!flatbuffers::Table::VerifyOffset((flatbuffers::Table *)&v18[v25], (const flatbuffers::Verifier *)&v501, 6u))
    goto LABEL_18;
  v121 = &v26[-*(int *)v26];
  if (*(unsigned __int16 *)v121 >= 7u)
  {
    v122 = *((unsigned __int16 *)v121 + 3);
    if (v122)
    {
      if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, &v26[v122 + *(unsigned int *)&v26[v122]], 4uLL, 0))goto LABEL_18;
      v123 = &v26[-*(int *)v26];
      if (*(unsigned __int16 *)v123 >= 7u)
      {
        v124 = *((unsigned __int16 *)v123 + 3);
        if (v124)
        {
          v125 = *(unsigned int *)&v26[v124];
          v472 = &v26[v124];
          if (*(_DWORD *)&v26[v124 + v125])
          {
            v479 = 0;
            v486 = (flatbuffers::Table *)&v18[v25 + 4 + v124];
            v126 = &v26[v124];
            v490 = (flatbuffers::Table *)*(unsigned int *)&v26[v124];
            do
            {
              v127 = &v126[v125];
              v128 = *(unsigned int *)&v126[v125 + 4];
              v129 = (unsigned __int8 *)&v126[v125 + 4 + v128];
              if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, v129))
                goto LABEL_18;
              v476 = v128 - *(int *)&v127[v128 + 4];
              v130 = *(unsigned __int16 *)&v127[v476 + 4];
              if (v130 >= 5
                && *(_WORD *)((char *)v490 + (_QWORD)v126 + v476 + 8)
                && (v502 < 5
                 || (flatbuffers::Table *)(v502 - 4) < (flatbuffers::Table *)((char *)v486
                                                                            + (_QWORD)v490
                                                                            + v128
                                                                            + *(unsigned __int16 *)((char *)v490
                                                                                                  + (_QWORD)v126
                                                                                                  + v476
                                                                                                  + 8)
                                                                            - (unint64_t)v501)))
              {
                goto LABEL_18;
              }
              if (!flatbuffers::Table::VerifyOffset((flatbuffers::Table *)v129, (const flatbuffers::Verifier *)&v501, 6u))goto LABEL_18;
              if (v130 >= 7 && *(_WORD *)((char *)v490 + (_QWORD)v126 + v476 + 10))
              {
                v131 = v128 + *(unsigned __int16 *)((char *)v490 + (_QWORD)v126 + v476 + 10);
                v132 = (const unsigned __int8 *)v490
                     + (_QWORD)v126
                     + v131
                     + *(unsigned int *)((char *)v490 + (_QWORD)v126 + v131 + 4)
                     + 4;
              }
              else
              {
                v132 = 0;
              }
              if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v132))
                goto LABEL_18;
              LODWORD(v503) = v503 - 1;
              v125 = (unint64_t)v490;
              ++v479;
              v486 = (flatbuffers::Table *)((char *)v486 + 4);
              v126 += 4;
            }
            while (v479 < *(unsigned int *)((char *)v490 + (_QWORD)v472));
          }
        }
      }
    }
  }
  LODWORD(v503) = v503 - 1;
  v133 = (unsigned int *)objc_msgSend(objc_retainAutorelease(v17), "bytes");
  v134 = *v133;
  v135 = *(unsigned __int16 *)((char *)v133 + v134 - *(int *)((char *)v133 + v134) + 4);
  v136 = (unsigned int *)((char *)v133 + v134 + v135);
  v137 = *v136;
  v138 = (unsigned int *)((char *)v136 + v137);
  v140 = v138 + 1;
  v139 = *v138;
  if (!(_DWORD)v139)
    goto LABEL_26;
  srcb = v8 + 288;
  v487 = (flatbuffers::Table *)((char *)v133 + v135 + v134 + v137);
  v477 = &v140[v139];
  v480 = v138 + 3;
  while (1)
  {
    v141 = *v140;
    v142 = *(int *)((char *)v140 + v141);
    v143 = -v142;
    v491 = (flatbuffers::Table *)((char *)v140 + v141);
    v144 = (unsigned __int16 *)((char *)v140 + v141 - v142);
    v145 = *v144;
    if (v145 >= 5)
    {
      if (v144[2])
      {
        if (v145 >= 7 && *((_BYTE *)v491 + v144[2]) == 1)
        {
          v147 = v144[3];
          if (v147)
            break;
        }
      }
    }
LABEL_498:
    v270 = (unsigned __int16 *)((char *)v491 + v143);
    v271 = *v270;
    if (v271 < 5 || !v270[2])
      goto LABEL_516;
    if (v271 < 7 || *((_BYTE *)v491 + v270[2]) != 3)
      goto LABEL_516;
    v273 = v270[3];
    if (!v273)
      goto LABEL_516;
    v274 = (int *)((char *)v491 + v273 + *(unsigned int *)((char *)v491 + v273));
    v275 = (unsigned __int16 *)((char *)v274 - *v274);
    if (*v275 >= 5u)
    {
      v276 = v275[2];
      if (v276)
      {
        v277 = (char *)v274 + v276 + *(unsigned int *)((char *)v274 + v276);
        memset(uu, 0, sizeof(uu));
        uuid_parse(v277 + 4, uu);
        if (uuid_is_null(uu))
        {
          if (_MergedGlobals_4[0] == 1)
          {
            v278 = *__error();
            _sa_logt();
            v279 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
            {
              v316 = v274;
              objc_msgSend(v8, "name");
              v317 = (void *)objc_claimAutoreleasedReturnValue();
              v318 = objc_msgSend(v8, "pid");
              v319 = (unsigned __int16 *)((char *)v316 - *v316);
              if (*v319 < 5u)
              {
                v320 = 0;
              }
              else
              {
                v320 = v319[2];
                if (v320)
                  v320 += (uint64_t)v316 + *(unsigned int *)((char *)v316 + v320);
              }
              *(_DWORD *)buf = 138412802;
              *(_QWORD *)&buf[4] = v317;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v318;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v320 + 4;
              _os_log_debug_impl(&dword_1B9BE0000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %{public}s with empty uuid", buf, 0x1Cu);

            }
LABEL_515:

            *__error() = v278;
            goto LABEL_516;
          }
          goto LABEL_516;
        }
        v280 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
        if (*v280 < 9u || (v281 = v280[4]) == 0)
        {
          if (_MergedGlobals_4[0] != 1)
            goto LABEL_516;
          v278 = *__error();
          _sa_logt();
          v279 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
          {
            v323 = v274;
            objc_msgSend(v8, "name");
            v324 = (void *)objc_claimAutoreleasedReturnValue();
            v325 = objc_msgSend(v8, "pid");
            v326 = (unsigned __int16 *)((char *)v323 - *v323);
            if (*v326 < 5u)
            {
              v327 = 0;
            }
            else
            {
              v327 = v326[2];
              if (v327)
                v327 += (uint64_t)v323 + *(unsigned int *)((char *)v323 + v327);
            }
            *(_DWORD *)buf = 138412802;
            *(_QWORD *)&buf[4] = v324;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v325;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v327 + 4;
            _os_log_debug_impl(&dword_1B9BE0000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %{public}s with no symbol owners", buf, 0x1Cu);

          }
          goto LABEL_515;
        }
        if (!*(_DWORD *)((char *)v491 + v281 + *(unsigned int *)((char *)v491 + v281)))
        {
          if (_MergedGlobals_4[0] != 1)
            goto LABEL_516;
          v294 = v274;
          v278 = *__error();
          _sa_logt();
          v279 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
          {
            objc_msgSend(v8, "name");
            v342 = (void *)objc_claimAutoreleasedReturnValue();
            v343 = objc_msgSend(v8, "pid");
            v344 = (unsigned __int16 *)((char *)v294 - *v294);
            if (*v344 < 5u)
            {
              v345 = 0;
            }
            else
            {
              v345 = v344[2];
              if (v345)
                v345 += (uint64_t)v294 + *(unsigned int *)((char *)v294 + v345);
            }
            *(_DWORD *)buf = 138412802;
            *(_QWORD *)&buf[4] = v342;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v343;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v345 + 4;
            _os_log_debug_impl(&dword_1B9BE0000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %{public}s with zero symbol owners", buf, 0x1Cu);

          }
          goto LABEL_515;
        }
        v458 = v274;
        v447 = v140;
        v495 = 0u;
        v496 = 0u;
        v493 = 0u;
        v494 = 0u;
        objc_msgSend(*(id *)(a1 + 32), "sharedCaches");
        objc = (id)objc_claimAutoreleasedReturnValue();
        v282 = objc_msgSend(objc, "countByEnumeratingWithState:objects:count:", &v493, v506, 16);
        if (v282)
        {
          v474 = 0;
          v283 = *(_QWORD *)v494;
          do
          {
            for (i = 0; i != v282; ++i)
            {
              if (*(_QWORD *)v494 != v283)
                objc_enumerationMutation(objc);
              v285 = *(void **)(*((_QWORD *)&v493 + 1) + 8 * i);
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = 0;
              objc_msgSend(v285, "uuid");
              v286 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v286, "getUUIDBytes:", buf);

              if (!uuid_compare(buf, uu))
              {
                v287 = v285;

                v474 = v287;
              }
            }
            v282 = objc_msgSend(objc, "countByEnumeratingWithState:objects:count:", &v493, v506, 16);
          }
          while (v282);

          if (v474)
          {
            objc_msgSend(v474, "binaryLoadInfos");
            v288 = (void *)objc_claimAutoreleasedReturnValue();
            v289 = objc_msgSend(v288, "count") == 0;

            if (!v289)
            {
              if (_MergedGlobals_4[0] == 1)
              {
                v290 = *__error();
                _sa_logt();
                v291 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v291, OS_LOG_TYPE_DEBUG))
                {
                  objc_msgSend(v8, "name");
                  v357 = (void *)objc_claimAutoreleasedReturnValue();
                  v358 = objc_msgSend(v8, "pid");
                  objc_msgSend(v474, "debugDescription");
                  v359 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 138412802;
                  *(_QWORD *)&buf[4] = v357;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v358;
                  *(_WORD *)&buf[18] = 2112;
                  *(_QWORD *)&buf[20] = v359;
                  _os_log_debug_impl(&dword_1B9BE0000, v291, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Already have load infos for %@", buf, 0x1Cu);

                }
                *__error() = v290;
              }
LABEL_570:

              v140 = v447;
              goto LABEL_516;
            }
            v295 = 0;
LABEL_544:
            v296 = objc_msgSend(v474, "slide");
            if ((v295 & 1) != 0 || objc_msgSend(v474, "slidBaseAddress") == -1)
            {
              v304 = (unsigned __int16 *)((char *)v458 - *v458);
              if (*v304 >= 0x15u && (v305 = v304[10]) != 0)
              {
                v306 = *(_QWORD *)((char *)v458 + v305);
                if (v306 == -1)
                  v297 = -1;
                else
                  v297 = v306 + v296;
              }
              else
              {
                v297 = -1;
              }
            }
            else
            {
              v297 = objc_msgSend(v474, "slidBaseAddress");
              v298 = (unsigned __int16 *)((char *)v458 - *v458);
              if (*v298 >= 0x15u)
              {
                v299 = v298[10];
                if (v299)
                {
                  v300 = *(_QWORD *)((char *)v458 + v299);
                  if (v300 != -1)
                  {
                    v301 = objc_msgSend(v474, "slidBaseAddress");
                    if (v300 != objc_msgSend(v474, "slide") + v301)
                    {
                      v302 = *__error();
                      _sa_logt();
                      v303 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v303, OS_LOG_TYPE_FAULT))
                      {
                        objc_msgSend(v474, "debugDescription");
                        v363 = objc_claimAutoreleasedReturnValue();
                        v364 = (void *)v363;
                        v365 = (unsigned __int16 *)((char *)v458 - *v458);
                        if (*v365 >= 0x15u && (v366 = v365[10]) != 0)
                          v367 = *(_QWORD *)((char *)v458 + v366);
                        else
                          v367 = -1;
                        *(_DWORD *)buf = 138412546;
                        *(_QWORD *)&buf[4] = v363;
                        *(_WORD *)&buf[12] = 2048;
                        *(_QWORD *)&buf[14] = v367;
                        _os_log_fault_impl(&dword_1B9BE0000, v303, OS_LOG_TYPE_FAULT, "SAKTSYM kt says shared cache %@ has unslid base address 0x%llx", buf, 0x16u);

                      }
                      *__error() = v302;
                    }
                  }
                }
              }
            }
            v307 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
            if (*v307 >= 9u && (v308 = v307[4]) != 0)
              v309 = (unsigned int *)((char *)v491 + v308 + *(unsigned int *)((char *)v491 + v308));
            else
              v309 = 0;
            -[SASampleStore loadInfosForKTSymbolOwners:isKernelSpace:excludeRange:](*(_QWORD *)(a1 + 32), v309, 0, 0, 0);
            v310 = (void *)objc_claimAutoreleasedReturnValue();
            if (objc_msgSend(v310, "count"))
            {
              uuidForBytes((uint64_t)uu);
              v311 = (void *)objc_claimAutoreleasedReturnValue();
              +[SASharedCache applyBinaryLoadInfos:sharedCacheUUID:slide:slidBaseAddress:]((uint64_t)SASharedCache, v310, v311, objc_msgSend(v474, "slide"), v297);

              if (_MergedGlobals_4[0] == 1)
              {
                v312 = *__error();
                _sa_logt();
                v313 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v313, OS_LOG_TYPE_DEBUG))
                {
                  objc_msgSend(v8, "name");
                  objd = (id)objc_claimAutoreleasedReturnValue();
                  v346 = objc_msgSend(v8, "pid");
                  v347 = (unsigned __int16 *)((char *)v458 - *v458);
                  if (*v347 >= 5u && (v348 = v347[2]) != 0)
                    v349 = (char *)v458 + v348 + *(unsigned int *)((char *)v458 + v348);
                  else
                    v349 = 0;
                  v361 = objc_msgSend(v310, "count");
                  v362 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
                  LODWORD(v362) = *(unsigned int *)((char *)v362 + *v362);
                  *(_DWORD *)buf = 138413314;
                  *(_QWORD *)&buf[4] = objd;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v346;
                  *(_WORD *)&buf[18] = 2080;
                  *(_QWORD *)&buf[20] = v349 + 4;
                  v509 = 2048;
                  v510 = v361;
                  v511 = 1024;
                  LODWORD(v512) = (_DWORD)v362;
                  _os_log_debug_impl(&dword_1B9BE0000, v313, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] shared cache %s: added %lu load infos from %d symbol owners", buf, 0x2Cu);

                }
                *__error() = v312;
              }
            }
            else if (_MergedGlobals_4[0] == 1)
            {
              v314 = *__error();
              _sa_logt();
              v315 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v315, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v8, "name");
                v353 = (void *)objc_claimAutoreleasedReturnValue();
                v354 = objc_msgSend(v8, "pid");
                v355 = (unsigned __int16 *)((char *)v458 - *v458);
                if (*v355 < 5u)
                {
                  v356 = 0;
                }
                else
                {
                  v356 = v355[2];
                  if (v356)
                    v356 += (uint64_t)v458 + *(unsigned int *)((char *)v458 + v356);
                }
                v360 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
                LODWORD(v360) = *(unsigned int *)((char *)v360 + *v360);
                *(_DWORD *)buf = 138413058;
                *(_QWORD *)&buf[4] = v353;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v354;
                *(_WORD *)&buf[18] = 2080;
                *(_QWORD *)&buf[20] = v356 + 4;
                v509 = 1024;
                LODWORD(v510) = (_DWORD)v360;
                _os_log_debug_impl(&dword_1B9BE0000, v315, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] shared cache %s: no load infos from %d symbol owners", buf, 0x22u);

              }
              *__error() = v314;
            }

            goto LABEL_570;
          }
        }
        else
        {

        }
        v474 = 0;
        v295 = 1;
        goto LABEL_544;
      }
    }
    if (_MergedGlobals_4[0] == 1)
    {
      v278 = *__error();
      _sa_logt();
      v279 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v8, "name");
        v292 = (void *)objc_claimAutoreleasedReturnValue();
        v293 = objc_msgSend(v8, "pid");
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v292;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v293;
        _os_log_debug_impl(&dword_1B9BE0000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache with no UUID", buf, 0x12u);

      }
      goto LABEL_515;
    }
LABEL_516:
    ++v140;
    ++v480;
    v487 = (flatbuffers::Table *)((char *)v487 + 4);
    if (v140 == v477)
      goto LABEL_26;
  }
  v148 = (int *)((char *)v491 + v147 + *(unsigned int *)((char *)v491 + v147));
  v149 = (unsigned __int16 *)((char *)v148 - *v148);
  if (*v149 < 7u || (v150 = v149[3]) == 0 || (v151 = *(_QWORD *)((char *)v148 + v150), v151 == -1))
  {
    if (_MergedGlobals_4[0] == 1)
    {
      v162 = *__error();
      _sa_logt();
      v163 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v8, "name");
        v223 = (void *)objc_claimAutoreleasedReturnValue();
        v224 = objc_msgSend(v8, "pid");
        v225 = (unsigned __int16 *)((char *)v148 - *v148);
        if (*v225 < 5u)
        {
          v226 = 0;
        }
        else
        {
          v226 = v225[2];
          if (v226)
            v226 += (uint64_t)v148 + *(unsigned int *)((char *)v148 + v226);
        }
        *(_DWORD *)buf = 138412802;
        *(_QWORD *)&buf[4] = v223;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v224;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v226 + 4;
        _os_log_debug_impl(&dword_1B9BE0000, v163, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] process %s missing pid", buf, 0x1Cu);

      }
      *__error() = v162;
    }
    goto LABEL_516;
  }
  if (objc_msgSend(v8, "pid") == (_DWORD)v151)
  {
    v152 = (unsigned __int16 *)((char *)v148 - *v148);
    if (*v152 >= 0xBu && (v153 = v152[5]) != 0)
    {
      v154 = (char *)v148 + v153 + *(unsigned int *)((char *)v148 + v153);
      memset(uu, 0, sizeof(uu));
      uuid_parse(v154 + 4, uu);
      uuidForBytes((uint64_t)uu);
      v473 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "mainBinary");
      v155 = (void *)objc_claimAutoreleasedReturnValue();
      v156 = v155 == 0;

      if (!v156)
      {
        objc_msgSend(v8, "mainBinary");
        v157 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v157, "uuid");
        v158 = (void *)objc_claimAutoreleasedReturnValue();
        v159 = objc_msgSend(v158, "isEqual:", v473);

        if ((v159 & 1) == 0)
        {
          v160 = *__error();
          _sa_logt();
          v161 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT))
          {
            objc_msgSend(v8, "name");
            v492 = (flatbuffers::Table *)objc_claimAutoreleasedReturnValue();
            v330 = objc_msgSend(v8, "pid");
            objc_msgSend(v8, "mainBinary");
            obje = (id)objc_claimAutoreleasedReturnValue();
            objc_msgSend(obje, "debugDescription");
            v331 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138413058;
            *(_QWORD *)&buf[4] = v492;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v330;
            *(_WORD *)&buf[18] = 2112;
            *(_QWORD *)&buf[20] = v473;
            v509 = 2112;
            v510 = (uint64_t)v331;
            _os_log_fault_impl(&dword_1B9BE0000, v161, OS_LOG_TYPE_FAULT, "SAKTSYM %@ [%d] Mismatched main binary %@ with existing %@", buf, 0x26u);

          }
          *__error() = v160;

          goto LABEL_516;
        }
      }
    }
    else
    {
      v473 = 0;
    }
    v446 = v140;
    v164 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
    if (*v164 >= 0xBu && (v165 = v164[5]) != 0)
    {
      v166 = *(unsigned int *)((char *)v491 + v165);
      v167 = *(unsigned int *)((char *)v491 + v165 + v166);
      if ((_DWORD)v167)
      {
        v168 = 0;
        obja = (id)(4 * v167);
        v169 = (char *)v487 + v141 + v166 + v165;
        v416 = (char *)v480 + v141 + v165 + v166;
        loga = 1;
        while (1)
        {
          v170 = *(unsigned int *)((char *)v168 + (_QWORD)v169 + 8);
          v171 = (char *)v168 + (_QWORD)v169 + v170;
          v172 = v170 - *((int *)v171 + 2);
          v173 = (char *)v168 + v172 + (_QWORD)v169;
          v174 = *((unsigned __int16 *)v173 + 4);
          if (v174 >= 5)
          {
            v175 = *((unsigned __int16 *)v173 + 6);
            if (v175)
            {
              v176 = v169[v170 + 8 + v175 + (_QWORD)v168];
              v177 = v174 >= 7 && v176 == 1;
              if (v177 && *(_WORD *)((char *)v168 + v172 + (_QWORD)v169 + 14))
                break;
            }
          }
          if (_MergedGlobals_4[0] == 1)
          {
            v189 = *__error();
            _sa_logt();
            v190 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
            {
              objc_msgSend(v8, "name");
              v192 = (void *)objc_claimAutoreleasedReturnValue();
              v193 = objc_msgSend(v8, "pid");
              *(_DWORD *)buf = 138412546;
              *(_QWORD *)&buf[4] = v192;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v193;
              _os_log_debug_impl(&dword_1B9BE0000, v190, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No shared cache metadata", buf, 0x12u);

            }
            goto LABEL_368;
          }
LABEL_370:
          v168 = (char *)v168 + 4;
          if (obja == v168)
            goto LABEL_406;
        }
        v456 = *(unsigned __int16 *)((char *)v168 + v172 + (_QWORD)v169 + 14);
        v178 = *(unsigned int *)&v169[v170 + 8 + v456 + (_QWORD)v168];
        v179 = v170 + v456 + v178;
        v180 = *(int *)((char *)v168 + (_QWORD)v169 + v179 + 8);
        v181 = (char *)v168 + (_QWORD)v169 + v179 - v180;
        v182 = *((unsigned __int16 *)v181 + 4);
        if (v182 >= 5 && *((_WORD *)v181 + 6))
        {
          v422 = *(unsigned int *)&v169[v170 + 8 + v456 + v178 + (_QWORD)v168 + *((unsigned __int16 *)v181 + 6)];
          v426 = (flatbuffers::Table *)*((unsigned __int16 *)v181 + 6);
          if (v174 <= 8
            || (v183 = *(unsigned __int16 *)((char *)v168 + v172 + (_QWORD)v169 + 16)) == 0
            || (v184 = *(_QWORD *)&v169[v170 + 8 + v183 + (_QWORD)v168], v184 == -1))
          {
            if (_MergedGlobals_4[0] == 1)
            {
              v194 = *(unsigned int *)&v169[v170 + 8 + v456 + (_QWORD)v168];
              v195 = *__error();
              _sa_logt();
              v412 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v412, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v8, "name");
                oslogc = (os_log_t)objc_claimAutoreleasedReturnValue();
                v203 = objc_msgSend(v8, "pid");
                *(_DWORD *)buf = 138412802;
                *(_QWORD *)&buf[4] = oslogc;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v203;
                *(_WORD *)&buf[18] = 2080;
                *(_QWORD *)&buf[20] = (char *)v168 + (_QWORD)v416 + (unint64_t)v426 + v170 + v456 + v194 + v422;
                _os_log_debug_impl(&dword_1B9BE0000, v412, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %s with no slide", buf, 0x1Cu);

              }
              *__error() = v195;
            }
            goto LABEL_370;
          }
          v411 = *(unsigned int *)&v169[v170 + 8 + v456 + (_QWORD)v168];
          if (v182 < 0x15
            || (v185 = v170 + v456 + v178,
                (v186 = *(unsigned __int16 *)((char *)v168 + (_QWORD)v169 + v185 - v180 + 28)) == 0)
            || (v187 = *(_QWORD *)&v169[v185 + 8 + (_QWORD)v168 + v186], v187 == -1))
          {
            if (_MergedGlobals_4[0] == 1)
            {
              v196 = *__error();
              _sa_logt();
              osloga = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(osloga, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v8, "name");
                v405 = (void *)objc_claimAutoreleasedReturnValue();
                v207 = objc_msgSend(v8, "pid");
                v208 = &v169[v170 - *((int *)v171 + 2) + (_QWORD)v168];
                if (*((unsigned __int16 *)v208 + 4) >= 9u && (v209 = *((unsigned __int16 *)v208 + 8)) != 0)
                  v210 = *(_QWORD *)&v169[v170 + 8 + v209 + (_QWORD)v168];
                else
                  v210 = -1;
                *(_DWORD *)buf = 138413058;
                *(_QWORD *)&buf[4] = v405;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v207;
                *(_WORD *)&buf[18] = 2080;
                *(_QWORD *)&buf[20] = (char *)v168 + (_QWORD)v416 + (unint64_t)v426 + v170 + v456 + v411 + v422;
                v509 = 2048;
                v510 = v210;
                _os_log_debug_impl(&dword_1B9BE0000, osloga, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %s with slide 0x%llx has no unslid base address", buf, 0x26u);

              }
              *__error() = v196;
            }
            v188 = -1;
          }
          else
          {
            v188 = v187 + v184;
          }
          oslogb = (os_log_t)v188;
          if ((loga & 1) != 0)
          {
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = 0;
            uuid_parse(&v169[(unint64_t)v426 + v170 + v456 + v411 + (_QWORD)v168 + 12 + v422], buf);
            v197 = &v169[v170 - *((int *)v171 + 2) + (_QWORD)v168];
            if (*((unsigned __int16 *)v197 + 4) >= 9u && (v198 = *((unsigned __int16 *)v197 + 8)) != 0)
              v199 = *(_QWORD *)&v169[v170 + 8 + v198 + (_QWORD)v168];
            else
              v199 = -1;
            v200 = -[SASampleStore applySharedCacheToTask:uuid:slide:slidBaseAddress:](*(_QWORD *)(a1 + 32), v8, (uint64_t)buf, v199, (uint64_t)oslogb);
            loga = 0;
            goto LABEL_370;
          }
          v189 = *__error();
          _sa_logt();
          logb = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(logb, OS_LOG_TYPE_FAULT))
          {
            objc_msgSend(v8, "name");
            v404 = (void *)objc_claimAutoreleasedReturnValue();
            v401 = objc_msgSend(v8, "pid");
            v204 = &v169[v170 - *((int *)v171 + 2) + (_QWORD)v168];
            if (*((unsigned __int16 *)v204 + 4) >= 9u && (v205 = *((unsigned __int16 *)v204 + 8)) != 0)
              v206 = *(_QWORD *)&v169[v170 + 8 + v205 + (_QWORD)v168];
            else
              v206 = -1;
            objc_msgSend(v8, "sharedCache");
            v402 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v402, "debugDescription");
            v211 = objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138413570;
            *(_QWORD *)&buf[4] = v404;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v401;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = (char *)v168 + (_QWORD)v416 + (unint64_t)v426 + v170 + v456 + v411 + v422;
            v509 = 2048;
            v510 = v206;
            v511 = 2048;
            v512 = oslogb;
            v513 = 2112;
            v212 = (void *)v211;
            v514 = v211;
            _os_log_fault_impl(&dword_1B9BE0000, logb, OS_LOG_TYPE_FAULT, "SAKTSYM %@ [%d] Ignoring second shared cache %s slide 0x%llx slideBaseAddress 0x%llx (existing %@)", buf, 0x3Au);

          }
          v191 = __error();
          loga = 0;
        }
        else
        {
          if (_MergedGlobals_4[0] != 1)
            goto LABEL_370;
          v189 = *__error();
          _sa_logt();
          v190 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
          {
            objc_msgSend(v8, "name");
            v201 = (void *)objc_claimAutoreleasedReturnValue();
            v202 = objc_msgSend(v8, "pid");
            *(_DWORD *)buf = 138412546;
            *(_QWORD *)&buf[4] = v201;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v202;
            _os_log_debug_impl(&dword_1B9BE0000, v190, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No shared cache UUID", buf, 0x12u);

          }
LABEL_368:

          v191 = __error();
        }
        *v191 = v189;
        goto LABEL_370;
      }
    }
    else if (_MergedGlobals_4[0] == 1)
    {
      v213 = *__error();
      _sa_logt();
      v214 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v214, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v8, "name");
        v227 = (void *)objc_claimAutoreleasedReturnValue();
        v228 = objc_msgSend(v8, "pid");
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v227;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v228;
        _os_log_debug_impl(&dword_1B9BE0000, v214, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No shared cache", buf, 0x12u);

      }
      *__error() = v213;
    }
LABEL_406:
    objc_copyStruct(buf, srcb, 8, 1, 0);
    if (!*(_QWORD *)buf)
    {
      v215 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
      v216 = *v215;
      if (v216 >= 5)
      {
        if (v215[2])
        {
          if (v216 >= 7 && *((_BYTE *)v491 + v215[2]) == 2)
          {
            v218 = v215[3];
            if (v218)
            {
              v219 = (int *)((char *)v491 + v218 + *(unsigned int *)((char *)v491 + v218));
              v220 = (unsigned __int16 *)((char *)v219 - *v219);
              v221 = *v220;
              if (v221 < 0xD)
              {
                v222 = 0;
              }
              else
              {
                v222 = (int *)v220[6];
                if (v220[6])
                  v222 = (int *)((char *)v222 + (_QWORD)v219 + *(unsigned int *)((char *)v222 + (_QWORD)v219));
              }
              v229 = (unsigned __int16 *)((char *)v222 - *v222);
              if (*v229 >= 7u && (v230 = v229[3]) != 0)
                v231 = *(unsigned int *)((char *)v222 + v230);
              else
                v231 = 0;
              if (v221 >= 0xD && (v232 = v220[6]) != 0)
                v233 = (int *)((char *)v219 + v232 + *(unsigned int *)((char *)v219 + v232));
              else
                v233 = 0;
              v234 = (unsigned __int16 *)((char *)v233 - *v233);
              if (*v234 >= 9u && (v235 = v234[4]) != 0)
                v236 = *(int *)((char *)v233 + v235);
              else
                v236 = 0;
              *(_QWORD *)buf = v231 | ((unint64_t)(v236 & 0xFFFFFF) << 32);
              objc_copyStruct(srcb, buf, 8, 1, 0);
              if (_MergedGlobals_4[0] == 1)
              {
                v237 = *__error();
                _sa_logt();
                v238 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v238, OS_LOG_TYPE_DEBUG))
                {
                  objc_msgSend(v8, "name");
                  v350 = (void *)objc_claimAutoreleasedReturnValue();
                  v351 = objc_msgSend(v8, "pid");
                  objc_copyStruct(uu, srcb, 8, 1, 0);
                  FamilyName = CSArchitectureGetFamilyName();
                  *(_DWORD *)buf = 138412802;
                  *(_QWORD *)&buf[4] = v350;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v351;
                  *(_WORD *)&buf[18] = 2082;
                  *(_QWORD *)&buf[20] = FamilyName;
                  _os_log_debug_impl(&dword_1B9BE0000, v238, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Applied architecture %{public}s", buf, 0x1Cu);

                }
                *__error() = v237;
              }
            }
          }
        }
      }
    }
    v239 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
    if (*v239 < 9u || !v239[4])
    {
      if (_MergedGlobals_4[0] == 1)
      {
        v245 = *__error();
        _sa_logt();
        v246 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v246, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(v8, "name");
          v321 = (void *)objc_claimAutoreleasedReturnValue();
          v322 = objc_msgSend(v8, "pid");
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v321;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v322;
          _os_log_debug_impl(&dword_1B9BE0000, v246, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No symbol owners", buf, 0x12u);

        }
        v247 = 0;
        *__error() = v245;
      }
      else
      {
        v247 = 0;
      }
      goto LABEL_479;
    }
    objc_msgSend(v8, "sharedCache");
    v240 = (void *)objc_claimAutoreleasedReturnValue();
    v241 = v240;
    v423 = v240;
    if (!v240 || objc_msgSend(v240, "startAddress") == -1)
    {
      v242 = 0;
      v244 = 0;
    }
    else
    {
      v242 = objc_msgSend(v241, "startAddress");
      v243 = objc_msgSend(v241, "endAddress");
      v244 = v243 - objc_msgSend(v241, "startAddress");
    }
    v247 = v473;
    v248 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
    if (*v248 >= 9u && (v249 = v248[4]) != 0)
      v250 = (unsigned int *)((char *)v491 + v249 + *(unsigned int *)((char *)v491 + v249));
    else
      v250 = 0;
    -[SASampleStore loadInfosForKTSymbolOwners:isKernelSpace:excludeRange:](*(_QWORD *)(a1 + 32), v250, objc_msgSend(v8, "pid") == 0, v242, v244);
    v251 = (flatbuffers::Table *)objc_claimAutoreleasedReturnValue();
    v427 = v251;
    if (-[SATask addImageInfos:]((uint64_t)v8, v251))
    {
      if (_MergedGlobals_4[0])
      {
        v252 = *__error();
        _sa_logt();
        v253 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v253, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(v8, "name");
          v332 = (void *)objc_claimAutoreleasedReturnValue();
          v333 = objc_msgSend(v8, "pid");
          v334 = -[flatbuffers::Table count](v427, "count");
          v335 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
          LODWORD(v335) = *(unsigned int *)((char *)v335 + *v335);
          *(_DWORD *)buf = 138413058;
          *(_QWORD *)&buf[4] = v332;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v333;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v334;
          v509 = 1024;
          LODWORD(v510) = (_DWORD)v335;
          _os_log_debug_impl(&dword_1B9BE0000, v253, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] added %lu load infos from %d symbol owners", buf, 0x22u);

        }
LABEL_463:

        *__error() = v252;
        v247 = v473;
        v251 = v427;
      }
    }
    else if (_MergedGlobals_4[0])
    {
      v252 = *__error();
      _sa_logt();
      v253 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v253, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v8, "name");
        v336 = (void *)objc_claimAutoreleasedReturnValue();
        v337 = objc_msgSend(v8, "pid");
        v338 = -[flatbuffers::Table count](v427, "count");
        v339 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
        LODWORD(v339) = *(unsigned int *)((char *)v339 + *v339);
        *(_DWORD *)buf = 138413058;
        *(_QWORD *)&buf[4] = v336;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v337;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v338;
        v509 = 1024;
        LODWORD(v510) = (_DWORD)v339;
        _os_log_debug_impl(&dword_1B9BE0000, v253, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] %lu load infos from %d symbol owners (nothing new)", buf, 0x22u);

      }
      goto LABEL_463;
    }
    if (v247)
    {
      v499 = 0u;
      v500 = 0u;
      v497 = 0u;
      v498 = 0u;
      logc = v251;
      v254 = -[NSObject countByEnumeratingWithState:objects:count:](logc, "countByEnumeratingWithState:objects:count:", &v497, v507, 16);
      if (v254)
      {
        objb = *(id *)v498;
LABEL_467:
        v457 = v254;
        v255 = 0;
        while (1)
        {
          if (*(id *)v498 != objb)
            objc_enumerationMutation(logc);
          v256 = *(void **)(*((_QWORD *)&v497 + 1) + 8 * v255);
          objc_msgSend(v256, "binary");
          v257 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v257, "uuid");
          v258 = (void *)objc_claimAutoreleasedReturnValue();
          v259 = objc_msgSend(v258, "isEqual:", v473);

          if (v259)
            break;
          if (v457 == ++v255)
          {
            v254 = -[NSObject countByEnumeratingWithState:objects:count:](logc, "countByEnumeratingWithState:objects:count:", &v497, v507, 16);
            if (v254)
              goto LABEL_467;
            goto LABEL_476;
          }
        }
        objc_msgSend(v256, "binary");
        v260 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v260, "path");
        v247 = (void *)objc_claimAutoreleasedReturnValue();

        if ((objc_msgSend(v247, "isAbsolutePath") & 1) != 0)
          goto LABEL_477;

      }
LABEL_476:
      v247 = 0;
LABEL_477:

      v251 = v427;
    }

LABEL_479:
    if (!v473)
    {
      if (_MergedGlobals_4[0] == 1)
      {
        v268 = *__error();
        _sa_logt();
        v269 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v269, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(v8, "name");
          objg = (id)objc_claimAutoreleasedReturnValue();
          v328 = objc_msgSend(v8, "pid");
          objc_msgSend(v8, "mainBinaryLoadInfo");
          v459 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v459, "debugDescription");
          v329 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = objg;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v328;
          *(_WORD *)&buf[18] = 2112;
          *(_QWORD *)&buf[20] = v329;
          _os_log_debug_impl(&dword_1B9BE0000, v269, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No main binary (assuming %@)", buf, 0x1Cu);

        }
        *__error() = v268;
      }
      goto LABEL_497;
    }
    +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v473, v247);
    v261 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v8, "pid"))
    {
      objc_msgSend(v8, "mainBinary");
      v262 = (void *)objc_claimAutoreleasedReturnValue();
      v263 = v262 == 0;

      if (!v263)
      {
        objc_msgSend(v8, "mainBinary");
        v264 = (void *)objc_claimAutoreleasedReturnValue();
        v265 = v264 == v261;

        if (v265)
          goto LABEL_496;
        -[SASampleStore setEndTime:]((uint64_t)v8, v261);
        if (_MergedGlobals_4[0] != 1)
          goto LABEL_496;
        v266 = *__error();
        _sa_logt();
        v267 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v267, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(v8, "name");
          objf = (id)objc_claimAutoreleasedReturnValue();
          v460 = objc_msgSend(v8, "pid");
          objc_msgSend(v261, "debugDescription");
          v340 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = objf;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v460;
          *(_WORD *)&buf[18] = 2112;
          *(_QWORD *)&buf[20] = v340;
          _os_log_debug_impl(&dword_1B9BE0000, v267, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Main binary non-lowest %@", buf, 0x1Cu);

        }
        goto LABEL_495;
      }
      -[SASampleStore setEndTime:]((uint64_t)v8, v261);
      if (_MergedGlobals_4[0] == 1)
      {
        v266 = *__error();
        _sa_logt();
        v267 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v267, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(v8, "name");
          objh = (id)objc_claimAutoreleasedReturnValue();
          v461 = objc_msgSend(v8, "pid");
          objc_msgSend(v261, "debugDescription");
          v341 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = objh;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v461;
          *(_WORD *)&buf[18] = 2112;
          *(_QWORD *)&buf[20] = v341;
          _os_log_debug_impl(&dword_1B9BE0000, v267, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Main binary %@", buf, 0x1Cu);

        }
LABEL_495:

        *__error() = v266;
      }
    }
    else
    {
      -[SASampleStore setEndTime:]((uint64_t)v8, v261);
    }
LABEL_496:

LABEL_497:
    v143 = -(uint64_t)*(int *)v491;
    v140 = v446;
    goto LABEL_498;
  }
  v374 = *__error();
  _sa_logt();
  v375 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v375, OS_LOG_TYPE_ERROR))
  {
    v376 = (unsigned __int16 *)((char *)v148 - *v148);
    if (*v376 >= 7u && (v377 = v376[3]) != 0)
      v378 = *(int *)((char *)v148 + v377);
    else
      v378 = -1;
    objc_msgSend(v8, "debugDescription");
    v379 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v380 = objc_msgSend(v379, "UTF8String");
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v378;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = v380;
    _os_log_error_impl(&dword_1B9BE0000, v375, OS_LOG_TYPE_ERROR, "ktrace flatbuffer returned data for pid %d when asking for %s", buf, 0x12u);

  }
  *__error() = v374;
  v381 = (unsigned __int16 *)((char *)v148 - *v148);
  if (*v381 >= 7u && (v382 = v381[3]) != 0)
    v383 = *(int *)((char *)v148 + v382);
  else
    LOBYTE(v383) = -1;
  objc_msgSend(v8, "debugDescription");
  v384 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  objc_msgSend(v384, "UTF8String");
  _SASetCrashLogMessage(2327, "ktrace flatbuffer returned data for pid %d when asking for %s", v385, v386, v387, v388, v389, v390, v383);

  _os_crash();
  __break(1u);
}

+ (BOOL)canOpenFileAsKTraceFile:(const char *)a3 errorOut:(id *)a4
{
  uint64_t v5;
  __CFString *v6;
  BOOL result;

  if (!ktrace_session_create())
  {
    if (a4)
    {
      v6 = CFSTR("Unable to allocate ktrace_session");
      goto LABEL_7;
    }
    return 0;
  }
  v5 = ktrace_set_file();
  ktrace_session_destroy();
  if ((_DWORD)v5)
  {
    if (a4)
    {
      v6 = (__CFString *)(id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Unable set file as ktrace: %d"), v5);
LABEL_7:
      result = 0;
      *a4 = v6;
      return result;
    }
    return 0;
  }
  return 1;
}

- (BOOL)parseStackshotsFromKTraceFile:(const char *)a3 warningsOut:(id)a4 errorOut:(id *)a5
{
  void **v6;
  char v7;
  id v9;

  v9 = 0;
  if (a5)
    v6 = &v9;
  else
    v6 = 0;
  v7 = -[SASampleStore _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:](self, (uint64_t)a3, 1, a4, v6);
  if (a5)
    *a5 = objc_retainAutorelease(v9);

  return v7;
}

- (uint64_t)_parseKTraceFile:(int)a3 stackshotsOnly:(void *)a4 warningsOut:(void *)a5 errorOut:
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  dispatch_semaphore_t v14;
  uint64_t v15;
  NSObject *v16;
  id v17;
  id v18;
  void *v19;
  id v20;
  void *v21;
  uint64_t v22;
  qos_class_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  char v31;
  NSObject **v32;
  char v33;
  uint64_t v34;
  id v35;
  id v36;
  id v37;
  uint64_t v38;
  uint64_t i;
  id v40;
  int *v41;
  unint64_t v42;
  _DWORD *v43;
  int v44;
  _DWORD *v45;
  void *v46;
  int v47;
  NSObject *v48;
  int v49;
  int v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  NSObject *v55;
  NSObject *v56;
  dispatch_semaphore_t v57;
  id v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t j;
  uint64_t v62;
  void *v63;
  void *v64;
  uint64_t v65;
  qos_class_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  void **v71;
  void *v72;
  void *v73;
  _BOOL4 v74;
  const __CFString *v75;
  void *v76;
  void *v77;
  uint64_t result;
  char v79;
  void *v80;
  BOOL v81;
  void *v82;
  unint64_t v83;
  uint64_t v84;
  void *v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  unint64_t v92;
  double v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  id v99;
  void *v100;
  void *v101;
  unint64_t v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  id v108;
  int v109;
  NSObject *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  NSObject *v118;
  uint64_t v119;
  char v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  NSObject *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  char v138;
  int v139;
  void *v140;
  id v141;
  id v142;
  int v143;
  void **v144;
  _BYTE *v145;
  void *context;
  id v147;
  id v148;
  id obj;
  __int128 v150;
  uint64_t v151;
  void *v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  uint64_t v157;
  uint64_t v158;
  void (*v159)(uint64_t);
  void *v160;
  void *v161;
  id v162;
  _BYTE *v163;
  uint64_t *v164;
  __int128 *v165;
  uint64_t v166;
  char v167;
  uint64_t v168;
  uint64_t v169;
  void (*v170)(uint64_t);
  void *v171;
  _BYTE *v172;
  NSObject *v173;
  id v174;
  _QWORD *v175;
  __int128 *v176;
  uint64_t *v177;
  __int128 *v178;
  uint64_t *v179;
  uint64_t v180;
  char v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t (*v184)(uint64_t);
  void *v185;
  __int128 *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  void (*v190)(_QWORD *);
  void *v191;
  id v192;
  uint64_t *v193;
  _QWORD *v194;
  uint64_t v195;
  uint64_t v196;
  void (*v197)(uint64_t);
  void *v198;
  id v199;
  _QWORD *v200;
  _QWORD v201[4];
  id v202;
  uint64_t *v203;
  uint64_t *v204;
  _QWORD v205[4];
  id v206;
  uint64_t *v207;
  uint64_t v208;
  uint64_t v209;
  void (*v210)(uint64_t);
  void *v211;
  id v212;
  _QWORD *v213;
  uint64_t *v214;
  uint64_t v215;
  uint64_t v216;
  void (*v217)(uint64_t);
  void *v218;
  id v219;
  id v220;
  uint64_t *v221;
  uint64_t v222;
  uint64_t v223;
  void (*v224)(uint64_t);
  void *v225;
  id v226;
  _QWORD *v227;
  uint64_t v228;
  uint64_t v229;
  void (*v230)(_QWORD *);
  void *v231;
  _QWORD *v232;
  id v233;
  uint64_t *v234;
  uint64_t *v235;
  uint64_t *v236;
  uint64_t *v237;
  uint64_t v238;
  uint64_t v239;
  void (*v240)(uint64_t);
  void *v241;
  id v242;
  uint64_t *v243;
  uint64_t v244;
  uint64_t v245;
  intptr_t (*v246)(uint64_t);
  void *v247;
  _QWORD *v248;
  NSObject *v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t *v252;
  uint64_t v253;
  uint64_t (*v254)(uint64_t, uint64_t);
  void (*v255)(uint64_t);
  id v256;
  uint64_t v257;
  uint64_t *v258;
  uint64_t v259;
  int v260;
  uint64_t v261;
  uint64_t *v262;
  uint64_t v263;
  char v264;
  uint64_t v265;
  uint64_t *v266;
  uint64_t v267;
  char v268;
  uint64_t v269;
  uint64_t *v270;
  uint64_t v271;
  char v272;
  _QWORD v273[5];
  id v274;
  uint64_t v275;
  uint64_t *v276;
  uint64_t v277;
  uint64_t (*v278)(uint64_t, uint64_t);
  void (*v279)(uint64_t);
  id v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  __int128 v284;
  uint8_t v285[128];
  _BYTE buf[24];
  uint64_t v287;
  __int128 v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;

  v291 = *MEMORY[0x1E0C80C00];
  v148 = a4;
  if (!a1)
  {
LABEL_168:
    v12 = 0;
    goto LABEL_129;
  }
  context = (void *)MEMORY[0x1BCCCC288]();
  if (-[SASampleStore(KPerf) _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:]::onceToken != -1)
    dispatch_once(&-[SASampleStore(KPerf) _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:]::onceToken, &__block_literal_global_156);
  v147 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v275 = 0;
  v276 = &v275;
  v277 = 0x3032000000;
  v278 = __Block_byref_object_copy__1;
  v279 = __Block_byref_object_dispose__1;
  v280 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 2);
  v273[0] = 0;
  v273[1] = v273;
  v273[2] = 0x3032000000;
  v273[3] = __Block_byref_object_copy__1;
  v273[4] = __Block_byref_object_dispose__1;
  v274 = 0;
  v269 = 0;
  v270 = &v269;
  v271 = 0x2020000000;
  v272 = 0;
  v265 = 0;
  v266 = &v265;
  v267 = 0x2020000000;
  v268 = 0;
  v261 = 0;
  v262 = &v261;
  v263 = 0x2020000000;
  v264 = 0;
  v257 = 0;
  v258 = &v257;
  v259 = 0x2020000000;
  v260 = -1;
  v251 = 0;
  v252 = &v251;
  v253 = 0x3032000000;
  v254 = __Block_byref_object_copy__1;
  v255 = __Block_byref_object_dispose__1;
  v256 = 0;
  v8 = ktrace_session_create();
  if (!v8)
  {
    if (a5)
    {
      v12 = 0;
      v13 = *a5;
      *a5 = CFSTR("Unable to allocate ktrace_session");
      goto LABEL_127;
    }
LABEL_27:
    v12 = 0;
LABEL_128:
    _Block_object_dispose(&v251, 8);

    _Block_object_dispose(&v257, 8);
    _Block_object_dispose(&v261, 8);
    _Block_object_dispose(&v265, 8);
    _Block_object_dispose(&v269, 8);
    _Block_object_dispose(v273, 8);

    _Block_object_dispose(&v275, 8);
    objc_autoreleasePoolPop(context);
LABEL_129:

    return v12;
  }
  ktrace_set_execnames_enabled();
  ktrace_session_set_event_names_enabled();
  ktrace_session_set_event_names_enabled();
  qos_class_self();
  ktrace_set_collection_qos();
  v9 = ktrace_set_file();
  if ((_DWORD)v9)
  {
    if (a5)
    {
      v10 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Unable to set file as ktrace: %d"), v9);
      v11 = *a5;
      *a5 = (void *)v10;

    }
    ktrace_session_destroy();
    goto LABEL_27;
  }
  v14 = dispatch_semaphore_create(0);
  v15 = MEMORY[0x1E0C809B0];
  v244 = MEMORY[0x1E0C809B0];
  v245 = 3221225472;
  v246 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_169;
  v247 = &unk_1E7147B48;
  v250 = v8;
  v248 = a1;
  v16 = v14;
  v249 = v16;
  ktrace_set_completion_handler();
  v238 = v15;
  v239 = 3221225472;
  v240 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2;
  v241 = &unk_1E7147B70;
  v243 = &v269;
  v242 = v148;
  ktrace_chunks();
  v228 = v15;
  v229 = 3221225472;
  v230 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3;
  v231 = &unk_1E7147B98;
  v235 = &v265;
  v236 = &v251;
  v237 = &v261;
  v234 = &v269;
  v232 = a1;
  v233 = v242;
  ktrace_chunks();
  v222 = v15;
  v223 = 3221225472;
  v224 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_178;
  v225 = &unk_1E7147BC0;
  v226 = v233;
  v227 = a1;
  ktrace_chunks();
  v215 = v15;
  v216 = 3221225472;
  v217 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_196;
  v218 = &unk_1E7147BE8;
  v221 = &v269;
  v17 = v226;
  v219 = v17;
  v142 = v147;
  v220 = v142;
  ktrace_chunks();
  v144 = a5;
  v145 = a1;
  v143 = a3;
  if ((a3 & 1) == 0)
  {
    v208 = MEMORY[0x1E0C809B0];
    v209 = 3221225472;
    v210 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_204;
    v211 = &unk_1E7147BE8;
    v212 = v17;
    v213 = a1;
    v214 = &v257;
    ktrace_chunks();

  }
  v205[0] = MEMORY[0x1E0C809B0];
  v205[1] = 3221225472;
  v205[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_210;
  v205[3] = &unk_1E7147B70;
  v207 = &v269;
  v18 = v17;
  v206 = v18;
  v19 = (void *)MEMORY[0x1BCCCC450](v205);
  ktrace_chunks();
  ktrace_chunks();
  v201[0] = MEMORY[0x1E0C809B0];
  v201[1] = 3221225472;
  v201[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_215;
  v201[3] = &unk_1E7147C10;
  v203 = &v269;
  v20 = v18;
  v202 = v20;
  v204 = &v275;
  v21 = (void *)MEMORY[0x1BCCCC450](v201);
  ktrace_chunks();
  ktrace_chunks();
  ktrace_chunks();
  v22 = MEMORY[0x1E0C809B0];
  v195 = MEMORY[0x1E0C809B0];
  v196 = 3221225472;
  v197 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_220;
  v198 = &unk_1E7147BC0;
  v199 = v20;
  v200 = a1;
  ktrace_chunks();
  v188 = v22;
  v189 = 3221225472;
  v190 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_223;
  v191 = &unk_1E7147C10;
  v193 = &v269;
  v194 = v273;
  v141 = v199;
  v192 = v141;
  ktrace_chunks();
  v23 = qos_class_self();
  dispatch_get_global_queue(v23, 0);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = ktrace_start();

  if (v25)
  {
    if (v144)
    {
      v138 = v25;
      v26 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Unable to ktrace_start session: %d"));
      v27 = *v144;
      *v144 = (void *)v26;

    }
    ktrace_session_destroy();
  }
  else
  {
    dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
    ktrace_session_destroy();
    if (*((_BYTE *)v270 + 24) && !*((_BYTE *)v266 + 24))
      *((_BYTE *)v262 + 24) = 1;
    if ((v143 & 1) == 0 && !objc_msgSend(a1, "dataStyle"))
    {
      if (*((_BYTE *)v270 + 24))
      {
        v28 = objc_msgSend(a1, "dataSource") | 2;
        v29 = 3;
      }
      else
      {
        v28 = objc_msgSend(a1, "dataSource") | 8;
        v29 = 1;
      }
      a1[44] = v28;
      a1[45] = v29;
    }
  }

  if (v25)
    goto LABEL_27;
  v30 = a1;
  v31 = objc_msgSend(a1, "dataSource");
  v32 = (NSObject **)v144;
  v33 = v143;
  v34 = MEMORY[0x1E0C809B0];
  if ((v31 & 2) != 0 && !*((_BYTE *)v262 + 24))
    v139 = objc_msgSend(a1, "kPerfPETParsePastLastStackshot");
  else
    v139 = 1;
  if ((objc_msgSend(a1, "dataSource") & 2) != 0 && !objc_msgSend((id)v276[5], "count"))
  {
    if (v144)
    {
      v12 = 0;
      v13 = *v144;
      *v144 = CFSTR("No stackshot for PET data");
      goto LABEL_127;
    }
    goto LABEL_27;
  }
  v35 = objc_alloc(MEMORY[0x1E0C99DE8]);
  v140 = (void *)objc_msgSend(v35, "initWithCapacity:", objc_msgSend((id)v276[5], "count"));
  if (!objc_msgSend((id)v276[5], "count"))
    goto LABEL_68;
  v36 = (id)v276[5];
  v37 = v140;
  v152 = v37;
  if (!v37)
  {
    v109 = *__error();
    _sa_logt();
    v110 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v288) = 0;
      _os_log_error_impl(&dword_1B9BE0000, v110, OS_LOG_TYPE_ERROR, "nil stackshotMachAbsTimes_out", (uint8_t *)&v288, 2u);
    }

    *__error() = v109;
    _SASetCrashLogMessage(2023, "nil stackshotMachAbsTimes_out", v111, v112, v113, v114, v115, v116, v138);
    _os_crash();
    __break(1u);
    goto LABEL_165;
  }
  if (objc_msgSend(v37, "count"))
  {
LABEL_165:
    v117 = *__error();
    _sa_logt();
    v118 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
    {
      v119 = objc_msgSend(v152, "count");
      LODWORD(v288) = 134217984;
      *(_QWORD *)((char *)&v288 + 4) = v119;
      _os_log_error_impl(&dword_1B9BE0000, v118, OS_LOG_TYPE_ERROR, "%lu stackshotMachAbsTimes_out.count", (uint8_t *)&v288, 0xCu);
    }

    *__error() = v117;
    v120 = objc_msgSend(v152, "count");
    _SASetCrashLogMessage(2024, "%lu stackshotMachAbsTimes_out.count", v121, v122, v123, v124, v125, v126, v120);
    _os_crash();
    __break(1u);
    goto LABEL_168;
  }
  v284 = 0u;
  v283 = 0u;
  v282 = 0u;
  v281 = 0u;
  obj = v36;
  v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v281, &v288, 16);
  if (v38)
  {
    DWORD1(v150) = 0;
    *((_QWORD *)&v150 + 1) = 0;
    v151 = *(_QWORD *)v282;
    do
    {
      for (i = 0; i != v38; ++i)
      {
        if (*(_QWORD *)v282 != v151)
          objc_enumerationMutation(obj);
        v40 = objc_retainAutorelease(*(id *)(*((_QWORD *)&v281 + 1) + 8 * i));
        v41 = (int *)objc_msgSend(v40, "bytes");
        v42 = (unint64_t)v41 + objc_msgSend(v40, "length");
        while (1)
        {
          v43 = v41 + 4;
          if ((unint64_t)(v41 + 4) > v42)
            break;
          if ((unint64_t)v43 + v41[1] > v42)
            break;
          v44 = *v41;
          if (*v41 == -242132755)
            break;
          if ((v44 & 0xFFFFFFF0) == 0x20)
            v44 = 17;
          if ((v44 - 1) >= 6)
            v45 = v41 + 4;
          else
            v45 = v41 + 12;
          if (v44 == 50)
          {
            if (v45[1] && *v45)
            {
              DWORD1(v150) = *v45;
              *((_QWORD *)&v150 + 1) = v45[1];
            }
            else
            {
              v47 = *__error();
              _sa_logt();
              v48 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
              {
                v49 = *v45;
                v50 = v45[1];
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)&buf[4] = v49;
                *(_WORD *)&buf[8] = 1024;
                *(_DWORD *)&buf[10] = v50;
                _os_log_error_impl(&dword_1B9BE0000, v48, OS_LOG_TYPE_ERROR, "Bad mach timebase: %d/%d", buf, 0xEu);
              }

              *__error() = v47;
            }
          }
          else if (v44 == 51)
          {
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)v45);
            v46 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v152, "addObject:", v46);

          }
          v41 = (_DWORD *)((char *)v43 + v41[1]);
        }
      }
      v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v281, &v288, 16);
    }
    while (v38);
  }
  else
  {
    *((_QWORD *)&v150 + 1) = 0;
    DWORD1(v150) = 0;
  }

  objc_msgSend(v152, "lastObject");
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(v51, "unsignedLongLongValue") || !DWORD2(v150))
  {

    goto LABEL_74;
  }

  if (!DWORD1(v150))
  {
LABEL_74:
    if (v144)
    {
      v12 = 0;
      v56 = *v144;
      *v144 = CFSTR("No timestamp / timebase in stackshot");
      goto LABEL_125;
    }
    v12 = 0;
    v13 = v152;
LABEL_127:

    goto LABEL_128;
  }
  v30 = v145;
  objc_msgSend(v145, "setMachTimebase:", (unint64_t)(v150 >> 32));
  v32 = (NSObject **)v144;
  v33 = v143;
  v34 = MEMORY[0x1E0C809B0];
LABEL_68:
  v52 = ktrace_session_create();
  if (!v52)
  {
    if (!v32)
    {
LABEL_81:
      v12 = 0;
LABEL_126:
      v13 = v140;
      goto LABEL_127;
    }
    v12 = 0;
    v56 = *v32;
    *v32 = CFSTR("Unable to allocate ktrace_session");
LABEL_125:

    goto LABEL_126;
  }
  ktrace_set_execnames_enabled();
  ktrace_session_set_event_names_enabled();
  ktrace_session_set_event_names_enabled();
  qos_class_self();
  ktrace_set_collection_qos();
  v53 = ktrace_set_file();
  if ((_DWORD)v53)
  {
    if (v32)
    {
      v54 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Unable set file as ktrace: %d"), v53);
      v55 = *v32;
      *v32 = v54;

    }
    ktrace_session_destroy();
    goto LABEL_81;
  }
  v57 = dispatch_semaphore_create(0);
  *(_QWORD *)&v288 = 0;
  *((_QWORD *)&v288 + 1) = &v288;
  v289 = 0x2020000000;
  v290 = 0;
  v182 = v34;
  v183 = 3221225472;
  v184 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_232;
  v185 = &unk_1E7147C38;
  v186 = &v288;
  v187 = v52;
  ktrace_events_all();
  *(_QWORD *)&v281 = 0;
  *((_QWORD *)&v281 + 1) = &v281;
  v282 = 0x2020000000uLL;
  v168 = v34;
  v169 = 3221225472;
  v170 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4;
  v171 = &unk_1E7147D60;
  v172 = v30;
  v56 = v57;
  v173 = v56;
  v174 = v142;
  v175 = v273;
  v181 = v33;
  v176 = &v281;
  v177 = &v275;
  v178 = &v288;
  v179 = &v269;
  v180 = v52;
  ktrace_set_completion_handler();
  if ((v33 & 1) != 0)
  {
    ktrace_chunks();
    v155 = 0u;
    v156 = 0u;
    v153 = 0u;
    v154 = 0u;
    v58 = (id)v276[5];
    v59 = objc_msgSend(v58, "countByEnumeratingWithState:objects:count:", &v153, v285, 16);
    if (v59)
    {
      v60 = *(_QWORD *)v154;
      do
      {
        for (j = 0; j != v59; ++j)
        {
          if (*(_QWORD *)v154 != v60)
            objc_enumerationMutation(v58);
          objc_msgSend(v30, "addKCDataStackshot:", *(_QWORD *)(*((_QWORD *)&v153 + 1) + 8 * j));
        }
        v59 = objc_msgSend(v58, "countByEnumeratingWithState:objects:count:", &v153, v285, 16);
      }
      while (v59);
    }

  }
  else
  {
    if (objc_msgSend((id)v276[5], "count"))
    {
      if ((v139 & 1) != 0)
      {
        v62 = -1;
      }
      else
      {
        objc_msgSend(v140, "lastObject");
        v63 = (void *)objc_claimAutoreleasedReturnValue();
        v62 = objc_msgSend(v63, "unsignedLongLongValue");

      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v287 = 0;
      objc_msgSend(v140, "objectAtIndexedSubscript:", *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24));
      v64 = (void *)objc_claimAutoreleasedReturnValue();
      v65 = objc_msgSend(v64, "unsignedLongLongValue");

      v287 = v65;
      v157 = MEMORY[0x1E0C809B0];
      v158 = 3221225472;
      v159 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_241;
      v160 = &unk_1E7147D88;
      v163 = buf;
      v161 = v145;
      v164 = &v275;
      v165 = &v281;
      v166 = v52;
      v162 = v140;
      v167 = v139;
      ktrace_events_all();

      _Block_object_dispose(buf, 8);
      v30 = v145;
    }
    else
    {
      v62 = -1;
    }
    -[SASampleStore _addKPerfDataFromKTraceSession:beforeMachAbsTime:petTimerID:](v30, v52, v62, *((_DWORD *)v258 + 6));
  }
  v66 = qos_class_self();
  dispatch_get_global_queue(v66, 0);
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v68 = ktrace_start();

  if ((_DWORD)v68)
  {
    if (v144)
    {
      v69 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Unable to ktrace_start session: %d"), v68);
      v70 = *v144;
      *v144 = (void *)v69;

    }
    ktrace_session_destroy();
    goto LABEL_103;
  }
  dispatch_semaphore_wait(v56, 0xFFFFFFFFFFFFFFFFLL);
  v71 = v144;
  v72 = v145;
  if ((v143 & 1) != 0)
    goto LABEL_105;
  v79 = objc_msgSend(v145, "dataSource");
  if (!v141)
    goto LABEL_105;
  if ((v79 & 2) == 0)
    goto LABEL_105;
  objc_msgSend(v145, "endTime");
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  v81 = v80 == 0;

  v71 = v144;
  v72 = v145;
  if (v81)
    goto LABEL_105;
  objc_msgSend(v145, "endTime");
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  v83 = objc_msgSend(v82, "machAbsTime");

  v84 = *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24);
  if (v84)
  {
    objc_msgSend(v140, "objectAtIndexedSubscript:", v84 - 1);
    v85 = (void *)objc_claimAutoreleasedReturnValue();
    v86 = objc_msgSend(v85, "unsignedLongLongValue");

    v71 = v144;
    v72 = v145;
    if (v86 >= v83)
      goto LABEL_105;
    if (v86)
    {
      v87 = *(_QWORD *)(*((_QWORD *)&v288 + 1) + 24);
      v88 = objc_msgSend(v145, "machTimebase");
      v89 = 0;
      if ((_DWORD)v88)
      {
        if (HIDWORD(v88))
        {
          v89 = v87 - v86;
          if ((_DWORD)v88 != HIDWORD(v88))
            v89 = __udivti3();
        }
      }
      +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", v86, 0, 0.0, 0.0, 0.0);
      v90 = (void *)objc_claimAutoreleasedReturnValue();
      v91 = objc_msgSend(v145, "indexOfLastSampleOnOrBeforeTimestamp:", v90);

      v92 = *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24);
      v72 = v145;
      v93 = (double)(unint64_t)v89 / 1000000000.0;
      if (v92 < objc_msgSend((id)v276[5], "count"))
      {
        objc_msgSend(v140, "objectAtIndexedSubscript:", *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24));
        v94 = (void *)objc_claimAutoreleasedReturnValue();
        v95 = objc_msgSend(v94, "unsignedLongLongValue");
        v96 = *(_QWORD *)(*((_QWORD *)&v288 + 1) + 24);
        v97 = objc_msgSend(v145, "machTimebase");
        v98 = 0;
        if ((_DWORD)v97)
        {
          if (HIDWORD(v97))
          {
            v98 = v95 - v96;
            if ((_DWORD)v97 != HIDWORD(v97))
              v98 = __udivti3();
          }
        }

        v99 = objc_alloc(MEMORY[0x1E0CB3940]);
        objc_msgSend(v145, "sampleTimestamps");
        v100 = (void *)objc_claimAutoreleasedReturnValue();
        v101 = (void *)objc_msgSend(v99, "initWithFormat:", CFSTR("KTrace data ended %.1fs before the next stackshot (%.1fs after the previous stackshot). Data for the last %lu samples will be missing for any threads/tasks after the point at which they stopped using any cpu time"), (double)(unint64_t)v98 / 1000000000.0, *(_QWORD *)&v93, objc_msgSend(v100, "count") - v91);
        objc_msgSend(v141, "addObject:", v101);
        goto LABEL_160;
      }
      v71 = v144;
      if ((v139 & 1) == 0)
      {
        v108 = objc_alloc(MEMORY[0x1E0CB3940]);
        objc_msgSend(v145, "sampleTimestamps");
        v100 = (void *)objc_claimAutoreleasedReturnValue();
        v101 = (void *)objc_msgSend(v108, "initWithFormat:", CFSTR("KTrace data ended %.1fs after the last stackshot. Data for the last %lu samples will be missing for any threads/tasks after the point at which they stopped using any cpu time"), (double)(unint64_t)v89 / 1000000000.0, objc_msgSend(v100, "count") - v91);
        objc_msgSend(v141, "addObject:", v101);
LABEL_160:

LABEL_161:
        v71 = v144;
        v72 = v145;
      }
LABEL_105:
      ktrace_session_destroy();
      if (v252[5] && objc_msgSend(v72, "targetProcessId") == -1)
        objc_msgSend(v72, "setTargetProcessId:", objc_msgSend((id)v252[5], "intValue"));
      if (objc_msgSend(v72, "dataStyle") == 1 || !objc_msgSend(v72, "dataStyle"))
      {
        if (objc_msgSend(v72, "isEmpty"))
        {
          if (v71)
          {
            v75 = CFSTR("No samples");
LABEL_118:
            v76 = *v71;
            *v71 = (void *)v75;

          }
LABEL_103:
          v12 = 0;
LABEL_124:

          _Block_object_dispose(&v281, 8);
          _Block_object_dispose(&v288, 8);
          goto LABEL_125;
        }
      }
      else
      {
        objc_msgSend(v72, "sampleTimestamps");
        v73 = (void *)objc_claimAutoreleasedReturnValue();
        v74 = objc_msgSend(v73, "count") == 0;

        v71 = v144;
        v72 = v145;
        if (v74)
        {
          if (v144)
          {
            v75 = CFSTR("No PET samples");
            if (v143)
              v75 = CFSTR("No stackshots");
            goto LABEL_118;
          }
          goto LABEL_103;
        }
      }
      if ((objc_msgSend(v72, "dataSource") & 2) != 0 && v139 && objc_msgSend(v140, "count"))
      {
        objc_msgSend(v140, "lastObject");
        v77 = (void *)objc_claimAutoreleasedReturnValue();
        -[SASampleStore forwardFillFromLastStackshot:](v72, objc_msgSend(v77, "unsignedLongLongValue"));

        v72 = v145;
      }
      objc_msgSend(v72, "postprocess");
      v12 = 1;
      goto LABEL_124;
    }
    v102 = *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24);
  }
  else
  {
    v71 = v144;
    v72 = v145;
    if (!v83)
      goto LABEL_105;
    v102 = 0;
  }
  if (v102 < objc_msgSend((id)v276[5], "count"))
  {
    objc_msgSend(v140, "objectAtIndexedSubscript:", *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24));
    v103 = (void *)objc_claimAutoreleasedReturnValue();
    v104 = objc_msgSend(v103, "unsignedLongLongValue");
    v105 = *(_QWORD *)(*((_QWORD *)&v288 + 1) + 24);
    v106 = objc_msgSend(v145, "machTimebase");
    v107 = 0;
    if ((_DWORD)v106)
    {
      if (HIDWORD(v106))
      {
        v107 = v104 - v105;
        if ((_DWORD)v106 != HIDWORD(v106))
          v107 = __udivti3();
      }
    }

    if ((double)(unint64_t)v107 / 1000000000.0 <= 0.001)
      v100 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("KTrace data ended %fs before the stackshot. Data will be missing/incomplete for any threads/tasks after the point at which they stopped using any cpu time"), (double)(unint64_t)v107 / 1000000000.0);
    else
      v100 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("KTrace data ended %.3fs before the stackshot. Data will be missing/incomplete for any threads/tasks after the point at which they stopped using any cpu time"), (double)(unint64_t)v107 / 1000000000.0);
    objc_msgSend(v141, "addObject:", v100);
    goto LABEL_161;
  }
  v127 = *__error();
  _sa_logt();
  v128 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
  {
    v129 = *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24);
    v130 = objc_msgSend(v140, "count");
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v129;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v130;
    _os_log_error_impl(&dword_1B9BE0000, v128, OS_LOG_TYPE_ERROR, "nextStackshotIndex %lu, %lu stackshots", buf, 0x16u);
  }

  *__error() = v127;
  v131 = *(_QWORD *)(*((_QWORD *)&v281 + 1) + 24);
  objc_msgSend(v140, "count");
  _SASetCrashLogMessage(3619, "nextStackshotIndex %lu, %lu stackshots", v132, v133, v134, v135, v136, v137, v131);
  result = _os_crash();
  __break(1u);
  return result;
}

- (BOOL)parseKTraceFile:(const char *)a3 warningsOut:(id)a4 errorOut:(id *)a5
{
  void **v6;
  char v7;
  id v9;

  v9 = 0;
  if (a5)
    v6 = &v9;
  else
    v6 = 0;
  v7 = -[SASampleStore _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:](self, (uint64_t)a3, 0, a4, v6);
  if (a5)
    *a5 = objc_retainAutorelease(v9);

  return v7;
}

const char *__77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke()
{
  char *v0;
  size_t v1;
  pid_t v2;
  int v3;
  NSObject *v4;
  const char *result;
  int v6;
  int *v7;
  char *v8;
  time_t v9;
  tm v10;
  uint8_t buf[4];
  char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  char *v16;
  char __filename[1032];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v0 = getenv("SA_PRINT_KPERF");
  if (v0 || (v0 = getenv("SA_DEBUG_KPERF")) != 0)
  {
    if (strcmp(v0, "0"))
    {
      strcpy(__filename, "/var/tmp/SAKPerfLog.");
      v9 = time(0);
      localtime_r(&v9, &v10);
      v1 = strftime(&__filename[20], 0x3ECuLL, "%Y-%m-%d-%T", &v10);
      v2 = getpid();
      snprintf(&__filename[v1 + 20], 1004 - v1, ".%d.txt", v2);
      qword_1ED1DD618 = (uint64_t)fopen(__filename, "w");
      if (qword_1ED1DD618)
      {
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "Logging kperf parsing to %s\n", __filename);
        v3 = *__error();
        _sa_logt();
        v4 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v12 = __filename;
          _os_log_impl(&dword_1B9BE0000, v4, OS_LOG_TYPE_DEFAULT, "Logging kperf parsing to %{public}s", buf, 0xCu);
        }
      }
      else
      {
        v3 = *__error();
        _sa_logt();
        v4 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          v6 = *__error();
          v7 = __error();
          v8 = strerror(*v7);
          *(_DWORD *)buf = 136446722;
          v12 = __filename;
          v13 = 1024;
          v14 = v6;
          v15 = 2080;
          v16 = v8;
          _os_log_error_impl(&dword_1B9BE0000, v4, OS_LOG_TYPE_ERROR, "Unable to open %{public}s: %d %s", buf, 0x1Cu);
        }
      }

      *__error() = v3;
    }
  }
  result = getenv("SA_LOG_KTSYM");
  if (result || (result = getenv("SA_DEBUG_KTSYM")) != 0)
  {
    result = (const char *)strcmp(result, "0");
    if ((_DWORD)result)
      _MergedGlobals_4[0] = 1;
  }
  return result;
}

intptr_t __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_169(uint64_t a1)
{
  uint64_t machine;
  uint64_t v3;
  uint64_t v4;
  int is_kernel_64_bit;

  machine = ktrace_get_machine();
  if (machine)
  {
    v3 = machine;
    v4 = *(_QWORD *)(a1 + 32);
    is_kernel_64_bit = ktrace_is_kernel_64_bit();
    -[SASampleStore _populateFromKtraceMachineInfo:is64bit:](v4, v3, is_kernel_64_bit);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  DictForChunkViaNSPropertyList();
  v2 = objc_claimAutoreleasedReturnValue();
  v4 = (id)v2;
  if (v2)
  {
    +[SABinary addSymbolsFromTailspin:](SABinary, "addSymbolsFromTailspin:", v2);
  }
  else
  {
    v3 = *(void **)(a1 + 32);
    if (v3)
      objc_msgSend(v3, "addObject:", CFSTR("Unable to get dict for tailspin symbols chunk"));
  }

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  void *v23;
  void *v24;
  char v25;
  uint64_t v26;
  const char *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  int v34;
  uint64_t v35;
  void *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  double v50;
  double v51;
  void *v52;
  void *v53;
  id *v54;
  id *v55;
  id v56;
  int v57;
  NSObject *v58;
  void *v59;
  const char *v60;
  void *v61;
  void *v62;
  void *v63;
  const char *v64;
  void *v65;
  void *v66;
  void *v67;
  const char *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  char v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  void *v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  void *v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  char v100;
  uint64_t v101;
  void *v102;
  void *v103;
  void *v104;
  uint8_t buf[4];
  void *v106;
  __int16 v107;
  uint64_t v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  DictForChunkViaNSPropertyList();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if (v2)
  {
    objc_msgSend(v2, "objectForKeyedSubscript:", 0x1E714A5D0);
    v4 = objc_claimAutoreleasedReturnValue();
    v5 = *(_QWORD *)(a1[8] + 8);
    v6 = *(void **)(v5 + 40);
    *(_QWORD *)(v5 + 40) = v4;

    DictGetNumber(v3, CFSTR("IsShutdownTrace"));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    if (v7)
      *(_BYTE *)(*(_QWORD *)(a1[9] + 8) + 24) = objc_msgSend(v7, "BOOLValue");
    v9 = objc_opt_class();
    v10 = objc_opt_class();
    DictGetDictOfClasses(v3, CFSTR("SystemAdvisoryLevels"), v9, v10);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    if (v12)
    {
      v13 = (void *)a1[4];
      if (v13)
        objc_setProperty_atomic(v13, v11, v12, 504);
    }
    v14 = objc_opt_class();
    v15 = objc_opt_class();
    DictGetDictOfClasses(v3, CFSTR("HomeVolumeSpace"), v14, v15);
    v16 = (void *)objc_claimAutoreleasedReturnValue();

    if (v16)
    {
      v18 = (void *)a1[4];
      if (v18)
        objc_setProperty_atomic(v18, v17, v16, 512);
    }
    v19 = objc_opt_class();
    v20 = objc_opt_class();
    DictGetDictOfClasses(v3, CFSTR("NonDefaultFeatureFlags"), v19, v20);
    v21 = (void *)objc_claimAutoreleasedReturnValue();

    if (v21)
    {
      v23 = (void *)a1[4];
      if (v23)
        objc_setProperty_atomic(v23, v22, v21, 520);
    }
    DictGetNumber(v3, CFSTR("IsRootInstalled"));
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
    {
      v25 = objc_msgSend(v24, "BOOLValue");
      v26 = a1[4];
      if (v26)
        *(_BYTE *)(v26 + 317) = v25;
    }
    objc_opt_class();
    DictGetArrayOfClass(v3, CFSTR("InstalledRootNames"));
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    if (v28)
    {
      v29 = (void *)a1[4];
      if (v29)
      {
        objc_setProperty_atomic(v29, v27, v28, 552);
        v29 = (void *)a1[4];
      }
      objc_msgSend(v29, "installedRootNames");
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      v31 = objc_msgSend(v30, "count");

      if (v31)
      {
        v32 = a1[4];
        if (v32)
          *(_BYTE *)(v32 + 317) = 1;
      }
    }
    DictGetNumber(v3, CFSTR("OSCryptexFileExtents"));
    v33 = (void *)objc_claimAutoreleasedReturnValue();

    if (v33)
    {
      v34 = objc_msgSend(v33, "intValue");
      v35 = a1[4];
      if (v35)
        *(_QWORD *)(v35 + 544) = v34;
    }
    DictGetNumber(v3, CFSTR("IsAppleInternal"));
    v36 = (void *)objc_claimAutoreleasedReturnValue();

    if (v36)
    {
      v37 = objc_msgSend(v36, "BOOLValue");
      v38 = a1[4];
      if (v38)
      {
        *(_BYTE *)(v38 + 318) = v37;
        v39 = a1[4];
        if (v39)
          *(_BYTE *)(v39 + 319) = 1;
      }
    }
    DictGetNumber(v3, CFSTR("IsInternalCarryDevice"));
    v40 = (void *)objc_claimAutoreleasedReturnValue();

    if (v40)
    {
      v41 = objc_msgSend(v40, "BOOLValue");
      v42 = a1[4];
      if (v42)
      {
        *(_BYTE *)(v42 + 320) = v41;
        v43 = a1[4];
        if (v43)
          *(_BYTE *)(v43 + 321) = 1;
      }
    }
    DictGetString(v3, CFSTR("AutomatedDeviceGroup"));
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    if (v45)
    {
      v46 = (void *)a1[4];
      if (v46)
        objc_setProperty_atomic(v46, v44, v45, 560);
    }
    DictGetDict(v3, CFSTR("MostRecentLowPowerModeTransition"));
    v47 = (void *)objc_claimAutoreleasedReturnValue();

    if (v47)
    {
      DictGetNumber(v47, CFSTR("LowPowerMode"));
      v104 = (void *)objc_claimAutoreleasedReturnValue();
      DictGetNumber(v47, CFSTR("PowerModeTransitionTimestamp"));
      v48 = (void *)objc_claimAutoreleasedReturnValue();
      v49 = v48;
      if (v104)
      {
        if (!v48 || (objc_msgSend(v48, "doubleValue"), v50 == 0.0))
        {
          v52 = 0;
        }
        else
        {
          objc_msgSend(v49, "doubleValue");
          +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, v51);
          v52 = (void *)objc_claimAutoreleasedReturnValue();
        }
        v54 = (id *)a1[4];
        v55 = -[SAPowerModeTransition initWithLowPowerMode:timestamp:]((id *)[SAPowerModeTransition alloc], objc_msgSend(v104, "BOOLValue"), v52);
        v56 = -[SASampleStore addPowerModeTransition:](v54, v55);

      }
      else
      {
        v57 = *__error();
        _sa_logt();
        v58 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(0, "debugDescription");
          v103 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v49, "debugDescription");
          *(_DWORD *)buf = 138412546;
          v106 = v103;
          v107 = 2112;
          v108 = objc_claimAutoreleasedReturnValue();
          v102 = (void *)v108;
          _os_log_error_impl(&dword_1B9BE0000, v58, OS_LOG_TYPE_ERROR, "Invalid power mode transition from tailspin. lowPowerModeNum:%@ transitionTimeNum:%@", buf, 0x16u);

        }
        *__error() = v57;
      }

    }
    objc_opt_class();
    DictGetArrayOfClass(v3, CFSTR("KeyboardLanguages"));
    v59 = (void *)objc_claimAutoreleasedReturnValue();

    v61 = v59;
    if (v59)
    {
      v62 = (void *)a1[4];
      if (v62)
        objc_setProperty_atomic(v62, v60, v59, 568);
    }
    objc_opt_class();
    DictGetArrayOfClass(v3, CFSTR("PreferredLanguages"));
    v63 = (void *)objc_claimAutoreleasedReturnValue();

    v65 = v63;
    if (v63)
    {
      v66 = (void *)a1[4];
      if (v66)
        objc_setProperty_atomic(v66, v64, v63, 576);
    }
    DictGetString(v3, CFSTR("CountryCode"));
    v67 = (void *)objc_claimAutoreleasedReturnValue();

    v69 = v67;
    if (v67)
    {
      v70 = (void *)a1[4];
      if (v70)
        objc_setProperty_atomic(v70, v68, v67, 584);
    }
    DictGetNumber(v3, CFSTR("HardwareKeyboard"));
    v71 = (void *)objc_claimAutoreleasedReturnValue();

    v72 = v71;
    if (v71)
    {
      v73 = objc_msgSend(v71, "BOOLValue");
      v74 = a1[4];
      if (v74)
      {
        *(_BYTE *)(v74 + 323) = v73;
        v75 = a1[4];
        if (v75)
          *(_BYTE *)(v75 + 322) = 1;
      }
    }
    DictGetDict(v3, CFSTR("VnodeInfo"));
    v76 = (void *)objc_claimAutoreleasedReturnValue();

    v77 = v76;
    if (!v76)
      goto LABEL_81;
    DictGetNumber(v76, CFSTR("NumVnodesAllocated"));
    v78 = (void *)objc_claimAutoreleasedReturnValue();
    DictGetNumber(v77, CFSTR("NumVnodesFree"));
    v79 = (void *)objc_claimAutoreleasedReturnValue();
    DictGetNumber(v77, CFSTR("NumVnodesMax"));
    v80 = (void *)objc_claimAutoreleasedReturnValue();
    DictGetNumber(v77, CFSTR("VnodeDeallocLevel"));
    v81 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v78 || !v79 || !v80)
      goto LABEL_80;
    v82 = objc_msgSend(v78, "unsignedLongLongValue");
    v83 = a1[4];
    if (v83)
      *(_QWORD *)(v83 + 984) = v82;
    v84 = objc_msgSend(v79, "unsignedLongLongValue");
    v85 = a1[4];
    if (v85)
      *(_QWORD *)(v85 + 992) = v84;
    v86 = objc_msgSend(v80, "unsignedLongLongValue");
    v87 = a1[4];
    if (v87)
      *(_QWORD *)(v87 + 1000) = v86;
    if (v81)
    {
      v88 = objc_msgSend(v81, "unsignedIntValue");
      v89 = a1[4];
      if (v88)
      {
        if (v89)
        {
          v90 = 2 * *(_QWORD *)(v89 + 1000);
LABEL_79:
          *(_QWORD *)(v89 + 1008) = v90;
          goto LABEL_80;
        }
        goto LABEL_80;
      }
    }
    else
    {
      v89 = a1[4];
    }
    if (v89)
    {
      v90 = *(_QWORD *)(v89 + 1000);
      goto LABEL_79;
    }
LABEL_80:

LABEL_81:
    DictGetNumber(v3, CFSTR("GPURestartCount"));
    v91 = (void *)objc_claimAutoreleasedReturnValue();

    v92 = v91;
    if (v91)
    {
      v93 = objc_msgSend(v91, "unsignedLongLongValue");
      v94 = a1[4];
      if (v94)
        *(_QWORD *)(v94 + 592) = v93;
    }
    DictGetNumber(v3, CFSTR("GPURestartLastMachAbs"));
    v95 = (void *)objc_claimAutoreleasedReturnValue();

    v96 = v95;
    if (v95)
    {
      v97 = objc_msgSend(v95, "unsignedLongLongValue");
      v98 = a1[4];
      if (v98)
        *(_QWORD *)(v98 + 600) = v97;
    }
    DictGetNumber(v3, CFSTR("HasEnterprisePersona"));
    v99 = (void *)objc_claimAutoreleasedReturnValue();

    if (v99)
    {
      v100 = objc_msgSend(v99, "BOOLValue");
      v101 = a1[4];
      if (v101)
        *(_BYTE *)(v101 + 324) = v100;
    }

    goto LABEL_91;
  }
  v53 = (void *)a1[5];
  if (v53)
    objc_msgSend(v53, "addObject:", CFSTR("Unable to get dict for tailspin metadata chunk"));
LABEL_91:

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_178(uint64_t a1)
{
  void *v1;
  id v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  const char *v15;
  const char *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  int v26;
  NSObject *v27;
  int v28;
  NSObject *v29;
  const char *v30;
  void *v31;
  int v32;
  NSObject *v33;
  void *v34;
  int v35;
  NSObject *v36;
  void *v38;
  int v39;
  NSObject *v40;
  void *v42;
  int v43;
  NSObject *v44;
  void *v46;
  int v47;
  NSObject *v48;
  void *v50;
  void *v51;
  int v52;
  NSObject *v53;
  void *v55;
  int v56;
  NSObject *v57;
  void *v59;
  int v60;
  NSObject *v61;
  void *v63;
  int v64;
  NSObject *v65;
  void *v67;
  const char *ClassName;
  const char *v69;
  const char *v70;
  const char *v71;
  const char *v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t i;
  uint64_t v79;
  void *v80;
  id obj;
  id newValue;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  _BYTE v100[128];
  uint8_t v101[128];
  uint8_t buf[4];
  const char *v103;
  __int16 v104;
  const char *v105;
  _BYTE v106[128];
  _BYTE v107[128];
  uint64_t v108;

  v108 = *MEMORY[0x1E0C80C00];
  DictForChunkViaNSPropertyList();
  newValue = (id)objc_claimAutoreleasedReturnValue();
  if (!newValue)
  {
    v32 = *__error();
    _sa_logt();
    v33 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v33, OS_LOG_TYPE_ERROR, "Unable to get dict for tailspin metadata chunk", buf, 2u);
    }

    *__error() = v32;
    v34 = *(void **)(a1 + 32);
    if (v34)
      objc_msgSend(v34, "addObject:", CFSTR("Unable to get dict for tailspin metadata chunk"));
    goto LABEL_116;
  }
  objc_opt_class();
  DictGetArrayOfClass(newValue, CFSTR("experiments"));
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  if (v80)
  {
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    obj = v80;
    v74 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v96, v107, 16);
    if (v74)
    {
      v76 = *(_QWORD *)v97;
      do
      {
        for (i = 0; i != v74; ++i)
        {
          if (*(_QWORD *)v97 != v76)
            objc_enumerationMutation(obj);
          v1 = *(void **)(*((_QWORD *)&v96 + 1) + 8 * i);
          v92 = 0u;
          v93 = 0u;
          v94 = 0u;
          v95 = 0u;
          v2 = v1;
          v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v92, v106, 16);
          if (v3)
          {
            v4 = *(_QWORD *)v93;
            do
            {
              v5 = 0;
              do
              {
                if (*(_QWORD *)v93 != v4)
                  objc_enumerationMutation(v2);
                v6 = *(char **)(*((_QWORD *)&v92 + 1) + 8 * v5);
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  objc_msgSend(v2, "objectForKeyedSubscript:", v6);
                  v7 = (id)objc_claimAutoreleasedReturnValue();
                  if (objc_msgSend(v6, "isEqualToString:", CFSTR("namespace_ids")))
                  {
                    v8 = objc_opt_class();
                    v9 = objc_opt_class();
                    DictGetDictOfClasses(v2, CFSTR("namespace_ids"), v8, v9);
                    v10 = (void *)objc_claimAutoreleasedReturnValue();
                    LODWORD(v8) = v10 == 0;

                    if ((_DWORD)v8)
                    {
                      v35 = *__error();
                      _sa_logt();
                      v36 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_error_impl(&dword_1B9BE0000, v36, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: namespaces value is invalid", buf, 2u);
                      }

                      *__error() = v35;
                      v38 = *(void **)(a1 + 32);
                      if (v38)
                        objc_msgSend(v38, "addObject:", CFSTR("Bad type in trial experiments dict: namespaces value is invalid"));
                      goto LABEL_114;
                    }
                  }
                  else if (objc_msgSend(v6, "isEqualToString:", CFSTR("experiment_id")))
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      v43 = *__error();
                      _sa_logt();
                      v44 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                      {
                        ClassName = object_getClassName(v7);
                        *(_DWORD *)buf = 136315138;
                        v103 = ClassName;
                        _os_log_error_impl(&dword_1B9BE0000, v44, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: experiment is %s", buf, 0xCu);
                      }

                      *__error() = v43;
                      v46 = *(void **)(a1 + 32);
                      if (v46)
                      {
                        v22 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Bad type in trial experiments dict: experiment is %s"), object_getClassName(v7));
                        objc_msgSend(v46, "addObject:", v22);
                        goto LABEL_113;
                      }
                      goto LABEL_114;
                    }
                  }
                  else if (objc_msgSend(v6, "isEqualToString:", CFSTR("deployment_id")))
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      v52 = *__error();
                      _sa_logt();
                      v53 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                      {
                        v70 = object_getClassName(v7);
                        *(_DWORD *)buf = 136315138;
                        v103 = v70;
                        _os_log_error_impl(&dword_1B9BE0000, v53, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: deployment is %s", buf, 0xCu);
                      }

                      *__error() = v52;
                      v55 = *(void **)(a1 + 32);
                      if (v55)
                      {
                        v22 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Bad type in trial experiments dict: deployment is %s"), object_getClassName(v7));
                        objc_msgSend(v55, "addObject:", v22);
                        goto LABEL_113;
                      }
                      goto LABEL_114;
                    }
                  }
                  else if (objc_msgSend(v6, "isEqualToString:", CFSTR("treatment_id")))
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      v60 = *__error();
                      _sa_logt();
                      v61 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                      {
                        v72 = object_getClassName(v7);
                        *(_DWORD *)buf = 136315138;
                        v103 = v72;
                        _os_log_error_impl(&dword_1B9BE0000, v61, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: treatment is %s", buf, 0xCu);
                      }

                      *__error() = v60;
                      v63 = *(void **)(a1 + 32);
                      if (v63)
                      {
                        v22 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Bad type in trial experiments dict: treatment is %s"), object_getClassName(v7));
                        objc_msgSend(v63, "addObject:", v22);
                        goto LABEL_113;
                      }
                      goto LABEL_114;
                    }
                  }
                  else
                  {
                    v13 = *__error();
                    _sa_logt();
                    v14 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 138412290;
                      v103 = v6;
                      _os_log_debug_impl(&dword_1B9BE0000, v14, OS_LOG_TYPE_DEBUG, "Unknown key in experiments dict %@, ignoring", buf, 0xCu);
                    }

                    *__error() = v13;
                  }

                }
                else
                {
                  v11 = *__error();
                  _sa_logt();
                  v12 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                  {
                    v15 = object_getClassName(v6);
                    *(_DWORD *)buf = 138412546;
                    v103 = v6;
                    v104 = 2080;
                    v105 = v15;
                    _os_log_debug_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_DEBUG, "Unknown key in experiments dict %@ (%s), ignoring", buf, 0x16u);
                  }

                  *__error() = v11;
                }
                ++v5;
              }
              while (v3 != v5);
              v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v92, v106, 16);
            }
            while (v3);
          }

        }
        v74 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v96, v107, 16);
      }
      while (v74);
    }

  }
  objc_opt_class();
  DictGetArrayOfClass(newValue, CFSTR("rollouts"));
  obj = (id)objc_claimAutoreleasedReturnValue();
  if (!obj)
  {
LABEL_74:
    v31 = *(void **)(a1 + 40);
    if (v31)
      objc_setProperty_atomic(v31, v16, newValue, 528);
    goto LABEL_115;
  }
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v2 = obj;
  v75 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v88, v101, 16);
  if (!v75)
    goto LABEL_73;
  v77 = *(_QWORD *)v89;
LABEL_41:
  v79 = 0;
LABEL_42:
  if (*(_QWORD *)v89 != v77)
    objc_enumerationMutation(v2);
  v17 = *(void **)(*((_QWORD *)&v88 + 1) + 8 * v79);
  v84 = 0u;
  v85 = 0u;
  v86 = 0u;
  v87 = 0u;
  v7 = v17;
  v18 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v84, v100, 16);
  if (!v18)
    goto LABEL_71;
  v19 = *(_QWORD *)v85;
LABEL_46:
  v20 = 0;
  while (1)
  {
    if (*(_QWORD *)v85 != v19)
      objc_enumerationMutation(v7);
    v21 = *(void **)(*((_QWORD *)&v84 + 1) + 8 * v20);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      v26 = *__error();
      _sa_logt();
      v27 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        v30 = object_getClassName(v21);
        *(_DWORD *)buf = 138412546;
        v103 = (const char *)v21;
        v104 = 2080;
        v105 = v30;
        _os_log_debug_impl(&dword_1B9BE0000, v27, OS_LOG_TYPE_DEBUG, "Unknown key in rollouts dict %@ (%s), ignoring", buf, 0x16u);
      }

      *__error() = v26;
      goto LABEL_69;
    }
    objc_msgSend(v7, "objectForKeyedSubscript:", v21);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v21, "isEqualToString:", CFSTR("factor_pack_ids")))
    {
      v23 = objc_opt_class();
      v24 = objc_opt_class();
      DictGetDictOfClasses(v7, CFSTR("factor_pack_ids"), v23, v24);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v23) = v25 == 0;

      if ((_DWORD)v23)
      {
        v39 = *__error();
        _sa_logt();
        v40 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1B9BE0000, v40, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: trial factor packs value is invalid", buf, 2u);
        }

        *__error() = v39;
        v42 = *(void **)(a1 + 32);
        if (v42)
          objc_msgSend(v42, "addObject:", CFSTR("Bad type in trial rollouts dict: trial factor packs value is invalid"));
        goto LABEL_113;
      }
      goto LABEL_68;
    }
    if (objc_msgSend(v21, "isEqualToString:", CFSTR("rollout_id")))
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        v47 = *__error();
        _sa_logt();
        v48 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          v69 = object_getClassName(v22);
          *(_DWORD *)buf = 136315138;
          v103 = v69;
          _os_log_error_impl(&dword_1B9BE0000, v48, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: rollout is %s", buf, 0xCu);
        }

        *__error() = v47;
        v50 = *(void **)(a1 + 32);
        if (!v50)
          goto LABEL_113;
        v51 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Bad type in trial rollouts dict: rollout is %s"), object_getClassName(v22));
        objc_msgSend(v50, "addObject:", v51);
        goto LABEL_112;
      }
      goto LABEL_68;
    }
    if (objc_msgSend(v21, "isEqualToString:", CFSTR("deployment_id")))
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        v56 = *__error();
        _sa_logt();
        v57 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        {
          v71 = object_getClassName(v22);
          *(_DWORD *)buf = 136315138;
          v103 = v71;
          _os_log_error_impl(&dword_1B9BE0000, v57, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: deployment is %s", buf, 0xCu);
        }

        *__error() = v56;
        v59 = *(void **)(a1 + 32);
        if (!v59)
          goto LABEL_113;
        v51 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Bad type in trial rollouts dict: deployment is %s"), object_getClassName(v22));
        objc_msgSend(v59, "addObject:", v51);
LABEL_112:

        goto LABEL_113;
      }
      goto LABEL_68;
    }
    if (!objc_msgSend(v21, "isEqualToString:", CFSTR("ramp_id")))
    {
      v28 = *__error();
      _sa_logt();
      v29 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        v103 = (const char *)v21;
        _os_log_debug_impl(&dword_1B9BE0000, v29, OS_LOG_TYPE_DEBUG, "Unknown key in experiments dict %@, ignoring", buf, 0xCu);
      }

      *__error() = v28;
      goto LABEL_68;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
      break;
LABEL_68:

LABEL_69:
    if (v18 == ++v20)
    {
      v18 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v84, v100, 16);
      if (v18)
        goto LABEL_46;
LABEL_71:

      if (++v79 == v75)
      {
        v75 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v88, v101, 16);
        if (!v75)
        {
LABEL_73:

          goto LABEL_74;
        }
        goto LABEL_41;
      }
      goto LABEL_42;
    }
  }
  v64 = *__error();
  _sa_logt();
  v65 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
  {
    v73 = object_getClassName(v22);
    *(_DWORD *)buf = 136315138;
    v103 = v73;
    _os_log_error_impl(&dword_1B9BE0000, v65, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: ramp is %s", buf, 0xCu);
  }

  *__error() = v64;
  v67 = *(void **)(a1 + 32);
  if (v67)
  {
    v51 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Bad type in trial rollouts dict: ramp is %s"), object_getClassName(v22));
    objc_msgSend(v67, "addObject:", v51);
    goto LABEL_112;
  }
LABEL_113:

LABEL_114:
LABEL_115:

LABEL_116:
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_196(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
  ktrace_chunk_size();
  v2 = ktrace_chunk_copy_cfdata();
  if (v2)
  {
    v3 = (void *)v2;
    objc_msgSend(MEMORY[0x1E0CB38B0], "propertyListWithData:options:format:error:", v2, 0, 0, 0);
    v6 = (id)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      objc_msgSend(*(id *)(a1 + 40), "addObject:");
    }
    else
    {
      v5 = *(void **)(a1 + 32);
      if (v5)
        objc_msgSend(v5, "addObject:", CFSTR("Unable to deserialize dictionary from tailspin process info chunk"));
    }

  }
  else
  {
    v4 = *(void **)(a1 + 32);
    if (v4)
      objc_msgSend(v4, "addObject:", CFSTR("Unable to get data for tailspin process info chunk"));
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_204(uint64_t a1)
{
  _BYTE *reason;
  void *v3;
  int pet_mode;
  int v5;
  NSObject *v6;
  void *v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  int timer_count;
  __int128 v15;
  unsigned int v16;
  void *v17;
  unint64_t timer_period_ns;
  int timer_action_id;
  uint64_t action_samplers;
  int v21;
  double v22;
  double v23;
  unint64_t v24;
  SAKPerfTrigger *v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  NSObject *v29;
  int *v30;
  NSObject *v31;
  SAKPerfTrigger *v32;
  _QWORD *v33;
  void *v34;
  int v35;
  NSObject *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  __int128 v44;
  id v45;
  objc_super v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!ktrace_config_create())
  {
    v8 = *(void **)(a1 + 32);
    if (v8)
      objc_msgSend(v8, "addObject:", CFSTR("Unable to parse ktrace config chunk"));
    return;
  }
  reason = (_BYTE *)ktrace_config_get_reason();
  if (reason && *reason)
  {
    SANSStringForCString(reason);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(a1 + 40), "setReason:", v3);

  }
  v45 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  pet_mode = ktrace_config_kperf_get_pet_mode();
  if (pet_mode)
  {
    if (pet_mode == 2)
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = ktrace_config_kperf_get_pet_timer_id();
      if ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) & 0x80000000) != 0)
      {
        v5 = *__error();
        _sa_logt();
        v6 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v46.receiver) = 0;
          _os_log_error_impl(&dword_1B9BE0000, v6, OS_LOG_TYPE_ERROR, "Unable to get lightweight PET timer, treating as non-PET", (uint8_t *)&v46, 2u);
        }

        *__error() = v5;
        v7 = *(void **)(a1 + 32);
        if (v7)
          objc_msgSend(v7, "addObject:", CFSTR("Unable to get lightweight PET timer, treating ktrace data as non-PET"));
      }
    }
    else
    {
      v12 = *__error();
      _sa_logt();
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v46.receiver) = 0;
        _os_log_error_impl(&dword_1B9BE0000, v13, OS_LOG_TYPE_ERROR, "Non-lightweight PET not supported, treating as non-PET", (uint8_t *)&v46, 2u);
      }

      *__error() = v12;
    }
  }
  else
  {
    v9 = *(_QWORD **)(a1 + 40);
    v10 = objc_msgSend(v9, "dataSource");
    if (v9)
      v9[44] = v10 | 8;
    v11 = *(_QWORD *)(a1 + 40);
    if (v11)
      *(_QWORD *)(v11 + 360) = 1;
  }
  timer_count = ktrace_config_kperf_get_timer_count();
  if (!timer_count)
    goto LABEL_63;
  v16 = 0;
  v17 = 0;
  *(_QWORD *)&v15 = 67109120;
  v44 = v15;
  do
  {
    timer_period_ns = ktrace_config_kperf_get_timer_period_ns();
    if (!timer_period_ns)
    {
      v28 = *__error();
      _sa_logt();
      v29 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        v46.receiver = (id)__PAIR64__(v16, v44);
        _os_log_error_impl(&dword_1B9BE0000, v29, OS_LOG_TYPE_ERROR, "KPerf timer %d has 0 period, ignoring", (uint8_t *)&v46, 8u);
      }
      goto LABEL_37;
    }
    timer_action_id = ktrace_config_kperf_get_timer_action_id();
    if (!timer_action_id)
    {
      v28 = *__error();
      _sa_logt();
      v29 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        v46.receiver = (id)__PAIR64__(v16, v44);
        _os_log_error_impl(&dword_1B9BE0000, v29, OS_LOG_TYPE_ERROR, "KPerf timer %d  has no action, ignoring", (uint8_t *)&v46, 8u);
      }
LABEL_37:

      v30 = __error();
LABEL_44:
      *v30 = v28;
      goto LABEL_45;
    }
    action_samplers = ktrace_config_kperf_get_action_samplers();
    if ((action_samplers & 0xC) == 0)
    {
      v28 = *__error();
      _sa_logt();
      v31 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        LODWORD(v46.receiver) = 67109632;
        HIDWORD(v46.receiver) = v16;
        LOWORD(v46.super_class) = 1024;
        *(_DWORD *)((char *)&v46.super_class + 2) = timer_action_id;
        HIWORD(v46.super_class) = 2048;
        v47 = action_samplers;
        _os_log_impl(&dword_1B9BE0000, v31, OS_LOG_TYPE_INFO, "KPerf timer %d (action %d) doesn't sample callstacks (0x%llx), ignoring", (uint8_t *)&v46, 0x18u);
      }

      v30 = __error();
      goto LABEL_44;
    }
    v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    if (v21 < 0 || v16 != v21)
    {
      v32 = [SAKPerfTrigger alloc];
      if (v32)
      {
        v46.receiver = v32;
        v46.super_class = (Class)SAKPerfTrigger;
        v33 = objc_msgSendSuper2(&v46, sel_init);
        v34 = v33;
        if (v33)
        {
          v33[1] = 2;
          v33[2] = timer_period_ns;
          v33[3] = action_samplers;
        }
      }
      else
      {
        v34 = 0;
      }
      objc_msgSend(v45, "addObject:", v34, v44);

    }
    else
    {
      objc_msgSend(*(id *)(a1 + 40), "kPerfPETSampleIntervalLimit");
      v23 = v22 * 1000000000.0;
      if (timer_period_ns <= (unint64_t)v23)
        v24 = (unint64_t)v23;
      else
        v24 = timer_period_ns;
      v25 = [SAKPerfTrigger alloc];
      if (v25)
      {
        v46.receiver = v25;
        v46.super_class = (Class)SAKPerfTrigger;
        v26 = objc_msgSendSuper2(&v46, sel_init);
        v27 = v26;
        if (v26)
        {
          v26[1] = 1;
          v26[2] = v24;
          v26[3] = action_samplers;
        }
      }
      else
      {
        v27 = 0;
      }

      v17 = v27;
      objc_msgSend(v45, "addObject:", v27);
    }
LABEL_45:
    ++v16;
  }
  while (timer_count != v16);
  if (v17)
  {
    if ((unint64_t)objc_msgSend(v45, "count") >= 2)
    {
      v35 = *__error();
      _sa_logt();
      v36 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v46.receiver) = 0;
        _os_log_error_impl(&dword_1B9BE0000, v36, OS_LOG_TYPE_ERROR, "Parsing both PET and non-PET data is not supported, parsing only PET data", (uint8_t *)&v46, 2u);
      }

      *__error() = v35;
      objc_msgSend(v45, "removeAllObjects");
      objc_msgSend(v45, "addObject:", v17);
    }
    v37 = *(_QWORD **)(a1 + 40);
    v38 = objc_msgSend(v37, "dataSource", v44);
    if (v37)
      v37[44] = v38 | 2;
    v39 = *(_QWORD *)(a1 + 40);
    if (v39)
      *(_QWORD *)(v39 + 360) = 3;
    objc_msgSend(*(id *)(a1 + 40), "setAttemptedSamplingInterval:", (double)(unint64_t)objc_msgSend(v17, "timerPeriodNs") / 1000000000.0);
    goto LABEL_72;
  }
LABEL_63:
  v40 = *(_QWORD **)(a1 + 40);
  v41 = objc_msgSend(v40, "dataSource", v44);
  if (v40)
    v40[44] = v41 | 8;
  v42 = *(_QWORD *)(a1 + 40);
  if (v42)
    *(_QWORD *)(v42 + 360) = 1;
  if (objc_msgSend(v45, "count") == 1)
  {
    objc_msgSend(v45, "firstObject");
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v43, "type") == 2)
      objc_msgSend(*(id *)(a1 + 40), "setAttemptedSamplingInterval:", (double)(unint64_t)objc_msgSend(v43, "timerPeriodNs") / 1000000000.0);

  }
  v17 = 0;
LABEL_72:
  objc_msgSend(*(id *)(a1 + 40), "setKperfTriggers:", v45);
  ktrace_config_destroy();

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_210(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;

  if (ktrace_chunk_tag() == 36869)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  ktrace_chunk_size();
  v2 = ktrace_chunk_copy_cfdata();
  if (v2)
  {
    v4 = (id)v2;
    +[SASharedCache addDSCSymData:](SASharedCache, "addDSCSymData:", v2);

  }
  else
  {
    v3 = *(void **)(a1 + 32);
    if (v3)
      objc_msgSend(v3, "addObject:", CFSTR("Unable to get data for dscsym chunk"));
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_215(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  int v6;
  NSObject *v7;
  uint8_t v8[16];

  if (ktrace_chunk_tag() == 36864)
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  ktrace_chunk_size();
  v2 = ktrace_chunk_copy_cfdata();
  if (v2)
  {
    v3 = (void *)v2;
    if (ktrace_chunk_tag() == 36864)
    {
      SAGetStackshotDataFromTailspinStackshotChunk(v3);
      v4 = objc_claimAutoreleasedReturnValue();

      v3 = (void *)v4;
    }
    if (objc_msgSend(v3, "length"))
    {
      objc_msgSend(*(id *)(*(_QWORD *)(a1[6] + 8) + 40), "addObject:", v3);
    }
    else
    {
      v6 = *__error();
      _sa_logt();
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v8 = 0;
        _os_log_error_impl(&dword_1B9BE0000, v7, OS_LOG_TYPE_ERROR, "0-length stackshot chunk", v8, 2u);
      }

      *__error() = v6;
    }

  }
  else
  {
    v5 = (void *)a1[4];
    if (v5)
      objc_msgSend(v5, "addObject:", CFSTR("Unable to get data for stackshot chunk"));
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_220(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;

  DictForChunkViaNSUnarchiver();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v2;
  if (v2)
  {
    -[SASampleStore addAddressTranslations:](*(_QWORD *)(a1 + 40), v2);
  }
  else
  {
    v3 = *(void **)(a1 + 32);
    if (v3)
      objc_msgSend(v3, "addObject:", CFSTR("Unable to get data for address translation chunk"));
  }

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_223(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  DictForChunkViaNSUnarchiver();
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = *(_QWORD *)(a1[6] + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

  if (!*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40))
  {
    v5 = (void *)a1[4];
    if (v5)
      objc_msgSend(v5, "addObject:", CFSTR("Unable to get data for resampled stacks chunk"));
  }
}

uint64_t __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_232(uint64_t a1)
{
  uint64_t result;

  result = ktrace_get_absolute_from_timestamp();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  SAFrameIterator *v9;
  void *v10;
  SAFrameIterator *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  void *v15;
  void *v16;
  BOOL v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  void *v22;
  void *v23;
  BOOL v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  char v29;
  void *v30;
  void *v31;
  id v32;
  void *v33;
  BOOL v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t j;
  void *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t k;
  _DWORD *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  int v49;
  const char *v50;
  id Property;
  const char *v52;
  void *v53;
  id v54;
  uint64_t v55;
  void *m;
  void *v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t n;
  _DWORD *v62;
  void *v63;
  uint64_t v64;
  void *v65;
  void *v66;
  int v67;
  void *v68;
  void *v69;
  BOOL v70;
  void *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  id v76;
  uint64_t v77;
  id v78;
  id v79;
  uint64_t v80;
  id obj;
  id obja;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  _DWORD *v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  _QWORD v107[5];
  _QWORD v108[5];
  SAFrameIterator *v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  _QWORD v114[5];
  id v115;
  uint64_t v116;
  char v117;
  _BYTE v118[128];
  _BYTE v119[128];
  _BYTE v120[128];
  _BYTE v121[128];
  _BYTE v122[128];
  _BYTE v123[128];
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(*(id *)(a1 + 32), "dataStyle") == 1 || !objc_msgSend(*(id *)(a1 + 32), "dataStyle"))
  {
    if (!objc_msgSend(*(id *)(a1 + 32), "isEmpty"))
      goto LABEL_4;
LABEL_28:
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
    return;
  }
  objc_msgSend(*(id *)(a1 + 32), "sampleTimestamps");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "count");

  if (!v3)
    goto LABEL_28;
LABEL_4:
  v112 = 0u;
  v113 = 0u;
  v110 = 0u;
  v111 = 0u;
  v4 = *(id *)(a1 + 48);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v110, v123, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v111;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v111 != v6)
          objc_enumerationMutation(v4);
        objc_msgSend(*(id *)(a1 + 32), "addProcessInfoFromTailspin:", *(_QWORD *)(*((_QWORD *)&v110 + 1) + 8 * i));
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v110, v123, 16);
    }
    while (v5);
  }

  v8 = MEMORY[0x1E0C809B0];
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40))
  {
    v9 = objc_alloc_init(SAFrameIterator);
    -[SAFrameIterator setBacktracer:](v9, "setBacktracer:", 3);
    v10 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40);
    v108[0] = v8;
    v108[1] = 3221225472;
    v108[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5;
    v108[3] = &unk_1E7147C88;
    v108[4] = *(_QWORD *)(a1 + 32);
    v11 = v9;
    v109 = v11;
    objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", v108);

  }
  if (!*(_BYTE *)(a1 + 104))
  {
    if (objc_msgSend(*(id *)(a1 + 32), "dataStyle") == 3 || objc_msgSend(*(id *)(a1 + 32), "dataStyle") == 4)
      objc_msgSend(*(id *)(a1 + 32), "enumerateTasks:", &__block_literal_global_235);
    objc_msgSend(*(id *)(a1 + 32), "enumerateTasks:", &__block_literal_global_237);
    v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
    if (v12 < objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40), "count"))
    {
      v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
      v14 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40), "count");
      while (v13 < v14)
      {
        +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, 0.0);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(*(id *)(a1 + 32), "dataStyle") != 3
          || (objc_msgSend(*(id *)(a1 + 32), "sampleTimestamps"),
              v16 = (void *)objc_claimAutoreleasedReturnValue(),
              v17 = objc_msgSend(v16, "count") == 0,
              v16,
              v17))
        {
          v20 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else
        {
          objc_msgSend(*(id *)(a1 + 32), "sampleTimestamps");
          v18 = (void *)objc_claimAutoreleasedReturnValue();
          v19 = objc_msgSend(v18, "count");

          v20 = v19 - 1;
        }
        v21 = *(_QWORD *)(a1 + 32);
        objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40), "objectAtIndexedSubscript:", v13);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:](v21, v22, v15, v20, 0, 1u, 1);

        objc_msgSend(*(id *)(a1 + 32), "endTime");
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        v24 = v23 == 0;

        if (!v24)
        {
          objc_msgSend(*(id *)(a1 + 32), "endTime");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v15, "guessMissingTimesBasedOnTimestamp:", v25);

        }
        v14 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40), "count");
        ++v13;
      }
    }
  }
  +[SATimestamp timestampWithMachAbsTime:machContTime:wallTime:machTimebase:](SATimestamp, "timestampWithMachAbsTime:machContTime:wallTime:machTimebase:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24), 0, objc_msgSend(*(id *)(a1 + 32), "machTimebase"), 0.0);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = *(void **)(a1 + 32);
  v28 = *(_QWORD *)(a1 + 96);
  v29 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24);
  v78 = v26;
  if (v27)
  {
    v30 = (void *)MEMORY[0x1BCCCC288]();
    objc_msgSend(v27, "tasksByPid");
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    v114[0] = v8;
    v114[1] = 3221225472;
    v114[2] = __116__SASampleStore_KPerf__addLoadInfoFromKTrace_lastKTraceEventTimestamp_checkForNewLoadInfosEvenWithExistingLoadInfo___block_invoke;
    v114[3] = &unk_1E7147B00;
    v114[4] = v27;
    v32 = v78;
    v117 = v29 ^ 1;
    v115 = v32;
    v116 = v28;
    objc_msgSend(v31, "enumerateKeysAndObjectsUsingBlock:", v114);

    objc_autoreleasePoolPop(v30);
  }

  objc_msgSend(*(id *)(a1 + 32), "sharedCaches");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = objc_msgSend(v33, "count") == 0;

  if (!v34)
  {
    objc_msgSend(*(id *)(a1 + 32), "tasksByPid");
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    v107[0] = v8;
    v107[1] = 3221225472;
    v107[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5_240;
    v107[3] = &unk_1E7147D38;
    v107[4] = *(_QWORD *)(a1 + 32);
    objc_msgSend(v35, "enumerateKeysAndObjectsUsingBlock:", v107);

  }
  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  objc_msgSend(*(id *)(a1 + 32), "hidEvents");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  obj = v36;
  v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v103, v122, 16);
  if (v37)
  {
    v83 = *(_QWORD *)v104;
    do
    {
      v85 = v37;
      for (j = 0; j != v85; ++j)
      {
        if (*(_QWORD *)v104 != v83)
          objc_enumerationMutation(obj);
        v39 = *(void **)(*((_QWORD *)&v103 + 1) + 8 * j);
        v99 = 0u;
        v100 = 0u;
        v101 = 0u;
        v102 = 0u;
        objc_msgSend(v39, "steps");
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        v41 = objc_msgSend(v40, "countByEnumeratingWithState:objects:count:", &v99, v121, 16);
        if (v41)
        {
          v42 = *(_QWORD *)v100;
          do
          {
            for (k = 0; k != v41; ++k)
            {
              if (*(_QWORD *)v100 != v42)
                objc_enumerationMutation(v40);
              v44 = *(_DWORD **)(*((_QWORD *)&v99 + 1) + 8 * k);
              if (objc_msgSend(v44, "pid") == -1 && objc_msgSend(v44, "tid"))
              {
                v45 = *(void **)(a1 + 32);
                v46 = objc_msgSend(v44, "tid");
                objc_msgSend(v44, "timestamp");
                v47 = (void *)objc_claimAutoreleasedReturnValue();
                -[SASampleStore taskWithPid:orTid:atTimestamp:](v45, 0xFFFFFFFFLL, v46, v47);
                v48 = (void *)objc_claimAutoreleasedReturnValue();

                if (v48)
                {
                  v49 = objc_msgSend(v48, "pid");
                  if (v44)
                    v44[3] = v49;
                }

              }
            }
            v41 = objc_msgSend(v40, "countByEnumeratingWithState:objects:count:", &v99, v121, 16);
          }
          while (v41);
        }

      }
      v36 = obj;
      v37 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v103, v122, 16);
    }
    while (v37);
  }

  v97 = 0u;
  v98 = 0u;
  v95 = 0u;
  v96 = 0u;
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v50, 64, 1);
  v76 = Property;
  v74 = objc_msgSend(v76, "countByEnumeratingWithState:objects:count:", &v95, v120, 16);
  if (v74)
  {
    v75 = *(_QWORD *)v96;
    do
    {
      v77 = 0;
      do
      {
        if (*(_QWORD *)v96 != v75)
          objc_enumerationMutation(v76);
        v53 = *(void **)(*((_QWORD *)&v95 + 1) + 8 * v77);
        v91 = 0u;
        v92 = 0u;
        v93 = 0u;
        v94 = 0u;
        if (v53)
          v54 = objc_getProperty(v53, v52, 8, 1);
        else
          v54 = 0;
        v86 = v53;
        v79 = v54;
        v55 = objc_msgSend(v79, "countByEnumeratingWithState:objects:count:", &v91, v119, 16);
        if (v55)
        {
          v80 = *(_QWORD *)v92;
          do
          {
            obja = (id)v55;
            for (m = 0; m != obja; m = (char *)m + 1)
            {
              if (*(_QWORD *)v92 != v80)
                objc_enumerationMutation(v79);
              v57 = *(void **)(*((_QWORD *)&v91 + 1) + 8 * (_QWORD)m);
              v87 = 0u;
              v88 = 0u;
              v89 = 0u;
              v90 = 0u;
              v84 = v57;
              objc_msgSend(v57, "steps", v74);
              v58 = (void *)objc_claimAutoreleasedReturnValue();
              v59 = objc_msgSend(v58, "countByEnumeratingWithState:objects:count:", &v87, v118, 16);
              if (v59)
              {
                v60 = *(_QWORD *)v88;
                do
                {
                  for (n = 0; n != v59; ++n)
                  {
                    if (*(_QWORD *)v88 != v60)
                      objc_enumerationMutation(v58);
                    v62 = *(_DWORD **)(*((_QWORD *)&v87 + 1) + 8 * n);
                    if (objc_msgSend(v62, "pid") == -1 && objc_msgSend(v62, "tid"))
                    {
                      v63 = *(void **)(a1 + 32);
                      v64 = objc_msgSend(v62, "tid");
                      objc_msgSend(v62, "timestamp");
                      v65 = (void *)objc_claimAutoreleasedReturnValue();
                      -[SASampleStore taskWithPid:orTid:atTimestamp:](v63, 0xFFFFFFFFLL, v64, v65);
                      v66 = (void *)objc_claimAutoreleasedReturnValue();

                      if (v66)
                      {
                        v67 = objc_msgSend(v66, "pid");
                        if (v62)
                          v62[3] = v67;
                      }

                    }
                  }
                  v59 = objc_msgSend(v58, "countByEnumeratingWithState:objects:count:", &v87, v118, 16);
                }
                while (v59);
              }

              if (v86)
              {
                if (v86[4] == -1)
                {
                  objc_msgSend(v84, "steps");
                  v68 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v68, "lastObject");
                  v69 = (void *)objc_claimAutoreleasedReturnValue();
                  v70 = objc_msgSend(v69, "pid") == -1;

                  if (!v70)
                  {
                    objc_msgSend(v84, "steps");
                    v71 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v71, "lastObject");
                    v72 = (void *)objc_claimAutoreleasedReturnValue();
                    v86[4] = objc_msgSend(v72, "pid");

                  }
                }
              }
            }
            v55 = objc_msgSend(v79, "countByEnumeratingWithState:objects:count:", &v91, v119, 16);
          }
          while (v55);
        }

        ++v77;
      }
      while (v77 != v74);
      v73 = objc_msgSend(v76, "countByEnumeratingWithState:objects:count:", &v95, v120, 16);
      v74 = v73;
    }
    while (v73);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5(uint64_t a1, void *a2, void *a3)
{
  id v5;
  _BYTE *v6;
  _BYTE *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  id v13;
  _QWORD v14[4];
  _BYTE *v15;
  id v16;
  uint64_t dest;

  v13 = a2;
  v5 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      -[SASampleStore lastTaskWithPid:](*(_QWORD **)(a1 + 32), objc_msgSend(v13, "intValue"));
      v6 = (_BYTE *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      if (v6)
      {
        objc_msgSend(v6, "binaryLoadInfos");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(*(id *)(a1 + 40), "setUserBinaryLoadInfos:", v8);

        objc_msgSend(*(id *)(a1 + 40), "setAssumeUserBinaryLoadInfosContainMainBinary:", v7[73] & 1);
        objc_msgSend(v7, "sharedCache");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(*(id *)(a1 + 40), "setSharedCache:", v9);

        v10 = *(_QWORD *)(a1 + 32);
        if (v10)
          v11 = *(_QWORD *)(v10 + 192);
        else
          v11 = 0;
        objc_copyStruct(&dest, v7 + 288, 8, 1, 0);
        if (v11)
        {
          if (dest)
          {
            CSArchitectureGetFamily();
            CSArchitectureGetFamily();
            if ((CSArchitectureMatchesArchitecture() & 1) == 0)
            {
              -[SASampleStore addressTranslationsForPid:](*(_QWORD *)(a1 + 32), objc_msgSend(v7, "pid"));
              v12 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(*(id *)(a1 + 40), "setAddressTranslations:", v12);

            }
          }
        }
        v14[0] = MEMORY[0x1E0C809B0];
        v14[1] = 3221225472;
        v14[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_6;
        v14[3] = &unk_1E7147C60;
        v15 = v7;
        v16 = *(id *)(a1 + 40);
        objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v14);
        objc_msgSend(*(id *)(a1 + 40), "clearTaskData");

      }
    }
  }

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_6(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  const char *v9;
  id Property;
  id v11;
  void *v12;
  unint64_t i;
  void *v14;
  const char *v15;
  void *v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  unsigned int v22;
  id v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend(*(id *)(a1 + 32), "threads");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "objectForKeyedSubscript:", v5);
      v8 = (void *)objc_claimAutoreleasedReturnValue();

      if (v8)
        Property = objc_getProperty(v8, v9, 48, 1);
      else
        Property = 0;
      v11 = Property;

      if (!v11)
      {
        v12 = malloc_type_calloc(objc_msgSend(v6, "count"), 8uLL, 0x100004000313F17uLL);
        for (i = 0; i < objc_msgSend(v6, "count"); ++i)
        {
          objc_msgSend(v6, "objectAtIndexedSubscript:", i);
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            free(v12);

            goto LABEL_18;
          }
          *((_QWORD *)v12 + i) = objc_msgSend(v14, "unsignedLongLongValue");

        }
        objc_msgSend(*(id *)(a1 + 40), "setUserFrames:", v12);
        objc_msgSend(*(id *)(a1 + 40), "setNumUserFrames:", objc_msgSend(v6, "count"));
        -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:](*(_QWORD *)(a1 + 32), *(void **)(a1 + 40), 0);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        if (v16)
        {
          if (v8)
            objc_setProperty_atomic(v8, v15, v16, 48);
        }
        else
        {
          v17 = *__error();
          _sa_logt();
          v18 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(*(id *)(a1 + 32), "debugDescription");
            v23 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v19 = objc_msgSend(v23, "UTF8String");
            objc_msgSend(v8, "debugDescription");
            v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v21 = objc_msgSend(v20, "UTF8String");
            v22 = objc_msgSend(*(id *)(a1 + 40), "numUserFrames");
            *(_DWORD *)buf = 136315650;
            v25 = v19;
            v26 = 2080;
            v27 = v21;
            v28 = 2048;
            v29 = v22;
            _os_log_error_impl(&dword_1B9BE0000, v18, OS_LOG_TYPE_ERROR, "%s %s unable to add resampled stack with %lu frames", buf, 0x20u);

          }
          *__error() = v17;
        }
        objc_msgSend(*(id *)(a1 + 40), "clearThreadData");

      }
LABEL_18:

    }
  }

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_234(uint64_t a1, uint64_t a2)
{
  -[SATask fixupThreadSuspension](a2);
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_236(uint64_t a1, void *a2)
{
  id v2;
  void *v3;
  id v4;
  _QWORD v5[4];
  id v6;

  v2 = a2;
  objc_msgSend(v2, "threads");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_238;
  v5[3] = &unk_1E7147920;
  v4 = v2;
  v6 = v4;
  objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v5);

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_238(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  _QWORD v5[4];
  id v6;
  _QWORD *v7;
  _QWORD v8[5];
  id v9;

  v4 = a3;
  if (objc_msgSend(*(id *)(a1 + 32), "pid"))
  {
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x3032000000;
    v8[3] = __Block_byref_object_copy__1;
    v8[4] = __Block_byref_object_dispose__1;
    v9 = 0;
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4_239;
    v5[3] = &unk_1E7147D10;
    v7 = v8;
    v6 = *(id *)(a1 + 32);
    objc_msgSend(v4, "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", 0, 0x7FFFFFFFFFFFFFFFLL, 0, 0x7FFFFFFFFFFFFFFFLL, 1, v5);

    _Block_object_dispose(v8, 8);
  }

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4_239(uint64_t a1, void *a2)
{
  void *v3;
  const char *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  id self;

  self = a2;
  objc_msgSend(self, "leafUserFrame");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v3)
  {
    v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    if (!v5)
    {
      -[SATask truncatedUserStackFrameSwiftAsync:](*(SAFrame **)(a1 + 32), 0);
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v8 = *(void **)(v7 + 40);
      *(_QWORD *)(v7 + 40) = v6;

      v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    }
    if (self)
      objc_setProperty_atomic(self, v4, v5, 64);
  }

}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5_240(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  _BYTE *v10;
  void *v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  const char *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t j;
  _BYTE *v23;
  void *v24;
  _BOOL4 v25;
  const char *v26;
  int v27;
  NSObject *v28;
  const char *v29;
  id Property;
  id v31;
  BOOL v32;
  const char *v33;
  id v34;
  id v35;
  int v36;
  NSObject *v37;
  const char *v38;
  void *v39;
  int v40;
  NSObject *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  id v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  char v55;
  void *v56;
  void *v57;
  void *v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint8_t v67[128];
  uint8_t buf[4];
  void *v69;
  __int16 v70;
  void *v71;
  __int16 v72;
  uint64_t v73;
  _BYTE v74[128];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v49 = a3;
  v50 = v4;
  if (objc_msgSend(v4, "intValue") && objc_msgSend(v4, "intValue") != -1)
  {
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    objc_msgSend(v49, "reverseObjectEnumerator");
    v5 = (id)objc_claimAutoreleasedReturnValue();
    v6 = 0;
    v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v63, v74, 16);
    if (!v7)
      goto LABEL_50;
    v55 = 0;
    v8 = *(_QWORD *)v64;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v64 != v8)
          objc_enumerationMutation(v5);
        v10 = *(_BYTE **)(*((_QWORD *)&v63 + 1) + 8 * i);
        if (!v10 || (v10[72] & 1) == 0)
        {
          objc_msgSend(*(id *)(*((_QWORD *)&v63 + 1) + 8 * i), "sharedCache");
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          v12 = v11 == 0;

          if (v12)
          {
            if (v6)
            {
              v14 = *__error();
              _sa_logt();
              v15 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v10, "debugDescription");
                v51 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v6, "uuid");
                v17 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v17, "UUIDString");
                v18 = (void *)objc_claimAutoreleasedReturnValue();
                v19 = objc_msgSend(v6, "slide");
                *(_DWORD *)buf = 138412802;
                v69 = v51;
                v70 = 2112;
                v71 = v18;
                v72 = 2048;
                v73 = v19;
                _os_log_debug_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_DEBUG, "%@: guessing shared cache based on later tasks with the same pid: UUID:%@ slide=0x%0llX", buf, 0x20u);

              }
              *__error() = v14;
              if (v10)
                objc_setProperty_atomic(v10, v16, v6, 256);
            }
            else
            {
              v55 = 1;
            }
          }
          else
          {
            objc_msgSend(v10, "sharedCache");
            v13 = objc_claimAutoreleasedReturnValue();

            v6 = (void *)v13;
          }
        }
      }
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v63, v74, 16);
    }
    while (v7);

    if ((v55 & 1) != 0)
    {
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v5 = v49;
      v20 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v59, v67, 16);
      if (!v20)
        goto LABEL_50;
      v21 = *(_QWORD *)v60;
      while (1)
      {
        for (j = 0; j != v20; ++j)
        {
          if (*(_QWORD *)v60 != v21)
            objc_enumerationMutation(v5);
          v23 = *(_BYTE **)(*((_QWORD *)&v59 + 1) + 8 * j);
          if (!v23 || (v23[72] & 1) == 0)
          {
            objc_msgSend(*(id *)(*((_QWORD *)&v59 + 1) + 8 * j), "sharedCache");
            v24 = (void *)objc_claimAutoreleasedReturnValue();
            v25 = v24 == 0;

            if (v25)
            {
              if (!v6)
              {
                Property = *(id *)(a1 + 32);
                if (Property)
                  Property = objc_getProperty(Property, v26, 1024, 1);
                v31 = Property;
                v32 = v31 == 0;

                v34 = *(id *)(a1 + 32);
                if (v32)
                {
                  objc_msgSend(v34, "sharedCaches");
                  v39 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v39, "firstObject");
                  v35 = (id)objc_claimAutoreleasedReturnValue();

                  v40 = *__error();
                  _sa_logt();
                  v41 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
                  {
                    objc_msgSend(v23, "debugDescription");
                    v58 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v35, "uuid");
                    v53 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v53, "UUIDString");
                    v47 = (void *)objc_claimAutoreleasedReturnValue();
                    v48 = objc_msgSend(v35, "slide");
                    *(_DWORD *)buf = 138412802;
                    v69 = v58;
                    v70 = 2112;
                    v71 = v47;
                    v72 = 2048;
                    v73 = v48;
                    _os_log_debug_impl(&dword_1B9BE0000, v41, OS_LOG_TYPE_DEBUG, "%@: guessing first shared cache: UUID:%@ slide=0x%0llX", buf, 0x20u);

                  }
                  *__error() = v40;
                  if (v23)
LABEL_46:
                    objc_setProperty_atomic(v23, v38, v35, 256);
                }
                else
                {
                  if (v34)
                    v34 = objc_getProperty(v34, v33, 1024, 1);
                  v35 = v34;
                  v36 = *__error();
                  _sa_logt();
                  v37 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                  {
                    objc_msgSend(v23, "debugDescription");
                    v57 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v35, "uuid");
                    v52 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v52, "UUIDString");
                    v45 = (void *)objc_claimAutoreleasedReturnValue();
                    v46 = objc_msgSend(v35, "slide");
                    *(_DWORD *)buf = 138412802;
                    v69 = v57;
                    v70 = 2112;
                    v71 = v45;
                    v72 = 2048;
                    v73 = v46;
                    _os_log_debug_impl(&dword_1B9BE0000, v37, OS_LOG_TYPE_DEBUG, "%@: guessing native shared cache: UUID:%@ slide=0x%0llX", buf, 0x20u);

                  }
                  *__error() = v36;
                  if (v23)
                    goto LABEL_46;
                }

                continue;
              }
              v27 = *__error();
              _sa_logt();
              v28 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v23, "debugDescription");
                v56 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v6, "uuid");
                v42 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v42, "UUIDString");
                v43 = (void *)objc_claimAutoreleasedReturnValue();
                v44 = objc_msgSend(v6, "slide");
                *(_DWORD *)buf = 138412802;
                v69 = v56;
                v70 = 2112;
                v71 = v43;
                v72 = 2048;
                v73 = v44;
                _os_log_debug_impl(&dword_1B9BE0000, v28, OS_LOG_TYPE_DEBUG, "%@: guessing shared cache based on earlier tasks with the same pid: UUID:%@ slide=0x%0llX", buf, 0x20u);

              }
              *__error() = v27;
              if (v23)
                objc_setProperty_atomic(v23, v29, v6, 256);
            }
          }
        }
        v20 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v59, v67, 16);
        if (!v20)
        {
LABEL_50:

          break;
        }
      }
    }

  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_241(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  unint64_t v11;
  void *v12;
  id v13;

  if ((unint64_t)ktrace_get_absolute_from_timestamp() >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8)
                                                                           + 24))
  {
    +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, 0.0);
    v13 = (id)objc_claimAutoreleasedReturnValue();
    v2 = objc_msgSend(*(id *)(a1 + 32), "dataStyle");
    if (v2 == 3)
    {
      objc_msgSend(*(id *)(a1 + 32), "sampleTimestamps");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      v3 = objc_msgSend(v4, "count");

    }
    else
    {
      v3 = 0x7FFFFFFFFFFFFFFFLL;
    }
    v5 = *(_QWORD *)(a1 + 32);
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), "objectAtIndexedSubscript:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:](v5, v6, v13, v3, 0, 1u, v2 != 3);

    objc_msgSend(*(id *)(a1 + 32), "endTime");
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      objc_msgSend(*(id *)(a1 + 32), "endTime");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "guessMissingTimesBasedOnTimestamp:", v9);

    }
    if (v2 == 3)
    {
      if (v7)
      {
        v10 = *(_QWORD *)(a1 + 32);
        if (v10)
          objc_msgSend(*(id *)(v10 + 24), "addObject:", v13);
      }
    }
    v11 = ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
    if (v11 >= objc_msgSend(*(id *)(a1 + 40), "count"))
    {
      if (*(_BYTE *)(a1 + 80))
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = -1;
      else
        ktrace_end();
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 40), "objectAtIndexedSubscript:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = objc_msgSend(v12, "unsignedLongLongValue");

    }
  }
}

- (void)forwardFillFromLastStackshot:(void *)a1
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  void *v14;
  id v15;
  void *v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[4];
  id v30;
  void *v31;
  id v32;
  unint64_t v33;
  uint64_t v34;
  uint8_t buf[4];
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "dataSource") != 2)
  {
    v20 = *__error();
    _sa_logt();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v36 = objc_msgSend(a1, "dataSource");
      _os_log_error_impl(&dword_1B9BE0000, v21, OS_LOG_TYPE_ERROR, "data source 0x%llx", buf, 0xCu);
    }

    *__error() = v20;
    v22 = objc_msgSend(a1, "dataSource");
    _SASetCrashLogMessage(3685, "data source 0x%llx", v23, v24, v25, v26, v27, v28, v22);
    _os_crash();
    __break(1u);
  }
  objc_msgSend(a1, "sampleTimestamps");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "count");

  if (v5)
  {
    objc_msgSend(a1, "sampleTimestamps");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = objc_msgSend(v6, "count");

    objc_msgSend(a1, "sampleTimestamps");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "lastObject");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    if (objc_msgSend(v9, "machAbsTime") <= a2)
    {
LABEL_14:

      return;
    }
    +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", a2, 0, 0.0, 0.0, 0.0);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_msgSend(a1, "indexOfLastSampleOnOrBeforeTimestamp:", v10);
    if (v11 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v12 = *__error();
      _sa_logt();
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B9BE0000, v13, OS_LOG_TYPE_DEFAULT, "WARNING: Cannot forward-fill from last stackshot because there was no KPerf sample before the stackshot", buf, 2u);
      }

      *__error() = v12;
      goto LABEL_13;
    }
    objc_msgSend(a1, "sampleTimestamps");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "objectAtIndexedSubscript:", v11);
    v15 = (id)objc_claimAutoreleasedReturnValue();

    if (objc_msgSend(v15, "machAbsTime") == a2)
    {
      if (!v11)
      {
        v18 = *__error();
        _sa_logt();
        v19 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B9BE0000, v19, OS_LOG_TYPE_DEFAULT, "WARNING: Cannot forward-fill from last stackshot because there was no KPerf sample before the stackshot", buf, 2u);
        }

        *__error() = v18;
        goto LABEL_12;
      }
      objc_msgSend(a1, "sampleTimestamps");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "objectAtIndexedSubscript:", v11 - 1);
      v17 = objc_claimAutoreleasedReturnValue();

      v15 = (id)v17;
    }
    v29[0] = MEMORY[0x1E0C809B0];
    v29[1] = 3221225472;
    v29[2] = __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke;
    v29[3] = &unk_1E7147E18;
    v33 = a2;
    v30 = v9;
    v31 = a1;
    v34 = v7 - 1;
    v15 = v15;
    v32 = v15;
    objc_msgSend(a1, "enumerateTasks:", v29);

LABEL_12:
LABEL_13:

    goto LABEL_14;
  }
}

void __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *v19;
  int v20;
  const char *v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  id v26;
  _QWORD v27[4];
  id v28;
  uint64_t v29;
  id v30;
  id v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint8_t buf[4];
  unint64_t v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v26 = a2;
  objc_msgSend(v26, "exitTimestamp");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (!v3)
    goto LABEL_9;
  if ((unint64_t)objc_msgSend(v3, "machAbsTime") <= *(_QWORD *)(a1 + 56))
  {
    v5 = 0;
    goto LABEL_15;
  }
  if (!objc_msgSend(v4, "lt:", *(_QWORD *)(a1 + 32)))
    goto LABEL_9;
  v5 = v4;
  v6 = objc_msgSend(*(id *)(a1 + 40), "indexOfLastSampleOnOrBeforeTimestamp:", v5);
  v7 = v6;
  if (v6 == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_15;
  if (v6 > *(_QWORD *)(a1 + 64))
  {
    v8 = *__error();
    _sa_logt();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)buf = 134218240;
      v36 = v7;
      v37 = 2048;
      v38 = v10;
      _os_log_error_impl(&dword_1B9BE0000, v9, OS_LOG_TYPE_ERROR, "%lu < %lu", buf, 0x16u);
    }

    *__error() = v8;
    _SASetCrashLogMessage(3735, "%lu < %lu", v11, v12, v13, v14, v15, v16, v7);
    _os_crash();
    __break(1u);
LABEL_9:
    v7 = *(_QWORD *)(a1 + 64);
    v5 = *(id *)(a1 + 32);
  }
  objc_msgSend(v26, "taskStates");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "lastObject");
  v18 = (_QWORD *)objc_claimAutoreleasedReturnValue();

  if (v18)
  {
    objc_msgSend(v18, "startTimestamp");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = objc_msgSend(v19, "lt:", *(_QWORD *)(a1 + 48));

    if (v20)
    {
      v18[7] = v7;
      objc_setProperty_atomic(v18, v21, v5, 40);
    }
  }
  objc_msgSend(v26, "threads");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 3221225472;
  v27[2] = __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke_266;
  v27[3] = &unk_1E7147DF0;
  v32 = *(_QWORD *)(a1 + 56);
  v23 = v5;
  v24 = *(_QWORD *)(a1 + 40);
  v25 = *(void **)(a1 + 48);
  v28 = v23;
  v29 = v24;
  v33 = *(_QWORD *)(a1 + 64);
  v34 = v7;
  v30 = v25;
  v31 = v26;
  objc_msgSend(v22, "enumerateKeysAndObjectsUsingBlock:", v27);

  v5 = v23;
LABEL_15:

}

void __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke_266(uint64_t a1, void *a2, void *a3)
{
  id v5;
  void *v6;
  void *v7;
  id v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  int v24;
  SEL v25;
  void *v26;
  void *v27;
  int v28;
  unint64_t v29;
  void *v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  unint64_t v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v42;
  void *v43;
  id *v44;
  const char *v45;
  void *v46;
  void *v47;
  SEL v48;
  void *v49;
  id v50;
  void *v51;
  id v52;
  NSObject *v53;
  id v54;
  id v55;
  uint64_t v56;
  void *v57;
  id v58;
  id v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  NSObject *v66;
  id v67;
  id v68;
  uint64_t v69;
  void *v70;
  id v71;
  id v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  NSObject *v79;
  id v80;
  id v81;
  uint64_t v82;
  void *v83;
  id v84;
  id v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  void *v95;
  void *v96;
  void *v97;
  uint64_t v98;
  char v99;
  uint64_t v100;
  char v101;
  uint64_t v102;
  char v103;
  id newValue;
  id v105;
  id obj;
  id v107;
  uint8_t buf[4];
  unint64_t v109;
  __int16 v110;
  uint64_t v111;
  __int16 v112;
  uint64_t v113;
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  v107 = a2;
  v5 = a3;
  objc_msgSend(v5, "exitTimestamp");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (!v6)
    goto LABEL_10;
  if ((unint64_t)objc_msgSend(v6, "machAbsTime") <= *(_QWORD *)(a1 + 64))
  {
    v8 = 0;
    goto LABEL_20;
  }
  if (!objc_msgSend(v7, "lt:", *(_QWORD *)(a1 + 32)))
    goto LABEL_10;
  v8 = v7;
  v9 = objc_msgSend(*(id *)(a1 + 40), "indexOfLastSampleOnOrBeforeTimestamp:", v8);
  v10 = v9;
  if (v9 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v9 <= *(_QWORD *)(a1 + 72) && v9 <= *(_QWORD *)(a1 + 80))
    {
LABEL_11:
      objc_msgSend(v5, "threadStates");
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v21, "lastObject");
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      if (v22
        && (objc_msgSend(v22, "startTimestamp"),
            v23 = (void *)objc_claimAutoreleasedReturnValue(),
            v24 = objc_msgSend(v23, "lt:", *(_QWORD *)(a1 + 48)),
            v23,
            v24))
      {
        -[SAThreadState setEndSampleIndex:]((uint64_t)v22, v10);
        objc_setProperty_atomic(v22, v25, v8, 56);
      }
      else
      {
        objc_msgSend(v5, "threadStates");
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        if ((unint64_t)objc_msgSend(v26, "count") >= 2)
        {
          objc_msgSend(v22, "leafUserFrame");
          v27 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v27)
          {
            v28 = objc_msgSend(*(id *)(a1 + 56), "pid");

            if (v28)
            {
              v29 = objc_msgSend(v22, "cpuTimeNs");
              if (v29)
              {
                objc_msgSend(v5, "threadStates");
                v30 = (void *)objc_claimAutoreleasedReturnValue();
                v31 = objc_msgSend(v30, "count");

                while (1)
                {
                  v32 = v31 - 1;
                  if (v31 == 1)
                    break;
                  objc_msgSend(v5, "threadStates");
                  v33 = (void *)objc_claimAutoreleasedReturnValue();
                  v34 = v31 - 2;
                  objc_msgSend(v33, "objectAtIndexedSubscript:", v34);
                  v35 = (void *)objc_claimAutoreleasedReturnValue();
                  v36 = objc_msgSend(v35, "cpuTimeNs");

                  if (v36 < v29)
                    break;
                  objc_msgSend(v5, "threadStates");
                  v37 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v37, "objectAtIndexedSubscript:", v34);
                  v38 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v38, "leafUserFrame");
                  v39 = (void *)objc_claimAutoreleasedReturnValue();

                  v31 = v32;
                  if (v39)
                  {
                    if (v32 == 0x8000000000000000)
                      goto LABEL_18;
                    objc_msgSend(v5, "threadStates");
                    v40 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v40, "objectAtIndexedSubscript:", v32 - 1);
                    v26 = (void *)objc_claimAutoreleasedReturnValue();

                    objc_msgSend(v26, "leafUserFrame");
                    v27 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v26, "leafOfCRootFramesReplacedBySwiftAsync");
                    newValue = (id)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v26, "dispatchQueue");
                    obj = (id)objc_claimAutoreleasedReturnValue();
                    objc_msgSend(v26, "swiftTask");
                    v105 = (id)objc_claimAutoreleasedReturnValue();
                    while (1)
                    {
                      objc_msgSend(v5, "threadStates");
                      v41 = (void *)objc_claimAutoreleasedReturnValue();
                      v42 = objc_msgSend(v41, "count");

                      if (v32 >= v42)
                        break;
                      objc_msgSend(v5, "threadStates");
                      v43 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v43, "objectAtIndexedSubscript:", v32);
                      v44 = (id *)objc_claimAutoreleasedReturnValue();

                      objc_msgSend(v44, "leafUserFrame");
                      v46 = (void *)objc_claimAutoreleasedReturnValue();
                      if (v46)
                      {
                        objc_msgSend(v44, "leafUserFrame");
                        v47 = (void *)objc_claimAutoreleasedReturnValue();

                        if (v47 != v27)
                        {
                          v92 = *__error();
                          _sa_logt();
                          v53 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                          {
                            objc_msgSend(v44, "leafUserFrame");
                            v95 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v95, "debugDescription");
                            v54 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v98 = objc_msgSend(v54, "UTF8String");
                            objc_msgSend(v27, "debugDescription");
                            v55 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v56 = objc_msgSend(v55, "UTF8String");
                            *(_DWORD *)buf = 136315394;
                            v109 = v98;
                            v110 = 2080;
                            v111 = v56;
                            _os_log_error_impl(&dword_1B9BE0000, v53, OS_LOG_TYPE_ERROR, "threadState.leafUserFrame %s != leafUserFrame %s", buf, 0x16u);

                          }
                          *__error() = v92;
                          objc_msgSend(v44, "leafUserFrame");
                          v57 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v57, "debugDescription");
                          v58 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          v99 = objc_msgSend(v58, "UTF8String");
                          objc_msgSend(v27, "debugDescription");
                          v59 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          objc_msgSend(v59, "UTF8String");
                          _SASetCrashLogMessage(3820, "threadState.leafUserFrame %s != leafUserFrame %s", v60, v61, v62, v63, v64, v65, v99);

                          _os_crash();
                          __break(1u);
LABEL_47:
                          v93 = *__error();
                          _sa_logt();
                          v66 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                          {
                            objc_msgSend(v44, "dispatchQueue");
                            v96 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v96, "debugDescription");
                            v67 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v100 = objc_msgSend(v67, "UTF8String");
                            objc_msgSend(obj, "debugDescription");
                            v68 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v69 = objc_msgSend(v68, "UTF8String");
                            *(_DWORD *)buf = 136315394;
                            v109 = v100;
                            v110 = 2080;
                            v111 = v69;
                            _os_log_error_impl(&dword_1B9BE0000, v66, OS_LOG_TYPE_ERROR, "threadState.dispatchQueue %s != dispatchQueue %s", buf, 0x16u);

                          }
                          *__error() = v93;
                          objc_msgSend(v44, "dispatchQueue");
                          v70 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v70, "debugDescription");
                          v71 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          v101 = objc_msgSend(v71, "UTF8String");
                          objc_msgSend(obj, "debugDescription");
                          v72 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          objc_msgSend(v72, "UTF8String");
                          _SASetCrashLogMessage(3823, "threadState.dispatchQueue %s != dispatchQueue %s", v73, v74, v75, v76, v77, v78, v101);

                          _os_crash();
                          __break(1u);
LABEL_50:
                          v94 = *__error();
                          _sa_logt();
                          v79 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                          {
                            objc_msgSend(v44, "swiftTask");
                            v97 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v97, "debugDescription");
                            v80 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v102 = objc_msgSend(v80, "UTF8String");
                            objc_msgSend(v105, "debugDescription");
                            v81 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                            v82 = objc_msgSend(v81, "UTF8String");
                            *(_DWORD *)buf = 136315394;
                            v109 = v102;
                            v110 = 2080;
                            v111 = v82;
                            _os_log_error_impl(&dword_1B9BE0000, v79, OS_LOG_TYPE_ERROR, "threadState.swiftTask %s != swiftTask %s", buf, 0x16u);

                          }
                          *__error() = v94;
                          objc_msgSend(v44, "swiftTask");
                          v83 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v83, "debugDescription");
                          v84 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          v103 = objc_msgSend(v84, "UTF8String");
                          objc_msgSend(v105, "debugDescription");
                          v85 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          objc_msgSend(v85, "UTF8String");
                          _SASetCrashLogMessage(3825, "threadState.swiftTask %s != swiftTask %s", v86, v87, v88, v89, v90, v91, v103);

                          _os_crash();
                          __break(1u);
                        }
                      }
                      if (v44)
                      {
                        objc_setProperty_atomic(v44, v45, v27, 64);
                        objc_setProperty_atomic(v44, v48, newValue, 72);
                      }
                      objc_msgSend(v44, "dispatchQueue");
                      v49 = (void *)objc_claimAutoreleasedReturnValue();
                      if (v49)
                      {
                        objc_msgSend(v44, "dispatchQueue");
                        v50 = (id)objc_claimAutoreleasedReturnValue();

                        if (v50 != obj)
                          goto LABEL_47;
                      }
                      if (v44)
                        objc_storeWeak(v44 + 14, obj);
                      objc_msgSend(v44, "swiftTask");
                      v51 = (void *)objc_claimAutoreleasedReturnValue();
                      if (v51)
                      {
                        objc_msgSend(v44, "swiftTask");
                        v52 = (id)objc_claimAutoreleasedReturnValue();

                        if (v52 != v105)
                          goto LABEL_50;
                      }
                      if (v44)
                        objc_storeWeak(v44 + 15, v105);

                      ++v32;
                    }

                    goto LABEL_16;
                  }
                }
              }
            }
            goto LABEL_18;
          }
LABEL_16:

        }
      }
LABEL_18:

      goto LABEL_20;
    }
    v11 = *__error();
    _sa_logt();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = *(_QWORD *)(a1 + 72);
      v14 = *(_QWORD *)(a1 + 80);
      *(_DWORD *)buf = 134218496;
      v109 = v10;
      v110 = 2048;
      v111 = v13;
      v112 = 2048;
      v113 = v14;
      _os_log_error_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_ERROR, "%lu < %lu, < %lu", buf, 0x20u);
    }

    *__error() = v11;
    _SASetCrashLogMessage(3769, "%lu < %lu, < %lu", v15, v16, v17, v18, v19, v20, v10);
    _os_crash();
    __break(1u);
LABEL_10:
    v10 = *(_QWORD *)(a1 + 80);
    v8 = *(id *)(a1 + 32);
    goto LABEL_11;
  }
LABEL_20:

}

void __616__SASampleStore_KPerfPrivate__backfillThread_inTask_lastSampleIndex_timestamp_haveName_name_haveDispatchQueueId_dispatchQueueId_dispatchQueueLabel_leafKernelFrame_hasExclaveInKernelStack_haveUserStack_leafUserFrame_swiftTaskId_leafOfCRootFramesReplacedBySwiftAsync_threadExclavesInfo_haveSched_systemCpuTimeNs_userCpuTimeNs_basePriority_scheduledPriority_state_threadQos_threadRequestedQos_threadRequestedQosOverride_threadQosPromote_haveCycIns_instructions_cycles_haveSnap_ioTier_isIOPassive_isDarwinBG_isSuspended_isGlobalForcedIdle_isIdleWorkQueue_lastMadeRunnableTime_isOnCore_isOnCoreForLastSampleIndex_cpuNum___block_invoke(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7;
  uint64_t v8;
  int v10;
  FILE *v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  const char *v16;
  char v17;
  uint64_t v18;
  int v19;
  const char *v20;
  int v21;
  FILE *v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  uint64_t v26;
  const char *v27;
  int v29;
  FILE *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  void *v34;
  void *v35;
  int v36;
  FILE *v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  int v42;
  uint64_t v43;
  const char *v44;
  id *v45;
  SEL v46;
  int v47;
  int v49;
  FILE *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  int v56;
  FILE *v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  id v76;
  const char *v77;
  char v78;
  char v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  id v89;
  const char *v90;
  int v91;
  FILE *v92;
  uint64_t v93;
  const char *v94;
  uint64_t v95;
  id Property;
  const char *v97;
  uint64_t v98;
  id v99;
  id v100;
  void *v101;
  const char *v102;
  void *v103;
  id v104;
  int v105;
  id v106;
  int v107;
  FILE *v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  id v112;
  const char *v113;
  uint64_t v114;
  id v115;
  void *v116;
  const char *v117;
  void *v118;
  id v119;
  id v120;
  uint64_t v121;
  int v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  FILE *v127;
  FILE *v128;
  id v129;
  uint64_t v130;
  id v131;
  _BYTE *v132;
  _BYTE *v133;
  id v134;
  _BYTE *v135;
  id v136;

  v136 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v7 = v136;
    v8 = (uint64_t)v7;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 24))
    {
      if ((objc_msgSend(v7, "filledName") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
        {
          v10 = *__error();
          v11 = (FILE *)qword_1ED1DD618;
          v12 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v13 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          objc_msgSend((id)v8, "name");
          v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v15 = objc_msgSend(v14, "UTF8String");
          v16 = "no name";
          if (v15)
            v16 = (const char *)v15;
          fprintf(v11, "%'llu Thread 0x%llx thread name %s backfilled to %d thread states (indexes %lu-%lu)\n", v12, v13, v16, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);

          *__error() = v10;
        }
        v17 = 0;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledName:", 1);
        if (v8)
          objc_setProperty_atomic_copy((id)v8, v20, *(id *)(a1 + 48), 104);
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v21 = *__error();
          v22 = (FILE *)qword_1ED1DD618;
          v23 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v24 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          objc_msgSend((id)v8, "name");
          v25 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v26 = objc_msgSend(v25, "UTF8String");
          v27 = "no name";
          if (v26)
            v27 = (const char *)v26;
          fprintf(v22, "%'llu Thread 0x%llx thread name %s backfilled to all (%d) thread states (indexes %lu-%lu)\n", v23, v24, v27, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));

          *__error() = v21;
          v17 = 1;
        }
      }
    }
    else
    {
      v17 = 0;
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 24))
    {
      if ((objc_msgSend((id)v8, "filledDispatchQueue") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
        {
          v29 = *__error();
          v30 = (FILE *)qword_1ED1DD618;
          v31 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v32 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          v33 = *(void **)(a1 + 56);
          if (v33)
            v33 = (void *)objc_msgSend(v33, "identifier");
          fprintf(v30, "%'llu Thread 0x%llx dispatch queue %lld backfilled to %d thread states (indexes %lu-%lu)\n", v31, v32, v33, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v29;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledDispatchQueue:", 1);
        v34 = *(void **)(a1 + 56);
        if (v8)
        {
          objc_storeWeak((id *)(v8 + 112), v34);
          v34 = *(void **)(a1 + 56);
        }
        if (v34)
        {
          +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, *(void **)(a1 + 40), a3);
          v35 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(*(id *)(a1 + 64), "insertObject:atIndex:", v35, 0);

        }
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v36 = *__error();
          v37 = (FILE *)qword_1ED1DD618;
          v38 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v39 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          v40 = *(void **)(a1 + 56);
          if (v40)
            v40 = (void *)objc_msgSend(v40, "identifier");
          fprintf(v37, "%'llu Thread 0x%llx dispatch queue %lld backfilled to all (%d) thread states (indexes %lu-%lu)\n", v38, v39, v40, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));
          *__error() = v36;
        }
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 152) + 8) + 24))
    {
      if ((objc_msgSend((id)v8, "filledUserStack") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
        {
          v42 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx user stack (leaf frame 0x%llx, swift async leaf 0x%llx) backfilled to %d thread states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), objc_msgSend(*(id *)(a1 + 72), "address"), objc_msgSend(*(id *)(a1 + 80), "address"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v42;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 152) + 8) + 24) = 0;
        v43 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8);
        if (*(_BYTE *)(v43 + 24) && *(_QWORD *)(a1 + 200) == -1)
          *(_BYTE *)(v43 + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledUserStack:", 1);
        if (v8)
        {
          objc_setProperty_atomic((id)v8, v44, *(id *)(a1 + 72), 64);
          v45 = (id *)(a1 + 80);
          objc_setProperty_atomic((id)v8, v46, *(id *)(a1 + 80), 72);
        }
        else
        {
          v45 = (id *)(a1 + 80);
        }
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v47 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx user stack (leaf frame 0x%llx, swift async leaf 0x%llx) backfilled to all (%d) thread states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), objc_msgSend(*(id *)(a1 + 72), "address"), objc_msgSend(*v45, "address"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));
          *__error() = v47;
          v17 = 1;
        }
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8) + 24))
    {
      if ((objc_msgSend((id)v8, "filledSwiftTask") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
        {
          v49 = *__error();
          v50 = (FILE *)qword_1ED1DD618;
          v51 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v52 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          v53 = *(void **)(a1 + 88);
          if (v53)
            v53 = (void *)objc_msgSend(v53, "identifier");
          fprintf(v50, "%'llu Thread 0x%llx swift task %lld backfilled to %d thread states (indexes %lu-%lu)\n", v51, v52, v53, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v49;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8) + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledSwiftTask:", 1);
        v54 = *(void **)(a1 + 88);
        if (v8)
        {
          objc_storeWeak((id *)(v8 + 120), v54);
          v54 = *(void **)(a1 + 88);
        }
        if (v54)
        {
          +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, *(void **)(a1 + 40), a3);
          v55 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(*(id *)(a1 + 96), "insertObject:atIndex:", v55, 0);

        }
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v56 = *__error();
          v57 = (FILE *)qword_1ED1DD618;
          v58 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v59 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          v60 = *(void **)(a1 + 88);
          if (v60)
            v60 = (void *)objc_msgSend(v60, "identifier");
          fprintf(v57, "%'llu Thread 0x%llx swift task %lld backfilled to all (%d) thread states (indexes %lu-%lu)\n", v58, v59, v60, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));
          *__error() = v56;
        }
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 168) + 8) + 24))
    {
      if ((objc_msgSend((id)v8, "filledScheduling") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
        {
          v62 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx sched info (cpu time %lld (%lld + %lld), state 0x%x, priority %d (%d), qos %d, rqos %d, qoso %d, qosp %d) backfilled to %d thread states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), *(_QWORD *)(a1 + 216) + *(_QWORD *)(a1 + 208), *(_QWORD *)(a1 + 208), *(_QWORD *)(a1 + 216), *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 248), *(_DWORD *)(a1 + 244), *(unsigned __int8 *)(a1 + 252), *(unsigned __int8 *)(a1 + 253), *(unsigned __int8 *)(a1 + 254), *(unsigned __int8 *)(a1 + 255), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v62;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 168) + 8) + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledScheduling:", 1);
        if (v8)
        {
          *(_QWORD *)(v8 + 144) = *(_QWORD *)(a1 + 208);
          *(_QWORD *)(v8 + 136) = *(_QWORD *)(a1 + 216);
          *(_DWORD *)(v8 + 40) = *(_DWORD *)(a1 + 240);
        }
        -[SAThreadState setBasePriority:]((int *)v8, *(_DWORD *)(a1 + 244));
        -[SAThreadState setScheduledPriority:]((int *)v8, *(_DWORD *)(a1 + 248));
        v63 = *(unsigned __int8 *)(a1 + 252);
        if (v63 != 125)
          -[SAThreadState setThreadQos:](v8, v63);
        v64 = *(unsigned __int8 *)(a1 + 253);
        if (v64 != 125)
          -[SAThreadState setThreadRequestedQos:](v8, v64);
        v65 = *(unsigned __int8 *)(a1 + 254);
        if (v65 != 125)
          -[SAThreadState setThreadRequestedQosOverride:](v8, v65);
        v66 = *(unsigned __int8 *)(a1 + 255);
        if (v66 != 125)
          -[SAThreadState setThreadQosPromote:](v8, v66);
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v67 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx sched info (cpu time %lld (%lld + %lld), state 0x%x, priority %d (%d), qos %d, rqos %d, qoso %d, qosp %d) backfilled to all (%d) thread states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), *(_QWORD *)(a1 + 216) + *(_QWORD *)(a1 + 208), *(_QWORD *)(a1 + 208), *(_QWORD *)(a1 + 216), *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 248), *(_DWORD *)(a1 + 244), *(unsigned __int8 *)(a1 + 252), *(unsigned __int8 *)(a1 + 253), *(unsigned __int8 *)(a1 + 254), *(unsigned __int8 *)(a1 + 255), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));
          *__error() = v67;
        }
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 8) + 24))
    {
      if ((objc_msgSend((id)v8, "filledCyclesInstructions") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618)
        {
          v68 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx thread instructions (%llu) cycles (%llu) backfilled to %d thread states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), *(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 232), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v68;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 8) + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledCyclesInstructions:", 1);
        if (v8)
        {
          *(_QWORD *)(v8 + 152) = *(_QWORD *)(a1 + 224);
          *(_QWORD *)(v8 + 160) = *(_QWORD *)(a1 + 232);
        }
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v69 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx thread instructions (%llu) cycles (%llu) backfilled to all (%d) thread states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), *(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 232), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));
          *__error() = v69;
        }
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 184) + 8) + 24))
    {
      if ((objc_msgSend((id)v8, "filledSnapshot") & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618)
        {
          v130 = a3;
          v132 = a4;
          v122 = *__error();
          v127 = (FILE *)qword_1ED1DD618;
          v124 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v121 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          v70 = *(unsigned __int8 *)(a1 + 256);
          v71 = *(unsigned __int8 *)(a1 + 257);
          v72 = *(unsigned __int8 *)(a1 + 258);
          v73 = *(unsigned __int8 *)(a1 + 259);
          v74 = *(unsigned __int8 *)(a1 + 260);
          v75 = *(unsigned __int8 *)(a1 + 261);
          objc_msgSend(*(id *)(a1 + 104), "debugDescription");
          v76 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          fprintf(v127, "%'llu Thread 0x%llx snapshot info (io tier %d, passive %d, suspended %d, darwinbg %d, idlewq %d, gfi %d, runnable %s) backfilled to %d thread states (indexes %lu-%lu)\n", v124, v121, v70, v71, v72, v73, v74, v75, (const char *)objc_msgSend(v76, "UTF8String"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), v130 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + v130);

          *__error() = v122;
          a3 = v130;
          a4 = v132;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 184) + 8) + 24) = 0;
      }
      else
      {
        objc_msgSend((id)v8, "setFilledSnapshot:", 1);
        if (v8)
        {
          *(_BYTE *)(v8 + 24) = *(_BYTE *)(a1 + 256);
          v78 = *(_BYTE *)(v8 + 11) & 0x7F | ((*(_BYTE *)(a1 + 257) != 0) << 7);
          *(_BYTE *)(v8 + 11) = v78;
          *(_BYTE *)(v8 + 11) = v78 & 0xBF | (*(_BYTE *)(a1 + 258) << 6);
          v79 = *(_BYTE *)(v8 + 15) & 0xBF | (*(_BYTE *)(a1 + 259) << 6);
          *(_BYTE *)(v8 + 15) = v79;
          *(_BYTE *)(v8 + 15) = v79 & 0x7F | ((*(_BYTE *)(a1 + 260) != 0) << 7);
        }
        if (*(_BYTE *)(a1 + 261))
        {
          v80 = *(_QWORD *)(a1 + 40);
          if (v80)
            *(_BYTE *)(v80 + 16) = 1;
        }
        if (v8)
        {
          v81 = *(void **)(a1 + 104);
          if (v81)
            objc_setProperty_atomic((id)v8, v77, v81, 168);
        }
        v17 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v133 = a4;
          v123 = *__error();
          v128 = (FILE *)qword_1ED1DD618;
          v125 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v82 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          v83 = *(unsigned __int8 *)(a1 + 256);
          v84 = *(unsigned __int8 *)(a1 + 257);
          v85 = *(unsigned __int8 *)(a1 + 258);
          v86 = *(unsigned __int8 *)(a1 + 259);
          v87 = *(unsigned __int8 *)(a1 + 260);
          v88 = *(unsigned __int8 *)(a1 + 261);
          objc_msgSend(*(id *)(a1 + 104), "debugDescription");
          v89 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          fprintf(v128, "%'llu Thread 0x%llx snapshot info (io tier %d, passive %d, suspended %d, darwinbg %d, idlewq %d, gfi %d, runnable %s) backfilled to all (%d) thread states (indexes %lu-%lu)\n", v125, v82, v83, v84, v85, v86, v87, v88, (const char *)objc_msgSend(v89, "UTF8String"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));

          *__error() = v123;
          v17 = 1;
          a3 = 0;
          a4 = v133;
        }
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 8) + 24))
    {
      if (objc_msgSend((id)v8, "needsExclave"))
      {
        objc_msgSend((id)v8, "setNeedsExclave:", 0);
        if (v8)
          objc_setProperty_atomic((id)v8, v90, *(id *)(a1 + 112), 176);
        if (!a3 && qword_1ED1DD618)
        {
          v91 = *__error();
          v92 = (FILE *)qword_1ED1DD618;
          v93 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v95 = objc_msgSend(*(id *)(a1 + 40), "threadId");
          Property = *(id *)(a1 + 112);
          if (Property)
            Property = objc_getProperty(Property, v94, 16, 1);
          v134 = Property;
          v98 = objc_msgSend(v134, "count");
          v99 = *(id *)(a1 + 112);
          if (v99)
            v99 = objc_getProperty(v99, v97, 16, 1);
          v100 = v99;
          objc_msgSend(v100, "lastObject");
          v101 = (void *)objc_claimAutoreleasedReturnValue();
          v103 = v101;
          if (v101)
          {
            v104 = objc_getProperty(v101, v102, 16, 1);
            v105 = v91;
          }
          else
          {
            v105 = v91;
            v104 = 0;
          }
          v106 = v104;
          fprintf(v92, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to all (%d) thread states (indexes %lu-%lu)\n", v93, v95, v98, objc_msgSend(v106, "address"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24));

          *__error() = v105;
        }
        goto LABEL_149;
      }
      if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) >= 1 && qword_1ED1DD618)
      {
        v107 = *__error();
        v108 = (FILE *)qword_1ED1DD618;
        v109 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
        v111 = objc_msgSend(*(id *)(a1 + 40), "threadId");
        v112 = *(id *)(a1 + 112);
        v135 = a4;
        if (v112)
          v112 = objc_getProperty(v112, v110, 16, 1);
        v131 = v112;
        v114 = objc_msgSend(v131, "count");
        v115 = *(id *)(a1 + 112);
        v126 = v111;
        if (v115)
          v115 = objc_getProperty(v115, v113, 16, 1);
        v129 = v115;
        objc_msgSend(v129, "lastObject");
        v116 = (void *)objc_claimAutoreleasedReturnValue();
        v118 = v116;
        if (v116)
          v119 = objc_getProperty(v116, v117, 16, 1);
        else
          v119 = 0;
        v120 = v119;
        fprintf(v108, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to %d thread states (indexes %lu-%lu)\n", v109, v126, v114, objc_msgSend(v120, "address"), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) + a3);

        a4 = v135;
        *__error() = v107;
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 8) + 24) = 0;
    }
    if ((v17 & 1) == 0)
    {
      *a4 = 1;
LABEL_153:

      goto LABEL_154;
    }
LABEL_149:
    if (objc_msgSend(*(id *)(a1 + 120), "dataStyle") != 3)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 24) = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 168) + 8) + 24) = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 8) + 24) = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 184) + 8) + 24) = 0;
    }
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24);
    goto LABEL_153;
  }
  if (qword_1ED1DD618)
  {
    v18 = a3;
    v19 = *__error();
    fprintf((FILE *)qword_1ED1DD618, "%'llu Thread 0x%llx ran into non-kperf state at index %lu, stopping\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "threadId"), v18);
    *__error() = v19;
  }
  *a4 = 1;
LABEL_154:

}

void __380__SASampleStore_KPerfPrivate__backfillTask_lastSampleIndex_timestamp_haveSnap_terminatedThreadsUserTimeInNs_terminatedThreadsSystemTimeInNs_terminatedThreadsCycles_terminatedThreadsInstructions_suspendCount_pageins_isDarwinBG_isForeground_isBoosted_isDirty_haveWQFlags_wqExceededTotalThreadLimit_wqExceededConstrainedThreadLimit_haveMem_taskSizeInBytes_haveLatencyQos_latencyQos___block_invoke(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  _BYTE *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  FILE *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v25;
  FILE *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v34;
  uint64_t v35;
  int v36;
  int v38;
  id v39;

  v39 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v7 = v39;
    v8 = v7;
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    if (!*(_BYTE *)(v9 + 24))
    {
      v16 = 0;
      goto LABEL_44;
    }
    if (v7)
    {
      if ((v7[120] & 1) != 0)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
        {
          v25 = *__error();
          v26 = (FILE *)qword_1ED1DD618;
          v27 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
          v28 = objc_msgSend(*(id *)(a1 + 40), "pid");
          v29 = *(unsigned __int8 *)(a1 + 144);
          if (*(_BYTE *)(a1 + 144))
          {
            v29 = *(unsigned __int8 *)(a1 + 145);
            v30 = *(unsigned __int8 *)(a1 + 146);
          }
          else
          {
            v30 = 0;
          }
          fprintf(v26, "%'llu task [%d] state (terminated cpu %llu, terminated instruction %llu, terminated cycles %llu, suspend count %d, pageins %u, darwinBG %d, foreground %d, boosted %d, dirty %d, wq total %d, wq constrained %d) backfilled to %d task states (indexes %lu-%lu)\n", v27, v28, *(_QWORD *)(a1 + 96) + *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 104), *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 132), *(unsigned __int8 *)(a1 + 140), *(unsigned __int8 *)(a1 + 141), *(unsigned __int8 *)(a1 + 142), *(unsigned __int8 *)(a1 + 143), v29, v30, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24), a3 + 1,
            *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + a3);
          *__error() = v25;
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        }
        v16 = 0;
        *(_BYTE *)(v9 + 24) = 0;
LABEL_44:
        v31 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        if (!*(_BYTE *)(v31 + 24))
          goto LABEL_57;
        if (v8)
        {
          if ((*((_BYTE *)v8 + 121) & 1) != 0)
          {
            if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
            {
              v34 = *__error();
              fprintf((FILE *)qword_1ED1DD618, "%'llu task [%d] size %llu backfilled to %d task states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "pid"), *(_QWORD *)(a1 + 120), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + a3);
              *__error() = v34;
              v31 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
            }
            *(_BYTE *)(v31 + 24) = 0;
LABEL_57:
            v35 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
            if (*(_BYTE *)(v35 + 24))
            {
              if (!v8)
              {
LABEL_61:
                if (!a3 && qword_1ED1DD618)
                {
                  v36 = *__error();
                  fprintf((FILE *)qword_1ED1DD618, "%'llu task [%d] latency qos %d backfilled to all (%d) task states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "pid"), *(_DWORD *)(a1 + 136), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
                  *__error() = v36;
                }
LABEL_71:
                if (objc_msgSend(*(id *)(a1 + 48), "dataStyle") == 3)
                {
                  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
LABEL_74:

                  goto LABEL_75;
                }
LABEL_73:
                *a4 = 1;
                goto LABEL_74;
              }
              if ((*((_BYTE *)v8 + 122) & 1) == 0)
              {
                *((_BYTE *)v8 + 122) = 1;
                *((_DWORD *)v8 + 6) = *(_DWORD *)(a1 + 136);
                goto LABEL_61;
              }
              if (*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) >= 1 && qword_1ED1DD618 != 0)
              {
                v38 = *__error();
                fprintf((FILE *)qword_1ED1DD618, "%'llu task [%d] latency qos %d backfilled to %d task states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "pid"), *(_DWORD *)(a1 + 136), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24), a3 + 1, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + a3);
                *__error() = v38;
                v35 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
              }
              *(_BYTE *)(v35 + 24) = 0;
            }
            if (!v16)
              goto LABEL_73;
            goto LABEL_71;
          }
          *((_BYTE *)v8 + 121) = 1;
          *((_QWORD *)v8 + 8) = *(_QWORD *)(a1 + 120);
        }
        v16 = 1;
        if (!a3 && qword_1ED1DD618)
        {
          v32 = *__error();
          fprintf((FILE *)qword_1ED1DD618, "%'llu task [%d] size %llu backfilled to all (%d) task states (indexes %lu-%lu)\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "pid"), *(_QWORD *)(a1 + 120), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + 1, 0, *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
          *__error() = v32;
          v16 = 1;
        }
        goto LABEL_57;
      }
      v7[120] = 1;
      *((_QWORD *)v7 + 9) = *(_QWORD *)(a1 + 88);
      *((_QWORD *)v7 + 10) = *(_QWORD *)(a1 + 96);
      *((_QWORD *)v7 + 12) = *(_QWORD *)(a1 + 104);
      *((_QWORD *)v7 + 11) = *(_QWORD *)(a1 + 112);
      *((_DWORD *)v7 + 2) = *(_DWORD *)(a1 + 128);
      *((_DWORD *)v7 + 4) = *(_DWORD *)(a1 + 132);
    }
    if (*(_BYTE *)(a1 + 140))
    {
      v10 = objc_msgSend(v7, "ssFlags");
      if (v8)
        *((_QWORD *)v8 + 14) = v10 | 0x40;
    }
    if (*(_BYTE *)(a1 + 141))
    {
      v11 = objc_msgSend(v8, "ssFlags");
      if (v8)
        *((_QWORD *)v8 + 14) = v11 | 0x400;
    }
    if (*(_BYTE *)(a1 + 142))
    {
      v12 = objc_msgSend(v8, "ssFlags");
      if (v8)
        *((_QWORD *)v8 + 14) = v12 | 0x800;
    }
    if (*(_BYTE *)(a1 + 143))
    {
      v13 = objc_msgSend(v8, "ssFlags");
      if (v8)
        *((_QWORD *)v8 + 14) = v13 | 0x10000;
    }
    if (*(_BYTE *)(a1 + 144))
    {
      if (*(_BYTE *)(a1 + 145))
      {
        v14 = objc_msgSend(v8, "ssFlags");
        if (v8)
          *((_QWORD *)v8 + 14) = v14 | 0x40000;
      }
      if (*(_BYTE *)(a1 + 146))
      {
        v15 = objc_msgSend(v8, "ssFlags");
        if (v8)
          *((_QWORD *)v8 + 14) = v15 | 0x20000;
      }
    }
    v16 = 1;
    if (!a3 && qword_1ED1DD618)
    {
      v17 = *__error();
      v18 = (FILE *)qword_1ED1DD618;
      v19 = objc_msgSend(*(id *)(a1 + 32), "machAbsTime");
      v20 = objc_msgSend(*(id *)(a1 + 40), "pid");
      v21 = *(unsigned __int8 *)(a1 + 144);
      if (*(_BYTE *)(a1 + 144))
      {
        v22 = *(unsigned __int8 *)(a1 + 145);
        v21 = *(unsigned __int8 *)(a1 + 146);
      }
      else
      {
        v22 = 0;
      }
      fprintf(v18, "%'llu task [%d] state (terminated cpu %llu, terminated instruction %llu, terminated cycles %llu, suspend count %d, pageins %u, darwinBG %d, foreground %d, boosted %d, dirty %d, wq total %d, wq constrained %d) backfilled to all (%d) task states (indexes %lu-%lu)\n", v19, v20, *(_QWORD *)(a1 + 96) + *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 104), *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 132), *(unsigned __int8 *)(a1 + 140), *(unsigned __int8 *)(a1 + 141), *(unsigned __int8 *)(a1 + 142), *(unsigned __int8 *)(a1 + 143), v22, v21, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + 1, 0,
        *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
      *__error() = v17;
      v16 = 1;
    }
    goto LABEL_44;
  }
  if (qword_1ED1DD618)
  {
    v23 = *__error();
    fprintf((FILE *)qword_1ED1DD618, "%'llu task [%d] ran into non-kperf state at index %lu, stopping\n", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"), objc_msgSend(*(id *)(a1 + 40), "pid"), a3);
    *__error() = v23;
  }
  *a4 = 1;
LABEL_75:

}

- (id)binaryFormat
{
  PASampleTimeSeriesDataStore *v2;
  void *v3;
  id v4;
  uLong v5;
  id v6;
  uint64_t v7;
  const Bytef *v8;
  uLong v9;
  Bytef *v10;
  int v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  void *v19;
  id v21;
  void *v22;
  void *v23;
  int v24;
  NSObject *v25;
  id v26;
  uint64_t v27;
  uLongf v28;
  id v29;
  uint8_t buf[4];
  uLong v31;
  __int16 v32;
  uLongf v33;
  __int16 v34;
  double v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v2 = -[PASampleTimeSeriesDataStore initWithSampleStore:]([PASampleTimeSeriesDataStore alloc], "initWithSampleStore:", self);
  v29 = 0;
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v2, 1, &v29);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v29;
  if (objc_msgSend(v3, "length"))
  {

    v5 = objc_msgSend(v3, "length");
    v6 = objc_retainAutorelease(v3);
    v7 = objc_msgSend(v6, "bytes");
    if (v7)
    {
      v8 = (const Bytef *)v7;
      v9 = compressBound(v5);
      v28 = v9;
      v10 = (Bytef *)malloc_type_malloc(v9 + 8, 0xD85D8ECCuLL);
      v11 = compress(v10 + 8, &v28, v8, v5);

      v12 = *__error();
      _sa_logt();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = v13;
      if (v11)
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218496;
          v31 = v5;
          v32 = 2048;
          v33 = v9;
          v34 = 1024;
          LODWORD(v35) = v11;
          _os_log_error_impl(&dword_1B9BE0000, v14, OS_LOG_TYPE_ERROR, "Unable to compress binary format of size %lu to estimated compressed size %lu: %d", buf, 0x1Cu);
        }

        *__error() = v12;
      }
      else
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 134218496;
          v31 = v5;
          v32 = 2048;
          v33 = v28;
          v34 = 2048;
          v35 = (double)(v5 - v28) * 100.0 / (double)v5;
          _os_log_debug_impl(&dword_1B9BE0000, v14, OS_LOG_TYPE_DEBUG, "Compressed %lu binary data into %lu (%.0f%% savings)", buf, 0x20u);
        }

        *__error() = v12;
        *(_QWORD *)v10 = v5;
        v28 += 8;
        v21 = objc_alloc(MEMORY[0x1E0C99DF0]);
        v22 = (void *)objc_msgSend(v21, "initWithBytesNoCopy:length:freeWhenDone:", v10, v28, 1);
        if (v22)
        {
          v23 = v22;
          objc_msgSend(v22, "base64EncodedDataWithOptions:", 34);
          v19 = (void *)objc_claimAutoreleasedReturnValue();

          return v19;
        }
        v24 = *__error();
        _sa_logt();
        v25 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1B9BE0000, v25, OS_LOG_TYPE_ERROR, "Unable to create NSData for compressed binary format", buf, 2u);
        }

        *__error() = v24;
      }
      free(v10);
    }
    else
    {
      v17 = *__error();
      _sa_logt();
      v18 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B9BE0000, v18, OS_LOG_TYPE_ERROR, "Unable to get bytes for binary format", buf, 2u);
      }

      *__error() = v17;
    }
  }
  else
  {
    v15 = *__error();
    _sa_logt();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(v4, "description");
      v26 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v27 = objc_msgSend(v26, "UTF8String");
      *(_DWORD *)buf = 136315138;
      v31 = v27;
      _os_log_error_impl(&dword_1B9BE0000, v16, OS_LOG_TYPE_ERROR, "Unable to archive samples for binary format: %s", buf, 0xCu);

    }
    *__error() = v15;

  }
  v19 = 0;
  return v19;
}

- (BOOL)saveBinaryFormatToStream:(__sFILE *)a3
{
  void *v4;
  void *v5;
  size_t v6;
  const void *v7;
  BOOL v8;
  int v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  _DWORD v15[2];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  -[SASampleStore binaryFormat](self, "binaryFormat");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (!v4)
  {
    v9 = *__error();
    _sa_logt();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15[0]) = 0;
      v11 = "Unable to get bytes for binary format";
      v12 = v10;
      v13 = 2;
      goto LABEL_9;
    }
LABEL_6:

    v8 = 0;
    *__error() = v9;
    goto LABEL_7;
  }
  v6 = objc_msgSend(v4, "length");
  v7 = (const void *)objc_msgSend(objc_retainAutorelease(v5), "bytes");
  v8 = 1;
  fwrite("Spindump binary format\n", 0x17uLL, 1uLL, a3);
  if (fwrite(v7, v6, 1uLL, a3) != 1)
  {
    v9 = *__error();
    _sa_logt();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v15[0] = 67109120;
      v15[1] = ferror(a3);
      v11 = "Unable to save binary format: %d";
      v12 = v10;
      v13 = 8;
LABEL_9:
      _os_log_error_impl(&dword_1B9BE0000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)v15, v13);
      goto LABEL_6;
    }
    goto LABEL_6;
  }
LABEL_7:

  return v8;
}

+ (id)sampleStoreForSpindumpFile:(const char *)a3
{
  void *v3;
  int v4;
  int v5;
  FILE *v6;
  FILE *v7;
  void *v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  int v12;
  const char *v13;
  int v14;
  NSObject *v15;
  int v17;
  NSObject *v18;
  _BYTE *v19;
  int v20;
  uint8_t *v21;
  int v22;
  int v23;
  _BYTE *v24;
  off_t st_size;
  uint64_t v26;
  char v27;
  BOOL v28;
  uint64_t v29;
  off_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  BOOL v34;
  int v35;
  NSObject *v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  void *v43;
  int v44;
  NSObject *v45;
  off_t v46;
  size_t v47;
  char *v48;
  int v49;
  NSObject *v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  id v55;
  size_t *v56;
  uLongf v57;
  const Bytef *v58;
  Bytef *v59;
  Bytef *v60;
  int v61;
  int v62;
  int v63;
  NSObject *v64;
  int v65;
  NSObject *v66;
  int v67;
  NSObject *v68;
  const char *v69;
  NSObject *v70;
  uint32_t v71;
  id v72;
  void *v73;
  void *v74;
  id v75;
  void *v76;
  int v77;
  NSObject *v78;
  int v79;
  int v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  int v84;
  int v85;
  NSObject *v86;
  id v87;
  uint64_t v88;
  id v89;
  uLongf destLen;
  uint8_t buf[4];
  _BYTE v92[18];
  stat v93;
  uint64_t v94;

  v3 = (void *)a3;
  v94 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return v3;
  v4 = open(a3, 0);
  if (v4 == -1)
  {
    v14 = *__error();
    _sa_logt();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v22 = *__error();
      v93.st_dev = 136315394;
      *(_QWORD *)&v93.st_mode = v3;
      WORD2(v93.st_ino) = 1024;
      *(_DWORD *)((char *)&v93.st_ino + 6) = v22;
      _os_log_error_impl(&dword_1B9BE0000, v15, OS_LOG_TYPE_ERROR, "Unable to open %s: %{errno}d", (uint8_t *)&v93, 0x12u);
    }

    *__error() = v14;
    return 0;
  }
  v5 = v4;
  v6 = fdopen(v4, "r");
  if (!v6)
  {
    v17 = *__error();
    _sa_logt();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v23 = *__error();
      v93.st_dev = 136315394;
      *(_QWORD *)&v93.st_mode = v3;
      WORD2(v93.st_ino) = 1024;
      *(_DWORD *)((char *)&v93.st_ino + 6) = v23;
      _os_log_error_impl(&dword_1B9BE0000, v18, OS_LOG_TYPE_ERROR, "Unable to fopen %s: %{errno}d", (uint8_t *)&v93, 0x12u);
    }

    *__error() = v17;
    close(v5);
    goto LABEL_19;
  }
  v7 = v6;
  v8 = malloc_type_malloc(0x800uLL, 0xF413A8C0uLL);
  do
  {
    if (!fgets((char *)v8, 2048, v7))
    {
      free(v8);
      v10 = *__error();
      _sa_logt();
      v11 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        goto LABEL_18;
      v93.st_dev = 136315138;
      *(_QWORD *)&v93.st_mode = v3;
      v21 = (uint8_t *)&v93;
LABEL_50:
      _os_log_debug_impl(&dword_1B9BE0000, v11, OS_LOG_TYPE_DEBUG, "Input file %s does not contain a binary format for spindump", v21, 0xCu);
      goto LABEL_18;
    }
  }
  while (strncmp("Spindump binary format", (const char *)v8, 0x16uLL));
  free(v8);
  v9 = MEMORY[0x1BCCCBE44](v7);
  memset(&v93, 0, sizeof(v93));
  if (fstat(v5, &v93))
  {
    v10 = *__error();
    _sa_logt();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = *__error();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v92 = v3;
      *(_WORD *)&v92[8] = 1024;
      *(_DWORD *)&v92[10] = v12;
      v13 = "Unable to fstat %s: %{errno}d";
      goto LABEL_10;
    }
    goto LABEL_18;
  }
  if (v93.st_size <= v9)
  {
    v10 = *__error();
    _sa_logt();
    v11 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      goto LABEL_18;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)v92 = v3;
    v21 = buf;
    goto LABEL_50;
  }
  v19 = mmap(0, v93.st_size, 1, 1, v5, 0);
  if ((unint64_t)(v19 + 1) <= 1)
  {
    v10 = *__error();
    _sa_logt();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v20 = *__error();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v92 = v3;
      *(_WORD *)&v92[8] = 1024;
      *(_DWORD *)&v92[10] = v20;
      v13 = "Unable to mmap %s: %{errno}d";
LABEL_10:
      _os_log_error_impl(&dword_1B9BE0000, v11, OS_LOG_TYPE_ERROR, v13, buf, 0x12u);
    }
LABEL_18:

    *__error() = v10;
    fclose(v7);
LABEL_19:
    v3 = 0;
    return v3;
  }
  v24 = v19;
  fclose(v7);
  st_size = v93.st_size;
  if (v9 >= v93.st_size)
  {
    v31 = v9;
    goto LABEL_62;
  }
  v26 = 0;
  v27 = 0;
  v28 = 1;
  v29 = v9;
  v30 = v9;
  v31 = v9;
  while (2)
  {
    v32 = v29 - v30;
    if (v26 && v32 > v26)
    {
      v35 = *__error();
      _sa_logt();
      v36 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        goto LABEL_57;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v92 = v29;
      v37 = "Found bad line length at %lld, ending scan";
      v38 = v36;
      v39 = 12;
      goto LABEL_56;
    }
    v33 = (char)v24[v29];
    if ((v27 & 1) == 0)
    {
      if (((v33 & 0xDF) - 65) < 0x1Au
        || (v33 != 43 ? (v34 = (v33 - 47) >= 0xBu) : (v34 = 0), !v34))
      {
        v27 = 0;
        goto LABEL_47;
      }
    }
    if (v33 == 61)
    {
      v27 = 1;
      goto LABEL_47;
    }
    if (v24[v29] != 10)
    {
      v35 = *__error();
      _sa_logt();
      v36 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        goto LABEL_57;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v92 = v33;
      *(_WORD *)&v92[4] = 2048;
      *(_QWORD *)&v92[6] = v29;
      v37 = "Found invalid base64 character '%c' at %lld, ending scan";
      v38 = v36;
      v39 = 18;
LABEL_56:
      _os_log_debug_impl(&dword_1B9BE0000, v38, OS_LOG_TYPE_DEBUG, v37, buf, v39);
LABEL_57:

      *__error() = v35;
      if (!v28)
      {
        st_size = v93.st_size;
        goto LABEL_62;
      }
      goto LABEL_61;
    }
    if (v26)
    {
      if (v32 != v26)
      {
        v30 = v29 + 1;
        goto LABEL_60;
      }
    }
    else
    {
      v26 = v29 - v30;
    }
    if ((v27 & 1) == 0)
    {
      v27 = 0;
      v31 = v29 + 1;
      v30 = v29 + 1;
LABEL_47:
      v28 = ++v29 < v93.st_size;
      if (v93.st_size == v29)
        goto LABEL_60;
      continue;
    }
    break;
  }
  v31 = v29 + 1;
  v30 = v29 + 1;
LABEL_60:
  if (!v28)
    goto LABEL_62;
LABEL_61:
  st_size = v30;
LABEL_62:
  v40 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytesNoCopy:length:freeWhenDone:", &v24[v9], st_size - v9, 0);
  if (!v40)
  {
    v44 = *__error();
    _sa_logt();
    v45 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
LABEL_104:
      _os_log_error_impl(&dword_1B9BE0000, v45, OS_LOG_TYPE_ERROR, "Unable to create NSData for base64 binary format", buf, 2u);
    }
LABEL_66:

    *__error() = v44;
    munmap(v24, v93.st_size);
    goto LABEL_19;
  }
  v41 = (void *)v40;
  v42 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedData:options:", v40, 1);
  if (v42)
  {
    v43 = (void *)v42;
    goto LABEL_73;
  }
  v46 = st_size - v31;
  if (st_size > v31)
  {
    v47 = v46 + 1;
    v48 = (char *)malloc_type_calloc(v46 + 1, 1uLL, 0x2AE4CE92uLL);
    snprintf(v48, v47, "%s", &v24[v31]);
    v49 = *__error();
    _sa_logt();
    v50 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v92 = v48;
      _os_log_debug_impl(&dword_1B9BE0000, v50, OS_LOG_TYPE_DEBUG, "Possible extra text at end of base-64 encoded data, ignoring last line \"%s\", buf, 0xCu);
    }

    *__error() = v49;
    free(v48);
    v51 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytesNoCopy:length:freeWhenDone:", &v24[v9], v31 - v9, 0);

    if (v51)
    {
      v43 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedData:options:", v51, 1);
      v41 = (void *)v51;
      goto LABEL_73;
    }
    v44 = *__error();
    _sa_logt();
    v45 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      goto LABEL_104;
    }
    goto LABEL_66;
  }
  v43 = 0;
LABEL_73:

  if (munmap(v24, v93.st_size))
  {
    v52 = *__error();
    _sa_logt();
    v53 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      v79 = *__error();
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v92 = v79;
      _os_log_error_impl(&dword_1B9BE0000, v53, OS_LOG_TYPE_ERROR, "Unable to unmap file: %{errno}d", buf, 8u);
    }

    *__error() = v52;
  }
  if (!v43)
  {
    v65 = *__error();
    _sa_logt();
    v66 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B9BE0000, v66, OS_LOG_TYPE_ERROR, "Unable to decode base64 binary format", buf, 2u);
    }

    *__error() = v65;
    return 0;
  }
  v54 = objc_msgSend(v43, "length");
  v55 = objc_retainAutorelease(v43);
  v56 = (size_t *)objc_msgSend(v55, "bytes");
  v58 = (const Bytef *)(v56 + 1);
  v57 = *v56;
  if (*v56 == -1)
  {
    v67 = *__error();
    _sa_logt();
    v68 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
LABEL_90:

      *__error() = v67;
      goto LABEL_19;
    }
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)v92 = -1;
    v69 = "Bad uncompressed size %llu";
    v70 = v68;
    v71 = 12;
LABEL_112:
    _os_log_error_impl(&dword_1B9BE0000, v70, OS_LOG_TYPE_ERROR, v69, buf, v71);
    goto LABEL_90;
  }
  v59 = (Bytef *)malloc_type_malloc(*v56, 0x7BBCC074uLL);
  if (!v59)
  {
    v67 = *__error();
    _sa_logt();
    v68 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      goto LABEL_90;
    v84 = *__error();
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)v92 = v84;
    v69 = "Unable to allocate buffer for binary format: %{errno}d";
    v70 = v68;
    v71 = 8;
    goto LABEL_112;
  }
  v60 = v59;
  destLen = v57;
  v61 = uncompress(v59, &destLen, v58, v54 - 8);
  if (v61)
  {
    v62 = v61;
    v63 = *__error();
    _sa_logt();
    v64 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v92 = v62;
      _os_log_error_impl(&dword_1B9BE0000, v64, OS_LOG_TYPE_ERROR, "Unable to decompress binary format: %d", buf, 8u);
    }

    *__error() = v63;
    goto LABEL_101;
  }
  if (v57 == destLen)
  {
    v72 = objc_alloc(MEMORY[0x1E0C99D50]);
    v73 = (void *)objc_msgSend(v72, "initWithBytesNoCopy:length:freeWhenDone:", v60, destLen, 1);
    if (v73)
    {
      v89 = 0;
      v74 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3710]), "initForReadingFromData:error:", v73, &v89);
      v75 = v89;
      v76 = v75;
      if (v74)
      {

        objc_msgSend(v74, "decodeObjectOfClass:forKey:", objc_opt_class(), *MEMORY[0x1E0CB2CD0]);
        v76 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v74, "finishDecoding");
        if (v76)
        {
          objc_msgSend(v76, "sampleStore");
          v3 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v3, "setDataGatheringOptions:", 628);
        }
        else
        {
          v85 = *__error();
          _sa_logt();
          v86 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_1B9BE0000, v86, OS_LOG_TYPE_ERROR, "Unable to unarchive binary format", buf, 2u);
          }

          v76 = 0;
          v3 = 0;
          *__error() = v85;
        }
      }
      else
      {
        v82 = *__error();
        _sa_logt();
        v83 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(v76, "description");
          v87 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v88 = objc_msgSend(v87, "UTF8String");
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)v92 = v3;
          *(_WORD *)&v92[8] = 2080;
          *(_QWORD *)&v92[10] = v88;
          _os_log_error_impl(&dword_1B9BE0000, v83, OS_LOG_TYPE_ERROR, "Unable to unarchive %s: %s", buf, 0x16u);

        }
        v3 = 0;
        *__error() = v82;
      }

    }
    else
    {
      v80 = *__error();
      _sa_logt();
      v81 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B9BE0000, v81, OS_LOG_TYPE_ERROR, "Unable to create NSData for binary format", buf, 2u);
      }

      *__error() = v80;
      free(v60);
      v3 = 0;
    }

  }
  else
  {
    v77 = *__error();
    _sa_logt();
    v78 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)v92 = destLen;
      *(_WORD *)&v92[8] = 2048;
      *(_QWORD *)&v92[10] = v57;
      _os_log_error_impl(&dword_1B9BE0000, v78, OS_LOG_TYPE_ERROR, "Unexpected uncompressed size %lu, expected %llu", buf, 0x16u);
    }

    *__error() = v77;
LABEL_101:
    free(v60);
    v3 = 0;
  }

  return v3;
}

@end
