unsigned __int16 *CUIRenditionKeySetValueForAttribute(unsigned __int16 *result, int a2, int a3, unsigned int a4)
{
  int v4;
  unint64_t v5;
  unsigned __int16 *v6;
  int v7;
  BOOL v8;
  unsigned __int16 v9;
  unsigned __int16 *v10;
  unsigned __int16 v11;
  unint64_t v12;
  unsigned __int16 *v13;

  if (result)
  {
    if (!a4)
      CUIRenditionKeySetValueForAttribute_cold_1();
    v4 = *result;
    if (!(result[1] | v4))
      goto LABEL_15;
    LODWORD(v5) = 0;
    v6 = result + 3;
    while (v4 != a2)
    {
      LODWORD(v5) = v5 + 1;
      v7 = *v6;
      v4 = *(v6 - 1);
      v6 += 2;
      if (v7)
        v8 = 0;
      else
        v8 = v4 == 0;
      if (v8)
        goto LABEL_15;
    }
    if ((v5 & 0x80000000) != 0)
    {
LABEL_15:
      if (!a3)
        return result;
      v9 = 0;
      if (result[1])
        goto LABEL_18;
      while (result[2 * v9])
      {
        do
LABEL_18:
          ++v9;
        while (result[2 * v9 + 1]);
      }
      if ((int)(a4 - 1) <= v9)
        CUIRenditionKeySetValueForAttribute_cold_2();
      v10 = &result[2 * v9];
      *v10 = a2;
      v10[1] = a3;
      v5 = v9 + 1;
      result[2 * v5] = 0;
      LOWORD(a3) = 0;
      goto LABEL_22;
    }
    if (a3)
    {
      v5 = v5;
LABEL_22:
      result[2 * v5 + 1] = a3;
      return result;
    }
    v11 = 0;
    if (result[1])
      goto LABEL_26;
    while (1)
    {
      v12 = v11;
      if (!result[2 * v11])
        break;
      do
LABEL_26:
        ++v11;
      while (result[2 * v11 + 1]);
    }
    if (a4 <= v11)
      CUIRenditionKeySetValueForAttribute_cold_3();
    if (v11 > (unsigned __int16)v5)
    {
      v5 = (unsigned __int16)v5;
      v13 = &result[2 * (unsigned __int16)v5 + 2];
      do
      {
        ++v5;
        *((_DWORD *)v13 - 1) = *(_DWORD *)v13;
        v13 += 2;
      }
      while (v5 < v12);
    }
  }
  return result;
}

unsigned __int16 *_CUIRenditionKeySetIntegerValueForAttribute(unsigned __int16 *a1, __int16 a2, unint64_t a3)
{
  if (a3 >> 16)
    _CUIRenditionKeySetIntegerValueForAttribute_cold_1(a2);
  return CUIRenditionKeySetValueForAttribute(a1, a2, (unsigned __int16)a3, 0x16u);
}

unsigned __int16 *CUIRenditionKeyValueForAttribute(unsigned __int16 *result, int a2)
{
  int v2;
  BOOL v3;
  int v4;
  unsigned __int16 *v5;
  int v6;
  BOOL v7;

  if (result)
  {
    v2 = *result;
    if (result[1])
      v3 = 0;
    else
      v3 = v2 == 0;
    if (v3)
      return 0;
    v4 = 0;
    v5 = result + 3;
    while (v2 != a2)
    {
      ++v4;
      v6 = *v5;
      v2 = *(v5 - 1);
      v5 += 2;
      if (v6)
        v7 = 0;
      else
        v7 = v2 == 0;
      if (v7)
        return 0;
    }
    if (v4 < 0)
      return 0;
    else
      return (unsigned __int16 *)result[2 * v4 + 1];
  }
  return result;
}

uint64_t CUICopyKeySignatureWithPrefix(char *a1, unint64_t a2, int *a3, uint64_t a4, uint64_t *a5, unsigned int a6)
{
  size_t v12;
  _OWORD *v13;
  char *v14;
  unsigned int v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  char v19;
  char *v20;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  char *v30;
  int v31;
  char v32;
  _OWORD v34[3];

  if (!a4)
    CUICopyKeySignatureWithPrefix_cold_1();
  memset(v34, 0, 44);
  v12 = *(unsigned int *)(a4 + 8);
  if (v12 < 0x16)
    v13 = v34;
  else
    v13 = malloc_type_calloc(v12, 2uLL, 0x1000040BDFB0063uLL);
  CUIFillCARKeyArrayForRenditionKey2((uint64_t)v13, a3, a4, a5);
  if (a2)
  {
    v14 = a1 + 1;
    do
    {
      v15 = a6;
      v16 = v14;
      a6 /= 0xAu;
      *(v14 - 1) = (v15 - 10 * a6) | 0x30;
      if (v15 < 0xA)
        break;
      ++v14;
      --a2;
    }
    while (a2);
  }
  else
  {
    v16 = a1;
  }
  v17 = v16 - a1;
  if ((unint64_t)(v16 - a1) >= 2)
  {
    v18 = 0;
    do
    {
      v19 = a1[v18];
      v20 = (char *)(v17 - (v18 + 1));
      a1[v18] = v20[(_QWORD)a1];
      v20[(_QWORD)a1] = v19;
    }
    while (v17 >> 1 > ++v18);
  }
  v22 = _CUICopySortedKeySignature(v16, a2, (uint64_t)v13, 2 * *(unsigned int *)(a4 + 8));
  if (v22 < 0)
  {
    if (v13 != v34)
      free(v13);
    return -1;
  }
  v23 = v22;
  if (v13 != v34)
    free(v13);
  if (a2 - v23 < 0x11)
    return -1;
  if (v23 < 0x61)
    return v23;
  v24 = 0;
  v25 = 0;
  while (HIWORD(a3[v24]))
  {
    v26 = LOWORD(a3[v24]);
    if (a5 && (*a5 & (1 << v26)) != 0)
    {
      LODWORD(v27) = *((unsigned __int8 *)a5 + LOWORD(a3[v24]) + 8);
LABEL_24:
      v28 = 4 * v24 + 16;
      if (v27 < 4)
        v28 = 8 * v24;
      if (v27 <= 0xB)
        v25 ^= (unint64_t)HIWORD(a3[v24]) << v28;
      goto LABEL_33;
    }
    v29 = *(unsigned int *)(a4 + 8);
    if ((_DWORD)v29)
    {
      v27 = 0;
      while (*(_DWORD *)(a4 + 12 + 4 * v27) != v26)
      {
        if (v29 == ++v27)
          goto LABEL_33;
      }
      goto LABEL_24;
    }
LABEL_33:
    if (++v24 == 21)
      break;
  }
  v23 += 16;
  v30 = &v16[v23];
  v16[v23] = 0;
  v31 = 16;
  do
  {
    if (v25)
    {
      if ((v25 & 0xF) >= 0xA)
        v32 = (v25 & 0xF) + 87;
      else
        v32 = v25 & 0xF | 0x30;
      *--v30 = v32;
      v25 >>= 4;
    }
    else
    {
      *--v30 = 48;
    }
    --v31;
  }
  while (v31);
  return v23;
}

uint64_t CUIFillCARKeyArrayForRenditionKey2(uint64_t result, int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int *v9;
  int v10;
  _OWORD v11[12];
  uint64_t v12;

  if (!result || !a2)
    CUIFillCARKeyArrayForRenditionKey2_cold_1();
  v5 = a4;
  v6 = result;
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  if (!a4)
  {
    v5 = (uint64_t *)v11;
    result = CUIRenditionKeyInitializeAttributeIndexWithKeyFormat((uint64_t)v11, a3);
  }
  v7 = *a2;
  if (*a2)
  {
    v8 = *v5;
    v9 = a2 + 1;
    do
    {
      if ((v8 & (1 << v7)) != 0)
        *(_WORD *)(v6 + 2 * *((unsigned __int8 *)v5 + (unsigned __int16)v7 + 8)) = *((_WORD *)v9 - 1);
      v10 = *v9++;
      LOWORD(v7) = v10;
    }
    while (v10);
  }
  return result;
}

uint64_t _CUICopySortedKeySignature(char *__dst, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  char *v9;
  char *v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  _BOOL4 v25;
  _BOOL4 v26;
  _BYTE *v27;
  BOOL v28;

  result = -1;
  if (__dst && a2 >= 0x65)
  {
    v9 = stpncpy(__dst, "{", a2 - 1);
    v10 = (char *)(&__dst[a2] - v9);
    if (&__dst[a2] != v9 && (uint64_t)(a4 & 0xFFFFFFFFFFFFFFFELL) >= 1)
    {
      v11 = a3 + 2;
      do
      {
        v12 = *(unsigned __int16 *)(v11 - 2);
        v13 = (v12 >> 8) & 0xF;
        if (v12 >= 0xA000)
          v14 = 87;
        else
          v14 = 48;
        v15 = v14 + (v12 >> 12);
        if (v13 >= 0xA)
          v16 = 87;
        else
          v16 = 48;
        v17 = v16 + v13;
        v18 = v12 & 0xF;
        v19 = v12 >> 4;
        if (v19 >= 0xA)
          v20 = 87;
        else
          v20 = 48;
        v21 = v20 + v19;
        if (v18 >= 0xA)
          v22 = 87;
        else
          v22 = 48;
        v23 = v22 + v18;
        v25 = v15 == 48 && v17 == 48;
        v26 = v21 == 48 && v25;
        v27 = v9 + 1;
        if (v26 && v23 == 48)
        {
          *v9 = 48;
        }
        else if (v26)
        {
          *v9 = v23;
        }
        else if (v25)
        {
          *v9 = v21;
          v27 = v9 + 2;
          v9[1] = v23;
        }
        else if (v15 == 48)
        {
          v27 = v9 + 3;
          *v9 = v17;
          v9[1] = v21;
          v9[2] = v23;
        }
        else
        {
          *v9 = v15;
          v9[1] = v17;
          v9[2] = v21;
          v27 = v9 + 4;
          v9[3] = v23;
        }
        *v27 = 45;
        v9 = v27 + 1;
        v10 -= 5;
        if (!v10)
          break;
        v28 = v11 >= a3 + (a4 & 0xFFFFFFFFFFFFFFFELL);
        v11 += 2;
      }
      while (!v28);
    }
    if ((unint64_t)(v10 - 3) > 0xFFFFFFFFFFFFFFFDLL)
      v9 -= 2;
    else
      *(v9 - 1) = 125;
    *v9 = 0;
    return v9 - __dst;
  }
  return result;
}

uint64_t CUICopyKeySignature(char *a1, unint64_t a2, int *a3, uint64_t a4, uint64_t *a5)
{
  return CUICopyKeySignatureWithPrefix(a1, a2, a3, a4, a5, 0);
}

uint64_t CUIBitVectorIsBitSet(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t v4;

  os_unfair_lock_lock(a1);
  if (a2 >> 5 >= a1[1]._os_unfair_lock_opaque)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (a1[(a2 >> 5) + 2]._os_unfair_lock_opaque >> a2) & 1;
  os_unfair_lock_unlock(a1);
  return v4;
}

uint64_t CUIRenditionKeyTokenCount(uint64_t a1)
{
  unsigned __int16 v1;

  v1 = 0;
  if (a1)
  {
    while (*(_WORD *)(a1 + 4 * v1 + 2) || *(_WORD *)(a1 + 4 * v1))
      ++v1;
  }
  return v1;
}

void *CUIRenditionKeyCopy(void *a1, _WORD *a2, unsigned int a3)
{
  unsigned __int16 i;

  if (!a1 || !a2)
    CUIRenditionKeyCopy_cold_1();
  for (i = 0; a2[2 * i + 1] || a2[2 * i]; ++i)
    ;
  if (i >= a3)
    CUIRenditionKeyCopy_cold_2();
  return memmove(a1, a2, 4 * i + 4);
}

const char *CUIDefaultThemeRenditionKeyFormat(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  const char *v10;

  switch(a1)
  {
    case 4:
      return "tmfk";
    case 2:
      if (a2 >= 6)
      {
        if (a2 >= 0xB)
        {
          if (a2 == 11)
          {
            return "tmfk";
          }
          else if (a2 >= 0xD)
          {
            if (a2 == 13)
            {
              return "tmfk";
            }
            else if (a2 >= 0xF)
            {
              if (a2 == 15)
              {
                return "tmfk";
              }
              else if (a2 >= 0x11)
              {
                return "tmfk";
              }
              else
              {
                return "tmfk";
              }
            }
            else
            {
              return "tmfk";
            }
          }
          else
          {
            return "tmfk";
          }
        }
        else
        {
          return "tmfk";
        }
      }
      else
      {
        return "tmfk";
      }
    case 1:
      v9 = "tmfk";
      v10 = "tmfk";
      if (a2 < 0xF)
        v10 = "tmfk";
      if (a2 != 13)
        v9 = v10;
      if (a2 >= 0xD)
        return v9;
      else
        return "tmfk";
    default:
      _CUILog(4, (uint64_t)"CoreUI: Unable to provide key format for custom theme semantics", a3, a4, a5, a6, a7, a8, v8);
      return 0;
  }
}

uint64_t CUICurrentPlatform()
{
  return 1;
}

uint64_t BOMTreeValueExists(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;

  result = 0;
  v15 = 0;
  if (a1 && a2)
  {
    if (a3 || (*(_BYTE *)(a1 + 356) & 4) != 0)
    {
      result = _findPagesForKey(a1, 0, a2, a3, a5, a6, a7, a8);
      if (result)
      {
        _findIndexForKey(a1, result, a2, a3, &v15, v12, v13, v14);
        return v15;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _findPagesForKey(uint64_t a1, char *a2, void *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  _QWORD *Page;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;

  if (!a1)
    return 0;
  v12 = *(_QWORD *)(a1 + 24);
  if (a2)
    BOMStackPush(a2, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
  if ((*(_WORD *)(v12 + 4) & 1) == 0)
  {
    do
    {
      v19 = *(_DWORD *)(*(_QWORD *)(v12 + 24) + 8 * (int)_findIndexForKey(a1, v12, a3, a4, 0, a6, a7, a8));
      v20 = bswap32(v19);
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0)
        v21 = v20;
      else
        v21 = v19;
      Page = _findPage(a1, v21, v13, v14, v15, v16, v17, v18);
      v12 = (uint64_t)Page;
      if (!Page)
        break;
      if (a2)
      {
        BOMStackPush(a2, (uint64_t)Page, v23, v24, v25, a6, a7, a8);
        v26 = *(_WORD *)(v12 + 4) | 8;
      }
      else
      {
        v26 = *((_WORD *)Page + 2);
      }
      *(_WORD *)(v12 + 4) = v26 & 0xFFFB;
    }
    while ((v26 & 1) == 0);
  }
  return v12;
}

_QWORD *_findPage(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  void *v15;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  int v28;
  int *v29;

  if (a2)
  {
    if (a1)
    {
      v10 = 0;
      while (1)
      {
        v11 = *(_QWORD **)(a1 + 32 + v10);
        if (v11)
        {
          if (*(_DWORD *)v11 == a2)
            break;
        }
        v10 += 8;
        if (v10 == 256)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      v11 = 0;
    }
    v12 = 0;
    while (1)
    {
      if (v11)
        return v11;
      v13 = *(int *)(a1 + 288);
      v11 = *(_QWORD **)(a1 + 8 * v13 + 32);
      if (!v11)
      {
        v11 = _NewPage(a1, a2);
        if (!v11)
          return v11;
        if (_ReadPage(a1, (uint64_t)v11, v18, v19, v20, v21, v22, v23))
          return 0;
        v13 = *(int *)(a1 + 288);
        *(_QWORD *)(a1 + 8 * v13 + 32) = v11;
        goto LABEL_26;
      }
      v14 = *((_WORD *)v11 + 2);
      if ((v14 & 0xC) == 4)
        break;
      if ((v14 & 4) != 0)
      {
        v11 = 0;
LABEL_26:
        v24 = v12;
        goto LABEL_27;
      }
      v24 = 0;
      *((_WORD *)v11 + 2) = v14 | 4;
      LODWORD(v13) = *(_DWORD *)(a1 + 288);
      v11 = 0;
LABEL_27:
      v25 = v13 + 1;
      v26 = -v25 < 0;
      v27 = -v25 & 0x1F;
      v28 = v25 & 0x1F;
      if (!v26)
        v28 = -v27;
      *(_DWORD *)(a1 + 288) = v28;
      v12 = v24 + 1;
      if (!v11 && v24 >= 32)
      {
        v29 = __error();
        _BOMExceptionHandlerCall("btree cache is deadlocked", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2347, *v29);
        return 0;
      }
    }
    if ((v14 & 2) != 0)
      _WritePage(a1, (uint64_t)v11);
    v15 = 0;
    v16 = (void *)v11[3];
    v11[4] = 0;
    *(_OWORD *)v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    if ((*(_BYTE *)(a1 + 356) & 0x40) == 0)
    {
      v17 = *(_DWORD *)(a1 + 308);
      if (v17 <= *(_DWORD *)(a1 + 312))
        v17 = *(_DWORD *)(a1 + 312);
      bzero(v16, 8 * v17);
      v15 = v16;
    }
    *(_DWORD *)v11 = a2;
    v11[1] = -1;
    v11[3] = v15;
    v11[4] = 0;
    if (_ReadPage(a1, (uint64_t)v11, a3, a4, a5, a6, a7, a8))
      return 0;
    v13 = *(int *)(a1 + 288);
    *(_QWORD *)(a1 + 8 * v13 + 32) = v11;
    goto LABEL_26;
  }
  return 0;
}

uint64_t BOMTreeReadValue(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int IndexForKey;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  BOOL v25;

  result = 0;
  v25 = 0;
  if (a1 && a2)
  {
    if (!a3 && (*(_BYTE *)(a1 + 356) & 4) == 0)
      return 0;
    result = _findPagesForKey(a1, 0, a2, a3, a5, a6, a7, a8);
    if (!result)
      return result;
    v15 = result;
    IndexForKey = _findIndexForKey(a1, result, a2, a3, &v25, v12, v13, v14);
    if (v25)
    {
      v23 = bswap32(*(_DWORD *)(*(_QWORD *)(v15 + 24) + 8 * IndexForKey));
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0)
        v24 = v23;
      else
        v24 = *(_DWORD *)(*(_QWORD *)(v15 + 24) + 8 * IndexForKey);
      return BOMStorageReadFromBlock(*(_QWORD *)a1, v24, v17, v18, v19, v20, v21, v22);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BOMStorageReadFromBlock(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  char *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v20;
  int v21;
  int v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  int *v40;
  char v41;

  if (!a1 || !a2)
  {
    if (a1)
    {
      if (!a2)
        goto LABEL_13;
    }
    else
    {
      v16 = __error();
      _BOMExceptionHandlerCall("BOMStorageCopyFromBlock: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1013, *v16);
      if (!a2)
      {
LABEL_13:
        v10 = *__error();
        v11 = "BOMStorageCopyFromBlock: !bid";
        v12 = 1016;
        goto LABEL_27;
      }
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    v10 = *__error();
    v11 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    v12 = 1023;
LABEL_27:
    _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v12, v10);
    return 0;
  }
  v13 = *(_DWORD *)(a1 + 1068);
  if (v13 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
    v13 = *(_DWORD *)(a1 + 1068);
    v15 = -1;
  }
  else
  {
    v14 = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2));
    if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
      v15 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2);
    else
      v15 = v14;
  }
  if (v13 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    v17 = 0;
  }
  else
  {
    v17 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
    v18 = bswap32(v17);
    if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
      v17 = v18;
    if (v15 == -1 && v17 == -1)
    {
      v10 = *__error();
      v11 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
      v12 = 1032;
      goto LABEL_27;
    }
  }
  if (__CFADD__(v17, v15))
  {
    v10 = *__error();
    v11 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    v12 = 1038;
    goto LABEL_27;
  }
  if (v17 + v15 > *(_DWORD *)(a1 + 1032))
  {
    v10 = *__error();
    v11 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    v12 = 1042;
    goto LABEL_27;
  }
  if (!v17)
    return 0;
  v20 = *(_QWORD *)(a1 + 1080);
  if (v20 && (*(_BYTE *)(v20 + 4 * a2) & 1) != 0)
  {
    v21 = *(_DWORD *)(a1 + 1052);
LABEL_39:
    if ((v21 & 2) == 0)
      return 0;
    return *(_QWORD *)(a1 + 1040) + v15;
  }
  v21 = *(_DWORD *)(a1 + 1052);
  if ((v21 & 1) == 0)
    goto LABEL_39;
  v22 = *(_DWORD *)(a1 + 1028);
  if (v22 == -1)
    goto LABEL_39;
  if ((v21 & 2) == 0)
    return 0;
  v23 = BOMStreamWithFile(v22, v15, v17, 0, (char *)(*(_QWORD *)(a1 + 1040) + v15));
  if (!v23)
  {
    v10 = *__error();
    v11 = "BOMStorageCopyRangeFromBlockRange: !stream";
    v12 = 1070;
    goto LABEL_27;
  }
  BOMStreamFree((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30);
  v38 = *(_QWORD *)(a1 + 1080);
  if (v38)
  {
    *(_BYTE *)(v38 + 4 * a2) |= 1u;
  }
  else
  {
    v39 = BOMExceptionHandlerMessage("BOM blockShadowTable is null", v31, v32, v33, v34, v35, v36, v37, v41);
    v40 = __error();
    _BOMExceptionHandlerCall(v39, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1077, *v40);
  }
  return *(_QWORD *)(a1 + 1040) + v15;
}

uint64_t BOMTreeGetValueSize(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t PagesForKey;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int IndexForKey;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  BOOL v28;

  result = 1;
  if (a1 && a2 && a4 && (a3 || (*(_BYTE *)(a1 + 356) & 4) != 0))
  {
    PagesForKey = _findPagesForKey(a1, 0, a2, a3, a5, a6, a7, a8);
    if (PagesForKey
      && (v17 = PagesForKey, v28 = 0, IndexForKey = _findIndexForKey(a1, PagesForKey, a2, a3, &v28, v14, v15, v16), v28))
    {
      v25 = bswap32(*(_DWORD *)(*(_QWORD *)(v17 + 24) + 8 * IndexForKey));
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0)
        v26 = v25;
      else
        v26 = *(_DWORD *)(*(_QWORD *)(v17 + 24) + 8 * IndexForKey);
      v27 = BOMStorageSizeOfBlock(*(_QWORD *)a1, v26, v19, v20, v21, v22, v23, v24);
      result = 0;
      *a4 = v27;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t CUIRenditionKeyInitializeAttributeIndexWithKeyFormat(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;

  *(_QWORD *)(result + 192) = 0;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 80) = 0u;
  v2 = *(_DWORD *)(a2 + 8);
  if (v2 >= 0x40)
    v2 = 64;
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = *(unsigned __int16 *)(a2 + 12 + 4 * v3);
      *(_BYTE *)(result + 8 + v6) = v3;
      if (v6 <= 0x1C)
        *(_DWORD *)(result + 80 + 4 * v5++) = v6;
      v4 |= 1 << v6;
      ++v3;
      LODWORD(v6) = *(_DWORD *)(a2 + 8);
      if (v6 >= 0x40)
        v6 = 64;
      else
        v6 = v6;
    }
    while (v3 < v6);
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  *(_DWORD *)(result + 76) = v5;
  *(_QWORD *)result = v4;
  return result;
}

void sub_19EBCE69C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id _LookupThemeProvider(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  id v9;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  void (*v15)(uint64_t, uint64_t);
  void (*v16)(uint64_t);
  uint64_t v17;

  v12 = 0;
  v13 = &v12;
  v14 = 0x3052000000;
  v15 = __Block_byref_object_copy__2;
  v16 = __Block_byref_object_dispose__2;
  v17 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = ___LookupThemeProvider_block_invoke;
  v11[3] = &unk_1E41B2440;
  v11[4] = &v12;
  v11[5] = a1;
  __PerformBlockWithThemeRegistry((uint64_t)v11);
  v8 = (void *)v13[5];
  if (!v8)
  {
    _CUILog(4, (uint64_t)"CoreUI: CUIThemeStore: No theme registered with id=%lu", v2, v3, v4, v5, v6, v7, a1);
    v8 = (void *)v13[5];
  }
  v9 = v8;
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_19EBCEA4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PerformBlockWithThemeRegistry(uint64_t a1)
{
  if (__PerformBlockWithThemeRegistry___onceToken != -1)
    dispatch_once(&__PerformBlockWithThemeRegistry___onceToken, &__block_literal_global_13);
  os_unfair_lock_lock((os_unfair_lock_t)&__PerformBlockWithThemeRegistry___lock);
  (*(void (**)(uint64_t, uint64_t))(a1 + 16))(a1, __PerformBlockWithThemeRegistry___themeRegistry);
  os_unfair_lock_unlock((os_unfair_lock_t)&__PerformBlockWithThemeRegistry___lock);
}

uint64_t _findIndexForKey(uint64_t a1, uint64_t a2, void *__s1, unint64_t a4, BOOL *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  unsigned int v23;
  size_t v24;
  size_t v25;
  int v26;
  int v27;
  BOOL v28;

  if (*(_WORD *)(a2 + 16))
  {
    v12 = 0;
    v13 = *(unsigned __int16 *)(a2 + 16) - 1;
    while (1)
    {
      v14 = v12 + ((v13 - v12) >> 1);
      v15 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * (int)v14 + 4);
      v16 = *(_DWORD *)(a1 + 356);
      v17 = bswap32(v15);
      if ((v16 & 0x40) != 0)
        v18 = v17;
      else
        v18 = v15;
      if (!(_DWORD)v18)
      {
        v18 = 0;
LABEL_18:
        v19 = 0;
        goto LABEL_27;
      }
      if ((v16 & 4) != 0)
        goto LABEL_18;
      if ((v16 & 0x40) != 0)
      {
        v19 = *(unsigned int *)(a1 + 348);
        if ((int)v19 >= 1)
          goto LABEL_12;
        v15 = v17;
      }
      v19 = BOMStorageSizeOfBlock(*(_QWORD *)a1, v15, (uint64_t)__s1, a4, (uint64_t)a5, a6, a7, a8);
LABEL_12:
      v20 = *(unsigned int *)(a1 + 344);
      v18 = *(_QWORD *)(a1 + 336);
      if (v19 > v20)
      {
        v21 = (2 * v20);
        if (v19 > v21)
          LODWORD(v21) = v19;
        *(_DWORD *)(a1 + 344) = v21;
        if (v18)
        {
          free((void *)v18);
          *(_QWORD *)(a1 + 336) = 0;
          v22 = *(unsigned int *)(a1 + 344);
        }
        else
        {
          v22 = v21;
        }
        v18 = (unint64_t)BOM_malloc(v22);
        *(_QWORD *)(a1 + 336) = v18;
      }
      if ((*(_BYTE *)(a1 + 356) & 0x40) != 0)
      {
        v24 = *(unsigned int *)(a1 + 348);
        if ((int)v24 >= 1)
        {
          memcpy((void *)v18, (const void *)(*(_QWORD *)(a2 + 32) + v24 * (int)v14), v24);
          goto LABEL_27;
        }
        v23 = bswap32(*(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * (int)v14 + 4));
      }
      else
      {
        v23 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * (int)v14 + 4);
      }
      BOMStorageCopyFromBlock(*(_QWORD *)a1, v23, (void *)v18, a4, (uint64_t)a5, a6, a7, a8);
LABEL_27:
      if ((*(_BYTE *)(a1 + 356) & 4) != 0)
      {
        if (v18 <= (unint64_t)__s1)
          v27 = 0;
        else
          v27 = -1;
        if (v18 < (unint64_t)__s1)
          v26 = 1;
        else
          v26 = v27;
        goto LABEL_43;
      }
      if ((void *)v18 == __s1)
      {
        if (!a5)
          return v14;
        v26 = 0;
        v28 = 1;
        goto LABEL_47;
      }
      if (__s1)
      {
        if (!v18)
        {
          v26 = 1;
          goto LABEL_43;
        }
        if (a4 >= v19)
          v25 = v19;
        else
          v25 = a4;
        v26 = memcmp(__s1, (const void *)v18, v25);
        if (v26)
          goto LABEL_43;
        if (v19 <= a4)
        {
          v26 = v19 < a4;
          goto LABEL_43;
        }
      }
      v26 = -1;
LABEL_43:
      if (!a5)
        goto LABEL_48;
      v28 = v26 == 0;
LABEL_47:
      *a5 = v28;
LABEL_48:
      if (v13 == v12)
      {
        if (v26 <= 0)
          return v14;
        else
          return (v14 + 1);
      }
      if (v26 >= 1)
      {
        if ((_DWORD)v14 == v13)
          v12 += (v13 - v12) >> 1;
        else
          v12 = v14 + 1;
      }
      else
      {
        if ((v26 & 0x80000000) == 0)
          return v14;
        v13 = v14 - ((v13 - v12) > 1);
      }
    }
  }
  v14 = 0;
  if (a5)
    *a5 = 0;
  return v14;
}

uint64_t BOMStorageSizeOfBlock(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;

  result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) < a2)
      return 0;
    v11 = *(_DWORD *)(a1 + 1068);
    if (v11 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
      v11 = *(_DWORD *)(a1 + 1068);
    }
    else
    {
      v12 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2);
      v13 = bswap32(v12);
      if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
        v12 = v13;
      if (v12 != -1)
      {
LABEL_16:
        if (v11 > a2)
        {
          v16 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
          v17 = bswap32(v16);
          if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
            return v16;
          else
            return v17;
        }
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        return 0;
      }
    }
    if (v11 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
      v11 = *(_DWORD *)(a1 + 1068);
    }
    else
    {
      v14 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
      v15 = bswap32(v14);
      if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
        v14 = v15;
      if (v14 == -1)
        return 0;
    }
    goto LABEL_16;
  }
  return result;
}

uint64_t BOMStorageCopyFromBlockRange(uint64_t a1, unsigned int a2, uint64_t a3, size_t __len, void *__dst, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  char *v12;
  int v13;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int *v19;
  int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v28;
  int v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  int *v62;
  char v63;

  if (!a1 || !a2 || !__dst)
  {
    if (a1)
    {
      if (a2)
        goto LABEL_8;
    }
    else
    {
      v19 = __error();
      _BOMExceptionHandlerCall("BOMStorageCopyFromBlockRange: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1096, *v19);
      if (a2)
      {
LABEL_8:
        if (!__dst)
          goto LABEL_17;
        return 1;
      }
    }
    v20 = __error();
    _BOMExceptionHandlerCall("BOMStorageCopyFromBlockRange: !bid", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1098, *v20);
    if (!__dst)
    {
LABEL_17:
      v11 = *__error();
      v12 = "BOMStorageCopyFromBlockRange: !data";
      v13 = 1100;
      goto LABEL_43;
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    v11 = *__error();
    v12 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    v13 = 1106;
LABEL_43:
    _BOMExceptionHandlerCall(v12, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v13, v11);
    return 1;
  }
  v16 = *(_DWORD *)(a1 + 1068);
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
    v16 = *(_DWORD *)(a1 + 1068);
  }
  else
  {
    v17 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2);
    v18 = bswap32(v17);
    if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
      v17 = v18;
    if (v17 != -1)
      goto LABEL_25;
  }
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    v16 = *(_DWORD *)(a1 + 1068);
  }
  else
  {
    v21 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
    v22 = bswap32(v21);
    if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
      v21 = v22;
    if (v21 == -1)
    {
      v11 = *__error();
      v12 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
      v13 = 1111;
      goto LABEL_43;
    }
  }
LABEL_25:
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
    v16 = *(_DWORD *)(a1 + 1068);
    v24 = -1;
  }
  else
  {
    v23 = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2));
    if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
      v24 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2);
    else
      v24 = v23;
  }
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    v25 = 0;
  }
  else
  {
    v25 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
    v26 = bswap32(v25);
    if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
      v25 = v26;
  }
  if (__CFADD__(v25, v24))
  {
    v11 = *__error();
    v12 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    v13 = 1121;
    goto LABEL_43;
  }
  if (v25 + v24 > *(_DWORD *)(a1 + 1032))
  {
    v11 = *__error();
    v12 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    v13 = 1125;
    goto LABEL_43;
  }
  if (__CFADD__(__len, a3))
  {
    v11 = *__error();
    v12 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size overflow";
    v13 = 1136;
    goto LABEL_43;
  }
  if (__len + a3 > v25)
  {
    v11 = *__error();
    v12 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size";
    v13 = 1140;
    goto LABEL_43;
  }
  if (v25)
  {
    if (!v24)
    {
      v11 = *__error();
      v12 = "BOMStorageCopyRangeFromBlockRange: bad block address";
      v13 = 1148;
      goto LABEL_43;
    }
    v28 = *(_QWORD *)(a1 + 1080);
    if (v28 && (*(_BYTE *)(v28 + 4 * a2) & 1) != 0)
    {
      v29 = *(_DWORD *)(a1 + 1052);
    }
    else
    {
      v29 = *(_DWORD *)(a1 + 1052);
      if ((v29 & 1) != 0 && *(_DWORD *)(a1 + 1028) != -1)
        goto LABEL_55;
    }
    if ((v29 & 2) != 0)
    {
      v44 = (const void *)(*(_QWORD *)(a1 + 1040) + v24 + a3);
      goto LABEL_64;
    }
LABEL_55:
    v30 = *(_DWORD *)(a1 + 1028);
    if ((v29 & 2) == 0)
    {
      v31 = BOMStreamWithFile(v30, v24, v25, 0, 0);
      BOMStreamReadBuffer((uint64_t)v31, __dst, __len, v32, v33, v34, v35, v36);
      BOMStreamFree((uint64_t)v31, v37, v38, v39, v40, v41, v42, v43);
      return 0;
    }
    v45 = BOMStreamWithFile(v30, v24, v25, 0, (char *)(*(_QWORD *)(a1 + 1040) + v24));
    if (!v45)
    {
      v11 = *__error();
      v12 = "BOMStorageCopyRangeFromBlockRange: !stream";
      v13 = 1173;
      goto LABEL_43;
    }
    BOMStreamFree((uint64_t)v45, v46, v47, v48, v49, v50, v51, v52);
    v60 = *(_QWORD *)(a1 + 1080);
    if (v60)
    {
      *(_BYTE *)(v60 + 4 * a2) |= 1u;
    }
    else
    {
      v61 = BOMExceptionHandlerMessage("BOM blockShadowTable is null", v53, v54, v55, v56, v57, v58, v59, v63);
      v62 = __error();
      _BOMExceptionHandlerCall(v61, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1180, *v62);
    }
    v44 = (const void *)(*(_QWORD *)(a1 + 1040) + v24 + a3);
LABEL_64:
    memmove(__dst, v44, __len);
  }
  return 0;
}

uint64_t BOMStorageCopyFromBlock(uint64_t a1, unsigned int a2, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  char *v11;
  int v12;
  unsigned int v14;
  unsigned int v15;
  size_t v16;
  int *v17;

  if (!a1 || !a2)
  {
    if (a1)
    {
      if (!a2)
        goto LABEL_13;
    }
    else
    {
      v17 = __error();
      _BOMExceptionHandlerCall("BOMStorageCopyFromBlock: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 994, *v17);
      if (!a2)
      {
LABEL_13:
        v10 = *__error();
        v11 = "BOMStorageCopyFromBlock: !bid";
        v12 = 996;
        goto LABEL_14;
      }
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    v10 = *__error();
    v11 = "BOMStorageCopyFromBlock: bid > storage->blocks";
    v12 = 1000;
LABEL_14:
    _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v12, v10);
    return 1;
  }
  if (*(_DWORD *)(a1 + 1068) <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)__dst, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    v16 = 0;
  }
  else
  {
    v14 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
    v15 = bswap32(v14);
    if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
      v16 = v14;
    else
      v16 = v15;
  }
  return BOMStorageCopyFromBlockRange(a1, a2, 0, v16, __dst, a6, a7, a8);
}

uint64_t CUIBitVectorNumberOfBitsSetInBucket(uint64_t a1, unsigned int a2)
{
  uint8x8_t v2;

  v2 = (uint8x8_t)vcnt_s8((int8x8_t)*(unsigned int *)(a1 + 4 * (a2 >> 5) + 8));
  v2.i16[0] = vaddlv_u8(v2);
  return v2.u32[0];
}

_DWORD *CUIBitVectorFromData(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v5;
  unint64_t v6;

  v2 = *a1;
  v3 = 4 * v2;
  if (4 * v2 + 4 != a2)
    return 0;
  v5 = malloc_type_malloc(v3 + 8, 0x7EDDED84uLL);
  bzero(v5, v3 + 8);
  __CFSetLastAllocationEventName(v5, "CUIBitmapVector");
  *v5 = 0;
  v5[1] = v2;
  if ((_DWORD)v2)
  {
    v6 = 0;
    do
    {
      v5[v6 / 4 + 2] = a1[v6 / 4 + 1];
      v6 += 4;
    }
    while (v3 != v6);
  }
  return v5;
}

uint64_t CUIMaxScaleForTargetPlatform(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) >= 2)
    return 2;
  else
    return 3;
}

uint64_t CUICurrentDeploymentVersionForTargetPlatform()
{
  return 11;
}

const char *CUISystemThemeRenditionKeyFormat()
{
  return "tmfk";
}

void sub_19EBD0A8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t _CUIColorSpaceGetGrayGamma2_2()
{
  if (_CUIColorSpaceGetGrayGamma2_2___once != -1)
    dispatch_once(&_CUIColorSpaceGetGrayGamma2_2___once, &__block_literal_global_6);
  return _CUIColorSpaceGetGrayGamma2_2_sGenericGrayColorSpace;
}

uint64_t _CUIColorSpaceGetDisplayP3()
{
  if (_CUIColorSpaceGetDisplayP3___once != -1)
    dispatch_once(&_CUIColorSpaceGetDisplayP3___once, &__block_literal_global_10);
  return _CUIColorSpaceGetDisplayP3_sDisplayP3ColorSpace;
}

void sub_19EBD1420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBD14C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19EBD1670(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19EBD1740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBD1810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CUIAccumulateSVGShapesIntoPath(uint64_t a1, uint64_t a2, CGPath *a3)
{
  const CGPath *CompoundCGPath;

  CompoundCGPath = (const CGPath *)CGSVGNodeCreateCompoundCGPath();
  CGPathAddPath(a3, 0, CompoundCGPath);
  CGPathRelease(CompoundCGPath);
}

void sub_19EBD3794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBD3AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBD3CA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL CUISVGAttributeGetBoolean(uint64_t a1)
{
  _BOOL8 v1;
  const __CFString *v2;
  const __CFString *v3;
  unsigned int v5;

  if (!a1)
    return 0;
  v5 = 0;
  v1 = 0;
  if (!CGSVGAttributeGetAtom(a1, &v5))
    return v1;
  v2 = (const __CFString *)CGSVGAtomCopyString(v5);
  if (!v2)
    return 0;
  v3 = v2;
  v1 = CFStringCompare(v2, CFSTR("1"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v3, CFSTR("true"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v3, CFSTR("yes"), 1uLL) == kCFCompareEqualTo;
  CFRelease(v3);
  return v1;
}

void sub_19EBD4D54(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _CUILog(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  uint8_t buf[24];

  if (_CUILog___onceDefaultToken != -1)
    dispatch_once(&_CUILog___onceDefaultToken, &__block_literal_global_27_0);
  if (a1 != 3 || _CUILog___showDebugLogs)
  {
    v11 = (void *)MEMORY[0x1A1AEEF7C]();
    if (__logToStderr)
    {
      *(_QWORD *)buf = &a9;
      v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a2);
      v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v12, &a9);

      switch(a1)
      {
        case 1:
        case 2:
        case 3:
          fprintf(__stderrp, "%s\n", (const char *)objc_msgSend(v13, "UTF8String"));
          break;
        case 4:
          fprintf(__stderrp, "%s\n", (const char *)objc_msgSend(v13, "UTF8String"));
          goto LABEL_30;
        default:
          break;
      }
    }
    else
    {
      v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a2);
      v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v14, &a9);

      switch(a1)
      {
        case 1:
          if (__onceToken != -1)
            dispatch_once(&__onceToken, &__block_literal_global_3);
          v15 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v13;
            v16 = v15;
            v17 = OS_LOG_TYPE_DEFAULT;
            goto LABEL_22;
          }
          break;
        case 2:
          if (__onceToken != -1)
            dispatch_once(&__onceToken, &__block_literal_global_3);
          v18 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v13;
            v16 = v18;
            v17 = OS_LOG_TYPE_INFO;
            goto LABEL_22;
          }
          break;
        case 3:
          if (__onceToken != -1)
            dispatch_once(&__onceToken, &__block_literal_global_3);
          v19 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v13;
            v16 = v19;
            v17 = OS_LOG_TYPE_DEBUG;
LABEL_22:
            _os_log_impl(&dword_19EBC9000, v16, v17, "%{public}@", buf, 0xCu);
          }
          break;
        case 4:
          if (__onceToken != -1)
            dispatch_once(&__onceToken, &__block_literal_global_3);
          v20 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v13;
            _os_log_impl(&dword_19EBC9000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            if (__onceToken != -1)
              dispatch_once(&__onceToken, &__block_literal_global_3);
          }
          v21 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_FAULT))
            _CUILog_cold_1((uint64_t)v13, v21);
LABEL_30:
          qword_1EE5343C8 = (uint64_t)objc_msgSend(v13, "UTF8String");
          break;
        default:
          break;
      }
    }

    objc_autoreleasePoolPop(v11);
  }
}

uint64_t CUIPlatformForPlatformString(void *a1)
{
  if ((objc_msgSend(a1, "isEqualToString:", kCUIPlatformMac[0]) & 1) != 0
    || (objc_msgSend(a1, "isEqualToString:", CFSTR("osx")) & 1) != 0)
  {
    return 0;
  }
  if ((objc_msgSend(a1, "isEqualToString:", kCUIPlatformMaciOS) & 1) != 0)
    return 2;
  if ((objc_msgSend(a1, "isEqualToString:", kCUIPlatformiOS) & 1) != 0
    || (objc_msgSend(a1, "isEqualToString:", CFSTR("iphoneos")) & 1) != 0)
  {
    return 1;
  }
  if ((objc_msgSend(a1, "isEqualToString:", kCUIPlatformAppleTV) & 1) != 0)
    return 3;
  if ((objc_msgSend(a1, "isEqualToString:", kCUIPlatformWatch[0]) & 1) != 0)
    return 4;
  if ((objc_msgSend(a1, "isEqualToString:", kCUIPlatformVision) & 1) != 0)
    return 5;
  if (objc_msgSend(a1, "isEqualToString:", CFSTR("xros")))
    return 5;
  return -1;
}

void sub_19EBD71F0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19EBD73F8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

unint64_t BOMTreeGetValue(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int IndexForKey;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  void *v32;
  unint64_t v33;
  unsigned int v34;
  unsigned int v35;
  BOOL v36;

  result = 0;
  v36 = 0;
  if (a1 && a2)
  {
    if (!a3 && (*(_BYTE *)(a1 + 356) & 4) == 0)
      return 0;
    result = _findPagesForKey(a1, 0, a2, a3, a5, a6, a7, a8);
    if (!result)
      return result;
    v15 = result;
    IndexForKey = _findIndexForKey(a1, result, a2, a3, &v36, v12, v13, v14);
    if (!v36)
      return 0;
    v23 = IndexForKey;
    v24 = bswap32(*(_DWORD *)(*(_QWORD *)(v15 + 24) + 8 * IndexForKey));
    v25 = (*(_DWORD *)(a1 + 356) & 0x40) != 0 ? v24 : *(_DWORD *)(*(_QWORD *)(v15 + 24) + 8 * IndexForKey);
    result = BOMStorageSizeOfBlock(*(_QWORD *)a1, v25, v17, v18, v19, v20, v21, v22);
    if (result)
    {
      v31 = result;
      v32 = *(void **)(a1 + 320);
      if (v32)
      {
        if (result <= *(unsigned int *)(a1 + 328))
          goto LABEL_19;
        free(*(void **)(a1 + 320));
        *(_QWORD *)(a1 + 320) = 0;
        v33 = (2 * *(_DWORD *)(a1 + 328));
        if (v31 <= v33)
          result = v33;
        else
          result = v31;
        *(_DWORD *)(a1 + 328) = result;
      }
      else
      {
        *(_DWORD *)(a1 + 328) = result;
        result = result;
      }
      v32 = BOM_malloc(result);
      *(_QWORD *)(a1 + 320) = v32;
LABEL_19:
      v34 = bswap32(*(_DWORD *)(*(_QWORD *)(v15 + 24) + 8 * v23));
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0)
        v35 = v34;
      else
        v35 = *(_DWORD *)(*(_QWORD *)(v15 + 24) + 8 * v23);
      if (!BOMStorageCopyFromBlock(*(_QWORD *)a1, v35, v32, v26, v27, v28, v29, v30))
        return *(_QWORD *)(a1 + 320);
      return 0;
    }
  }
  return result;
}

uint64_t BOMTreeIteratorKeySize(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;

  if (result)
  {
    v8 = result;
    if ((*(_BYTE *)(result + 57) & 8) != 0)
      return 0;
    if (((*(_BYTE *)(result + 57) & 1) != 0 || (v9 = *(_DWORD **)(result + 8)) == 0
                                             || *v9 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8))
    {
      result = 0;
      *(_BYTE *)(v8 + 57) |= 8u;
      return result;
    }
    v10 = *(_QWORD *)v8;
    v11 = *(_DWORD *)(*(_QWORD *)v8 + 356);
    if ((v11 & 4) != 0)
    {
      return 0;
    }
    else
    {
      if ((v11 & 0x40) == 0)
      {
        v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
        return BOMStorageSizeOfBlock(*(_QWORD *)v10, v12, a3, a4, a5, a6, a7, a8);
      }
      result = *(unsigned int *)(v10 + 348);
      if ((int)result < 1)
      {
        v12 = bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4));
        return BOMStorageSizeOfBlock(*(_QWORD *)v10, v12, a3, a4, a5, a6, a7, a8);
      }
    }
  }
  return result;
}

uint64_t BOMTreeIteratorValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v9;
  _DWORD *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void *v22;
  size_t v23;
  unsigned int v24;
  unsigned int v25;

  if (result)
  {
    v8 = result;
    v9 = *(_BYTE *)(result + 57);
    if ((v9 & 8) != 0)
      return 0;
    if ((*(_BYTE *)(result + 57) & 1) == 0
      && (v10 = *(_DWORD **)(result + 8)) != 0
      && *v10 == *(_DWORD *)(result + 16)
      || (v11 = _revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8), v9 = *(_BYTE *)(v8 + 57), v11))
    {
      if ((v9 & 4) == 0)
      {
        v12 = bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20)));
        if ((*(_DWORD *)(*(_QWORD *)v8 + 356) & 0x40) != 0)
          v13 = v12;
        else
          v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20));
        v14 = BOMStorageSizeOfBlock(**(_QWORD **)v8, v13, a3, a4, a5, a6, a7, a8);
        v20 = *(_QWORD *)(v8 + 48);
        if (v14 > v20)
        {
          v21 = v14;
          v22 = *(void **)(v8 + 40);
          if (v22)
          {
            free(v22);
            *(_QWORD *)(v8 + 40) = 0;
            v20 = *(_QWORD *)(v8 + 48);
          }
          if (v21 <= 2 * v20)
            v23 = 2 * v20;
          else
            v23 = v21;
          *(_QWORD *)(v8 + 48) = v23;
          *(_QWORD *)(v8 + 40) = BOM_malloc(v23);
        }
        v24 = bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20)));
        if ((*(_DWORD *)(*(_QWORD *)v8 + 356) & 0x40) != 0)
          v25 = v24;
        else
          v25 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20));
        if (BOMStorageCopyFromBlock(**(_QWORD **)v8, v25, *(void **)(v8 + 40), v15, v16, v17, v18, v19))
          return 0;
        *(_BYTE *)(v8 + 57) |= 4u;
      }
      return *(_QWORD *)(v8 + 40);
    }
    else
    {
      result = 0;
      *(_BYTE *)(v8 + 57) = v9 | 8;
    }
  }
  return result;
}

uint64_t BOMStorageOpenWithSys(uint64_t a1, int a2, __int128 *a3)
{
  __int128 *v3;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  BOOL v85;
  unsigned int v86;
  char *v87;
  int v88;
  char *v89;
  int v90;
  int *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  int *v100;
  int *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char *v110;
  char *v111;
  int v112;
  char *v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v132;
  int *v133;
  char v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char *v142;
  int *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  char *v152;
  int v153;
  int v154;
  unsigned int v155;
  char *v156;
  char *v157;
  unsigned int v158;
  uint64_t v159;
  uint64_t v160;
  _QWORD *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t (*v169)(_QWORD, _QWORD);
  uint64_t v170;
  NSObject *v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  char *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  int *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  _OWORD v213[6];
  __int128 v214;
  __int128 v215;
  __int128 v216;
  uint8_t buf[4];
  uint64_t v218;
  __int16 v219;
  uint64_t v220;

  v3 = a3;
  if (!a3)
    v3 = BomSys_default();
  v215 = 0u;
  v216 = 0u;
  v214 = 0u;
  memset(v213, 0, sizeof(v213));
  v6 = (*((uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))v3 + 2))(*((_QWORD *)v3 + 1), a1, 2 * (a2 != 0), 420);
  if ((_DWORD)v6 != -1)
  {
    v7 = v6;
    if ((*((unsigned int (**)(_QWORD, uint64_t, _OWORD *))v3 + 9))(*((_QWORD *)v3 + 1), v6, v213) != -1)
    {
      v8 = BOMStreamWithFileAndSys(v7, 0, 0x200uLL, 0, 0, v3);
      if (!v8)
      {
        v122 = __error();
        strerror(*v122);
        v130 = BOMExceptionHandlerMessage("can't read from: '%s' %s", v123, v124, v125, v126, v127, v128, v129, a1);
        v88 = *__error();
        v89 = v130;
        v90 = 286;
        goto LABEL_18;
      }
      v16 = (uint64_t)v8;
      if (BOMStreamReadUInt32((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15) == 1112493395
        && BOMStreamReadUInt32(v16, v17, v18, v19, v20, v21, v22, v23) == 1953460837)
      {
        if (BOMStreamReadUInt32(v16, v17, v18, v19, v20, v21, v22, v23) == 1)
        {
          v31 = BOM_malloczero(0x470uLL);
          v39 = (uint64_t)v31;
          if (!v31)
          {
            v133 = __error();
            v134 = strerror(*v133);
            v142 = BOMExceptionHandlerMessage("malloc: %s", v135, v136, v137, v138, v139, v140, v141, v134);
            v143 = __error();
            _BOMExceptionHandlerCall(v142, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 317, *v143);
            BOMStreamFree(v16, v144, v145, v146, v147, v148, v149, v150);
            (*((void (**)(_QWORD, uint64_t))v3 + 3))(*((_QWORD *)v3 + 1), v7);
            return v39;
          }
          v31[140] = v3;
          *((_DWORD *)v31 + 257) = v7;
          v40 = v214;
          *((_DWORD *)v31 + 258) = v214;
          *((_DWORD *)v31 + 259) = v40;
          *((_DWORD *)v31 + 263) = *((_DWORD *)v31 + 263) & 0xFFFFFFF6 | a2 & 1;
          *((_DWORD *)v31 + 264) = BOMStreamReadUInt32(v16, v32, v33, v34, v35, v36, v37, v38);
          *(_DWORD *)(v39 + 1060) = BOMStreamReadUInt32(v16, v41, v42, v43, v44, v45, v46, v47);
          *(_DWORD *)(v39 + 1064) = BOMStreamReadUInt32(v16, v48, v49, v50, v51, v52, v53, v54);
          *(_DWORD *)(v39 + 1096) = BOMStreamReadUInt32(v16, v55, v56, v57, v58, v59, v60, v61);
          *(_DWORD *)(v39 + 1100) = BOMStreamReadUInt32(v16, v62, v63, v64, v65, v66, v67, v68);
          *(_DWORD *)(v39 + 1052) &= ~4u;
          *(_QWORD *)(v39 + 1128) = 0;
          BOMStreamFree(v16, v69, v70, v71, v72, v73, v74, v75);
          v83 = *(_DWORD *)(v39 + 1060);
          v84 = *(_DWORD *)(v39 + 1064);
          v85 = __CFADD__(v84, v83);
          v86 = v84 + v83;
          if (v85)
          {
            v87 = BOMExceptionHandlerMessage("%s: stream invalid; overflow of admin offset+size",
                    v76,
                    v77,
                    v78,
                    v79,
                    v80,
                    v81,
                    v82,
                    a1);
            v88 = *__error();
            v89 = v87;
            v90 = 344;
          }
          else
          {
            v151 = *(unsigned int *)(v39 + 1032);
            if (v86 <= v151)
            {
              v153 = *(_DWORD *)(v39 + 1096);
              v154 = *(_DWORD *)(v39 + 1100);
              v85 = __CFADD__(v154, v153);
              v155 = v154 + v153;
              if (v85)
              {
                v156 = BOMExceptionHandlerMessage("%s: stream invalid; overflow of toc offset+size",
                         v76,
                         v151,
                         v78,
                         v79,
                         v80,
                         v81,
                         v82,
                         a1);
                v88 = *__error();
                v89 = v156;
                v90 = 358;
              }
              else
              {
                if (v155 <= v151)
                {
                  if (a2)
                  {
                    if (v151 <= 0x800)
                      v158 = 2048;
                    else
                      v158 = *(_DWORD *)(v39 + 1032);
                    *(_DWORD *)(v39 + 1048) = v158;
                    _CreateMapAddress(v39, v158);
                    v159 = *(_QWORD *)(v39 + 1040);
                    if (!v159)
                      goto LABEL_19;
                    *(_DWORD *)(v39 + 1052) |= 0xAu;
                    v160 = *(unsigned int *)(v39 + 1096);
                    if ((_DWORD)v160)
                    {
                      v161 = BOMStreamWithFileAndSys(*(_DWORD *)(v39 + 1028), v160, *(unsigned int *)(v39 + 1100), 0, (char *)(v159 + v160), v3);
                      if (!v161)
                        goto LABEL_19;
                      BOMStreamFree((uint64_t)v161, v162, v163, v164, v165, v166, v167, v168);
                    }
                  }
                  else
                  {
                    v169 = (uint64_t (*)(_QWORD, _QWORD))*((_QWORD *)v3 + 12);
                    if (!v169)
                      goto LABEL_48;
                    v170 = v169(*((_QWORD *)v3 + 1), 0);
                    if (CUILogRenditionLogEnabled())
                    {
                      v171 = CUILogHandle();
                      if (os_log_type_enabled(v171, OS_LOG_TYPE_INFO))
                      {
                        *(_DWORD *)buf = 136446466;
                        v218 = a1;
                        v219 = 2050;
                        v220 = v170;
                        _os_log_impl(&dword_19EBC9000, v171, OS_LOG_TYPE_INFO, "CoreUI %{public}s %{public}p", buf, 0x16u);
                      }
                    }
                    if (v170 == -1)
                    {
LABEL_48:
                      *(_DWORD *)(v39 + 1048) = 0;
                      *(_QWORD *)(v39 + 1040) = 0;
                      *(_DWORD *)(v39 + 1052) &= ~2u;
                      __error();
                      _CUILog(1, (uint64_t)"mmap failed for '%s' using regular file reading %d", v175, v176, v177, v178, v179, v180, a1);
                    }
                    else
                    {
                      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v39 + 1120) + 24))(*(_QWORD *)(*(_QWORD *)(v39 + 1120) + 8), *(unsigned int *)(v39 + 1028));
                      *(_DWORD *)(v39 + 1028) = -1;
                      v172 = *(_DWORD *)(v39 + 1052);
                      *(_DWORD *)(v39 + 1048) = *(_DWORD *)(v39 + 1032);
                      *(_QWORD *)(v39 + 1040) = v170;
                      *(_DWORD *)(v39 + 1052) = v172 | 0xA;
                      v173 = *(unsigned int *)(v39 + 1060);
                      if ((_DWORD)v173)
                        madvise((void *)(v170 + v173), *(unsigned int *)(v39 + 1064), 3);
                      v174 = *(unsigned int *)(v39 + 1096);
                      if ((_DWORD)v174)
                        madvise((void *)(*(_QWORD *)(v39 + 1040) + v174), *(unsigned int *)(v39 + 1100), 3);
                    }
                  }
                  _CreateBlockTable((_QWORD *)v39);
                  v181 = *(unsigned int *)(v39 + 1060);
                  if ((_DWORD)v181)
                  {
                    if (!a2 && (*(_BYTE *)(v39 + 1052) & 2) != 0)
                    {
                      v183 = BOMStreamWithAddress(*(_QWORD *)(v39 + 1040) + v181, *(unsigned int *)(v39 + 1064), 0);
                    }
                    else
                    {
                      v182 = (char *)BOM_malloczero(*(unsigned int *)(v39 + 1064));
                      *(_QWORD *)(v39 + 1128) = v182;
                      if (!v182)
                      {
                        v191 = __error();
                        strerror(*v191);
                        _CUILog(4, (uint64_t)"%s: malloc: %s", v192, v193, v194, v195, v196, v197, (uint64_t)"BOMStorage BOMStorageOpenWithSys(const char *, Boolean, BomSys *)");
                        return 0;
                      }
                      v183 = (uint64_t)BOMStreamWithFileAndSys(v7, *(unsigned int *)(v39 + 1060), *(unsigned int *)(v39 + 1064), 0, v182, v3);
                    }
                    v198 = v183;
                    if (!v183)
                    {
                      v212 = BOMExceptionHandlerMessage("can't read from %s unable to create a BOMStream", v184, v185, v186, v187, v188, v189, v190, a1);
                      v88 = *__error();
                      v89 = v212;
                      v90 = 452;
                      goto LABEL_18;
                    }
                    if (_ReadBlockTable(v39, v183, v185, v186, v187, v188, v189, v190)
                      || _ReadFreeList(v39, v198, v199, v200, v201, v202, v203, v204))
                    {
                      goto LABEL_19;
                    }
                    BOMStreamFree(v198, v205, v206, v207, v208, v209, v210, v211);
                  }
                  else
                  {
                    *(_QWORD *)(v39 + 1088) = _BOMFreeListAllocate();
                  }
                  __strlcpy_chk(v39, a1, 1025, 1025);
                  return v39;
                }
                v157 = BOMExceptionHandlerMessage("%s: stream invalid; toc range is outside of file",
                         v76,
                         v151,
                         v78,
                         v79,
                         v80,
                         v81,
                         v82,
                         a1);
                v88 = *__error();
                v89 = v157;
                v90 = 365;
              }
            }
            else
            {
              v152 = BOMExceptionHandlerMessage("%s: stream invalid; admin range is outside of file",
                       v76,
                       v151,
                       v78,
                       v79,
                       v80,
                       v81,
                       v82,
                       a1);
              v88 = *__error();
              v89 = v152;
              v90 = 351;
            }
          }
LABEL_18:
          _BOMExceptionHandlerCall(v89, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v90, v88);
          goto LABEL_19;
        }
        v132 = BOMExceptionHandlerMessage("%s has an unknown version: 0x%X", v24, v25, v26, v27, v28, v29, v30, a1);
        v112 = *__error();
        v113 = v132;
        v114 = 307;
      }
      else
      {
        v111 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", v17, v18, v19, v20, v21, v22, v23, a1);
        v112 = *__error();
        v113 = v111;
        v114 = 293;
      }
      _BOMExceptionHandlerCall(v113, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v114, v112);
      BOMStreamFree(v16, v115, v116, v117, v118, v119, v120, v121);
LABEL_19:
      (*((void (**)(_QWORD, uint64_t))v3 + 3))(*((_QWORD *)v3 + 1), v7);
      return 0;
    }
    v101 = __error();
    v102 = strerror(*v101);
    v110 = BOMExceptionHandlerMessage("fstat: %s", v103, v104, v105, v106, v107, v108, v109, v102);
    v88 = *__error();
    v89 = v110;
    v90 = 277;
    goto LABEL_18;
  }
  v91 = __error();
  strerror(*v91);
  v99 = BOMExceptionHandlerMessage("can't open: '%s' %s", v92, v93, v94, v95, v96, v97, v98, a1);
  v100 = __error();
  _BOMExceptionHandlerCall(v99, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 270, *v100);
  return 0;
}

uint64_t CUILogRenditionLogEnabled()
{
  return __renditionLogginEnabled;
}

uint64_t BOMTreeIteratorIsAtEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  _DWORD *v10;
  int v11;

  if (!a1)
    return 1;
  v9 = *(unsigned __int8 *)(a1 + 57);
  if ((v9 & 8) != 0)
    return 1;
  if ((v9 & 1) != 0 || (v10 = *(_DWORD **)(a1 + 8)) == 0 || *v10 != *(_DWORD *)(a1 + 16))
  {
    v11 = _revalidateIterator(a1, a2, a3, a4, a5, a6, a7, a8);
    v9 = *(unsigned __int8 *)(a1 + 57);
    if (!v11)
    {
      v9 |= 8u;
      *(_BYTE *)(a1 + 57) = v9;
    }
  }
  return (v9 >> 3) & 1;
}

uint64_t BOMTreeIteratorKey(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  void *v17;
  size_t v18;
  uint64_t v19;
  unsigned int v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;

  if (result)
  {
    v8 = result;
    if ((*(_BYTE *)(result + 57) & 8) != 0)
      return 0;
    if (((*(_BYTE *)(result + 57) & 1) != 0 || (v9 = *(_DWORD **)(result + 8)) == 0
                                             || *v9 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8))
    {
      result = 0;
      *(_BYTE *)(v8 + 57) |= 8u;
      return result;
    }
    v10 = *(_QWORD *)v8;
    v11 = *(_DWORD *)(*(_QWORD *)v8 + 356);
    if ((v11 & 4) == 0)
    {
      if ((*(_BYTE *)(v8 + 57) & 2) != 0)
        return *(_QWORD *)(v8 + 24);
      if ((v11 & 0x40) != 0)
      {
        v15 = *(unsigned int *)(v10 + 348);
        if ((int)v15 >= 1)
        {
LABEL_18:
          v16 = *(_QWORD *)(v8 + 32);
          if (v15 > v16)
          {
            v17 = *(void **)(v8 + 24);
            if (v17)
            {
              free(v17);
              *(_QWORD *)(v8 + 24) = 0;
              v16 = *(_QWORD *)(v8 + 32);
            }
            if (v15 <= 2 * v16)
              v18 = 2 * v16;
            else
              v18 = v15;
            *(_QWORD *)(v8 + 32) = v18;
            *(_QWORD *)(v8 + 24) = BOM_malloc(v18);
          }
          v19 = *(_QWORD *)v8;
          if ((*(_BYTE *)(*(_QWORD *)v8 + 356) & 0x40) == 0)
          {
            v20 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
            goto LABEL_31;
          }
          v21 = *(unsigned int *)(v19 + 348);
          v22 = *(_QWORD *)(v8 + 8);
          if ((int)v21 < 1)
          {
            v20 = bswap32(*(_DWORD *)(*(_QWORD *)(v22 + 24) + 8 * *(int *)(v8 + 20) + 4));
LABEL_31:
            if (BOMStorageCopyFromBlock(*(_QWORD *)v19, v20, *(void **)(v8 + 24), a4, a5, a6, a7, a8))
              return 0;
            goto LABEL_34;
          }
          v23 = *(_QWORD *)(v22 + 32);
          if (v23)
          {
            memcpy(*(void **)(v8 + 24), (const void *)(v23 + *(int *)(v8 + 20) * v21), v21);
LABEL_34:
            *(_BYTE *)(v8 + 57) |= 2u;
            return *(_QWORD *)(v8 + 24);
          }
          return 0;
        }
        v12 = bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4));
      }
      else
      {
        v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
      }
      v15 = BOMStorageSizeOfBlock(*(_QWORD *)v10, v12, a3, a4, a5, a6, a7, a8);
      goto LABEL_18;
    }
    v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
    v14 = bswap32(v13);
    if ((v11 & 0x40) != 0)
      return v14;
    else
      return v13;
  }
  return result;
}

uint64_t BOMTreeIteratorNext(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  char v13;

  if (result)
  {
    v8 = result;
    if ((*(_BYTE *)(result + 57) & 8) == 0)
    {
      if ((*(_BYTE *)(result + 57) & 1) == 0
        && (v9 = *(_DWORD **)(result + 8)) != 0
        && *v9 == *(_DWORD *)(result + 16)
        || (result = _revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8), (_DWORD)result))
      {
        if (*(_BYTE *)(v8 + 56))
        {
          v10 = *(_DWORD *)(v8 + 20) + 1;
          *(_DWORD *)(v8 + 20) = v10;
          v11 = *(_QWORD *)(v8 + 8);
          if (v10 >= *(unsigned __int16 *)(v11 + 16))
          {
            *(_DWORD *)(v8 + 20) = 0;
            v12 = *(_DWORD *)(v11 + 8);
            if (!v12
              || (*(_DWORD *)(v8 + 16) = v12,
                  result = (uint64_t)_findPage(*(_QWORD *)v8, v12, a3, a4, a5, a6, a7, a8),
                  (*(_QWORD *)(v8 + 8) = result) == 0))
            {
              *(_BYTE *)(v8 + 57) |= 8u;
            }
          }
        }
        else
        {
          *(_BYTE *)(v8 + 56) = 1;
        }
        v13 = *(_BYTE *)(v8 + 57) & 0xF9;
      }
      else
      {
        v13 = *(_BYTE *)(v8 + 57) | 8;
      }
      *(_BYTE *)(v8 + 57) = v13;
    }
  }
  return result;
}

uint64_t BOMTreeOpenWithName(uint64_t a1, const char *a2, char a3)
{
  unsigned int NamedBlock;

  if (a1 && a2 && (NamedBlock = BOMStorageGetNamedBlock(a1, a2)) != 0)
    return _BOMTreeOpen(a1, a2, NamedBlock, a3);
  else
    return 0;
}

uint64_t _BOMTreeOpen(uint64_t a1, const char *a2, unsigned int a3, char a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int UInt32;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;

  v8 = _newBOMTree(a1, a2);
  v15 = (uint64_t)v8;
  if (!v8)
    return v15;
  *v8 = a1;
  *((_DWORD *)v8 + 4) = a3;
  v22 = BOMStorageSizeOfBlock(a1, a3, v9, v10, v11, v12, v13, v14);
  v23 = *(_QWORD *)v15;
  if ((*(_BYTE *)(v15 + 356) & 0x40) != 0)
  {
    v32 = BOMStorageReadFromBlock(v23, a3, v16, v17, v18, v19, v20, v21);
    if (!v32)
      goto LABEL_22;
    v33 = (void *)v32;
    v31 = BOMStreamWithAddress(v32, v22, 0);
    madvise(v33, v22, 3);
    if (!v31)
      goto LABEL_22;
  }
  else
  {
    v31 = BOMStreamWithBlockID(v23, a3, v22, 0);
    if (!v31)
      goto LABEL_22;
  }
  if (BOMStreamReadUInt32(v31, v24, v25, v26, v27, v28, v29, v30) != 1953654117)
  {
    if (a2)
      _CUILog(4, (uint64_t)"%s: '%s' is not a BOMTree", v35, v36, v37, v38, v39, v40, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    else
      _CUILog(4, (uint64_t)"%s: '<Tree %d>' is not a BOMTree", v35, v36, v37, v38, v39, v40, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    goto LABEL_21;
  }
  if (BOMStreamReadUInt32(v31, v34, v35, v36, v37, v38, v39, v40) != 1)
  {
    if (a2)
      _CUILog(4, (uint64_t)"%s: BOMTree '%s' has an unknown version: 0x%X", v42, v43, v44, v45, v46, v47, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    else
      _CUILog(4, (uint64_t)"%s: BOMTree '<Tree %d>' has an unknown version: 0x%X", v42, v43, v44, v45, v46, v47, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
LABEL_21:
    BOMStreamFree(v31, v99, v100, v101, v102, v103, v104, v105);
LABEL_22:
    BOMTreeFree(v15);
    return 0;
  }
  UInt32 = BOMStreamReadUInt32(v31, v41, v42, v43, v44, v45, v46, v47);
  *(_DWORD *)(v15 + 304) = BOMStreamReadUInt32(v31, v49, v50, v51, v52, v53, v54, v55);
  *(_DWORD *)(v15 + 20) = BOMStreamReadUInt32(v31, v56, v57, v58, v59, v60, v61, v62);
  *(_DWORD *)(v15 + 356) = *(_DWORD *)(v15 + 356) & 0xFFFFFFFB | (4
                                                                * (BOMStreamReadUInt8(v31, v63, v64, v65, v66, v67, v68, v69) & 1));
  if (!BOMStreamAtEOF(v31, v70, v71, v72, v73, v74, v75, v76))
  {
    *(_DWORD *)(v15 + 348) = BOMStreamReadUInt32(v31, v77, v78, v79, v80, v81, v82, v83);
    if (!BOMStreamAtEOF(v31, v84, v85, v86, v87, v88, v89, v90))
      *(_DWORD *)(v15 + 352) = BOMStreamReadUInt32(v31, v77, v78, v79, v80, v81, v82, v83);
  }
  BOMStreamFree(v31, v77, v78, v79, v80, v81, v82, v83);
  v91 = *(_DWORD *)(v15 + 304) - 16;
  *(_DWORD *)(v15 + 308) = v91 >> 3;
  *(_DWORD *)(v15 + 312) = (v91 >> 3) + 1;
  *(_DWORD *)(v15 + 316) = v91 >> 4;
  v92 = _NewPage(v15, UInt32);
  *(_QWORD *)(v15 + 24) = v92;
  if (!v92 || _ReadPage(v15, (uint64_t)v92, v93, v94, v95, v96, v97, v98))
    goto LABEL_22;
  *(_DWORD *)(v15 + 356) = *(_DWORD *)(v15 + 356) & 0xFFFFFFFD | (2 * (a4 & 1));
  return v15;
}

uint64_t _tocGet(uint64_t a1, const char *a2)
{
  uint64_t v4;
  size_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int UInt32;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int UInt8;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  void *v50;
  unsigned int v51;
  unsigned int v52;
  size_t v53;
  char __s2[256];

  if (!a1)
    return 0;
  v4 = *(unsigned int *)(a1 + 1096);
  if (!(_DWORD)v4)
    return 0;
  v5 = *(unsigned int *)(a1 + 1100);
  if (!(_DWORD)v5)
    return 0;
  v6 = (*(_BYTE *)(a1 + 1052) & 2) != 0
     ? (_QWORD *)BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v4, *(unsigned int *)(a1 + 1100), 0)
     : BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v4, v5, 0, 0);
  v14 = (uint64_t)v6;
  if (!v6)
    return 0;
  UInt32 = BOMStreamReadUInt32((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13);
  if (UInt32)
  {
    v23 = UInt32;
    while (1)
    {
      v24 = BOMStreamReadUInt32(v14, v16, v17, v18, v19, v20, v21, v22);
      UInt8 = BOMStreamReadUInt8(v14, v25, v26, v27, v28, v29, v30, v31);
      BOMStreamReadBuffer(v14, __s2, UInt8, v33, v34, v35, v36, v37);
      __s2[UInt8] = 0;
      if (!strncmp(a2, __s2, 0xFFuLL))
        break;
      if (!--v23)
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    v24 = 0;
  }
  BOMStreamFree(v14, v16, v17, v18, v19, v20, v21, v22);
  v44 = *(_DWORD *)(a1 + 1068);
  if (v24 <= v44)
    v45 = v24;
  else
    v45 = 0;
  v46 = *(_DWORD *)(a1 + 1052);
  if ((v46 & 2) != 0 && (v46 & 1) == 0 && (_DWORD)v45)
  {
    v47 = *(_QWORD *)(a1 + 1040);
    if (v44 <= v45)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v38, v39, v40, v41, v42, v43, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
      v44 = *(_DWORD *)(a1 + 1068);
      v48 = 0xFFFFFFFFLL;
    }
    else
    {
      v48 = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v45));
    }
    v50 = (void *)(v47 + v48);
    if (v44 <= v45)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v38, v39, v40, v41, v42, v43, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
      v53 = 0;
    }
    else
    {
      v51 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v45 + 4);
      v52 = bswap32(v51);
      if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
        v53 = v51;
      else
        v53 = v52;
    }
    madvise(v50, v53, 3);
    return v24;
  }
  return v45;
}

uint64_t BOMStreamReadUInt32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v9;
  int v10;
  char *v11;
  unsigned __int8 v12;
  int v13;
  unsigned int *v14;
  unsigned int *v15;
  char *v16;
  unsigned int v17;
  unsigned int v18;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v9 = BOMExceptionHandlerMessage("%s read called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt32");
    v10 = *__error();
    v11 = v9;
    v12 = 0;
    v13 = 272;
LABEL_5:
    _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
    v17 = 0;
    goto LABEL_7;
  }
  v14 = *(unsigned int **)(a1 + 56);
  v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) > *(_QWORD *)(a1 + 64))
  {
    v16 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt32");
    v10 = *__error();
    v11 = v16;
    v12 = 1;
    v13 = 274;
    goto LABEL_5;
  }
  v17 = *v14;
  *(_QWORD *)(a1 + 56) = v15;
LABEL_7:
  v18 = bswap32(v17);
  if (*(_DWORD *)(a1 + 4) == 2)
    return v17;
  else
    return v18;
}

uint64_t BOMStreamReadUInt8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  int v9;
  char *v10;
  unsigned __int8 v11;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  char *v15;
  uint64_t v16;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v8 = BOMExceptionHandlerMessage("%s read called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt8");
    v9 = *__error();
    v10 = v8;
    v11 = 0;
    v12 = 312;
  }
  else
  {
    v13 = *(unsigned __int8 **)(a1 + 56);
    v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) <= *(_QWORD *)(a1 + 64))
    {
      v16 = *v13;
      *(_QWORD *)(a1 + 56) = v14;
      return v16;
    }
    v15 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt8");
    v9 = *__error();
    v10 = v15;
    v11 = 1;
    v12 = 314;
  }
  _BOMExceptionHandlerCall(v10, v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v12, v9);
  return 0;
}

uint64_t (*BOMStreamReadBuffer(uint64_t a1, void *__dst, size_t __len, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(_QWORD *)
{
  char *v8;
  int v9;
  char *v10;
  unsigned __int8 v11;
  int v12;
  const void *v15;
  char *v16;
  uint64_t (*result)(_QWORD *);
  char *v18;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v8 = BOMExceptionHandlerMessage("%s read called on read-only buffer", (uint64_t)__dst, __len, a4, a5, a6, a7, a8, (char)"BOMStreamReadBuffer");
    v9 = *__error();
    v10 = v8;
    v11 = 0;
    v12 = 326;
    return _BOMExceptionHandlerCall(v10, v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v12, v9);
  }
  v15 = *(const void **)(a1 + 56);
  if (__CFADD__(__len, v15))
  {
    v18 = BOMExceptionHandlerMessage("%s buffer overflow", (uint64_t)__dst, __len, a4, a5, a6, a7, a8, (char)"BOMStreamReadBuffer");
    v9 = *__error();
    v10 = v18;
    v11 = 1;
    v12 = 338;
    return _BOMExceptionHandlerCall(v10, v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v12, v9);
  }
  if ((unint64_t)v15 + __len > *(_QWORD *)(a1 + 64))
  {
    v16 = BOMExceptionHandlerMessage("%s buffer overflow", (uint64_t)__dst, __len, a4, a5, a6, a7, a8, (char)"BOMStreamReadBuffer");
    v9 = *__error();
    v10 = v16;
    v11 = 1;
    v12 = 341;
    return _BOMExceptionHandlerCall(v10, v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v12, v9);
  }
  result = (uint64_t (*)(_QWORD *))memmove(__dst, v15, __len);
  *(_QWORD *)(a1 + 56) += __len;
  return result;
}

uint64_t _ReadPage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v75;
  uint64_t DataPointer;
  char *v77;
  int *v78;

  v10 = *(_DWORD *)a2;
  v17 = BOMStorageSizeOfBlock(*(_QWORD *)a1, *(_DWORD *)a2, a3, a4, a5, a6, a7, a8);
  v18 = *(_QWORD *)a1;
  if ((*(_BYTE *)(a1 + 356) & 0x40) != 0)
  {
    v27 = BOMStorageReadFromBlock(v18, v10, v11, v12, v13, v14, v15, v16);
    if (!v27)
      return 1;
    v28 = (void *)v27;
    v26 = BOMStreamWithAddress(v27, v17, 0);
    madvise(v28, v17, 3);
    if (!v26)
      return 1;
  }
  else
  {
    v26 = BOMStreamWithBlockID(v18, v10, v17, 0);
    if (!v26)
      return 1;
  }
  *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 4) & 0xFFFE | (BOMStreamReadUInt16(v26, v19, v20, v21, v22, v23, v24, v25) != 0);
  *(_WORD *)(a2 + 16) = BOMStreamReadUInt16(v26, v29, v30, v31, v32, v33, v34, v35);
  *(_DWORD *)(a2 + 8) = BOMStreamReadUInt32(v26, v36, v37, v38, v39, v40, v41, v42);
  *(_DWORD *)(a2 + 12) = BOMStreamReadUInt32(v26, v43, v44, v45, v46, v47, v48, v49);
  v57 = *(unsigned __int16 *)(a2 + 16);
  if (*(_DWORD *)(a1 + 308) < v57)
  {
    v77 = BOMExceptionHandlerMessage("(tree (%s) page->numKeys(%d) > tree->maxKeys(%d)", v50, v51, v52, v53, v54, v55, v56, *(_QWORD *)(a1 + 8));
    v78 = __error();
    _BOMFatalException(v77, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 1329, *v78);
  }
  if ((*(_BYTE *)(a1 + 356) & 0x40) != 0)
  {
    *(_QWORD *)(a2 + 24) = BOMStreamGetDataPointer(v26, (8 * v57) | 4);
  }
  else
  {
    if (*(_WORD *)(a2 + 16))
    {
      v58 = 0;
      v59 = 0;
      do
      {
        *(_DWORD *)(*(_QWORD *)(a2 + 24) + v58) = BOMStreamReadUInt32(v26, v50, v51, v52, v53, v54, v55, v56);
        *(_DWORD *)(*(_QWORD *)(a2 + 24) + v58 + 4) = BOMStreamReadUInt32(v26, v60, v61, v62, v63, v64, v65, v66);
        ++v59;
        v58 += 8;
      }
      while (v59 < *(unsigned __int16 *)(a2 + 16));
    }
    *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * *(unsigned __int16 *)(a2 + 16)) = BOMStreamReadUInt32(v26, v50, v51, v52, v53, v54, v55, v56);
  }
  if ((*(_DWORD *)(a1 + 356) & 0x44) == 0x40 && (v75 = *(_DWORD *)(a1 + 348), v75 >= 1))
    DataPointer = BOMStreamGetDataPointer(v26, v75 * (unint64_t)*(unsigned __int16 *)(a2 + 16));
  else
    DataPointer = 0;
  *(_QWORD *)(a2 + 32) = DataPointer;
  BOMStreamFree(v26, v67, v68, v69, v70, v71, v72, v73);
  return 0;
}

uint64_t BOMStreamFree(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void *v9;

  if (result)
  {
    v8 = result;
    if ((*(_BYTE *)(result + 80) & 2) != 0 && BOMStreamFlush((int *)result, a2, a3, a4, a5, a6, a7, a8))
    {
      return 1;
    }
    else
    {
      v9 = *(void **)(v8 + 48);
      if (v9)
      {
        if ((*(_BYTE *)(v8 + 80) & 1) != 0)
          free(v9);
      }
      free((void *)v8);
      return 0;
    }
  }
  return result;
}

uint64_t BOMStreamWithAddress(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v6 = BOM_malloczero(0x58uLL);
  v14 = (uint64_t)v6;
  if (v6)
  {
    *v6 = 0x100000002;
    v6[4] = a2;
    *((_DWORD *)v6 + 10) = a3;
    v6[6] = a1;
    *((_BYTE *)v6 + 80) &= ~1u;
    if (a2 < 0)
    {
      _CUILog(4, (uint64_t)"%s: stream invalid: overflow", v8, v9, v10, v11, v12, v13, (uint64_t)"BOMStreamWithAddress");
LABEL_7:
      BOMStreamFree(v14, v7, v8, v9, v10, v11, v12, v13);
      return 0;
    }
    v6[7] = a1;
    v6[8] = a1 + a2;
    if (!a2)
      goto LABEL_7;
  }
  else
  {
    v15 = __error();
    strerror(*v15);
    _CUILog(4, (uint64_t)"%s malloc: %s", v16, v17, v18, v19, v20, v21, (uint64_t)"BOMStreamWithAddress");
  }
  return v14;
}

void *BOM_malloczero(size_t size)
{
  char v1;
  void *v2;
  void *v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int *v13;

  v1 = size;
  v2 = malloc_type_calloc(1uLL, size, 0x83655E9DuLL);
  v3 = v2;
  if (v2)
  {
    __CFSetLastAllocationEventName(v2, "CUIBOM_malloczero");
  }
  else
  {
    v4 = __error();
    strerror(*v4);
    v12 = BOMExceptionHandlerMessage("BOM_malloczero: (%zd bytes) %s\n", v5, v6, v7, v8, v9, v10, v11, v1);
    v13 = __error();
    _BOMExceptionHandlerCall(v12, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 37, *v13);
  }
  return v3;
}

uint64_t BOMStreamReadUInt16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v9;
  int v10;
  char *v11;
  unsigned __int8 v12;
  int v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  char *v16;
  unsigned int v17;
  unsigned int v18;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v9 = BOMExceptionHandlerMessage("%s read called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt16");
    v10 = *__error();
    v11 = v9;
    v12 = 0;
    v13 = 292;
LABEL_5:
    _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
    v17 = 0;
    goto LABEL_7;
  }
  v14 = *(unsigned __int16 **)(a1 + 56);
  v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) > *(_QWORD *)(a1 + 64))
  {
    v16 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt16");
    v10 = *__error();
    v11 = v16;
    v12 = 1;
    v13 = 294;
    goto LABEL_5;
  }
  v17 = *v14;
  *(_QWORD *)(a1 + 56) = v15;
LABEL_7:
  v18 = __rev16(v17);
  if (*(_DWORD *)(a1 + 4) == 2)
    return v17;
  else
    return v18;
}

uint64_t BOMStreamGetDataPointer(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 40))
    return 0;
  result = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = result + a2;
  return result;
}

_QWORD *_NewPage(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned int v4;
  _QWORD *result;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;

  v3 = *(_QWORD *)a1;
  if ((*(_BYTE *)(a1 + 356) & 0x40) != 0)
  {
    v8 = BOM_malloczero(0x28uLL);
    v6 = 0;
    result = 0;
    if (!v8)
      return result;
LABEL_8:
    if (!a2)
      a2 = BOMStorageNewBlock(v3);
    v8[3] = v6;
    *(_DWORD *)v8 = a2;
    return v8;
  }
  v4 = *(_DWORD *)(a1 + 308);
  if (v4 <= *(_DWORD *)(a1 + 312))
    v4 = *(_DWORD *)(a1 + 312);
  result = BOM_malloczero(8 * (v4 + 1));
  if (result)
  {
    v6 = result;
    v7 = BOM_malloczero(0x28uLL);
    if (!v7)
    {
      free(v6);
      return 0;
    }
    v8 = v7;
    goto LABEL_8;
  }
  return result;
}

BOOL BOMStreamAtEOF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v9;
  int *v10;

  if (*(_DWORD *)(a1 + 40))
  {
    v9 = BOMExceptionHandlerMessage("%s Can't check EOF on a writeable stream", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamAtEOF");
    v10 = __error();
    _BOMExceptionHandlerCall(v9, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", 353, *v10);
  }
  return *(_QWORD *)(a1 + 56) == *(_QWORD *)(a1 + 64);
}

_QWORD *_newBOMTree(uint64_t a1, const char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  char *v15;

  v4 = BOM_malloczero(0x168uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    if (BOMStorageMemoryMapped(a1))
      v6 = (BOMStorageIsOpenForWriting(a1) == 0) << 6;
    else
      v6 = 0;
    v14 = *((_DWORD *)v5 + 89) & 0xFFFFFFBF | v6;
    *((_DWORD *)v5 + 89) = v14;
    if (a2)
    {
      v15 = strdup(a2);
      v5[1] = v15;
      *((_DWORD *)v5 + 89) = v14 & 0xFFFFFFDF | (32 * (v15 != a2));
    }
  }
  else
  {
    v7 = __error();
    strerror(*v7);
    _CUILog(4, (uint64_t)"%s: malloc: %s creating tree '%s'", v8, v9, v10, v11, v12, v13, (uint64_t)"BOMTree _newBOMTree(BOMStorage, const char *)");
  }
  return v5;
}

BOOL BOMStorageMemoryMapped(_BOOL8 result)
{
  if (result)
    return (*(_DWORD *)(result + 1052) & 6) == 2;
  return result;
}

uint64_t BOMStorageIsOpenForWriting(uint64_t result)
{
  if (result)
    return *(_BYTE *)(result + 1052) & 1;
  return result;
}

_QWORD *BOMTreeIteratorNew(uint64_t a1, void *a2, unint64_t a3, BOOL *a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const __CFArray *v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  __CFArray *Mutable;
  int *v19;
  CFRange v21;

  v8 = BOM_malloczero(0x40uLL);
  v13 = v8;
  if (!v8)
    return v13;
  *v8 = a1;
  BOMTreeIteratorSet((uint64_t)v8, a2, a3, a4, v9, v10, v11, v12);
  v14 = *(const __CFArray **)(a1 + 296);
  if (!v14)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(_QWORD *)(a1 + 296) = Mutable;
    if (!Mutable)
    {
      v19 = __error();
      _BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2679, *v19);
      goto LABEL_8;
    }
    goto LABEL_6;
  }
  v15 = BOMCFArrayMaxRange(v14);
  v17 = v16;
  v21.location = v15;
  v21.length = v17;
  if (!CFArrayContainsValue(*(CFArrayRef *)(a1 + 296), v21, v13))
  {
    Mutable = *(__CFArray **)(a1 + 296);
LABEL_6:
    CFArrayAppendValue(Mutable, v13);
  }
LABEL_8:
  if ((*(_BYTE *)(*v13 + 356) & 4) == 0)
    v13[3] = BOM_malloc(v13[4]);
  v13[5] = BOM_malloc(v13[6]);
  return v13;
}

void *BOM_malloc(size_t a1)
{
  char v1;
  void *v2;
  void *v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int *v13;

  v1 = a1;
  v2 = malloc_type_malloc(a1, 0x1607F7D5uLL);
  v3 = v2;
  if (v2)
  {
    __CFSetLastAllocationEventName(v2, "CUIBOM_malloc");
  }
  else
  {
    v4 = __error();
    strerror(*v4);
    v12 = BOMExceptionHandlerMessage("BOM_malloc: (%zd bytes) %s\n", v5, v6, v7, v8, v9, v10, v11, v1);
    v13 = __error();
    _BOMExceptionHandlerCall(v12, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 24, *v13);
  }
  return v3;
}

_DWORD *BOMTreeIteratorSet(uint64_t a1, void *a2, unint64_t a3, BOOL *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  *(_BYTE *)(a1 + 57) &= 0xF6u;
  result = (_DWORD *)_findPagesForKey(*(_QWORD *)a1, 0, a2, a3, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 8) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 16) = *result;
    result = (_DWORD *)_findIndexForKey(*(_QWORD *)a1, (uint64_t)result, a2, a3, a4, v13, v14, v15);
    *(_DWORD *)(a1 + 20) = (_DWORD)result;
    *(_BYTE *)(a1 + 56) = 1;
    v22 = *(_QWORD *)(a1 + 8);
    if (result >= *(unsigned __int16 *)(v22 + 16))
    {
      *(_DWORD *)(a1 + 20) = 0;
      v23 = *(_DWORD *)(v22 + 8);
      if (!v23
        || (*(_DWORD *)(a1 + 16) = v23,
            result = _findPage(*(_QWORD *)a1, v23, v16, v17, v18, v19, v20, v21),
            (*(_QWORD *)(a1 + 8) = result) == 0))
      {
        *(_BYTE *)(a1 + 57) |= 8u;
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 57) |= 8u;
    *(_BYTE *)(a1 + 56) = 0;
  }
  return result;
}

void BOMTreeIteratorFree(_BYTE *a1)
{
  char v2;
  char v3;
  void *v4;
  char v5;
  void *v6;
  uint64_t v7;
  const __CFArray *v8;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex FirstIndexOfValue;
  CFRange v13;

  if (a1)
  {
    v2 = a1[57];
    a1[56] = 0;
    v3 = v2 | 9;
    a1[57] = v3;
    v4 = (void *)*((_QWORD *)a1 + 3);
    if (v4 && (*(_BYTE *)(*(_QWORD *)a1 + 356) & 4) == 0)
    {
      free(v4);
      *((_QWORD *)a1 + 3) = 0;
      v3 = a1[57];
    }
    v5 = v3 & 0xFD;
    a1[57] = v5;
    v6 = (void *)*((_QWORD *)a1 + 5);
    if (v6)
    {
      free(v6);
      *((_QWORD *)a1 + 5) = 0;
      v5 = a1[57];
    }
    a1[57] = v5 & 0xFB;
    *((_DWORD *)a1 + 4) = -1;
    *((_QWORD *)a1 + 1) = 0;
    v7 = *(_QWORD *)a1;
    v8 = *(const __CFArray **)(*(_QWORD *)a1 + 296);
    if (v8)
    {
      v9 = BOMCFArrayMaxRange(v8);
      v11 = v10;
      v13.location = v9;
      v13.length = v11;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v7 + 296), v13, a1);
      if (FirstIndexOfValue != -1)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v7 + 296), FirstIndexOfValue);
        if (!CFArrayGetCount(*(CFArrayRef *)(v7 + 296)))
        {
          CFRelease(*(CFTypeRef *)(v7 + 296));
          *(_QWORD *)(v7 + 296) = 0;
        }
      }
    }
    free(a1);
  }
}

uint64_t BOMCFArrayMaxRange(const __CFArray *a1)
{
  CFArrayGetCount(a1);
  return 0;
}

BOOL CUIRenditionKeyHasIdentifier(uint64_t a1, int a2)
{
  uint64_t v2;
  int *v3;
  uint64_t i;
  int v5;

  v2 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v2)
    return 0;
  v3 = (int *)(a1 + 12);
  for (i = 0xFFFFFFFFLL; ; --i)
  {
    v5 = *v3++;
    if (v5 == a2)
      break;
    if (!--v2)
      return 0;
  }
  return i != 0;
}

uint64_t _ReadBlockTable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char *v19;
  int *v20;
  uint64_t DataPointer;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;

  result = BOMStreamReadUInt32(a2, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    v18 = result;
    if (result >> 29 || (v11 = 8 * result, v11 > *(unsigned int *)(a1 + 1064)))
    {
      v19 = BOMExceptionHandlerMessage("bad value for block table count", v11, v12, v13, v14, v15, v16, v17, v40);
      v20 = __error();
      _BOMExceptionHandlerCall(v19, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1594, *v20);
      return 1;
    }
    else if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
    {
      v22 = result;
      _ExpandBlockTable((char *)a1, result);
      v30 = 0;
      v31 = 4 * v22;
      v32 = 4;
      do
      {
        *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v32 - 4) = BOMStreamReadUInt32(a2, v23, v24, v25, v26, v27, v28, v29);
        *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v32) = BOMStreamReadUInt32(a2, v33, v34, v35, v36, v37, v38, v39);
        *(_BYTE *)(*(_QWORD *)(a1 + 1080) + v30) &= ~1u;
        v32 += 8;
        v30 += 4;
      }
      while (v31 != v30);
      return 0;
    }
    else
    {
      DataPointer = BOMStreamGetDataPointer(a2, v11);
      result = 0;
      *(_QWORD *)(a1 + 1072) = DataPointer;
      *(_DWORD *)(a1 + 1068) = v18;
    }
  }
  return result;
}

_QWORD *_CreateBlockTable(_QWORD *result)
{
  _QWORD *v1;

  if ((*((_BYTE *)result + 1052) & 1) != 0)
  {
    v1 = result;
    result[134] = BOM_malloczero(0x800uLL);
    result = BOM_malloczero(0x400uLL);
    v1[135] = result;
    *((_DWORD *)v1 + 267) = 256;
  }
  return result;
}

uint64_t BomSys_open(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

void *BomSys_mmap(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t BomSys_fstat(int a1, int a2, stat *a3)
{
  return fstat(a2, a3);
}

__int128 *BomSys_default()
{
  return &gDefaultSys;
}

uint64_t BomSys_close(int a1, int a2)
{
  return close(a2);
}

_QWORD *BOMStreamWithFileAndSys(int a1, uint64_t a2, size_t a3, int a4, char *a5, __int128 *a6)
{
  _QWORD *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v12 = BOM_malloczero(0x58uLL);
  if (v12)
  {
    if (!a6)
      a6 = BomSys_default();
    v12[9] = a6;
    *v12 = 0x100000001;
    *((_DWORD *)v12 + 5) = a1;
    v12[3] = a2;
    v12[4] = a3;
    *((_DWORD *)v12 + 10) = a4;
    if (a5)
    {
      v12[6] = a5;
      *((_BYTE *)v12 + 80) &= ~1u;
      if ((a3 & 0x8000000000000000) != 0)
      {
LABEL_15:
        v21 = __error();
        strerror(*v21);
        _CUILog(4, (uint64_t)"%s: malloc: %s", v22, v23, v24, v25, v26, v27, (uint64_t)"BOMStreamWithFileAndSys");
LABEL_18:
        BOMStreamFree(v12);
        return 0;
      }
    }
    else
    {
      v20 = (char *)BOM_malloczero(a3);
      v12[6] = v20;
      if (!v20)
        goto LABEL_15;
      a5 = v20;
      *((_BYTE *)v12 + 80) |= 1u;
      a3 = v12[4];
      if ((a3 & 0x8000000000000000) != 0)
        goto LABEL_15;
    }
    v12[7] = a5;
    v12[8] = &a5[a3];
    if ((*((_DWORD *)v12 + 10) | 2) == 2)
    {
      if ((*((uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))a6 + 7))(*((_QWORD *)a6 + 1), *((unsigned int *)v12 + 5), v12[3], 0) == -1)
      {
        v28 = __error();
        strerror(*v28);
        _CUILog(4, (uint64_t)"%s: lseek: %s", v29, v30, v31, v32, v33, v34, (uint64_t)"BOMStreamWithFileAndSys");
        goto LABEL_18;
      }
      a3 = (*((uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))a6 + 5))(*((_QWORD *)a6 + 1), *((unsigned int *)v12 + 5), v12[6], v12[4]);
      if (a3 != v12[4])
      {
        v35 = __error();
        strerror(*v35);
        _CUILog(4, (uint64_t)"%s: read: %s", v36, v37, v38, v39, v40, v41, (uint64_t)"BOMStreamWithFileAndSys");
        goto LABEL_18;
      }
    }
    if (!a3)
      goto LABEL_18;
  }
  else
  {
    v13 = __error();
    strerror(*v13);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v14, v15, v16, v17, v18, v19, (uint64_t)"BOMStreamWithFileAndSys");
  }
  return v12;
}

ssize_t BomSys_read(int a1, int a2, void *a3, size_t a4)
{
  return read(a2, a3, a4);
}

uint64_t _ReadFreeList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v9;
  uint64_t result;
  int UInt32;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void (*v29)(uint64_t, void *, size_t, _BOOL8);
  _BOOL8 v30;
  char *v31;
  int *v32;

  if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
  {
    v9 = _BOMFreeListAllocate();
    result = 0;
    *(_QWORD *)(a1 + 1088) = v9;
    return result;
  }
  UInt32 = BOMStreamReadUInt32(a2, a2, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 1088) = _BOMFreeListAllocate();
  if (!UInt32)
    return 0;
  v20 = (8 * UInt32);
  if ((int)v20 < 1)
  {
    v31 = BOMExceptionHandlerMessage("_ReadFreeList: tring to read %d byte for freelist table.", v13, v14, v15, v16, v17, v18, v19, v20);
    v32 = __error();
    _BOMExceptionHandlerCall(v31, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1723, *v32);
  }
  else
  {
    v21 = BOM_malloc(v20);
    if (v21)
    {
      v27 = v21;
      BOMStreamReadBuffer(a2, v21, v20, v22, v23, v24, v25, v26);
      v28 = *(_QWORD *)(a1 + 1088);
      v29 = *(void (**)(uint64_t, void *, size_t, _BOOL8))(v28 + 16);
      v30 = BOMStreamGetByteOrder(a2) == 1;
      v29(v28, v27, v20, v30);
      free(v27);
      return 0;
    }
  }
  return 1;
}

_DWORD *_BOMFreeListAllocate()
{
  _QWORD *v0;
  _DWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v0 = BOM_malloc(0x48uLL);
  v1 = v0;
  if (v0)
  {
    v0[2] = _dense_initialize;
    v0[3] = _dense_serialize;
    v0[4] = _dense_deallocate;
    v0[5] = _dense_addFreeRange;
    v0[6] = _dense_allocateRange;
    v0[7] = _dense_clear;
    v0[8] = _dense_print;
    v2 = BOM_malloc(0x18uLL);
    if (v2)
    {
      v3 = v2;
      v4 = BOM_calloc(0x20uLL, 8uLL);
      *v3 = v4;
      if (v4)
      {
        v3[1] = 0;
        *((_DWORD *)v3 + 4) = 32;
        *(_QWORD *)v1 = v3;
        v1[2] = 0;
        return v1;
      }
      free(v1);
      v5 = v3;
    }
    else
    {
      v5 = v1;
    }
    free(v5);
    return 0;
  }
  return v1;
}

void *BOM_calloc(size_t a1, size_t a2)
{
  char v2;
  void *v3;
  void *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int *v14;

  v2 = a2;
  v3 = malloc_type_calloc(a1, a2, 0x561175E7uLL);
  v4 = v3;
  if (v3)
  {
    __CFSetLastAllocationEventName(v3, "CUIBOM_calloc");
  }
  else
  {
    v5 = __error();
    strerror(*v5);
    v13 = BOMExceptionHandlerMessage("BOM_calloc: (%zd bytes) %s\n", v6, v7, v8, v9, v10, v11, v12, v2);
    v14 = __error();
    _BOMExceptionHandlerCall(v13, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 54, *v14);
  }
  return v4;
}

off_t BomSys_lseek(int a1, int a2, off_t a3, int a4)
{
  return lseek(a2, a3, a4);
}

uint64_t _revalidateIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *Page;
  int v10;
  uint64_t PagesForKey;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int IndexForKey;
  uint64_t result;

  if ((*(_BYTE *)(a1 + 57) & 1) != 0)
  {
    PagesForKey = _findPagesForKey(*(_QWORD *)a1, 0, *(void **)(a1 + 24), *(_QWORD *)(a1 + 32), a5, a6, a7, a8);
    *(_QWORD *)(a1 + 8) = PagesForKey;
    if (!PagesForKey)
    {
      *(_BYTE *)(a1 + 57) |= 1u;
      goto LABEL_12;
    }
    IndexForKey = _findIndexForKey(*(_QWORD *)a1, PagesForKey, *(void **)(a1 + 24), *(_QWORD *)(a1 + 32), (BOOL *)(a1 + 56), v12, v13, v14);
    Page = *(_QWORD **)(a1 + 8);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)Page;
    *(_DWORD *)(a1 + 20) = IndexForKey;
    *(_BYTE *)(a1 + 57) &= ~1u;
    goto LABEL_9;
  }
  Page = *(_QWORD **)(a1 + 8);
  if (!Page)
  {
    v10 = *(_DWORD *)(a1 + 16);
LABEL_8:
    Page = _findPage(*(_QWORD *)a1, v10, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 8) = Page;
    if (!Page)
      goto LABEL_12;
    goto LABEL_9;
  }
  v10 = *(_DWORD *)(a1 + 16);
  if (*(_DWORD *)Page != v10)
    goto LABEL_8;
LABEL_9:
  if (*(_DWORD *)(a1 + 20) < *((unsigned __int16 *)Page + 8))
    return 1;
LABEL_12:
  result = 0;
  *(_BYTE *)(a1 + 57) |= 1u;
  return result;
}

void sub_19EBDB388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_19EBDB8D8()
{
  objc_end_catch();
  JUMPOUT(0x19EBDB8E0);
}

uint64_t _CUIColorSpaceGetSRGB()
{
  if (_CUIColorSpaceGetSRGB___once != -1)
    dispatch_once(&_CUIColorSpaceGetSRGB___once, &__block_literal_global_2);
  return _CUIColorSpaceGetSRGB_sSRGBColorSpace;
}

void sub_19EBDD2C0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

int8x16_t _extractMetrics(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, int8x16_t *a6, _QWORD *a7, double *a8, int8x16_t *a9, double *a10, int8x16_t *a11)
{
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int8x16_t result;
  unsigned int v18;
  double v19;
  uint64_t v20;
  int64x2_t v21;
  int8x16_t v22;
  double v23;
  uint64_t v24;
  int64x2_t v25;
  int8x16_t v26;
  double v27;
  uint64_t v28;
  int64x2_t v29;
  int8x16_t v30;

  if (a2)
  {
    if (a1)
    {
      if (a3)
      {
        if (a4)
        {
          v11 = *(_DWORD *)(a1 + 4);
          v12 = *(_DWORD *)(a1 + 8);
          v13 = *(_DWORD *)(a1 + 12);
          v14 = *(_DWORD *)(a1 + 16);
          v15 = *(_DWORD *)(a1 + 20);
          v16 = *(_DWORD *)(a1 + 24);
          *a3 = (double)v11;
          a3[1] = (double)v14;
          *a4 = (double)v13;
          a4[1] = (double)v12;
          *(double *)result.i64 = (double)(v13 + v11 + v15);
          *(_QWORD *)a2 = result.i64[0];
          *(double *)(a2 + 8) = (double)(v14 + v12 + v16);
          if (a6)
          {
            if (a5)
            {
              v18 = *(_DWORD *)a1;
              if (*(_DWORD *)a1 >= 2u)
              {
                v19 = (double)*(int *)(a1 + 40);
                *a5 = (double)*(int *)(a1 + 28);
                a5[1] = v19;
                v20 = *(_QWORD *)(a1 + 32);
                v21.i64[0] = (int)v20;
                v21.i64[1] = SHIDWORD(v20);
                v22 = (int8x16_t)vcvtq_f64_s64(v21);
                result = vextq_s8(v22, v22, 8uLL);
                *a6 = result;
                if (a7)
                {
                  if (v18 >= 3)
                  {
                    *(double *)result.i64 = *(double *)(a2 + 8) - (double)*(int *)(a1 + 56);
                    *a7 = result.i64[0];
                    if (a9)
                    {
                      if (a8)
                      {
                        if (v18 >= 4)
                        {
                          v23 = (double)*(int *)(a1 + 88);
                          *a8 = (double)*(int *)(a1 + 76);
                          a8[1] = v23;
                          v24 = *(_QWORD *)(a1 + 80);
                          v25.i64[0] = (int)v24;
                          v25.i64[1] = SHIDWORD(v24);
                          v26 = (int8x16_t)vcvtq_f64_s64(v25);
                          result = vextq_s8(v26, v26, 8uLL);
                          *a9 = result;
                          if (a11)
                          {
                            if (a10)
                            {
                              if (v18 >= 5)
                              {
                                v27 = (double)*(int *)(a1 + 112);
                                *a10 = (double)*(int *)(a1 + 100);
                                a10[1] = v27;
                                v28 = *(_QWORD *)(a1 + 104);
                                v29.i64[0] = (int)v28;
                                v29.i64[1] = SHIDWORD(v28);
                                v30 = (int8x16_t)vcvtq_f64_s64(v29);
                                result = vextq_s8(v30, v30, 8uLL);
                                *a11 = result;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDataRef __compress_data_stream(const __CFData *a1, compression_stream_operation a2)
{
  unint64_t Length;
  size_t v5;
  uint64_t v6;
  uint8_t *v7;
  const uint8_t *BytePtr;
  size_t v9;
  CFDataRef result;
  compression_status v11;
  const uint8_t *v12;
  BOOL v13;
  _BOOL4 v14;
  size_t src_size;
  const char *v16;
  void *v17;
  uint8_t *v18;
  compression_status v19;
  compression_stream v20;

  Length = CFDataGetLength(a1);
  v5 = Length;
  if (a2 == COMPRESSION_STREAM_DECODE && !(Length >> 14))
  {
    v6 = 2 * Length;
    v7 = (uint8_t *)malloc_type_malloc(2 * Length, 0x977FF6F5uLL);
    __CFSetLastAllocationEventName(v7, "CUIUncompressDataWithLZFSE");
    BytePtr = CFDataGetBytePtr(a1);
    v9 = compression_decode_buffer(v7, 2 * v5, BytePtr, v5, 0, COMPRESSION_LZFSE);
    if (v9 && v9 != v6)
      return CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v7, v9, kCFAllocatorMalloc);
    free(v7);
  }
  memset(&v20, 0, sizeof(v20));
  v11 = compression_stream_init(&v20, a2, COMPRESSION_LZFSE);
  result = 0;
  if (v11 == COMPRESSION_STATUS_OK)
  {
    v20.src_size = v5;
    v12 = CFDataGetBytePtr(a1);
    v13 = a2 == COMPRESSION_STREAM_DECODE;
    v14 = a2 != COMPRESSION_STREAM_DECODE;
    v20.src_ptr = v12;
    if (v13)
      src_size = v20.src_size;
    else
      src_size = v20.src_size >> 2;
    if (v13)
      v16 = "CUIUncompressDataWithLZFSE";
    else
      v16 = "CUICompressedDataWithLZFSE";
    v17 = malloc_type_malloc(src_size, 0x68E2A627uLL);
    __CFSetLastAllocationEventName(v17, v16);
    v18 = 0;
    while (1)
    {
      if ((unint64_t)v18 >= src_size)
      {
        src_size += src_size >> 1;
        v17 = reallocf(v17, src_size);
        __CFSetLastAllocationEventName(v17, v16);
      }
      v20.dst_ptr = &v18[(_QWORD)v17];
      v20.dst_size = src_size - (_QWORD)v18;
      v19 = compression_stream_process(&v20, v14);
      if (v19 == COMPRESSION_STATUS_ERROR)
        break;
      v18 = (uint8_t *)(v20.dst_ptr - (uint8_t *)v17);
      if (v19 == COMPRESSION_STATUS_END)
      {
        compression_stream_destroy(&v20);
        return CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)v17, (CFIndex)v18, kCFAllocatorMalloc);
      }
    }
    free(v17);
    compression_stream_destroy(&v20);
    return 0;
  }
  return result;
}

CFDataRef CUIUncompressDataWithLZFSE(const __CFData *a1)
{
  return __compress_data_stream(a1, COMPRESSION_STREAM_DECODE);
}

void __csiImageBlockRelease(id a1)
{
  if (a1 && !*((_BYTE *)a1 + 176))
    *((_BYTE *)a1 + 176) = 1;

}

uint64_t _CUIColorGetSRGBBlack()
{
  if (_CUIColorGetSRGBBlack_onceToken != -1)
    dispatch_once(&_CUIColorGetSRGBBlack_onceToken, &__block_literal_global_23);
  return _CUIColorGetSRGBBlack_sBlackColor;
}

CGContextRef CUICGBitmapContextCreate(size_t a1, size_t a2, size_t a3, size_t a4, CGColorSpaceRef space, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGContextRef result;
  uint32_t v11;
  size_t AlignedBytesPerRow;
  size_t NumberOfComponents;
  void *releaseInfo;
  void *v17;
  void *v18;
  int *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  result = 0;
  if (a1 && a2)
  {
    v11 = a6;
    AlignedBytesPerRow = a4;
    if (!a4)
    {
      if ((a6 & 0x1F) - 1 >= 6)
      {
        if ((a6 & 0x1F) == 7)
        {
          NumberOfComponents = 1;
        }
        else
        {
          if ((a6 & 0x1F) != 0)
            CUICGBitmapContextCreate_cold_1(0, a2, a3, 0, (uint64_t)space, a6, a7, a8);
          NumberOfComponents = CGColorSpaceGetNumberOfComponents(space);
        }
      }
      else
      {
        NumberOfComponents = CGColorSpaceGetNumberOfComponents(space) + 1;
      }
      AlignedBytesPerRow = CGBitmapGetAlignedBytesPerRow(((NumberOfComponents * a3) >> 3) * a1);
    }
    releaseInfo = (void *)((vm_page_size + AlignedBytesPerRow * a2 - 1) & -(uint64_t)vm_page_size);
    v17 = mmap(0, (size_t)releaseInfo, 3, 4098, 1728053248, 0);
    if (v17 == (void *)-1)
    {
      v19 = __error();
      v20 = strerror(*v19);
      _CUILog(4, (uint64_t)"CoreUI: CUICGBitmapContextCreate() mmap failed error:'%s'", v21, v22, v23, v24, v25, v26, (uint64_t)v20);
    }
    else
    {
      v18 = v17;
      result = CGBitmapContextCreateWithData(v17, a1, a2, a3, AlignedBytesPerRow, space, v11, (CGBitmapContextReleaseDataCallback)__freeBitmapContextData, releaseInfo);
      if (result)
        return result;
      munmap(v18, (size_t)releaseInfo);
    }
    return 0;
  }
  return result;
}

void sub_19EBE11A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBE1E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t BOMTreeStorage(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

void sub_19EBE2354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 64), 8);
  _Unwind_Resume(a1);
}

void PerformBlockWithThemeRefCache(uint64_t a1)
{
  if (PerformBlockWithThemeRefCache___onceToken != -1)
    dispatch_once(&PerformBlockWithThemeRefCache___onceToken, &__block_literal_global_7);
  os_unfair_lock_lock((os_unfair_lock_t)&PerformBlockWithThemeRefCache___themeRefCacheLookupMutex);
  (*(void (**)(uint64_t, uint64_t))(a1 + 16))(a1, PerformBlockWithThemeRefCache___themeRefsByUniqueKey);
  os_unfair_lock_unlock((os_unfair_lock_t)&PerformBlockWithThemeRefCache___themeRefCacheLookupMutex);
}

uint64_t _RegisterThemeProvider(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  if ((objc_msgSend(a1, "conformsToProtocol:", &unk_1EE540AD8) & 1) != 0)
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2020000000;
    v14 = 0;
    v10[0] = (uint64_t)_NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = (uint64_t)___RegisterThemeProvider_block_invoke;
    v10[3] = (uint64_t)&unk_1E41B23D0;
    v10[4] = (uint64_t)a1;
    v10[5] = (uint64_t)&v11;
    __PerformBlockWithThemeRegistry((uint64_t)v10);
    objc_msgSend(a1, "setThemeIndex:", v12[3]);
    v8 = v12[3];
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    _CUILog(4, (uint64_t)"provider must conform to the CUIStructuredThemeStorage protocol", v2, v3, v4, v5, v6, v7, v10[0]);
    return 0;
  }
  return v8;
}

void sub_19EBE266C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void BOMExceptionHandlerSetDefault(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOMExceptionHandlerSet(__defaultHandler, a2, a3, a4, a5, a6, a7, a8, a9);
}

void BOMExceptionHandlerSet(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (__BOMExceptionHandlerKey___onceHandler != -1)
    dispatch_once(&__BOMExceptionHandlerKey___onceHandler, &__block_literal_global_21);
  if (pthread_setspecific(__BOMExceptionHandlerKey___key, a1))
    _CUILog(4, (uint64_t)"BOMExceptionHandlerSet couldn't pthread_setspecific", v10, v11, v12, v13, v14, v15, a9);
}

void sub_19EBE2C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFString *_CUICreateStringWithColor(CGColor *a1)
{
  CGColorSpace *ColorSpace;
  CFStringRef Name;
  size_t NumberOfComponents;
  const CGFloat *Components;
  __CFString *Mutable;
  __CFString *v7;
  CFDataRef v8;
  const __CFString *v9;
  uint64_t v10;

  ColorSpace = CGColorGetColorSpace(a1);
  Name = CGColorSpaceGetName(ColorSpace);
  NumberOfComponents = CGColorGetNumberOfComponents(a1);
  Components = CGColorGetComponents(a1);
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  v7 = Mutable;
  if (Name)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("%@-"), Name);
    if (!NumberOfComponents)
      return v7;
  }
  else
  {
    v8 = CGColorSpaceCopyICCData(ColorSpace);
    CFStringAppendFormat(v7, 0, CFSTR("%@"), v8);
    CFRelease(v8);
    if (!NumberOfComponents)
      return v7;
  }
  do
  {
    if (--NumberOfComponents)
      v9 = CFSTR("%f,");
    else
      v9 = CFSTR("%f");
    v10 = *(_QWORD *)Components++;
    CFStringAppendFormat(v7, 0, v9, v10);
  }
  while (NumberOfComponents);
  return v7;
}

uint64_t CUISVGNodeCanBeRepresentedAsPath(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 1;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = __CUISVGNodeCanBeRepresentedAsPath_block_invoke;
  v3[3] = &unk_1E41AB640;
  v3[4] = &v4;
  v3[5] = a1;
  CGSVGNodeEnumerate(a1, v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_19EBE3144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id CUICreatePathFromSVGNode(void *a1, __int128 *a2)
{
  id v2;
  uint64_t Parent;
  uint64_t i;
  __int128 v6;
  __int128 v7;
  _QWORD v9[9];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  id v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _QWORD v19[5];
  NSValue *v20;
  _QWORD v21[3];
  char v22;

  v2 = a1;
  if (a1)
  {
    Parent = CGSVGNodeGetParent(a1);
    for (i = (uint64_t)v2; Parent; Parent = CGSVGNodeGetParent(Parent))
      i = Parent;
    v21[0] = 0;
    v21[1] = v21;
    v21[2] = 0x2020000000;
    v22 = 0;
    v19[0] = 0;
    v19[1] = v19;
    v19[2] = 0x3052000000;
    v19[3] = __Block_byref_object_copy__0;
    v19[4] = __Block_byref_object_dispose__0;
    v20 = 0;
    v6 = a2[1];
    v16 = *a2;
    v7 = a2[2];
    v17 = v6;
    v18 = v7;
    v20 = +[NSValue valueWithCGAffineTransform:](NSValue, "valueWithCGAffineTransform:", &v16);
    *(_QWORD *)&v16 = 0;
    *((_QWORD *)&v16 + 1) = &v16;
    *(_QWORD *)&v17 = 0x3052000000;
    *((_QWORD *)&v17 + 1) = __Block_byref_object_copy__0;
    *(_QWORD *)&v18 = __Block_byref_object_dispose__0;
    *((_QWORD *)&v18 + 1) = 0;
    *((_QWORD *)&v18 + 1) = +[NSMutableArray array](NSMutableArray, "array");
    v10 = 0;
    v11 = &v10;
    v12 = 0x3052000000;
    v13 = __Block_byref_object_copy__0;
    v14 = __Block_byref_object_dispose__0;
    v15 = 0;
    v15 = +[NSMutableArray array](NSMutableArray, "array");
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = __CUICreatePathFromSVGNode_block_invoke;
    v9[3] = &unk_1E41AB5F0;
    v9[4] = v19;
    v9[5] = &v16;
    v9[7] = &v10;
    v9[8] = v2;
    v9[6] = v21;
    CGSVGNodeEnumerate(i, v9);
    v2 = +[CUIVectorGlyphPath createConcatenatingPaths:](CUIVectorGlyphPath, "createConcatenatingPaths:", v11[5]);
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v16, 8);
    _Block_object_dispose(v19, 8);
    _Block_object_dispose(v21, 8);
  }
  return v2;
}

void sub_19EBE3310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Block_object_dispose((const void *)(v17 - 112), 8);
  _Unwind_Resume(a1);
}

void __freeBitmapContextData(size_t a1, void *a2)
{
  int *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (munmap(a2, a1) < 0)
  {
    v2 = __error();
    v3 = strerror(*v2);
    _CUILog(4, (uint64_t)"CoreUI: CUICGBitmapContextCreate() munmap failed error:'%s'", v4, v5, v6, v7, v8, v9, (uint64_t)v3);
  }
}

void ____getDeviceTraits_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v9;
  id v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  void *v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  const char *v29;
  uint64_t *v30;
  uint64_t v31;
  id v32;
  id v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  const char *v41;
  const char *v42;
  uint64_t *v43;
  id v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  const char *v52;
  const char *v53;
  uint64_t *v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  id v70;
  id v71;
  id v72;
  char v73;
  uint64_t v74;
  void *i;
  const char *v76;
  const char *v77;
  const char *v78;
  uint64_t *v79;
  uint64_t v80;
  id v81;
  id v82;
  id v83;
  uint64_t v84;
  void *j;
  const char *v86;
  const char *v87;
  const char *v88;
  uint64_t *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  void *v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  _BYTE v106[128];
  _BYTE v107[128];

  v9 = +[NSMutableArray array](NSMutableArray, "array");
  v10 = +[NSMutableArray array](NSMutableArray, "array");
  v11 = (void *)MGCopyAnswer(CFSTR("oPeik/9e8lQWMszEjbPzng"), 0);
  __getDeviceTraits___deviceIdiom = 0;
  __getDeviceTraits___deviceSubtype = 0;
  __getDeviceTraits___deviceDisplayGamut = 0;
  __getDeviceTraits___deviceMemoryClass = 0;
  __getDeviceTraits___deviceGraphicsClass = 0;
  v18 = &_motionGroupAtom_onceToken;
  __getDeviceTraits___deviceGraphicsFallbackOrder = 0;
  __getDeviceTraits___deviceSubtypeFallbackOrder = 0;
  if (!v11)
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: MGCopyAnswer returned nil", v12, v13, v14, v15, v16, v17, a9);
    return;
  }
  v19 = v11;
  v20 = objc_msgSend(v11, "objectForKey:", CFSTR("ArtworkDeviceIdiom"));
  if (objc_msgSend(v20, "length"))
  {
    v27 = v19;
    v28 = (const char *)objc_msgSend(v20, "UTF8String");
    v29 = "universal";
    if ("universal")
    {
      v30 = &gThemeIdioms;
      while (strcasecmp(v28, v29))
      {
        v29 = (const char *)v30[5];
        v30 += 3;
        if (!v29)
          goto LABEL_7;
      }
      v31 = *v30;
      __getDeviceTraits___deviceIdiom = *v30;
    }
    else
    {
LABEL_7:
      v31 = __getDeviceTraits___deviceIdiom;
    }
    v19 = v27;
    if (!v31 && !strcasecmp(v28, "reality"))
      __getDeviceTraits___deviceIdiom = 8;
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkDeviceIdiom' from MGCopyAnswer got '%@'", v21, v22, v23, v24, v25, v26, (uint64_t)v19);
  }
  v32 = objc_msgSend(objc_msgSend(v19, "objectForKey:", CFSTR("ArtworkDeviceSubType")), "integerValue");
  __getDeviceTraits___deviceSubtype = (uint64_t)v32;
  if (__getDeviceTraits___deviceIdiom == 5)
    CUIWatchSubTypeFallbackOrder((uint64_t)v32, v10);
  objc_msgSend(v10, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 0));
  __getDeviceTraits___deviceSubtypeFallbackOrder = (uint64_t)v10;
  __getDeviceTraits___deviceMemoryClass = (uint64_t)objc_msgSend(objc_msgSend(v19, "objectForKey:", CFSTR("DevicePerformanceMemoryClass")), "integerValue");
  v33 = objc_msgSend(v19, "objectForKey:", CFSTR("ArtworkDisplayGamut"));
  if (objc_msgSend(v33, "length"))
  {
    v40 = (const char *)objc_msgSend(v33, "UTF8String");
    v41 = "sRGB";
    if ("sRGB")
    {
      v42 = v40;
      v43 = &gThemeDisplayGamuts;
      while (strcasecmp(v42, v41))
      {
        v41 = (const char *)v43[5];
        v43 += 3;
        if (!v41)
          goto LABEL_24;
      }
      __getDeviceTraits___deviceDisplayGamut = *v43;
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkDisplayGamut' from MGCopyAnswer got '%@'", v34, v35, v36, v37, v38, v39, (uint64_t)v19);
  }
LABEL_24:
  v44 = objc_msgSend(v19, "objectForKey:", CFSTR("GraphicsFeatureSetClass"));
  if (v44)
  {
    v51 = v44;
    v52 = (const char *)objc_msgSend(v44, "UTF8String");
    v53 = "GLES2,0";
    if ("GLES2,0")
    {
      v54 = &gThemeGraphicsFeatureSetClasses_Legacy;
      while (strcasecmp(v52, v53))
      {
        v53 = (const char *)v54[5];
        v54 += 3;
        if (!v53)
          goto LABEL_29;
      }
    }
    else
    {
LABEL_29:
      v55 = "GLES2,0";
      if (!"GLES2,0")
      {
LABEL_33:
        if (objc_msgSend(v51, "length"))
          _CUILog(4, (uint64_t)"CoreUI: CUICatalog: Failed to parse value of 'kMGArtworkGraphicsFeatureSetClass' from MGCopyAnswer: '%@'", v56, v57, v58, v59, v60, v61, (uint64_t)v51);
        goto LABEL_37;
      }
      v54 = &gThemeGraphicsFeatureSetClasses;
      while (strcasecmp(v52, v55))
      {
        v55 = (const char *)v54[5];
        v54 += 3;
        if (!v55)
          goto LABEL_33;
      }
    }
    __getDeviceTraits___deviceGraphicsClass = *v54;
    objc_msgSend(v51, "length");
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkGraphicsFeatureSetClass' from MGCopyAnswer got '%@'", v45, v46, v47, v48, v49, v50, (uint64_t)v19);
  }
LABEL_37:
  v62 = objc_msgSend(v19, "objectForKey:", CFSTR("GraphicsFeatureSetFallbacks"));
  if (v62 && (v69 = v62, (unint64_t)objc_msgSend(v62, "length") >= 2))
  {
    v96 = v19;
    v97 = v69;
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v70 = objc_msgSend(v69, "componentsSeparatedByString:", CFSTR(":"));
    v71 = objc_msgSend(v70, "countByEnumeratingWithState:objects:count:", &v102, v107, 16);
    if (!v71)
      goto LABEL_54;
    v72 = v71;
    v73 = 0;
    v74 = *(_QWORD *)v103;
    do
    {
      for (i = 0; i != v72; i = (char *)i + 1)
      {
        if (*(_QWORD *)v103 != v74)
          objc_enumerationMutation(v70);
        v76 = (const char *)objc_msgSend(*(id *)(*((_QWORD *)&v102 + 1) + 8 * (_QWORD)i), "UTF8String");
        v77 = "GLES2,0";
        if ("GLES2,0")
        {
          v78 = v76;
          v79 = &gThemeGraphicsFeatureSetClasses_Legacy;
          while (strcasecmp(v78, v77))
          {
            v77 = (const char *)v79[5];
            v79 += 3;
            if (!v77)
              goto LABEL_50;
          }
          v80 = *v79;
          objc_msgSend(v9, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *v79));
          v73 |= v80 > 0;
        }
LABEL_50:
        ;
      }
      v72 = objc_msgSend(v70, "countByEnumeratingWithState:objects:count:", &v102, v107, 16);
    }
    while (v72);
    if ((v73 & 1) == 0 || !objc_msgSend(v9, "count"))
    {
LABEL_54:
      objc_msgSend(v9, "removeAllObjects");
      v100 = 0u;
      v101 = 0u;
      v98 = 0u;
      v99 = 0u;
      v81 = objc_msgSend(v97, "componentsSeparatedByString:", CFSTR(":"));
      v82 = objc_msgSend(v81, "countByEnumeratingWithState:objects:count:", &v98, v106, 16);
      if (v82)
      {
        v83 = v82;
        v84 = *(_QWORD *)v99;
        do
        {
          for (j = 0; j != v83; j = (char *)j + 1)
          {
            if (*(_QWORD *)v99 != v84)
              objc_enumerationMutation(v81);
            v86 = (const char *)objc_msgSend(*(id *)(*((_QWORD *)&v98 + 1) + 8 * (_QWORD)j), "UTF8String");
            v87 = "GLES2,0";
            if ("GLES2,0")
            {
              v88 = v86;
              v89 = &gThemeGraphicsFeatureSetClasses;
              while (strcasecmp(v88, v87))
              {
                v87 = (const char *)v89[5];
                v89 += 3;
                if (!v87)
                  goto LABEL_65;
              }
              objc_msgSend(v9, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *v89));
            }
LABEL_65:
            ;
          }
          v83 = objc_msgSend(v81, "countByEnumeratingWithState:objects:count:", &v98, v106, 16);
        }
        while (v83);
      }
    }
    v18 = &_motionGroupAtom_onceToken;
    v19 = v96;
    if (!objc_msgSend(v9, "count"))
      _CUILog(4, (uint64_t)"CoreUI: CUICatalog: Failed to parse value of 'kMGArtworkGraphicsFeatureSetFallbacks' from MGCopyAnswer: '%@'", v90, v91, v92, v93, v94, v95, (uint64_t)v97);
  }
  else
  {
    _CUILog(3, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkGraphicsFeatureSetFallbacks' from MGCopyAnswer got '%@'", v63, v64, v65, v66, v67, v68, (uint64_t)v19);
  }

  if (objc_msgSend(v9, "count"))
    v18[39] = (uint64_t)v9;
}

void sub_19EBE3E1C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t CUIValidateIdiomSubtypes(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  BOOL v11;
  BOOL v12;

  v8 = *a2;
  switch(a1)
  {
    case 0:
    case 4:
    case 6:
    case 7:
      goto LABEL_2;
    case 1:
    case 2:
      result = 1;
      if (v8 > 2419)
      {
        if (v8 <= 2731)
        {
          if (v8 > 2555)
          {
            if (v8 == 2556 || v8 == 2622 || v8 == 2688)
              return result;
          }
          else if (v8 == 2420 || v8 == 2436 || v8 == 2532)
          {
            return result;
          }
        }
        else if (v8 > 2867)
        {
          if (v8 == 2868 || v8 == 3024 || v8 == 32401)
            return result;
        }
        else if ((unint64_t)(v8 - 2752) <= 0x2C && ((1 << (v8 + 64)) & 0x100004000001) != 0
               || v8 == 2732)
        {
          return result;
        }
      }
      else if (v8 > 2159)
      {
        v12 = (unint64_t)(v8 - 2224) > 0x2A || ((1 << (v8 + 80)) & 0x40000000401) == 0;
        if (!v12
          || (unint64_t)(v8 - 2340) <= 0x30 && ((1 << (v8 - 36)) & 0x1000000100001) != 0
          || v8 == 2160)
        {
          return result;
        }
      }
      else if (v8 > 1664)
      {
        if (v8 == 1665 || v8 == 1792 || v8 == 1964)
          return result;
      }
      else if ((unint64_t)(v8 - 568) < 3 || v8 == 163)
      {
        return result;
      }
      goto LABEL_2;
    case 3:
      result = 1;
      if (v8 == 720 || v8 == 1088 || v8 == 3840)
        return result;
      goto LABEL_2;
    case 5:
      result = 1;
      if (v8 > 483)
      {
        if ((unint64_t)(v8 - 484) <= 0x12 && ((1 << (v8 + 28)) & 0x41001) != 0)
          return result;
      }
      else
      {
        v11 = (unint64_t)(v8 - 384) > 0x3E || ((1 << (v8 + 0x80)) & 0x4000400000000041) == 0;
        if (!v11 || v8 == 320 || v8 == 340)
          return result;
      }
LABEL_2:
      v9 = 0;
      *a2 = 0;
LABEL_3:
      if (v9 == v8)
        return 1;
      _CUILog(4, (uint64_t)"CoreUI: %s passed a device subtype '%d' and idiom '%d':%s that are not a matching pair, subtype is not valid with given idiom. Assuming subtype should be 0 instead.", a3, a4, a5, a6, a7, a8, (uint64_t)"_Bool CUIValidateIdiomSubtypes(NSInteger, NSUInteger *)");
      return 0;
    case 8:
      if (v8 != 3648)
        goto LABEL_2;
      v9 = 3648;
      goto LABEL_3;
    default:
      return 1;
  }
}

void sub_19EBE42A0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t CUIBitVectorSetBit(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t v4;

  os_unfair_lock_lock(a1);
  if (a2 >> 5 >= a1[1]._os_unfair_lock_opaque)
  {
    v4 = 0xFFFFFFFFLL;
  }
  else
  {
    v4 = 1;
    a1[(a2 >> 5) + 2]._os_unfair_lock_opaque |= 1 << a2;
  }
  os_unfair_lock_unlock(a1);
  return v4;
}

void CUIBitVectorDestroy(os_unfair_lock_s *a1)
{
  if (a1)
  {
    os_unfair_lock_lock(a1);
    free(a1);
  }
}

uint64_t CUIBitVectorSetBitRange(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3)
{
  uint32_t os_unfair_lock_opaque;

  os_unfair_lock_lock(a1);
  if (a2 >= a3)
  {
LABEL_5:
    os_unfair_lock_unlock(a1);
    return 1;
  }
  else
  {
    os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
    while (a2 >> 5 < os_unfair_lock_opaque)
    {
      a1[(a2 >> 5) + 2]._os_unfair_lock_opaque |= 1 << a2;
      if (a3 == ++a2)
        goto LABEL_5;
    }
    os_unfair_lock_unlock(a1);
    return 0xFFFFFFFFLL;
  }
}

_DWORD *CUIBitVectorCreate(unsigned int a1)
{
  int v1;
  unsigned int v2;
  _DWORD *v3;

  if (a1 <= 1)
    v1 = 1;
  else
    v1 = a1;
  v2 = ((v1 - 1) >> 5) + 1;
  v3 = malloc_type_malloc(4 * v2 + 8, 0x7EDDED84uLL);
  bzero(v3, 4 * v2 + 8);
  __CFSetLastAllocationEventName(v3, "CUIBitmapVector");
  *v3 = 0;
  v3[1] = v2;
  return v3;
}

void *CUIBitVectorCopy(unsigned int *a1)
{
  uint64_t v2;
  _DWORD *v3;

  v2 = a1[1];
  v3 = malloc_type_malloc(4 * v2 + 8, 0x7EDDED84uLL);
  bzero(v3, 4 * v2 + 8);
  __CFSetLastAllocationEventName(v3, "CUIBitmapVector");
  *v3 = 0;
  v3[1] = v2;
  return memcpy(v3, a1, 4 * a1[1] + 8);
}

__IOSurface *__csiCompressImageProviderCopyIOSurfaceWithOptions(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  int v5;
  id *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v27;
  unsigned int v29;
  unsigned int v30;
  BOOL v31;
  BOOL v32;
  int v33;
  int v34;
  __IOSurface *v35;
  int v36;
  int AlignedBytesPerRow;
  __CFDictionary *Mutable;
  _CSIRenditionBlockData *v39;
  void *BaseAddress;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v49;
  void *value;
  int v51;
  int valuePtr;

  v5 = 1111970369;
  v6 = (id *)(a1 + 48);
  v7 = (unsigned __int16 *)objc_msgSend(objc_loadWeak((id *)(a1 + 48)), "key");
  v8 = CUIRenditionKeyValueForAttribute(v7, 17);
  v9 = CUIRenditionKeyValueForAttribute(v7, 1);
  v10 = CUIRenditionKeyValueForAttribute(v7, 2);
  kdebug_trace(726663177, 2, v8, v9, v10);
  v18 = (const char *)objc_msgSend(*(id *)(a1 + 24), "bytes");
  v51 = 0;
  valuePtr = 1111970369;
  v19 = *(_QWORD *)(a1 + 8);
  v20 = *(_QWORD *)(a1 + 16);
  v21 = *((_DWORD *)v18 + 3);
  v22 = *((_DWORD *)v18 + 4);
  if (a3)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(a3, CFSTR("kCGImageSurfaceFormatRequest"), (const void **)&value))
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
  }
  v23 = *((_DWORD *)v18 + 6);
  v51 = v23;
  v24 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v24 == 12 || v24 == 7)
  {
    CUIUpdatePixelFormatForATECompressedData(&v51, v11, v12, v13, v14, v15, v16, v17);
    v24 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v23 = v51;
  }
  if (v24 == 5 && (v23 == 1195454774 || v23 == 1380401751))
  {
    v27 = 0;
    v51 = 1095911234;
    v23 = 1095911234;
    if (valuePtr == 1111970369)
      goto LABEL_62;
    goto LABEL_44;
  }
  LOBYTE(v27) = valuePtr == 1111970369;
  if (v23 == 1095911234 && valuePtr == 1111970369)
    goto LABEL_75;
  if (v23 != 1380401751)
  {
    if (v23 == 1195456544 && valuePtr == 1279340600)
      goto LABEL_30;
    if (v23 == 1195454774)
    {
      v30 = *((_DWORD *)v18 + 7);
      if ((v30 & 0xF) != 6 || valuePtr != 843264104)
      {
        v31 = (v30 & 0xF) == 3 && valuePtr == 843264310;
        v32 = v31;
        if (a3 && !v32)
          goto LABEL_73;
      }
      v5 = 843264104;
      v33 = v30 & 0xF;
      if (v33 == 2)
      {
        v5 = 843264310;
      }
      else if (v33 != 6)
      {
        -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), CFSTR("CUIThemeRendition.m"), 1558, CFSTR("CoreUI: %s No supported surface type for this gray colorspace: %d in rendition '%@'"), "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", *((_DWORD *)v18 + 7) & 0xF, objc_msgSend(objc_loadWeak(v6), "name"));
        goto LABEL_73;
      }
      v27 = 5;
      goto LABEL_62;
    }
    goto LABEL_44;
  }
  v29 = *((_DWORD *)v18 + 7);
  if ((v29 & 0xF) == 4 && valuePtr == 1380411457)
    goto LABEL_50;
  if ((v29 & 0xF) != 3)
  {
    v23 = 1380401751;
LABEL_44:
    if (a3)
      goto LABEL_73;
    if (v23 > 1195456543)
    {
      if (v23 != 1195456544)
      {
        if (v23 != 1380401717)
        {
          if (v23 == 1380401751)
          {
            v29 = *((_DWORD *)v18 + 7);
            goto LABEL_50;
          }
          goto LABEL_71;
        }
        v47 = 6;
LABEL_72:
        -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), CFSTR("CUIThemeRendition.m"), 1569, CFSTR("CoreUI: %s No supported surface type for this block pixel format: %d in rendition '%@'"), "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", v47, objc_msgSend(objc_loadWeak(v6), "name"));
        goto LABEL_73;
      }
LABEL_30:
      v27 = 2;
      v5 = 1279340600;
      goto LABEL_62;
    }
    if (v23 != 1095911234)
    {
LABEL_71:
      -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), CFSTR("CUIThemeRendition.m"), 1528, CFSTR("CoreUI: %s unknown pixel format %d rendition '%@'"), "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", *((unsigned int *)v18 + 6), objc_msgSend(objc_loadWeak(v6), "name"));
      v47 = 0xFFFFFFFFLL;
      goto LABEL_72;
    }
    if ((v27 & 1) == 0)
    {
      v47 = 1;
      goto LABEL_72;
    }
LABEL_75:
    v27 = 0;
    goto LABEL_62;
  }
  v23 = 1380401751;
  if (valuePtr != 1815491698)
    goto LABEL_44;
LABEL_50:
  if ((v29 & 0xF) != 3)
  {
    if ((v29 & 0xF) == 4)
    {
      v27 = 4;
      v5 = 1380411457;
      goto LABEL_62;
    }
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), CFSTR("CUIThemeRendition.m"), 1545, CFSTR("CoreUI: %s No supported surface type for this color space: %d in rendition '%@'"), "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", *((_DWORD *)v18 + 7) & 0xF, objc_msgSend(objc_loadWeak(v6), "name"));
LABEL_73:
    v35 = 0;
    goto LABEL_74;
  }
  v5 = 1815491698;
  v27 = 4;
LABEL_62:
  v34 = __bppFromBlockPixelFormat(v27);
  v35 = 0;
  if (__PAIR64__(v22, v21) == v20)
  {
    v36 = v34;
    v49 = v19;
    AlignedBytesPerRow = CGBitmapGetAlignedBytesPerRow((*(_DWORD *)(a1 + 16) * v34));
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceWidth, v21);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceHeight, v22);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceBytesPerElement, v36);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceBytesPerRow, AlignedBytesPerRow);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfacePixelFormat, v5);
    v35 = IOSurfaceCreate(Mutable);
    IOSurfaceSetValue(v35, kIOSurfaceName, CFSTR("CoreUI image IOSurface"));
    CFRelease(Mutable);
    if (!IOSurfaceLock(v35, 0, 0))
    {
      v39 = [_CSIRenditionBlockData alloc];
      BaseAddress = IOSurfaceGetBaseAddress(v35);
      v41 = -[_CSIRenditionBlockData initWithBytes:pixelWidth:pixelHeight:sourceRowbytes:pixelFormat:](v39, (uint64_t)BaseAddress, v21, v22, *(_QWORD *)(a1 + 112), v27);
      v45 = v41;
      if (v41)
      {
        strlcpy((char *)v41 + 48, v18 + 40, 0x80uLL);
        v45[2] = *((_DWORD *)v18 + 6);
      }
      v46 = -[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:]((uint64_t)v45, *(const UInt8 **)(a1 + 32), v49, v20, 0, v42, v43, v44);

      IOSurfaceUnlock(v35, 0, 0);
      if (!v46)
      {
        CFRelease(v35);
        goto LABEL_73;
      }
    }
  }
LABEL_74:
  kdebug_trace(726663178, 2, 0, 0, 0);
  return v35;
}

void __CUICFMutableDictAddInt32Property(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

uint64_t __csiCompressImageProviderCopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  unint64_t v3;
  unint64_t v4;
  id *v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  _BOOL4 v19;
  uint64_t v20;
  int v21;
  double v22;
  double v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  double v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *Weak;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  const char *v57;
  NSString *v58;
  NSAssertionHandler *v59;
  void *value;

  v7 = (id *)(a1 + 48);
  v8 = (unsigned __int16 *)objc_msgSend(objc_loadWeak((id *)(a1 + 48)), "key");
  v9 = CUIRenditionKeyValueForAttribute(v8, 17);
  v10 = 1;
  v11 = CUIRenditionKeyValueForAttribute(v8, 1);
  v12 = CUIRenditionKeyValueForAttribute(v8, 2);
  kdebug_trace(726663177, 1, v9, v11, v12);
  v13 = (const char *)objc_msgSend(*(id *)(a1 + 24), "bytes");
  LODWORD(v3) = *(_DWORD *)(a1 + 16);
  LODWORD(v4) = *(_DWORD *)(a1 + 20);
  if (a3)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(a3, kCGImageBlockFormatRequest, (const void **)&value)
      && CFStringCompare((CFStringRef)value, kCGImageBlockFormatBGRx8, 0) == kCFCompareEqualTo)
    {
      if (*((_DWORD *)v13 + 6) != 1095911234)
        goto LABEL_46;
      v10 = 0;
    }
    else
    {
      v10 = 1;
    }
  }
  v14 = *(_QWORD *)(a1 + 16);
  v15 = *((unsigned int *)v13 + 3);
  v16 = *((unsigned int *)v13 + 4);
  v17 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8) - 2;
  v19 = (v17 >= 0xA || ((0x3CFu >> v17) & 1) == 0) && ((_DWORD)v15 != (_DWORD)v14 || (_DWORD)v16 != HIDWORD(v14));
  v20 = *(_QWORD *)(a1 + 8);
  v21 = *((_DWORD *)v13 + 6);
  if (v21 <= 1195456543)
  {
    if (v21 == 1095911234)
      goto LABEL_25;
    if (v21 == 1195454774)
    {
      v10 = 5;
      goto LABEL_25;
    }
  }
  else
  {
    switch(v21)
    {
      case 1195456544:
        v10 = 2;
        goto LABEL_25;
      case 1380401717:
        v10 = 6;
        goto LABEL_25;
      case 1380401751:
        v10 = 4;
        goto LABEL_25;
    }
  }
  v59 = +[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler");
  v58 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "CGImageBlockSetRef __CUIImageProviderCopyImageBlockSetWithOptions(void *, CGImageProviderRef, CGRect, CGSize, CFDictionaryRef)");
  objc_msgSend(objc_loadWeak(v7), "name");
  v57 = "CGImageBlockSetRef __CUIImageProviderCopyImageBlockSetWithOptions(void *, CGImageProviderRef, CGRect, CGSize, CFDictionaryRef)";
  -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](v59, "handleFailureInFunction:file:lineNumber:description:", v58, CFSTR("CUIThemeRendition.m"), 1335, CFSTR("CoreUI: %s unknown pixel format %d rendition '%@'"));
  v10 = 0xFFFFFFFFLL;
LABEL_25:
  v22 = (double)v3;
  v23 = (double)v4;
  if (v19)
  {
    v24 = (char *)-[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v14, SHIDWORD(v14), *(_QWORD *)(a1 + 112), v10);
    v28 = (uint64_t)v24;
    if (v24)
    {
      strlcpy(v24 + 48, v13 + 40, 0x80uLL);
      *(_DWORD *)(v28 + 8) = *((_DWORD *)v13 + 6);
    }
    if (-[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:](v28, *(const UInt8 **)(a1 + 32), v20, v14, 1, v25, v26, v27))
    {
      if (v28)
      {
        v29 = *(_QWORD *)(v28 + 16);
        v30 = *(_QWORD *)(v28 + 32);
      }
      else
      {
        v29 = 0;
        v30 = 0;
      }
      v31 = v22;
      v32 = (double)v4;
      v33 = (_QWORD *)v28;
      goto LABEL_42;
    }
  }
  else
  {
    if (_CSIAcquireCachedBlockData(a1, v10))
    {
      if (v10 <= 2 && (Weak = objc_loadWeak((id *)(a1 + 8 * v10 + 56))) != 0)
      {
        v41 = (void *)CGImageBlockCreate(Weak[2]+ 4 * (*((_DWORD *)v13 + 6) == 1095911234) * *(_DWORD *)(a1 + 8)+ Weak[4] * *(unsigned int *)(a1 + 12), Weak[4], Weak, &__csiImageBlockCallbacks, 0.0, 0.0, v22, (double)v4);
      }
      else
      {
        _CUILog(4, (uint64_t)"CoreUI: image data is not available, returning a 1,1 image instead that is all black", v34, v35, v36, v37, v38, v39, (uint64_t)v57);
        v23 = 1.0;
        v41 = (void *)CGImageBlockCreate(&__CUIImageProviderCopyImageBlockSetWithOptions___imageData, 4, 0, 0, 0.0, 0.0, 1.0, 1.0);
        v22 = 1.0;
      }
      if (!v41)
        goto LABEL_45;
      goto LABEL_49;
    }
    v48 = __bppFromBlockPixelFormat(v10);
    v49 = (char *)-[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v15, v16, *(_QWORD *)(a1 + 112), v10);
    v28 = (uint64_t)v49;
    if (v49)
    {
      strlcpy(v49 + 48, v13 + 40, 0x80uLL);
      *(_DWORD *)(v28 + 8) = *((_DWORD *)v13 + 6);
    }
    if (-[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:](v28, *(const UInt8 **)(a1 + 32), 0, v15 | (v16 << 32), 1, v50, v51, v52))
    {
      v53 = _CSIStoreBlockData(a1, (void *)v28, v10);
      v33 = v53;
      if (v53)
      {
        v54 = v53[2];
        v30 = v53[4];
      }
      else
      {
        v54 = 0;
        v30 = 0;
      }
      v29 = v54 + (*(_DWORD *)(a1 + 8) * v48) + v30 * *(unsigned int *)(a1 + 12);
      v31 = v22;
      v32 = (double)v4;
LABEL_42:
      v41 = (void *)CGImageBlockCreate(v29, v30, v33, &__csiImageBlockCallbacks, 0.0, 0.0, v31, v32);
      if (!v41)
        goto LABEL_45;
LABEL_49:
      value = v41;
      v55 = CGImageBlockSetCreate(a2, 1, &value, 0, &__csiImageBlockSetCallBacks, v22, v23, 0.0, 0.0, v22, v23);
      goto LABEL_50;
    }
  }

LABEL_45:
  _CUILog(4, (uint64_t)"CoreUI: couldn't create block from blockData", v42, v43, v44, v45, v46, v47, (uint64_t)v57);
LABEL_46:
  v55 = 0;
LABEL_50:
  kdebug_trace(726663178, 1, 0, 0, 0);
  return v55;
}

BOOL _CSIAcquireCachedBlockData(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  id WeakRetained;
  void *v6;
  uint64_t v7;
  id v9;
  id *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = (os_unfair_lock_s *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained)
  {
    os_unfair_lock_unlock(v4);
    return 0;
  }
  v6 = WeakRetained;
  if ((_DWORD)a2)
  {
    if ((_DWORD)a2 == 1)
    {
      v7 = 64;
    }
    else
    {
      if ((_DWORD)a2 != 2)
        goto LABEL_11;
      v7 = 72;
    }
    v9 = objc_loadWeakRetained((id *)(a1 + v7));
    if (!v9)
    {
LABEL_11:
      v9 = objc_msgSend(v6, "copySharedBlockDataWithPixelFormat:", a2);
      if ((_DWORD)a2 == 2)
      {
        v10 = (id *)(a1 + 72);
      }
      else
      {
        if ((_DWORD)a2 != 1)
        {
          if ((a2 - 7) <= 0xFFFFFFFB)
            _CUILog(4, (uint64_t)"CUIThemeRendition %s called with bogus pixel format %d", v11, v12, v13, v14, v15, v16, (uint64_t)"BOOL _CSIAcquireCachedBlockData(CSIHelper *, enum CSIRenditionBlockPixelFormat)");
          goto LABEL_16;
        }
        v10 = (id *)(a1 + 64);
      }
      goto LABEL_15;
    }
  }
  else
  {
    v9 = objc_loadWeakRetained((id *)(a1 + 56));
    if (!v9)
    {
      v9 = objc_msgSend(v6, "copySharedBlockDataWithPixelFormat:", 0);
      v10 = (id *)(a1 + 56);
LABEL_15:
      objc_storeWeak(v10, v9);
    }
  }
LABEL_16:

  os_unfair_lock_unlock(v4);
  return v9 != 0;
}

void sub_19EBE6A30(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t CUIUncompressDeepmap2ImageData(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int *v12;
  int v13;
  uint64_t v14;
  id v15;
  unsigned int *v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  id v21;
  char *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BOOL4 v33;
  int v34;
  _QWORD block[5];
  _QWORD v38[12];
  unsigned int v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  char v43;

  if (!a1)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL buffer in [%s]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  if (!a4)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL destination in [%s]", a3, 0, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  v10 = a3;
  v12 = a1;
  if ((int)a8 > 1195456543)
  {
    if ((_DWORD)a8 != 1195456544)
    {
      v13 = 1380401751;
      goto LABEL_10;
    }
  }
  else if ((_DWORD)a8 != 1095911234)
  {
    v13 = 1195454774;
LABEL_10:
    if ((_DWORD)a8 == v13)
      goto LABEL_11;
    _CUILog(4, (uint64_t)"CoreUI: %s got unsupported pixel format [%d]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
LABEL_11:
  v40 = 0;
  v41 = &v40;
  v42 = 0x2020000000;
  v43 = 1;
  if ((_DWORD)a3)
  {
    v14 = a1[3];
    a2 = a1[4];
    v33 = *a1 == 1262699075;
    v15 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", a3);
    v16 = v12;
    v12 += 5;
  }
  else
  {
    v33 = 0;
    v15 = 0;
    v16 = 0;
    v14 = a6;
  }
  v17 = 0;
  v18 = 0;
  if (v10 <= 1)
    v19 = 1;
  else
    v19 = v10;
  v34 = v19 - 1;
  do
  {
    if (v10)
    {
      if (v17 >= v10)
        -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)"), CFSTR("CUIDeepmap2Compression.m"), 401, CFSTR("Invalid chunk index"));
      if (!v16 || v14 - 1 >= a6)
      {
        _CUILog(4, (uint64_t)"CoreUI: Invalid chunk rows of %lu in image of height %lu", a3, a4, a5, a6, a7, a8, v14);
        if (!v15)
          goto LABEL_43;
        goto LABEL_42;
      }
    }
    if (*v12 >= 2)
    {
      _CUILog(4, (uint64_t)"CoreUI: Encoded Deepmap 2.0 blob version %lu greater than decoder version %lu", a3, a4, a5, a6, a7, a8, *v12);
      *((_BYTE *)v41 + 24) = 0;
      if (!v15)
        goto LABEL_43;
LABEL_42:

      goto LABEL_43;
    }
    v20 = v12[1];
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472;
    v38[2] = __CUIUncompressDeepmap2ImageData_block_invoke;
    v38[3] = &unk_1E41AB178;
    v38[6] = v14;
    v38[7] = a7;
    v38[8] = a4;
    v38[9] = v18;
    v38[10] = v12;
    v38[11] = v12;
    v39 = v20;
    v38[4] = &v40;
    v38[5] = a5;
    if (!v10)
    {
      __CUIUncompressDeepmap2ImageData_block_invoke((uint64_t)v38);
      goto LABEL_38;
    }
    if (!v15)
      v15 = objc_alloc_init((Class)NSMutableArray);
    v21 = objc_msgSend(v38, "copy");
    objc_msgSend(v15, "addObject:", v21);

    if (v34 == v17)
      break;
    v22 = (char *)v16 + a2;
    v16 = (unsigned int *)((char *)v16 + a2 + 20);
    v23 = *((_DWORD *)v22 + 8);
    if (v33)
    {
      v23 = bswap32(v23);
      v24 = bswap32(v16[4]);
    }
    else
    {
      v24 = v16[4];
    }
    v18 += v14;
    v14 = v23;
    a2 = v24;
    v12 = v16 + 5;
    ++v17;
  }
  while (v18 < a6);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __CUIUncompressDeepmap2ImageData_block_invoke_2;
  block[3] = &unk_1E41AB150;
  block[4] = v15;
  dispatch_apply((size_t)objc_msgSend(v15, "count"), 0, block);

LABEL_38:
  if (*((_BYTE *)v41 + 24))
  {
    v31 = 1;
    goto LABEL_44;
  }
  _CUILog(4, (uint64_t)"CoreUI: CUIUncompressDeepmap2ImageData() fails [version %lu].", v25, v26, v27, v28, v29, v30, 1);
LABEL_43:
  v31 = 0;
LABEL_44:
  _Block_object_dispose(&v40, 8);
  return v31;
}

void sub_19EBE6E00(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

id _CSIStoreBlockData(uint64_t a1, void *a2, int a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  id *v8;
  id WeakRetained;
  id v10;
  id v11;

  v6 = (os_unfair_lock_s *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  if (a3)
  {
    if (a3 == 1)
    {
      v7 = 64;
    }
    else
    {
      if (a3 != 2)
      {
LABEL_14:
        objc_msgSend(objc_loadWeak((id *)(a1 + 48)), "setSharedBlockData:", a2);
        v10 = a2;
        goto LABEL_15;
      }
      v7 = 72;
    }
    WeakRetained = objc_loadWeakRetained((id *)(a1 + v7));
    if (WeakRetained)
      goto LABEL_9;
    if (a3 == 2)
      v8 = (id *)(a1 + 72);
    else
      v8 = (id *)(a1 + 64);
LABEL_13:
    objc_storeWeak(v8, a2);
    goto LABEL_14;
  }
  v8 = (id *)(a1 + 56);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (!WeakRetained)
    goto LABEL_13;
LABEL_9:

  v10 = WeakRetained;
LABEL_15:
  v11 = v10;
  os_unfair_lock_unlock(v6);
  return v11;
}

uint64_t __bppFromBlockPixelFormat(uint64_t a1)
{
  if (a1 < 7)
    return dword_19EC730A4[(int)a1];
  -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "unsigned int __bppFromBlockPixelFormat(enum CSIRenditionBlockPixelFormat)"), CFSTR("CUIThemeRendition.m"), 488, CFSTR("CoreUI: %s unknown pixel format %d"), "unsigned int __bppFromBlockPixelFormat(enum CSIRenditionBlockPixelFormat)", a1);
  return 0;
}

void sub_19EBE7DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __resolvedDesignSystemForInputSystem(uint64_t result)
{
  unint64_t v1;

  if (!result)
  {
    v1 = CUICurrentPlatform();
    if (v1 > 5)
      return 1;
    else
      return qword_19EC72C18[v1];
  }
  return result;
}

uint64_t ____hardware_supports_encoding_block_invoke()
{
  uint64_t result;

  result = MGGetBoolAnswer(CFSTR("ji56BO1mUeT7Qg9RO7Er9w"));
  __hardware_supports_encoding_supportsASTC = result;
  return result;
}

uint64_t _CUIColorGetSRGBWhite()
{
  if (_CUIColorGetSRGBWhite_onceToken != -1)
    dispatch_once(&_CUIColorGetSRGBWhite_onceToken, &__block_literal_global_25);
  return _CUIColorGetSRGBWhite_sWhiteColor;
}

void sub_19EBE8A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __csiCopyImageTextureDataWithOptions(uint64_t a1, uint64_t a2)
{
  unsigned __int16 *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v10;
  __CFDictionary *Mutable;
  CSIATECHelper *v12;
  _CUISubrangeData *v13;
  const void *ColorSpace;

  v4 = (unsigned __int16 *)objc_msgSend(objc_loadWeak((id *)(a1 + 48)), "key");
  v5 = CUIRenditionKeyValueForAttribute(v4, 17);
  v6 = CUIRenditionKeyValueForAttribute(v4, 1);
  v7 = CUIRenditionKeyValueForAttribute(v4, 2);
  kdebug_trace(726663177, 4, v5, v6, v7);
  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (__hardware_supports_encoding_onceToken != -1)
    dispatch_once(&__hardware_supports_encoding_onceToken, &__block_literal_global_582);
  if (v8 != 7 || __hardware_supports_encoding_supportsASTC == 0)
  {
    v10 = 0;
  }
  else
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v12 = objc_alloc_init(CSIATECHelper);
    v13 = CUIATECompressedDataFromBuffer(*(_QWORD *)(a1 + 32) + 16, *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8), (int *)&v12->glInternalFormat, (int *)&v12->metalPixelFormat, &v12->width, &v12->height, &v12->rowbytes, &v12->twiddled);
    v12->data = (__CFData *)v13;
    if (v13)
    {
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("width"), v12->width);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("height"), v12->height);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("rowBytes"), v12->rowbytes);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("glInternalFormat"), v12->glInternalFormat);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("pixelFormatGL"), v12->glInternalFormat);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("pixelFormatMetal"), v12->metalPixelFormat);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("mipmapLevelCount"), 1);
      __CUICFMutableDictAddInt32Property(Mutable, CFSTR("faceCount"), 1);
      CFDictionaryAddValue(Mutable, CFSTR("supportsTiledLayout"), v12->twiddled);
      ColorSpace = (const void *)CGImageProviderGetColorSpace(a2);
      CFDictionaryAddValue(Mutable, CFSTR("colorSpace"), ColorSpace);
      v10 = CGImageTextureDataCreate(a2, Mutable, v12, &csiTextureDataCallbacks);
    }
    else
    {

      v10 = 0;
    }
    CFRelease(Mutable);
  }
  kdebug_trace(726663178, 4, 0, 0, 0);
  return v10;
}

void sub_19EBE8E6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_19EBE8F1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19EBE9480(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void _CUILog_cold_1(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 138543362;
  v3 = a1;
  _os_log_fault_impl(&dword_19EBC9000, a2, OS_LOG_TYPE_FAULT, "%{public}@", (uint8_t *)&v2, 0xCu);
}

uint64_t CUIBitVectorUnSetBit(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t v4;

  os_unfair_lock_lock(a1);
  if (a2 >> 5 >= a1[1]._os_unfair_lock_opaque)
  {
    v4 = 0xFFFFFFFFLL;
  }
  else
  {
    v4 = 1;
    a1[(a2 >> 5) + 2]._os_unfair_lock_opaque &= ~(1 << a2);
  }
  os_unfair_lock_unlock(a1);
  return v4;
}

uint64_t CUIBitVectorNumberOfBitsSet(os_unfair_lock_s *a1)
{
  uint64_t os_unfair_lock_opaque;
  uint64_t v3;
  os_unfair_lock_s *v4;
  uint32_t v5;
  uint8x8_t v6;

  os_unfair_lock_lock(a1);
  os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque)
  {
    LODWORD(v3) = 0;
    v4 = a1 + 2;
    do
    {
      v5 = v4->_os_unfair_lock_opaque;
      ++v4;
      v6 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
      v6.i16[0] = vaddlv_u8(v6);
      v3 = (v6.i32[0] + v3);
      --os_unfair_lock_opaque;
    }
    while (os_unfair_lock_opaque);
  }
  else
  {
    v3 = 0;
  }
  os_unfair_lock_unlock(a1);
  return v3;
}

uint64_t CUIBitVectorBucketValue(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t os_unfair_lock_opaque;

  os_unfair_lock_lock(a1);
  os_unfair_lock_opaque = a1[(a2 >> 5) + 2]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(a1);
  return os_unfair_lock_opaque;
}

_DWORD *CUIBitVectorBitAnd(os_unfair_lock_s *a1, os_unfair_lock_s *a2)
{
  uint64_t os_unfair_lock_opaque;
  _DWORD *v5;
  uint64_t v6;
  unint64_t v7;

  os_unfair_lock_lock(a1);
  os_unfair_lock_lock(a2);
  os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque == a2[1]._os_unfair_lock_opaque)
  {
    v5 = malloc_type_malloc(4 * os_unfair_lock_opaque + 8, 0x7EDDED84uLL);
    bzero(v5, 4 * os_unfair_lock_opaque + 8);
    __CFSetLastAllocationEventName(v5, "CUIBitmapVector");
    *v5 = 0;
    v5[1] = os_unfair_lock_opaque;
    if (a1[1]._os_unfair_lock_opaque)
    {
      v6 = 2;
      do
      {
        v5[v6] = a2[v6]._os_unfair_lock_opaque & a1[v6]._os_unfair_lock_opaque;
        v7 = v6++ - 1;
      }
      while (v7 < a1[1]._os_unfair_lock_opaque);
    }
  }
  else
  {
    v5 = 0;
  }
  os_unfair_lock_unlock(a2);
  os_unfair_lock_unlock(a1);
  return v5;
}

_DWORD *CUIBitVectorBitOrForBucket(os_unfair_lock_s *a1, os_unfair_lock_s *a2, int a3)
{
  uint64_t os_unfair_lock_opaque;
  _DWORD *v7;
  unint64_t v8;
  int v9;

  os_unfair_lock_lock(a1);
  os_unfair_lock_lock(a2);
  os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque == a2[1]._os_unfair_lock_opaque)
  {
    v7 = malloc_type_malloc(4 * os_unfair_lock_opaque + 8, 0x7EDDED84uLL);
    bzero(v7, 4 * os_unfair_lock_opaque + 8);
    __CFSetLastAllocationEventName(v7, "CUIBitmapVector");
    *v7 = 0;
    v7[1] = os_unfair_lock_opaque;
    if (a1[1]._os_unfair_lock_opaque)
    {
      v8 = 0;
      do
      {
        if (a3 == v8)
          v9 = a2[a3 + 2]._os_unfair_lock_opaque | a1[a3 + 2]._os_unfair_lock_opaque;
        else
          v9 = a1[v8 + 2]._os_unfair_lock_opaque;
        v7[v8++ + 2] = v9;
      }
      while (v8 < a1[1]._os_unfair_lock_opaque);
    }
    os_unfair_lock_unlock(a2);
  }
  else
  {
    os_unfair_lock_unlock(a2);
    v7 = 0;
  }
  os_unfair_lock_unlock(a1);
  return v7;
}

_DWORD *CUIBitVectorToData(os_unfair_lock_s *a1, size_t *a2)
{
  size_t v4;
  _DWORD *v5;
  _DWORD *v6;
  unint64_t v7;

  os_unfair_lock_lock(a1);
  v4 = 4 * a1[1]._os_unfair_lock_opaque + 4;
  *a2 = v4;
  v5 = malloc_type_malloc(v4, 0x46EEF169uLL);
  v6 = v5;
  *v5 = a1[1]._os_unfair_lock_opaque;
  if (a1[1]._os_unfair_lock_opaque)
  {
    v7 = 0;
    do
    {
      v5[v7 + 1] = a1[v7 + 2]._os_unfair_lock_opaque;
      ++v7;
    }
    while (v7 < a1[1]._os_unfair_lock_opaque);
  }
  __CFSetLastAllocationEventName(v5, "CUIBitVectorToData");
  os_unfair_lock_unlock(a1);
  return v6;
}

BOOL CUIBitVectorEqual(os_unfair_lock_s *a1, os_unfair_lock_s *a2)
{
  uint64_t os_unfair_lock_opaque;
  uint64_t v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  uint32_t v8;
  uint32_t v9;
  uint32_t v10;
  uint32_t v11;
  BOOL v13;
  _BOOL8 v14;

  os_unfair_lock_lock(a1);
  os_unfair_lock_lock(a2);
  os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque == a2[1]._os_unfair_lock_opaque)
  {
    if ((_DWORD)os_unfair_lock_opaque)
    {
      v5 = os_unfair_lock_opaque - 1;
      v6 = a1 + 2;
      v7 = a2 + 2;
      do
      {
        v9 = v6->_os_unfair_lock_opaque;
        ++v6;
        v8 = v9;
        v11 = v7->_os_unfair_lock_opaque;
        ++v7;
        v10 = v11;
        v13 = v5-- != 0;
        v14 = v8 == v10;
      }
      while (v8 == v10 && v13);
    }
    else
    {
      v14 = 1;
    }
  }
  else
  {
    v14 = 0;
  }
  os_unfair_lock_unlock(a2);
  os_unfair_lock_unlock(a1);
  return v14;
}

_BYTE *CUIBitVectorToString(os_unfair_lock_s *a1)
{
  int v2;
  _BYTE *v3;
  signed int os_unfair_lock_opaque;
  unint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char v12;

  os_unfair_lock_lock(a1);
  v2 = (34 * a1[1]._os_unfair_lock_opaque) | 1;
  v3 = malloc_type_calloc((2 * a1[1]._os_unfair_lock_opaque + 32 * a1[1]._os_unfair_lock_opaque) | 1, 1uLL, 0x100004077774924uLL);
  os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = 0;
      v8 = v6;
      v3[v6] = 91;
      v9 = (v6 + 1);
      v10 = &v3[(int)v9];
      v11 = v9 << 32;
      do
      {
        if (((a1[v5 + 2]._os_unfair_lock_opaque >> v7) & 1) != 0)
          v12 = 49;
        else
          v12 = 48;
        v10[v7++] = v12;
        v11 += 0x100000000;
      }
      while ((_DWORD)v7 != 32);
      v6 += 34;
      v3[v11 >> 32] = 93;
      ++v5;
    }
    while (v5 < a1[1]._os_unfair_lock_opaque);
    os_unfair_lock_opaque = v8 + 34;
  }
  if (os_unfair_lock_opaque >= v2)
    CUIBitVectorToString_cold_1();
  __CFSetLastAllocationEventName(v3, "CUIBitVectorToString");
  os_unfair_lock_unlock(a1);
  return v3;
}

CFDataRef CUIImageCompressedWithColorQuantization(uint64_t a1, uint64_t *a2, uint64_t a3, int *a4, __int16 *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v15;
  __int16 v16;
  char v17;
  id v18;
  char *v19;
  uint64_t v20;
  float32x2_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  float v36;
  float32x2_t v37;
  float v38;
  unint64_t v39;
  __int16 *v40;
  int v41;
  BOOL v42;
  unsigned int v43;
  float v44;
  float v45;
  int8x8_t v46;
  int8x8_t v47;
  int v48;
  BOOL v49;
  unsigned int v50;
  float v51;
  int8x8_t v52;
  int8x8_t v53;
  float v54;
  float v55;
  unint64_t v56;
  int8x8_t v57;
  float v58;
  int8x16_t v59;
  id v60;
  unsigned __int16 v61;
  NSNumber *v62;
  unint64_t v63;
  NSNumber *v64;
  NSNumber *v65;
  NSNumber *v66;
  __CFData *Mutable;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __CFData *v74;
  id v75;
  id v76;
  id v77;
  unint64_t v78;
  id v79;
  uint64_t v80;
  void *i;
  void *v82;
  __CFData *v83;
  CFIndex v84;
  unsigned int v85;
  int v86;
  unsigned int v87;
  int v88;
  unsigned __int8 v89;
  unint64_t v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  CFDataRef v98;
  NSAssertionHandler *v100;
  NSString *v101;
  NSAssertionHandler *v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  void *v107;
  uint64_t v108;
  int8x8_t v109;
  int8x8_t v110;
  float32x2_t v111;
  unsigned __int16 v112;
  unsigned int v113;
  UInt8 v114[8];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  UInt8 v119[2];
  UInt8 bytes[8];
  _BYTE v121[128];

  if (!*a2 || (v9 = a2[3]) == 0 || (v10 = a2[2]) == 0 || (v11 = a2[1]) == 0)
  {
    _CUILog(4, (uint64_t)"CoreUI: invalid input image buffer in %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (uint64_t)"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
    return 0;
  }
  v12 = 2 * (v9 / v10);
  v13 = v12 & 0xFFFFFFFFFFFFFFF8;
  if ((v12 & 0xFFFFFFFFFFFFFFF8) > 0x20 || ((1 << (v12 & 0xF8)) & 0x100010100) == 0)
  {
    _CUILog(4, (uint64_t)"CoreUI: Unsupported bitsPerComponent: %lu %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v12 & 0xFFFFFFFFFFFFFFF8);
    return 0;
  }
  if (v13 <= 8)
    v15 = 1095911234;
  else
    v15 = 1380401751;
  if (v13 <= 8)
    v16 = 1;
  else
    v16 = 4;
  v17 = 2;
  if (v13 > 8)
    v17 = 3;
  *a4 = v15;
  *a5 = v16;
  *a6 = CGBitmapGetAlignedBytesPerRow(v10 << v17);
  v18 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", 1024);
  v19 = (char *)malloc_type_malloc(2 * v10 * v11, 0x7061895uLL);
  if (!v19)
  {
LABEL_88:

    return 0;
  }
  v103 = 2 * v10 * v11;
  v20 = 0;
  v105 = 2 * v10;
  v106 = v11;
  __asm { FMOV            V0.2S, #1.0 }
  v111 = _D0;
  v25 = (float32x2_t)vdup_n_s32(0x461C4000u);
  v109 = (int8x8_t)vdup_n_s32(0x7800000u);
  v110 = (int8x8_t)vdup_n_s32(0x80007FFF);
  v26 = a2[3] / (v12 >> 3);
  v27 = 0;
  v107 = v19;
  v28 = v19;
  v104 = v26;
  while (2)
  {
    v29 = 0;
    v108 = v27;
    v30 = v26 * v27;
    v31 = v20;
    do
    {
      v32 = v30 + 4 * v29;
      v33 = *a2;
      if (v13 < 9)
      {
        v39 = bswap32(*(_DWORD *)(v33 + v32));
      }
      else
      {
        v34 = v32 + 3;
        if (v13 == 32)
        {
          v35 = v33 + 4 * v32;
          v36 = *(float *)v35;
          v37 = *(float32x2_t *)(v35 + 4);
          v38 = *(float *)(v33 + 4 * v34);
        }
        else
        {
          v40 = (__int16 *)(v33 + 2 * v32);
          v41 = *(__int16 *)(v33 + 2 * v34);
          v42 = (v41 & 0x7C00) == 0;
          if ((v41 & 0x7C00) != 0)
            v43 = (v41 << 13) | 0x70000000;
          else
            v43 = v41 & 0x80007FFF;
          v44 = 1.9259e-34;
          if (v42)
            v45 = 4.2535e37;
          else
            v45 = 1.9259e-34;
          v36 = v45 * *(float *)&v43;
          v46.i32[0] = *v40;
          v46.i32[1] = v40[1];
          v47 = (int8x8_t)vceqz_s32((int32x2_t)vand_s8(v46, (int8x8_t)0x7C0000007C00));
          v37 = vmul_f32((float32x2_t)vbsl_s8(v47, (int8x8_t)0x7E0000007E000000, v109), (float32x2_t)vorr_s8(vand_s8(vand_s8(v46, v110), v47), vbic_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)v46, 0xDuLL) | 0x7000000070000000), v47)));
          v48 = v40[2];
          v49 = (v48 & 0x7C00) == 0;
          if ((v48 & 0x7C00) != 0)
            v50 = (v48 << 13) | 0x70000000;
          else
            v50 = v48 & 0x80007FFF;
          if (v49)
            v44 = 4.2535e37;
          v38 = v44 * *(float *)&v50;
        }
        if ((float)(1.093 - v37.f32[0]) < 0.001
          || (float)(v37.f32[0] + 0.5118) < 0.001
          || (float)(1.0183 - v37.f32[1]) < 0.001
          || (float)(v37.f32[1] + 0.2267) < 0.001
          || (float)(1.0419 - v38) < 0.001
          || (float)(v38 + 0.3107) < 0.001)
        {
          goto LABEL_87;
        }
        v51 = v36 * 10000.0;
        if (v36 > 1.0)
          v51 = 10000.0;
        v52 = (int8x8_t)vcltz_f32(v37);
        v53 = (int8x8_t)vcgt_f32(v37, v111);
        v54 = v38 * 10000.0;
        if (v38 > 1.0)
          v54 = 10000.0;
        if (v36 >= 0.0)
          v55 = v51;
        else
          v55 = 0.0;
        v56 = (unint64_t)v55;
        v57 = (int8x8_t)vmul_f32(v37, v25);
        if (v38 >= 0.0)
          v58 = v54;
        else
          v58 = 0.0;
        v59 = vandq_s8((int8x16_t)vshlq_u64(vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vbic_s8(vbsl_s8(v53, (int8x8_t)v25, v57), v52))), (uint64x2_t)xmmword_19EC71000), (int8x16_t)xmmword_19EC71010);
        v39 = v59.i64[0] | (v56 << 48) | (unsigned __int16)(unint64_t)v58 | v59.i64[1];
      }
      v60 = objc_msgSend(v18, "objectForKey:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v39));
      if (v60)
      {
        v61 = (unsigned __int16)objc_msgSend(v60, "integerValue");
        v20 = v31;
      }
      else
      {
        if (objc_msgSend(v18, "count") == (id)1024)
        {

          free(v107);
          return 0;
        }
        v113 = v31 + 1;
        v62 = +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", (unsigned __int16)v31);
        v112 = v31;
        v63 = v10;
        v64 = v62;
        v65 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v39);
        v66 = v64;
        v10 = v63;
        objc_msgSend(v18, "setObject:forKey:", v66, v65);
        v61 = v112;
        v20 = v113;
        v31 = v113;
      }
      *(_WORD *)&v28[2 * v29++] = v61;
    }
    while (v10 != v29);
    v27 = v108 + 1;
    v28 += v105;
    v26 = v104;
    if (v108 + 1 != v106)
      continue;
    break;
  }
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, v103 + 8202);
  if (!Mutable)
  {
    _CUILog(4, (uint64_t)"CoreUI: encoding error in %s (line %lu)", v68, v69, v70, v71, v72, v73, (uint64_t)"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
LABEL_87:
    free(v107);
    goto LABEL_88;
  }
  v74 = Mutable;
  *(_QWORD *)bytes = 0x1CAFEF00DLL;
  CFDataAppendBytes(Mutable, bytes, 8);
  *(_WORD *)v119 = (unsigned __int16)objc_msgSend(v18, "count");
  CFDataAppendBytes(v74, v119, 2);
  v75 = v18;
  v76 = objc_msgSend(v18, "keysSortedByValueUsingComparator:", &__block_literal_global);
  v115 = 0u;
  v116 = 0u;
  v117 = 0u;
  v118 = 0u;
  v77 = objc_msgSend(v76, "countByEnumeratingWithState:objects:count:", &v115, v121, 16);
  v78 = v106;
  if (v77)
  {
    v79 = v77;
    v80 = *(_QWORD *)v116;
    do
    {
      for (i = 0; i != v79; i = (char *)i + 1)
      {
        if (*(_QWORD *)v116 != v80)
          objc_enumerationMutation(v76);
        v82 = *(void **)(*((_QWORD *)&v115 + 1) + 8 * (_QWORD)i);
        if (v13 < 9)
        {
          *(_DWORD *)v114 = 0;
          *(_DWORD *)v114 = objc_msgSend(v82, "integerValue");
          v83 = v74;
          v84 = 4;
        }
        else
        {
          *(_QWORD *)v114 = 0;
          *(_QWORD *)v114 = objc_msgSend(v82, "integerValue");
          v83 = v74;
          v84 = 8;
        }
        CFDataAppendBytes(v83, v114, v84);
      }
      v79 = objc_msgSend(v76, "countByEnumeratingWithState:objects:count:", &v115, v121, 16);
    }
    while (v79);
  }
  v85 = 32 - __clz(*(unsigned __int16 *)v119 - 1);
  if (*(unsigned __int16 *)v119 == 1)
    LOBYTE(v85) = 1;
  v86 = v85;
  v87 = (v86 - 1) | ((v86 - 1) >> 1) | (((v86 - 1) | ((v86 - 1) >> 1)) >> 2);
  v88 = v87 | (v87 >> 4);
  v89 = v88 + 1;
  if (v88 >= 0x10u)
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)"), CFSTR("CUIColorQuantizationCompression.m"), 653, CFSTR("Bits per LUT index should be between [1, 16]."));
  v90 = __compact_bytes((unsigned __int16 *)v107, v10, v106, v86, v89);
  v91 = v75;
  if (v90 > v103)
  {
    v100 = +[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler");
    v101 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
    v102 = v100;
    v78 = v106;
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](v102, "handleFailureInFunction:file:lineNumber:description:", v101, CFSTR("CUIColorQuantizationCompression.m"), 657, CFSTR("Invalid palette size."));
  }
  if (v90 % v78)
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)"), CFSTR("CUIColorQuantizationCompression.m"), 658, CFSTR("Compacted palette table size must be multiples of image height."));
  CFDataAppendBytes(v74, (const UInt8 *)v107, v90);
  v98 = CUICompressedDataWithLZFSE(v74);
  if (!v98)
    _CUILog(4, (uint64_t)"CoreUI: [%s] Failed to compress blob...", v92, v93, v94, v95, v96, v97, (uint64_t)"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
  CFRelease(v74);
  free(v107);

  return v98;
}

uint64_t __compact_bytes(unsigned __int16 *a1, uint64_t a2, unint64_t a3, char a4, int a5)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned __int16 v9;
  unsigned __int16 *v10;
  unsigned __int16 v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  uint64_t v15;
  unsigned __int16 *v16;
  int v17;

  if (!a3)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = ~(-1 << a4);
  v10 = a1;
  do
  {
    v8 += a5;
    v11 = *a1++;
    *v10 = *v10 & ~(v9 << (16 - v8)) | ((v11 & v9) << (16 - v8));
    v10 += v8 == 16;
    if (v8 == 16)
    {
      v8 = 0;
      v7 += 2;
    }
    v12 = v6 + 1;
    v13 = (v8 - 1);
    v14 = v13 >= 0xF;
    v15 = v7 + 2;
    v16 = &v10[v13 < 0xF];
    if (v14)
      v17 = v8;
    else
      v17 = 0;
    if (v14)
      v15 = v7;
    if (v12 == a2)
    {
      v10 = v16;
      v8 = v17;
      v7 = v15;
      v6 = 0;
    }
    else
    {
      ++v6;
    }
    if (v12 == a2)
      ++v5;
  }
  while (v5 < a3);
  return v7;
}

uint64_t CUIUncompressQuantizedImageData(const uint8_t *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v13;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;
  size_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  uint8_t *v44;
  uint64_t v45;
  _BOOL4 v46;
  unint64_t v47;
  unsigned int v48;
  float32x4_t v49;
  float v50;
  float32_t v51;
  float v52;
  float32x4_t v53;
  uint32x4_t v54;
  float v55;
  float v56;
  float32x4_t v57;
  float32x4_t v58;
  uint64_t v59;
  size_t v60;
  uint8_t *v61;
  unsigned __int16 v62;
  uint64_t v63;
  compression_stream stream;
  _DWORD v65[8192];

  v8 = a7;
  if ((_DWORD)a7 != 1095911234 && (_DWORD)a7 != 1380401751)
  {
    _CUILog(4, (uint64_t)"CoreUI: %s got unsupported pixel format [%d]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  v13 = a3;
  memset(&stream, 0, sizeof(stream));
  if (compression_stream_init(&stream, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE))
    goto LABEL_13;
  stream.src_ptr = a1;
  stream.src_size = a2;
  v63 = 0;
  stream.dst_ptr = (uint8_t *)&v63;
  stream.dst_size = 8;
  if (compression_stream_process(&stream, 0) || (_DWORD)v63 != -889262067)
    goto LABEL_13;
  if (HIDWORD(v63) >= 2)
  {
    _CUILog(4, (uint64_t)"[%s] Decoded version is higher than supported", v16, v17, v18, v19, v20, v21, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  v62 = 0;
  stream.dst_ptr = (uint8_t *)&v62;
  stream.dst_size = 2;
  if (compression_stream_process(&stream, 0))
    goto LABEL_13;
  if (v62 > 0x1000u)
  {
    _CUILog(4, (uint64_t)"[%s] Decoded color count %u more than max number of colors allowed during decode...", v16, v17, v18, v19, v20, v21, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  v23 = 2;
  if (v8 == 1380401751)
    v23 = 3;
  v24 = (unint64_t)v62 << v23;
  bzero(v65, 0x8000uLL);
  stream.dst_ptr = (uint8_t *)v65;
  stream.dst_size = v24;
  if (compression_stream_process(&stream, 0))
  {
LABEL_13:
    _CUILog(4, (uint64_t)"CoreUI: decoding error in %s (line %lu)", v16, v17, v18, v19, v20, v21, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  v25 = __clz(v62 - 1) ^ 0x1F;
  if (v62 == 1)
    v25 = 0;
  v26 = v25 | (v25 >> 1) | ((v25 | (v25 >> 1)) >> 2);
  v27 = (v26 | (v26 >> 4)) + 1;
  v60 = (((((v26 | (v26 >> 4)) + 1) * a4 - 1) & 0xFFFFFFFFFFFFFFF0) + 16) >> 3;
  v61 = (uint8_t *)malloc_type_malloc(v60, 0xB5E3FDBAuLL);
  if (!v61)
  {
    _CUILog(4, (uint64_t)"CoreUI: failed to allocate row buffer in %s", v28, v29, v30, v31, v32, v33, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  if (a5)
  {
    v59 = 0;
    v58 = (float32x4_t)vdupq_n_s32(0x461C4000u);
    v57 = (float32x4_t)vdupq_n_s32(0x7800000u);
    while (1)
    {
      stream.dst_ptr = v61;
      stream.dst_size = v60;
      if (compression_stream_process(&stream, 0) > COMPRESSION_STATUS_END)
      {
        _CUILog(4, (uint64_t)"CoreUI: decoding error in %s (line %lu)", v34, v35, v36, v37, v38, v39, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
        goto LABEL_39;
      }
      if (a4)
        break;
LABEL_35:
      bzero(v61, v60);
      v13 += a6;
      if (++v59 == a5)
        goto LABEL_36;
    }
    v40 = 0;
    v41 = 0;
    v42 = v62;
    v43 = 1;
    v44 = v61;
    while (1)
    {
      v45 = (*(unsigned __int16 *)v44 >> (16 - (v27 + v40))) & ~(-1 << v27);
      if (v45 >= v42)
        break;
      v40 += v27;
      v46 = v40 == 16;
      if (v40 == 16)
        v40 = 0;
      if (v8 == 1380401751)
      {
        v47 = *(_QWORD *)&v65[2 * v45];
        *(float *)&v48 = (float)HIWORD(v47) / 10000.0;
        v49.f32[0] = (float)WORD2(v47);
        v50 = fTo16FRoundTable[COERCE_UNSIGNED_INT((float)WORD1(v47) / 10000.0) >> 23];
        v51 = (float)(v50 + (float)((float)((float)((float)WORD1(v47) / 10000.0) * 5.1923e33) * 1.9259e-34)) - v50;
        v52 = fTo16FRoundTable[v48 >> 23];
        v49.f32[1] = v51;
        v49.f32[2] = (float)(unsigned __int16)v47;
        v49.f32[3] = (float)((float)((float)(*(float *)&v48 * 5.1923e33) * 1.9259e-34) + v52) - v52;
        v53 = vdivq_f32(v49, v58);
        v54 = (uint32x4_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v53), (int32x4_t)vmulq_f32(v49, v57));
        v55 = vmuls_lane_f32(5.1923e33, v53, 2);
        v53.f32[0] = (float)((float)(fTo16FRoundTable[(unsigned __int32)v53.i32[0] >> 23]
                                   + (float)((float)(5.1923e33 * v53.f32[0]) * 1.9259e-34))
                           - fTo16FRoundTable[(unsigned __int32)v53.i32[0] >> 23])
                   * 1.9259e-34;
        v56 = fTo16FRoundTable[(unsigned __int32)v53.i32[2] >> 23];
        v53.f32[1] = (float)WORD1(v47) / 10000.0;
        v53.i64[1] = __PAIR64__(v48, (float)((float)((float)(v55 * 1.9259e-34) + v56) - v56) * 1.9259e-34);
        *(int16x4_t *)(v13 + 8 * v41) = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v54, (uint32x4_t)xmmword_19EC71040), (int8x16_t)xmmword_19EC71050), vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)v53, (uint32x4_t)xmmword_19EC71020), (int8x16_t)xmmword_19EC71030)));
      }
      else
      {
        *(_DWORD *)(v13 + v43 - 1) = bswap32(v65[v45]);
      }
      v44 += 2 * v46;
      ++v41;
      v43 += 4;
      if (a4 == v41)
        goto LABEL_35;
    }
    _CUILog(4, (uint64_t)"CoreUI: colorTableIdx [%u] no less than color count [%u] in %s", 125829120, v35, v36, v37, v38, v39, v45);
LABEL_39:
    free(v61);
    return 0;
  }
LABEL_36:
  free(v61);
  compression_stream_destroy(&stream);
  return 1;
}

double _CUIRGBToHSB(double *a1, double *a2, double *a3, double a4, double a5, double a6)
{
  double v7;
  double v8;
  BOOL v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double result;
  BOOL v18;
  double v19;

  if (a4 < a5 || a4 < a6)
  {
    if (a5 >= a4)
      v7 = a4;
    else
      v7 = a5;
    if (a4 >= a6)
      v8 = a6;
    else
      v8 = a4;
    v9 = a5 < a4 || a5 < a6;
    if (v9)
      v10 = a6;
    else
      v10 = a5;
    if (v9)
      v11 = v7;
    else
      v11 = v8;
  }
  else
  {
    if (a5 >= a6)
      v11 = a6;
    else
      v11 = a5;
    v10 = a4;
  }
  v12 = 0.0;
  if (v10 <= 0.0)
  {
    v14 = 0.0;
  }
  else
  {
    v13 = v10 - v11;
    v14 = (v10 - v11) / v10;
    if (v14 != 0.0)
    {
      v15 = (v10 - a5) / v13;
      v16 = (v10 - a6) / v13;
      if (v10 == a4)
      {
        if (v11 == a5)
          v12 = v16 + 5.0;
        else
          v12 = 1.0 - v15;
      }
      else
      {
        v18 = v10 == a5;
        v19 = (v10 - a4) / v13;
        if (v18)
        {
          if (v11 == a6)
            v12 = v19 + 1.0;
          else
            v12 = 3.0 - v16;
        }
        else if (v11 == a4)
        {
          v12 = v15 + 3.0;
        }
        else
        {
          v12 = 5.0 - v19;
        }
      }
    }
  }
  *a3 = v10;
  result = v12 / 6.0;
  *a1 = v12 / 6.0;
  *a2 = v14;
  return result;
}

double *_CUIHSBToRGB(double *result, double *a2, double *a3, double a4, double a5, double a6)
{
  double v6;
  BOOL v7;
  double v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;

  v6 = a4 * 6.0;
  v7 = a4 == 1.0;
  v8 = 0.0;
  if (!v7)
    v8 = v6;
  v9 = (uint64_t)v8;
  v10 = v8 - (double)(uint64_t)v8;
  v11 = (1.0 - a5) * a6;
  v12 = (1.0 - a5 * v10) * a6;
  v13 = (1.0 - a5 * (1.0 - v10)) * a6;
  v14 = a6;
  v15 = v13;
  switch(v9)
  {
    case 0:
      goto LABEL_10;
    case 1:
      v14 = v12;
      v15 = a6;
      goto LABEL_10;
    case 2:
      v14 = v11;
      v15 = a6;
      v11 = v13;
      goto LABEL_10;
    case 3:
      v14 = v11;
      v15 = v12;
      goto LABEL_8;
    case 4:
      v14 = v13;
      v15 = v11;
LABEL_8:
      v11 = a6;
      goto LABEL_10;
    case 5:
      v14 = a6;
      v15 = v11;
      v11 = v12;
LABEL_10:
      *result = v14;
      *a2 = v15;
      *a3 = v11;
      break;
    default:
      return result;
  }
  return result;
}

double *_CUICreateColorByAdjustingTemperature(int a1, double *a2, double *a3, double *a4, double a5, double a6, double a7)
{
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;

  v13 = fmax(fmin((double)a1, 40000.0), 1000.0);
  v14 = v13 / 100.0;
  if (v13 / 100.0 <= 66.0)
  {
    v16 = log(v13 / 100.0) * 0.390081579 + -0.631841444;
    v15 = 1.0;
  }
  else
  {
    v15 = fmax(fmin(pow(v14 + -60.0, -0.133204759) * 1.29293619, 1.0), 0.0);
    v16 = pow(v14 + -60.0, -0.0755148492) * 1.12989086;
  }
  v17 = 1.0;
  if (v14 < 66.0)
  {
    v17 = 0.0;
    if (v14 > 19.0)
      v17 = fmax(fmin(log(v14 + -10.0) * 0.543206789 + -1.19625409, 1.0), 0.0);
  }
  v22 = 0.0;
  _CUIRGBToHSB(&v24, &v23, &v22, a5, a6, a7);
  v20 = 0.0;
  v21 = 0.0;
  _CUIRGBToHSB(&v21, &v20, &v19, v15 * a5, fmax(fmin(v16, 1.0), 0.0) * a6, v17 * a7);
  return _CUIHSBToRGB(a2, a3, a4, v21, v20, v22);
}

double CGPathLineLength(double a1, double a2, double a3, double a4)
{
  return sqrt((a4 - a2) * (a4 - a2) + (a3 - a1) * (a3 - a1));
}

uint64_t CGPathQuadraticLength(double a1, double a2, double a3, double a4, double a5, double a6)
{
  _BYTE v7[80];
  Point v8[2];
  double v9;
  Point v10[2];
  double v11;
  Point v12[2];
  double v13;

  *(double *)&v12[0].v = a1;
  v13 = a2;
  *(double *)&v10[0].v = a3;
  v11 = a4;
  *(double *)&v8[0].v = a5;
  v9 = a6;
  CG::Quadratic::Quadratic((CG::Quadratic *)v7, v12, v10, v8);
  return CG::Quadratic::length((CG::Quadratic *)v7, 0);
}

double CGPathCubicLength(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _BYTE v9[112];
  Point v10[2];
  double v11;
  Point v12[2];
  double v13;
  Point v14[2];
  double v15;
  Point v16[2];
  double v17;

  *(double *)&v16[0].v = a1;
  v17 = a2;
  *(double *)&v14[0].v = a3;
  v15 = a4;
  *(double *)&v12[0].v = a5;
  v13 = a6;
  *(double *)&v10[0].v = a7;
  v11 = a8;
  CG::Cubic::Cubic((CG::Cubic *)v9, v16, v14, v12, v10);
  return CG::Cubic::length((CG::Cubic *)v9, 0.5);
}

void sub_19EBEBAB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEBD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEBF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEC144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEC550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_19EBECA38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBECBA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBECE80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBED130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBED620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBED778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBED8D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEE08C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEE2CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEE940(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19EBEEEE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EBEFEE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double _segmentForValue(_QWORD *a1, int a2, char a3, double a4)
{
  unsigned int v4;
  double v5;
  unsigned int v7;

  v4 = a2 - 1;
  if (a2 == 1)
    return *(double *)a1;
  if (!a2)
    _segmentForValue_cold_1();
  v5 = *(double *)a1;
  if (*(double *)a1 <= a4)
  {
    if (*(double *)&a1[v4] >= a4)
    {
      v7 = 1;
      do
      {
        if (*(double *)&a1[v7] > a4)
          break;
        ++v7;
      }
      while (v7 <= v4);
      return *(double *)&a1[v7 - 1];
    }
    else if ((a3 & 1) != 0)
    {
      return *(double *)&a1[v4];
    }
    else
    {
      return *(double *)&a1[a2 - 2];
    }
  }
  return v5;
}

double _segmentForGlyphContinuousSize(char a1, double a2)
{
  return _segmentForValue(kCoreThemeContinuousGlyphInternalSizes, 6, a1, a2);
}

double _segmentForGlyphContinuousWeight(char a1, double a2)
{
  return _segmentForValue(kCoreThemeContinuousGlyphWeights, 9, a1, a2);
}

uint64_t _snapToDiscreteSizeForSize(double a1)
{
  double v1;
  double v2;
  uint64_t i;
  uint64_t v4;
  double v5;

  if (a1 <= 1.0)
    return 1;
  if (a1 >= 1.647)
    return 3;
  v1 = 0.2;
  v2 = 0.2;
  if (a1 >= 0.2)
  {
    v1 = 2.0;
    v2 = 2.0;
    if (a1 <= 2.0)
    {
      for (i = 1; i != 6; ++i)
      {
        if (kCoreThemeContinuousGlyphInternalSizes[i] > a1)
          break;
      }
      v1 = kCoreThemeContinuousGlyphInternalSizes[(i - 1)];
      v2 = kCoreThemeContinuousGlyphInternalSizes[i];
    }
  }
  v4 = 0;
  if ((v1 + v2) * 0.5 > a1)
    v5 = v1;
  else
    v5 = v2;
  while (*(double *)&kCoreThemeContinuousGlyphSizes[v4] != v5)
  {
    if (++v4 == 3)
      return 0;
  }
  return kCoreThemeDiscreteGlyphSizes[v4];
}

uint64_t _snapToDiscreteWeightForWeight(double a1)
{
  double v1;
  double v2;
  uint64_t i;
  uint64_t v4;
  double v5;

  v1 = -0.8;
  v2 = -0.8;
  if (a1 >= -0.8)
  {
    v1 = 0.62;
    v2 = 0.62;
    if (a1 <= 0.62)
    {
      for (i = 1; i != 9; ++i)
      {
        if (kCoreThemeContinuousGlyphWeights[i] > a1)
          break;
      }
      v1 = kCoreThemeContinuousGlyphWeights[(i - 1)];
      v2 = kCoreThemeContinuousGlyphWeights[i];
    }
  }
  v4 = 0;
  if ((v1 + v2) * 0.5 > a1)
    v5 = v1;
  else
    v5 = v2;
  while (kCoreThemeContinuousGlyphWeights[v4] != v5)
  {
    if (++v4 == 9)
      return 0;
  }
  return kCoreThemeDiscreteGlyphWeights[v4];
}

uint64_t pk_compressData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, unint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t, unsigned int *);
  size_t v16;
  unsigned int *v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, uint64_t, unsigned int *);
  unint64_t v25;
  _DWORD *v26;

  if (4 * a4 + 12 >= a7)
  {
    _CUILog(4, (uint64_t)"compressData: destinatinon buffer size %ld too small for y index (%ld)\n", a3, a4, a5, (uint64_t)a6, a7, a8, a7);
    return 0;
  }
  v10 = 2 * a3;
  if (a2 != 5)
    v10 = a3;
  if (a2 == 6)
    v11 = 4 * a3;
  else
    v11 = v10;
  *a6 = a2;
  a6[1] = v11;
  a6[2] = a4;
  v26 = a6 + 3;
  v12 = &a6[a4 + 3];
  if (a4)
  {
    v14 = 0;
    v15 = (uint64_t (*)(uint64_t, uint64_t, unsigned int *))compress_line_32;
    if (a2 == 3)
      v15 = (uint64_t (*)(uint64_t, uint64_t, unsigned int *))compress_line_16;
    if (a2 < 3)
      v15 = (uint64_t (*)(uint64_t, uint64_t, unsigned int *))compress_line_8;
    v24 = v15;
    v25 = 4 * (v11 + 1 + ((unint64_t)(v11 + 1) >> 1));
    v16 = -1;
    v17 = &a6[a4 + 3];
    v23 = a4;
    while (1)
    {
      v18 = (_DWORD)v17 - (_DWORD)a6;
      if ((char *)v17 - (char *)a6 + v25 > a7)
        break;
      v19 = v11;
      v20 = v24(a1, v11, v17);
      if (v16 == v20 && !memcmp(v12, v17, v16))
      {
        v18 = (_DWORD)v12 - (_DWORD)a6;
        v21 = (int)v17;
      }
      else
      {
        v16 = v20;
        v21 = (_DWORD)v17 + v20;
        v12 = v17;
        v17 = (unsigned int *)((char *)v17 + v20);
      }
      v11 = v19;
      a4 = v23;
      v26[v14++] = v18;
      a1 += a5;
      if (v23 == v14)
        return (v21 - (_DWORD)a6);
    }
    _CUILog(4, (uint64_t)"compressData: overflow: %ld bytes in %ld byte buffer at scanline %ld (of %ld).\n", a3, a4, a5, (uint64_t)a6, a7, a8, (char *)v17 - (char *)a6);
    return 0;
  }
  v21 = (_DWORD)a6 + 12 + 4 * a4;
  return (v21 - (_DWORD)a6);
}

uint64_t compress_line_8(char *__src, uint64_t a2, unsigned int *a3)
{
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char v10;
  char v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  char *v17;

  if (a2 < 1)
    return 0;
  v5 = __src;
  v6 = 0;
  v7 = &__src[a2];
  v8 = &__src[a2 - 1];
  v9 = __src;
  do
  {
    v11 = *v9++;
    v10 = v11;
    if (v9 >= v7)
    {
      v12 = 0;
      v14 = 1;
    }
    else
    {
      v12 = 0;
      v13 = v8 - v5;
      v14 = 1;
      do
      {
        if (*v9 == v10)
        {
          ++v14;
        }
        else
        {
          if (v14 > 9)
            goto LABEL_12;
          v12 += v14;
          v14 = 1;
          v10 = *v9;
        }
        ++v9;
        --v13;
      }
      while (v13);
      v9 = v7;
    }
LABEL_12:
    if (v14 <= 9)
      v15 = v14;
    else
      v15 = 0;
    v16 = v15 + v12;
    if (v15 + v12 >= 1)
    {
      *a3 = v16;
      v17 = (char *)(a3 + 1);
      memcpy(v17, v5, (v15 + v12));
      v6 = v6 + v16 + 4;
      a3 = (unsigned int *)&v17[v16];
    }
    if (v14 >= 10)
    {
      *a3 = v14 | 0x80000000;
      *((_BYTE *)a3 + 4) = v10;
      v6 = (v6 + 5);
      a3 = (unsigned int *)((char *)a3 + 5);
    }
    v5 = v9;
  }
  while (v9 < v7);
  return v6;
}

uint64_t compress_line_16(unsigned __int16 *__src, uint64_t a2, unsigned int *a3)
{
  unsigned __int16 *v5;
  int v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  char *v15;

  if (a2 < 1)
  {
    v6 = 0;
  }
  else
  {
    v5 = __src;
    v6 = 0;
    v7 = &__src[a2];
    v8 = __src;
    do
    {
      v10 = *v8++;
      v9 = v10;
      if (v8 >= v7)
      {
        v11 = 0;
        v12 = 1;
      }
      else
      {
        v11 = 0;
        v12 = 1;
        do
        {
          if (*v8 == v9)
          {
            ++v12;
          }
          else
          {
            if (v12 > 5)
              break;
            v11 += v12;
            v12 = 1;
            v9 = *v8;
          }
          ++v8;
        }
        while (v8 < v7);
      }
      if (v12 <= 5)
        v13 = v12;
      else
        v13 = 0;
      v14 = v13 + v11;
      if (v13 + v11 >= 1)
      {
        *a3 = v14;
        v15 = (char *)(a3 + 1);
        memcpy(v15, v5, 2 * (v13 + v11));
        v6 += v14 + 2;
        a3 = (unsigned int *)&v15[2 * v14];
      }
      if (v12 >= 6)
      {
        *a3 = v12 | 0x80000000;
        *((_WORD *)a3 + 2) = v9;
        v6 += 3;
        a3 = (unsigned int *)((char *)a3 + 6);
      }
      v5 = v8;
    }
    while (v8 < v7);
  }
  return (2 * v6);
}

uint64_t compress_line_32(char *__src, uint64_t a2, unsigned int *a3)
{
  char *v5;
  int v6;
  char *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  char *v15;

  if (a2 < 1)
  {
    v6 = 0;
  }
  else
  {
    v5 = __src;
    v6 = 0;
    v7 = &__src[4 * a2];
    v8 = (unsigned int *)__src;
    do
    {
      v10 = *v8++;
      v9 = v10;
      if (v8 >= (unsigned int *)v7)
      {
        v11 = 0;
        v12 = 1;
      }
      else
      {
        v11 = 0;
        v12 = 1;
        do
        {
          if (*v8 == v9)
          {
            ++v12;
          }
          else
          {
            if (v12 > 3)
              break;
            v11 += v12;
            v12 = 1;
            v9 = *v8;
          }
          ++v8;
        }
        while (v8 < (unsigned int *)v7);
      }
      if (v12 <= 3)
        v13 = v12;
      else
        v13 = 0;
      v14 = v13 + v11;
      if (v13 + v11 >= 1)
      {
        *a3 = v14;
        v15 = (char *)(a3 + 1);
        memcpy(v15, v5, (int)(4 * v14));
        v6 += v14 + 1;
        a3 = (unsigned int *)&v15[4 * v14];
      }
      if (v12 >= 4)
      {
        *a3 = v12 | 0x80000000;
        a3[1] = v9;
        a3 += 2;
        v6 += 2;
      }
      v5 = (char *)v8;
    }
    while (v8 < (unsigned int *)v7);
  }
  return (4 * v6);
}

int *pk_decompressData(int *result, uint64_t a2, unsigned int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  int v15;
  int *v17;
  unsigned int *v18;
  uint64_t v19;
  BOOL v20;
  uint64_t (*v21)(uint64_t, uint64_t, int, int, int);
  uint64_t (*v22)(uint64_t, uint64_t, int, int, int);
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;

  v8 = *result;
  v9 = 4 * a5;
  v10 = 2 * a3;
  v11 = 2 * a5;
  if (*result != 5)
    v11 = a5;
  if (v8 != 5)
    v10 = a3;
  if (v8 == 6)
  {
    v12 = 4 * a3;
  }
  else
  {
    v9 = v11;
    v12 = v10;
  }
  if (a6 >= 1)
  {
    v15 = a6;
    v17 = result;
    v18 = (unsigned int *)&result[a4 + 3];
    v19 = (v12 + v9);
    v20 = v8 < 3;
    if (v8 == 3)
      v21 = __decompressRLE16;
    else
      v21 = __decompressRLE32;
    if (v20)
      v22 = __decompressRLE8;
    else
      v22 = v21;
    do
    {
      v24 = *v18++;
      LODWORD(v23) = v24;
      v25 = bswap32(v24);
      if ((_DWORD)a8)
        v23 = v25;
      else
        v23 = v23;
      result = (int *)v22((uint64_t)v17 + v23, a2, v12, v19, a8);
      a2 += a7;
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t __decompressRLE8(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  unsigned int *v9;
  int v10;
  unsigned int v11;
  unsigned __int8 *v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;

  if (a4 >= 1)
  {
    v9 = (unsigned int *)result;
    v10 = 0;
    do
    {
      v12 = (unsigned __int8 *)(v9 + 1);
      v11 = *v9;
      v13 = bswap32(*v9);
      if (a5)
        v11 = v13;
      v14 = v11 & 0xFFFFFF;
      v15 = (v11 & 0xFFFFFF) + v10;
      if (HIBYTE(v11) == 128)
      {
        if (v15 > a3)
        {
          v16 = a4 - v10;
          if (a4 - v10 >= v14)
            v16 = v14;
          v17 = v16 - ((a3 - v10) & ~((a3 - v10) >> 31));
          v18 = *v12 | (*v12 << 8);
          result = CGBlt_fillBytes(v17, 1, v18 | (v18 << 16), a2, 0, 0);
          a2 += (int)v17;
        }
        v9 = (unsigned int *)((char *)v9 + 5);
      }
      else
      {
        if (v15 > a3)
        {
          v19 = a4 - v10;
          if (a4 - v10 >= v14)
            v19 = v14;
          v20 = (a3 - v10) & ~((a3 - v10) >> 31);
          v21 = v19 - v20;
          result = CGBlt_copyBytes((v19 - v20), 1, &v12[v20], a2, 0, 0, 0);
          a2 += v21;
        }
        v9 = (unsigned int *)&v12[v14];
      }
      v10 = v15;
    }
    while (v15 < a4);
  }
  return result;
}

uint64_t __decompressRLE16(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  unsigned int *v9;
  int v10;
  unsigned int v11;
  unsigned __int16 *v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  signed int v20;

  if (a4 >= 1)
  {
    v9 = (unsigned int *)result;
    v10 = 0;
    do
    {
      v12 = (unsigned __int16 *)(v9 + 1);
      v11 = *v9;
      v13 = bswap32(*v9);
      if (a5)
        v11 = v13;
      v14 = v11 & 0xFFFFFF;
      v15 = (v11 & 0xFFFFFF) + v10;
      if (HIBYTE(v11) == 128)
      {
        if (v15 > a3)
        {
          v16 = a4 - v10;
          if (a4 - v10 >= v14)
            v16 = v14;
          v17 = v16 - ((a3 - v10) & ~((a3 - v10) >> 31));
          result = CGBlt_fillBytes((2 * v17), 1, *v12 | (*v12 << 16), a2, 0, 0);
          a2 += 2 * v17;
        }
        v9 = (unsigned int *)((char *)v9 + 6);
      }
      else
      {
        if (v15 > a3)
        {
          v18 = a4 - v10;
          if (a4 - v10 >= v14)
            v18 = v14;
          v19 = (a3 - v10) & ~((a3 - v10) >> 31);
          v20 = v18 - v19;
          result = CGBlt_copyBytes(2 * (v18 - v19), 1, &v12[v19], a2, 0, 0, 0);
          a2 += 2 * v20;
        }
        v9 = (unsigned int *)&v12[v14];
      }
      v10 = v15;
    }
    while (v15 < a4);
  }
  return result;
}

uint64_t __decompressRLE32(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  unsigned int *v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  signed int v19;

  if (a4 >= 1)
  {
    v9 = (unsigned int *)result;
    v10 = 0;
    do
    {
      v11 = *v9;
      v12 = bswap32(*v9);
      if (a5)
        v11 = v12;
      v13 = v11 & 0xFFFFFF;
      v14 = (v11 & 0xFFFFFF) + v10;
      if (HIBYTE(v11) == 128)
      {
        if (v14 > a3)
        {
          v15 = a4 - v10;
          if (a4 - v10 >= v13)
            v15 = v13;
          v16 = v15 - ((a3 - v10) & ~((a3 - v10) >> 31));
          result = CGBlt_fillBytes((4 * v16), 1, v9[1], a2, 0, 0);
          a2 += 4 * v16;
        }
        v9 += 2;
      }
      else
      {
        if (v14 > a3)
        {
          v17 = a4 - v10;
          if (a4 - v10 >= v13)
            v17 = v13;
          v18 = (a3 - v10) & ~((a3 - v10) >> 31);
          v19 = v17 - v18;
          result = CGBlt_copyBytes(4 * (v17 - v18), 1, &v9[v18 + 1], a2, 0, 0, 0);
          a2 += 4 * v19;
        }
        v9 += v13 + 1;
      }
      v10 = v14;
    }
    while (v14 < a4);
  }
  return result;
}

void CStdException::CStdException(CStdException *this, uint64_t a2)
{
  *(_QWORD *)this = &off_1E41A8FA0;
  *((_QWORD *)this + 1) = a2;
  CStdException::m_SaveLastErrorCode = a2;
}

void CStdException::~CStdException(CStdException *this)
{
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CStdException::ErrorCode(CStdException *this)
{
  return *((_QWORD *)this + 1);
}

char *CStdException::ErrorString(CStdException *this, char *a2)
{
  return a2;
}

uint64_t CStdException::ErrorMessageOut(CStdException *this)
{
  return *((_QWORD *)this + 1);
}

__CFData *CUIImageCompressedWithHEVC(CGImageRef image, _DWORD *a2, __int16 *a3, size_t *a4, double a5)
{
  CGImageRef v9;
  _BOOL4 v10;
  size_t BitsPerComponent;
  CGColorSpace *ColorSpace;
  const __CFString *v13;
  CGColorSpace *v14;
  __int16 v15;
  __CFData *Mutable;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __CFData *v23;
  CGImageDestinationRef v24;
  double v25;
  CGImageDestination *v26;
  CFIndex Length;
  __CFData *v28;
  __CFData *v29;
  const UInt8 *BytePtr;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *CStringPtr;
  UInt8 bytes[8];
  _QWORD v48[3];
  _QWORD v49[3];
  _QWORD v50[2];
  _QWORD v51[2];

  v9 = image;
  v10 = a5 > 1.0 || a5 <= 0.0;
  if (a2)
    *a2 = 1095911234;
  if (a3)
    *a3 = 1;
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent < 9)
    goto LABEL_20;
  ColorSpace = CGImageGetColorSpace(v9);
  if (CGColorSpaceGetModel(ColorSpace))
  {
    v13 = kCGColorSpaceDisplayP3;
    v14 = CGColorSpaceCreateWithName(kCGColorSpaceDisplayP3);
    if (a2)
      *a2 = 1095911234;
    if (a3)
    {
      v15 = 3;
LABEL_18:
      *a3 = v15;
    }
  }
  else
  {
    v13 = kCGColorSpaceGenericGrayGamma2_2;
    v14 = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
    if (a2)
      *a2 = 1195456544;
    if (a3)
    {
      v15 = 2;
      goto LABEL_18;
    }
  }
  v9 = CUIConvertDeepImageTo8(v9, v14);
  CFRelease(v14);
  if (!v9)
  {
    CStringPtr = CFStringGetCStringPtr(v13, 0x600u);
    _CUILog(4, (uint64_t)"CoreUI: Failed to convert source image to 8-bit color channel with %s colorspace in HEVC compression.", v32, v33, v34, v35, v36, v37, (uint64_t)CStringPtr);
    return 0;
  }
LABEL_20:
  if (a4)
    *a4 = CGImageGetBytesPerRow(v9);
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    if (BitsPerComponent >= 9 && v9)
      CFRelease(v9);
    v31 = "CoreUI: Failed to allocate buffer for HEVC image destination.";
    goto LABEL_45;
  }
  v23 = Mutable;
  v50[0] = kCGImageMetadataShouldExcludeXMP;
  v50[1] = CFSTR("kCGImageMetadataShouldExcludeGPS");
  v51[0] = &unk_1E41DCEC0;
  v51[1] = &unk_1E41DCEC0;
  v24 = CGImageDestinationCreateWithData(Mutable, CFSTR("public.heic"), 1uLL, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v51, v50, 2));
  if (!v24)
  {
    if (BitsPerComponent >= 9 && v9)
      CFRelease(v9);
    CFRelease(v23);
    v31 = "CoreUI: Failed to instantiate HEVC image destination.";
    goto LABEL_45;
  }
  v26 = v24;
  *(float *)&v25 = a5;
  v48[0] = kCGImageDestinationLossyCompressionQuality;
  if (v10)
    *(float *)&v25 = *(float *)"fff?\b";
  v49[0] = +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v25);
  v49[1] = &unk_1E41DCEC0;
  v48[1] = CFSTR("kCGImageDestinationChromaSubSamplingX");
  v48[2] = CFSTR("kCGImageDestinationChromaSubSamplingY");
  v49[2] = &unk_1E41DCEC0;
  CGImageDestinationAddImage(v26, v9, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v49, v48, 3));
  if (!CGImageDestinationFinalize(v26))
  {
    if (BitsPerComponent >= 9 && v9)
      CFRelease(v9);
    CFRelease(v26);
    CFRelease(v23);
    v31 = "CoreUI: Failed to write to HEVC image destination.";
LABEL_45:
    _CUILog(4, (uint64_t)v31, v17, v18, v19, v20, v21, v22, v45);
    return 0;
  }
  CFRelease(v26);
  *(_DWORD *)bytes = 1;
  Length = CFDataGetLength(v23);
  *(_DWORD *)&bytes[4] = Length;
  v28 = CFDataCreateMutable(kCFAllocatorDefault, Length + 8);
  v29 = v28;
  if (v28)
  {
    CFDataAppendBytes(v28, bytes, 8);
    BytePtr = CFDataGetBytePtr(v23);
    CFDataAppendBytes(v29, BytePtr, Length);
    if (BitsPerComponent >= 9 && v9)
      CFRelease(v9);
    CFRelease(v23);
  }
  else
  {
    if (BitsPerComponent >= 9 && v9)
      CFRelease(v9);
    CFRelease(v23);
    _CUILog(4, (uint64_t)"CoreUI: Failed to allocate buffer for encoded payload in HEVC compression.", v39, v40, v41, v42, v43, v44, v45);
  }
  return v29;
}

CFDataRef CUIUncompressHEVCInfoData(uint64_t a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  CFDataRef result;
  const void *v12;
  CGImageSource *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CGImageSource *v20;
  CGImage *ImageAtIndex;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CGImage *v28;
  size_t Height;
  size_t BytesPerRow;
  CGColorSpace *ColorSpace;
  vImagePixelCount v32;
  int v33;
  CGBitmapInfo BitmapInfo;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  vImageConverter *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  vImageConverter *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint32_t BitsPerPixel;
  uint32_t BitsPerComponent;
  CGColorSpace *v61;
  vImagePixelCount Width;
  vImage_Buffer dests;
  vImage_CGImageFormat destFormat;
  vImage_Error error;
  vImage_CGImageFormat format;
  vImage_Buffer buf;

  if (a1 && a2)
  {
    v9 = a4;
    if ((_DWORD)a4 == 1095911234 || (_DWORD)a4 == 1195456544)
    {
      result = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)(a1 + 8), *(unsigned int *)(a1 + 4), kCFAllocatorNull);
      if (!result)
        return result;
      v12 = result;
      v13 = CGImageSourceCreateWithData(result, 0);
      if (v13)
      {
        v20 = v13;
        ImageAtIndex = CGImageSourceCreateImageAtIndex(v13, 0, 0);
        if (ImageAtIndex)
        {
          v28 = ImageAtIndex;
          Width = CGImageGetWidth(ImageAtIndex);
          Height = CGImageGetHeight(v28);
          BytesPerRow = CGImageGetBytesPerRow(v28);
          BitsPerComponent = CGImageGetBitsPerComponent(v28);
          BitsPerPixel = CGImageGetBitsPerPixel(v28);
          ColorSpace = CGImageGetColorSpace(v28);
          v61 = ColorSpace;
          if (v9 == 1195456544 || CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelMonochrome)
          {
            v32 = Height;
            v36 = malloc_type_malloc(BytesPerRow * Height, 0x3EAC2956uLL);
            BitmapInfo = CGImageGetBitmapInfo(v28);
            __CFSetLastAllocationEventName(v36, "CUIHEVCCompression");
            v35 = v36;
            v33 = 1;
            if (!v35)
            {
              v58 = 0;
              goto LABEL_34;
            }
          }
          else
          {
            v32 = Height;
            v33 = 0;
            BitmapInfo = 8196;
            BytesPerRow = a3;
            v35 = a2;
          }
          v58 = v35;
          buf.data = v35;
          buf.height = v32;
          buf.width = Width;
          buf.rowBytes = BytesPerRow;
          format.bitsPerComponent = BitsPerComponent;
          format.bitsPerPixel = BitsPerPixel;
          format.colorSpace = v61;
          format.bitmapInfo = BitmapInfo;
          memset(&format.version, 0, 20);
          if (vImageBuffer_InitWithCGImage(&buf, &format, 0, v28, 0x300u))
          {
            _CUILog(4, (uint64_t)"CoreUI: Failed to get buffer from HEVC CGImage.", v37, v38, v39, v40, v41, v42, v57);
            goto LABEL_34;
          }
          if (v33)
          {
            if (v9 != 1195456544 && CGColorSpaceGetModel(v61))
              -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Boolean CUIUncompressHEVCInfoData(const u_int8_t *, u_int8_t *, size_t, u_int32_t)"), CFSTR("CUIHEVCCompression.m"), 285, CFSTR("Only need to convert to GRAY pixel format"));
            error = 0;
            *(_QWORD *)&destFormat.bitsPerComponent = *(_QWORD *)"\b";
            destFormat.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
            destFormat.bitmapInfo = 4100;
            memset(&destFormat.version, 0, 20);
            dests.data = a2;
            dests.height = v32;
            dests.width = Width;
            dests.rowBytes = a3;
            v43 = vImageConverter_CreateWithCGImageFormat(&format, &destFormat, 0, 0x110u, &error);
            if (!v43 || error)
            {
              _CUILog(4, (uint64_t)"CoreUI: Failed to create image format converter (at %s:%lu)", v44, v45, v46, v47, v48, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/CoreUI/CoreTheme/ImageUtils/CUIHEVCCompression.m");
              goto LABEL_33;
            }
            v50 = v43;
            error = vImageConvert_AnyToAny(v43, &buf, &dests, 0, 0x110u);
            vImageConverter_Release(v50);
            if (error)
            {
              _CUILog(4, (uint64_t)"CoreUI: Failed to convert to destination image format (at %s:%lu)", v51, v52, v53, v54, v55, v56, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/CoreUI/CoreTheme/ImageUtils/CUIHEVCCompression.m");
LABEL_33:
              v33 = 1;
LABEL_34:
              CFRelease(v28);
              CFRelease(v20);
              CFRelease(v12);
              if (v33)
                free(v58);
              return 0;
            }
            CFRelease(v28);
            CFRelease(v20);
            CFRelease(v12);
            free(v58);
          }
          else
          {
            CFRelease(v28);
            CFRelease(v20);
            CFRelease(v12);
          }
          return (CFDataRef)1;
        }
        _CUILog(4, (uint64_t)"CoreUI: Failed to instantiate CGImage from HEVC data.", v22, v23, v24, v25, v26, v27, v57);
        CFRelease(v20);
      }
      else
      {
        _CUILog(4, (uint64_t)"CoreUI: Failed to instantiate CGSourceRef from HEVC data.", v14, v15, v16, v17, v18, v19, v57);
      }
      CFRelease(v12);
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: Unsupported pixel format: %u (at %s:%lu).", a3, a4, a5, a6, a7, a8, a4);
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: Invalid input to %s.", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressHEVCInfoData(const u_int8_t *, u_int8_t *, size_t, u_int32_t)");
  }
  return 0;
}

unsigned __int16 *CUIFillRenditionKeyForCARKeyArray(unsigned __int16 *result, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  unsigned __int16 *v6;
  int v7;

  if (!result || !a2)
    CUIFillRenditionKeyForCARKeyArray_cold_1();
  v5 = *(_DWORD *)(a3 + 8);
  if (v5)
  {
    v6 = result;
    v7 = 0;
    do
    {
      result = CUIRenditionKeySetValueForAttribute(v6, *(unsigned __int16 *)(a3 + 4 * (unsigned __int16)v7 + 12), *(unsigned __int16 *)(a2 + 2 * (unsigned __int16)v7), (unsigned __int16)(v5 + 1));
      ++v7;
      v5 = *(_DWORD *)(a3 + 8);
    }
    while (v5 > (unsigned __int16)v7);
  }
  return result;
}

uint64_t CUIRenditionKeyIndexForAttribute(unsigned __int16 *a1, int a2)
{
  int v3;
  uint64_t result;
  unsigned __int16 *v6;
  int v7;
  BOOL v8;

  if (!a1)
    return 0xFFFFFFFFLL;
  v3 = *a1;
  if (!a1[1] && v3 == 0)
    return 0xFFFFFFFFLL;
  result = 0;
  v6 = a1 + 3;
  while (v3 != a2)
  {
    v7 = *v6;
    v3 = *(v6 - 1);
    result = (result + 1);
    v6 += 2;
    if (v7)
      v8 = 0;
    else
      v8 = v3 == 0;
    if (v8)
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CUIRenditionKeyFormatRemoveAttribute(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(unsigned int *)(result + 8);
  if ((_DWORD)v2)
  {
    v3 = 0;
    while (*(_DWORD *)(result + 12 + 4 * v3) != a2)
    {
      if (v2 == ++v3)
        return result;
    }
    if ((int)v3 + 1 < v2)
    {
      do
      {
        *(_DWORD *)(result + 4 * v3 + 12) = *(_DWORD *)(result + 16 + 4 * v3);
        ++v3;
      }
      while ((_DWORD)v2 - 1 != (_DWORD)v3);
    }
    *(_DWORD *)(result + 8) = v2 - 1;
  }
  return result;
}

uint64_t CUIFillCARKeyArrayForRenditionKey(uint64_t a1, int *a2, uint64_t a3)
{
  return CUIFillCARKeyArrayForRenditionKey2(a1, a2, a3, 0);
}

void CUIRenditionKeyStandardize(void *a1, unsigned __int16 *a2, uint64_t a3)
{
  unsigned int v6;
  _WORD *v7;
  _WORD *v8;
  uint64_t v9;
  int *v10;
  __int16 v11;
  int v12;
  unsigned int v13;
  _OWORD v14[6];

  memset(v14, 0, 92);
  v6 = *(_DWORD *)(a3 + 8);
  if (v6 - 23 > 0xFFFFFFE7)
  {
    v7 = v14;
  }
  else
  {
    v7 = malloc_type_calloc(v6 + 3, 4uLL, 0x100004052888210uLL);
    v6 = *(_DWORD *)(a3 + 8);
  }
  v8 = v7;
  if (v6)
  {
    v9 = v6;
    v10 = (int *)(a3 + 12);
    v8 = v7;
    do
    {
      v12 = *v10++;
      v11 = v12;
      v13 = CUIRenditionKeyValueForAttribute(a2, (unsigned __int16)v12);
      if (v13)
      {
        *v8 = v11;
        v8[1] = v13;
        v8 += 2;
      }
      --v9;
    }
    while (v9);
  }
  *(_DWORD *)v8 = 0;
  CUIRenditionKeyCopy(a1, v7, (unsigned __int16)(*(_WORD *)(a3 + 8) + 1));
  if (v7 != (_WORD *)v14)
    free(v7);
}

uint64_t CUICompareRenditionKey(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;

  v4 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v4)
    return 0;
  v7 = (unsigned __int16 *)(a3 + 12);
  while (1)
  {
    v8 = *v7;
    v7 += 2;
    v9 = CUIRenditionKeyValueForAttribute(a1, v8);
    v10 = CUIRenditionKeyValueForAttribute(a2, v8);
    v11 = v9 > v10 ? 1 : v3;
    v3 = v9 < v10 ? -1 : v11;
    if (v9 != v10)
      break;
    if (!--v4)
      return 0;
  }
  return v3;
}

uint64_t CUIMinScaleForTargetPlatform(uint64_t a1)
{
  if ((a1 & 0xFFFFFFFFFFFFFFFELL) == 4)
    return 2;
  else
    return 1;
}

double CUIPointSizeForDimensionForVectorGlyph(uint64_t a1, unsigned int a2)
{
  char *v2;
  char *v3;
  char *v4;

  v2 = (char *)&__VectorGlyphDimension2ToPointSizeTableEmbedded + 8 * a2;
  v3 = (char *)&__VectorGlyphDimension2ToPointSizeTableWatch + 8 * a2;
  v4 = (char *)&__VectorGlyphDimension2ToPointSizeTableForMac + 8 * a2;
  if (a1)
    v4 = (char *)&__VectorGlyphDimension2ToPointSizeTableEmbedded + 8 * a2;
  if (a1 != 4)
    v3 = v4;
  if (a1 != 5)
    v2 = v3;
  return *(double *)v2;
}

uint64_t CUIMinDimensionForVectorGlyph()
{
  return 0;
}

uint64_t CUIMaxDimensionForVectorGlyph(uint64_t a1)
{
  if (a1 == 4)
    return 1;
  else
    return 3;
}

uint64_t CUIPreferredVectorGlyphConfigurationsForPlatform(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 6)
    return (uint64_t)*(&off_1E41AAFE8 + a1);
  _CUILog(4, (uint64_t)"CoreUI: CUIPreferredVectorGlyphConfigurationsForPlatform() called with an unknown platform '%d'", a3, a4, a5, a6, a7, a8, a1);
  return 0;
}

const __CFString *CUIPlatformNameForPlatform(uint64_t a1)
{
  const __CFString *result;

  switch(a1)
  {
    case 0:
      result = kCUIPlatformMac[0];
      break;
    case 1:
      result = (const __CFString *)kCUIPlatformiOS;
      break;
    case 2:
      result = (const __CFString *)kCUIPlatformMaciOS;
      break;
    case 3:
      result = (const __CFString *)kCUIPlatformAppleTV;
      break;
    case 4:
      result = kCUIPlatformWatch[0];
      break;
    case 5:
      result = (const __CFString *)kCUIPlatformVision;
      break;
    default:
      result = &stru_1E41B97C0;
      break;
  }
  return result;
}

const char *CUICGBlendModeFromLSRDescription(void *a1)
{
  const char *result;
  const char *v2;
  uint64_t v3;

  result = (const char *)objc_msgSend(a1, "UTF8String");
  if (result)
  {
    v2 = result;
    v3 = 0;
    while (strcasecmp((const char *)gCGBlendModeDescriptions[v3 + 1], v2))
    {
      v3 += 3;
      if (v3 == 84)
        return 0;
    }
    return (const char *)LODWORD(gCGBlendModeDescriptions[v3]);
  }
  return result;
}

const __CFString *CUIBlendModeLSRDescriptionFromCGBlendMode(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (gCGBlendModeDescriptions[v1] != a1)
  {
    v1 += 3;
    if (v1 == 84)
      return CFSTR("normal");
  }
  return (const __CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", gCGBlendModeDescriptions[v1 + 1]);
}

const __CFString *CUIBlendModeDescriptionFromCGBlendMode(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (gCGBlendModeDescriptions[v1] != a1)
  {
    v1 += 3;
    if (v1 == 84)
      return CFSTR("Normal");
  }
  return (const __CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", gCGBlendModeDescriptions[v1 + 2]);
}

const char *CUIThemeAttributeNameToString(int a1)
{
  if ((a1 - 1) > 0x1B)
    return "UNKNOWN";
  else
    return off_1E41AB018[a1 - 1];
}

id CUIKeyFormatToArrayString(uint64_t a1)
{
  id v2;
  int v3;

  v2 = +[NSMutableArray array](NSMutableArray, "array");
  if (*(_DWORD *)(a1 + 8))
  {
    v3 = 0;
    do
      objc_msgSend(v2, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", CUIThemeAttributeNameToString(*(_DWORD *)(a1 + 4 * (unsigned __int16)v3++ + 12))));
    while (*(_DWORD *)(a1 + 8) > (unsigned __int16)v3);
  }
  return v2;
}

CFDataRef CUICompressedDataWithLZFSE(const __CFData *a1)
{
  return __compress_data_stream(a1, COMPRESSION_STREAM_ENCODE);
}

uint64_t CreateFile(char *a1, int a2)
{
  return CreateFileOptionalLogging(a1, a2, 1);
}

uint64_t CreateFileOptionalLogging(char *a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t result;
  FILE *v7;
  int *v8;
  char *v9;

  if (a2 && a2 != 1538)
  {
    if (a3)
      fwrite("Error: Only GENERIC_READ or CREATE_ALWAYS supported at this time\n", 0x41uLL, 1uLL, __stderrp);
    return 0xFFFFFFFFLL;
  }
  v5 = 511;
  if (a2 != 1538)
    v5 = 0;
  result = open(a1, a2, v5);
  if ((result & 0x80000000) != 0)
  {
    if (a3)
    {
      v7 = __stderrp;
      v8 = __error();
      v9 = strerror(*v8);
      fprintf(v7, "Failed to open file: %s [%s]\n", a1, v9);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CloseHandle(int a1)
{
  FILE *v2;
  int *v3;
  char *v4;

  if ((close(a1) & 0x80000000) == 0)
    return 1;
  v2 = __stderrp;
  v3 = __error();
  v4 = strerror(*v3);
  fprintf(v2, "Failed to close File Stream [%s]\n", v4);
  return 0;
}

uint64_t ReadFile(int a1, void *a2, size_t a3, _DWORD *a4)
{
  ssize_t v5;
  FILE *v7;
  int *v8;
  char *v9;

  v5 = read(a1, a2, a3);
  if (v5 < 0)
  {
    v7 = __stderrp;
    v8 = __error();
    v9 = strerror(*v8);
    fprintf(v7, "Error while reading file: [%s]\n", v9);
    return 0;
  }
  else
  {
    *a4 = v5;
    return 1;
  }
}

unint64_t SetFilePointer(int a1, off_t a2, unint64_t *a3, int a4)
{
  unint64_t result;
  FILE *v6;
  int *v7;
  char *v8;

  if (a3)
  {
    result = lseek(a1, a2 | (*a3 << 32), a4);
    if ((result & 0x8000000000000000) == 0)
    {
      *a3 = HIDWORD(result);
      return result;
    }
  }
  else
  {
    result = lseek(a1, a2, a4);
    if ((result & 0x8000000000000000) == 0)
      return result;
  }
  v6 = __stderrp;
  v7 = __error();
  v8 = strerror(*v7);
  fprintf(v6, "Error while seeking: [%s]\n", v8);
  return 0;
}

void *File::CopyToBuffer(File *this, const void *a2, size_t a3)
{
  uint64_t v3;
  int v4;
  void *result;

  v3 = *((unsigned int *)this + 2);
  if ((uint64_t)(v3 + a3) >= 2049)
    File::CopyToBuffer();
  v4 = a3;
  result = memcpy((char *)this + v3 + 12, a2, a3);
  *((_DWORD *)this + 2) += v4;
  return result;
}

uint64_t File::BufferedWrite(File *this, const void *a2, int64_t a3)
{
  size_t v6;

  v6 = *((unsigned int *)this + 2);
  if ((uint64_t)(v6 + a3) <= 2048)
    goto LABEL_5;
  if ((_DWORD)v6)
  {
    write(*((_DWORD *)this + 515), (char *)this + 12, v6);
    *((_DWORD *)this + 2) = 0;
  }
  if (a3 > 2048)
    a3 += write(*((_DWORD *)this + 515), a2, a3);
  else
LABEL_5:
    File::CopyToBuffer(this, a2, a3);
  return a3;
}

uint64_t File::AppendUTF16StringCore(File *this, unsigned __int16 *a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  __int16 v13;

  if (!a3)
    return 0;
  v5 = 0;
  v6 = *((_QWORD *)this + 258);
  v7 = a3;
  while (1)
  {
    v9 = *a2++;
    v8 = v9;
    v10 = bswap32(v9) >> 16;
    if (v6 != 1)
      v8 = v10;
    v13 = v8;
    v11 = File::BufferedWrite(this, &v13, 2);
    if (v11 == -1)
      break;
    v5 += v11;
    if (!--v7)
      return v5;
  }
  return -1;
}

uint64_t File::AppendZerosCore(File *this, size_t size)
{
  void *v4;
  void *v5;
  uint64_t v6;

  if (!size)
    return 0;
  v4 = malloc_type_malloc(size, 0xE8C0764CuLL);
  if (!v4)
    return 0;
  v5 = v4;
  bzero(v4, size);
  v6 = File::BufferedWrite(this, v5, size);
  free(v5);
  return v6;
}

void File::File(File *this, int a2, uint64_t a3)
{
  *(_QWORD *)this = &off_1E41AA0C8;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 515) = a2;
  *((_QWORD *)this + 258) = a3;
}

void File::HandleWriteOperationResults(File *this, uint64_t a2)
{
  void *exception;

  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(1uLL);
  }
}

void File::AppendCString(File *this, char *__s)
{
  size_t v4;
  File *v5;

  v4 = strlen(__s);
  v5 = (File *)File::BufferedWrite(this, __s, v4);
  File::HandleWriteOperationResults(v5, (uint64_t)v5);
}

uint64_t File::AppendAsPString(uint64_t a1, char *__s, int a3)
{
  size_t v6;
  size_t v7;
  uint64_t result;
  void *exception;

  v6 = strlen(__s);
  if (v6 >= 0x100)
  {
    exception = __cxa_allocate_exception(1uLL);
  }
  v7 = v6;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 64))(a1, v6);
  result = (*(uint64_t (**)(uint64_t, char *, size_t))(*(_QWORD *)a1 + 48))(a1, __s, v7);
  if (a3 == 2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 64))(a1, 0);
  if (a3 == 4)
    __asm { BR              X10 }
  return result;
}

void File::AppendUTF16String(File *this, unsigned __int16 *a2, unsigned int a3)
{
  File *appended;

  appended = (File *)File::AppendUTF16StringCore(this, a2, a3);
  File::HandleWriteOperationResults(appended, (uint64_t)appended);
}

void File::AppendBytes(File *this, void *a2, int64_t a3)
{
  File *v3;

  v3 = (File *)File::BufferedWrite(this, a2, a3);
  File::HandleWriteOperationResults(v3, (uint64_t)v3);
}

void File::AppendZeros(File *this, size_t a2)
{
  File *appended;

  appended = (File *)File::AppendZerosCore(this, a2);
  File::HandleWriteOperationResults(appended, (uint64_t)appended);
}

void File::AppendUInt8(File *this, char a2)
{
  File *v2;
  char v3;

  v3 = a2;
  v2 = (File *)File::BufferedWrite(this, &v3, 1);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

void File::AppendUInt16(File *this, __int16 a2)
{
  File *v2;
  __int16 v3;

  v3 = a2;
  if (*((_QWORD *)this + 258) != 1)
    v3 = __rev16(a2);
  v2 = (File *)File::BufferedWrite(this, &v3, 2);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

void File::AppendUInt32(File *this, unsigned int a2)
{
  File *v2;
  unsigned int v3;

  v3 = a2;
  if (*((_QWORD *)this + 258) != 1)
    v3 = bswap32(a2);
  v2 = (File *)File::BufferedWrite(this, &v3, 4);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

void File::AppendFloat64(File *this, double a2)
{
  File *v2;
  unint64_t v3;

  v3 = *(_QWORD *)&a2;
  if (*((_QWORD *)this + 258) != 1)
    v3 = bswap64(*(unint64_t *)&a2);
  v2 = (File *)File::BufferedWrite(this, &v3, 8);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

size_t ByteCounter::AppendAsPString(uint64_t a1, char *__s, int a3)
{
  size_t result;
  uint64_t v6;
  void *exception;

  result = strlen(__s);
  if (result >= 0x100)
  {
    exception = __cxa_allocate_exception(1uLL);
  }
  v6 = result + *(_QWORD *)(a1 + 2072) + 1;
  *(_QWORD *)(a1 + 2072) = v6;
  if (a3 == 2)
  {
    *(_QWORD *)(a1 + 2072) = v6 + 1;
  }
  else if (a3 == 4)
  {
    __asm { BR              X12 }
  }
  return result;
}

void File::~File(File *this)
{
  File::~File(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  int v2;
  size_t v3;

  *(_QWORD *)this = &off_1E41AA0C8;
  v2 = *((_DWORD *)this + 515);
  if (v2)
  {
    v3 = *((unsigned int *)this + 2);
    if ((_DWORD)v3)
    {
      write(v2, (char *)this + 12, v3);
      *((_DWORD *)this + 2) = 0;
    }
  }
}

uint64_t File::GetCurrentBytePosition(File *this)
{
  return *((_DWORD *)this + 2) + SetFilePointer(*((_DWORD *)this + 515), 0, 0, 1);
}

void ByteCounter::~ByteCounter(ByteCounter *this)
{
  File::~File(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t ByteCounter::GetCurrentBytePosition(ByteCounter *this)
{
  return *((_QWORD *)this + 259);
}

size_t ByteCounter::AppendCString(ByteCounter *this, char *__s)
{
  size_t result;

  result = strlen(__s);
  *((_QWORD *)this + 259) += result;
  return result;
}

uint64_t ByteCounter::AppendUTF16String(uint64_t this, unsigned __int16 *a2, int a3)
{
  *(_QWORD *)(this + 2072) += (2 * a3);
  return this;
}

uint64_t ByteCounter::AppendBytes(uint64_t this, void *a2, uint64_t a3)
{
  *(_QWORD *)(this + 2072) += a3;
  return this;
}

uint64_t ByteCounter::AppendZeros(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 2072) += a2;
  return this;
}

uint64_t ByteCounter::AppendUInt8(uint64_t this)
{
  ++*(_QWORD *)(this + 2072);
  return this;
}

uint64_t ByteCounter::AppendUInt16(uint64_t this)
{
  *(_QWORD *)(this + 2072) += 2;
  return this;
}

uint64_t ByteCounter::AppendUInt32(uint64_t this)
{
  *(_QWORD *)(this + 2072) += 4;
  return this;
}

uint64_t ByteCounter::AppendFloat64(uint64_t this, double a2)
{
  *(_QWORD *)(this + 2072) += 8;
  return this;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

__CFData *CUIImageCompressedWithJPEGandLZFSE(CGImageRef image, _DWORD *a2, __int16 *a3, size_t *a4, double a5)
{
  CGImageRef v9;
  _BOOL4 v10;
  size_t BitsPerComponent;
  CGColorSpace *ColorSpace;
  CGColorSpace *v13;
  __int16 v14;
  CGImageAlphaInfo AlphaInfo;
  __int16 BitmapInfo;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int Width;
  uint64_t v24;
  uint32_t v25;
  int v26;
  CGImageAlphaInfo v27;
  CGBitmapInfo v28;
  char v29;
  vImage_Error v30;
  __CFData *v31;
  CGImage *v33;
  CGImage *v34;
  float v35;
  CGColorSpace *v36;
  CGImageRef CopyWithColorSpace;
  __CFData *Mutable;
  CGImageDestination *v39;
  double v40;
  unsigned int v41;
  uint64_t v42;
  uint8_t *v43;
  uint64_t v44;
  unsigned int v45;
  const UInt8 *BytePtr;
  CFIndex v47;
  CFIndex v48;
  vImage_Buffer v49;
  vImage_CGImageFormat format;
  vImage_Buffer buf;
  UInt8 bytes[8];
  CFIndex length;
  unsigned int v54;
  _QWORD v55[3];
  _QWORD v56[3];
  _QWORD v57[2];
  _QWORD v58[2];

  v9 = image;
  v10 = a5 > 1.0 || a5 <= 0.0;
  if (a2)
    *a2 = 1095911234;
  if (a3)
    *a3 = 1;
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent < 9)
    goto LABEL_20;
  ColorSpace = CGImageGetColorSpace(v9);
  if (CGColorSpaceGetModel(ColorSpace))
  {
    v13 = CGColorSpaceCreateWithName(kCGColorSpaceDisplayP3);
    if (a2)
      *a2 = 1095911234;
    if (a3)
    {
      v14 = 3;
LABEL_18:
      *a3 = v14;
    }
  }
  else
  {
    v13 = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
    if (a2)
      *a2 = 1195456544;
    if (a3)
    {
      v14 = 2;
      goto LABEL_18;
    }
  }
  v9 = CUIConvertDeepImageTo8(v9, v13);
  CFRelease(v13);
  if (!v9)
    return 0;
LABEL_20:
  AlphaInfo = CGImageGetAlphaInfo(v9);
  BitmapInfo = CGImageGetBitmapInfo(v9);
  Width = CGImageGetWidth(v9);
  *(_QWORD *)bytes = 0;
  length = 0;
  v54 = 0;
  if (AlphaInfo > kCGImageAlphaNoneSkipFirst)
  {
    _CUILog(4, (uint64_t)"CoreUI: need to do something here", v17, v18, v19, v20, v21, v22, (uint64_t)v49.data);
    v24 = 0;
LABEL_31:
    v25 = 32;
    v26 = 1;
    AlphaInfo = kCGImageAlphaNoneSkipLast;
    goto LABEL_32;
  }
  if (((1 << AlphaInfo) & 0x2A) != 0)
  {
    if ((BitmapInfo & 0x7000) == 0x2000)
      v24 = 0;
    else
      v24 = 3;
    goto LABEL_31;
  }
  if (((1 << AlphaInfo) & 0x54) != 0)
  {
    if ((BitmapInfo & 0x7000) == 0x2000)
      v24 = 3;
    else
      v24 = 0;
    v25 = 32;
    v26 = 1;
    AlphaInfo = kCGImageAlphaNoneSkipFirst;
  }
  else
  {
    v26 = 0;
    v24 = AlphaInfo;
    v25 = 24;
  }
LABEL_32:
  memset(&buf, 0, sizeof(buf));
  *((_DWORD *)&format.renderingIntent + 1) = 0;
  memset(&v49, 0, sizeof(v49));
  format.bitsPerComponent = 8;
  format.bitsPerPixel = v25;
  format.colorSpace = CGImageGetColorSpace(v9);
  v27 = CGImageGetAlphaInfo(v9);
  v28 = CGImageGetBitmapInfo(v9);
  v29 = v28 | v27;
  format.bitmapInfo = v28 | v27;
  format.version = 0;
  format.decode = 0;
  format.renderingIntent = CGImageGetRenderingIntent(v9);
  v30 = vImageBuffer_InitWithCGImage(&buf, &format, 0, v9, 0x100u);
  if (BitsPerComponent >= 9)
    CGImageRelease(v9);
  if (v30)
    return 0;
  format.bitmapInfo = format.bitmapInfo & ~(v29 & 0x1F) | AlphaInfo;
  v33 = vImageCreateCGImageFromBuffer(&buf, &format, 0, 0, 0, 0);
  if (!v33)
    return 0;
  v34 = v33;
  if (a4)
    *a4 = CGImageGetBytesPerRow(v33);
  v35 = a5;
  v36 = CGImageGetColorSpace(v34);
  if (v36 != format.colorSpace)
  {
    CopyWithColorSpace = CGImageCreateCopyWithColorSpace(v34, format.colorSpace);
    CGImageRelease(v34);
    v34 = CopyWithColorSpace;
  }
  format.colorSpace = 0;
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  v57[0] = kCGImageMetadataShouldExcludeXMP;
  v57[1] = CFSTR("kCGImageMetadataShouldExcludeGPS");
  v58[0] = &unk_1E41DCED8;
  v58[1] = &unk_1E41DCED8;
  v39 = CGImageDestinationCreateWithData(Mutable, CFSTR("public.jpeg"), 1uLL, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v58, v57, 2, v49.data, v49.height, *(_OWORD *)&v49.width, *(_QWORD *)&format.bitsPerComponent));
  v55[0] = kCGImageDestinationLossyCompressionQuality;
  LODWORD(v40) = *(_DWORD *)"fff?\b";
  if (!v10)
    *(float *)&v40 = v35;
  v56[0] = +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v40);
  v56[1] = &unk_1E41DCED8;
  v55[1] = CFSTR("kCGImageDestinationChromaSubSamplingX");
  v55[2] = CFSTR("kCGImageDestinationChromaSubSamplingY");
  v56[2] = &unk_1E41DCED8;
  CGImageDestinationAddImage(v39, v34, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v56, v55, 3));
  CGImageDestinationFinalize(v39);
  CFRelease(v34);
  *(_DWORD *)bytes = 0;
  v41 = CFDataGetLength(Mutable);
  HIDWORD(length) = Width;
  v54 = v41;
  v42 = Width;
  v43 = (uint8_t *)malloc_type_malloc(buf.height * Width, 0x8E4428C2uLL);
  __CFSetLastAllocationEventName(v43, "CUIImageCompressedWithJPEGandLZFSE");
  v44 = 0;
  LODWORD(length) = 0;
  if (!v26)
    goto LABEL_50;
  v49.height = buf.height;
  v49.width = buf.width;
  v49.rowBytes = buf.width;
  v49.data = malloc_type_malloc(buf.width * buf.height, 0xF57DD6EEuLL);
  __CFSetLastAllocationEventName(v49.data, "CUIImageCompressedWithJPEGandLZFSE");
  if (!vImageExtractChannel_ARGB8888(&buf, &v49, v24, 0x100u))
  {
    v45 = compression_encode_buffer(v43, buf.height * v42, (const uint8_t *)v49.data, v49.rowBytes * v49.height, 0, COMPRESSION_LZFSE);
    LODWORD(length) = v45;
    if (v45)
    {
      free(v49.data);
      v44 = v45;
LABEL_50:
      v31 = CFDataCreateMutable(kCFAllocatorDefault, v44 + v41 + 20);
      CFDataAppendBytes(v31, bytes, 20);
      CFDataAppendBytes(v31, v43, length);
      BytePtr = CFDataGetBytePtr(Mutable);
      v47 = CFDataGetLength(Mutable);
      CFDataAppendBytes(v31, BytePtr, v47);
      goto LABEL_51;
    }
  }
  free(v49.data);
  v31 = 0;
LABEL_51:
  free(buf.data);
  free(v43);
  CFRelease(v39);
  CFRelease(Mutable);
  if (v31)
  {
    v48 = CFDataGetLength(v31);
    if (v48 > (int64_t)(buf.height * HIDWORD(length)))
    {
      CFRelease(v31);
      return 0;
    }
  }
  return v31;
}

BOOL CUIUncompressJPEGandLZFSEInfoData(const UInt8 *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 v8;
  int v9;
  int v10;
  int v11;
  const __CFData *v15;
  CGImageSource *v16;
  CGImageSource *v17;
  CGImage *ImageAtIndex;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CGColorSpaceRef ColorSpace;
  uint64_t *v26;
  const vImage_Buffer *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  vImagePixelCount Width;
  size_t v36;
  vImage_Error v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  vImage_Error v44;
  uint64_t v46;
  _QWORD block[5];
  _QWORD v48[10];
  int v49;
  _QWORD v50[8];
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  char v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  vImage_Buffer newSrc;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  void *v67;
  int v68;
  int v69;
  uint64_t v70;
  int v71;
  int v72;
  __int128 v73;
  uint64_t v74;
  const vImage_Buffer *v75;
  uint64_t v76;
  void *v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;

  if (*((_DWORD *)a1 + 1))
  {
    _CUILog(4, (uint64_t)"CoreUI: not expecting to a JPEG-LZFSE image with a chunk count != 0", a3, a4, a5, a6, a7, a8, v46);
    return 0;
  }
  else
  {
    v9 = a6;
    v10 = a5;
    v11 = a4;
    v15 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, &a1[*((unsigned int *)a1 + 2) + 20], *((unsigned int *)a1 + 4), kCFAllocatorNull);
    v16 = CGImageSourceCreateWithData(v15, 0);
    if (v16)
    {
      v17 = v16;
      ImageAtIndex = CGImageSourceCreateImageAtIndex(v16, 0, 0);
      v8 = (_BOOL8)ImageAtIndex;
      if (ImageAtIndex)
      {
        v80 = 0;
        v81 = &v80;
        v82 = 0x2020000000;
        v83 = 0;
        v74 = 0;
        v75 = (const vImage_Buffer *)&v74;
        v76 = 0x4010000000;
        v77 = &unk_19EC9DD21;
        v78 = 0u;
        v79 = 0u;
        v64 = 0;
        v65 = &v64;
        v66 = 0x4810000000;
        v67 = &unk_19EC9DD21;
        v70 = 0;
        v73 = 0u;
        memset(&newSrc, 0, sizeof(newSrc));
        v59 = 0;
        v60 = &v59;
        v61 = 0x2020000000;
        v62 = 0;
        v55 = 0;
        v56 = &v55;
        v57 = 0x2020000000;
        v58 = 0;
        v51 = 0;
        v52 = &v51;
        v53 = 0x2020000000;
        v54 = 0;
        v68 = v11;
        v69 = v10;
        v71 = v9;
        v72 = 0;
        *(_QWORD *)&v73 = 0;
        ColorSpace = CGImageGetColorSpace(ImageAtIndex);
        v26 = v65;
        v65[5] = (uint64_t)ColorSpace;
        *((_DWORD *)v26 + 16) = 0;
        v27 = v75;
        v75[1].rowBytes = a3;
        v27[1].data = a2;
        v50[0] = _NSConcreteStackBlock;
        v50[1] = 3221225472;
        v50[2] = __CUIUncompressJPEGandLZFSEInfoData_block_invoke;
        v50[3] = &unk_1E41AB100;
        v50[4] = &v80;
        v50[5] = &v74;
        v50[6] = &v64;
        v50[7] = v8;
        v48[0] = _NSConcreteStackBlock;
        v48[1] = 3221225472;
        v48[2] = __CUIUncompressJPEGandLZFSEInfoData_block_invoke_2;
        v48[3] = &unk_1E41AB128;
        v49 = v9;
        v48[4] = &v51;
        v48[5] = &v55;
        v48[8] = v8;
        v48[9] = a1;
        v48[6] = &v59;
        v48[7] = a1;
        v28 = objc_alloc_init((Class)NSMutableArray);
        objc_msgSend(v28, "addObject:", v50);
        objc_msgSend(v28, "addObject:", v48);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = __CUIUncompressJPEGandLZFSEInfoData_block_invoke_3;
        block[3] = &unk_1E41AB150;
        block[4] = v28;
        dispatch_apply((size_t)objc_msgSend(v28, "count"), 0, block);

        if (!v60[3] || v81[3])
        {
          _CUILog(4, (uint64_t)"CoreUI: Couldn't decompress the alpha channel or decode JPEG of a JPEG-LZFSE image %zu:%zd", v29, v30, v31, v32, v33, v34, v60[3]);
        }
        else
        {
          newSrc.data = (void *)v56[3];
          newSrc.height = CGImageGetHeight((CGImageRef)v8);
          Width = CGImageGetWidth((CGImageRef)v8);
          v36 = *((unsigned int *)a1 + 3);
          newSrc.width = Width;
          newSrc.rowBytes = v36;
          v37 = vImageOverwriteChannels_ARGB8888(&newSrc, v75 + 1, v75 + 1, *((_BYTE *)v52 + 24), 0x10u);
          v81[3] = v37;
          if (v37)
          {
            _CUILog(4, (uint64_t)"CoreUI: Couldn't clip to alpha of a JPEG-LZFSE image %zd", v38, v39, v40, v41, v42, v43, v37);
          }
          else
          {
            v44 = vImageClipToAlpha_RGBA8888(v75 + 1, v75 + 1, 0x10u);
            v81[3] = v44;
          }
        }
        free((void *)v56[3]);
        CFRelease((CFTypeRef)v8);
        if (v60[3])
          v8 = v81[3] == 0;
        else
          v8 = 0;
        _Block_object_dispose(&v51, 8);
        _Block_object_dispose(&v55, 8);
        _Block_object_dispose(&v59, 8);
        _Block_object_dispose(&v64, 8);
        _Block_object_dispose(&v74, 8);
        _Block_object_dispose(&v80, 8);
      }
      else
      {
        _CUILog(4, (uint64_t)"CoreUI: Couldn't get the jpeg CGImageFrom from the data of a JPEG-LZFSE image", v19, v20, v21, v22, v23, v24, v46);
      }
      CFRelease(v17);
    }
    else
    {
      v8 = 0;
    }
    CFRelease(v15);
  }
  return v8;
}

void sub_19EBF3BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  uint64_t v54;

  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose((const void *)(v54 - 208), 8);
  _Block_object_dispose((const void *)(v54 - 144), 8);
  _Unwind_Resume(a1);
}

void _CUISetPattern(CGContext *a1, CGPattern *a2)
{
  CGColorSpace *Pattern;
  CGFloat components;

  if (a2)
  {
    components = 1.0;
    Pattern = CGColorSpaceCreatePattern(0);
    CGContextSetFillColorSpace(a1, Pattern);
    CGContextSetFillPattern(a1, a2, &components);
    CGContextSetStrokeColorSpace(a1, Pattern);
    CGContextSetStrokePattern(a1, a2, &components);
    CGColorSpaceRelease(Pattern);
  }
}

void drawPatternBitmap(CGImageRef image, CGContextRef c)
{
  CGRect v2;

  v2.origin.x = 0.0;
  v2.origin.y = 0.0;
  v2.size.width = 1.0;
  v2.size.height = 1.0;
  CGContextDrawImage(c, v2, image);
}

__CFData *__CUIImageCompressedWithDeepmap2(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  __CFData *Mutable;
  const char *v14;
  uint64_t v16;
  UInt8 bytes[4];
  int v18;
  CFIndex v19;
  UInt8 *v20;
  uint64_t v21;
  int v22;

  v4 = a2;
  v20 = 0;
  v21 = a3;
  v22 = a4;
  v5 = vImageDeepmap2EncodeCreateBuffer(a1, a2, &v21, &v20);
  if (!v5)
  {
    v14 = "CoreUI: vImageDeepmap2EncodeCreateBuffer() returned 0.";
LABEL_8:
    _CUILog(4, (uint64_t)v14, v6, v7, v8, v9, v10, v11, v16);
    return 0;
  }
  v12 = v5;
  if (!v20)
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "CFDataRef __CUIImageCompressedWithDeepmap2(vImage_Buffer, vImageDeepmap2PixelFormat, vImageDeepmap2CompressionOptions)"), CFSTR("CUIDeepmap2Compression.m"), 173, CFSTR("Expects non-null pointer."));
  if ((v21 - 1) >= 4)
  {
    v16 = v21;
    v14 = "CoreUI: vImageDeepmap2EncodeCreateBuffer() returned unrecognized compression method: %lu [%s]";
    goto LABEL_8;
  }
  *(_DWORD *)bytes = 1;
  v18 = v4;
  v19 = v12;
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, v12 + 16);
  CFDataAppendBytes(Mutable, bytes, 16);
  CFDataAppendBytes(Mutable, v20, v12);
  free(v20);
  return Mutable;
}

id CUIImageCompressedWithDeepmap2(unsigned int *a1, _QWORD *a2, uint64_t a3, _DWORD *a4, __int16 *a5, _QWORD *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v11;
  __int16 v12;
  id v13;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  __int128 v18;
  __CFData *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFData *v26;
  uint64_t v27;
  unint64_t v28;
  __int128 v29;
  __CFData *v30;
  __CFData *v31;
  __int128 v32;
  __int128 v33;

  if (!*a2 || !a2[3] || (v9 = a2[2]) == 0 || !a2[1])
  {
    _CUILog(4, (uint64_t)"CoreUI: invalid input image buffer in %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap2(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
    return 0;
  }
  if (*a1 != 8 && *a1 != 16)
  {
    _CUILog(4, (uint64_t)"CoreUI: unsupported bpc for Deepmap 2.0 compression: %d [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, *a1);
    return 0;
  }
  if (!*((_QWORD *)a1 + 1))
  {
    _CUILog(4, (uint64_t)"CoreUI: Missing image color space to perform Deemap 2.0 compression [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap2(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
    return 0;
  }
  if ((int)a3 > 1195456543)
  {
    if ((_DWORD)a3 == 1195456544)
    {
      v12 = 2;
      v11 = 2;
      goto LABEL_22;
    }
    if ((_DWORD)a3 == 1380401751)
    {
      v11 = 20;
      v12 = 4;
      goto LABEL_22;
    }
LABEL_27:
    _CUILog(4, (uint64_t)"CoreUI: Unrecognized input pixel format: %d [%s]", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, a3);
    return 0;
  }
  if ((_DWORD)a3 == 1095911234)
  {
    v11 = 4;
    v12 = 1;
    goto LABEL_22;
  }
  if ((_DWORD)a3 != 1195454774)
    goto LABEL_27;
  v11 = 18;
  v12 = 6;
LABEL_22:
  *a4 = a3;
  *a5 = v12;
  *a6 = CGBitmapGetAlignedBytesPerRow(v9 * ((unint64_t)a1[1] >> 3));
  v13 = objc_alloc_init((Class)NSMutableArray);
  v16 = a2[1];
  v15 = a2[2];
  if (v16 * v15 < 0x100000)
  {
    v18 = *((_OWORD *)a2 + 1);
    v32 = *(_OWORD *)a2;
    v33 = v18;
    v19 = __CUIImageCompressedWithDeepmap2((uint64_t)&v32, v11, 0x100000000, 10);
    if (v19)
    {
      v26 = v19;
      objc_msgSend(v13, "addObject:", v19);
      CFRelease(v26);
      *a7 = a2[1];
      return v13;
    }
  }
  else
  {
    if (v15 <= 0x100000)
      v17 = 0x100000 / v15;
    else
      v17 = 1;
    if (!v16)
    {
LABEL_36:
      *a7 = v17;
      return v13;
    }
    v27 = *a2;
    while (1)
    {
      v28 = v16 >= v17 ? v17 : v16;
      *a2 = v27;
      a2[1] = v28;
      v29 = *((_OWORD *)a2 + 1);
      v32 = *(_OWORD *)a2;
      v33 = v29;
      v30 = __CUIImageCompressedWithDeepmap2((uint64_t)&v32, v11, 0x100000000, 10);
      if (!v30)
        break;
      v31 = v30;
      objc_msgSend(v13, "addObject:", v30);
      CFRelease(v31);
      v27 += a2[3] * v28;
      v16 -= v28;
      if (!v16)
        goto LABEL_36;
    }
  }
  _CUILog(4, (uint64_t)"CoreUI: Deepmap 2.0 compressed failed in %s [%s:%lu]", v20, v21, v22, v23, v24, v25, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap2(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");

  return 0;
}

uint64_t _CUIColorSpaceGetGenericRGB()
{
  if (_CUIColorSpaceGetGenericRGB___once != -1)
    dispatch_once(&_CUIColorSpaceGetGenericRGB___once, &__block_literal_global_1);
  return _CUIColorSpaceGetGenericRGB_sGenericRGBColorSpace;
}

uint64_t _CUIColorSpaceGetExtendedRangeSRGB()
{
  if (_CUIColorSpaceGetExtendedRangeSRGB___once != -1)
    dispatch_once(&_CUIColorSpaceGetExtendedRangeSRGB___once, &__block_literal_global_8);
  return _CUIColorSpaceGetExtendedRangeSRGB_sExtendedRangeSRGBColorSpace;
}

uint64_t _CUIColorSpaceGetExtendedGray()
{
  if (_CUIColorSpaceGetExtendedGray___once != -1)
    dispatch_once(&_CUIColorSpaceGetExtendedGray___once, &__block_literal_global_12);
  return _CUIColorSpaceGetExtendedGray_sExtendedGrayColorSpace;
}

uint64_t _CUIColorSpaceGetExtendedLinearSRGB()
{
  if (_CUIColorSpaceGetExtendedLinearSRGB___once != -1)
    dispatch_once(&_CUIColorSpaceGetExtendedLinearSRGB___once, &__block_literal_global_14);
  return _CUIColorSpaceGetExtendedLinearSRGB_sExtendedLinearSRGBColorSpace;
}

uint64_t _CUIColorGetSRGBClear()
{
  if (_CUIColorGetSRGBClear_onceToken != -1)
    dispatch_once(&_CUIColorGetSRGBClear_onceToken, &__block_literal_global_27);
  return _CUIColorGetSRGBClear_sClearColor;
}

const char *__SetBoolConfigFromEnvironment(BOOL *a1, char *a2)
{
  const char *result;
  const char *v4;
  BOOL v5;

  result = getenv(a2);
  if (result)
  {
    v4 = result;
    result = (const char *)strncasecmp(result, "NO", 2uLL);
    if ((_DWORD)result)
    {
      result = (const char *)strncasecmp(v4, "0", 1uLL);
      v5 = (_DWORD)result != 0;
      if (!a1)
        return result;
    }
    else
    {
      v5 = 0;
      if (!a1)
        return result;
    }
    *a1 = v5;
  }
  return result;
}

uint64_t __sliceSort(void *a1, void *a2)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  objc_msgSend(a1, "rectValue");
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  objc_msgSend(a2, "rectValue");
  v12 = v6 + v10;
  v15 = v13 + v14;
  v16 = v4 + v8;
  v18 = v11 + v17;
  v19 = -1;
  if (v6 < v13)
    v20 = 1;
  else
    v20 = -1;
  if (v16 > v18)
    v21 = 1;
  else
    v21 = -1;
  if (v16 != v18)
    v20 = v21;
  if (v4 >= v11)
    v22 = 1;
  else
    v22 = -1;
  if (v4 != v11)
    v20 = v22;
  if (v12 < v15)
    v19 = 1;
  if (v12 == v15)
    return v20;
  else
    return v19;
}

char *CUIConvertCompressionTypeToString(unsigned int a1)
{
  if (a1 > 0xC)
    return 0;
  else
    return off_1E41AB398[a1];
}

const char *CUIConvertPixelFormatToString(int a1)
{
  if (a1 > 1246774598)
  {
    if (a1 <= 1380401716)
    {
      if (a1 == 1246774599)
        return "JPEG";
      if (a1 == 1346651680)
        return "PDF";
    }
    else
    {
      switch(a1)
      {
        case 1380401717:
          return "RGB5";
        case 1398163232:
          return "SVG";
        case 1380401751:
          return "RGBW";
      }
    }
  }
  else if (a1 <= 1195454773)
  {
    if (a1 == 1095911234)
      return "ARGB";
    if (a1 == 1145132097)
      return "DATA";
  }
  else
  {
    switch(a1)
    {
      case 1195454774:
        return "GA16";
      case 1195456544:
        return "GA8";
      case 1212500294:
        return "HEIF";
    }
  }
  return "(Unknown)";
}

uint64_t CUILogLogToStderr(uint64_t result)
{
  __logToStderr = result;
  return result;
}

uint64_t CUILogHandle()
{
  if (__onceToken != -1)
    dispatch_once(&__onceToken, &__block_literal_global_3);
  return __handle;
}

uint64_t CUILogEnableRenditionLog(uint64_t result)
{
  __renditionLogginEnabled = result;
  return result;
}

BOOL CSIEqualMetrics(NSSize *a1, NSSize *a2)
{
  return NSEqualSizes(*a1, *a2) && NSEqualSizes(a1[1], a2[1]) && NSEqualSizes(a1[2], a2[2]);
}

void sub_19EBFA8DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class initMDLMaterial()
{
  Class result;

  __NSGetFrameworkReference();
  result = objc_getClass("MDLMaterial");
  classMDLMaterial = (uint64_t)result;
  if (!result)
    initMDLMaterial_cold_1();
  getMDLMaterialClass[0] = MDLMaterialFunction;
  return result;
}

void __NSGetFrameworkReference()
{
  id v0;
  const char *v1;
  const char *v2;
  const char *v3;
  uint64_t i;
  void *v5;
  void *v6;
  id v7;
  char __str[1024];
  _QWORD v9[3];

  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
  v0 = objc_msgSend((id)__NSGetFrameworkReference_table, "objectForKey:", CFSTR("ModelIO"));
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
  if (!v0)
  {
    memset(v9, 0, sizeof(v9));
    v1 = (const char *)objc_msgSend(CFSTR("ModelIO"), "UTF8String");
    if (v1)
    {
      v2 = v1;
      v3 = "/System/Library/Frameworks/";
      for (i = 1; ; ++i)
      {
        if (snprintf(__str, 0x400uLL, "%s%s.framework/%s", v3, v2, v2) <= 1023)
        {
          v5 = dlopen(__str, 2);
          if (v5)
            break;
        }
        v3 = (const char *)v9[i];
        if (!v3)
          return;
      }
      v6 = v5;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
      v7 = (id)__NSGetFrameworkReference_table;
      if (!__NSGetFrameworkReference_table)
      {
        v7 = objc_msgSend(objc_alloc((Class)NSMapTable), "initWithKeyOptions:valueOptions:capacity:", 0, 2, 0);
        __NSGetFrameworkReference_table = (uint64_t)v7;
      }
      if (!objc_msgSend(v7, "objectForKey:", CFSTR("ModelIO")))
        objc_msgSend((id)__NSGetFrameworkReference_table, "setObject:forKey:", v6, CFSTR("ModelIO"));
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
    }
  }
}

uint64_t MDLMaterialFunction()
{
  return classMDLMaterial;
}

Class initMDLTexture()
{
  Class result;

  __NSGetFrameworkReference();
  result = objc_getClass("MDLTexture");
  classMDLTexture = (uint64_t)result;
  if (!result)
    initMDLTexture_cold_1();
  getMDLTextureClass[0] = MDLTextureFunction;
  return result;
}

uint64_t MDLTextureFunction()
{
  return classMDLTexture;
}

Class initMDLTextureSampler()
{
  Class result;

  __NSGetFrameworkReference();
  result = objc_getClass("MDLTextureSampler");
  classMDLTextureSampler = (uint64_t)result;
  if (!result)
    initMDLTextureSampler_cold_1();
  getMDLTextureSamplerClass[0] = MDLTextureSamplerFunction;
  return result;
}

uint64_t MDLTextureSamplerFunction()
{
  return classMDLTextureSampler;
}

Class initMDLMaterialProperty()
{
  Class result;

  __NSGetFrameworkReference();
  result = objc_getClass("MDLMaterialProperty");
  classMDLMaterialProperty = (uint64_t)result;
  if (!result)
    initMDLMaterialProperty_cold_1();
  getMDLMaterialPropertyClass[0] = MDLMaterialPropertyFunction;
  return result;
}

uint64_t MDLMaterialPropertyFunction()
{
  return classMDLMaterialProperty;
}

Class initMDLSubmesh()
{
  Class result;

  __NSGetFrameworkReference();
  result = objc_getClass("MDLSubmesh");
  classMDLSubmesh = (uint64_t)result;
  if (!result)
    initMDLSubmesh_cold_1();
  getMDLSubmeshClass[0] = MDLSubmeshFunction;
  return result;
}

uint64_t MDLSubmeshFunction()
{
  return classMDLSubmesh;
}

__CFData *CUIImageCompressedWithATECompression(CGImageRef image, uint64_t a2, unint64_t a3, _DWORD *a4, _DWORD *a5, _WORD *a6)
{
  CGImageRef v10;
  size_t BitsPerComponent;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  CFStringRef *v14;
  CGColorSpace *v15;
  const __CFData *Mutable;
  at_block_format_t v17;
  CGColorSpace *v18;
  CGColorSpaceModel v19;
  CGImageAlphaInfo AlphaInfo;
  at_texel_format_t v21;
  __CFData *v22;
  at_block_format_t v23;
  CGColorSpace *v24;
  CGColorSpaceModel v25;
  CGImageAlphaInfo v26;
  at_texel_format_t v27;
  vImage_Error v28;
  size_t Length;
  uint8_t *v30;
  size_t v31;
  const uint8_t *BytePtr;
  size_t v33;
  size_t v34;
  __CFData *v35;
  const UInt8 *v36;
  CFIndex v37;
  at_alpha_t v38;
  const UInt8 *v39;
  uint32_t Width;
  uint32_t Height;
  NSObject *v42;
  __int128 v43;
  char v44;
  char v45;
  unint64_t v46;
  int v47;
  uint32_t x;
  uint64_t v49;
  uint64_t v50;
  size_t block_size;
  UInt8 *MutableBytePtr;
  size_t v53;
  float v54;
  vImage_Error v55;
  at_alpha_t v56;
  unsigned int v57;
  unsigned int v58;
  NSObject *v59;
  unint64_t block_dimensions;
  char v61;
  unint64_t v62;
  unint64_t v63;
  uint32_t v64;
  uint32_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  size_t v70;
  UInt8 *v71;
  size_t v72;
  uint32_t z;
  const __CFAllocator *v75;
  __CFData *theData;
  __CFData *theDataa;
  size_t v78;
  UInt8 bytes[8];
  int v80;
  at_block_buffer_t dest;
  at_texel_region_t src;
  UInt8 v83[4];
  char v84;
  char v85;
  char v86;
  __int16 v87;
  char v88;
  __int16 v89;
  char v90;
  _BYTE v91[3];
  vImage_Buffer buf;
  vImage_CGImageFormat format;
  at_size_t block_counts;
  at_size_t v95;
  at_size_t v96;

  v10 = image;
  v80 = 0;
  *(_QWORD *)bytes = 0;
  if (a5)
    *a5 = 1095911234;
  if (a6)
    *a6 = 1;
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent >= 9)
  {
    ColorSpace = CGImageGetColorSpace(v10);
    Model = CGColorSpaceGetModel(ColorSpace);
    v14 = (CFStringRef *)&kCGColorSpaceGenericGrayGamma2_2;
    if (Model)
      v14 = (CFStringRef *)&kCGColorSpaceDisplayP3;
    v15 = CGColorSpaceCreateWithName(*v14);
    v10 = CUIConvertDeepImageTo8(v10, v15);
    CFRelease(v15);
    if (a6)
      *a6 = 3;
    if (!v10)
      return 0;
  }
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (a3 <= 5 && ((1 << a3) & 0x3A) != 0)
  {
    *a4 = 7;
    memset(&format, 0, sizeof(format));
    if (a2 == 4)
      v17 = at_block_format_astc_4x4_ldr;
    else
      v17 = at_block_format_astc_8x8_ldr;
    v18 = CGImageGetColorSpace(v10);
    v19 = CGColorSpaceGetModel(v18);
    AlphaInfo = CGImageGetAlphaInfo(v10);
    if (CGImageGetBitsPerComponent(v10) < 9)
    {
      if (v19)
      {
        if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && ((1 << AlphaInfo) & 0x61) != 0)
        {
          *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
          format.colorSpace = CGImageGetColorSpace(v10);
          v21 = at_texel_format_rgba8_unorm;
          format.bitmapInfo = 5;
          *(_OWORD *)&format.version = 0uLL;
          CFRetain(format.colorSpace);
        }
        else
        {
          *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
          format.colorSpace = CGImageGetColorSpace(v10);
          format.bitmapInfo = 1;
          *(_OWORD *)&format.version = 0uLL;
          CFRetain(format.colorSpace);
          v21 = at_texel_format_rgba8_unorm;
        }
      }
      else if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && ((1 << AlphaInfo) & 0x61) != 0)
      {
        *(_QWORD *)&format.bitsPerComponent = 0x800000008;
        memset(&format.bitmapInfo, 0, 20);
        format.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
        v21 = at_texel_format_l8_unorm;
      }
      else
      {
        *(_QWORD *)&format.bitsPerComponent = *(_QWORD *)"\b";
        format.colorSpace = CGColorSpaceCreateDeviceGray();
        format.bitmapInfo = 1;
        *(_OWORD *)&format.version = 0uLL;
        v21 = at_texel_format_la8_unorm;
      }
    }
    else if (v19)
    {
      *(_QWORD *)&format.bitsPerComponent = 0x4000000010;
      format.colorSpace = 0;
      format.bitmapInfo = 4097;
      *(_OWORD *)&format.version = 0uLL;
      v21 = at_texel_format_rgba16_unorm;
    }
    else if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && ((1 << AlphaInfo) & 0x61) != 0)
    {
      *(_QWORD *)&format.bitsPerComponent = 0x1000000010;
      format.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      format.bitmapInfo = 4096;
      *(_OWORD *)&format.version = 0uLL;
      v21 = at_texel_format_l16_unorm;
    }
    else
    {
      *(_QWORD *)&format.bitsPerComponent = 0x2000000010;
      format.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      format.bitmapInfo = 4097;
      *(_OWORD *)&format.version = 0uLL;
      v21 = at_texel_format_la16_unorm;
    }
    memset(&buf, 0, sizeof(buf));
    *(_QWORD *)&src.validSize.z = 0;
    v28 = vImageBuffer_InitWithCGImage(&buf, &format, __ASTC_encodeToData_backgroundColor, v10, 0x100u);
    if (format.colorSpace)
      CFRelease(format.colorSpace);
    if (v28)
      goto LABEL_72;
    theData = Mutable;
    v78 = BitsPerComponent;
    v75 = kCFAllocatorDefault;
    if (AlphaInfo > kCGImageAlphaNoneSkipFirst)
      v38 = at_alpha_premultiplied;
    else
      v38 = dword_19EC721F0[AlphaInfo];
    Width = CGImageGetWidth(v10);
    Height = CGImageGetHeight(v10);
    v42 = at_encoder_create(v21, v38, v17, v38, 0);
    *(at_size_t *)&v43 = at_encoder_get_block_dimensions(v42);
    v44 = v43;
    v45 = BYTE8(v43);
    v46 = DWORD1(v43);
    *((_QWORD *)&v43 + 1) = Width | ((unint64_t)Height << 32);
    v47 = 1;
    block_counts = at_encoder_get_block_counts(v42, *(at_size_t *)((char *)&v43 + 8));
    x = block_counts.x;
    z = block_counts.z;
    *(_DWORD *)v83 = 1554098963;
    v49 = HIDWORD(*(_QWORD *)&block_counts.x);
    v84 = v44;
    v85 = v46;
    v86 = v45;
    v87 = Width;
    v88 = BYTE2(Width);
    v89 = Height;
    v90 = BYTE2(Height);
    *(_WORD *)v91 = 1;
    v91[2] = 0;
    Mutable = theData;
    CFDataAppendBytes(theData, v83, 16);
    v50 = v49 * x;
    block_size = at_encoder_get_block_size(v42);
    CFDataIncreaseLength(theData, block_size * v50 * z);
    MutableBytePtr = CFDataGetMutableBytePtr(theData);
    v53 = at_encoder_get_block_size(v42);
    src.texels = buf.data;
    src.validSize.x = Width;
    src.validSize.y = Height;
    src.validSize.z = 1;
    src.rowBytes = buf.rowBytes;
    src.sliceBytes = 0;
    dest.blocks = MutableBytePtr + 16;
    dest.rowBytes = v53 * x;
    dest.sliceBytes = v53 * v50;
    v54 = at_encoder_compress_texels(v42, &src, &dest, 0.0, at_flags_default);
    free(buf.data);

  }
  else
  {
    *a4 = 12;
    if (a2 == 4)
      v23 = at_block_format_bc7;
    else
      v23 = at_block_format_bc3;
    memset(&format, 0, sizeof(format));
    v24 = CGImageGetColorSpace(v10);
    v25 = CGColorSpaceGetModel(v24);
    v26 = CGImageGetAlphaInfo(v10);
    if (CGImageGetBitsPerComponent(v10) < 9)
    {
      if (v25)
      {
        if (v26 <= kCGImageAlphaNoneSkipFirst && ((1 << v26) & 0x61) != 0)
        {
          *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
          format.colorSpace = CGImageGetColorSpace(v10);
          v27 = at_texel_format_rgba8_unorm;
          format.bitmapInfo = 5;
          *(_OWORD *)&format.version = 0uLL;
          CFRetain(format.colorSpace);
        }
        else
        {
          *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
          format.colorSpace = CGImageGetColorSpace(v10);
          format.bitmapInfo = 1;
          *(_OWORD *)&format.version = 0uLL;
          CFRetain(format.colorSpace);
          v27 = at_texel_format_rgba8_unorm;
        }
      }
      else if (v26 <= kCGImageAlphaNoneSkipFirst && ((1 << v26) & 0x61) != 0)
      {
        *(_QWORD *)&format.bitsPerComponent = 0x800000008;
        memset(&format.bitmapInfo, 0, 20);
        format.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
        v27 = at_texel_format_l8_unorm;
      }
      else
      {
        *(_QWORD *)&format.bitsPerComponent = *(_QWORD *)"\b";
        format.colorSpace = CGColorSpaceCreateDeviceGray();
        format.bitmapInfo = 1;
        *(_OWORD *)&format.version = 0uLL;
        v27 = at_texel_format_la8_unorm;
      }
    }
    else if (v25)
    {
      *(_QWORD *)&format.bitsPerComponent = 0x4000000010;
      format.colorSpace = 0;
      format.bitmapInfo = 4097;
      *(_OWORD *)&format.version = 0uLL;
      v27 = at_texel_format_rgba16_unorm;
    }
    else if (v26 <= kCGImageAlphaNoneSkipFirst && ((1 << v26) & 0x61) != 0)
    {
      *(_QWORD *)&format.bitsPerComponent = 0x1000000010;
      format.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      format.bitmapInfo = 4096;
      *(_OWORD *)&format.version = 0uLL;
      v27 = at_texel_format_l16_unorm;
    }
    else
    {
      *(_QWORD *)&format.bitsPerComponent = 0x2000000010;
      format.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      format.bitmapInfo = 4097;
      *(_OWORD *)&format.version = 0uLL;
      v27 = at_texel_format_la16_unorm;
    }
    memset(&buf, 0, sizeof(buf));
    *(_QWORD *)&src.validSize.z = 0;
    v55 = vImageBuffer_InitWithCGImage(&buf, &format, __ATE_encodeToData_backgroundColor, v10, 0x100u);
    if (format.colorSpace)
      CFRelease(format.colorSpace);
    if (v55)
      goto LABEL_72;
    theDataa = Mutable;
    v78 = BitsPerComponent;
    v75 = kCFAllocatorDefault;
    if (v26 > kCGImageAlphaNoneSkipFirst)
      v56 = at_alpha_premultiplied;
    else
      v56 = dword_19EC721F0[v26];
    v57 = CGImageGetWidth(v10);
    v58 = CGImageGetHeight(v10);
    v59 = at_encoder_create(v27, v56, v23, v56, 0);
    block_dimensions = (unint64_t)at_encoder_get_block_dimensions(v59);
    v61 = block_dimensions;
    v62 = HIDWORD(block_dimensions);
    v63 = v57 | ((unint64_t)v58 << 32);
    *(_QWORD *)&v96.x = v63;
    v96.z = 1;
    v95 = at_encoder_get_block_counts(v59, v96);
    v64 = v95.x;
    v65 = v95.z;
    *(_DWORD *)v83 = 1128617025;
    v66 = v23;
    v67 = HIDWORD(*(_QWORD *)&v95.x);
    v84 = v61;
    v85 = v62;
    v86 = 0;
    v87 = v57;
    v88 = BYTE2(v57);
    v89 = v58;
    v90 = BYTE2(v58);
    v91[0] = v66;
    *(_WORD *)&v91[1] = 0;
    CFDataAppendBytes(theDataa, v83, 16);
    v68 = v67 * v64;
    v69 = v68 * v65;
    Mutable = theDataa;
    v70 = at_encoder_get_block_size(v59);
    CFDataIncreaseLength(theDataa, v70 * v69);
    v71 = CFDataGetMutableBytePtr(theDataa);
    v72 = at_encoder_get_block_size(v59);
    src.texels = buf.data;
    *(_QWORD *)&src.validSize.x = v63;
    src.validSize.z = 1;
    src.rowBytes = buf.rowBytes;
    src.sliceBytes = 0;
    dest.blocks = v71 + 16;
    dest.rowBytes = v72 * v64;
    dest.sliceBytes = v72 * v68;
    v54 = at_encoder_compress_texels(v59, &src, &dest, 0.0, at_flags_print_debug_info);
    free(buf.data);

  }
  BitsPerComponent = v78;
  if (v54 >= 0.0)
  {
    Length = CFDataGetLength(Mutable);
    v30 = (uint8_t *)malloc_type_malloc(Length, 0x7BD4EDA8uLL);
    v31 = CFDataGetLength(Mutable);
    BytePtr = CFDataGetBytePtr(Mutable);
    v33 = CFDataGetLength(Mutable);
    v34 = compression_encode_buffer(v30, v31, BytePtr, v33, 0, COMPRESSION_LZFSE);
    __CFSetLastAllocationEventName(v30, "CUIImageCompressedWithATECompression");
    v22 = CFDataCreateMutable(v75, 0);
    if (v34)
    {
      *(_DWORD *)bytes = 1;
      *(_DWORD *)&bytes[4] = v34;
      v80 = CFDataGetLength(Mutable);
      CFDataAppendBytes(v22, bytes, 12);
      v35 = v22;
      v36 = v30;
      v37 = v34;
    }
    else
    {
      *(_DWORD *)bytes = 0;
      v80 = CFDataGetLength(Mutable);
      *(_DWORD *)&bytes[4] = CFDataGetLength(Mutable);
      CFDataAppendBytes(v22, bytes, 12);
      v39 = CFDataGetBytePtr(Mutable);
      v37 = CFDataGetLength(Mutable);
      v35 = v22;
      v36 = v39;
    }
    CFDataAppendBytes(v35, v36, v37);
    free(v30);
    goto LABEL_73;
  }
LABEL_72:
  v22 = 0;
LABEL_73:
  CFRelease(Mutable);
  if (BitsPerComponent >= 9)
    CFRelease(v10);
  return v22;
}

BOOL CUIExpandATECompressedDataIntoBuffer(uint64_t a1, int a2, void *a3, uint64_t a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  malloc_zone_t *v13;
  uint8_t *v14;
  uint8_t *v15;
  malloc_zone_t *v16;
  at_texel_format_t v17;
  unsigned __int16 v18;
  int v19;
  at_block_format_t v20;
  int v21;
  uint8_t *v23;
  int v24;
  int v25;
  uint8_t *v26;
  int v27;
  at_alpha_t v28;
  at_alpha_t v29;
  NSObject *v30;
  unint64_t block_counts;
  unint64_t v32;
  unsigned int v33;
  size_t v34;
  size_t block_size;
  void *v36;
  at_error_t v37;
  at_texel_region_t dest;
  at_block_buffer_t src;
  at_size_t v40;

  v9 = a4;
  if (*(_DWORD *)a1)
  {
    v13 = malloc_default_zone();
    v14 = (uint8_t *)malloc_type_zone_memalign(v13, 0x40uLL, *(unsigned int *)(a1 + 8), 0x699A31C1uLL);
    __CFSetLastAllocationEventName(v14, "CUIExpandATECompressedDataIntoBuffer");
    if (!compression_decode_buffer(v14, *(unsigned int *)(a1 + 8), (const uint8_t *)(a1 + 12), *(unsigned int *)(a1 + 4), 0, COMPRESSION_LZFSE))goto LABEL_37;
    goto LABEL_6;
  }
  v15 = (uint8_t *)(a1 + 12);
  if (((a1 + 12) & 0x3F) != 0)
  {
    v16 = malloc_default_zone();
    v14 = (uint8_t *)malloc_type_zone_memalign(v16, 0x40uLL, *(unsigned int *)(a1 + 8), 0x86B7A138uLL);
    __CFSetLastAllocationEventName(v14, "CUIExpandATECompressedDataIntoBuffer");
    memcpy(v14, (const void *)(a1 + 12), *(unsigned int *)(a1 + 8));
LABEL_6:
    v15 = v14;
    goto LABEL_7;
  }
  v14 = 0;
LABEL_7:
  v17 = at_texel_format_bgra8_unorm;
  if (v9 > 1195456543)
  {
    if (v9 == 1380401751)
      goto LABEL_16;
    v18 = 14368;
  }
  else
  {
    if (v9 == 1095911234)
      goto LABEL_16;
    v18 = 12598;
  }
  if (v9 != (v18 | 0x47410000))
  {
    _CUILog(4, (uint64_t)"CoreUI: %s got a pixelFormat that it doesn't understand", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"_Bool CUIExpandATECompressedDataIntoBuffer(const u_int8_t *, _Bool, u_int8_t *, enum CSIPixelFormat, size_t)");
    if (!v14)
      return 0;
    goto LABEL_37;
  }
  if (a2)
    v17 = at_texel_format_l8_unorm;
  else
    v17 = at_texel_format_la8_unorm;
LABEL_16:
  memset(&src, 0, sizeof(src));
  *(_QWORD *)&dest.validSize.z = 0;
  v19 = *v15;
  if (v19 == 19)
  {
    if (v15[1] != 171 || v15[2] != 161 || v15[3] != 92)
      goto LABEL_36;
    v20 = at_block_format_invalid;
    v21 = (16 * (v15[4] & 0xF)) | v15[5];
    if (v21 > 135)
    {
      if (v21 > 201)
      {
        if (v21 == 202)
        {
          v20 = at_block_format_astc_12x10_ldr;
        }
        else if (v21 == 204)
        {
          v20 = at_block_format_astc_12x12_ldr;
        }
      }
      else
      {
        switch(v21)
        {
          case 165:
            v20 = at_block_format_astc_10x5_ldr;
            break;
          case 166:
            v20 = at_block_format_astc_10x6_ldr;
            break;
          case 167:
          case 169:
            break;
          case 168:
            v20 = at_block_format_astc_10x8_ldr;
            break;
          case 170:
            v20 = at_block_format_astc_10x10_ldr;
            break;
          default:
            if (v21 == 136)
              v20 = at_block_format_astc_8x8_ldr;
            break;
        }
      }
    }
    else if (v21 <= 100)
    {
      switch(v21)
      {
        case 'D':
          v20 = at_block_format_astc_4x4_ldr;
          break;
        case 'T':
          v20 = at_block_format_astc_5x4_ldr;
          break;
        case 'U':
          v20 = at_block_format_astc_5x5_ldr;
          break;
      }
    }
    else if (v21 > 132)
    {
      if (v21 == 133)
      {
        v20 = at_block_format_astc_8x5_ldr;
      }
      else if (v21 == 134)
      {
        v20 = at_block_format_astc_8x6_ldr;
      }
    }
    else if (v21 == 101)
    {
      v20 = at_block_format_astc_6x5_ldr;
    }
    else if (v21 == 102)
    {
      v20 = at_block_format_astc_6x6_ldr;
    }
    v26 = 0;
    v24 = *(unsigned __int16 *)(v15 + 7) | (v15[9] << 16);
    v25 = *((unsigned __int16 *)v15 + 5);
    v23 = v15;
  }
  else
  {
    if (v19 != 65 || v15[1] != 84 || v15[2] != 69 || v15[3] != 67 || v15[6])
    {
LABEL_36:
      _CUILog(4, (uint64_t)"CoreUI: %s got data that is not ASTC or DXTC encoded %c%c%c%c", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"_Bool CUIExpandATECompressedDataIntoBuffer(const u_int8_t *, _Bool, u_int8_t *, enum CSIPixelFormat, size_t)");
LABEL_37:
      free(v14);
      return 0;
    }
    v23 = 0;
    v20 = *(unsigned __int16 *)(v15 + 13) | ((unint64_t)v15[15] << 16);
    v24 = *(unsigned __int16 *)(v15 + 7) | (v15[9] << 16);
    v25 = *((unsigned __int16 *)v15 + 5);
    v26 = v15;
  }
  v27 = v25 | (v15[12] << 16);
  if (a2)
  {
    v28 = at_alpha_not_premultiplied;
    v29 = at_alpha_not_premultiplied;
  }
  else
  {
    v28 = at_alpha_premultiplied;
    v29 = at_alpha_premultiplied;
  }
  v30 = at_encoder_create(v17, v28, v20, v29, 0);
  dest.texels = a3;
  *(_QWORD *)&dest.validSize.x = __PAIR64__(v27, v24);
  dest.validSize.z = 1;
  dest.rowBytes = a5;
  dest.sliceBytes = 0;
  *(_QWORD *)&v40.x = __PAIR64__(v27, v24);
  v40.z = 1;
  block_counts = (unint64_t)at_encoder_get_block_counts(v30, v40);
  v32 = HIDWORD(block_counts);
  v33 = block_counts;
  v34 = at_encoder_get_block_size(v30) * block_counts;
  block_size = at_encoder_get_block_size(v30);
  v36 = v26 + 16;
  if (v23)
    v36 = v23 + 16;
  src.blocks = v36;
  src.rowBytes = v34;
  src.sliceBytes = v32 * (unint64_t)v33 * block_size;
  v37 = at_encoder_decompress_texels(v30, &src, &dest, at_flags_default);
  if (v14)
    free(v14);

  return v37 >= at_error_success;
}

void CUIUpdateImageProviderForATECompressedData(int a1, _DWORD *a2, int *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  if (a1 <= 1195456543)
  {
    if (a1 != 1095911234)
    {
      if (a1 != 1195454774)
        goto LABEL_10;
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (a1 == 1195456544)
  {
LABEL_8:
    *a2 = 8;
    v8 = 2;
    goto LABEL_9;
  }
  if (a1 == 1380401751)
  {
LABEL_7:
    *a2 = 8;
    v8 = 4;
LABEL_9:
    *a3 = v8;
    *a4 = 1;
    return;
  }
LABEL_10:
  _CUILog(4, (uint64_t)"CoreUI: %s got a pixelFormat that it doesn't understand", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"void CUIUpdateImageProviderForATECompressedData(enum CSIPixelFormat, u_int32_t *, u_int32_t *, CGImageComponentType *)");
}

void CUIUpdatePixelFormatForATECompressedData(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;

  v8 = *a1;
  if (*a1 <= 1195456543)
  {
    if (v8 != 1095911234)
    {
      if (v8 != 1195454774)
        goto LABEL_10;
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (v8 == 1195456544)
  {
LABEL_8:
    v9 = 1195456544;
    goto LABEL_9;
  }
  if (v8 == 1380401751)
  {
LABEL_7:
    v9 = 1095911234;
LABEL_9:
    *a1 = v9;
    return;
  }
LABEL_10:
  _CUILog(4, (uint64_t)"CoreUI: %s got a pixelFormat that it doesn't understand", a3, a4, a5, a6, a7, a8, (uint64_t)"void CUIUpdatePixelFormatForATECompressedData(enum CSIPixelFormat *)");
}

_CUISubrangeData *CUIATECompressedDataFromBuffer(uint64_t a1, int a2, int *a3, int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, CFBooleanRef *a8)
{
  int *v13;
  id v15;
  void *v16;
  malloc_zone_t *v17;
  unsigned __int8 *v18;
  size_t v19;
  size_t v20;
  NSData *v21;
  int v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BOOL8 v32;
  malloc_zone_t *v33;
  void *v34;
  void *v35;
  unsigned int v36;
  size_t v37;
  malloc_zone_t *v38;
  size_t v39;
  unsigned __int8 *v40;
  MTLTextureDescriptor *v41;
  id v42;
  void *v43;
  uint64_t v44;
  unsigned __int8 v45;
  compression_status v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  compression_status v53;
  id v54;
  malloc_zone_t *v55;
  malloc_zone_t *v56;
  uint64_t v57;
  uint64_t v58;
  malloc_zone_t *v60;
  id v61;
  void *v62;
  MTLTextureDescriptor *v63;
  id v64;
  id v65;
  malloc_zone_t *v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int *v71;
  int *v72;
  unsigned int *v73;
  CFBooleanRef *v74;
  id v75;
  void *v76;
  uint64_t v77;
  unsigned int *v78;
  _QWORD v79[6];
  compression_stream stream;
  _QWORD v81[7];

  v13 = a3;
  if (!*(_DWORD *)a1)
  {
    v24 = a1 + 12;
    v23 = *(unsigned __int8 *)(a1 + 12);
    if (v23 == 19)
    {
      if (*(unsigned __int8 *)(a1 + 13) != 171 || *(unsigned __int8 *)(a1 + 14) != 161 || *(_BYTE *)(a1 + 15) != 92)
        goto LABEL_49;
      *a5 = *(unsigned __int16 *)(a1 + 19) | (*(unsigned __int8 *)(a1 + 21) << 16);
      *a6 = *(unsigned __int16 *)(a1 + 22) | (*(unsigned __int8 *)(a1 + 24) << 16);
      __ASTCBlockFormatToGLInternalFormat(*(unsigned __int8 *)(a1 + 16), *(_BYTE *)(a1 + 17), a3, a4);
      *a7 = 16 * ((*a5 + *(unsigned __int8 *)(a1 + 16) - 1) / *(unsigned __int8 *)(a1 + 16));
      *a8 = kCFBooleanFalse;
      v32 = (v24 & 0x3F) != 0;
      if ((v24 & 0x3F) != 0)
      {
        v33 = malloc_default_zone();
        v34 = malloc_type_zone_memalign(v33, 0x40uLL, *(unsigned int *)(a1 + 8), 0x199EF338uLL);
        __CFSetLastAllocationEventName(v34, "CUIATECompressedDataFromBuffer");
        memcpy(v34, (const void *)(a1 + 28), *(unsigned int *)(a1 + 8) - 16);
        v35 = v34;
      }
      else
      {
        v35 = 0;
        v34 = (void *)(a1 + 268);
      }
      v61 = MTLCreateSystemDefaultDevice();
      if (v61)
      {
        v62 = v61;
        v63 = +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:](MTLTextureDescriptor, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", *a4, *a5, *a6, 0);
        -[MTLTextureDescriptor setMipmapLevelCount:](v63, "setMipmapLevelCount:", 1);
        v64 = objc_msgSend(v62, "newTextureLayoutWithDescriptor:isHeapOrBufferBacked:", v63, 0);
        v65 = objc_msgSend(v64, "size");
        v66 = malloc_default_zone();
        v67 = malloc_type_zone_memalign(v66, (size_t)objc_msgSend(v64, "alignment"), (size_t)v65, 0x2C273B7BuLL);
        __CFSetLastAllocationEventName(v67, "CUIATECompressedDataFromBuffer");
        if ((objc_opt_respondsToSelector(v64, sel_initializeTextureMemory_) & 1) != 0)
          objc_msgSend(v64, "initializeTextureMemory:", v67);
        v68 = *a7;
        v69 = *a5;
        v70 = *a6;
        memset(v81, 0, 24);
        v81[3] = v69;
        v81[4] = v70;
        v81[5] = 1;
        objc_msgSend(v64, "copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:", v34, 0, v68, 0, v67, 0, 0, v81);
        objc_msgSend(v64, "finalizeTextureMemory:", v67);
        *a8 = kCFBooleanTrue;
        if (v35)
          free(v35);

        return (_CUISubrangeData *)+[NSData dataWithBytesNoCopy:length:freeWhenDone:](NSData, "dataWithBytesNoCopy:length:freeWhenDone:", v67, v65, 1);
      }
    }
    else
    {
      if (v23 != 65
        || *(_BYTE *)(a1 + 13) != 84
        || *(_BYTE *)(a1 + 14) != 69
        || *(_BYTE *)(a1 + 15) != 67
        || *(_BYTE *)(a1 + 18))
      {
        goto LABEL_49;
      }
      LODWORD(stream.dst_ptr) = 0;
      *a5 = *(unsigned __int16 *)(a1 + 19) | (*(unsigned __int8 *)(a1 + 21) << 16);
      *a6 = *(unsigned __int16 *)(a1 + 22) | (*(unsigned __int8 *)(a1 + 24) << 16);
      __ATEBlockFormatToGLInternalFormat((at_block_format_t)(*(unsigned __int16 *)(a1 + 25) | ((unint64_t)*(unsigned __int8 *)(a1 + 27) << 16)), a4, a3, &stream, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
      *a7 = LODWORD(stream.dst_ptr) * ((*a5 + *(unsigned __int8 *)(a1 + 16) - 1) / *(unsigned __int8 *)(a1 + 16));
      *a8 = kCFBooleanFalse;
      v32 = (v24 & 0x3F) != 0;
      if ((v24 & 0x3F) != 0)
      {
        v60 = malloc_default_zone();
        v34 = malloc_type_zone_memalign(v60, 0x40uLL, *(unsigned int *)(a1 + 8), 0x1A426AA6uLL);
        __CFSetLastAllocationEventName(v34, "CUIATECompressedDataFromBuffer");
        memcpy(v34, (const void *)(a1 + 28), *(unsigned int *)(a1 + 8) - 16);
      }
      else
      {
        v34 = (void *)(a1 + 268);
      }
    }
    return (_CUISubrangeData *)objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:freeWhenDone:", v34, *(unsigned int *)(a1 + 8) - 16, v32);
  }
  if (a2 != 7 || (memset(&stream, 0, sizeof(stream)), (v15 = MTLCreateSystemDefaultDevice()) == 0))
  {
LABEL_6:
    v17 = malloc_default_zone();
    v18 = (unsigned __int8 *)malloc_type_zone_memalign(v17, 0x40uLL, *(unsigned int *)(a1 + 8), 0xF9378EAEuLL);
    __CFSetLastAllocationEventName(v18, "CUIATECompressedDataFromBuffer");
    v19 = compression_decode_buffer(v18, *(unsigned int *)(a1 + 8), (const uint8_t *)(a1 + 12), *(unsigned int *)(a1 + 4), 0, COMPRESSION_LZFSE);
    if (!v19)
    {
      free(v18);
      _CUILog(4, (uint64_t)"CoreUI: %s couldn't uncompress ASTC buffer %zu %u %u", v25, v26, v27, v28, v29, v30, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
      return 0;
    }
    v20 = v19;
    v21 = +[NSData dataWithBytesNoCopy:length:freeWhenDone:](NSData, "dataWithBytesNoCopy:length:freeWhenDone:", v18, v19, 1);
    v22 = *v18;
    if (v22 == 19)
    {
      if (v18[1] != 171 || v18[2] != 161 || v18[3] != 92)
        goto LABEL_49;
      *a5 = *(unsigned __int16 *)(v18 + 7) | (v18[9] << 16);
      *a6 = *((unsigned __int16 *)v18 + 5) | (v18[12] << 16);
      __ASTCBlockFormatToGLInternalFormat(v18[4], v18[5], v13, a4);
      v36 = 16 * ((*a5 + v18[4] - 1) / v18[4]);
    }
    else
    {
      if (v22 != 65 || v18[1] != 84 || v18[2] != 69 || v18[3] != 67 || v18[6])
      {
LABEL_49:
        _CUILog(4, (uint64_t)"CoreUI: %s got an invalid Compressed Texture Header %c%c%c%c", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
        return 0;
      }
      LODWORD(stream.dst_ptr) = 0;
      *a5 = *(unsigned __int16 *)(v18 + 7) | (v18[9] << 16);
      *a6 = *((unsigned __int16 *)v18 + 5) | (v18[12] << 16);
      __ATEBlockFormatToGLInternalFormat((at_block_format_t)(*(unsigned __int16 *)(v18 + 13) | ((unint64_t)v18[15] << 16)), a4, v13, &stream, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
      v36 = LODWORD(stream.dst_ptr) * ((*a5 + v18[4] - 1) / v18[4]);
    }
    *a7 = v36;
    *a8 = kCFBooleanFalse;
    return -[_CUISubrangeData initWithData:range:]([_CUISubrangeData alloc], "initWithData:range:", v21, 16, v20 - 16);
  }
  v16 = v15;
  if (compression_stream_init(&stream, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE))
  {

    goto LABEL_6;
  }
  v76 = v16;
  v72 = a4;
  v73 = a6;
  v78 = a7;
  v74 = a8;
  v37 = *(unsigned int *)(a1 + 4);
  stream.src_ptr = (const uint8_t *)(a1 + 12);
  stream.src_size = v37;
  v38 = malloc_default_zone();
  v39 = 16;
  v40 = (unsigned __int8 *)malloc_type_zone_memalign(v38, 0x40uLL, 0x10uLL, 0xC928110FuLL);
  __CFSetLastAllocationEventName(v40, "CUIATECompressedDataFromBuffer");
  v41 = 0;
  v42 = 0;
  v75 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v71 = v13;
  while (1)
  {
    stream.dst_ptr = v40;
    stream.dst_size = v39;
    v46 = compression_stream_process(&stream, 0);
    if (v46 == COMPRESSION_STATUS_ERROR)
    {
      free(v40);

      compression_stream_destroy(&stream);
      return 0;
    }
    v53 = v46;
    if (v41 || (uint8_t *)(stream.dst_ptr - v40) != (uint8_t *)16)
    {
      if (!v45)
        CUIATECompressedDataFromBuffer_cold_1();
      v57 = *v78;
      v58 = *a5;
      v79[0] = 0;
      v79[1] = v44;
      v79[2] = 0;
      v79[3] = v58;
      v79[4] = v45;
      v79[5] = 1;
      objc_msgSend(v42, "copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:", v40, 0, v57, 0, v43, 0, 0, v79);
      v44 += v45;
      goto LABEL_47;
    }
    if (*v40 != 19 || v40[1] != 171 || v40[2] != 161 || v40[3] != 92)
    {
      _CUILog(4, (uint64_t)"CoreUI: %s got an invalid ASTC Header %c%c%c%c", v47, v48, v49, v50, v51, v52, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
      goto LABEL_53;
    }
    v45 = v40[5];
    if (!v45)
      break;
    v77 = v44;
    *a5 = *(unsigned __int16 *)(v40 + 7) | (v40[9] << 16);
    *v73 = *((unsigned __int16 *)v40 + 5) | (v40[12] << 16);
    __ASTCBlockFormatToGLInternalFormat(v40[4], v45, v13, v72);
    *v78 = 16 * ((*a5 + v40[4] - 1) / v40[4]);
    *v74 = kCFBooleanTrue;
    v41 = +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:](MTLTextureDescriptor, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", *v72, *a5, *v73, 0);
    -[MTLTextureDescriptor setMipmapLevelCount:](v41, "setMipmapLevelCount:", 1);
    v42 = objc_msgSend(v76, "newTextureLayoutWithDescriptor:isHeapOrBufferBacked:", v41, 0);
    v54 = objc_msgSend(v42, "size");
    v55 = malloc_default_zone();
    v75 = v54;
    v43 = malloc_type_zone_memalign(v55, (size_t)objc_msgSend(v42, "alignment"), (size_t)v54, 0x8486CB5uLL);
    __CFSetLastAllocationEventName(v43, "CUIATECompressedDataFromBuffer");
    v39 = *v78;
    free(v40);
    v56 = malloc_default_zone();
    v40 = (unsigned __int8 *)malloc_type_zone_memalign(v56, 0x40uLL, v39, 0xBD5A217FuLL);
    __CFSetLastAllocationEventName(v40, "CUIATECompressedDataFromBuffer");
    if ((objc_opt_respondsToSelector(v42, sel_initializeTextureMemory_) & 1) != 0)
      objc_msgSend(v42, "initializeTextureMemory:", v43);
    v13 = v71;
    v44 = v77;
LABEL_47:
    if (v53 == COMPRESSION_STATUS_END)
    {
      objc_msgSend(v42, "finalizeTextureMemory:", v43);
      free(v40);
      compression_stream_destroy(&stream);

      return (_CUISubrangeData *)objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:freeWhenDone:", v43, v75, 1);
    }
  }
  _CUILog(4, (uint64_t)"CoreUI: %s got an invalid ASTC Header (astcHeader->blockdim_y == 0) ", v47, v48, v49, v50, v51, v52, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
LABEL_53:

  return 0;
}

uint64_t __ASTCBlockFormatToGLInternalFormat(uint64_t result, unsigned __int8 a2, int *a3, int *a4)
{
  unsigned int v4;
  int v5;
  int v6;

  v4 = (a2 | (16 * result));
  if (v4 > 0x87)
  {
    if ((a2 | (16 * result)) > 0xC9u)
    {
      if (v4 == 202)
      {
        v5 = 217;
        v6 = 37820;
      }
      else
      {
        if (v4 != 204)
          return result;
        v5 = 218;
        v6 = 37821;
      }
    }
    else
    {
      switch(a2 | (16 * result))
      {
        case 165:
          v5 = 213;
          v6 = 37816;
          break;
        case 166:
          v5 = 214;
          v6 = 37817;
          break;
        case 167:
        case 169:
          return result;
        case 168:
          v5 = 215;
          v6 = 37818;
          break;
        case 170:
          v5 = 216;
          v6 = 37819;
          break;
        default:
          if (v4 != 136)
            return result;
          v5 = 212;
          v6 = 37815;
          break;
      }
    }
  }
  else if ((a2 | (16 * result)) <= 0x64u)
  {
    switch(v4)
    {
      case 'D':
        v5 = 204;
        v6 = 37808;
        break;
      case 'T':
        v5 = 205;
        v6 = 37809;
        break;
      case 'U':
        v5 = 206;
        v6 = 37810;
        break;
      default:
        return result;
    }
  }
  else if ((a2 | (16 * result)) > 0x84u)
  {
    if (v4 == 133)
    {
      v5 = 210;
      v6 = 37813;
    }
    else
    {
      if (v4 != 134)
        return result;
      v5 = 211;
      v6 = 37814;
    }
  }
  else if (v4 == 101)
  {
    v5 = 207;
    v6 = 37811;
  }
  else
  {
    if (v4 != 102)
      return result;
    v5 = 208;
    v6 = 37812;
  }
  *a3 = v6;
  *a4 = v5;
  return result;
}

uint64_t __ATEBlockFormatToGLInternalFormat(at_block_format_t blockFormat, _DWORD *a2, int *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;

  switch(blockFormat)
  {
    case at_block_format_bc1:
      *a3 = 33777;
      *a4 = 8;
      break;
    case at_block_format_bc2:
      *a4 = 16;
      v10 = 33778;
      goto LABEL_13;
    case at_block_format_bc3:
      *a4 = 16;
      v10 = 33779;
      goto LABEL_13;
    case at_block_format_bc4:
      *a4 = 16;
      v10 = 36283;
      goto LABEL_13;
    case at_block_format_bc4s:
      *a4 = 2;
      v10 = 36284;
      goto LABEL_13;
    case at_block_format_bc5:
      *a4 = 2;
      v10 = 36285;
      goto LABEL_13;
    case at_block_format_bc5s:
      *a4 = 2;
      v10 = 36286;
      goto LABEL_13;
    case at_block_format_bc6:
      *a4 = 16;
      v10 = 36494;
      goto LABEL_13;
    case at_block_format_bc6u:
      *a4 = 16;
      v10 = 36495;
      goto LABEL_13;
    case at_block_format_bc7:
      *a4 = 16;
      v10 = 36492;
LABEL_13:
      *a3 = v10;
      break;
    default:
      _CUILog(4, (uint64_t)"CoreUI: %s got a blockFormat doesn't understand", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"void __ATEBlockFormatToGLInternalFormat(at_block_format_t, uint32_t *, uint32_t *, uint32_t *)");
      break;
  }
  result = at_block_format_to_MTLPixelFormat(blockFormat);
  *a2 = result;
  return result;
}

uint64_t __CUISubtypeFromIndex(unint64_t a1, unsigned int a2)
{
  uint64_t result;
  signed int v4;
  unsigned int *v5;

  if (a1 == -1)
  {
    if (a2 >= 0x20)
      return 0xFFFFFFFFLL;
    else
      return dword_19EC722B4[a2];
  }
  else if (a2)
  {
    switch(a1)
    {
      case 0uLL:
        result = 1864;
        switch(a2)
        {
          case 0x1Au:
            return 1964;
          case 0x1Bu:
            return 2234;
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
            goto LABEL_25;
          case 0x1Fu:
            return 1665;
          case 0x20u:
            return result;
          default:
            if (a2 != 1)
              goto LABEL_25;
            return result;
        }
      case 3uLL:
        v4 = a2 - 5;
        if (a2 - 5 >= 3)
          goto LABEL_25;
        v5 = (unsigned int *)&unk_19EC72334;
        goto LABEL_16;
      case 4uLL:
        switch(a2)
        {
          case 0x17u:
            return 430;
          case 0x18u:
            return 484;
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
            goto LABEL_25;
          case 0x1Cu:
            return 502;
          case 0x1Du:
            return 446;
          case 0x1Eu:
            return 496;
          default:
            result = 320;
            switch(a2)
            {
              case 8u:
                return result;
              case 9u:
                return 384;
              case 0xDu:
                return 340;
              case 0xEu:
                return 390;
              default:
                goto LABEL_25;
            }
        }
      case 5uLL:
        if (a2 != 1)
          goto LABEL_25;
        return 3648;
      default:
        if (a1 > 2 || a2 >= 0x1F || (v4 = a2 - 1, ((0x313FFEFFu >> (a2 - 1)) & 1) == 0))
LABEL_25:
          __CUISubtypeFromIndex_cold_1(a1);
        v5 = (unsigned int *)&unk_19EC72340;
LABEL_16:
        result = v5[v4];
        break;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t CUIParseDeploymentTarget(char *a1, int a2)
{
  const char *v4;
  int *v5;
  id v6;
  id v7;
  id v8;
  id v9;
  unsigned int v10;
  signed int v11;
  uint64_t result;
  uint64_t v13;
  BOOL v14;
  unsigned int v15;

  v4 = "any";
  if ("any")
  {
    v5 = &gThemeDeploymentTargets;
    while (strcasecmp(a1, v4))
    {
      v4 = (const char *)*((_QWORD *)v5 + 5);
      v5 += 6;
      if (!v4)
        goto LABEL_5;
    }
    return *v5;
  }
  else
  {
LABEL_5:
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a1);
    v7 = objc_msgSend(v6, "componentsSeparatedByString:", CFSTR("."));
    v8 = objc_msgSend(v7, "count");
    if (v8)
    {
      v9 = v8;
      v10 = objc_msgSend(objc_msgSend(v7, "objectAtIndexedSubscript:", 0), "intValue");
      if (v9 == (id)1)
        v11 = 0;
      else
        v11 = objc_msgSend(objc_msgSend(v7, "objectAtIndexedSubscript:", 1), "intValue");
    }
    else
    {
      v11 = 0;
      v10 = 0x7FFFFFFF;
    }

    if (a2 <= 1)
      v13 = 1;
    else
      v13 = a2;
    switch(v13)
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 7:
        if ((int)v10 < 10)
          goto LABEL_53;
        if (v10 == 10)
          return 1;
        if (v10 < 0xC)
          return 2;
        if (v10 == 12)
          goto LABEL_35;
        if (v10 < 0xE)
          return 5;
        if (v10 == 14)
          return 6;
        if (v10 < 0x10)
          return 7;
        if (v10 == 16)
          return 8;
        if (v10 <= 0x11)
          goto LABEL_50;
        if (v10 == 18)
          goto LABEL_40;
        goto LABEL_52;
      case 5:
        if ((int)v10 < 3)
          goto LABEL_53;
        if (v10 == 3)
          return 1;
        if (v10 < 5)
          return 2;
        if (v10 == 5)
        {
LABEL_35:
          v14 = v11 < 2;
          v15 = 3;
          goto LABEL_36;
        }
        if (v10 < 7)
          return 5;
        if (v10 == 7)
          return 6;
        if (v10 < 9)
          return 7;
        if (v10 == 9)
          return 8;
        if (v10 <= 0xA)
        {
LABEL_50:
          v14 = v11 < 4;
          goto LABEL_33;
        }
        if (v10 == 11)
          goto LABEL_40;
        goto LABEL_52;
      case 8:
        if ((int)v10 > 1)
        {
          if (v10 == 2)
          {
LABEL_40:
            result = 11;
          }
          else
          {
LABEL_52:
            fprintf(__stderrp, "assuming --deployment-target %s == --deployment-target any\n", a1);
LABEL_53:
            result = 0;
          }
        }
        else
        {
          v14 = v11 < 1;
LABEL_33:
          v15 = 9;
LABEL_36:
          if (v14)
            result = v15;
          else
            result = v15 + 1;
        }
        break;
      default:
        goto LABEL_52;
    }
  }
  return result;
}

uint64_t CUIWatchSubTypeFallbackOrder(uint64_t result, void *a2)
{
  uint64_t v3;

  if (result > 445)
  {
    if (result > 495)
    {
      if (result != 496 && result != 502)
        return result;
      objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 484));
    }
    else
    {
      if (result == 446)
      {
        v3 = 430;
        goto LABEL_18;
      }
      if (result != 484)
        return result;
    }
    v3 = 390;
LABEL_18:
    objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v3));
    goto LABEL_19;
  }
  if (result <= 389)
  {
    if (result != 340)
    {
      if (result != 384)
        return result;
      return (uint64_t)objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 320));
    }
LABEL_20:
    objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 384));
    return (uint64_t)objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 320));
  }
  if (result == 390 || result == 430)
  {
LABEL_19:
    objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 340));
    goto LABEL_20;
  }
  return result;
}

void OUTLINED_FUNCTION_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _CUILog(4, a2, a3, a4, a5, a6, a7, a8, a9);
}

const __CFString *OUTLINED_FUNCTION_1(uint64_t a1, uint64_t a2)
{
  return CUIPlatformNameForPlatform(a2);
}

const __CFString *OUTLINED_FUNCTION_2(uint64_t a1, uint64_t a2)
{
  return CUIPlatformNameForPlatform(a2);
}

id NSStringToUTF16LEBytes(NSString *a1, unsigned int *a2)
{
  NSData *v3;

  v3 = -[NSString dataUsingEncoding:](a1, "dataUsingEncoding:", 2483028224);
  *a2 = -[NSData length](v3, "length") >> 1;
  return (id)-[NSData bytes](v3, "bytes");
}

CPSDString *NewCPSDStringFromNSString(NSString *a1)
{
  NSData *v1;
  unsigned int v2;
  const unsigned __int16 *v3;
  CPSDString *v4;

  v1 = -[NSString dataUsingEncoding:](a1, "dataUsingEncoding:", 2483028224);
  v2 = -[NSData length](v1, "length") >> 1;
  v3 = -[NSData bytes](v1, "bytes");
  v4 = (CPSDString *)operator new(16, 0x1010C4082113244);
  CPSDString::CPSDString(v4, v3, v2);
  return v4;
}

void sub_19EC05C00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x1010C4082113244);
  _Unwind_Resume(a1);
}

void CPSDString::CPSDString(CPSDString *this, const unsigned __int16 *a2, unsigned int a3)
{
  *((_QWORD *)this + 1) = 0;
  CPSDString::AllocateCharData(this, 1u);
  **((_WORD **)this + 1) = 0;
  CPSDString::Init((void **)this, a2, a3, 1);
}

void sub_19EC05C7C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 8);
  if (v3)
  {
    MEMORY[0x1A1AEEAF0](v3, 0x1000C80BDFB0063);
    *(_QWORD *)(v1 + 8) = 0;
  }
  _Unwind_Resume(exception_object);
}

void sub_19EC05D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19EC05FA4()
{
  JUMPOUT(0x19EC05FACLL);
}

void sub_19EC06258(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC06204);
}

void sub_19EC06534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC06544);
}

void sub_19EC066B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC066C0);
}

void sub_19EC07744(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC07754);
}

void sub_19EC079B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC079C4);
}

void sub_19EC07C38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC07C48);
}

void sub_19EC07DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC07DBCLL);
}

void sub_19EC07ED4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC07EE4);
}

void sub_19EC099DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC099ECLL);
}

void *CPSDString::Init(void **this, const unsigned __int16 *a2, unsigned int a3, int a4)
{
  BOOL v7;
  void *result;

  if (a3)
  {
    v7 = a2[a3 - 1] == 0;
    if (!a4)
      goto LABEL_7;
  }
  else
  {
    v7 = 0;
    if (!a4)
      goto LABEL_7;
  }
  if (!v7)
  {
    CPSDString::AllocateCharData((CPSDString *)this, a3 + 1);
    result = memcpy(this[1], a2, (2 * *(_DWORD *)this - 2));
    *((_WORD *)this[1] + a3) = 0;
    return result;
  }
LABEL_7:
  CPSDString::AllocateCharData((CPSDString *)this, a3);
  return memcpy(this[1], a2, (2 * *(_DWORD *)this));
}

uint64_t CPSDString::AllocateCharData(CPSDString *this, unsigned int a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    MEMORY[0x1A1AEEAF0](v4, 0x1000C80BDFB0063);
    *((_QWORD *)this + 1) = 0;
  }
  *(_DWORD *)this = a2;
  result = operator new[](2 * a2, 0x1000C80BDFB0063);
  *((_QWORD *)this + 1) = result;
  return result;
}

uint64_t encodeRadiosity(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  unint64_t v10;
  uint64_t result;
  uint64_t v12;
  char *v14;
  char v15;
  float v16;
  float v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  size_t v23;
  void *v24;
  float *v25;
  void *v26;
  float *v27;
  BOOL v28;
  signed int v29;
  _WORD *v30;
  char v31;
  unint64_t v32;
  int v33;
  signed int v34;
  float v36;
  _WORD *v37;
  uint64_t v38;
  float *v39;
  char *v40;
  unint64_t v41;
  float *v42;
  uint64_t v43;
  float v45;
  uint64_t v46;
  float *v47;
  float v48;
  size_t v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  _QWORD *v54;
  char *v55;
  float *v56;
  unint64_t v57;
  vImage_Buffer dest;
  vImage_Buffer src;
  float __B[3];

  v10 = a1 - 0x10000;
  result = 0xFFFFFFFFLL;
  if (v10 < 0xFFFFFFFFFFFF0001)
    return result;
  if ((unint64_t)(a2 - 0x10000) < 0xFFFFFFFFFFFF0001)
    return result;
  v12 = 4 * a1;
  if (4 * a1 > a3)
    return result;
  v14 = (char *)a4;
  if (a9 == 20.0)
  {
    v54 = (_QWORD *)a6;
    v57 = a3;
    v15 = 4;
    v16 = 0.4574;
    v17 = -0.3324;
    v18 = 1060696910;
  }
  else
  {
    if (a9 != 40.0)
    {
      _CUILog(4, (uint64_t)"Invalid sigma=%.2f\n", a3, a4, a5, a6, a7, a8, COERCE__INT64(a9));
      return 0xFFFFFFFFLL;
    }
    v54 = (_QWORD *)a6;
    v57 = a3;
    v15 = 5;
    v16 = 0.22498;
    v17 = -0.16248;
    v18 = 1060748727;
  }
  v19 = (1 << v15);
  v20 = (unint64_t)(a1 + v19 - 1) >> v15;
  v21 = (unint64_t)(a2 + v19 - 1) >> v15;
  v22 = 4 * v20 * v21;
  v23 = 8 * v20 * v21 + 12;
  v52 = v20;
  v24 = malloc_type_malloc(16 * a1, 0x100004052888210uLL);
  v53 = v21;
  v25 = (float *)malloc_type_calloc(v21 * v12, 4uLL, 0x100004052888210uLL);
  v51 = v22;
  v55 = (char *)malloc_type_calloc(v22, 4uLL, 0x100004052888210uLL);
  v26 = malloc_type_malloc(v23, 0x2E1431D7uLL);
  v27 = v25;
  if (!v24 || !v25 || (v55 ? (v28 = v26 == 0) : (v28 = 1), v28))
  {
    free(v25);
    free(v55);
    free(v24);
    free(v26);
    return 0xFFFFFFFFLL;
  }
  v49 = v23;
  v50 = (_QWORD *)a5;
  v29 = v19 >> 2;
  v30 = v26;
  v31 = v15;
  v56 = v27;
  bzero(v30, v23);
  v32 = 0;
  *v30 = a1;
  v30[1] = a2;
  v33 = v19 - 1;
  v30[2] = v19;
  v34 = 3 * (v19 >> 2);
  *((_DWORD *)v30 + 2) = v18;
  do
  {
    if ((int)(v33 & v32) >= v34 || (int)(v33 & v32) < v29)
      v36 = v17;
    else
      v36 = v16;
    __B[0] = v36;
    src.data = v14;
    src.height = 1;
    src.width = 4 * a1;
    src.rowBytes = 4 * a1;
    dest.data = v24;
    dest.height = 1;
    dest.width = 4 * a1;
    dest.rowBytes = 4 * a1;
    vImageConvert_Planar8toPlanarF(&src, &dest, 255.0, 0.0, 0);
    vDSP_vsma((const float *)v24, 1, __B, &v56[(v32 >> v31) * v12], 1, &v56[(v32 >> v31) * v12], 1, 4 * a1);
    ++v32;
    v14 += v57;
  }
  while (a2 != v32);
  v37 = v30 + 6;
  if (v53)
  {
    v38 = 0;
    v39 = v56;
    v40 = v55;
    do
    {
      if (a1)
      {
        v41 = 0;
        v42 = v39;
        do
        {
          v43 = 0;
          if ((int)(v33 & v41) >= v34 || (int)(v33 & v41) < v29)
            v45 = v17;
          else
            v45 = v16;
          do
          {
            *(float *)&v40[16 * (v41 >> v31) + v43 * 4] = *(float *)&v40[16 * (v41 >> v31) + v43 * 4]
                                                        + (float)(v45 * v42[v43]);
            ++v43;
          }
          while (v43 != 4);
          ++v41;
          v42 += 4;
        }
        while (v41 != a1);
      }
      ++v38;
      v40 += 16 * v52;
      v39 += 4 * a1;
    }
    while (v38 != v53);
    if (v52)
    {
      v46 = v51;
      if (v51 <= 1)
        v46 = 1;
      v47 = (float *)v55;
      do
      {
        v48 = *v47++;
        *v37++ = vcvts_n_s32_f32(v48, 6uLL);
        --v46;
      }
      while (v46);
    }
  }
  free(v56);
  free(v55);
  free(v24);
  result = 0;
  *v50 = v30;
  *v54 = v49;
  return result;
}

uint64_t decodeRadiosity(unsigned __int16 *a1, unint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v11;
  char v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  size_t v17;
  size_t v18;
  char *v19;
  float *v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  int v24;
  uint64_t v25;
  float *v26;
  double v27;
  double v28;
  double v29;
  float v30;
  float v31;
  __int16 *v32;
  float *v33;
  int v34;
  size_t v35;
  float *v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *v41;
  unint64_t v42;
  float *v43;
  unint64_t v44;
  int v45;
  uint64_t v46;
  float v47;
  uint64_t v48;
  float v49;
  uint64_t v50;
  float v51;
  char *v52;
  unint64_t v53;
  uint64_t v54;
  float *v55;
  unint64_t v56;
  int v57;
  uint64_t v58;
  char *v59;
  float v60;
  int v61;
  char v62;
  char v63;
  int v64;
  char *v65;
  uint64_t v66;
  uint64_t v68;
  float *v69;
  float *v70;
  unint64_t v71;
  float __B;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;

  if (a2 < 0xC)
    return 0xFFFFFFFFLL;
  v73 = v7;
  v74 = v6;
  v75 = v4;
  v76 = v5;
  v11 = a1[2];
  v12 = -1;
  do
    ++v12;
  while (1 << v12 < (int)v11);
  v13 = *a1;
  v14 = (unint64_t)(v11 - 1 + v13) >> v12;
  v68 = a1[1];
  v15 = (unint64_t)(v11 - 1 + v68) >> v12;
  v16 = (float *)malloc_type_calloc(3 * v11, 4uLL, 0x100004052888210uLL);
  v17 = 4 * v13;
  v70 = (float *)malloc_type_calloc(v15 * v17, 4uLL, 0x100004052888210uLL);
  v71 = v15;
  v18 = 4 * v14 * v15;
  v19 = (char *)malloc_type_calloc(v18, 4uLL, 0x100004052888210uLL);
  v20 = (float *)malloc_type_calloc(v17, 4uLL, 0x100004052888210uLL);
  v65 = v19;
  if (v70)
    v21 = v19 == 0;
  else
    v21 = 1;
  v22 = v21 || v16 == 0;
  v69 = v20;
  v23 = v22 || v20 == 0;
  v24 = v23;
  v64 = v24;
  if (!v23)
  {
    if ((_DWORD)v11)
    {
      v25 = 0;
      v26 = v16 + 2;
      do
      {
        v27 = ((double)(int)v25 + 0.5 - (double)v11 * 0.5) / ((double)v11 * 0.5);
        v28 = v27 * (v27 * -2.0);
        v29 = *((float *)a1 + 2);
        v30 = (v28 + v27 * (v27 * 3.0) * v27 + v27 * -5.0 + 4.0) * 0.125
            + (v27 + v27 * v27 + -(v27 * v27) * v27 + -1.0) * 0.5 * v29;
        v31 = v27 * v27 * 0.5 + (1.0 - v27 * v27) * v29;
        *(v26 - 2) = v30;
        *(v26 - 1) = v31;
        *(float *)&v27 = (v28 + v27 * (v27 * -3.0) * v27 + v27 * 5.0 + 4.0) * 0.125
                       + (v27 * v27 + v27 * v27 * v27 - v27 + -1.0) * 0.5 * v29;
        *v26 = *(float *)&v27;
        v26 += 3;
        ++v25;
      }
      while (v11 != v25);
    }
    if (v18)
    {
      v32 = (__int16 *)(a1 + 6);
      v33 = (float *)v19;
      do
      {
        v34 = *v32++;
        *v33++ = (float)v34 * 0.015625;
        --v18;
      }
      while (v18);
    }
    v35 = 16 * v13;
    v36 = v70;
    if (v71)
    {
      v37 = 0;
      v38 = v19;
      v39 = v19 - 16;
      v40 = 16 * v14;
      v41 = v19 + 16;
      do
      {
        if ((_DWORD)v13)
        {
          v42 = 0;
          v43 = v36;
          do
          {
            v44 = v42 >> v12;
            v45 = 3 * ((v11 - 1) & v42);
            if (v42 >> v12)
            {
              v46 = 0;
              v47 = v16[v45];
              do
              {
                v43[v46] = v43[v46] + (float)(v47 * *(float *)&v39[16 * v44 + v46 * 4]);
                ++v46;
              }
              while (v46 != 4);
            }
            v48 = 0;
            v49 = v16[v45 + 1];
            do
            {
              v43[v48] = v43[v48] + (float)(v49 * *(float *)&v38[16 * v44 + v48 * 4]);
              ++v48;
            }
            while (v48 != 4);
            if (v44 + 1 < v14)
            {
              v50 = 0;
              v51 = v16[v45 + 2];
              v52 = &v41[16 * v44];
              do
              {
                v43[v50] = v43[v50] + (float)(v51 * *(float *)&v52[v50 * 4]);
                ++v50;
              }
              while (v50 != 4);
            }
            ++v42;
            v43 += 4;
          }
          while (v42 != v13);
        }
        ++v37;
        v39 += v40;
        v36 = (float *)((char *)v36 + v35);
        v38 += v40;
        v41 += v40;
      }
      while (v37 != v71);
    }
    if ((_DWORD)v68)
    {
      v53 = 0;
      if (v17 <= 1)
        v54 = 1;
      else
        v54 = 4 * v13;
      v66 = v54;
      do
      {
        v55 = v69;
        bzero(v69, v35);
        v56 = v53 >> v12;
        v57 = 3 * ((v11 - 1) & v53);
        if (v53 >> v12)
        {
          __B = v16[v57];
          vDSP_vsma(&v70[(v56 - 1) * v17], 1, &__B, v69, 1, v69, 1, 4 * v13);
        }
        __B = v16[v57 + 1];
        vDSP_vsma(&v70[v56 * v17], 1, &__B, v69, 1, v69, 1, 4 * v13);
        if (v56 + 1 < v71)
        {
          __B = v16[v57 + 2];
          vDSP_vsma(&v70[(v56 + 1) * v17], 1, &__B, v69, 1, v69, 1, 4 * v13);
        }
        v58 = v66;
        v59 = a4;
        if ((_DWORD)v13)
        {
          do
          {
            v60 = *v55++;
            v61 = (int)(float)(v60 + 0.5);
            if (v61 >= 0xFF)
              v62 = -1;
            else
              v62 = v61;
            if (v61 >= 0)
              v63 = v62;
            else
              v63 = 0;
            *v59++ = v63;
            --v58;
          }
          while (v58);
        }
        ++v53;
        v35 = 16 * v13;
        a4 += a3;
      }
      while (v53 != v68);
    }
  }
  free(v16);
  free(v70);
  free(v65);
  free(v69);
  return (v64 << 31 >> 31);
}

uint64_t CUIConvertToTXRPixelFormat(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  BOOL v6;

  v1 = 0;
  if (a1 > 109)
  {
    if (a1 > 151)
    {
      if (a1 == 555)
        v1 = 555;
      else
        v1 = 0;
      if (a1 == 553)
        v1 = 553;
      if (a1 == 212)
        v2 = 212;
      else
        v2 = 0;
      if (a1 == 204)
        v2 = 204;
      if (a1 <= 552)
        v1 = v2;
      if (a1 == 194)
        v3 = 194;
      else
        v3 = 0;
      if (a1 == 186)
        v3 = 186;
      if (a1 == 153)
        v4 = 153;
      else
        v4 = 0;
      if (a1 == 152)
        v4 = 152;
      if (a1 <= 185)
        v3 = v4;
      v5 = a1 <= 203;
LABEL_50:
      if (v5)
        return v3;
      return v1;
    }
    switch(a1)
    {
      case 110:
      case 112:
      case 115:
      case 125:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 140:
      case 141:
      case 142:
      case 143:
LABEL_9:
        v1 = a1;
        break;
      default:
        return v1;
    }
  }
  else
  {
    if (a1 > 59)
    {
      if (a1 <= 79)
      {
        switch(a1)
        {
          case '<':
          case '>':
          case 'A':
          case 'F':
          case 'G':
          case 'H':
            goto LABEL_9;
          default:
            return v1;
        }
        return v1;
      }
      if (a1 == 105)
        v1 = 105;
      else
        v1 = 0;
      if (a1 == 93)
        v1 = 93;
      if (a1 == 92)
        v1 = 92;
      if (a1 == 90)
        v3 = 90;
      else
        v3 = 0;
      if (a1 == 81)
        v3 = 81;
      if (a1 == 80)
        v3 = 80;
      v5 = a1 <= 91;
      goto LABEL_50;
    }
    if (a1 <= 11)
    {
      if (a1 == 11)
        v1 = 11;
      else
        v1 = 0;
      if (a1 == 10)
        v1 = 10;
      v6 = a1 == 1;
LABEL_63:
      if (v6)
        return a1;
    }
    else
    {
      switch(a1)
      {
        case 20:
        case 22:
        case 25:
        case 30:
        case 31:
        case 32:
          goto LABEL_9;
        case 21:
        case 23:
        case 24:
        case 26:
        case 27:
        case 28:
        case 29:
          return v1;
        default:
          if (a1 == 55)
            v1 = 55;
          else
            v1 = 0;
          v6 = a1 == 12;
          goto LABEL_63;
      }
    }
  }
  return v1;
}

uint64_t CUIConvertFromTXRPixelFormat(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  BOOL v5;

  v1 = 0;
  if (a1 <= 104)
  {
    if (a1 <= 59)
    {
      if (a1 <= 11)
      {
        if (a1 == 11)
          v1 = 11;
        else
          v1 = 0;
        if (a1 == 10)
          v1 = 10;
        v5 = a1 == 1;
LABEL_56:
        if (v5)
          return a1;
      }
      else
      {
        switch(a1)
        {
          case 20:
          case 22:
          case 25:
          case 30:
          case 31:
          case 32:
            goto LABEL_9;
          case 21:
          case 23:
          case 24:
          case 26:
          case 27:
          case 28:
          case 29:
            return v1;
          default:
            if (a1 == 55)
              v1 = 55;
            else
              v1 = 0;
            v5 = a1 == 12;
            goto LABEL_56;
        }
      }
      return v1;
    }
    if (a1 <= 79)
    {
      switch(a1)
      {
        case '<':
        case '>':
        case 'A':
        case 'F':
        case 'G':
        case 'H':
          goto LABEL_9;
        default:
          return v1;
      }
      return v1;
    }
    if (a1 == 93)
      v1 = 93;
    else
      v1 = 0;
    if (a1 == 92)
      v1 = 92;
    if (a1 == 90)
      v1 = 90;
    if (a1 == 81)
      v3 = 81;
    else
      v3 = 0;
    if (a1 == 80)
      v3 = 80;
    v4 = a1 <= 89;
    goto LABEL_43;
  }
  if (a1 > 151)
  {
    if (a1 == 555)
      v1 = 555;
    else
      v1 = 0;
    if (a1 == 553)
      v1 = 553;
    if (a1 == 212)
      v2 = 212;
    else
      v2 = 0;
    if (a1 == 204)
      v2 = 204;
    if (a1 <= 552)
      v1 = v2;
    if (a1 == 194)
      v3 = 194;
    else
      v3 = 0;
    if (a1 == 186)
      v3 = 186;
    if (a1 == 152)
      v3 = 152;
    v4 = a1 <= 203;
LABEL_43:
    if (v4)
      return v3;
    return v1;
  }
  switch(a1)
  {
    case 110:
    case 112:
    case 115:
    case 125:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 140:
    case 141:
    case 142:
    case 143:
LABEL_9:
      v1 = a1;
      break;
    case 111:
    case 113:
    case 114:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 126:
    case 127:
    case 128:
    case 129:
    case 136:
    case 137:
    case 138:
    case 139:
      return v1;
    default:
      if (a1 == 105)
        v1 = 105;
      else
        v1 = 0;
      break;
  }
  return v1;
}

CFDataRef CUIConvertImageToPixelFormat(CGImage *a1, int a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6, double a7, double a8)
{
  uint64_t v15;
  id v16;
  id v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  id v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  CFDataRef v44;
  double v46;
  uint64_t v47;

  v15 = CUIConvertToTXRPixelFormat(a5);
  v16 = objc_alloc_init((Class)TXRDefaultBufferAllocator);
  v47 = 0;
  v17 = objc_alloc_init((Class)TXROptions);
  v18 = v17;
  v19 = 16;
  if (a2)
    v19 = 64;
  objc_msgSend(v17, "setOriginOperation:", v19 | a3);
  if (a4 == 2)
  {
    objc_msgSend(v18, "setColorSpaceHandling:", 0);
    v20 = 1;
    objc_msgSend(v18, "setMultiplyAlpha:", 1);
  }
  else if (a4 == 1)
  {
    objc_msgSend(v18, "setColorSpaceHandling:", 0);
    v20 = 1;
  }
  else
  {
    if (!a4)
      objc_msgSend(v18, "setColorSpaceHandling:", 3);
    v20 = 0;
  }
  v21 = objc_msgSend(objc_alloc((Class)TXRImageIndependent), "initWithCGImage:bufferAllocator:options:error:", a1, v16, v18, &v47);

  if (!v21)
  {
    _CUILog(4, (uint64_t)"CoreUI: %s got error '%@' converting image", v22, v23, v24, v25, v26, v27, (uint64_t)"CFDataRef CUIConvertImageToPixelFormat(CGImageRef, BOOL, int32_t, _CUIThemeTextureInterpretation, CGSize, _CUIThemeTexturePixelFormat, size_t *)");
LABEL_21:
    v44 = 0;
    goto LABEL_22;
  }
  if (a7 != (double)CGImageGetWidth(a1) || a8 != (double)CGImageGetHeight(a1))
  {
    LODWORD(v28) = a7;
    HIDWORD(v28) = a8;
    v46 = v28;
    v35 = +[TXRDataScaler newImageFromSourceImage:scaledDimensions:bufferAllocattor:filter:error:](TXRDataScaler, "newImageFromSourceImage:scaledDimensions:bufferAllocattor:filter:error:", v21, v16, 1, &v47);
    if (v35)
    {
      v36 = objc_msgSend(objc_alloc((Class)TXRImageIndependent), "initWithImage:dimensions:pixelFormat:", v35, objc_msgSend(v21, "pixelFormat"), v46);
      v37 = +[TXRDataConverter newImageFromSourceImage:newPixelFormat:bufferAllocator:gammaDegamma:error:](TXRDataConverter, "newImageFromSourceImage:newPixelFormat:bufferAllocator:gammaDegamma:error:", v36, v15, v16, v20, &v47);

    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: %s got error '%@' scaling image", v29, v30, v31, v32, v33, v34, (uint64_t)"CFDataRef CUIConvertImageToPixelFormat(CGImageRef, BOOL, int32_t, _CUIThemeTextureInterpretation, CGSize, _CUIThemeTexturePixelFormat, size_t *)");
      v37 = 0;
    }

    if (v37)
      goto LABEL_18;
    goto LABEL_20;
  }
  v37 = +[TXRDataConverter newImageFromSourceImage:newPixelFormat:bufferAllocator:gammaDegamma:error:](TXRDataConverter, "newImageFromSourceImage:newPixelFormat:bufferAllocator:gammaDegamma:error:", v21, v15, v16, v20, &v47);
  if (!v37)
  {
LABEL_20:
    _CUILog(4, (uint64_t)"CoreUI: %s got error '%@' converting scaled image", v38, v39, v40, v41, v42, v43, (uint64_t)"CFDataRef CUIConvertImageToPixelFormat(CGImageRef, BOOL, int32_t, _CUIThemeTextureInterpretation, CGSize, _CUIThemeTexturePixelFormat, size_t *)");
    goto LABEL_21;
  }
LABEL_18:
  *a6 = objc_msgSend(v37, "bytesPerRow");
  v44 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)objc_msgSend(objc_msgSend(objc_msgSend(v37, "buffer"), "map"), "bytes"), (CFIndex)objc_msgSend(v37, "bytesPerImage"));

LABEL_22:
  return v44;
}

uint64_t CUIGetFormatForFeatureSetAndPixelFormat(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];

  v8 = 1;
  v9 = 1001;
  switch(*a2)
  {
    case 0:
      v8 = 0;
      goto LABEL_5;
    case 1:
      break;
    case 2:
      v9 = 1002;
      break;
    case 4:
      v9 = 1003;
      break;
    case 5:
      v9 = 1004;
      break;
    case 6:
      v9 = 1005;
      break;
    case 7:
      v9 = 1006;
      break;
    case 8:
      v9 = 1007;
      break;
    case 9:
      v9 = 1008;
      break;
    case 10:
      v9 = 1009;
      break;
    default:
      v8 = 1;
LABEL_5:
      v9 = 3001;
      break;
  }
  if ((a1 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    v10 = 1000;
  else
    v10 = 3000;
  if (a5)
  {
    v11 = 0;
  }
  else
  {
    v11 = objc_alloc_init((Class)TXROptions);
    objc_msgSend(v11, "setColorSpaceHandling:", 3);
  }
  v12 = +[TXRDataConverter newPixelFormatSetForCGImage:displayGamut:options:](TXRDataConverter, "newPixelFormatSetForCGImage:displayGamut:options:", a4, a3 == 1, v11);

  if (v8)
  {
    while (1)
    {
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
      if (v13)
      {
        v14 = v13;
        v15 = *(_QWORD *)v24;
LABEL_22:
        v16 = 0;
        while (1)
        {
          if (*(_QWORD *)v24 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * v16);
          v22 = 0;
          +[TXRPixelFormatInfo isASTC:](TXRPixelFormatInfo, "isASTC:", objc_msgSend(v17, "unsignedIntegerValue"));
          if ((MTLGPUFamilySupportsSamplingFromPixelFormat(v9, objc_msgSend(v17, "unsignedIntegerValue"), &v22) & 1) != 0)
            break;
          if (v14 == (id)++v16)
          {
            v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
            if (v14)
              goto LABEL_22;
            goto LABEL_30;
          }
        }
        v18 = objc_msgSend(v17, "unsignedIntegerValue");
        if (v18)
          goto LABEL_37;
      }
LABEL_30:
      if (v9 == v10)
        break;
      if ((unint64_t)(v9 - 1002) > 8)
        v19 = 2;
      else
        v19 = qword_19EC72490[v9 - 1002];
      --v9;
      *a2 = v19;
    }
    *a2 = 0;
  }
  v18 = objc_msgSend(objc_msgSend(v12, "lastObject"), "unsignedIntegerValue");
LABEL_37:
  v20 = (uint64_t)v18;

  return CUIConvertFromTXRPixelFormat(v20);
}

void CPSDFile::CPSDFile(CPSDFile *this)
{
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_WORD *)this + 22) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_BYTE *)this + 104) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_WORD *)this + 44) = 0;
  *(_QWORD *)this = &off_1E41AA138;
  *((_QWORD *)this + 14) = &off_1E41A8E60;
  *((_QWORD *)this + 16) = 0;
  *(_QWORD *)((char *)this + 134) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 20) = &off_1E41A9310;
  *((_DWORD *)this + 44) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = &off_1E41A94C0;
  *((_DWORD *)this + 52) = 0;
  *((_QWORD *)this + 27) = 0;
  CPSDLayerAndMaskInfo::CPSDLayerAndMaskInfo((CPSDFile *)((char *)this + 224));
  *((_BYTE *)this + 392) = 0;
  *((_QWORD *)this + 1) = this;
  *((_QWORD *)this + 21) = this;
  *((_QWORD *)this + 29) = this;
  *((_QWORD *)this + 32) = this;
}

void CPSDLayerAndMaskInfo::~CPSDLayerAndMaskInfo(CPSDLayerAndMaskInfo *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E41A9810;
  *((_QWORD *)this + 17) = &off_1E41A9BB0;
  v2 = *((_QWORD *)this + 20);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CPSDLayerInfo::~CPSDLayerInfo((CPSDLayerAndMaskInfo *)((char *)this + 24));
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E41A9810;
  *((_QWORD *)this + 17) = &off_1E41A9BB0;
  v2 = *((_QWORD *)this + 20);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CPSDLayerInfo::~CPSDLayerInfo((CPSDLayerAndMaskInfo *)((char *)this + 24));
  JUMPOUT(0x1A1AEEB08);
}

void CPSDImageResources::~CPSDImageResources(CPSDImageResources *this)
{
  _QWORD *v1;
  _QWORD *v2;

  *(_QWORD *)this = &off_1E41A94C0;
  v1 = (_QWORD *)*((_QWORD *)this + 3);
  if (v1)
  {
    do
    {
      v2 = (_QWORD *)v1[37];
      (*(void (**)(_QWORD *))(*v1 + 8))(v1);
      v1 = v2;
    }
    while (v2);
  }
}

{
  _QWORD *v1;
  _QWORD *v2;

  *(_QWORD *)this = &off_1E41A94C0;
  v1 = (_QWORD *)*((_QWORD *)this + 3);
  if (v1)
  {
    do
    {
      v2 = (_QWORD *)v1[37];
      (*(void (**)(_QWORD *))(*v1 + 8))(v1);
      v1 = v2;
    }
    while (v2);
  }
  JUMPOUT(0x1A1AEEB08);
}

void CPSDColorModeData::~CPSDColorModeData(CPSDColorModeData *this)
{
  void *v1;

  *(_QWORD *)this = &off_1E41A9310;
  v1 = (void *)*((_QWORD *)this + 3);
  if (v1)
    free(v1);
}

{
  void *v1;

  *(_QWORD *)this = &off_1E41A9310;
  v1 = (void *)*((_QWORD *)this + 3);
  if (v1)
    free(v1);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDImageLoad::~CPSDImageLoad(void **this)
{
  void *v2;

  *this = off_1E41A8F10;
  CPSDImageLoad::DeAllocateChannelBuffers((CPSDImageLoad *)this);
  v2 = this[12];
  if (v2)
  {
    free(v2);
    this[12] = 0;
    this[8] = 0;
  }
  free(this[2]);
  this[2] = 0;
}

void CPSDFile::~CPSDFile(CPSDFile *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;

  *(_QWORD *)this = &off_1E41AA138;
  *((_QWORD *)this + 28) = &off_1E41A9810;
  *((_QWORD *)this + 45) = &off_1E41A9BB0;
  v2 = *((_QWORD *)this + 48);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CPSDLayerInfo::~CPSDLayerInfo((CPSDFile *)((char *)this + 248));
  *((_QWORD *)this + 24) = &off_1E41A94C0;
  v3 = (_QWORD *)*((_QWORD *)this + 27);
  if (v3)
  {
    do
    {
      v4 = (_QWORD *)v3[37];
      (*(void (**)(_QWORD *))(*v3 + 8))(v3);
      v3 = v4;
    }
    while (v4);
  }
  *((_QWORD *)this + 20) = &off_1E41A9310;
  v5 = (void *)*((_QWORD *)this + 23);
  if (v5)
    free(v5);
  CPSDImageLoad::~CPSDImageLoad((void **)this);
}

{
  CPSDFile::~CPSDFile(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDBaseComponent::SetFileObject(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t CPSDLayerAndMaskInfo::SetFileObject(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 32) = a2;
  return result;
}

void *CPSDFile::Init(CPSDFile *this, int a2, int a3, const unsigned __int8 *a4, size_t size)
{
  *((_DWORD *)this + 32) = 943870035;
  *((_WORD *)this + 66) = 1;
  *((_DWORD *)this + 36) = a3;
  *((_DWORD *)this + 37) = a2;
  *((_WORD *)this + 70) = 3;
  *((_DWORD *)this + 38) = 196616;
  CPSDImageResources::AddICCData((CPSDFile *)((char *)this + 192), a4, size);
  return CPSDFile::InitCompositeData(this);
}

CPSDBaseComponent *CPSDImageResources::AddICCData(CPSDBaseComponent *this, const unsigned __int8 *a2, size_t size)
{
  CPSDBaseComponent *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CPSDICCProfileResourceItem *v11;
  CStdException *exception;

  if (a2 && size)
  {
    v5 = this;
    v7 = (uint64_t *)((char *)this + 24);
    v6 = *((_QWORD *)this + 3);
    if (v6)
    {
      while (*(_WORD *)(v6 + 20) != 1039)
      {
        v6 = *(_QWORD *)(v6 + 296);
        if (!v6)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      v6 = operator new(304, 0x10A1C4050C531E5);
      *(_QWORD *)v6 = &off_1E41A9B30;
      *(_DWORD *)(v6 + 280) = 0;
      *(_BYTE *)(v6 + 22) = 0;
      *(_QWORD *)(v6 + 288) = 0;
      *(_QWORD *)(v6 + 296) = 0;
      *(_DWORD *)(v6 + 16) = 943868237;
      *(_WORD *)(v6 + 20) = 1039;
      v8 = operator new(56, 0x10B1C40300736D0);
      *(_DWORD *)(v8 + 16) = 0;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 0;
      *(_QWORD *)v8 = &off_1E41A9F10;
      *(_QWORD *)(v8 + 40) = v6;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v6 + 288) = v8;
      v9 = *v7;
      if (*v7)
      {
        do
        {
          v10 = v9;
          v9 = *(_QWORD *)(v9 + 296);
        }
        while (v9);
        v7 = (uint64_t *)(v10 + 296);
      }
      *v7 = v6;
    }
    v11 = *(CPSDICCProfileResourceItem **)(v6 + 288);
    if (!v11)
    {
      exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
      CStdException::CStdException(exception, 3238789123);
    }
    CPSDICCProfileResourceItem::AddICCData(v11, a2, size);
    return CPSDImageResources::UpdateResourceSize(v5, v11);
  }
  return this;
}

void sub_19EC0BCD8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *CPSDFile::InitCompositeData(CPSDFile *this)
{
  int v2;
  size_t v3;
  void *result;

  (*(void (**)(CPSDFile *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 48))(this, *((unsigned int *)this + 37), *((unsigned int *)this + 36), *((unsigned __int16 *)this + 70), *((unsigned __int16 *)this + 76), *((unsigned __int16 *)this + 77), *((_QWORD *)this + 23));
  v2 = *((_DWORD *)this + 6);
  v3 = *((_DWORD *)this + 37)
     * *((unsigned __int16 *)this + 70)
     * *((_DWORD *)this + 36)
     * (*((unsigned __int16 *)this + 76) >> 3);
  *((_DWORD *)this + 6) = v3;
  result = (void *)*((_QWORD *)this + 2);
  if (!result || v2 != (_DWORD)v3)
  {
    result = malloc_type_realloc(result, v3, 0x26A5A854uLL);
    *((_QWORD *)this + 2) = result;
  }
  *((_BYTE *)this + 392) = 1;
  return result;
}

CPSDBaseComponent *CPSDFile::AddExtraAlphaChannel(CPSDFile *this, unsigned __int8 *a2, unsigned int a3, const CPSDString *a4)
{
  char v8;
  unsigned int v9;
  CPSDBaseComponent *result;
  CStdException *exception;

  if ((unsigned __int16)(*((_WORD *)this + 70) + 1) > 0x38u
    || (v8 = *((_BYTE *)this + 392),
        ++*((_WORD *)this + 70),
        CPSDFile::InitCompositeData(this),
        v9 = *((_DWORD *)this + 37)
           * (unsigned __int16)(*((_WORD *)this + 70) - 1)
           * *((_DWORD *)this + 36)
           * (*((unsigned __int16 *)this + 76) >> 3),
        *((_DWORD *)this + 6) - v9 < a3))
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  memcpy((void *)(*((_QWORD *)this + 2) + v9), a2, a3);
  result = CPSDImageResources::AddExtraChannelName((CPSDFile *)((char *)this + 192), a4);
  *((_BYTE *)this + 392) = v8;
  return result;
}

void sub_19EC0BE70(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CPSDBaseComponent *CPSDImageResources::AddExtraChannelName(CPSDImageResources *this, const CPSDString *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CPSDUnicodeChannelNames *v9;
  CStdException *exception;

  v5 = (uint64_t *)((char *)this + 24);
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    while (*(_WORD *)(v4 + 20) != 1045)
    {
      v4 = *(_QWORD *)(v4 + 296);
      if (!v4)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v4 = operator new(304, 0x10A1C4050C531E5);
    *(_QWORD *)v4 = &off_1E41A9B30;
    *(_DWORD *)(v4 + 280) = 0;
    *(_BYTE *)(v4 + 22) = 0;
    *(_QWORD *)(v4 + 288) = 0;
    *(_QWORD *)(v4 + 296) = 0;
    *(_DWORD *)(v4 + 16) = 943868237;
    *(_WORD *)(v4 + 20) = 1045;
    v6 = operator new(72, 0x10B1C40580B6E5ALL);
    *(_DWORD *)(v6 + 16) = 0;
    *(_QWORD *)(v6 + 24) = 0;
    *(_QWORD *)(v6 + 32) = 0;
    *(_QWORD *)v6 = &off_1E41A9D90;
    *(_QWORD *)(v6 + 40) = v4;
    *(_QWORD *)(v6 + 48) = 0;
    *(_QWORD *)(v6 + 56) = 0;
    *(_QWORD *)(v6 + 64) = 0;
    *(_QWORD *)(v4 + 288) = v6;
    v7 = *v5;
    if (*v5)
    {
      do
      {
        v8 = v7;
        v7 = *(_QWORD *)(v7 + 296);
      }
      while (v7);
      v5 = (uint64_t *)(v8 + 296);
    }
    *v5 = v4;
  }
  v9 = *(CPSDUnicodeChannelNames **)(v4 + 288);
  if (!v9)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  CPSDUnicodeChannelNames::AddName(v9, a2);
  return CPSDImageResources::UpdateResourceSize(this, v9);
}

void sub_19EC0BFB8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CPSDFile::AddLayerCore(CPSDFile *this, CPSDLayerRecord *a2, const UniChar **a3, char a4, int a5)
{
  CPSDLayerBlendingRanges *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  _QWORD v13[259];
  uint64_t v14;

  *((_DWORD *)a2 + 16) = 943868237;
  *((_DWORD *)a2 + 17) = a5;
  *((_BYTE *)a2 + 72) = a4;
  *((_BYTE *)a2 + 74) = 8;
  v8 = (CPSDLayerRecord *)((char *)a2 + 144);
  CPSDLayerBlendingRanges::Init((CPSDLayerRecord *)((char *)a2 + 144), 4u);
  CPSDString::CopyStringValue(a3, (char *)a2 + 200, 0x100u);
  LODWORD(a3) = CPSDBaseComponent::ComputeSize((CPSDLayerRecord *)((char *)a2 + 456));
  *((_DWORD *)a2 + 118) = (_DWORD)a3;
  File::File((File *)v13, 0, 0);
  v13[0] = &unk_1E41A8EA0;
  v14 = 0;
  CPSDLayerMaskData::Save((CPSDLayerRecord *)((char *)a2 + 80), (File *)v13);
  CPSDLayerBlendingRanges::Save(v8, (File *)v13);
  ByteCounter::AppendAsPString((uint64_t)v13, (char *)a2 + 200, 4);
  *((_DWORD *)a2 + 19) = v14 + (_DWORD)a3;
  v9 = *((_QWORD *)this + 35);
  if (v9 >= *((_QWORD *)this + 36))
  {
    v10 = std::vector<CPSDLayerRecord>::__push_back_slow_path<CPSDLayerRecord>((uint64_t *)this + 34, (uint64_t)a2);
  }
  else
  {
    CPSDLayerRecord::CPSDLayerRecord(*((_QWORD *)this + 35), (uint64_t)a2);
    v10 = v9 + 488;
    *((_QWORD *)this + 35) = v9 + 488;
  }
  *((_QWORD *)this + 35) = v10;
  ++*((_WORD *)this + 134);
  v11 = CPSDBaseComponent::ComputeSize((CPSDFile *)((char *)this + 248));
  v12 = (v11 & 1) + v11;
  *((_DWORD *)this + 66) = v12;
  *((_DWORD *)this + 60) = v12 + 4;
  *((_BYTE *)this + 392) = 1;
  File::~File((File *)v13);
}

void sub_19EC0C144(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  File::~File((File *)va);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerBlendingRanges::Init(CPSDLayerBlendingRanges *this, unsigned int a2)
{
  _QWORD *v4;
  void (***v5)(_QWORD);
  void (***v6)(_QWORD);
  void (***v7)(_QWORD);
  void (***v8)(_QWORD);
  void (**v9)(_QWORD);
  BOOL v10;
  uint64_t v11;
  uint64_t result;
  _QWORD *v13;

  v4 = (_QWORD *)((char *)this + 32);
  v5 = (void (***)(_QWORD))*((_QWORD *)this + 4);
  *(_QWORD *)((char *)this + 20) = 0xFFFF0000FFFFLL;
  v6 = (void (***)(_QWORD))*((_QWORD *)this + 5);
  if (v6 != v5)
  {
    v7 = v6 - 3;
    v8 = v6 - 3;
    do
    {
      v9 = *v8;
      v8 -= 3;
      (*v9)(v7);
      v10 = v7 == v5;
      v7 = v8;
    }
    while (!v10);
  }
  *((_QWORD *)this + 5) = v5;
  v11 = a2;
  result = std::vector<CPSDChannelBlendingInfo>::resize((uint64_t)v4, a2);
  if (a2)
  {
    v13 = (_QWORD *)(*v4 + 16);
    do
    {
      *v13 = 0xFFFF0000FFFFLL;
      v13 += 3;
      --v11;
    }
    while (v11);
  }
  *((_DWORD *)this + 4) = 8 * a2 + 8;
  return result;
}

void CPSDString::CopyStringValue(const UniChar **this, char *a2, unsigned int a3)
{
  const __CFString *v5;
  CFStringEncoding SystemEncoding;

  v5 = CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, this[1], *(unsigned int *)this, kCFAllocatorNull);
  SystemEncoding = CFStringGetSystemEncoding();
  CFStringGetCString(v5, a2, a3, SystemEncoding);
  CFRelease(v5);
}

uint64_t CPSDBaseComponent::ComputeSize(CPSDBaseComponent *this)
{
  uint64_t v2;
  _QWORD v4[259];
  uint64_t v5;

  File::File((File *)v4, 0, 0);
  v4[0] = &unk_1E41A8EA0;
  v5 = 0;
  (*(void (**)(CPSDBaseComponent *, _QWORD *))(*(_QWORD *)this + 24))(this, v4);
  v2 = v5;
  File::~File((File *)v4);
  return v2;
}

void sub_19EC0C32C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  File::~File((File *)va);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerMaskData::Save(CPSDLayerMaskData *this, File *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(File *, uint64_t);

  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4))
  {
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 5));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 6));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 7));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 8));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 36));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 37));
    v5 = *(_QWORD *)a2;
    if (*((_DWORD *)this + 4) == 20)
    {
      v6 = *((unsigned __int16 *)this + 19);
      v7 = *(uint64_t (**)(File *, uint64_t))(v5 + 72);
    }
    else
    {
      (*(void (**)(File *, _QWORD))(v5 + 64))(a2, *((unsigned __int8 *)this + 57));
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 56));
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 12));
      v6 = *((unsigned int *)this + 13);
      v7 = *(uint64_t (**)(File *, uint64_t))(*(_QWORD *)a2 + 80);
    }
    return v7(a2, v6);
  }
  return result;
}

uint64_t CPSDLayerBlendingRanges::Save(CPSDLayerBlendingRanges *this, File *a2)
{
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4) >= 8u)
  {
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 5));
    result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 6));
    v5 = *((_DWORD *)this + 4) - 8;
    if (v5 >= 8)
    {
      v6 = v5 >> 3;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 3) == v6)
      {
        v7 = 0;
        if (v6 <= 1)
          v6 = 1;
        v8 = 24 * v6;
        do
        {
          result = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)(*((_QWORD *)this + 4) + v7) + 24))(*((_QWORD *)this + 4) + v7, a2);
          v7 += 24;
        }
        while (v8 != v7);
      }
    }
  }
  return result;
}

void CPSDFile::AddLayer(CPSDFile *this, unsigned __int8 **a2, int a3, const UniChar **a4, char a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  CPSDLayerChannelGroup *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _QWORD v20[4];
  __int16 v21;
  _OWORD v22[2];
  uint64_t v23;
  void (**v24)(CPSDLayerMaskData *__hidden);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (**v28)(CPSDLayerBlendingRanges *__hidden);
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[34];
  int v35;
  uint64_t v36;

  v12 = *((unsigned __int16 *)this + 134);
  v20[0] = &off_1E41A9120;
  memset(v22, 0, sizeof(v22));
  v23 = 0;
  v24 = &off_1E41A9350;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = off_1E41A9CC0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34[32] = &off_1E41A9BB0;
  v35 = 0;
  v36 = 0;
  bzero(v34, 0x100uLL);
  v13 = *(_QWORD *)((char *)this + 36);
  v20[2] = 0;
  v20[3] = v13;
  v21 = 4;
  std::vector<CPSDChannelLengthInfo>::resize((uint64_t)v22, 4uLL);
  std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 296, ((uint64_t)(*((_QWORD *)this + 38) - *((_QWORD *)this + 37)) >> 3) + 1);
  v14 = (CPSDLayerChannelGroup *)operator new(40, 0x10A1C401A1F3E30);
  CPSDLayerChannelGroup::CPSDLayerChannelGroup(v14, (CPSDLayerRecord *)v20);
  CPSDLayerChannelGroup::Init((uint64_t)v14, a2, a3);
  v15 = 0;
  v16 = 0;
  *(_QWORD *)(*((_QWORD *)this + 37) + 8 * v12) = v14;
  do
  {
    v17 = *(_QWORD *)&v22[0];
    v18 = CPSDLayerChannelGroup::ComputeSizeForChannel(v14, v16);
    v19 = v17 + v15;
    *(_WORD *)(v19 + 16) = v16 - 1;
    *(_DWORD *)(v19 + 20) = v18;
    ++v16;
    v15 += 24;
  }
  while (v16 != 4);
  CPSDFile::AddLayerCore(this, (CPSDLayerRecord *)v20, a4, a5, a6);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)v20);
}

void sub_19EC0C738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x1A1AEEB08](v9, 0x10A1C401A1F3E30);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CPSDChannelLengthInfo>::resize(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t (***v8)(_QWORD);
  uint64_t (***v9)(_QWORD);
  uint64_t (**v10)(_QWORD);
  BOOL v11;

  v2 = result;
  v3 = *(_QWORD *)(result + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *(_QWORD *)result) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
    return std::vector<CPSDChannelLengthInfo>::__append((char **)result, v6);
  if (!v5)
  {
    v7 = *(_QWORD *)result + 24 * a2;
    if (v3 != v7)
    {
      v8 = (uint64_t (***)(_QWORD))(v3 - 24);
      v9 = (uint64_t (***)(_QWORD))(v3 - 24);
      do
      {
        v10 = *v9;
        v9 -= 3;
        result = (*v10)(v8);
        v11 = v8 == (uint64_t (***)(_QWORD))v7;
        v8 = v9;
      }
      while (!v11);
    }
    *(_QWORD *)(v2 + 8) = v7;
  }
  return result;
}

void std::vector<CPSDLayerChannelGroup *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<CPSDLayerChannelGroup *>::__append((void **)a1, a2 - v2);
  }
}

uint64_t CPSDLayerChannelGroup::Init(uint64_t this, unsigned __int8 **a2, int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;

  if (*(_DWORD *)(this + 24) != 4)
    CPSDLayerChannelGroup::Init();
  v3 = 0;
  v4 = (_DWORD *)(*(_QWORD *)(this + 32) + 48);
  do
  {
    v5 = a2[v3];
    *((_WORD *)v4 - 12) = 0;
    *v4 = a3;
    *((_QWORD *)v4 - 1) = v5;
    ++v3;
    v4 += 14;
  }
  while (v3 != 4);
  return this;
}

uint64_t CPSDLayerChannelGroup::ComputeSizeForChannel(CPSDLayerChannelGroup *this, unsigned int a2)
{
  if (*((_DWORD *)this + 6) <= a2)
    CPSDLayerChannelGroup::ComputeSizeForChannel();
  return CPSDBaseComponent::ComputeSize((CPSDBaseComponent *)(*((_QWORD *)this + 4) + 56 * a2));
}

void CPSDFile::AddLayer(uint64_t a1, uint64_t a2, const UniChar **a3, char a4, int a5)
{
  uint64_t v10;
  CPSDLayerChannelGroup *v11;
  uint64_t v12;
  size_t v13;
  unsigned __int8 *v14;
  double *v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  CPSDActionDescriptor *v23;
  uint64_t v24;
  CPSDActionDescriptor **v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  int v31;
  uint64_t v32;
  unsigned __int8 *v33[2];
  __int128 v34;
  _QWORD v35[4];
  __int16 v36;
  _OWORD v37[2];
  uint64_t v38;
  void (**v39)(CPSDLayerMaskData *__hidden);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (**v43)(CPSDLayerBlendingRanges *__hidden);
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD v49[34];
  int v50;
  uint64_t v51;

  v32 = *(unsigned __int16 *)(a1 + 268);
  v35[0] = &off_1E41A9120;
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  v39 = &off_1E41A9350;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = off_1E41A9CC0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49[32] = &off_1E41A9BB0;
  v50 = 0;
  v51 = 0;
  bzero(v49, 0x100uLL);
  v10 = *(_QWORD *)(a1 + 36);
  v35[2] = 0;
  v35[3] = v10;
  v36 = 4;
  std::vector<CPSDChannelLengthInfo>::resize((uint64_t)v37, 4uLL);
  std::vector<CPSDLayerChannelGroup *>::resize(a1 + 296, ((uint64_t)(*(_QWORD *)(a1 + 304) - *(_QWORD *)(a1 + 296)) >> 3) + 1);
  v11 = (CPSDLayerChannelGroup *)operator new(40, 0x10A1C401A1F3E30);
  v30 = a4;
  v31 = a5;
  CPSDLayerChannelGroup::CPSDLayerChannelGroup(v11, (CPSDLayerRecord *)v35);
  v12 = 0;
  *(_OWORD *)v33 = 0u;
  v34 = 0u;
  v13 = (*(_DWORD *)(a1 + 144) * *(_DWORD *)(a1 + 148));
  do
  {
    v14 = (unsigned __int8 *)malloc_type_malloc(v13, 0x3F94555DuLL);
    v33[v12] = v14;
    v15 = (double *)(a2 + 80);
    switch((int)v12)
    {
      case 0:
        goto LABEL_6;
      case 1:
        v15 = (double *)(a2 + 56);
        goto LABEL_6;
      case 2:
        v15 = (double *)(a2 + 64);
        goto LABEL_6;
      case 3:
        v15 = (double *)(a2 + 72);
LABEL_6:
        v16 = *v15;
        memset(v14, llroundf(v16), v13);
        break;
      default:
        break;
    }
    ++v12;
  }
  while (v12 != 4);
  CPSDLayerChannelGroup::Init((uint64_t)v11, v33, v13);
  v17 = 0;
  v18 = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 296) + 8 * v32) = v11;
  do
  {
    v19 = *(_QWORD *)&v37[0];
    v20 = CPSDLayerChannelGroup::ComputeSizeForChannel(v11, v18);
    v21 = v19 + v17;
    *(_WORD *)(v21 + 16) = v18 - 1;
    *(_DWORD *)(v21 + 20) = v20;
    ++v18;
    v17 += 24;
  }
  while (v18 != 4);
  v22 = &v51;
  v23 = (CPSDActionDescriptor *)operator new(128, 0x10B1C4032540B95);
  CPSDActionDescriptor::CPSDActionDescriptor(v23);
  *(_QWORD *)v23 = &off_1E41A9F60;
  *((_QWORD *)v23 + 15) = 0;
  CPSDObjectEffectsLayerInfo::InitWithGradient((uint64_t)v23, a2);
  CPSDAdditionalLayerInfoItem::SizeUpItem(v23);
  v24 = v51;
  v25 = (CPSDActionDescriptor **)&v51;
  if (v51)
  {
    do
    {
      v26 = v24;
      v24 = *(_QWORD *)(v24 + 48);
    }
    while (v24);
    v25 = (CPSDActionDescriptor **)(v26 + 48);
  }
  *v25 = v23;
  v27 = operator new(64, 0x10B1C40B4161B10);
  *(_DWORD *)(v27 + 16) = 0;
  *(_OWORD *)(v27 + 40) = 0u;
  *(_OWORD *)(v27 + 24) = 0u;
  *(_QWORD *)v27 = &off_1E41A99A8;
  *(_QWORD *)(v27 + 40) = 0x694F70613842494DLL;
  *(_BYTE *)(v27 + 56) = 0;
  CPSDAdditionalLayerInfoItem::SizeUpItem((CPSDAdditionalLayerInfoItem *)v27);
  v28 = v51;
  if (v51)
  {
    do
    {
      v29 = v28;
      v28 = *(_QWORD *)(v28 + 48);
    }
    while (v28);
    v22 = (uint64_t *)(v29 + 48);
  }
  *v22 = v27;
  CPSDFile::AddLayerCore((CPSDFile *)a1, (CPSDLayerRecord *)v35, a3, v30, v31);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)v35);
}

void sub_19EC0CBF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  va_list va;

  va_start(va, a12);
  MEMORY[0x1A1AEEB08](v12, 0x10B1C4032540B95);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)va);
  _Unwind_Resume(a1);
}

void CPSDObjectEffectsLayerInfo::InitWithGradient(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CPSDActionBaseComponent *GradientOverlayObject;
  _BYTE v8[88];
  _BYTE v9[88];
  _BYTE v10[88];

  *(_QWORD *)(a1 + 40) = 0x6C6678323842494DLL;
  *(_QWORD *)(a1 + 120) = 0x1000000000;
  *(_DWORD *)(a1 + 84) = 1853189228;
  v4 = operator new(72, 0x10B1C403C8C186CLL);
  *(_DWORD *)(v4 + 16) = 0;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_QWORD *)v4 = &off_1E41A96A8;
  *(_DWORD *)(v4 + 56) = 592474723;
  *(_QWORD *)(v4 + 64) = 0x4059000000000000;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v10, 1399024672, (CPSDActionBaseComponent *)v4);
  CPSDActionDescriptor::AdoptItem((CPSDActionDescriptor *)a1, (CPSDActionKeyedItem *)v10);
  v5 = operator new(64, 0x10B1C40B4161B10);
  *(_DWORD *)(v5 + 16) = 0;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_QWORD *)v5 = &off_1E41A9390;
  *(_BYTE *)(v5 + 56) = 1;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v9, "masterFXSwitch", (CPSDActionBaseComponent *)v5);
  v6 = CPSDActionDescriptor::AdoptItem((CPSDActionDescriptor *)a1, (CPSDActionKeyedItem *)v9);
  GradientOverlayObject = CPSDObjectEffectsLayerInfo::MakeGradientOverlayObject(v6, a2);
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v8, 1198671468, GradientOverlayObject);
  CPSDActionDescriptor::AdoptItem((CPSDActionDescriptor *)a1, (CPSDActionKeyedItem *)v8);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v8);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v9);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v10);
}

void sub_19EC0CDB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v2 - 120));
  _Unwind_Resume(a1);
}

uint64_t CPSDAdditionalLayerInfoItem::SizeUpItem(CPSDAdditionalLayerInfoItem *this)
{
  int v2;
  uint64_t v3;
  size_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  char *v8;

  v2 = CPSDBaseComponent::ComputeSize(this);
  v3 = v2 & 3;
  if ((v2 & 3) != 0)
  {
    v4 = 4 - v3;
    v6 = *((_QWORD *)this + 3);
    v5 = (void *)*((_QWORD *)this + 4);
    v7 = v6 + 4 - v3;
    *((_QWORD *)this + 3) = v7;
    v8 = (char *)malloc_type_realloc(v5, v7, 0x1F095122uLL);
    *((_QWORD *)this + 4) = v8;
    bzero(&v8[v6], v4);
  }
  else
  {
    LODWORD(v4) = 0;
  }
  *((_DWORD *)this + 4) = v2 + v4 - 12;
  return (v2 + v4 - 12);
}

void CPSDFile::AddLayerGroupEnd(CPSDFile *this, const UniChar **a2, char a3, int a4)
{
  CPSDFile::AddSectionDivider(this, 1, a2, a3, a4);
}

void CPSDFile::AddSectionDivider(CPSDFile *this, int a2, const UniChar **a3, char a4, int a5)
{
  uint64_t v9;
  CPSDLayerChannelGroup *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v22[2];
  __int128 v23;
  _QWORD v24[4];
  __int16 v25;
  _OWORD v26[2];
  uint64_t v27;
  void (**v28)(CPSDLayerMaskData *__hidden);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (**v32)(CPSDLayerBlendingRanges *__hidden);
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[34];
  int v39;
  uint64_t v40;

  v9 = *((unsigned __int16 *)this + 134);
  v24[2] = 0;
  v24[3] = 0;
  v24[0] = &off_1E41A9120;
  memset(v26, 0, sizeof(v26));
  v27 = 0;
  v28 = &off_1E41A9350;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = off_1E41A9CC0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38[32] = &off_1E41A9BB0;
  v39 = 0;
  v40 = 0;
  bzero(v38, 0x100uLL);
  v25 = 4;
  std::vector<CPSDChannelLengthInfo>::resize((uint64_t)v26, 4uLL);
  std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 296, ((uint64_t)(*((_QWORD *)this + 38) - *((_QWORD *)this + 37)) >> 3) + 1);
  v10 = (CPSDLayerChannelGroup *)operator new(40, 0x10A1C401A1F3E30);
  CPSDLayerChannelGroup::CPSDLayerChannelGroup(v10, (CPSDLayerRecord *)v24);
  *(_OWORD *)v22 = 0u;
  v23 = 0u;
  CPSDLayerChannelGroup::Init((uint64_t)v10, v22, 0);
  v11 = 0;
  v12 = 0;
  v13 = &v40;
  *(_QWORD *)(*((_QWORD *)this + 37) + 8 * v9) = v10;
  do
  {
    v14 = *(_QWORD *)&v26[0];
    v15 = CPSDLayerChannelGroup::ComputeSizeForChannel(v10, v12);
    v16 = v14 + v11;
    *(_WORD *)(v16 + 16) = v12 - 1;
    *(_DWORD *)(v16 + 20) = v15;
    ++v12;
    v11 += 24;
  }
  while (v12 != 4);
  v17 = operator new(72, 0x10B1C40B9FD2085);
  v18 = v17;
  *(_DWORD *)(v17 + 16) = 0;
  *(_OWORD *)(v17 + 40) = 0u;
  *(_OWORD *)(v17 + 24) = 0u;
  *(_QWORD *)v17 = &off_1E41A9540;
  *(_DWORD *)(v17 + 60) = 0;
  *(_DWORD *)(v17 + 64) = 0;
  *(_QWORD *)(v17 + 40) = 0x6C7363743842494DLL;
  *(_DWORD *)(v17 + 56) = a2;
  if ((a2 - 1) <= 1)
  {
    *(_DWORD *)(v17 + 16) = 12;
    *(_DWORD *)(v17 + 60) = 943868237;
    *(_DWORD *)(v17 + 64) = a5;
  }
  CPSDAdditionalLayerInfoItem::SizeUpItem((CPSDAdditionalLayerInfoItem *)v17);
  v19 = v40;
  if (v40)
  {
    do
    {
      v20 = v19;
      v19 = *(_QWORD *)(v19 + 48);
    }
    while (v19);
    v13 = (uint64_t *)(v20 + 48);
  }
  *v13 = v18;
  CPSDFile::AddLayerCore(this, (CPSDLayerRecord *)v24, a3, a4, 1852797549);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)v24);
}

void sub_19EC0D0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)va);
  _Unwind_Resume(a1);
}

_WORD *CPSDFile::AddLayerGroupStart(CPSDFile *this)
{
  _WORD *result;
  const UniChar *v3;
  _WORD *v4;

  v4 = 0;
  CPSDString::AllocateCharData((CPSDString *)&v3, 1u);
  *v4 = 0;
  CPSDFile::AddSectionDivider(this, 3, &v3, 255, 1885434739);
  result = v4;
  if (v4)
    return (_WORD *)MEMORY[0x1A1AEEAF0](v4, 0x1000C80BDFB0063);
  return result;
}

void sub_19EC0D1A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    MEMORY[0x1A1AEEAF0](a10, 0x1000C80BDFB0063);
  _Unwind_Resume(exception_object);
}

CPSDBaseComponent *CPSDFile::AddOrUpdateSlices(CPSDFile *this, int32x4_t *a2, int a3)
{
  return CPSDImageResources::AddOrUpdateSlices((CPSDFile *)((char *)this + 192), a2, a3, *((_DWORD *)this + 37), *((_DWORD *)this + 36));
}

CPSDBaseComponent *CPSDImageResources::AddOrUpdateSlices(CPSDImageResources *this, int32x4_t *a2, int a3, int a4, int a5)
{
  uint64_t v10;
  uint64_t *v11;
  CPSDSlicesResourceItem *v12;
  uint64_t v13;
  uint64_t v14;
  CPSDSlicesResourceItem *v15;
  CStdException *exception;

  v11 = (uint64_t *)((char *)this + 24);
  v10 = *((_QWORD *)this + 3);
  if (v10)
  {
    while (*(_WORD *)(v10 + 20) != 1050)
    {
      v10 = *(_QWORD *)(v10 + 296);
      if (!v10)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v10 = operator new(304, 0x10A1C4050C531E5);
    *(_QWORD *)v10 = &off_1E41A9B30;
    *(_DWORD *)(v10 + 280) = 0;
    *(_BYTE *)(v10 + 22) = 0;
    *(_QWORD *)(v10 + 288) = 0;
    *(_QWORD *)(v10 + 296) = 0;
    *(_DWORD *)(v10 + 16) = 943868237;
    *(_WORD *)(v10 + 20) = 1050;
    v12 = (CPSDSlicesResourceItem *)operator new(120, 0x10B1C40B2DFEBF7);
    CPSDSlicesResourceItem::CPSDSlicesResourceItem(v12, (CPSDImageResourceBlock *)v10, 0);
    *(_QWORD *)(v10 + 288) = v12;
    v13 = *v11;
    if (*v11)
    {
      do
      {
        v14 = v13;
        v13 = *(_QWORD *)(v13 + 296);
      }
      while (v13);
      v11 = (uint64_t *)(v14 + 296);
    }
    *v11 = v10;
  }
  v15 = *(CPSDSlicesResourceItem **)(v10 + 288);
  if (!v15)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  CPSDSlicesResourceItem::AddOrUpdateSlices(v15, a2, a3, a4, a5);
  return CPSDImageResources::UpdateResourceSize(this, v15);
}

void sub_19EC0D32C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CPSDBaseComponent *CPSDFile::UpdateSliceNameAtIndex(CPSDFile *this, const unsigned __int16 *a2, unsigned int a3, unsigned int a4)
{
  return CPSDImageResources::UpdateSliceNameAtIndex((CPSDFile *)((char *)this + 192), a2, a3, a4);
}

CPSDBaseComponent *CPSDImageResources::UpdateSliceNameAtIndex(CPSDImageResources *this, const unsigned __int16 *a2, unsigned int a3, unsigned int a4)
{
  CPSDSlicesResourceItem *v8;

  v8 = (CPSDSlicesResourceItem *)CPSDImageResources::LookupResourceWithResID(this, 1050);
  CPSDSlicesResourceItem::UpdateSliceNameAtIndex(v8, a2, a3, a4);
  return CPSDImageResources::UpdateResourceSize(this, v8);
}

size_t CPSDFile::Dump(CPSDFile *this, __sFILE *__stream)
{
  uint64_t v4;

  fwrite("{ PSDFile: \n", 0xCuLL, 1uLL, __stream);
  fprintf(__stream, "Header: { %dx%d %d bps, %d channels, mode = %d }\n", *((_DWORD *)this + 36), *((_DWORD *)this + 37), *((unsigned __int16 *)this + 76), *((unsigned __int16 *)this + 70), *((unsigned __int16 *)this + 77));
  if (*((_DWORD *)this + 44))
    fprintf(__stream, "{ ColorModeData:       [ %d ] bytes }\n", *((_DWORD *)this + 44));
  v4 = *((_QWORD *)this + 27);
  if (v4)
    (*(void (**)(uint64_t, __sFILE *))(*(_QWORD *)v4 + 40))(v4, __stream);
  CPSDLayerAndMaskInfo::Dump((CPSDFile *)((char *)this + 224), __stream);
  return fwrite("}\n", 2uLL, 1uLL, __stream);
}

uint64_t CPSDHeader::Dump(CPSDHeader *this, __sFILE *a2)
{
  return fprintf(a2, "Header: { %dx%d %d bps, %d channels, mode = %d }\n", *((_DWORD *)this + 8), *((_DWORD *)this + 9), *((unsigned __int16 *)this + 20), *((unsigned __int16 *)this + 14), *((unsigned __int16 *)this + 21));
}

uint64_t CPSDColorModeData::Dump(uint64_t this, __sFILE *a2)
{
  if (*(_DWORD *)(this + 16))
    return fprintf(a2, "{ ColorModeData:       [ %d ] bytes }\n", *(_DWORD *)(this + 16));
  return this;
}

uint64_t CPSDImageResources::Dump(CPSDImageResources *this, __sFILE *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
    return (*(uint64_t (**)(uint64_t, __sFILE *))(*(_QWORD *)result + 40))(result, a2);
  return result;
}

uint64_t CPSDLayerAndMaskInfo::Dump(CPSDLayerAndMaskInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ LayerAndMaskInfo: [%d bytes]\n", *((_DWORD *)this + 4));
  CPSDLayerInfo::Dump((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
  return fputc(125, a2);
}

uint64_t CPSDFile::Load(CPSDFile *this, uint64_t a2)
{
  if (!CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2)
    || !CPSDColorModeData::Load((CPSDFile *)((char *)this + 160), a2)
    || !CPSDImageResources::Load((CPSDFile *)((char *)this + 192), a2)
    || !CPSDLayerAndMaskInfo::Load((CPSDFile *)((char *)this + 224), a2))
  {
    return 0;
  }
  (*(void (**)(CPSDFile *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 48))(this, *((unsigned int *)this + 37), *((unsigned int *)this + 36), *((unsigned __int16 *)this + 70), *((unsigned __int16 *)this + 76), *((unsigned __int16 *)this + 77), *((_QWORD *)this + 23));
  return CPSDFile::LoadImageData(this, a2, 0);
}

uint64_t CPSDHeader::Load(CPSDHeader *this, int a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v13;

  v13 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v13);
  LOBYTE(v4) = 0;
  v5 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v5);
  if (v5 == 1397768760)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 2uLL, &v13);
    v6 = *((unsigned __int16 *)this + 10);
    *((_WORD *)this + 10) = __rev16(v6);
    if (v6 != 256)
      goto LABEL_9;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 22, 6uLL, &v13);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 2uLL, &v13);
    v7 = bswap32(*((unsigned __int16 *)this + 14)) >> 16;
    *((_WORD *)this + 14) = v7;
    if ((unsigned __int16)(v7 - 25) < 0xFFE8u)
      goto LABEL_9;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 4uLL, &v13);
    v8 = bswap32(*((_DWORD *)this + 8));
    *((_DWORD *)this + 8) = v8;
    if (v8 - 30001 < 0xFFFF8AD0)
      goto LABEL_9;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 36, 4uLL, &v13);
    v9 = bswap32(*((_DWORD *)this + 9));
    *((_DWORD *)this + 9) = v9;
    if (v9 - 30001 < 0xFFFF8AD0)
      goto LABEL_9;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 40, 2uLL, &v13);
    LOBYTE(v4) = 0;
    v10 = bswap32(*((unsigned __int16 *)this + 20)) >> 16;
    *((_WORD *)this + 20) = v10;
    if (v10 <= 0x10 && ((1 << v10) & 0x10102) != 0)
    {
      CPSDBaseComponent::ReadFile(a2, (char *)this + 42, 2uLL, &v13);
      v11 = bswap32(*((unsigned __int16 *)this + 21)) >> 16;
      *((_WORD *)this + 21) = v11;
      if (v11 > 9)
      {
LABEL_9:
        LOBYTE(v4) = 0;
        return v4;
      }
      if (v11 > 6)
        LOBYTE(v4) = 1;
      else
        return (0x101010100uLL >> (8 * v11));
    }
  }
  return v4;
}

uint64_t CPSDColorModeData::Load(CPSDColorModeData *this, int a2)
{
  int v4;
  unsigned int *v5;
  unsigned int v6;
  off_t v7;
  void *v8;
  size_t v9;
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  int v13;

  v13 = 0;
  v4 = *(unsigned __int16 *)(*((_QWORD *)this + 1) + 154);
  v5 = (unsigned int *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v13);
  v6 = *((_DWORD *)this + 4);
  v7 = bswap32(v6);
  *((_DWORD *)this + 4) = v7;
  if (!v6)
    return 1;
  if (v4 != 2 || v6 != 196608)
    return SetFilePointer(a2, v7, 0, 1) != -1;
  v8 = (void *)*((_QWORD *)this + 3);
  if (v8)
  {
    free(v8);
    v9 = *v5;
  }
  else
  {
    v9 = 768;
  }
  result = (uint64_t)malloc_type_malloc(v9, 0x366AB81EuLL);
  *((_QWORD *)this + 3) = result;
  if (result)
  {
    v11 = *v5;
    if (v11)
    {
      v12 = 0;
      do
      {
        CPSDBaseComponent::ReadFile(a2, (char *)(*((_QWORD *)this + 3) + v12), v11, &v13);
        v12 += v13;
        v11 -= v13;
      }
      while (v11);
    }
    return 1;
  }
  return result;
}

BOOL CPSDImageResources::Load(CPSDImageResources *this, uint64_t a2)
{
  _DWORD *v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  CStdException *exception;
  unsigned int v15;

  v15 = 0;
  v4 = (_DWORD *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v15);
  v5 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v5);
  if (!v5)
    return 1;
  v6 = SetFilePointer(a2, 0, 0, 1);
  v7 = *((_DWORD *)this + 4);
  if (v7 >= 2)
  {
    v8 = (uint64_t *)((char *)this + 24);
    do
    {
      v9 = operator new(304, 0x10A1C4050C531E5);
      *(_QWORD *)v9 = &off_1E41A9B30;
      *(_DWORD *)(v9 + 16) = 0;
      *(_WORD *)(v9 + 20) = 0;
      *(_DWORD *)(v9 + 280) = 0;
      *(_BYTE *)(v9 + 22) = 0;
      *(_QWORD *)(v9 + 288) = 0;
      *(_QWORD *)(v9 + 296) = 0;
      v15 = 0;
      if (!CPSDImageResourceBlock::Load((CPSDImageResourceBlock *)v9, a2, &v15))
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      v10 = *v8;
      v11 = v8;
      if (*v8)
      {
        do
        {
          v12 = v10;
          v10 = *(_QWORD *)(v10 + 296);
        }
        while (v10);
        v11 = (uint64_t *)(v12 + 296);
      }
      v7 -= v15;
      *v11 = v9;
    }
    while (v7 > 1);
  }
  return !v7 || SetFilePointer(a2, (*v4 + v6), 0, 0) != -1;
}

void sub_19EC0DA78(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerAndMaskInfo::Load(CPSDLayerAndMaskInfo *this, uint64_t a2)
{
  unsigned int *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  int v14;

  v14 = 0;
  v4 = (unsigned int *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v14);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  v5 = 1;
  v6 = SetFilePointer(a2, 0, 0, 1);
  if (*((_DWORD *)this + 4))
  {
    v7 = v6;
    if (!CPSDLayerInfo::Load((CPSDLayerAndMaskInfo *)((char *)this + 24), a2))
      return 0;
    v8 = SetFilePointer(a2, 0, 0, 1);
    if (*v4 < v8 - v7)
      return 0;
    CPSDGlobalLayerMaskInfo::Load((CPSDLayerAndMaskInfo *)((char *)this + 96), a2, *v4 - (v8 - v7));
    v9 = SetFilePointer(a2, 0, 0, 1) - v7;
    v10 = *((_DWORD *)this + 4);
    v11 = v10 >= v9;
    v12 = v10 - v9;
    if (!v11)
      return 0;
    if (v12)
    {
      *((_DWORD *)this + 38) = v12;
      if (!CPSDAdditionalLayerInfo::Load((CPSDLayerAndMaskInfo *)((char *)this + 136), a2))
        return 0;
      v9 = *v4;
    }
    SetFilePointer(a2, v9 + v7, 0, 0);
  }
  return v5;
}

uint64_t CPSDFile::LoadImageData(CPSDFile *this, int a2, int a3)
{
  unsigned int v6;
  uint64_t result;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  void *v12;
  void *v13;
  int v14;

  if (!*((_BYTE *)this + 32))
    return 0;
  v14 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 88, 2uLL, &v14);
  *((_WORD *)this + 44) = bswap32(*((unsigned __int16 *)this + 44)) >> 16;
  v6 = *((unsigned __int16 *)this + 28);
  if (!a3 || (result = 0, v6 <= 8))
  {
    v8 = *((_DWORD *)this + 10) * v6;
    if ((v8 & 0xFFFFFFF8) >= v8)
      v9 = v8 >> 3;
    else
      v9 = (v8 >> 3) + 1;
    v10 = SetFilePointer(a2, 0, 0, 1);
    v11 = SetFilePointer(a2, 0, 0, 2) - v10;
    *((_QWORD *)this + 3) = v11;
    v12 = (void *)*((_QWORD *)this + 2);
    if (v12)
    {
      free(v12);
      v11 = *((_DWORD *)this + 6);
    }
    v13 = malloc_type_malloc(v11, 0x16CD93EFuLL);
    *((_QWORD *)this + 2) = v13;
    if (!v13)
      CPSDFile::LoadImageData();
    SetFilePointer(a2, v10, 0, 0);
    CPSDBaseComponent::ReadFile(a2, *((char **)this + 2), *((unsigned int *)this + 6), &v14);
    CPSDImageLoad::AllocateChannelBuffers(this, v9);
    if (a3)
      CPSDImageLoad::FillLayerImageChannelBuffers(this, v9);
    else
      CPSDImageLoad::FillCompositeImageChannelBuffers(this, v9);
    CPSDImageLoad::CreatePlanarBitmap(this);
    CPSDImageLoad::DeAllocateChannelBuffers(this);
    SetFilePointer(a2, *((_DWORD *)this + 7) + v10, 0, 0);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::Save(CPSDFile *this, int a2)
{
  _BYTE v4[2072];

  File::File((File *)v4, a2, 2);
  (*(void (**)(CPSDFile *, _BYTE *))(*(_QWORD *)this + 24))(this, v4);
  File::~File((File *)v4);
  return 1;
}

uint64_t CPSDFile::Save(void **this, File *a2)
{
  CPSDHeader::Save((CPSDHeader *)(this + 14), a2);
  CPSDColorModeData::Save((CPSDColorModeData *)(this + 20), a2);
  CPSDImageResources::Save((CPSDImageResources *)(this + 24), a2);
  CPSDLayerAndMaskInfo::Save((CPSDLayerAndMaskInfo *)(this + 28), a2);
  CPSDFile::CompositeImageData(this);
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 44));
  return (*(uint64_t (**)(File *, void *, _QWORD))(*(_QWORD *)a2 + 48))(a2, this[2], *((unsigned int *)this + 6));
}

uint64_t CPSDHeader::Save(CPSDHeader *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 10));
  (*(void (**)(File *, char *, uint64_t))(*(_QWORD *)a2 + 48))(a2, (char *)this + 22, 6);
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 14));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 8));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 9));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 20));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 21));
}

uint64_t CPSDColorModeData::Save(CPSDColorModeData *this, File *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_QWORD *)this + 3))
  {
    if (*((_DWORD *)this + 4))
      return (*(uint64_t (**)(File *))(*(_QWORD *)a2 + 48))(a2);
  }
  return result;
}

uint64_t CPSDImageResources::Save(CPSDImageResources *this, File *a2)
{
  uint64_t v4;
  _QWORD *i;
  uint64_t result;
  unint64_t v7;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  v4 = (*(uint64_t (**)(File *))(*(_QWORD *)a2 + 16))(a2);
  for (i = (_QWORD *)*((_QWORD *)this + 3); i; i = (_QWORD *)i[37])
    (*(void (**)(_QWORD *, File *))(*i + 24))(i, a2);
  result = (*(uint64_t (**)(File *))(*(_QWORD *)a2 + 16))(a2);
  v7 = *((unsigned int *)this + 4);
  if (v7 > result - v4)
    return (*(uint64_t (**)(File *, unint64_t))(*(_QWORD *)a2 + 56))(a2, v7 - (result - v4));
  return result;
}

uint64_t CPSDLayerAndMaskInfo::Save(CPSDLayerAndMaskInfo *this, File *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4))
  {
    CPSDLayerInfo::Save((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
    CPSDGlobalLayerMaskInfo::Save((CPSDLayerAndMaskInfo *)((char *)this + 96), a2);
    return CPSDAdditionalLayerInfo::Save((uint64_t)this + 136, a2);
  }
  return result;
}

uint64_t CPSDFile::LoadLayers(CPSDFile *this, uint64_t a2)
{
  if (CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2)
    && CPSDColorModeData::Load((CPSDFile *)((char *)this + 160), a2)
    && CPSDImageResources::Load((CPSDFile *)((char *)this + 192), a2))
  {
    return CPSDLayerAndMaskInfo::Load((CPSDFile *)((char *)this + 224), a2);
  }
  else
  {
    return 0;
  }
}

uint64_t CPSDLayerAndMaskInfo::LoadLayer(CPSDLayerAndMaskInfo *this, uint64_t a2)
{
  uint64_t v4;
  int v6;

  v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v6);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  v4 = 1;
  SetFilePointer(a2, 0, 0, 1);
  if (*((_DWORD *)this + 4))
    return CPSDLayerInfo::LoadLayer((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
  return v4;
}

uint64_t CPSDFile::ValidateFormat(CPSDFile *this, int a2)
{
  return CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2);
}

BOOL CPSDFile::ValidateIsDrawable(CPSDFile *this)
{
  return *((_WORD *)this + 77) == 3 && *((unsigned __int16 *)this + 76) == 8;
}

uint64_t CPSDFile::GetImageInfo(CPSDFile *this, int a2, unsigned int *a3, unsigned int *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int16 *a7)
{
  unsigned int v14;
  uint64_t result;

  v14 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, 0, 0, 0);
  result = CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2);
  if ((_DWORD)result)
  {
    if (a7)
      *a7 = *((_WORD *)this + 70);
    if (a3)
      *a3 = *((_DWORD *)this + 36);
    if (a4)
      *a4 = *((_DWORD *)this + 37);
    if (a6)
      *a6 = *((_WORD *)this + 77);
    if (a5)
      *a5 = *((_WORD *)this + 76);
    SetFilePointer(a2, v14, 0, 0);
    return 1;
  }
  return result;
}

BOOL CPSDFile::IsTaggedWithICCProfile(CPSDFile *this)
{
  uint64_t v1;
  CPSDImageResources *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 27);
  if (!v1)
    return 0;
  v2 = (CPSDFile *)((char *)this + 192);
  v3 = v1;
  while (*(_WORD *)(v3 + 20) != 1039)
  {
    v3 = *(_QWORD *)(v3 + 296);
    if (!v3)
      return 0;
  }
  while (*(_WORD *)(v1 + 20) != 1041)
  {
    v1 = *(_QWORD *)(v1 + 296);
    if (!v1)
      return 1;
  }
  v4 = CPSDImageResources::LookupResourceWithResID(v2, 1041);
  return !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
}

uint64_t CPSDImageResources::LookupResourceWithResID(CPSDImageResources *this, int a2)
{
  uint64_t v2;
  CStdException *exception;

  v2 = *((_QWORD *)this + 3);
  if (!v2)
  {
LABEL_4:
    fprintf(__stderrp, "CPSDImageResources::LookupResourceWithResID() failed to locate resource with resID=%d\n", a2);
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238395925);
  }
  while (*(unsigned __int16 *)(v2 + 20) != a2)
  {
    v2 = *(_QWORD *)(v2 + 296);
    if (!v2)
      goto LABEL_4;
  }
  return *(_QWORD *)(v2 + 288);
}

void sub_19EC0E3C4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDFile::GetICCProfile(CPSDFile *this)
{
  return CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1039);
}

uint64_t CPSDFile::GetGlobalLightAngle(CPSDFile *this)
{
  uint64_t v1;
  CPSDImageResources *v2;
  uint64_t v4;

  v1 = *((_QWORD *)this + 27);
  if (!v1)
    return 120;
  v2 = (CPSDFile *)((char *)this + 192);
  while (*(_WORD *)(v1 + 20) != 1037)
  {
    v1 = *(_QWORD *)(v1 + 296);
    if (!v1)
      return 120;
  }
  v4 = CPSDImageResources::LookupResourceWithResID(v2, 1037);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
}

uint64_t CPSDFile::GetGlobalLightAltitude(CPSDFile *this)
{
  uint64_t v1;
  CPSDImageResources *v2;
  uint64_t v4;

  v1 = *((_QWORD *)this + 27);
  if (!v1)
    return 30;
  v2 = (CPSDFile *)((char *)this + 192);
  while (*(_WORD *)(v1 + 20) != 1049)
  {
    v1 = *(_QWORD *)(v1 + 296);
    if (!v1)
      return 30;
  }
  v4 = CPSDImageResources::LookupResourceWithResID(v2, 1049);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
}

uint64_t CPSDFile::GetLayerBounds(uint64_t a1, unsigned int a2, int32x4_t *a3)
{
  if (*(unsigned __int16 *)(a1 + 268) <= a2)
    return 0;
  *a3 = vrev64q_s32(*(int32x4_t *)(*(_QWORD *)(a1 + 272) + 488 * a2 + 16));
  return 1;
}

uint64_t CPSDFile::LookupSliceWithNumber(CPSDFile *this, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;

  v3 = CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1050);
  v4 = *(_DWORD *)(v3 + 88) - 1;
  if (v4 >= a2)
    v4 = a2;
  return *(_QWORD *)(*(_QWORD *)(v3 + 104) + 8 * v4);
}

uint64_t CPSDFile::GetSliceCount(CPSDFile *this)
{
  uint64_t v1;
  CPSDImageResources *v2;

  v1 = *((_QWORD *)this + 27);
  if (!v1)
    return 0;
  v2 = (CPSDFile *)((char *)this + 192);
  while (*(_WORD *)(v1 + 20) != 1050)
  {
    v1 = *(_QWORD *)(v1 + 296);
    if (!v1)
      return 0;
  }
  return *(unsigned int *)(CPSDImageResources::LookupResourceWithResID(v2, 1050) + 88);
}

uint64_t CPSDFile::GetLayerIsSectionDivider(CPSDFile *this, unsigned int a2, BOOL *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  *a3 = CPSDLayerRecord::GetSectionDivider((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2)) != 0;
  return 1;
}

uint64_t CPSDFile::GetLayerSectionDividerType(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  _QWORD *SectionDivider;
  unsigned int v5;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  SectionDivider = CPSDLayerRecord::GetSectionDivider((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (SectionDivider)
    v5 = *((_DWORD *)SectionDivider + 14);
  else
    v5 = 0;
  *a3 = v5;
  return 1;
}

uint64_t CPSDFile::GetLayerIsVisible(CPSDFile *this, unsigned int a2, BOOL *a3)
{
  unsigned int v3;
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  v3 = *(unsigned __int8 *)(*((_QWORD *)this + 34) + 488 * a2 + 74);
  result = 1;
  *a3 = ((v3 >> 1) & 1) == 0;
  return result;
}

uint64_t CPSDFile::GetLayerOpacity(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  *a3 = *(_BYTE *)(*((_QWORD *)this + 34) + 488 * a2 + 72);
  return 1;
}

uint64_t CPSDFile::GetLayerGradientStyle(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetStyle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

_QWORD *CPSDLayerRecord::GetGradientFillInfo(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
      break;
  }
  return i;
}

uint64_t CPSDGradientDescriptor::GetStyle(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return CPSDOSTypeEnumerated::GetEnum(0);
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1417244773)
  {
    if (v1 <= ++v2)
      return CPSDOSTypeEnumerated::GetEnum(0);
  }
  return CPSDOSTypeEnumerated::GetEnum(*(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80));
}

uint64_t CPSDFile::GetLayerGradientAngle(CPSDFile *this, unsigned int a2, double *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetAngle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

double CPSDGradientDescriptor::GetAngle(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 0.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1097754476)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientSmoothing(CPSDFile *this, unsigned int a2, double *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetSmoothness((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

double CPSDGradientDescriptor::GetSmoothness(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *((_DWORD *)this + 22);
  if (v1)
  {
    v2 = 0;
    v3 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1198678372)
    {
      if (v1 <= ++v2)
        goto LABEL_5;
    }
    v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  }
  else
  {
LABEL_5:
    v4 = 0;
  }
  v5 = *(_DWORD *)(v4 + 88);
  if (!v5)
    return 1.0;
  v6 = 0;
  v7 = *(_QWORD *)(v4 + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1231975538)
  {
    if (v5 <= ++v6)
      return 1.0;
  }
  v8 = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (v8)
    return round(*(double *)(v8 + 56) * 0.000244140625);
  else
    return 1.0;
}

uint64_t CPSDFile::GetLayerGradientColorStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v5;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    v5 = *(_DWORD *)(result + 88);
    if (v5)
      v5 = *(_DWORD *)(result + 120);
    *a3 = v5;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientColorStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  CPSDGradientDescriptor *GradientFillInfo;

  if (*((unsigned __int16 *)this + 134) > a2
    && (GradientFillInfo = (CPSDGradientDescriptor *)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2))) != 0)
  {
    return CPSDGradientDescriptor::GetColorStopAtIndex(GradientFillInfo, a3, a4, a5, a6);
  }
  else
  {
    return 0;
  }
}

uint64_t CPSDGradientDescriptor::GetColorStopAtIndex(CPSDGradientDescriptor *this, unsigned int a2, double *a3, double *a4, double *a5)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  unsigned __int16 v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  unsigned __int16 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int16 v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  double v37;

  result = 0;
  if (a3 && a4 && a5)
  {
    v7 = *((_QWORD *)this + 12);
    if (*(_DWORD *)(v7 + 60) == 1198678372)
    {
      v8 = 0;
    }
    else
    {
      v9 = 0;
      do
        v8 = (unsigned __int16)++v9;
      while (*(_DWORD *)(v7 + 88 * (unsigned __int16)v9 + 60) != 1198678372);
    }
    v10 = *(_QWORD *)(*(_QWORD *)(v7 + 88 * v8 + 80) + 96);
    if (*(_DWORD *)(v10 + 60) == 1131180659)
    {
      v11 = 0;
    }
    else
    {
      v12 = 0;
      do
        v11 = (unsigned __int16)++v12;
      while (*(_DWORD *)(v10 + 88 * (unsigned __int16)v12 + 60) != 1131180659);
    }
    v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 88 * v11 + 80) + 64) + 8 * a2);
    v14 = *(_QWORD *)(v13 + 96);
    if (*(_DWORD *)(v14 + 60) == 1131180576)
    {
      v15 = 0;
    }
    else
    {
      v16 = 0;
      do
        v15 = (unsigned __int16)++v16;
      while (*(_DWORD *)(v14 + 88 * (unsigned __int16)v16 + 60) != 1131180576);
    }
    v17 = 0;
    v18 = *(_DWORD *)(v13 + 88);
    v19 = *(_QWORD *)(v14 + 88 * v15 + 80);
    v20 = *(_DWORD *)(v19 + 88);
    v21 = *(_QWORD *)(v19 + 96);
    while (*(_DWORD *)(v21 + 88 * v17 + 60) != 1382293536)
    {
      if (v20 <= ++v17)
      {
        v22 = 0;
        goto LABEL_21;
      }
    }
    v22 = *(_QWORD *)(v21 + 88 * v17 + 80);
LABEL_21:
    v23 = 0;
    while (*(_DWORD *)(v21 + 88 * v23 + 60) != 1198681632)
    {
      if (v20 <= ++v23)
      {
        v24 = 0;
        goto LABEL_26;
      }
    }
    v24 = *(_QWORD *)(v21 + 88 * v23 + 80);
LABEL_26:
    if (*(_DWORD *)(v21 + 60) == 1114382368)
    {
      v25 = 0;
    }
    else
    {
      v26 = 0;
      do
        v25 = (unsigned __int16)++v26;
      while (*(_DWORD *)(v21 + 88 * (unsigned __int16)v26 + 60) != 1114382368);
    }
    v27 = 0;
    v28 = *(_QWORD *)(v22 + 56);
    v29 = *(_QWORD *)(v24 + 56);
    v30 = *(_QWORD *)(*(_QWORD *)(v21 + 88 * v25 + 80) + 56);
    *(_QWORD *)a3 = v28;
    *((_QWORD *)a3 + 1) = v29;
    *((_QWORD *)a3 + 2) = v30;
    a3[3] = 1.0;
    v31 = *(_QWORD *)(v13 + 96);
    while (1)
    {
      v32 = v27;
      if (*(_DWORD *)(v31 + 88 * v27 + 60) == 1281586286)
        break;
      ++v27;
      if (v18 <= (unsigned __int16)(v32 + 1))
      {
        v33 = 0;
        goto LABEL_35;
      }
    }
    v33 = *(_QWORD *)(v31 + 88 * v27 + 80);
LABEL_35:
    if (*(_DWORD *)(v31 + 60) == 1298428014)
    {
      v34 = 0;
    }
    else
    {
      v35 = 0;
      do
        v34 = (unsigned __int16)++v35;
      while (*(_DWORD *)(v31 + 88 * (unsigned __int16)v35 + 60) != 1298428014);
    }
    v36 = *(_QWORD *)(v31 + 88 * v34 + 80);
    LODWORD(v28) = *(_DWORD *)(v33 + 56);
    v37 = round((double)v28 * 0.000244140625 * 100.0) / 100.0;
    *a4 = v37;
    LODWORD(v37) = *(_DWORD *)(v36 + 56);
    *a5 = (double)*(unint64_t *)&v37 / 100.0;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientOpacityStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v5;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    v5 = *(_DWORD *)(result + 88);
    if (v5)
      v5 = *(_DWORD *)(result + 124);
    *a3 = v5;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientOpacityStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  CPSDGradientDescriptor *GradientFillInfo;

  if (*((unsigned __int16 *)this + 134) > a2
    && (GradientFillInfo = (CPSDGradientDescriptor *)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2))) != 0)
  {
    return CPSDGradientDescriptor::GetOpacityStopAtIndex(GradientFillInfo, a3, a4, a5, a6);
  }
  else
  {
    return 0;
  }
}

uint64_t CPSDGradientDescriptor::GetOpacityStopAtIndex(CPSDGradientDescriptor *this, unsigned int a2, double *a3, double *a4, double *a5)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned __int16 v18;
  unsigned int v19;
  double v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  double v25;

  result = 0;
  if (a3 && a4 && a5)
  {
    v7 = *((_QWORD *)this + 12);
    if (*(_DWORD *)(v7 + 60) == 1198678372)
    {
      v8 = 0;
    }
    else
    {
      v9 = 0;
      do
        v8 = (unsigned __int16)++v9;
      while (*(_DWORD *)(v7 + 88 * (unsigned __int16)v9 + 60) != 1198678372);
    }
    v10 = *(_QWORD *)(*(_QWORD *)(v7 + 88 * v8 + 80) + 96);
    if (*(_DWORD *)(v10 + 60) == 1416785523)
    {
      v11 = 0;
    }
    else
    {
      v12 = 0;
      do
        v11 = (unsigned __int16)++v12;
      while (*(_DWORD *)(v10 + 88 * (unsigned __int16)v12 + 60) != 1416785523);
    }
    v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 88 * v11 + 80) + 64) + 8 * a2);
    v14 = *(_QWORD *)(v13 + 96);
    v15 = *(_DWORD *)(v14 + 60);
    if (v15 == 1332765556)
    {
      v16 = 0;
    }
    else
    {
      v17 = 0;
      do
        v16 = (unsigned __int16)++v17;
      while (*(_DWORD *)(v14 + 88 * (unsigned __int16)v17 + 60) != 1332765556);
    }
    v18 = 0;
    v19 = *(_DWORD *)(v13 + 88);
    v20 = round(*(double *)(*(_QWORD *)(v14 + 88 * v16 + 80) + 64));
    *a3 = v20;
    while (*(_DWORD *)(v14 + 88 * v18 + 60) != 1281586286)
    {
      if (v19 <= ++v18)
      {
        v21 = 0;
        goto LABEL_21;
      }
    }
    v21 = *(_QWORD *)(v14 + 88 * v18 + 80);
LABEL_21:
    if (v15 == 1298428014)
    {
      v22 = 0;
    }
    else
    {
      v23 = 0;
      do
        v22 = (unsigned __int16)++v23;
      while (*(_DWORD *)(v14 + 88 * (unsigned __int16)v23 + 60) != 1298428014);
    }
    v24 = *(_QWORD *)(v14 + 88 * v22 + 80);
    LODWORD(v20) = *(_DWORD *)(v21 + 56);
    v25 = round((double)*(unint64_t *)&v20 * 0.000244140625 * 100.0) / 100.0;
    *a4 = v25;
    LODWORD(v25) = *(_DWORD *)(v24 + 56);
    *a5 = (double)*(unint64_t *)&v25 / 100.0;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientBlendMode(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetBlendMode((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetBlendMode(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  CPSDOSTypeEnumerated *v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1114402381)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4)
    return CPSDOSTypeEnumerated::GetEnum(v4);
  else
    return 0;
}

uint64_t CPSDFile::GetLayerGradientIsReversed(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetIsReversed((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetIsReversed(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1383494259)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  if (v4)
    return *(unsigned __int8 *)(v4 + 56);
  else
    return 0;
}

uint64_t CPSDFile::GetLayerGradientIsDithered(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetGradientFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetIsDithered((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetIsDithered(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1148479602)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  if (v4)
    return *(unsigned __int8 *)(v4 + 56);
  else
    return 0;
}

uint64_t CPSDFile::GetLayerEffectGradientStyle(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (!result)
    return result;
  v5 = *(_DWORD *)(result + 88);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(_QWORD *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6)
      return 0;
  }
  result = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetStyle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

_QWORD *CPSDLayerRecord::GetObjectEffectsLayerInfo(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
    {
      break;
    }
  }
  return i;
}

uint64_t CPSDObjectEffectsLayerInfo::GetEffect(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned __int16 v3;
  uint64_t v4;

  v2 = *(_DWORD *)(a1 + 88);
  if (!v2)
    return 0;
  v3 = 0;
  v4 = *(_QWORD *)(a1 + 96);
  while (*(_DWORD *)(v4 + 88 * v3 + 60) != a2)
  {
    if (v2 <= ++v3)
      return 0;
  }
  return *(_QWORD *)(v4 + 88 * v3 + 80);
}

uint64_t CPSDFile::GetLayerEffectGradientAngle(CPSDFile *this, unsigned int a2, double *a3)
{
  uint64_t result;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (!result)
    return result;
  v5 = *(_DWORD *)(result + 88);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(_QWORD *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6)
      return 0;
  }
  result = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetAngle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerEffectGradientSmoothing(CPSDFile *this, unsigned int a2, double *a3)
{
  uint64_t result;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (!result)
    return result;
  v5 = *(_DWORD *)(result + 88);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(_QWORD *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6)
      return 0;
  }
  result = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetSmoothness((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerEffectGradientColorStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (!result)
    return result;
  v5 = *(_DWORD *)(result + 88);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(_QWORD *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6)
      return 0;
  }
  v8 = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (!v8)
    return 0;
  if (*(_DWORD *)(v8 + 88))
    v9 = *(_DWORD *)(v8 + 120);
  else
    v9 = 0;
  *a3 = v9;
  return 1;
}

uint64_t CPSDFile::GetLayerEffectGradientColorStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  _QWORD *ObjectEffectsLayerInfo;
  unsigned int v11;
  unsigned __int16 v12;
  uint64_t v13;
  CPSDGradientDescriptor *v14;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  ObjectEffectsLayerInfo = CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34)
                                                                                        + 488 * a2));
  if (!ObjectEffectsLayerInfo)
    return 0;
  v11 = *((_DWORD *)ObjectEffectsLayerInfo + 22);
  if (!v11)
    return 0;
  v12 = 0;
  v13 = ObjectEffectsLayerInfo[12];
  while (*(_DWORD *)(v13 + 88 * v12 + 60) != 1198671468)
  {
    if (v11 <= ++v12)
      return 0;
  }
  v14 = *(CPSDGradientDescriptor **)(v13 + 88 * v12 + 80);
  if (v14)
    return CPSDGradientDescriptor::GetColorStopAtIndex(v14, a3, a4, a5, a6);
  else
    return 0;
}

uint64_t CPSDFile::GetLayerEffectGradientOpacityStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (!result)
    return result;
  v5 = *(_DWORD *)(result + 88);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(_QWORD *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6)
      return 0;
  }
  v8 = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (!v8)
    return 0;
  if (*(_DWORD *)(v8 + 88))
    v9 = *(_DWORD *)(v8 + 124);
  else
    v9 = 0;
  *a3 = v9;
  return 1;
}

uint64_t CPSDFile::GetLayerEffectGradientOpacityStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  _QWORD *ObjectEffectsLayerInfo;
  unsigned int v11;
  unsigned __int16 v12;
  uint64_t v13;
  CPSDGradientDescriptor *v14;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  ObjectEffectsLayerInfo = CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34)
                                                                                        + 488 * a2));
  if (!ObjectEffectsLayerInfo)
    return 0;
  v11 = *((_DWORD *)ObjectEffectsLayerInfo + 22);
  if (!v11)
    return 0;
  v12 = 0;
  v13 = ObjectEffectsLayerInfo[12];
  while (*(_DWORD *)(v13 + 88 * v12 + 60) != 1198671468)
  {
    if (v11 <= ++v12)
      return 0;
  }
  v14 = *(CPSDGradientDescriptor **)(v13 + 88 * v12 + 80);
  if (v14)
    return CPSDGradientDescriptor::GetOpacityStopAtIndex(v14, a3, a4, a5, a6);
  else
    return 0;
}

uint64_t CPSDFile::GetLayerEffectGradientIsReversed(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t result;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (!result)
    return result;
  v5 = *(_DWORD *)(result + 88);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(_QWORD *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6)
      return 0;
  }
  result = *(_QWORD *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetIsReversed((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerEffectGradientBlendMode(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDObjectEffectsLayerInfo::GetBlendModeForEffect(result, 1198671468);
    return 1;
  }
  return result;
}

uint64_t CPSDObjectEffectsLayerInfo::GetBlendModeForEffect(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned __int16 v7;
  uint64_t v8;

  v2 = *(_DWORD *)(a1 + 88);
  if (!v2)
    return 0;
  v3 = 0;
  v4 = *(_QWORD *)(a1 + 96);
  while (*(_DWORD *)(v4 + 88 * v3 + 60) != a2)
  {
    if (v2 <= ++v3)
      return 0;
  }
  v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
  if (!v5)
    return 0;
  v6 = *(_DWORD *)(v5 + 88);
  if (!v6)
    return CPSDOSTypeEnumerated::GetEnum(0);
  v7 = 0;
  v8 = *(_QWORD *)(v5 + 96);
  while (*(_DWORD *)(v8 + 88 * v7 + 60) != 1298407456)
  {
    if (v6 <= ++v7)
      return CPSDOSTypeEnumerated::GetEnum(0);
  }
  return CPSDOSTypeEnumerated::GetEnum(*(CPSDOSTypeEnumerated **)(v8 + 88 * v7 + 80));
}

uint64_t CPSDFile::GetLayerEffectOpacity(CPSDFile *this, unsigned int a2, double *a3)
{
  uint64_t result;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  result = (uint64_t)CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (result)
  {
    *a3 = CPSDObjectEffectsLayerInfo::GetOpacityForEffect(result, 1198671468);
    return 1;
  }
  return result;
}

double CPSDObjectEffectsLayerInfo::GetOpacityForEffect(uint64_t a1, int a2)
{
  unsigned int v2;
  double result;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;

  v2 = *(_DWORD *)(a1 + 88);
  result = 0.0;
  if (v2)
  {
    v4 = 0;
    v5 = *(_QWORD *)(a1 + 96);
    while (*(_DWORD *)(v5 + 88 * v4 + 60) != a2)
    {
      if (v2 <= ++v4)
        return result;
    }
    v6 = *(_QWORD *)(v5 + 88 * v4 + 80);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 + 96);
      if (*(_DWORD *)(v7 + 60) == 1332765556)
      {
        v8 = 0;
      }
      else
      {
        v9 = 0;
        do
          v8 = (unsigned __int16)++v9;
        while (*(_DWORD *)(v7 + 88 * (unsigned __int16)v9 + 60) != 1332765556);
      }
      return *(double *)(*(_QWORD *)(v7 + 88 * v8 + 80) + 64);
    }
  }
  return result;
}

uint64_t CPSDFile::GetLayerFillOpacity(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  _QWORD *FillOpacityObject;
  unsigned __int8 v5;

  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  FillOpacityObject = CPSDLayerRecord::GetFillOpacityObject((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
  if (FillOpacityObject)
    v5 = *((_BYTE *)FillOpacityObject + 56);
  else
    v5 = -1;
  *a3 = v5;
  return 1;
}

uint64_t CPSDFile::GetLayerBlendMode(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  *a3 = *(_DWORD *)(*((_QWORD *)this + 34) + 488 * a2 + 68);
  return 1;
}

uint64_t CPSDFile::GetLayerRecord(CPSDFile *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  else
    return *((_QWORD *)this + 34) + 488 * a2;
}

uint64_t CPSDFile::GetIndexOfFirstLayerNamed(CPSDFile *this, const UniChar **a2, int a3, int a4)
{
  unsigned int v4;
  signed int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  BOOL v15;
  char __s2[256];
  char __s1[256];

  v4 = *((unsigned __int16 *)this + 134);
  v5 = v4 - 1;
  v6 = a3 & ~(a3 >> 31);
  if (a4 >= 0)
    v5 = a4;
  if (v5 >= v6)
    v7 = a3 & ~(a3 >> 31);
  else
    v7 = v5;
  if (v5 <= v6)
    v8 = v6;
  else
    v8 = v5;
  if (v7 >= (int)v4 || v8 >= v4)
    return 0xFFFFFFFFLL;
  if (v5 >= (uint64_t)v6)
    v12 = a3 & ~(a3 >> 31);
  else
    v12 = v5;
  v13 = 488 * v12;
  while (1)
  {
    CPSDLayerRecord::GetLayerName((CPSDLayerRecord *)(*((_QWORD *)this + 34) + v13), __s1, 0x100u);
    CPSDString::CopyStringValue(a2, __s2, 0x100u);
    if (!strcmp(__s1, __s2))
      break;
    v13 += 488;
    v15 = __OFSUB__(v12, v8);
    v14 = v12 - v8 < 0;
    ++v12;
    if (v14 == v15)
      return 0xFFFFFFFFLL;
  }
  return v12;
}

size_t CPSDLayerRecord::GetLayerName(CPSDLayerRecord *this, char *a2, unsigned int a3)
{
  const char *v5;
  size_t result;

  v5 = (char *)this + 200;
  result = strlen((const char *)this + 200);
  if (a3)
    *a2 = 0;
  if (result)
  {
    if (result <= a3)
    {
      strlcpy(a2, v5, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CPSDFile::GetLayerIndexOfParentGroup(CPSDFile *this, int a2)
{
  uint64_t v2;
  int v4;
  unsigned int v5;
  int v6;
  _QWORD *SectionDivider;

  LODWORD(v2) = a2;
  v4 = 0;
  while (1)
  {
    v5 = v2 + 1;
    v6 = *((unsigned __int16 *)this + 134);
    if ((int)v2 + 1 >= v6)
      break;
    if (v5 < v6)
    {
      SectionDivider = CPSDLayerRecord::GetSectionDivider((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * v5));
      if (SectionDivider)
      {
        v4 = *((_DWORD *)SectionDivider + 14);
        if (v4 == 3)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v4 = 0;
      }
    }
    v2 = (v2 + 1);
    if ((v4 - 1) <= 1)
      return v2;
  }
  return 0xFFFFFFFFLL;
}

_QWORD *CPSDFile::GetRangeOfChildLayers(_QWORD *this, unsigned int a2, int *a3, int *a4)
{
  int v6;
  _QWORD *v7;
  int v8;
  int v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v16;

  v6 = -1;
  *a3 = -1;
  *a4 = -1;
  if ((a2 & 0x80000000) != 0)
    goto LABEL_19;
  v7 = this;
  if (*((unsigned __int16 *)this + 134) <= a2)
  {
    v6 = -1;
    goto LABEL_19;
  }
  v8 = 0;
  v9 = 0;
  v10 = a2 - 1;
  v11 = a2;
  v12 = 488 * a2;
  while (1)
  {
    if (v11 < *((unsigned __int16 *)v7 + 134))
    {
      this = CPSDLayerRecord::GetSectionDivider((CPSDLayerRecord *)(v7[34] + v12));
      if (!this)
      {
        v9 = 0;
        goto LABEL_10;
      }
      v9 = *((_DWORD *)this + 14);
    }
    if (v9 == 3)
    {
      v13 = 1;
      goto LABEL_13;
    }
LABEL_10:
    v13 = (v9 - 1) >= 2 ? 0 : -1;
LABEL_13:
    v8 += v13;
    if (!v8)
      break;
    *a3 = v10;
    *a4 = v11;
    v14 = v11 - 1;
    v12 -= 488;
    if ((uint64_t)v11-- <= 0)
    {
      v6 = v14 + 1;
      goto LABEL_19;
    }
  }
  v6 = *a4;
LABEL_19:
  v16 = *a3;
  if (v6 < *a3)
  {
    *a3 = v6;
    *a4 = v16;
  }
  return this;
}

_QWORD *CPSDFile::GetLayerEffectsInfo(CPSDFile *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  else
    return CPSDLayerRecord::GetObjectEffectsLayerInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
}

_QWORD *CPSDFile::GetColorFillInfo(CPSDFile *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 134) <= a2)
    return 0;
  else
    return CPSDLayerRecord::GetColorFillInfo((CPSDLayerRecord *)(*((_QWORD *)this + 34) + 488 * a2));
}

_QWORD *CPSDLayerRecord::GetColorFillInfo(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
      break;
  }
  return i;
}

uint64_t CPSDFile::GetXMPMetadataString(CPSDFile *this, char **a2, unsigned int *a3)
{
  const char **v5;

  v5 = (const char **)CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1060);
  return CPSDXMPResourceItem::GetXMPString(v5, a2, a3);
}

uint64_t CPSDXMPResourceItem::GetXMPString(const char **this, char **a2, unsigned int *a3)
{
  uint64_t v3;
  char *v7;
  char *v8;
  char *v9;
  size_t v10;
  char *v11;

  v3 = 0;
  if (a2 && a3)
  {
    v7 = strnstr(this[6], "<x:xapmeta", *((unsigned int *)this + 4));
    v8 = strnstr(this[6], "</x:xapmeta>", *((unsigned int *)this + 4));
    if (!v7)
    {
      v7 = strnstr(this[6], "<x:xmpmeta", *((unsigned int *)this + 4));
      v8 = strnstr(this[6], "</x:xmpmeta>", *((unsigned int *)this + 4));
    }
    v3 = 1;
    if (v7 && v8)
    {
      v9 = strchr(v8, 10);
      v10 = v9 - v7 + 1;
      v11 = (char *)malloc_type_malloc(v9 - v7 + 2, 0xE4A56501uLL);
      *a2 = v11;
      memcpy(v11, v7, v10);
      (*a2)[v10 + 1] = 48;
      *a3 = v10;
      return 1;
    }
  }
  return v3;
}

BOOL CPSDFile::HasCompositeImage(CPSDFile *this)
{
  return *((_BYTE *)this + 32) && *((_QWORD *)this + 12) != 0;
}

void CPSDFile::GetCompositeImage(CPSDFile *this)
{
  unsigned __int8 **v1;
  uint64_t v3;
  unsigned __int8 *v4;
  int v5;
  CPSDCompositeImage *v6;

  v1 = (unsigned __int8 **)*((_QWORD *)this + 12);
  if (v1)
  {
    *((_QWORD *)this + 12) = 0;
    if (CPSDFile::IsTaggedWithICCProfile(this))
    {
      v3 = CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1039);
      v4 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
      v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    v6 = (CPSDCompositeImage *)operator new(56, 0x1091C4014DB3CA4);
    CPSDCompositeImage::CPSDCompositeImage(v6, (CPSDFile *)((char *)this + 112), v1, *((unsigned __int8 *)this + 104), v5, v4);
  }
}

uint64_t CPSDBaseComponent::ReadFile(int a1, char *a2, size_t a3, _DWORD *a4)
{
  size_t v5;
  int v8;
  uint64_t result;
  uint64_t v10;
  CStdException *exception;

  if (a3)
  {
    v5 = a3;
    v8 = 0;
    do
    {
      LODWORD(result) = ReadFile(a1, a2, v5, a4);
      if (!(_DWORD)result || (v10 = *a4, !(_DWORD)v10))
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      v8 += v10;
      a2 += v10;
      v5 -= v10;
    }
    while (v5);
  }
  else
  {
    v8 = 0;
    LOBYTE(result) = 1;
  }
  *a4 = v8;
  return result;
}

void sub_19EC0FFC8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageResourceBlock::Load(CPSDImageResourceBlock *this, uint64_t a2, unsigned int *a3)
{
  unsigned int v6;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  char v12;
  int v13;

  v13 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v13);
  *a3 += v13;
  v6 = bswap32(*((_DWORD *)this + 4));
  *((_DWORD *)this + 4) = v6;
  if (v6 != 943868237 && v6 != 1298486113)
  {
    fprintf(__stderrp, "CPSDImageResourceBlock::Load(): encountered unrecognized image resource block of type 0x%x\n", v6);
    return 0;
  }
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 2uLL, &v13);
  *a3 += v13;
  *((_WORD *)this + 10) = bswap32(*((unsigned __int16 *)this + 10)) >> 16;
  LoadPascalStringAsCString(a2, a3, (char *)this + 22, 2);
  v8 = (_DWORD *)((char *)this + 280);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 280, 4uLL, &v13);
  *a3 += v13;
  v9 = bswap32(*((_DWORD *)this + 70));
  *((_DWORD *)this + 70) = v9;
  if (!CPSDImageResourceBlock::CreateResourceItem(this, a2, v9))
    return 0;
  *a3 += *v8;
  if ((*(_BYTE *)v8 & 1) == 0)
    return 1;
  v12 = 0;
  v10 = 1;
  CPSDBaseComponent::ReadFile(a2, &v12, 1uLL, &v13);
  *a3 += v13;
  return v10;
}

CPSDBaseComponent *CPSDImageResources::UpdateResourceSize(CPSDBaseComponent *result, CPSDBaseComponent *this)
{
  uint64_t v3;
  CPSDBaseComponent *v4;
  int v5;
  CStdException *exception;

  if (this)
  {
    v3 = *((_QWORD *)this + 5);
    if (!v3)
    {
      exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
      CStdException::CStdException(exception, 3238789123);
    }
    v4 = result;
    v5 = CPSDBaseComponent::ComputeSize(this);
    *((_DWORD *)this + 4) = v5;
    *(_DWORD *)(v3 + 280) = v5;
    result = (CPSDBaseComponent *)CPSDBaseComponent::ComputeSize(v4);
    *((_DWORD *)v4 + 4) = (_DWORD)result - 4;
  }
  return result;
}

void sub_19EC10298(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *CPSDICCProfileResourceItem::AddICCData(CPSDICCProfileResourceItem *this, const unsigned __int8 *a2, size_t size)
{
  void *v6;
  void *result;

  v6 = (void *)*((_QWORD *)this + 6);
  if (v6)
    free(v6);
  result = malloc_type_malloc(size, 0x123FEE07uLL);
  *((_QWORD *)this + 6) = result;
  if (result)
  {
    result = memcpy(result, a2, size);
    *((_DWORD *)this + 4) = size;
  }
  return result;
}

uint64_t CPSDSlicesResourceItem::AddOrUpdateSlices(CPSDSlicesResourceItem *this, int32x4_t *a2, int a3, int a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int32x4_t *v18;
  CStdException *exception;

  *((_QWORD *)this + 6) = 6;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = a5;
  *((_DWORD *)this + 16) = a4;
  if (*((_DWORD *)this + 22))
  {
    v8 = *((_QWORD *)this + 12);
    if (v8)
    {
      v9 = v8 - 16;
      v10 = *(_QWORD *)(v8 - 8);
      if (v10)
      {
        v11 = v8 - 176;
        v12 = 176 * v10;
        do
        {
          CPSDSliceResource::~CPSDSliceResource((CPSDSliceResource *)(v11 + v12));
          v12 -= 176;
        }
        while (v12);
      }
      MEMORY[0x1A1AEEAF0](v9, 0x10B1C808814FAA7);
    }
  }
  v13 = (a3 + 1);
  *((_DWORD *)this + 22) = v13;
  if (a3 == -1)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  v14 = 176 * v13;
  v15 = operator new[](v14 + 16, 0x10B1C808814FAA7);
  v16 = 0;
  *(_QWORD *)v15 = 176;
  *(_QWORD *)(v15 + 8) = v13;
  do
  {
    CPSDSliceResource::CPSDSliceResource((CPSDSliceResource *)(v15 + v16 + 16));
    v16 += 176;
  }
  while (v14 != v16);
  *((_QWORD *)this + 12) = v15 + 16;
  if (a3)
  {
    v17 = 0;
    v18 = (int32x4_t *)(v15 + 244);
    do
    {
      *v18 = vrev64q_s32(a2[v17]);
      v18[-1].i32[3] = 1;
      v18[-2].i32[1] = 2;
      *(int32x2_t *)((char *)&v18[-3].u64[1] + 4) = vdup_n_s32((int)v17++ + 2);
      v18 += 11;
    }
    while (a3 - 1 >= v17);
  }
  *(int32x4_t *)(v15 + 68) = vrev64q_s32(*(int32x4_t *)((char *)this + 52));
  return CPSDSlicesResourceItem::SortSlices(this);
}

void sub_19EC10494(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDUnicodeChannelNames::AddName(CPSDUnicodeChannelNames *this, const CPSDString *a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t result;

  v3 = (uint64_t *)((char *)this + 48);
  v4 = *((_QWORD *)this + 7);
  if (v4 >= *((_QWORD *)this + 8))
  {
    result = std::vector<CPSDString>::__push_back_slow_path<CPSDString const&>(v3, (uint64_t)a2);
  }
  else
  {
    std::vector<CPSDString>::__construct_one_at_end[abi:ne180100]<CPSDString const&>((uint64_t)v3, (uint64_t)a2);
    result = v4 + 16;
  }
  *((_QWORD *)this + 7) = result;
  return result;
}

void *CPSDSlicesResourceItem::UpdateSliceNameAtIndex(CPSDSlicesResourceItem *this, const unsigned __int16 *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v5;
  CStdException *exception;

  if (*((_DWORD *)this + 22) <= a4)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  v5 = *(_QWORD *)(*((_QWORD *)this + 13) + 8 * a4);
  CPSDString::AllocateCharData((CPSDString *)(v5 + 32), a3);
  return memcpy(*(void **)(v5 + 40), a2, (2 * *(_DWORD *)(v5 + 32)));
}

void sub_19EC1059C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CPSDImageResourceBlock::~CPSDImageResourceBlock(CPSDImageResourceBlock *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E41A9B30;
  v1 = *((_QWORD *)this + 36);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E41A9B30;
  v1 = *((_QWORD *)this + 36);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDImageResourceBlock::Dump(CPSDImageResourceBlock *this, __sFILE *a2)
{
  uint64_t result;

  (*(void (**)(_QWORD))(**((_QWORD **)this + 36) + 40))(*((_QWORD *)this + 36));
  result = *((_QWORD *)this + 37);
  if (result)
    return (*(uint64_t (**)(uint64_t, __sFILE *))(*(_QWORD *)result + 40))(result, a2);
  return result;
}

unint64_t LoadPascalStringAsCString(int a1, _DWORD *a2, char *a3, int a4)
{
  unint64_t result;
  int v9;
  int v10;
  unsigned __int8 v11;

  v11 = 0;
  v10 = 0;
  result = CPSDBaseComponent::ReadFile(a1, (char *)&v11, 1uLL, &v10);
  *a2 += v10;
  if (v11)
  {
    result = CPSDBaseComponent::ReadFile(a1, a3, v11, &v10);
    *a2 += v10;
    v9 = v11;
  }
  else
  {
    v9 = 0;
  }
  a3[v9] = 0;
  if (a4 == 2)
  {
    result = SetFilePointer(a1, 1, 0, 1);
    ++*a2;
  }
  else if (a4 == 4)
  {
    __asm { BR              X10; loc_19EC1075C }
  }
  return result;
}

uint64_t CPSDImageResourceBlock::CreateResourceItem(CPSDImageResourceBlock *this, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  void (**v10)(CPSDICCProfileResourceItem *__hidden);

  switch(*((_WORD *)this + 10))
  {
    case 0x40D:
      v6 = operator new(56, 0x10B1C40CB24EE9ALL);
      v7 = v6;
      *(_DWORD *)(v6 + 16) = a3;
      *(_QWORD *)(v6 + 24) = 0;
      *(_QWORD *)(v6 + 32) = 0;
      *(_QWORD *)(v6 + 40) = this;
      *(_QWORD *)v6 = &off_1E41A9FF0;
      v8 = 120;
      goto LABEL_11;
    case 0x40E:
    case 0x410:
    case 0x412:
    case 0x413:
    case 0x414:
    case 0x416:
    case 0x417:
    case 0x418:
      goto LABEL_5;
    case 0x40F:
      v9 = operator new(56, 0x10B1C40300736D0);
      v7 = v9;
      *(_DWORD *)(v9 + 16) = a3;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      v10 = &off_1E41A9F10;
      goto LABEL_7;
    case 0x411:
      v7 = operator new(56, 0x10B1C404C354DEELL);
      *(_DWORD *)(v7 + 16) = a3;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 0;
      *(_QWORD *)(v7 + 40) = this;
      *(_QWORD *)v7 = &off_1E41AA038;
      *(_BYTE *)(v7 + 48) = 1;
      goto LABEL_13;
    case 0x415:
      v7 = operator new(72, 0x10B1C40580B6E5ALL);
      *(_DWORD *)(v7 + 16) = a3;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 0;
      *(_QWORD *)v7 = &off_1E41A9D90;
      *(_QWORD *)(v7 + 40) = this;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_QWORD *)(v7 + 64) = 0;
      goto LABEL_13;
    case 0x419:
      v6 = operator new(56, 0x10B1C40CB24EE9ALL);
      v7 = v6;
      *(_DWORD *)(v6 + 16) = a3;
      *(_QWORD *)(v6 + 24) = 0;
      *(_QWORD *)(v6 + 32) = 0;
      *(_QWORD *)(v6 + 40) = this;
      *(_QWORD *)v6 = &off_1E41AA080;
      v8 = 30;
LABEL_11:
      *(_DWORD *)(v6 + 48) = v8;
      goto LABEL_13;
    case 0x41A:
      v7 = operator new(120, 0x10B1C40B2DFEBF7);
      CPSDSlicesResourceItem::CPSDSlicesResourceItem((CPSDSlicesResourceItem *)v7, this, a3);
      goto LABEL_13;
    default:
      if (*((_WORD *)this + 10) == 1060)
      {
        v7 = operator new(56, 0x10B1C40300736D0);
        CPSDXMPResourceItem::CPSDXMPResourceItem((CPSDXMPResourceItem *)v7, this, a3);
      }
      else
      {
LABEL_5:
        v9 = operator new(56, 0x10B1C40300736D0);
        v7 = v9;
        *(_DWORD *)(v9 + 16) = a3;
        *(_QWORD *)(v9 + 24) = 0;
        *(_QWORD *)(v9 + 32) = 0;
        v10 = &off_1E41A9968;
LABEL_7:
        *(_QWORD *)v9 = v10;
        *(_QWORD *)(v9 + 40) = this;
        *(_QWORD *)(v9 + 48) = 0;
      }
LABEL_13:
      *((_QWORD *)this + 36) = v7;
      return CPSDResourceItem::LoadItem((CPSDResourceItem *)v7, a2);
  }
}

void sub_19EC109AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C40300736D0);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageResourceBlock::Save(CPSDImageResourceBlock *this, File *a2)
{
  uint64_t result;
  _QWORD *v5;
  uint64_t v6;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 10));
  (*(void (**)(File *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)this + 22, 2);
  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 70));
  v5 = (_QWORD *)*((_QWORD *)this + 36);
  if (v5)
  {
    result = (*(uint64_t (**)(_QWORD, File *))(*v5 + 24))(*((_QWORD *)this + 36), a2);
    v6 = v5[4];
    if (v6)
      result = (*(uint64_t (**)(File *, uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, v6, v5[3]);
  }
  if ((*((_BYTE *)this + 280) & 1) != 0)
    return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, 0);
  return result;
}

uint64_t CPSDResourceItem::LoadItem(CPSDResourceItem *this, uint64_t a2)
{
  int v4;
  uint64_t result;
  unsigned int v6;

  v4 = SetFilePointer(a2, 0, 0, 1);
  result = (*(uint64_t (**)(CPSDResourceItem *, uint64_t))(*(_QWORD *)this + 16))(this, a2);
  if ((_DWORD)result)
  {
    v6 = SetFilePointer(a2, 0, 0, 1) - v4;
    return CPSDResourceItem::LoadUnparsedData(this, a2, v6);
  }
  return result;
}

BOOL CPSDResourceItem::LoadUnparsedData(CPSDResourceItem *this, int a2, unsigned int a3)
{
  unsigned int v4;
  uint64_t v5;
  char *v8;
  int v9;

  v4 = *((_DWORD *)this + 4);
  v5 = v4 - a3;
  if (v4 >= a3)
  {
    *((_QWORD *)this + 3) = v5;
    if (v4 == a3)
    {
      return 1;
    }
    else
    {
      if (*((_QWORD *)this + 4))
      {
        MEMORY[0x1A1AEEAF0](*((_QWORD *)this + 4), 0x1000C8077774924);
        v5 = *((_QWORD *)this + 3);
      }
      v8 = (char *)operator new[](v5, 0x1000C8077774924);
      *((_QWORD *)this + 4) = v8;
      v9 = 0;
      CPSDBaseComponent::ReadFile(a2, v8, *((_QWORD *)this + 3), &v9);
      return *((_QWORD *)this + 3) == v9;
    }
  }
  else
  {
    *((_QWORD *)this + 3) = 0;
    puts("Error: Attempting to load more data than exists");
    return 0;
  }
}

uint64_t CPSDDummyResourceItem::Dump(CPSDDummyResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Resource: %d \t[ %d ] bytes }\n", *(unsigned __int16 *)(*((_QWORD *)this + 5) + 20), *((_DWORD *)this + 4));
}

uint64_t CPSDXMPResourceItem::Load(char **this, int a2)
{
  uint64_t result;
  int v4;

  v4 = 0;
  CPSDBaseComponent::ReadFile(a2, this[6], *((unsigned int *)this + 4), &v4);
  result = 0;
  if (v4 == *((_DWORD *)this + 4))
  {
    this[6][v4] = 0;
    return 1;
  }
  return result;
}

uint64_t CPSDXMPResourceItem::Save(uint64_t this, File *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 48);
  if (v2)
    return (*(uint64_t (**)(File *, uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, v2, *(unsigned int *)(this + 16));
  return this;
}

uint64_t CPSDXMPResourceItem::Dump(CPSDXMPResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Resource: XMP Metadata: \t[ %d ] bytes }\n", *((_DWORD *)this + 4));
}

BOOL CPSDDummyResourceItem::Load(CPSDDummyResourceItem *this, int a2)
{
  char *v4;
  int v6;

  v6 = 0;
  v4 = (char *)malloc_type_malloc(*((unsigned int *)this + 4), 0xAD6A69A5uLL);
  *((_QWORD *)this + 6) = v4;
  CPSDBaseComponent::ReadFile(a2, v4, *((unsigned int *)this + 4), &v6);
  return v6 == *((_DWORD *)this + 4);
}

uint64_t CPSDDummyResourceItem::Save(uint64_t this, File *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 48);
  if (v2)
    return (*(uint64_t (**)(File *, uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, v2, *(unsigned int *)(this + 16));
  return this;
}

uint64_t CPSDICCProfileResourceItem::Dump(CPSDICCProfileResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ ICC Profile: %d \t[ %d ] bytes }\n", *(unsigned __int16 *)(*((_QWORD *)this + 5) + 20), *((_DWORD *)this + 4));
}

BOOL CPSDICCProfileResourceItem::Load(CPSDICCProfileResourceItem *this, int a2)
{
  char *v4;
  int v6;

  v6 = 0;
  v4 = (char *)malloc_type_malloc(*((unsigned int *)this + 4), 0xB9FD3D5FuLL);
  *((_QWORD *)this + 6) = v4;
  CPSDBaseComponent::ReadFile(a2, v4, *((unsigned int *)this + 4), &v6);
  return v6 == *((_DWORD *)this + 4);
}

uint64_t CPSDICCProfileResourceItem::Save(uint64_t this, File *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 48);
  if (v2)
    return (*(uint64_t (**)(File *, uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, v2, *(unsigned int *)(this + 16));
  return this;
}

uint64_t CPSDICCUntaggedResourceItem::Dump(CPSDICCUntaggedResourceItem *this, __sFILE *a2)
{
  const char *v2;

  if (*((_BYTE *)this + 48))
    v2 = "YES";
  else
    v2 = "NO";
  return fprintf(a2, "{ Untagged: %s }\n", v2);
}

BOOL CPSDICCUntaggedResourceItem::Load(CPSDICCUntaggedResourceItem *this, int a2)
{
  int v3;

  v3 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 1uLL, &v3);
  return v3 == 1;
}

uint64_t CPSDICCUntaggedResourceItem::Save(CPSDICCUntaggedResourceItem *this, File *a2)
{
  return (*(uint64_t (**)(File *, char *, _QWORD))(*(_QWORD *)a2 + 48))(a2, (char *)this + 48, *((unsigned int *)this + 4));
}

uint64_t CPSDUnicodeChannelNames::Load(CPSDUnicodeChannelNames *this, int a2)
{
  unsigned int v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  char *v10;
  _WORD *v11;
  unsigned int v12;

  v12 = 0;
  if (*((_DWORD *)this + 4))
  {
    v4 = 0;
    v5 = (uint64_t *)((char *)this + 48);
    do
    {
      v11 = 0;
      CPSDString::AllocateCharData((CPSDString *)&v10, 1u);
      *v11 = 0;
      CPSDString::Load(&v10, a2, &v12);
      v6 = *((_QWORD *)this + 7);
      if (v6 >= *((_QWORD *)this + 8))
      {
        v7 = std::vector<CPSDString>::__push_back_slow_path<CPSDString const&>(v5, (uint64_t)&v10);
      }
      else
      {
        std::vector<CPSDString>::__construct_one_at_end[abi:ne180100]<CPSDString const&>((uint64_t)v5, (uint64_t)&v10);
        v7 = v6 + 16;
      }
      *((_QWORD *)this + 7) = v7;
      v8 = v12;
      if (v11)
        MEMORY[0x1A1AEEAF0](v11, 0x1000C80BDFB0063);
      v4 += v8;
    }
    while (v4 < *((_DWORD *)this + 4));
  }
  return 1;
}

void sub_19EC10FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x1A1AEEAF0](a11, 0x1000C80BDFB0063);
  _Unwind_Resume(exception_object);
}

uint64_t CPSDString::Load(char **this, int a2, unsigned int *a3)
{
  int v6;
  unsigned int v7;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;

  v13 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v13, 4uLL, (_DWORD *)&v13 + 1);
  *a3 += HIDWORD(v13);
  v6 = v13;
  v7 = bswap32(v13);
  LODWORD(v13) = v7;
  if (v6)
  {
    if (v7 > 0xFF)
      return 0;
    CPSDString::AllocateCharData((CPSDString *)this, v7);
    CPSDBaseComponent::ReadFile(a2, this[1], (2 * *(_DWORD *)this), (_DWORD *)&v13 + 1);
    v10 = HIDWORD(v13);
    *a3 += HIDWORD(v13);
    if (v10 >= 2)
    {
      v11 = v10 >> 1;
      v12 = this[1];
      do
      {
        *(_WORD *)v12 = bswap32(*(unsigned __int16 *)v12) >> 16;
        v12 += 2;
        --v11;
      }
      while (v11);
    }
  }
  else
  {
    v9 = this[1];
    if (v9)
    {
      MEMORY[0x1A1AEEAF0](v9, 0x1000C80BDFB0063);
      this[1] = 0;
    }
    *(_DWORD *)this = 0;
  }
  return 1;
}

uint64_t CPSDUnicodeChannelNames::Save(uint64_t this, File *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int *v8;

  v2 = *(_QWORD *)(this + 56) - *(_QWORD *)(this + 48);
  if (v2)
  {
    v4 = this;
    v5 = 0;
    v6 = v2 >> 4;
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = v6;
    do
    {
      v8 = (unsigned int *)(*(_QWORD *)(v4 + 48) + v5);
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *v8);
      this = (*(uint64_t (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)v8 + 1), *v8);
      v5 += 16;
      --v7;
    }
    while (v7);
  }
  return this;
}

uint64_t CPSDGlobalAngleResourceItem::Dump(CPSDGlobalAngleResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Global Angle: %d }\n", *((_DWORD *)this + 12));
}

BOOL CPSDGlobalAngleResourceItem::Load(CPSDGlobalAngleResourceItem *this, int a2)
{
  int v4;

  v4 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v4);
  *((_DWORD *)this + 12) = bswap32(*((_DWORD *)this + 12));
  return v4 == 4;
}

uint64_t CPSDGlobalAngleResourceItem::Save(CPSDGlobalAngleResourceItem *this, File *a2)
{
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 12));
}

uint64_t CPSDGlobalAltitudeResourceItem::Dump(CPSDGlobalAltitudeResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Global Altitude: %d }\n", *((_DWORD *)this + 12));
}

BOOL CPSDGlobalAltitudeResourceItem::Load(CPSDGlobalAltitudeResourceItem *this, int a2)
{
  int v4;

  v4 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v4);
  *((_DWORD *)this + 12) = bswap32(*((_DWORD *)this + 12));
  return v4 == 4;
}

uint64_t CPSDGlobalAltitudeResourceItem::Save(CPSDGlobalAltitudeResourceItem *this, File *a2)
{
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 12));
}

void CPSDSlicesResourceItem::~CPSDSlicesResourceItem(CPSDSlicesResourceItem *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)this = &off_1E41A9B70;
  if (*((_DWORD *)this + 12) < 7u)
  {
    if (*((_DWORD *)this + 22))
    {
      v3 = *((_QWORD *)this + 12);
      if (v3)
      {
        v4 = v3 - 16;
        v5 = *(_QWORD *)(v3 - 8);
        if (v5)
        {
          v6 = v3 - 176;
          v7 = 176 * v5;
          do
          {
            CPSDSliceResource::~CPSDSliceResource((CPSDSliceResource *)(v6 + v7));
            v7 -= 176;
          }
          while (v7);
        }
        MEMORY[0x1A1AEEAF0](v4, 0x10B1C808814FAA7);
      }
      v8 = *((_QWORD *)this + 13);
      if (v8)
        MEMORY[0x1A1AEEAF0](v8, 0x20C8093837F09);
    }
  }
  else
  {
    v2 = *((_QWORD *)this + 14);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  v9 = *((_QWORD *)this + 10);
  if (v9)
  {
    MEMORY[0x1A1AEEAF0](v9, 0x1000C80BDFB0063);
    *((_QWORD *)this + 10) = 0;
  }
  *(_QWORD *)this = &unk_1E41A9250;
  v10 = *((_QWORD *)this + 4);
  if (v10)
    MEMORY[0x1A1AEEAF0](v10, 0x1000C8077774924);
}

{
  CPSDSlicesResourceItem::~CPSDSlicesResourceItem(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDSlicesResourceItem::Dump(CPSDSlicesResourceItem *this, __sFILE *a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;

  if (*((_DWORD *)this + 12) < 7u)
  {
    result = fprintf(a2, "{ SLICES:   1051\t[%d Slices] bounds={%d,%d,%d,%d} [%d] bytes }\n", *((_DWORD *)this + 22), *((_DWORD *)this + 14), *((_DWORD *)this + 13), *((_DWORD *)this + 16), *((_DWORD *)this + 15), *((_DWORD *)this + 4));
    if (*((_DWORD *)this + 22))
    {
      v5 = 0;
      v6 = 0;
      do
      {
        fprintf(a2, "[%d]\t", v6);
        result = (*(uint64_t (**)(uint64_t, __sFILE *))(*(_QWORD *)(*((_QWORD *)this + 12) + v5) + 40))(*((_QWORD *)this + 12) + v5, a2);
        ++v6;
        v5 += 176;
      }
      while (v6 < *((unsigned int *)this + 22));
    }
  }
  else
  {
    fprintf(a2, "{ SLICES:   1051\t v%d ActionDescriptor [%d] bytes }\n", *((_DWORD *)this + 12), *((_DWORD *)this + 4));
    return (*(uint64_t (**)(_QWORD, __sFILE *, uint64_t))(**((_QWORD **)this + 14) + 56))(*((_QWORD *)this + 14), a2, 1);
  }
  return result;
}

uint64_t CPSDSlicesResourceItem::Load(CPSDSlicesResourceItem *this, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  CPSDActionDescriptor *v7;
  uint64_t result;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;

  v18 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v18);
  v17 = v18;
  v4 = bswap32(*((_DWORD *)this + 12));
  *((_DWORD *)this + 12) = v4;
  if (v4 < 7)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 52, 0x10uLL, &v18);
    v17 += v18;
    *(int8x16_t *)((char *)this + 52) = vrev32q_s8(*(int8x16_t *)((char *)this + 52));
    CPSDString::Load((char **)this + 9, a2, &v17);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 88, 4uLL, &v18);
    v17 += v18;
    v9 = *((_DWORD *)this + 22);
    v10 = bswap32(v9);
    *((_DWORD *)this + 22) = v10;
    if (!v9)
      return CPSDSlicesResourceItem::SortSlices(this);
    v11 = 176 * v10;
    v12 = (_QWORD *)operator new[](v11 + 16, 0x10B1C808814FAA7);
    v13 = 0;
    *v12 = 176;
    v12[1] = v10;
    do
    {
      CPSDSliceResource::CPSDSliceResource((CPSDSliceResource *)&v12[v13 / 8 + 2]);
      v13 += 176;
    }
    while (v11 != v13);
    *((_QWORD *)this + 12) = v12 + 2;
    if (*((_DWORD *)this + 22))
    {
      v14 = 0;
      v15 = 0;
      while (1)
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(_QWORD *)(*((_QWORD *)this + 12) + v14)
                                                                             + 48))(*((_QWORD *)this + 12) + v14, a2, &v17);
        if (!(_DWORD)result)
          break;
        ++v15;
        v14 += 176;
        if (v15 >= *((unsigned int *)this + 22))
          return CPSDSlicesResourceItem::SortSlices(this);
      }
    }
    else
    {
      return CPSDSlicesResourceItem::SortSlices(this);
    }
  }
  else
  {
    v16 = 0;
    CPSDBaseComponent::ReadFile(a2, (char *)&v16, 4uLL, &v17);
    v17 += v18;
    v5 = v16;
    v6 = bswap32(v16);
    v16 = v6;
    if (v5 == 0x10000000)
    {
      v7 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
      CPSDActionDescriptor::CPSDActionDescriptor(v7);
      *((_QWORD *)this + 14) = v7;
      *((_DWORD *)this + 22) = 0;
      return (*(uint64_t (**)(CPSDActionDescriptor *, uint64_t))(*(_QWORD *)v7 + 16))(v7, a2);
    }
    else
    {
      fprintf(__stderrp, "CPSDSlicesResourceItem::Load(): unexpected descriptor version (%d) encountered.\n", v6);
      return 0;
    }
  }
  return result;
}

void sub_19EC11758(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C4022C5DBF1);
  _Unwind_Resume(a1);
}

uint64_t CPSDSlicesResourceItem::SortSlices(CPSDSlicesResourceItem *this)
{
  unsigned int v1;
  uint64_t v3;
  void *v4;
  size_t v5;
  uint64_t i;

  v1 = *((_DWORD *)this + 22);
  if (!v1 || !*((_QWORD *)this + 12))
    return 0;
  v3 = *((_QWORD *)this + 13);
  if (v3)
  {
    MEMORY[0x1A1AEEAF0](v3, 0x20C8093837F09);
    v1 = *((_DWORD *)this + 22);
  }
  v4 = (void *)operator new[](8 * v1, 0x20C8093837F09);
  *((_QWORD *)this + 13) = v4;
  v5 = *((unsigned int *)this + 22);
  if ((_DWORD)v5)
  {
    for (i = 0; i != v5; ++i)
      *(_QWORD *)(*((_QWORD *)this + 13) + 8 * i) = *((_QWORD *)this + 12) + 176 * i;
    v4 = (void *)*((_QWORD *)this + 13);
  }
  else
  {
    v5 = 0;
  }
  qsort(v4, v5, 8uLL, (int (__cdecl *)(const void *, const void *))slice_cmp_fn);
  return 1;
}

uint64_t CPSDSlicesResourceItem::Save(CPSDSlicesResourceItem *this, File *a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 12));
  PSDRect::Save((PSDRect *)((char *)this + 52), a2);
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 18));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 10), *((unsigned int *)this + 18));
  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 22));
  if (*((_DWORD *)this + 22))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)(*((_QWORD *)this + 12) + v5) + 24))(*((_QWORD *)this + 12) + v5, a2);
      ++v6;
      v5 += 176;
    }
    while (v6 < *((unsigned int *)this + 22));
  }
  return result;
}

uint64_t PSDRect::Save(PSDRect *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *(_DWORD *)this);
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 1));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 2));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 3));
}

uint64_t slice_cmp_fn(const void *a1, const void *a2)
{
  _DWORD *v2;
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD **)a2;
  v4 = *(_DWORD *)(*(_QWORD *)a1 + 56);
  v5 = *(_DWORD *)(*(_QWORD *)a2 + 56);
  v6 = v4 >= v5;
  if (v4 == v5 && (v7 = v2[13], v8 = v3[13], v6 = v7 >= v8, v7 == v8))
  {
    v9 = v2[15];
    v10 = v3[15];
    v6 = v9 >= v10;
    if (v9 == v10)
      v6 = v2[16] >= v3[16];
    v11 = 1;
  }
  else
  {
    v11 = -1;
  }
  if (v6)
    return -v11;
  else
    return v11;
}

uint64_t CPSDSliceResource::Load(CPSDSliceResource *this, int a2, unsigned int *a3)
{
  unsigned int v6;
  int v8;

  v8 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 0xCuLL, &v8);
  *a3 += v8;
  *((int8x8_t *)this + 2) = vrev32_s8(*(int8x8_t *)((char *)this + 16));
  v6 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = bswap32(v6);
  if (v6 == 0x1000000)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 4uLL, &v8);
    *((_DWORD *)this + 7) = bswap32(*((_DWORD *)this + 7));
  }
  CPSDString::Load((char **)this + 4, a2, a3);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 0x14uLL, &v8);
  *a3 += v8;
  *((int8x16_t *)this + 3) = vrev32q_s8(*((int8x16_t *)this + 3));
  *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
  CPSDString::Load((char **)this + 9, a2, a3);
  CPSDString::Load((char **)this + 11, a2, a3);
  CPSDString::Load((char **)this + 13, a2, a3);
  CPSDString::Load((char **)this + 15, a2, a3);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 136, 1uLL, &v8);
  *a3 += v8;
  CPSDString::Load((char **)this + 18, a2, a3);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 160, 8uLL, &v8);
  *a3 += v8;
  *((int8x8_t *)this + 20) = vrev32_s8(*(int8x8_t *)((char *)this + 160));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 168, 1uLL, &v8);
  *a3 += v8;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 169, 1uLL, &v8);
  *a3 += v8;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 170, 1uLL, &v8);
  *a3 += v8;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 171, 1uLL, &v8);
  *a3 += v8;
  return 1;
}

uint64_t CPSDSliceResource::Save(CPSDSliceResource *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 5));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 6));
  if (*((_DWORD *)this + 6) == 1)
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 7));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 8));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 5), *((unsigned int *)this + 8));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 12));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 13));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 15));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 16));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 18));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 10), *((unsigned int *)this + 18));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 22));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 12), *((unsigned int *)this + 22));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 26));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 14), *((unsigned int *)this + 26));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 30));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 16), *((unsigned int *)this + 30));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 136));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 36));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 19), *((unsigned int *)this + 36));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 40));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 41));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 168));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 169));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 170));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 171));
}

uint64_t CPSDSliceResource::Dump(CPSDSliceResource *this, __sFILE *a2)
{
  const UniChar **v4;
  int v5;
  char v7[256];

  v5 = *((_DWORD *)this + 8);
  v4 = (const UniChar **)((char *)this + 32);
  if (v5)
    CPSDString::CopyStringValue(v4, v7, 0x100u);
  return fprintf(a2, " |  {%d,%d,%d,%d} \t[ %s ]\ttype=%d \thoriz=%d, vert=%d\t|\n", *((_DWORD *)this + 13), *((_DWORD *)this + 14), *((_DWORD *)this + 15), *((_DWORD *)this + 16), v7, *((_DWORD *)this + 12), *((_DWORD *)this + 40), *((_DWORD *)this + 41));
}

void CPSDPathsResourceItem::~CPSDPathsResourceItem(CPSDPathsResourceItem *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  *(_QWORD *)this = &off_1E41A9A68;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    MEMORY[0x1A1AEEAF0](v2, 0x20C8093837F09);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  if (v3)
  {
    do
    {
      v4 = (_QWORD *)v3[3];
      (*(void (**)(_QWORD *))(*v3 + 8))(v3);
      v3 = v4;
    }
    while (v4);
  }
}

{
  CPSDPathsResourceItem::~CPSDPathsResourceItem(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDPathsResourceItem::Load(CPSDPathsResourceItem *this, int a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t *v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  void (**v10)(CPSDPathDataRecord *__hidden);
  unsigned __int16 v11;
  uint64_t v12;
  uint64_t *v13;
  CStdException *exception;
  unsigned __int16 v16;
  int v17;

  v2 = *((_DWORD *)this + 4);
  if ((float)v2 / 26.0 >= 1.0)
  {
    v5 = 0;
    v6 = (uint64_t *)((char *)this + 24);
    while (2)
    {
      v17 = 0;
      v16 = 0;
      CPSDBaseComponent::ReadFile(a2, (char *)&v16, 2uLL, &v17);
      v7 = bswap32(v16) >> 16;
      v16 = v7;
      v8 = v17;
      switch(v7)
      {
        case 0u:
        case 3u:
          v9 = operator new(56, 0x10A1C40796BEDEALL);
          *(_WORD *)(v9 + 16) = v16;
          *(_QWORD *)(v9 + 24) = 0;
          *(_QWORD *)(v9 + 32) = 0;
          *(_QWORD *)v9 = &off_1E41A9D50;
          *(_QWORD *)(v9 + 40) = 0;
          *(_QWORD *)(v9 + 48) = 0;
          ++*((_WORD *)this + 16);
          v10 = &off_1E41A9D50;
          goto LABEL_10;
        case 1u:
        case 2u:
        case 4u:
        case 5u:
          v9 = operator new(80, 0x10A1C40699119A0);
          *(_WORD *)(v9 + 16) = v16;
          *(_QWORD *)(v9 + 24) = 0;
          *(_QWORD *)v9 = &off_1E41A9780;
          v10 = &off_1E41A9780;
          goto LABEL_10;
        case 6u:
          v9 = operator new(32, 0x10A1C40AF615CF1);
          v11 = v16;
          *(_QWORD *)v9 = &off_1E41A9500;
          *(_WORD *)(v9 + 16) = v11;
          *(_QWORD *)(v9 + 24) = 0;
          v10 = &off_1E41A9500;
          goto LABEL_10;
        case 7u:
          v12 = operator new(72, 0x10A1C40B404A633);
          v9 = v12;
          *(_WORD *)(v12 + 16) = v16;
          *(_QWORD *)(v12 + 24) = 0;
          v10 = &off_1E41A9608;
          goto LABEL_9;
        case 8u:
          v12 = operator new(40, 0x10A1C4082A5C483);
          v9 = v12;
          *(_WORD *)(v12 + 16) = v16;
          *(_QWORD *)(v12 + 24) = 0;
          v10 = &off_1E41A99E8;
LABEL_9:
          *(_QWORD *)v12 = v10;
LABEL_10:
          if (!((unsigned int (*)(CPSDPathDataRecord *, int))v10[2])((CPSDPathDataRecord *)v9, a2))
            goto LABEL_17;
          v13 = v6;
          if (!*v6)
            goto LABEL_14;
          if (v5)
          {
            v13 = (uint64_t *)(v5 + 24);
LABEL_14:
            *v13 = v9;
          }
          v2 = v2 - v8 - 24;
          v5 = v9;
          if ((float)v2 / 26.0 < 1.0)
            return 1;
          continue;
        default:
LABEL_17:
          exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
          CStdException::CStdException(exception, 3238395925);
      }
    }
  }
  return 1;
}

void sub_19EC12258(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDPathsResourceItem::Save(uint64_t this, File *a2)
{
  _QWORD *i;

  for (i = *(_QWORD **)(this + 24); i; i = (_QWORD *)i[3])
    this = (*(uint64_t (**)(_QWORD *, File *))(*i + 24))(i, a2);
  return this;
}

uint64_t CPSDPathsResourceItem::GenerateSubpathResources(CPSDPathsResourceItem *this)
{
  uint64_t v2;
  unsigned __int16 v3;
  unsigned __int16 v4;
  unsigned int v5;
  _QWORD *v6;
  BOOL v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *((_QWORD *)this + 5) = operator new[](8 * *((unsigned __int16 *)this + 16), 0x20C8093837F09);
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(unsigned __int16 *)(v2 + 16);
      if (v5 <= 5)
      {
        if (((1 << v5) & 0x36) == 0)
        {
          v6 = (_QWORD *)operator new(32, 0x10A1C40E45398F5);
          *(_QWORD *)(*((_QWORD *)this + 5) + 8 * v3) = v6;
          *v6 = &off_1E41A9208;
          if (*(_WORD *)(v2 + 16))
            v7 = *(unsigned __int16 *)(v2 + 16) == 3;
          else
            v7 = 1;
          v8 = v7;
          v9 = *(_QWORD *)(*((_QWORD *)this + 5) + 8 * v3);
          *(_BYTE *)(v9 + 16) = v8;
          v10 = *(unsigned __int16 *)(v2 + 32);
          *(_WORD *)(v9 + 18) = v10;
          v11 = operator new[](8 * v10, 0x20C8093837F09);
          v4 = 0;
          *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 5) + 8 * v3) + 24) = v11;
          goto LABEL_18;
        }
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 5) + 8 * v3) + 24) + 8 * v4++) = v2;
      }
      if (v4)
      {
        if (*(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)this + 5) + 8 * v3) + 18) == v4)
          ++v3;
      }
      else
      {
        v4 = 0;
      }
LABEL_18:
      v2 = *(_QWORD *)(v2 + 24);
    }
    while (v2);
  }
  return 1;
}

uint64_t CPSDPathsResourceItem::GetSubpath(CPSDPathsResourceItem *this, unsigned int a2)
{
  if (!*((_QWORD *)this + 5))
    CPSDPathsResourceItem::GenerateSubpathResources(this);
  if (*((unsigned __int16 *)this + 16) <= a2)
    return 0;
  else
    return *(_QWORD *)(*((_QWORD *)this + 5) + 8 * a2);
}

uint64_t CPSDPathsResourceItem::Dump(CPSDPathsResourceItem *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ PathsResourceItem:\n", v6);
  fprintf(a2, "%s\tFillStartsWithAllPixels:\n", v7);
  fprintf(a2, "%s\tSubpaths[%d]\n", v7, *((unsigned __int16 *)this + 16));
  if (*((_WORD *)this + 16))
  {
    v9 = 0;
    v10 = a3 + 2;
    do
    {
      fprintf(a2, "%s\t===== Subpath %d =====\n", v7, v9);
      if (!*((_QWORD *)this + 5))
        CPSDPathsResourceItem::GenerateSubpathResources(this);
      v11 = *((unsigned __int16 *)this + 16);
      if (v9 < v11)
      {
        v12 = *(_QWORD *)(*((_QWORD *)this + 5) + 8 * v9);
        if (v12)
        {
          (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(_QWORD *)v12 + 48))(v12, a2, v10);
          v11 = *((unsigned __int16 *)this + 16);
        }
      }
      ++v9;
    }
    while (v9 < v11);
  }
  return fprintf(a2, "%s} // End of PathsResourceItem\n", v7);
}

uint64_t CPSDPathResource::Dump(CPSDPathResource *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Bezier Path:\n", v6);
  fprintf(a2, "%s\tKnots[%d]:\n", v7, *((unsigned __int16 *)this + 9));
  if (*((_WORD *)this + 9))
  {
    v9 = 0;
    do
    {
      fprintf(a2, "%s\t[%d]: ", v7, v9);
      v10 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v9);
      (*(void (**)(uint64_t, __sFILE *))(*(_QWORD *)v10 + 40))(v10, a2);
      ++v9;
    }
    while (v9 < *((unsigned __int16 *)this + 9));
  }
  return fprintf(a2, "%s} // End Bezier Path\n", v7);
}

uint64_t CPSDPathResource::GetBezierKnot(uint64_t a1, unsigned int a2, _OWORD *a3, _OWORD *a4, _OWORD *a5)
{
  _OWORD *v5;

  v5 = *(_OWORD **)(*(_QWORD *)(a1 + 24) + 8 * a2);
  *a4 = v5[2];
  *a3 = v5[3];
  *a5 = v5[4];
  return 1;
}

uint64_t CPSDPathDataRecord::Load(CPSDPathDataRecord *this, int a2)
{
  int v3;

  v3 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, (v3 + 24), 0, 0);
  return 1;
}

uint64_t CPSDPathDataRecord::Save(CPSDPathDataRecord *this, File *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  if (*((_WORD *)this + 8) == 6)
    return (*(uint64_t (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 24);
  return result;
}

uint64_t CPSDSubpathLengthRecord::Load(CPSDSubpathLengthRecord *this, int a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 2uLL, &v5);
  *((_WORD *)this + 16) = bswap32(*((unsigned __int16 *)this + 16)) >> 16;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 34, 0x16uLL, &v5);
  return 1;
}

uint64_t CPSDSubpathLengthRecord::Save(CPSDSubpathLengthRecord *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  if (*((_WORD *)this + 8) == 6)
    (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 24);
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 16));
  return (*(uint64_t (**)(File *, char *, uint64_t))(*(_QWORD *)a2 + 48))(a2, (char *)this + 34, 22);
}

uint64_t CPSDBezierKnotRecord::Load(CPSDBezierKnotRecord *this, int a2)
{
  uint64_t v4;
  unsigned int v5;
  double v6;
  double *v7;
  unsigned int v9;
  uint64_t v10;

  v4 = 0;
  v10 = 0;
  v9 = 0;
  do
  {
    CPSDBaseComponent::ReadFile(a2, (char *)&v9, 4uLL, (_DWORD *)&v10 + 1);
    CPSDBaseComponent::ReadFile(a2, (char *)&v10, 4uLL, (_DWORD *)&v10 + 1);
    v5 = bswap32(v9);
    v6 = (double)v5 * 0.0000000596046448;
    v9 = v5;
    LODWORD(v10) = bswap32(v10);
    v7 = (double *)((char *)this + v4);
    v7[4] = (double)v10 * 0.0000000596046448;
    v7[5] = v6;
    v4 += 16;
  }
  while (v4 != 48);
  return 1;
}

uint64_t CPSDBezierKnotRecord::Save(CPSDBezierKnotRecord *this, File *a2)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t result;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  if (*((_WORD *)this + 8) == 6)
    (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 24);
  for (i = 0; i != 48; i += 16)
  {
    LODWORD(v4) = vcvtd_n_u64_f64(*(double *)((char *)this + i + 40), 0x18uLL);
    (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v4);
    LODWORD(v6) = vcvtd_n_u64_f64(*(double *)((char *)this + i + 32), 0x18uLL);
    result = (*(uint64_t (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v6);
  }
  return result;
}

uint64_t CPSDBezierKnotRecord::Dump(CPSDBezierKnotRecord *this, __sFILE *a2)
{
  int v2;
  BOOL v3;
  const char *v4;

  v2 = *((unsigned __int16 *)this + 8);
  v3 = v2 == 4 || v2 == 1;
  v4 = "YES";
  if (!v3)
    v4 = "NO";
  return fprintf(a2, "Anchor: (%f, %f)\tCtrlPt1: (%f, %f)\tCtrlPt2:(%f,%f), <isLinked: %s >\n", *((double *)this + 6), *((double *)this + 7), *((double *)this + 4), *((double *)this + 5), *((double *)this + 8), *((double *)this + 9), v4);
}

uint64_t CPSDClipboardRecord::Load(CPSDClipboardRecord *this, int a2)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v8, 4uLL, (_DWORD *)&v8 + 1);
  LODWORD(v8) = bswap32(v8);
  *((double *)this + 4) = (double)v8 * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v7 + 4, 4uLL, (_DWORD *)&v8 + 1);
  HIDWORD(v7) = bswap32(HIDWORD(v7));
  *((double *)this + 5) = (double)HIDWORD(v7) * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v7, 4uLL, (_DWORD *)&v8 + 1);
  LODWORD(v7) = bswap32(v7);
  *((double *)this + 6) = (double)v7 * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v6 + 4, 4uLL, (_DWORD *)&v8 + 1);
  HIDWORD(v6) = bswap32(HIDWORD(v6));
  *((double *)this + 7) = (double)HIDWORD(v6) * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v6, 4uLL, (_DWORD *)&v8 + 1);
  LODWORD(v6) = bswap32(v6);
  *((double *)this + 8) = (double)v6 * 0.0000000596046448;
  v4 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, (v4 + 2), 0, 0);
  return 1;
}

uint64_t CPSDClipboardRecord::Save(CPSDClipboardRecord *this, File *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  if (*((_WORD *)this + 8) == 6)
    (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 24);
  LODWORD(v4) = vcvtd_n_u64_f64(*((double *)this + 4), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v4);
  LODWORD(v5) = vcvtd_n_u64_f64(*((double *)this + 5), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v5);
  LODWORD(v6) = vcvtd_n_u64_f64(*((double *)this + 6), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v6);
  LODWORD(v7) = vcvtd_n_u64_f64(*((double *)this + 7), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v7);
  LODWORD(v8) = vcvtd_n_u64_f64(*((double *)this + 8), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v8);
  return (*(uint64_t (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 4);
}

uint64_t CPSDInitialFillRecord::Load(CPSDInitialFillRecord *this, int a2)
{
  int v4;
  int v5;
  unsigned __int16 v7;
  int v8;

  v8 = 0;
  v7 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v7, 2uLL, &v8);
  v4 = v7;
  v7 = __rev16(v7);
  *((_BYTE *)this + 32) = v4 == 256;
  v5 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, (v5 + 22), 0, 0);
  return 1;
}

uint64_t CPSDInitialFillRecord::Save(CPSDInitialFillRecord *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  if (*((_WORD *)this + 8) == 6)
    (*(void (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 24);
  (*(void (**)(File *, BOOL))(*(_QWORD *)a2 + 72))(a2, *((_BYTE *)this + 32) != 0);
  return (*(uint64_t (**)(File *, uint64_t))(*(_QWORD *)a2 + 56))(a2, 22);
}

uint64_t CPSDAdditionalLayerInfo::Load(CPSDAdditionalLayerInfo *this, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t *v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;

  v4 = SetFilePointer(a2, 0, 0, 1);
  v5 = *((_DWORD *)this + 4);
  if ((v5 - 1) < 0xB)
    return 0;
  v6 = v4;
  v8 = (uint64_t *)((char *)this + 24);
  v7 = *((_QWORD *)this + 3);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  if (v5)
  {
    v9 = v5 + v6;
    do
    {
      v23 = 0;
      v24 = 0;
      CPSDBaseComponent::ReadFile(a2, (char *)&v24, 4uLL, (_DWORD *)&v24 + 1);
      LODWORD(v24) = bswap32(v24);
      CPSDBaseComponent::ReadFile(a2, (char *)&v23 + 4, 4uLL, (_DWORD *)&v24 + 1);
      HIDWORD(v23) = bswap32(HIDWORD(v23));
      CPSDBaseComponent::ReadFile(a2, (char *)&v23, 4uLL, (_DWORD *)&v24 + 1);
      LODWORD(v23) = bswap32(v23);
      if (SHIDWORD(v23) <= 1818654769)
      {
        switch(HIDWORD(v23))
        {
          case 0x4764466C:
            v10 = operator new(136, 0x10B1C408FE8321ELL);
            CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v10);
            *(_QWORD *)(v10 + 120) = 0;
            *(_QWORD *)v10 = &off_1E41A97C0;
            *(_DWORD *)(v10 + 128) = 0;
            goto LABEL_23;
          case 0x536F436F:
            v10 = operator new(128, 0x10B1C402C48CE55);
            CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v10);
            *(_QWORD *)v10 = &off_1E41A92C0;
            *(_DWORD *)(v10 + 120) = 0;
            goto LABEL_23;
          case 0x694F7061:
            v10 = operator new(64, 0x10B1C40B4161B10);
            *(_DWORD *)(v10 + 16) = 0;
            *(_OWORD *)(v10 + 24) = 0u;
            *(_OWORD *)(v10 + 40) = 0u;
            *(_QWORD *)v10 = &off_1E41A99A8;
            *(_BYTE *)(v10 + 56) = -1;
            goto LABEL_23;
        }
      }
      else if (SHIDWORD(v23) > 1819635304)
      {
        if (HIDWORD(v23) == 1986884459)
        {
          v10 = operator new(112, 0x10B1C40ACA3B8FELL);
          *(_DWORD *)(v10 + 16) = 0;
          *(_OWORD *)(v10 + 24) = 0u;
          *(_OWORD *)(v10 + 40) = 0u;
          *(_QWORD *)v10 = &off_1E41A9580;
          *(_QWORD *)(v10 + 56) = &off_1E41A9A68;
          *(_QWORD *)(v10 + 80) = 0;
          *(_WORD *)(v10 + 88) = 0;
          *(_QWORD *)(v10 + 96) = 0;
          *(_QWORD *)(v10 + 104) = 0;
          goto LABEL_23;
        }
        if (HIDWORD(v23) == 1819635305)
        {
          v10 = operator new(72, 0x10B1C4015F6298ELL);
          *(_DWORD *)(v10 + 16) = 0;
          *(_OWORD *)(v10 + 24) = 0u;
          *(_OWORD *)(v10 + 40) = 0u;
          *(_QWORD *)v10 = &off_1E41A98E0;
          *(_DWORD *)(v10 + 56) = 0;
          goto LABEL_23;
        }
      }
      else
      {
        if (HIDWORD(v23) == 1818654770)
        {
          v10 = operator new(128, 0x10B1C4032540B95);
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v10);
          *(_QWORD *)v10 = &off_1E41A9F60;
          *(_QWORD *)(v10 + 120) = 0;
          goto LABEL_23;
        }
        if (HIDWORD(v23) == 1819501428)
        {
          v10 = operator new(72, 0x10B1C40B9FD2085);
          *(_DWORD *)(v10 + 16) = 0;
          *(_OWORD *)(v10 + 24) = 0u;
          *(_OWORD *)(v10 + 40) = 0u;
          *(_QWORD *)v10 = &off_1E41A9540;
          *(_QWORD *)(v10 + 56) = 0;
          *(_DWORD *)(v10 + 64) = 0;
          goto LABEL_23;
        }
      }
      v10 = operator new(56, 0x10B1C40AE6707B7);
      *(_DWORD *)(v10 + 16) = 0;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 0;
      *(_QWORD *)v10 = &off_1E41A9FB0;
      *(_QWORD *)(v10 + 40) = 0;
      *(_QWORD *)(v10 + 48) = 0;
LABEL_23:
      v11 = HIDWORD(v23);
      *(_DWORD *)(v10 + 16) = v23;
      *(_DWORD *)(v10 + 40) = v24;
      *(_DWORD *)(v10 + 44) = v11;
      CPSDResourceItem::LoadItem((CPSDResourceItem *)v10, a2);
      v12 = *v8;
      v13 = (uint64_t *)((char *)this + 24);
      if (*v8)
      {
        do
        {
          v14 = v12;
          v12 = *(_QWORD *)(v12 + 48);
        }
        while (v12);
        v13 = (uint64_t *)(v14 + 48);
      }
      *v13 = v10;
      v15 = SetFilePointer(a2, 0, 0, 1);
      if (v15 > v9)
      {
        _CUILog(1, (uint64_t)"Additional Layer Info Size is Recorded Incorrectly in File: recorded size = %d, bytes read = %d.\n", v16, v17, v18, v19, v20, v21, *((unsigned int *)this + 4));
        return 0;
      }
      if ((v23 & 3) != 0)
        v15 = SetFilePointer(a2, 4 - (v23 & 3), 0, 1);
    }
    while (v9 != v15);
  }
  SetFilePointer(a2, (*((_DWORD *)this + 4) + v6), 0, 0);
  return 1;
}

void sub_19EC13188(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C402C48CE55);
  _Unwind_Resume(a1);
}

uint64_t CPSDAdditionalLayerInfo::Save(uint64_t this, File *a2)
{
  _QWORD *i;
  uint64_t v4;

  for (i = *(_QWORD **)(this + 24); i; i = (_QWORD *)i[6])
  {
    this = (*(uint64_t (**)(_QWORD *, File *))(*i + 24))(i, a2);
    v4 = i[4];
    if (v4)
      this = (*(uint64_t (**)(File *, uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, v4, i[3]);
  }
  return this;
}

_QWORD *CPSDAdditionalLayerInfo::GetFirstItemOfTypeID(CPSDAdditionalLayerInfo *this, const std::type_info *a2)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 3); i; i = (_QWORD *)i[6])
  {
    if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(*i - 8), (uint64_t)a2))
      break;
  }
  return i;
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t CPSDAdditionalLayerInfoItem::Save(CPSDAdditionalLayerInfoItem *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
}

void CPSDLayerAndMaskInfo::CPSDLayerAndMaskInfo(CPSDLayerAndMaskInfo *this)
{
  *(_QWORD *)this = &off_1E41A9810;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = &off_1E41A8F58;
  *((_DWORD *)this + 10) = 0;
  *((_WORD *)this + 22) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = &off_1E41A9C30;
  *((_DWORD *)this + 28) = 0;
  *((_WORD *)this + 58) = 0;
  *((_WORD *)this + 63) = 0;
  *((_BYTE *)this + 128) = 0;
  *((_DWORD *)this + 33) = 0;
  bzero((char *)this + 118, 8uLL);
  *((_QWORD *)this + 17) = &off_1E41A9BB0;
  *((_DWORD *)this + 38) = 0;
  *((_QWORD *)this + 20) = 0;
}

uint64_t CPSDLayerAndMaskInfo::SkipPast(CPSDLayerAndMaskInfo *this, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v9;

  v9 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v9);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  v4 = SetFilePointer(a2, 0, 0, 1);
  v5 = *((_DWORD *)this + 4);
  if (v5)
  {
    v6 = v4;
    v7 = *((_QWORD *)this + 4);
    if (*(unsigned __int16 *)(v7 + 152) < 9u)
    {
      CPSDLayerInfo::LoadLayerInfo((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
      v5 = *((_DWORD *)this + 4);
    }
    else if (*(unsigned __int16 *)(v7 + 154) < *(unsigned __int16 *)(v7 + 140))
    {
      *(_BYTE *)(v7 + 104) = 1;
    }
    SetFilePointer(a2, (v5 + v6), 0, 0);
  }
  return 1;
}

uint64_t CPSDLayerInfo::Load(CPSDLayerInfo *this, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  CPSDLayerChannelGroup *v9;
  uint64_t v10;

  result = CPSDLayerInfo::LoadLayerInfo(this, a2);
  if ((_DWORD)result)
  {
    std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 48, *((unsigned __int16 *)this + 10));
    v5 = 0;
    v6 = 0;
    v7 = *((unsigned __int16 *)this + 10);
    *((_WORD *)this + 10) = 0;
    do
    {
      v8 = v6;
      if (v7 == v6)
        break;
      v9 = (CPSDLayerChannelGroup *)operator new(40, 0x10A1C401A1F3E30);
      CPSDLayerChannelGroup::CPSDLayerChannelGroup(v9, (CPSDLayerRecord *)(*((_QWORD *)this + 3) + v5));
      *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v8) = v9;
      v6 = v8 + 1;
      *((_WORD *)this + 10) = v8 + 1;
      v10 = *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v8);
      v5 += 488;
    }
    while ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 16))(v10, a2));
    return v8 >= v7;
  }
  return result;
}

void sub_19EC1353C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10A1C401A1F3E30);
  _Unwind_Resume(a1);
}

uint64_t CPSDGlobalLayerMaskInfo::Load(CPSDGlobalLayerMaskInfo *this, int a2, unsigned int a3)
{
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  char v15;
  int v16;
  int v17;

  v6 = SetFilePointer(a2, 0, 0, 1);
  v17 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v17);
  v7 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v7);
  if (v7)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 2uLL, &v17);
    *((_WORD *)this + 10) = bswap32(*((unsigned __int16 *)this + 10)) >> 16;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 22, 8uLL, &v17);
    *(int8x8_t *)((char *)this + 22) = vrev16_s8(*(int8x8_t *)((char *)this + 22));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 30, 2uLL, &v17);
    *((_WORD *)this + 15) = bswap32(*((unsigned __int16 *)this + 15)) >> 16;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 1uLL, &v17);
  }
  v8 = SetFilePointer(a2, 0, 0, 1) - v6;
  v16 = 0;
  do
  {
    v15 = -1;
    CPSDBaseComponent::ReadFile(a2, &v15, 1uLL, &v16);
    v9 = v16;
    v10 = *((_DWORD *)this + 9) + v16;
    *((_DWORD *)this + 9) = v10;
    v11 = v8 + v10;
  }
  while (v9 == 1 && v11 < a3 && v15 == 0);
  if (v9 == 1)
  {
    SetFilePointer(a2, -1, 0, 1);
    --*((_DWORD *)this + 9);
  }
  return 1;
}

uint64_t CPSDLayerInfo::Save(CPSDLayerInfo *this, File *a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v7;
  uint64_t v8;

  result = CPSDLayerInfo::SaveLayerInfo(this, a2);
  v5 = *((unsigned __int16 *)this + 10);
  if (v5 == (uint64_t)(*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 3 && (_DWORD)v5 != 0)
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v7);
      result = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)v8 + 24))(v8, a2);
      ++v7;
    }
    while (v7 < *((unsigned __int16 *)this + 10));
  }
  return result;
}

uint64_t CPSDGlobalLayerMaskInfo::Save(CPSDGlobalLayerMaskInfo *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4))
  {
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 10));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 11));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 12));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 13));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 14));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 15));
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 32));
  }
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 56))(a2, *((unsigned int *)this + 9));
}

uint64_t CPSDLayerInfo::LoadLayer(CPSDLayerInfo *this, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int v6;
  off_t v7;

  v4 = SetFilePointer(a2, 0, 0, 1);
  if (!CPSDLayerInfo::LoadLayerInfo(this, a2))
    return 0;
  v5 = 1;
  v6 = SetFilePointer(a2, 0, 0, 1);
  v7 = (*((_DWORD *)this + 4) + v4);
  if (v6 != (_DWORD)v7)
    SetFilePointer(a2, v7, 0, 0);
  return v5;
}

uint64_t CPSDLayerInfo::Dump(CPSDLayerInfo *this, __sFILE *a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  const char *v7;
  uint64_t v8;
  char v9[256];

  result = fprintf(a2, "{ LayerInfo: %d layers [%d bytes]\n", *((unsigned __int16 *)this + 10), *((_DWORD *)this + 4));
  if (*((_WORD *)this + 10))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      CPSDLayerRecord::GetLayerName((CPSDLayerRecord *)(*((_QWORD *)this + 3) + v5), v9, 0x100u);
      if (CPSDLayerRecord::GetSectionDivider((CPSDLayerRecord *)(*((_QWORD *)this + 3) + v5)))
        v7 = "Group";
      else
        v7 = "Layer";
      fprintf(a2, "\n  ================ %s: [ %s ] ==================\n", v7, v9);
      (*(void (**)(uint64_t, __sFILE *))(*(_QWORD *)(*((_QWORD *)this + 3) + v5) + 40))(*((_QWORD *)this + 3) + v5, a2);
      v8 = *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v6);
      result = (*(uint64_t (**)(uint64_t, __sFILE *))(*(_QWORD *)v8 + 40))(v8, a2);
      ++v6;
      v5 += 488;
    }
    while (v6 < *((unsigned __int16 *)this + 10));
  }
  return result;
}

void CPSDChannelData::~CPSDChannelData(CPSDChannelData *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A90C8;
  if (*((_WORD *)this + 12))
  {
    v2 = *((_QWORD *)this + 4);
    if (v2)
      MEMORY[0x1A1AEEAF0](v2, 0x1000C80BDFB0063);
  }
  v3 = *((_QWORD *)this + 5);
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
}

{
  CPSDChannelData::~CPSDChannelData(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDChannelData::UnpackImageInPosition(CPSDChannelData *this, unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  unsigned int v12;
  const unsigned __int8 *v13;
  unsigned __int16 *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int16 v23;
  size_t v24;
  unsigned int v25;

  v12 = a10;
  v14 = (unsigned __int16 *)*((_QWORD *)this + 4);
  v13 = (const unsigned __int8 *)*((_QWORD *)this + 5);
  v15 = *((_DWORD *)this + 5);
  if (v15 >= a8)
    v16 = a8;
  else
    v16 = *((_DWORD *)this + 5);
  if (v15 >= a6)
    v17 = a6;
  else
    v17 = *((_DWORD *)this + 5);
  if (a10 >= a4)
    v12 = a4;
  if (v15)
  {
    v18 = (unsigned __int16)(*((_DWORD *)this + 12) / v15);
    if (!v17)
      goto LABEL_17;
  }
  else
  {
    v18 = 0;
    if (!v17)
      goto LABEL_17;
  }
  do
  {
    if (*((_WORD *)this + 12))
    {
      v20 = *v14++;
      v19 = v20;
    }
    else
    {
      v19 = v18;
    }
    v13 += v19;
    --v17;
  }
  while (v17);
LABEL_17:
  *((_BYTE *)this + 52) = 1;
  if (v16)
  {
    v21 = a3;
    v22 = &a2[a9 + v12 * (unint64_t)a3];
    if (a3 >= a7)
      v23 = a7;
    else
      v23 = a3;
    v24 = v23;
    do
    {
      if (*((_WORD *)this + 12))
      {
        v25 = *v14++;
        v18 = v25;
      }
      CPSDChannelData::UnpackRowBits(this, v13, (unsigned __int16)v18, v22, v24, a5);
      v13 += v18;
      v22 += v21;
      --v16;
    }
    while (v16);
  }
  return 1;
}

uint64_t CPSDChannelData::UnpackRowBits(CPSDChannelData *this, const unsigned __int8 *a2, int a3, unsigned __int8 *__b, size_t __n, int a6)
{
  unsigned int v6;
  unsigned __int8 *v7;
  const unsigned __int8 *v8;
  int v10;
  int v11;
  int v12;
  const unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  __int16 v17;
  int v18;
  unsigned __int16 v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v25;

  v6 = __n;
  v7 = __b;
  v8 = a2;
  if (*((_WORD *)this + 12))
  {
    v10 = a3;
    if (a3 && (_DWORD)__n)
    {
      v11 = 0;
      v25 = a6;
      do
      {
        v13 = v8 + 1;
        v12 = *(char *)v8;
        if (v12 < 0)
        {
          if (v12 == -128)
          {
            --v10;
            ++v8;
            continue;
          }
          v19 = 1 - v12;
          v20 = v8[1];
          LODWORD(v14) = v19;
          if (v19 >= v6)
            v21 = v6;
          else
            v21 = v19;
          v22 = (v11 - a6 + v19) & ~((v11 - a6 + v19) >> 31);
          if (v21 >= v22)
            v23 = v22;
          else
            v23 = v21;
          if (v23)
          {
            memset(v7, v8[1], (__int16)v23);
            a6 = v25;
          }
          if (*((_BYTE *)this + 52) && v20)
            *((_BYTE *)this + 52) = 0;
          v8 += 2;
          v10 -= 2;
          v18 = (__int16)v23;
          v7 += (__int16)v23;
        }
        else
        {
          v14 = *(char *)v8 + 1;
          v15 = a6 - v11;
          if (v14 >= v6)
            v16 = v6;
          else
            v16 = *(char *)v8 + 1;
          if (v16 >= (((_DWORD)v14 - v15) & ~(((int)v14 - v15) >> 31)))
            v17 = (v14 - v15) & ~(unsigned __int16)(((int)v14 - v15) >> 31);
          else
            v17 = v16;
          if (v17)
          {
            memcpy(v7, &v13[(unsigned __int16)(v15 & ~(unsigned __int16)(v15 >> 31))], v17);
            a6 = v25;
          }
          v8 = &v13[v14];
          v10 = v10 - 1 - v14;
          v18 = v17;
          v7 += v17;
          if (*((_BYTE *)this + 52))
            *((_BYTE *)this + 52) = 0;
        }
        v6 -= v18;
        v11 += v14;
      }
      while ((_WORD)v10 && v6);
    }
  }
  else
  {
    memcpy(__b, &a2[a6], __n);
    if (*((_BYTE *)this + 52))
      *((_BYTE *)this + 52) = 0;
  }
  return 1;
}

BOOL CPSDChannelData::Load(CPSDChannelData *this, uint64_t a2, int a3, int a4)
{
  int v6;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  _WORD *v11;
  unsigned int v12;
  int v14;

  v14 = 0;
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = a4;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 2uLL, &v14);
  v6 = v14;
  v7 = bswap32(*((unsigned __int16 *)this + 12)) >> 16;
  *((_WORD *)this + 12) = v7;
  if (v7)
  {
    if (v7 != 1)
    {
      printf("Error - Unhandled compression type.  We currently handle 'Run Length Encoding' and 'no compression' only.");
      return 0;
    }
    v8 = (char *)operator new[](2 * *((unsigned int *)this + 5), 0x1000C80BDFB0063);
    *((_QWORD *)this + 4) = v8;
    CPSDBaseComponent::ReadFile(a2, v8, (2 * *((_DWORD *)this + 5)), &v14);
    v6 += v14;
    v9 = *((unsigned int *)this + 5);
    if ((_DWORD)v9)
    {
      LODWORD(v10) = 0;
      v11 = (_WORD *)*((_QWORD *)this + 4);
      do
      {
        v12 = bswap32((unsigned __int16)*v11);
        *v11++ = HIWORD(v12);
        v10 = v10 + HIWORD(v12);
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    v10 = (*((_DWORD *)this + 4) - 2);
  }
  (*(void (**)(CPSDChannelData *, uint64_t, uint64_t))(*(_QWORD *)this + 56))(this, a2, v10);
  return (_DWORD)v10 + v6 == *((_DWORD *)this + 4);
}

uint64_t CPSDChannelData::Save(CPSDChannelData *this, File *a2)
{
  unint64_t v4;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 12));
  if (*((_WORD *)this + 12) && *((_DWORD *)this + 5))
  {
    v4 = 0;
    do
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *(unsigned __int16 *)(*((_QWORD *)this + 4) + 2 * v4++));
    while (v4 < *((unsigned int *)this + 5));
  }
  return (*(uint64_t (**)(CPSDChannelData *, File *))(*(_QWORD *)this + 64))(this, a2);
}

uint64_t CPSDChannelData::LoadChannelData(uint64_t this, int a2, unsigned int a3)
{
  uint64_t v3;
  char *v5;
  int v6;

  v3 = this;
  *(_DWORD *)(this + 48) = a3;
  if (a3)
  {
    v6 = 0;
    v5 = (char *)operator new[](a3, 0x1000C8077774924);
    *(_QWORD *)(v3 + 40) = v5;
    this = CPSDBaseComponent::ReadFile(a2, v5, *(unsigned int *)(v3 + 48), &v6);
    if (v6 != *(_DWORD *)(v3 + 48))
      CPSDChannelData::LoadChannelData();
  }
  else
  {
    *(_QWORD *)(this + 40) = 0;
  }
  return this;
}

uint64_t CPSDChannelData::SaveChannelData(uint64_t this, File *a2)
{
  if (*(_DWORD *)(this + 48))
    return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *(_QWORD *)(this + 40));
  return this;
}

BOOL CPSDLayerChannelGroup::Load(CPSDLayerChannelGroup *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _BOOL8 result;

  if (!*((_DWORD *)this + 6))
    return 1;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = *((_QWORD *)this + 2);
    v8 = *(_QWORD *)(v7 + 40) + v4;
    v9 = *(unsigned __int16 *)(v8 + 16);
    if (v9 == 65533)
    {
      v10 = *(_DWORD *)(v7 + 128);
      v11 = *(_DWORD *)(v7 + 120);
    }
    else if (v9 == 65534)
    {
      v10 = *(_DWORD *)(v7 + 108);
      v11 = *(_DWORD *)(v7 + 100);
    }
    else
    {
      v10 = *(_DWORD *)(v7 + 24);
      v11 = *(_DWORD *)(v7 + 16);
    }
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(*((_QWORD *)this + 4) + v5) + 48))(*((_QWORD *)this + 4) + v5, a2, *(unsigned int *)(v8 + 20), (v10 - v11));
    result = v12 != 0;
    if (!v12)
      break;
    ++v6;
    v5 += 56;
    v4 += 24;
  }
  while (v6 < *((unsigned int *)this + 6));
  return result;
}

uint64_t CPSDLayerChannelGroup::Save(uint64_t this, File *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  if (*(_DWORD *)(this + 24))
  {
    v3 = this;
    v4 = 0;
    v5 = 0;
    do
    {
      this = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)(*(_QWORD *)(v3 + 32) + v4) + 24))(*(_QWORD *)(v3 + 32) + v4, a2);
      ++v5;
      v4 += 56;
    }
    while (v5 < *(unsigned int *)(v3 + 24));
  }
  return this;
}

void CPSDLayerInfo::~CPSDLayerInfo(CPSDLayerInfo *this)
{
  _QWORD *v2;
  _QWORD *v3;
  char *v4;
  unint64_t v5;
  uint64_t v6;
  void **v7;

  *(_QWORD *)this = &off_1E41A8F58;
  v4 = (char *)this + 48;
  v2 = (_QWORD *)*((_QWORD *)this + 6);
  v3 = (_QWORD *)*((_QWORD *)v4 + 1);
  if (v3 == v2)
  {
    v2 = v3;
    if (!v3)
      goto LABEL_8;
    goto LABEL_7;
  }
  v5 = 0;
  do
  {
    v6 = v2[v5];
    if (v6)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v6 + 8))(v2[v5]);
      v2 = (_QWORD *)*((_QWORD *)this + 6);
      v3 = (_QWORD *)*((_QWORD *)this + 7);
    }
    ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
LABEL_8:
  v7 = (void **)((char *)this + 24);
  std::vector<CPSDLayerRecord>::__destroy_vector::operator()[abi:ne180100](&v7);
}

{
  CPSDLayerInfo::~CPSDLayerInfo(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDLayerInfo::LoadLayerInfo(CPSDLayerInfo *this, uint64_t a2)
{
  void (***v4)(_QWORD);
  uint64_t *v5;
  void (***v6)(_QWORD);
  void (***v7)(_QWORD);
  BOOL v8;
  unsigned int v9;
  int v10;
  int v11;
  _WORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t result;
  unsigned __int16 v16;
  int v17;

  v6 = (void (***)(_QWORD))*((_QWORD *)this + 3);
  v4 = (void (***)(_QWORD))*((_QWORD *)this + 4);
  v5 = (uint64_t *)((char *)this + 24);
  if (v4 != v6)
  {
    v7 = v4 - 61;
    do
    {
      (**v7)(v7);
      v8 = v7 == v6;
      v7 -= 61;
    }
    while (!v8);
  }
  v17 = 0;
  *((_QWORD *)this + 4) = v6;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v17);
  v9 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v9);
  if (!v9)
    return 1;
  v16 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v16, 2uLL, &v17);
  v10 = v16;
  v11 = (int)bswap32(v16) >> 16;
  v16 = __rev16(v16);
  if (v11 < 0)
  {
    v11 = -v11;
    *((_WORD *)this + 10) = v11;
    v12 = (_WORD *)((char *)this + 20);
    *(_BYTE *)(*((_QWORD *)this + 1) + 104) = 1;
  }
  else
  {
    *((_WORD *)this + 10) = v11;
    v12 = (_WORD *)((char *)this + 20);
    if (!v10)
      return 1;
  }
  std::vector<CPSDLayerRecord>::resize(v5, (unsigned __int16)v11);
  if (!*v12)
    return 1;
  v13 = 0;
  v14 = 0;
  while (1)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(*((_QWORD *)this + 3) + v13) + 32))(*((_QWORD *)this + 3) + v13, *((_QWORD *)this + 1));
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*((_QWORD *)this + 3) + v13) + 16))(*((_QWORD *)this + 3) + v13, a2);
    if (!(_DWORD)result)
      break;
    ++v14;
    v13 += 488;
    if (v14 >= (unsigned __int16)*v12)
      return 1;
  }
  return result;
}

void std::vector<CPSDLayerRecord>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void (***v8)(_QWORD);
  BOOL v9;

  v3 = a1[1];
  v4 = 0x4FBCDA3AC10C9715 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<CPSDLayerRecord>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 488 * a2;
    if (v3 != v7)
    {
      v8 = (void (***)(_QWORD))(v3 - 488);
      do
      {
        (**v8)(v8);
        v9 = v8 == (void (***)(_QWORD))v7;
        v8 -= 61;
      }
      while (!v9);
    }
    a1[1] = v7;
  }
}

uint64_t CPSDLayerInfo::SaveLayerInfo(CPSDLayerInfo *this, File *a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 104))
    v4 = -*((unsigned __int16 *)this + 10);
  else
    LOWORD(v4) = *((_WORD *)this + 10);
  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, (unsigned __int16)v4);
  v6 = *((unsigned __int16 *)this + 10);
  if (0x4FBCDA3AC10C9715 * ((uint64_t)(*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 3) == v6 && (_DWORD)v6 != 0)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)(*((_QWORD *)this + 3) + v8) + 24))(*((_QWORD *)this + 3) + v8, a2);
      ++v9;
      v8 += 488;
    }
    while (v9 < *((unsigned __int16 *)this + 10));
  }
  return result;
}

void CPSDLayerInfo::CreateImageAtLayer(CPSDLayerInfo *this, unsigned int a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  CPSDLayerImage *v7;

  if (*((unsigned __int16 *)this + 10) >= a2)
  {
    if (CPSDFile::IsTaggedWithICCProfile(*((CPSDFile **)this + 1)))
    {
      v4 = CPSDImageResources::LookupResourceWithResID((CPSDImageResources *)(*((_QWORD *)this + 1) + 192), 1039);
      v5 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 56))(v4);
      v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    }
    else
    {
      v5 = 0;
      v6 = 0;
    }
    v7 = (CPSDLayerImage *)operator new(72, 0x10B1C40772D3F4BLL);
    CPSDLayerImage::CPSDLayerImage(v7, (CPSDLayerRecord *)(*((_QWORD *)this + 3) + 488 * a2), *(CPSDLayerChannelGroup **)(*((_QWORD *)this + 6) + 8 * a2), *(_WORD *)(*((_QWORD *)this + 1) + 154), *(unsigned __int16 *)(*((_QWORD *)this + 1) + 152), v6, v5);
  }
}

void CPSDLayerInfo::CreateImageAtLayerWithSlice(CPSDLayerInfo *this, unsigned int a2, CPSDSliceResource *a3)
{
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  CPSDLayerSliceImage *v8;
  int32x4_t v9;

  if (*((unsigned __int16 *)this + 10) >= a2)
  {
    v9 = vrev64q_s32(*(int32x4_t *)((char *)a3 + 52));
    if (CPSDFile::IsTaggedWithICCProfile(*((CPSDFile **)this + 1)))
    {
      v5 = CPSDImageResources::LookupResourceWithResID((CPSDImageResources *)(*((_QWORD *)this + 1) + 192), 1039);
      v6 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 56))(v5);
      v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    }
    else
    {
      v6 = 0;
      v7 = 0;
    }
    v8 = (CPSDLayerSliceImage *)operator new(96, 0x10B1C40763CCA06);
    CPSDLayerSliceImage::CPSDLayerSliceImage(v8, (CPSDLayerRecord *)(*((_QWORD *)this + 3) + 488 * a2), *(CPSDLayerChannelGroup **)(*((_QWORD *)this + 6) + 8 * a2), (PSDRect *)&v9, *(_WORD *)(*((_QWORD *)this + 1) + 154), *(unsigned __int16 *)(*((_QWORD *)this + 1) + 152), v7, v6);
  }
}

void CPSDAdditionalLayerInfo::~CPSDAdditionalLayerInfo(CPSDAdditionalLayerInfo *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E41A9BB0;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E41A9BB0;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDLayerBlendingRanges::~CPSDLayerBlendingRanges(CPSDLayerBlendingRanges *this)
{
  void **v1;

  *(_QWORD *)this = off_1E41A9CC0;
  v1 = (void **)((char *)this + 32);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(_QWORD *)this = off_1E41A9CC0;
  v2 = (void **)((char *)this + 32);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1A1AEEB08](this, 0x10A1C40D16F0FACLL);
}

void CPSDLayerRecord::~CPSDLayerRecord(CPSDLayerRecord *this)
{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E41A9120;
  *((_QWORD *)this + 57) = &off_1E41A9BB0;
  v2 = *((_QWORD *)this + 60);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 18) = off_1E41A9CC0;
  v3 = (void **)((char *)this + 176);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 40);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v3);
}

{
  CPSDLayerRecord::~CPSDLayerRecord(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDLayerRecord::Dump(CPSDLayerRecord *this, __sFILE *a2)
{
  const char *v4;
  int v5;
  int *v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int *v12;
  int v13;
  float v14;
  uint64_t v15;
  uint64_t v17;
  unint64_t v18;
  const char *v19;
  size_t v20;
  int v21;
  _QWORD *FillOpacityObject;
  int v23;
  _QWORD *UnicodeLayerName;
  _QWORD *SectionDivider;
  _QWORD *v26;
  int v27;
  const char *v28;
  size_t v29;
  _QWORD *VectorMaskData;
  _QWORD *GradientFillInfo;
  _QWORD *ObjectEffectsLayerInfo;
  unsigned int v34;
  char v35;

  fprintf(a2, "{    Rect: { %d,%d,%d,%d } x %d Channels\n", *((_DWORD *)this + 5), *((_DWORD *)this + 4), *((_DWORD *)this + 7), *((_DWORD *)this + 6), *((unsigned __int16 *)this + 16));
  v4 = "No";
  if ((*((_BYTE *)this + 74) & 2) == 0)
    v4 = "Yes";
  fprintf(a2, "     Visible: %s\t\t\t\t\tExtraDataSize: [%d bytes]\n", v4, *((_DWORD *)this + 19));
  if (*((_WORD *)this + 16))
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)this + 5) + 20);
    v7 = *((unsigned __int16 *)this + 16);
    do
    {
      v8 = *v6;
      v6 += 6;
      v5 += v8;
      --v7;
    }
    while (v7);
  }
  else
  {
    v5 = 0;
  }
  if (*((_WORD *)this + 16))
  {
    v10 = 0;
    v11 = *((unsigned __int16 *)this + 16);
    v12 = (int *)(*((_QWORD *)this + 5) + 20);
    do
    {
      v13 = *v12;
      v12 += 6;
      v10 += v13;
      --v11;
    }
    while (v11);
    v14 = (float)v10;
  }
  else
  {
    v14 = 0.0;
  }
  v9 = 4
     * *((unsigned __int16 *)this + 16)
     * (*((_DWORD *)this + 7) - *((_DWORD *)this + 5))
     * (*((_DWORD *)this + 6) - *((_DWORD *)this + 4));
  fprintf(a2, "     Channels:   [%d bytes]\t\tUncompressed: [%d bytes]\tRatio: %f\n", v5, v9, (float)(v14 / (float)v9));
  v15 = *((unsigned __int16 *)this + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3) == v15 && (_DWORD)v15 != 0)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      fprintf(a2, "          Channel %d:\t%8d bytes, id=%d ", v18, *(_DWORD *)(*((_QWORD *)this + 5) + v17 + 20), *(__int16 *)(*((_QWORD *)this + 5) + v17 + 16));
      switch(*(_WORD *)(*((_QWORD *)this + 5) + v17 + 16))
      {
        case 0xFFFE:
          v19 = "(user supplied layer mask or vector mask)";
          v20 = 41;
          break;
        case 0xFFFF:
          v19 = "(transparency mask)";
          v20 = 19;
          break;
        case 0:
          v19 = "(R)";
          goto LABEL_25;
        case 1:
          v19 = "(G)";
          goto LABEL_25;
        case 2:
          v19 = "(B)";
LABEL_25:
          v20 = 3;
          break;
        default:
          v19 = "(real layer mask)";
          v20 = 17;
          break;
      }
      fwrite(v19, v20, 1uLL, a2);
      fputc(10, a2);
      ++v18;
      v17 += 24;
    }
    while (v18 < *((unsigned __int16 *)this + 16));
  }
  v35 = 0;
  v34 = bswap32(*((_DWORD *)this + 17));
  v21 = *((unsigned __int8 *)this + 72);
  FillOpacityObject = CPSDLayerRecord::GetFillOpacityObject(this);
  if (FillOpacityObject)
    v23 = *((unsigned __int8 *)FillOpacityObject + 56);
  else
    v23 = 255;
  fprintf(a2, "     BlendModeKey: '%s'\tOpacity: %d\tFill Opacity: %d (out of 255)\n", (const char *)&v34, v21, v23);
  CPSDLayerMaskData::Dump((_DWORD *)this + 20, a2);
  UnicodeLayerName = CPSDLayerRecord::GetUnicodeLayerName(this);
  if (UnicodeLayerName)
    (*(void (**)(_QWORD *, __sFILE *))(*UnicodeLayerName + 40))(UnicodeLayerName, a2);
  SectionDivider = CPSDLayerRecord::GetSectionDivider(this);
  if (SectionDivider)
  {
    v26 = SectionDivider;
    fwrite("{ Section Divider Type: ", 0x18uLL, 1uLL, a2);
    v27 = *((_DWORD *)v26 + 14);
    switch(v27)
    {
      case 3:
        v28 = "Bounding section divider, hidden in the UI";
        v29 = 42;
        break;
      case 2:
        v28 = "Closed \"folder\"";
        v29 = 15;
        break;
      case 1:
        v28 = "Open \"folder\"";
        v29 = 13;
        break;
      default:
        v28 = "Any other type of layer";
        v29 = 23;
        break;
    }
    fwrite(v28, v29, 1uLL, a2);
    fwrite(" }\n", 3uLL, 1uLL, a2);
  }
  VectorMaskData = CPSDLayerRecord::GetVectorMaskData(this);
  if (VectorMaskData)
    (*(void (**)(_QWORD *, __sFILE *))(*VectorMaskData + 40))(VectorMaskData, a2);
  GradientFillInfo = CPSDLayerRecord::GetGradientFillInfo(this);
  if (GradientFillInfo)
    (*(void (**)(_QWORD *, __sFILE *))(*GradientFillInfo + 40))(GradientFillInfo, a2);
  ObjectEffectsLayerInfo = CPSDLayerRecord::GetObjectEffectsLayerInfo(this);
  if (ObjectEffectsLayerInfo)
    (*(void (**)(_QWORD *, __sFILE *))(*ObjectEffectsLayerInfo + 40))(ObjectEffectsLayerInfo, a2);
  return fputc(125, a2);
}

_DWORD *CPSDLayerMaskData::Dump(_DWORD *this, __sFILE *a2)
{
  int v2;

  v2 = this[4];
  if (v2)
    return (_DWORD *)fprintf(a2, "{ LayerMaskData: {%d,%d,%d,%d} size=%d }\n", this[5], this[6], this[7], this[8], v2);
  return this;
}

_QWORD *CPSDLayerRecord::GetUnicodeLayerName(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
      break;
  }
  return i;
}

_QWORD *CPSDLayerRecord::GetSectionDivider(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
      break;
  }
  return i;
}

_QWORD *CPSDLayerRecord::GetVectorMaskData(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
      break;
  }
  return i;
}

uint64_t CPSDLayerRecord::Load(CPSDLayerRecord *this, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  int v11;

  v11 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v11);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v11);
  *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 4uLL, &v11);
  *((_DWORD *)this + 6) = bswap32(*((_DWORD *)this + 6));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 4uLL, &v11);
  *((_DWORD *)this + 7) = bswap32(*((_DWORD *)this + 7));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 2uLL, &v11);
  v4 = *((unsigned __int16 *)this + 16);
  v5 = __rev16(v4);
  *((_WORD *)this + 16) = v5;
  if (v4 && (std::vector<CPSDChannelLengthInfo>::resize((uint64_t)this + 40, v5), *((_WORD *)this + 16)))
  {
    v6 = 0;
    v7 = 0;
    while (1)
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*((_QWORD *)this + 5) + v6) + 16))(*((_QWORD *)this + 5) + v6, a2);
      if (!(_DWORD)result)
        break;
      ++v7;
      v6 += 24;
      if (v7 >= *((unsigned __int16 *)this + 16))
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    CPSDBaseComponent::ReadFile(a2, (char *)this + 64, 4uLL, &v11);
    *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 68, 4uLL, &v11);
    *((_DWORD *)this + 17) = bswap32(*((_DWORD *)this + 17));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 72, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 73, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 74, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 75, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 76, 4uLL, &v11);
    *((_DWORD *)this + 19) = bswap32(*((_DWORD *)this + 19));
    v9 = *((_DWORD *)this + 19) + SetFilePointer(a2, 0, 0, 1);
    CPSDLayerMaskData::Load((CPSDLayerRecord *)((char *)this + 80), a2);
    CPSDLayerBlendingRanges::Load((CPSDLayerRecord *)((char *)this + 144), a2);
    LoadPascalStringAsCString(a2, &v11, (char *)this + 200, 4);
    v10 = SetFilePointer(a2, 0, 0, 1);
    if (v9 >= v10)
    {
      *((_DWORD *)this + 118) = v9 - v10;
      CPSDAdditionalLayerInfo::Load((CPSDLayerRecord *)((char *)this + 456), a2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CPSDLayerMaskData::Load(CPSDLayerMaskData *this, int a2)
{
  unsigned int v4;
  int v6;

  v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v6);
  v4 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v4);
  if (v4)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v6);
    *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 4uLL, &v6);
    *((_DWORD *)this + 6) = bswap32(*((_DWORD *)this + 6));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 4uLL, &v6);
    *((_DWORD *)this + 7) = bswap32(*((_DWORD *)this + 7));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 4uLL, &v6);
    *((_DWORD *)this + 8) = bswap32(*((_DWORD *)this + 8));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 36, 1uLL, &v6);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 37, 1uLL, &v6);
    if (*((_DWORD *)this + 4) == 20)
    {
      CPSDBaseComponent::ReadFile(a2, (char *)this + 38, 2uLL, &v6);
      *((_WORD *)this + 19) = bswap32(*((unsigned __int16 *)this + 19)) >> 16;
    }
    else
    {
      CPSDBaseComponent::ReadFile(a2, (char *)this + 57, 1uLL, &v6);
      CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 1uLL, &v6);
      CPSDBaseComponent::ReadFile(a2, (char *)this + 40, 4uLL, &v6);
      *((_DWORD *)this + 10) = bswap32(*((_DWORD *)this + 10));
      CPSDBaseComponent::ReadFile(a2, (char *)this + 44, 4uLL, &v6);
      *((_DWORD *)this + 11) = bswap32(*((_DWORD *)this + 11));
      CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v6);
      *((_DWORD *)this + 12) = bswap32(*((_DWORD *)this + 12));
      CPSDBaseComponent::ReadFile(a2, (char *)this + 52, 4uLL, &v6);
      *((_DWORD *)this + 13) = bswap32(*((_DWORD *)this + 13));
    }
  }
  return 1;
}

uint64_t CPSDLayerBlendingRanges::Load(CPSDLayerBlendingRanges *this, uint64_t a2)
{
  void (***v4)(_QWORD);
  _QWORD *v5;
  void (***v6)(_QWORD);
  void (***v7)(_QWORD);
  void (***v8)(_QWORD);
  void (**v9)(_QWORD);
  BOOL v10;
  _DWORD *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  off_t v20;
  int v22;

  v6 = (void (***)(_QWORD))*((_QWORD *)this + 4);
  v4 = (void (***)(_QWORD))*((_QWORD *)this + 5);
  v5 = (_QWORD *)((char *)this + 32);
  if (v4 != v6)
  {
    v7 = v4 - 3;
    v8 = v4 - 3;
    do
    {
      v9 = *v8;
      v8 -= 3;
      (*v9)(v7);
      v10 = v7 == v6;
      v7 = v8;
    }
    while (!v10);
  }
  v22 = 0;
  *((_QWORD *)this + 5) = v6;
  v11 = (_DWORD *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v22);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  v12 = SetFilePointer(a2, 0, 0, 1);
  if (*((_DWORD *)this + 4) < 8u
    || (CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v22),
        *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5)),
        CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 4uLL, &v22),
        *((_DWORD *)this + 6) = bswap32(*((_DWORD *)this + 6)),
        v13 = *((_DWORD *)this + 4) - 8,
        v13 < 8))
  {
LABEL_13:
    v18 = 1;
    v19 = SetFilePointer(a2, 0, 0, 1);
    v20 = (*v11 + v12);
    if (v19 != (_DWORD)v20)
      SetFilePointer(a2, v20, 0, 0);
  }
  else
  {
    v14 = v13 >> 3;
    std::vector<CPSDChannelBlendingInfo>::resize((uint64_t)v5, v13 >> 3);
    v15 = 0;
    if (v14 <= 1)
      v16 = 1;
    else
      v16 = v14;
    v17 = 24 * v16;
    while ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(*v5 + v15) + 16))(*v5 + v15, a2))
    {
      v15 += 24;
      if (v17 == v15)
        goto LABEL_13;
    }
    return 0;
  }
  return v18;
}

uint64_t CPSDLayerRecord::Save(CPSDLayerRecord *this, File *a2)
{
  uint64_t v4;
  uint64_t v6;
  unint64_t v7;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 5));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 6));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 7));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 16));
  v4 = *((unsigned __int16 *)this + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3) == v4 && (_DWORD)v4 != 0)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      (*(void (**)(uint64_t, File *))(*(_QWORD *)(*((_QWORD *)this + 5) + v6) + 24))(*((_QWORD *)this + 5) + v6, a2);
      ++v7;
      v6 += 24;
    }
    while (v7 < *((unsigned __int16 *)this + 16));
  }
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 16));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 17));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 72));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 73));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 74));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 75));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 19));
  CPSDLayerMaskData::Save((CPSDLayerRecord *)((char *)this + 80), a2);
  CPSDLayerBlendingRanges::Save((CPSDLayerRecord *)((char *)this + 144), a2);
  (*(void (**)(File *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)this + 200, 4);
  return CPSDAdditionalLayerInfo::Save((uint64_t)this + 456, a2);
}

uint64_t CPSDLayerRecord::SeekPast(CPSDLayerRecord *this, int a2)
{
  unint64_t v4;
  uint64_t v5;
  CStdException *exception;

  if (*((_WORD *)this + 16))
  {
    v4 = 0;
    v5 = 20;
    do
    {
      if (SetFilePointer(a2, *(unsigned int *)(*((_QWORD *)this + 5) + v5), 0, 1) == -1)
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      ++v4;
      v5 += 24;
    }
    while (v4 < *((unsigned __int16 *)this + 16));
  }
  return 1;
}

void sub_19EC154D4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *CPSDLayerRecord::GetUnicodeLayerName(CPSDLayerRecord *this, unsigned int *a2)
{
  _QWORD *result;

  result = CPSDLayerRecord::GetUnicodeLayerName(this);
  if (result)
  {
    if (a2)
      *a2 = *((_DWORD *)result + 14);
    return (_QWORD *)result[8];
  }
  return result;
}

BOOL CPSDLayerRecord::GetTransparencyMask(CPSDLayerRecord *this)
{
  unint64_t v1;
  uint64_t v2;
  __int16 *v3;
  uint64_t v4;
  unint64_t v5;
  int v6;

  v1 = *((unsigned __int16 *)this + 16);
  if (!*((_WORD *)this + 16))
    return 0;
  v2 = *((_QWORD *)this + 5);
  if (*(__int16 *)(v2 + 16) == -1)
    return 1;
  v3 = (__int16 *)(v2 + 40);
  v4 = 1;
  do
  {
    v5 = v4;
    if (v1 == v4)
      break;
    v6 = *v3;
    v3 += 12;
    ++v4;
  }
  while (v6 != -1);
  return v5 < v1;
}

uint64_t CPSDImageLoad::DeAllocateChannelBuffers(CPSDImageLoad *this)
{
  unint64_t v2;

  if (*((_QWORD *)this + 10))
  {
    if (!*((_WORD *)this + 22))
      goto LABEL_6;
    v2 = 0;
    do
      free(*(void **)(*((_QWORD *)this + 10) + 8 * v2++));
    while (v2 < *((unsigned __int16 *)this + 22));
    if (*((_QWORD *)this + 10))
LABEL_6:
      MEMORY[0x1A1AEEAF0]();
    *((_QWORD *)this + 10) = 0;
  }
  return 1;
}

uint64_t CPSDImageLoad::Initialize(CPSDImageLoad *this, int a2, int a3, __int16 a4, __int16 a5, __int16 a6, unsigned __int8 *a7)
{
  *((_DWORD *)this + 9) = a3;
  *((_DWORD *)this + 10) = a2;
  *((_WORD *)this + 22) = a4;
  *((_WORD *)this + 28) = a5;
  *((_WORD *)this + 29) = a6;
  *((_BYTE *)this + 32) = 1;
  *((_QWORD *)this + 8) = a7;
  return 1;
}

uint64_t CPSDImageLoad::CreatePlanarBitmap(CPSDImageLoad *this)
{
  unint64_t v2;
  unsigned int v3;
  void *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  size_t v8;
  uint64_t v9;
  void *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  unint64_t v16;
  void *v17;

  v2 = *((unsigned __int16 *)this + 28);
  v3 = *((_DWORD *)this + 10);
  v4 = (void *)*((_QWORD *)this + 12);
  if (v4)
  {
    free(v4);
    *((_QWORD *)this + 12) = 0;
  }
  if (*((_WORD *)this + 22))
  {
    v5 = v2 >> 3;
    v6 = (-(v3 * (v2 >> 3)) & 3) + v3 * (unint64_t)(v2 >> 3);
    v7 = malloc_type_malloc(8 * v5 * (unint64_t)*((unsigned __int16 *)this + 22), 0xB4D708C9uLL);
    v8 = v6 * *((unsigned int *)this + 9);
    *((_QWORD *)this + 6) = v8;
    if (*((unsigned __int16 *)this + 22) >= 4u && *((_WORD *)this + 29) == 3)
    {
      if (*((_BYTE *)this + 104))
      {
        v9 = *((_QWORD *)this + 10);
        v10 = malloc_type_malloc(v8, 0x8CBE3C66uLL);
        *v7 = v10;
        memcpy(v10, *(const void **)(v9 + 24), *((_QWORD *)this + 6));
        v11 = *((unsigned __int16 *)this + 22);
        if (*((_WORD *)this + 22))
        {
          v12 = 0;
          v13 = *((_QWORD *)this + 10);
          v14 = v7 + 1;
          do
          {
            if ((_DWORD)v12 != 3)
            {
              v15 = malloc_type_malloc(*((_QWORD *)this + 6), 0x9675BA3EuLL);
              *v14++ = v15;
              memcpy(v15, *(const void **)(v13 + 8 * v12), *((_QWORD *)this + 6));
              v11 = *((unsigned __int16 *)this + 22);
            }
            ++v12;
          }
          while (v12 < v11);
        }
        goto LABEL_16;
      }
    }
    else if (!*((_WORD *)this + 22))
    {
LABEL_16:
      *((_QWORD *)this + 12) = v7;
      return 1;
    }
    v16 = 0;
    do
    {
      v17 = malloc_type_malloc(*((_QWORD *)this + 6), 0xE3B25454uLL);
      v7[v16] = v17;
      memcpy(v17, *(const void **)(*((_QWORD *)this + 10) + 8 * v16++), *((_QWORD *)this + 6));
    }
    while (v16 < *((unsigned __int16 *)this + 22));
    goto LABEL_16;
  }
  return 1;
}

uint64_t CPSDImageLoad::AllocateChannelBuffers(CPSDImageLoad *this, int a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  CStdException *exception;

  *((_QWORD *)this + 10) = operator new[](8 * *((unsigned __int16 *)this + 22), 0x10C80436913F5);
  if (*((_WORD *)this + 22))
  {
    v4 = 0;
    v5 = (-a2 & 3) + a2;
    v6 = 8 * *((unsigned __int16 *)this + 22);
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 10) + v4) = 0;
      v4 += 8;
    }
    while (v6 != v4);
    v7 = 0;
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v7) = malloc_type_malloc((*((_DWORD *)this + 9) * v5), 0x9407C846uLL);
      if (!*(_QWORD *)(*((_QWORD *)this + 10) + 8 * v7))
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395909);
      }
      ++v7;
    }
    while (v7 < *((unsigned __int16 *)this + 22));
  }
  return 1;
}

void sub_19EC15850(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageLoad::FillLayerImageChannelBuffers(CPSDImageLoad *this, unsigned int a2)
{
  unint64_t v4;
  unsigned int v5;
  uint64_t i;
  unsigned int v7;
  int v8;
  unsigned __int16 *ChannelByteCounts;
  unsigned int v10;
  CStdException *exception;

  if (!*((_WORD *)this + 22))
    return 1;
  v4 = 0;
  v5 = *((_DWORD *)this + 7);
  for (i = 20; ; i += 24)
  {
    v7 = *(_DWORD *)(*((_QWORD *)this + 9) + i);
    if (v7 < 5)
    {
      bzero(*(void **)(*((_QWORD *)this + 10) + 8 * v4), *((_DWORD *)this + 9) * a2);
      goto LABEL_9;
    }
    v8 = *((_DWORD *)this + 9) * a2;
    if (*((_WORD *)this + 44) == 1)
    {
      ChannelByteCounts = (unsigned __int16 *)CPSDImageLoad::GetChannelByteCounts(this);
      if (CPSDImageLoad::UncompressChannelImageData(this, ChannelByteCounts, *(unsigned __int8 **)(*((_QWORD *)this + 10) + 8 * v4), a2) != v8)
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      goto LABEL_9;
    }
    if (*((_WORD *)this + 44))
      break;
    memcpy(*(void **)(*((_QWORD *)this + 10) + 8 * v4), (const void *)(*((_QWORD *)this + 2) + v5), *((_DWORD *)this + 9) * a2);
    *((_DWORD *)this + 7) += v8;
LABEL_9:
    v10 = *((_DWORD *)this + 7);
    if (v10 != v7 + v5)
    {
      *((_DWORD *)this + 7) = v7 + v5;
      v10 = v7 + v5;
    }
    ++v4;
    v5 = v10;
    if (v4 >= *((unsigned __int16 *)this + 22))
      return 1;
  }
  return 0;
}

void sub_19EC159AC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageLoad::FillCompositeImageChannelBuffers(CPSDImageLoad *this, unsigned int a2)
{
  size_t v3;
  unint64_t v4;
  unsigned int v5;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  CStdException *exception;

  v3 = *((_DWORD *)this + 9) * a2;
  if (*((_WORD *)this + 44) == 1)
  {
    v7 = (_QWORD *)operator new[](8 * *((unsigned __int16 *)this + 22), 0x10C80436913F5);
    v8 = v7;
    if (*((_WORD *)this + 22))
    {
      bzero(v7, 8 * *((unsigned __int16 *)this + 22));
      v9 = 0;
      do
        v8[v9++] = CPSDImageLoad::GetChannelByteCounts(this);
      while (v9 < *((unsigned __int16 *)this + 22));
      if (*((_WORD *)this + 22))
      {
        v10 = 0;
        do
        {
          if (CPSDImageLoad::UncompressChannelImageData(this, (unsigned __int16 *)v8[v10], *(unsigned __int8 **)(*((_QWORD *)this + 10) + 8 * v10), a2) != (_DWORD)v3)
          {
            exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
            CStdException::CStdException(exception, 3238395925);
          }
          ++v10;
        }
        while (v10 < *((unsigned __int16 *)this + 22));
      }
    }
    MEMORY[0x1A1AEEAF0](v8, 0x10C80436913F5);
    return 1;
  }
  if (!*((_WORD *)this + 44))
  {
    if (*((_WORD *)this + 22))
    {
      v4 = 0;
      v5 = *((_DWORD *)this + 7);
      do
      {
        memcpy(*(void **)(*((_QWORD *)this + 10) + 8 * v4), (const void *)(*((_QWORD *)this + 2) + v5), v3);
        v5 = *((_DWORD *)this + 7) + v3;
        *((_DWORD *)this + 7) = v5;
        ++v4;
      }
      while (v4 < *((unsigned __int16 *)this + 22));
    }
    return 1;
  }
  return 0;
}

void sub_19EC15B38()
{
  __break(1u);
}

void sub_19EC15BD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC15BE4);
}

void CPSDFile::CompositeImageData(void **this)
{
  float v2;
  int64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  unsigned int v17;
  float v18;
  unsigned int v19;
  float v20;

  if (*((_BYTE *)this + 392))
  {
    bzero(this[2], 3 * *((_DWORD *)this + 37) * *((_DWORD *)this + 36) * (*((unsigned __int16 *)this + 76) >> 3));
    v3 = (_BYTE *)this[35] - (_BYTE *)this[34];
    if (v3)
    {
      v4 = 0;
      v5 = v3 / 488;
      if (v5 <= 1)
        v6 = 1;
      else
        v6 = v5;
      do
      {
        v7 = *((unsigned __int16 *)this + 44);
        if (*((_WORD *)this + 44))
        {
          printf("Error - Can't generate composite data, unimplemented compression mode.");
        }
        else
        {
          v8 = *((_QWORD *)this[37] + v4);
          v9 = *(unsigned __int8 **)(*(_QWORD *)(v8 + 32) + 40);
          for (i = 1; i != 4; ++i)
          {
            v11 = *(_QWORD *)(v8 + 32) + 56 * i;
            v12 = *(unsigned int *)(v11 + 48);
            if ((_DWORD)v12)
            {
              v13 = *(unsigned __int8 **)(v11 + 40);
              v14 = v12 * v7;
              v15 = v9;
              do
              {
                v16 = this[2];
                v17 = *v13++;
                v18 = (float)v17;
                v19 = *v15++;
                v20 = (double)v19 / 255.0;
                LOBYTE(v2) = v16[v14];
                v2 = (float)LODWORD(v2);
                v16[v14++] = (int)(float)((float)((float)(1.0 - v20) * v2) + (float)(v18 * v20));
                --v12;
              }
              while (v12);
            }
            ++v7;
          }
        }
        ++v4;
      }
      while (v4 != v6);
    }
    *((_BYTE *)this + 392) = 0;
  }
}

void *CPSDImageLoad::GetChannelByteCounts(CPSDImageLoad *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  _WORD *v5;

  v2 = (void *)operator new[](2 * *((unsigned int *)this + 9), 0x1000C80BDFB0063);
  v3 = *((unsigned int *)this + 9);
  v4 = *((unsigned int *)this + 7);
  memcpy(v2, (const void *)(*((_QWORD *)this + 2) + v4), 2 * (v3 & 0x7FFF));
  *((_DWORD *)this + 7) = v4 + 2 * (v3 & 0x7FFF);
  if ((_DWORD)v3)
  {
    v5 = v2;
    do
    {
      *v5 = bswap32((unsigned __int16)*v5) >> 16;
      ++v5;
      --v3;
    }
    while (v3);
  }
  return v2;
}

uint64_t CPSDImageLoad::UncompressChannelImageData(CPSDImageLoad *this, unsigned __int16 *a2, unsigned __int8 *__b, unsigned int a4)
{
  unsigned __int8 *v4;
  int v8;
  unint64_t v9;
  int v10;
  CStdException *exception;

  if (!a2)
    CPSDImageLoad::UncompressChannelImageData();
  v4 = __b;
  if (!__b)
    CPSDImageLoad::UncompressChannelImageData();
  v8 = *((_DWORD *)this + 9);
  if (v8)
  {
    v9 = 0;
    v10 = v8 * a4;
    do
    {
      if (CPSDImageLoad::UncompressChannelScanLine(this, v4, a2[v9]) != a4)
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      v10 -= a4;
      v4 += a4;
      ++v9;
    }
    while (v9 < *((unsigned int *)this + 9));
  }
  else
  {
    v10 = 0;
  }
  MEMORY[0x1A1AEEAF0](a2, 0x1000C80BDFB0063);
  return *((_DWORD *)this + 9) * a4 - v10;
}

void sub_19EC15ECC()
{
  __break(1u);
}

void sub_19EC15F38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CStdException::~CStdException((CStdException *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x19EC15F48);
}

uint64_t CPSDImageLoad::UncompressChannelScanLine(CPSDImageLoad *this, unsigned __int8 *__b, int a3)
{
  unsigned __int16 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  size_t v11;
  __int16 v12;

  if (a3)
  {
    v5 = 0;
    while (1)
    {
      v6 = *((_QWORD *)this + 2);
      v7 = *((unsigned int *)this + 7);
      v8 = v7 + 1;
      *((_DWORD *)this + 7) = v7 + 1;
      v9 = *(char *)(v6 + v7);
      v10 = a3 - 1;
      if ((v9 & 0x80000000) == 0)
        break;
      if (v9 != -128)
      {
        v12 = 1 - v9;
        *((_DWORD *)this + 7) = v7 + 2;
        v10 = a3 - 2;
        v11 = (unsigned __int16)(1 - v9);
        memset(__b, *(unsigned __int8 *)(v6 + v8), v11);
        goto LABEL_7;
      }
LABEL_8:
      a3 = v10;
      if (!(_WORD)v10)
        return v5;
    }
    v11 = *(char *)(v6 + v7) + 1;
    memcpy(__b, (const void *)(v6 + v8), v11);
    *((_DWORD *)this + 7) += v11;
    v10 -= v11;
    v12 = v11;
LABEL_7:
    v5 += v12;
    __b += v11;
    goto LABEL_8;
  }
  return 0;
}

uint64_t CPSDChannelImage::DeAllocateChannelBuffers(CPSDChannelImage *this)
{
  unint64_t v2;

  if (*((_QWORD *)this + 6))
  {
    if (!*((_WORD *)this + 12))
      goto LABEL_6;
    v2 = 0;
    do
      free(*(void **)(*((_QWORD *)this + 6) + 8 * v2++));
    while (v2 < *((unsigned __int16 *)this + 12));
    if (*((_QWORD *)this + 6))
LABEL_6:
      MEMORY[0x1A1AEEAF0]();
    *((_QWORD *)this + 6) = 0;
  }
  return 1;
}

uint64_t CPSDChannelImage::AllocateChannelBuffers(CPSDChannelImage *this)
{
  void *v2;
  uint64_t v3;
  unint64_t v4;
  unsigned int v5;
  size_t v6;

  v2 = (void *)operator new[](8 * *((unsigned __int16 *)this + 12), 0x10C80436913F5);
  *((_QWORD *)this + 6) = v2;
  v3 = *((unsigned __int16 *)this + 12);
  bzero(v2, 8 * v3);
  if (v3)
  {
    v4 = 0;
    do
    {
      v5 = *((_DWORD *)this + 3) * *((_DWORD *)this + 5);
      if (v5 <= 4)
        v6 = 4;
      else
        v6 = v5;
      *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v4++) = malloc_type_calloc(v6, 1uLL, 0xAB40E959uLL);
    }
    while (v4 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

CPSDMeshedARGBStream *CPSDChannelImage::CreateChannelStream(CPSDChannelImage *this)
{
  CPSDMeshedARGBStream *v2;

  CPSDChannelImage::DeAllocateChannelBuffers(this);
  (*(void (**)(CPSDChannelImage *))(*(_QWORD *)this + 56))(this);
  (*(void (**)(CPSDChannelImage *))(*(_QWORD *)this + 64))(this);
  v2 = (CPSDMeshedARGBStream *)operator new(72, 0x10B1C4035EE323ALL);
  CPSDMeshedARGBStream::CPSDMeshedARGBStream(v2, this);
  return v2;
}

void sub_19EC161AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C4035EE323ALL);
  _Unwind_Resume(a1);
}

CPSDAlphaChannelStream *CPSDChannelImage::CreateAlphaStream(CPSDChannelImage *this, unsigned int a2)
{
  CPSDAlphaChannelStream *v4;

  if (!*((_QWORD *)this + 6))
  {
    CPSDChannelImage::DeAllocateChannelBuffers(this);
    (*(void (**)(CPSDChannelImage *))(*(_QWORD *)this + 56))(this);
    (*(void (**)(CPSDChannelImage *))(*(_QWORD *)this + 64))(this);
  }
  v4 = (CPSDAlphaChannelStream *)operator new(48, 0x10B1C4068A33497);
  CPSDAlphaChannelStream::CPSDAlphaChannelStream(v4, this, a2);
  return v4;
}

void sub_19EC16254(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C4068A33497);
  _Unwind_Resume(a1);
}

void CPSDLayerImage::CPSDLayerImage(CPSDLayerImage *this, CPSDLayerRecord *a2, CPSDLayerChannelGroup *a3, __int16 a4, int a5, int a6, unsigned __int8 *a7)
{
  int v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __int16 *v12;
  int v13;
  BOOL v14;
  int v15;
  __int16 v16;
  __int16 *v17;
  unint64_t v18;
  int v19;

  v7 = *((_DWORD *)a2 + 6);
  v8 = *((_DWORD *)a2 + 4);
  v9 = *((unsigned __int16 *)a2 + 16);
  if (*((_WORD *)a2 + 16))
  {
    v10 = *((_QWORD *)a2 + 5);
    if (*(__int16 *)(v10 + 16) == -1)
    {
      v14 = 1;
    }
    else
    {
      v11 = 0;
      v12 = (__int16 *)(v10 + 40);
      while (v9 - 1 != v11)
      {
        v13 = *v12;
        v12 += 12;
        ++v11;
        if (v13 == -1)
          goto LABEL_10;
      }
      v11 = *((unsigned __int16 *)a2 + 16);
LABEL_10:
      v14 = v11 < v9;
    }
  }
  else
  {
    v14 = 0;
  }
  v15 = *((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 2) = v15;
  *((_DWORD *)this + 3) = v7 - v8;
  *((_WORD *)this + 9) = a5;
  *((_DWORD *)this + 5) = (v15 * a5) >> 3;
  *((_WORD *)this + 12) = v9;
  *((_WORD *)this + 13) = a4;
  *((_BYTE *)this + 28) = v14;
  *((_DWORD *)this + 8) = a6;
  *((_QWORD *)this + 5) = a7;
  *((_QWORD *)this + 6) = 0;
  *(_QWORD *)this = &off_1E41A8FD8;
  *((_QWORD *)this + 7) = a2;
  *((_QWORD *)this + 8) = a3;
  v16 = 0;
  if ((_DWORD)v9)
  {
    v17 = (__int16 *)(*((_QWORD *)a2 + 5) + 16);
    v18 = v9;
    do
    {
      v19 = *v17;
      v17 += 12;
      if (v19 < -1)
        ++v16;
      --v18;
    }
    while (v18);
  }
  *((_WORD *)this + 8) = (v9 - v16) * a5;
}

uint64_t CPSDLayerImage::GetComponentChannels(CPSDLayerImage *this)
{
  __int16 v1;
  __int16 *v2;
  uint64_t v3;
  int v4;

  if (*((_WORD *)this + 12))
  {
    v1 = 0;
    v2 = (__int16 *)(*(_QWORD *)(*((_QWORD *)this + 7) + 40) + 16);
    v3 = *((unsigned __int16 *)this + 12);
    do
    {
      v4 = *v2;
      v2 += 12;
      if (v4 < -1)
        ++v1;
      --v3;
    }
    while (v3);
  }
  else
  {
    v1 = 0;
  }
  return (unsigned __int16)(*((_WORD *)this + 12) - v1);
}

uint64_t CPSDLayerImage::AllocateChannelBuffers(CPSDLayerImage *this)
{
  void *v2;
  uint64_t v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;

  v2 = (void *)operator new[](8 * *((unsigned __int16 *)this + 12), 0x10C80436913F5);
  *((_QWORD *)this + 6) = v2;
  v3 = *((unsigned __int16 *)this + 12);
  bzero(v2, 8 * v3);
  if (v3)
  {
    v4 = 0;
    do
    {
      v5 = ((*(unsigned int (**)(CPSDLayerImage *, unint64_t))(*(_QWORD *)this + 40))(this, v4)
          * *((unsigned __int16 *)this + 9)) >> 3;
      if (v5 * (*(unsigned int (**)(CPSDLayerImage *, unint64_t))(*(_QWORD *)this + 48))(this, v4) < 5)
        v6 = 4;
      else
        v6 = (*(uint64_t (**)(CPSDLayerImage *, unint64_t))(*(_QWORD *)this + 48))(this, v4) * v5;
      *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v4++) = malloc_type_calloc(v6, 1uLL, 0xEA0AD297uLL);
    }
    while (v4 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

uint64_t CPSDLayerImage::FillChannelBuffers(CPSDLayerImage *this)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  CPSDChannelData *v5;
  unsigned __int8 *v6;
  unsigned int v7;

  if (*((_WORD *)this + 12))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = ((*(unsigned int (**)(CPSDLayerImage *, unint64_t))(*(_QWORD *)this + 40))(this, v3)
          * *((unsigned __int16 *)this + 9)) >> 3;
      v5 = (CPSDChannelData *)(*(_QWORD *)(*((_QWORD *)this + 8) + 32) + v2);
      v6 = *(unsigned __int8 **)(*((_QWORD *)this + 6) + 8 * v3);
      v7 = (*(uint64_t (**)(CPSDLayerImage *, unint64_t))(*(_QWORD *)this + 48))(this, v3);
      CPSDChannelData::UnpackImageInPosition(v5, v6, v4, v7, 0, 0, v4, v7, 0, 0);
      ++v3;
      v2 += 56;
    }
    while (v3 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

uint64_t CPSDLayerImage::Dump(CPSDLayerImage *this, __sFILE *a2)
{
  return fprintf(a2, "{\tLayerImage:\t{A=%d, BPS=%d, BPP=%d} {size: %d x %d x %d} = \t[%d] bytes }\n", *((unsigned __int8 *)this + 28), *((unsigned __int16 *)this + 9), *((unsigned __int16 *)this + 8), *((_DWORD *)this + 5), *((_DWORD *)this + 3), *((unsigned __int16 *)this + 12), *((_DWORD *)this + 3) * *((_DWORD *)this + 5) * *((unsigned __int16 *)this + 12));
}

uint64_t CPSDLayerImage::GetChannelImageWidth(CPSDLayerImage *this, unsigned int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v2 = *((_QWORD *)this + 7);
  v3 = *(unsigned __int16 *)(*(_QWORD *)(v2 + 40) + 24 * a2 + 16);
  if (v3 == 65533)
  {
    v4 = *(_DWORD *)(v2 + 132);
    v5 = *(_DWORD *)(v2 + 124);
  }
  else if (v3 == 65534)
  {
    v4 = *(_DWORD *)(v2 + 112);
    v5 = *(_DWORD *)(v2 + 104);
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 28);
    v5 = *(_DWORD *)(v2 + 20);
  }
  return (v4 - v5);
}

uint64_t CPSDLayerImage::GetChannelImageHeight(CPSDLayerImage *this, unsigned int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v2 = *((_QWORD *)this + 7);
  v3 = *(unsigned __int16 *)(*(_QWORD *)(v2 + 40) + 24 * a2 + 16);
  if (v3 == 65533)
  {
    v4 = *(_DWORD *)(v2 + 128);
    v5 = *(_DWORD *)(v2 + 120);
  }
  else if (v3 == 65534)
  {
    v4 = *(_DWORD *)(v2 + 108);
    v5 = *(_DWORD *)(v2 + 100);
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 24);
    v5 = *(_DWORD *)(v2 + 16);
  }
  return (v4 - v5);
}

void CPSDLayerSliceImage::CPSDLayerSliceImage(CPSDLayerSliceImage *this, CPSDLayerRecord *a2, CPSDLayerChannelGroup *a3, PSDRect *a4, __int16 a5, int a6, int a7, unsigned __int8 *a8)
{
  int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __int16 *v15;
  int v16;
  BOOL v17;
  unsigned int v18;
  __int16 v19;
  __int16 *v20;
  unint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;

  v8 = *((_DWORD *)a4 + 2);
  v9 = *((_DWORD *)a4 + 3);
  v10 = *(_DWORD *)a4;
  v11 = *((_DWORD *)a4 + 1);
  v12 = *((unsigned __int16 *)a2 + 16);
  if (*((_WORD *)a2 + 16))
  {
    v13 = *((_QWORD *)a2 + 5);
    if (*(__int16 *)(v13 + 16) == -1)
    {
      v17 = 1;
    }
    else
    {
      v14 = 0;
      v15 = (__int16 *)(v13 + 40);
      while (v12 - 1 != v14)
      {
        v16 = *v15;
        v15 += 12;
        ++v14;
        if (v16 == -1)
          goto LABEL_10;
      }
      v14 = *((unsigned __int16 *)a2 + 16);
LABEL_10:
      v17 = v14 < v12;
    }
  }
  else
  {
    v17 = 0;
  }
  *((_DWORD *)this + 2) = v9 - v11;
  *((_DWORD *)this + 3) = v8 - v10;
  *((_WORD *)this + 9) = a6;
  v18 = ((v9 - v11) * a6) >> 3;
  *((_DWORD *)this + 5) = v18;
  *((_WORD *)this + 12) = v12;
  *((_WORD *)this + 13) = a5;
  *((_BYTE *)this + 28) = v17;
  *((_DWORD *)this + 8) = a7;
  *((_QWORD *)this + 5) = a8;
  *((_QWORD *)this + 6) = 0;
  *(_QWORD *)this = &off_1E41A9648;
  *((_QWORD *)this + 7) = a2;
  *((_QWORD *)this + 8) = a3;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = v18;
  v19 = 0;
  if ((_DWORD)v12)
  {
    v20 = (__int16 *)(*((_QWORD *)a2 + 5) + 16);
    v21 = v12;
    do
    {
      v22 = *v20;
      v20 += 12;
      if (v22 < -1)
        ++v19;
      --v21;
    }
    while (v21);
  }
  *((_WORD *)this + 8) = (v12 - v19) * a6;
  v24 = *((_DWORD *)a2 + 4);
  v23 = *((_DWORD *)a2 + 5);
  v26 = *((_DWORD *)a2 + 6);
  v25 = *((_DWORD *)a2 + 7);
  v27 = v11 & ~(v11 >> 31);
  v28 = v10 & ~(v10 >> 31);
  *(_DWORD *)a4 = v28;
  *((_DWORD *)a4 + 1) = v27;
  v29 = v28 - v24;
  if (v28 > v24)
    v24 = v28;
  *((_DWORD *)this + 18) = (v27 - v23) & ~((v27 - v23) >> 31);
  *((_DWORD *)this + 19) = v29 & ~(v29 >> 31);
  if (v27 > v23)
    v23 = v27;
  if (v9 >= v25)
    v9 = v25;
  if (*((_DWORD *)a4 + 3) < v25)
    v25 = *((_DWORD *)a4 + 3);
  if (v8 >= v26)
    v8 = v26;
  if (*((_DWORD *)a4 + 2) < v26)
    v26 = *((_DWORD *)a4 + 2);
  *((_DWORD *)this + 20) = v23 - v27;
  *((_DWORD *)this + 21) = v24 - v28;
  if (v23 <= v9)
    v30 = v25 - v23;
  else
    v30 = 0;
  v31 = (v30 * a6) >> 3;
  if (v24 <= v8)
    v32 = v26 - v24;
  else
    v32 = 0;
  *((_DWORD *)this + 22) = v31;
  *((_DWORD *)this + 23) = v32;
}

uint64_t CPSDLayerSliceImage::GetComponentChannels(CPSDLayerSliceImage *this)
{
  __int16 v1;
  __int16 *v2;
  uint64_t v3;
  int v4;

  if (*((_WORD *)this + 12))
  {
    v1 = 0;
    v2 = (__int16 *)(*(_QWORD *)(*((_QWORD *)this + 7) + 40) + 16);
    v3 = *((unsigned __int16 *)this + 12);
    do
    {
      v4 = *v2;
      v2 += 12;
      if (v4 < -1)
        ++v1;
      --v3;
    }
    while (v3);
  }
  else
  {
    v1 = 0;
  }
  return (unsigned __int16)(*((_WORD *)this + 12) - v1);
}

uint64_t CPSDLayerSliceImage::FillChannelBuffers(CPSDLayerSliceImage *this)
{
  uint64_t v2;
  unint64_t v3;

  if (*((_WORD *)this + 12))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      CPSDChannelData::UnpackImageInPosition((CPSDChannelData *)(*(_QWORD *)(*((_QWORD *)this + 8) + 32) + v2), *(unsigned __int8 **)(*((_QWORD *)this + 6) + 8 * v3++), *((_DWORD *)this + 5), *((_DWORD *)this + 3), *((_DWORD *)this + 18), *((_DWORD *)this + 19), *((_DWORD *)this + 22), *((_DWORD *)this + 23), *((_DWORD *)this + 20), *((_DWORD *)this + 21));
      v2 += 56;
    }
    while (v3 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

uint64_t CPSDLayerSliceImage::IsEmptyImage(CPSDLayerSliceImage *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)this + 8) + 32) + 52);
}

void CPSDCompositeImage::CPSDCompositeImage(CPSDCompositeImage *this, CPSDHeader *a2, unsigned __int8 **a3, int a4, int a5, unsigned __int8 *a6)
{
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;

  v7 = *((_DWORD *)a2 + 8);
  v6 = *((_DWORD *)a2 + 9);
  v8 = *((unsigned __int16 *)a2 + 21);
  v9 = *((unsigned __int16 *)a2 + 14);
  v10 = *((unsigned __int16 *)a2 + 20);
  *((_DWORD *)this + 2) = v6;
  *((_DWORD *)this + 3) = v7;
  *((_WORD *)this + 9) = v10;
  *((_DWORD *)this + 5) = (v6 * v10) >> 3;
  *((_WORD *)this + 12) = v9;
  *((_WORD *)this + 13) = v8;
  *((_BYTE *)this + 28) = a4;
  *((_DWORD *)this + 8) = a5;
  *(_QWORD *)this = &off_1E41A9468;
  *((_QWORD *)this + 5) = a6;
  *((_QWORD *)this + 6) = a3;
  if (v9 >= v8)
    v11 = v8;
  else
    v11 = v9;
  if (v8 < v9)
    v12 = v8 + 1;
  else
    v12 = v9;
  if (a4)
    v11 = v12;
  if (((1 << v8) & 0x1A) != 0)
    v13 = v11;
  else
    v13 = v9;
  if (v8 > 4)
    v13 = v9;
  *((_WORD *)this + 8) = v13 * v10;
}

uint64_t CPSDCompositeImage::GetComponentChannels(CPSDCompositeImage *this)
{
  unsigned int v1;
  unsigned int v3;
  unsigned __int16 v4;
  unsigned __int16 v5;

  v1 = *((unsigned __int16 *)this + 13);
  if (v1 > 4 || ((1 << v1) & 0x1A) == 0)
  {
    return *((unsigned __int16 *)this + 12);
  }
  else
  {
    v3 = *((unsigned __int16 *)this + 12);
    if (v3 >= v1)
      v4 = *((_WORD *)this + 13);
    else
      v4 = *((_WORD *)this + 12);
    if (v1 < v3)
      v5 = v1 + 1;
    else
      v5 = *((_WORD *)this + 12);
    if (!*((_BYTE *)this + 28))
      return v4;
  }
  return v5;
}

CPSDMeshedARGBStream *CPSDCompositeImage::CreateChannelStream(CPSDCompositeImage *this)
{
  CPSDMeshedARGBStream *v2;

  v2 = (CPSDMeshedARGBStream *)operator new(72, 0x10B1C4035EE323ALL);
  CPSDMeshedARGBStream::CPSDMeshedARGBStream(v2, this);
  return v2;
}

void sub_19EC169A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C4035EE323ALL);
  _Unwind_Resume(a1);
}

uint64_t CPSDChannelLengthInfo::Load(CPSDChannelLengthInfo *this, int a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 2uLL, &v5);
  *((_WORD *)this + 8) = bswap32(*((unsigned __int16 *)this + 8)) >> 16;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v5);
  *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
  return 1;
}

uint64_t CPSDChannelLengthInfo::Save(CPSDChannelLengthInfo *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 5));
}

uint64_t CPSDLayerMaskData::GetMaskCount(CPSDLayerMaskData *this)
{
  int v1;

  v1 = *((_DWORD *)this + 4);
  if (v1 == 36)
    return 2;
  else
    return v1 == 20;
}

uint64_t CPSDVectorMaskData::Load(CPSDVectorMaskData *this, int a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 104, 4uLL, &v5);
  *((_DWORD *)this + 26) = bswap32(*((_DWORD *)this + 26));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 108, 4uLL, &v5);
  *((_DWORD *)this + 27) = bswap32(*((_DWORD *)this + 27));
  *((_DWORD *)this + 18) = *((_DWORD *)this + 4) & ~(*((int *)this + 4) >> 31);
  CPSDPathsResourceItem::Load((CPSDVectorMaskData *)((char *)this + 56), a2);
  return 1;
}

uint64_t CPSDVectorMaskData::Save(CPSDVectorMaskData *this, File *a2)
{
  uint64_t result;
  _QWORD *i;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 26));
  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 27));
  for (i = (_QWORD *)*((_QWORD *)this + 10); i; i = (_QWORD *)i[3])
    result = (*(uint64_t (**)(_QWORD *, File *))(*i + 24))(i, a2);
  return result;
}

size_t CPSDVectorMaskData::Dump(CPSDVectorMaskData *this, __sFILE *a2)
{
  int v4;
  const char *v5;
  const char *v6;
  const char *v7;

  fprintf(a2, "{ VectorMaskData: version=%d", *((_DWORD *)this + 26));
  v4 = *((_DWORD *)this + 27);
  if ((v4 & 1) != 0)
    v5 = "YES";
  else
    v5 = "NO";
  if ((v4 & 2) != 0)
    v6 = "NO";
  else
    v6 = "YES";
  if ((v4 & 3) != 0)
    v7 = "NO";
  else
    v7 = "YES";
  fprintf(a2, "  <isInverted: %s >  <isLinked: %s >  <isEnabled: %s >\n", v5, v6, v7);
  CPSDPathsResourceItem::Dump((CPSDVectorMaskData *)((char *)this + 56), a2, 1u);
  return fwrite("} // End VectorMaskData\n", 0x18uLL, 1uLL, a2);
}

uint64_t std::vector<CPSDChannelBlendingInfo>::resize(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t (***v8)(_QWORD);
  uint64_t (***v9)(_QWORD);
  uint64_t (**v10)(_QWORD);
  BOOL v11;

  v2 = result;
  v3 = *(_QWORD *)(result + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *(_QWORD *)result) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
    return std::vector<CPSDChannelBlendingInfo>::__append((char **)result, v6);
  if (!v5)
  {
    v7 = *(_QWORD *)result + 24 * a2;
    if (v3 != v7)
    {
      v8 = (uint64_t (***)(_QWORD))(v3 - 24);
      v9 = (uint64_t (***)(_QWORD))(v3 - 24);
      do
      {
        v10 = *v9;
        v9 -= 3;
        result = (*v10)(v8);
        v11 = v8 == (uint64_t (***)(_QWORD))v7;
        v8 = v9;
      }
      while (!v11);
    }
    *(_QWORD *)(v2 + 8) = v7;
  }
  return result;
}

uint64_t CPSDChannelBlendingInfo::Load(CPSDChannelBlendingInfo *this, int a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v5);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v5);
  *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
  return 1;
}

uint64_t CPSDChannelBlendingInfo::Save(CPSDChannelBlendingInfo *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 5));
}

uint64_t CPSDActionBaseComponent::Dump(CPSDActionBaseComponent *this, __sFILE *a2)
{
  return fputs("Dump: ActionBaseComponent\n", a2);
}

{
  return (*(uint64_t (**)(CPSDActionBaseComponent *, __sFILE *, _QWORD))(*(_QWORD *)this + 48))(this, a2, 0);
}

void CPSDOSTypeList::~CPSDOSTypeList(CPSDOSTypeList *this)
{
  _QWORD *v2;
  _QWORD *v3;
  char *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  *(_QWORD *)this = &off_1E41A9038;
  v4 = (char *)this + 64;
  v2 = (_QWORD *)*((_QWORD *)this + 8);
  v3 = (_QWORD *)*((_QWORD *)v4 + 1);
  if (v3 == v2)
  {
    v2 = v3;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = v2[v5];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
        v2 = (_QWORD *)*((_QWORD *)this + 8);
        v3 = (_QWORD *)*((_QWORD *)this + 9);
      }
      v5 = (unsigned __int16)++v6;
    }
    while ((unsigned __int16)v6 < (unint64_t)(v3 - v2));
  }
  *((_DWORD *)this + 14) = 0;
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  CPSDOSTypeList::~CPSDOSTypeList(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDOSTypeList::Load(CPSDOSTypeList *this, uint64_t a2)
{
  unsigned int *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int v19;
  int v20;

  v20 = 0;
  v4 = (unsigned int *)((char *)this + 56);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v20);
  v5 = bswap32(*((_DWORD *)this + 14));
  *((_DWORD *)this + 14) = v5;
  v6 = (_QWORD *)((char *)this + 64);
  std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 64, v5);
  if (*((_DWORD *)this + 14))
  {
    v7 = 0;
    v8 = (char *)this + 60;
    do
    {
      CPSDBaseComponent::ReadFile(a2, v8, 4uLL, &v20);
      v15 = 0;
      v16 = bswap32(*(_DWORD *)v8);
      *(_DWORD *)v8 = v16;
      if (v16 > 1651470187)
      {
        if (v16 > 1701737836)
        {
          if (v16 == 1701737837)
          {
            v15 = operator new(96, 0x10B1C4065EDEABDLL);
            *(_DWORD *)(v15 + 16) = 0;
            *(_OWORD *)(v15 + 24) = 0u;
            *(_OWORD *)(v15 + 40) = 0u;
            *(_QWORD *)v15 = &off_1E41A9898;
            *(_QWORD *)(v15 + 56) = 0;
            *(_DWORD *)(v15 + 64) = 0;
            *(_DWORD *)(v15 + 80) = 0;
            *(_QWORD *)(v15 + 88) = 0;
          }
          else if (v16 == 1819242087)
          {
            v15 = operator new(64, 0x10B1C40D02A791CLL);
            *(_DWORD *)(v15 + 16) = 0;
            *(_OWORD *)(v15 + 24) = 0u;
            *(_OWORD *)(v15 + 40) = 0u;
            *(_QWORD *)v15 = &off_1E41A93D8;
            *(_DWORD *)(v15 + 56) = 0;
          }
        }
        else if (v16 == 1651470188)
        {
          v15 = operator new(64, 0x10B1C40B4161B10);
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_QWORD *)v15 = &off_1E41A9390;
          *(_BYTE *)(v15 + 56) = 0;
        }
        else if (v16 == 1685026146)
        {
          v15 = operator new(64, 0x10B1C40507B098BLL);
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_QWORD *)v15 = &off_1E41A91C0;
          *(_QWORD *)(v15 + 56) = 0;
        }
      }
      else if (v16 > 1433302085)
      {
        if (v16 == 1433302086)
        {
          v15 = operator new(72, 0x10B1C403C8C186CLL);
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_QWORD *)v15 = &off_1E41A96A8;
          *(_DWORD *)(v15 + 56) = 0;
          *(_QWORD *)(v15 + 64) = 0;
        }
        else if (v16 == 1449938035)
        {
          v15 = operator new(88, 0x10B1C40B59DE747);
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_QWORD *)v15 = &off_1E41A9038;
          *(_OWORD *)(v15 + 56) = 0u;
          *(_OWORD *)(v15 + 72) = 0u;
        }
      }
      else if (v16 == 1331849827)
      {
        v15 = operator new(120, 0x10B1C4022C5DBF1);
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v15);
      }
      else if (v16 == 1413830740)
      {
        v15 = operator new(72, 0x10B1C4015F6298ELL);
        CPSDOSTypeText::CPSDOSTypeText((CPSDOSTypeText *)v15);
      }
      *(_QWORD *)(*v6 + 8 * v7) = v15;
      v17 = *(_QWORD *)(*v6 + 8 * v7);
      if (v17)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v17 + 16))(v17, a2);
      }
      else
      {
        v19 = bswap32(*(_DWORD *)v8);
        _CUILog(1, (uint64_t)"Error parsing gradient fill info: The OSType \"%.4s\" cannot be parsed.\n", v9, v10, v11, v12, v13, v14, (uint64_t)&v19);
      }
      ++v7;
    }
    while (v7 < *v4);
  }
  return 1;
}

void sub_19EC17294(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C4022C5DBF1);
  _Unwind_Resume(a1);
}

uint64_t CPSDOSTypeList::Save(CPSDOSTypeList *this, File *a2)
{
  uint64_t result;
  unint64_t v5;

  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 14))
  {
    v5 = 0;
    do
    {
      (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 15));
      result = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * v5);
      if (result)
        result = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)result + 24))(result, a2);
      ++v5;
    }
    while (v5 < *((unsigned int *)this + 14));
  }
  return result;
}

uint64_t CPSDOSTypeList::Dump(CPSDOSTypeList *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6;
  const char *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v6 = operator new[](a3, 0x1000C8077774924);
  v7 = (const char *)v6;
  if (a3)
  {
    v8 = 0;
    do
      *(_BYTE *)(v6 + (unsigned __int16)v8++) = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "List { Number of Items = %d:\n", *((_DWORD *)this + 14));
  if (*((_DWORD *)this + 14))
  {
    v9 = 0;
    v10 = a3 + 2;
    do
    {
      v11 = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * (unsigned __int16)v9);
      (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(_QWORD *)v11 + 48))(v11, a2, v10);
      ++v9;
    }
    while (*((_DWORD *)this + 14) > (unsigned __int16)v9);
  }
  return fprintf(a2, "%s} // End of List\n", v7);
}

uint64_t CPSDOSTypeInteger::Load(CPSDOSTypeInteger *this, int a2)
{
  int v4;

  v4 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v4);
  *((_DWORD *)this + 14) = bswap32(*((_DWORD *)this + 14));
  return 1;
}

uint64_t CPSDOSTypeInteger::Save(CPSDOSTypeInteger *this, File *a2)
{
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
}

uint64_t CPSDOSTypeInteger::Dump(CPSDOSTypeInteger *this, __sFILE *a2)
{
  return fprintf(a2, "Integer { %d }\n", *((_DWORD *)this + 14));
}

uint64_t CPSDOSTypeDouble::Dump(CPSDOSTypeDouble *this, __sFILE *a2)
{
  return fprintf(a2, "Double { %f }\n", *((double *)this + 7));
}

uint64_t CPSDOSTypeDouble::Load(CPSDOSTypeDouble *this, int a2)
{
  unint64_t v4;
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v4, 8uLL, &v5);
  *((_QWORD *)this + 7) = bswap64(v4);
  return 1;
}

uint64_t CPSDOSTypeDouble::Save(CPSDOSTypeDouble *this, File *a2)
{
  return (*(uint64_t (**)(File *, double))(*(_QWORD *)a2 + 88))(a2, *((double *)this + 7));
}

uint64_t CPSDOSTypeBoolean::Load(CPSDOSTypeBoolean *this, int a2)
{
  int v3;

  v3 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 1uLL, &v3);
  return 1;
}

uint64_t CPSDOSTypeBoolean::Save(CPSDOSTypeBoolean *this, File *a2)
{
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 56));
}

uint64_t CPSDOSTypeBoolean::Dump(CPSDOSTypeBoolean *this, __sFILE *a2)
{
  return fprintf(a2, "Boolean { %d }\n", *((unsigned __int8 *)this + 56));
}

uint64_t CPSDOSTypeUnitFloat::Load(CPSDOSTypeUnitFloat *this, int a2)
{
  unint64_t v5;
  int v6;

  v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v6);
  *((_DWORD *)this + 14) = bswap32(*((_DWORD *)this + 14));
  CPSDBaseComponent::ReadFile(a2, (char *)&v5, 8uLL, &v6);
  *((_QWORD *)this + 8) = bswap64(v5);
  return 1;
}

uint64_t CPSDOSTypeUnitFloat::Save(CPSDOSTypeUnitFloat *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  return (*(uint64_t (**)(File *, double))(*(_QWORD *)a2 + 88))(a2, *((double *)this + 8));
}

uint64_t CPSDOSTypeUnitFloat::Dump(CPSDOSTypeUnitFloat *this, __sFILE *a2)
{
  unsigned int v3;

  v3 = bswap32(*((_DWORD *)this + 14));
  return fprintf(a2, "Unit Float { Units = '%s', Double value = %f }\n", (const char *)&v3, *((double *)this + 8));
}

void CPSDOSTypeText::~CPSDOSTypeText(CPSDOSTypeText *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E41A9080;
  v2 = *((_QWORD *)this + 8);
  if (v2)
  {
    MEMORY[0x1A1AEEAF0](v2, 0x1000C80BDFB0063);
    *((_QWORD *)this + 8) = 0;
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  CPSDOSTypeText::~CPSDOSTypeText(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDOSTypeText::Load(char **this, int a2)
{
  unsigned int v3;

  v3 = 0;
  return CPSDString::Load(this + 7, a2, &v3);
}

uint64_t CPSDOSTypeText::Save(CPSDOSTypeText *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  return (*(uint64_t (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 8), *((unsigned int *)this + 14));
}

uint64_t CPSDOSTypeText::Dump(const UniChar **this, __sFILE *a2)
{
  char v4[256];

  CPSDString::CopyStringValue(this + 7, v4, 0x100u);
  return fprintf(a2, "Text { %s }\n", v4);
}

uint64_t CPSDOSTypeEnumerated::Load(CPSDOSTypeEnumerated *this, int a2)
{
  unsigned int v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  unsigned int v8;
  char *v9;
  int v11;

  v11 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v11);
  v4 = *((_DWORD *)this + 14);
  v5 = bswap32(v4);
  *((_DWORD *)this + 14) = v5;
  if (v4)
  {
    v6 = (char *)operator new[](v5, 0x1000C8077774924);
    *((_QWORD *)this + 9) = v6;
    CPSDBaseComponent::ReadFile(a2, v6, *((unsigned int *)this + 14), &v11);
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 64, 4uLL, &v11);
    *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
  }
  CPSDBaseComponent::ReadFile(a2, (char *)this + 60, 4uLL, &v11);
  v7 = *((_DWORD *)this + 15);
  v8 = bswap32(v7);
  *((_DWORD *)this + 15) = v8;
  if (v7)
  {
    v9 = (char *)operator new[](v8 + 1, 0x1000C8077774924);
    *((_QWORD *)this + 11) = v9;
    CPSDBaseComponent::ReadFile(a2, v9, *((unsigned int *)this + 15), &v11);
    *(_BYTE *)(*((_QWORD *)this + 11) + *((unsigned int *)this + 15)) = 0;
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 80, 4uLL, &v11);
    *((_DWORD *)this + 20) = bswap32(*((_DWORD *)this + 20));
  }
  return 1;
}

uint64_t CPSDOSTypeEnumerated::Save(CPSDOSTypeEnumerated *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 14))
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)this + 9));
  else
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 16));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 15));
  if (*((_DWORD *)this + 15))
    return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)this + 11));
  else
    return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 20));
}

uint64_t CPSDOSTypeEnumerated::Dump(CPSDOSTypeEnumerated *this, __sFILE *__stream)
{
  fwrite("Enum { ", 7uLL, 1uLL, __stream);
  if (*((_DWORD *)this + 16))
    fprintf(__stream, "TypeID = '%s', ");
  else
    fprintf(__stream, "TypeID string = %s, ");
  if (*((_DWORD *)this + 20))
    return fprintf(__stream, "Enum = '%s' }\n");
  else
    return fprintf(__stream, "Enum string = %s }\n");
}

void CPSDActionKeyedItem::CPSDActionKeyedItem(CPSDActionKeyedItem *this, int a2, CPSDActionBaseComponent *a3)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_QWORD *)this = &off_1E41A95C0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = a2;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = a3;
  CPSDActionKeyedItem::SetItem(this, a3);
}

void sub_19EC17B50(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem *v1;

  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

BOOL CPSDActionKeyedItem::SetItem(CPSDActionKeyedItem *this, CPSDActionBaseComponent *a2)
{
  _BOOL8 result;
  int v5;

  *((_QWORD *)this + 10) = a2;
  if (!a2)
    __cxa_bad_typeid();
  if (result)
  {
    v5 = 1433302086;
LABEL_17:
    *((_DWORD *)this + 18) = v5;
    return result;
  }
  if (result)
  {
    v5 = 1651470188;
    goto LABEL_17;
  }
  if (result)
  {
    v5 = 1685026146;
    goto LABEL_17;
  }
  if (result)
  {
    v5 = 1819242087;
    goto LABEL_17;
  }
  if (result)
  {
    v5 = 1413830740;
    goto LABEL_17;
  }
  if (result)
  {
    v5 = 1701737837;
    goto LABEL_17;
  }
  if (result
  {
    v5 = 1331849827;
    goto LABEL_17;
  }
  if (result)
  {
    v5 = 1449938035;
    goto LABEL_17;
  }
  return result;
}

void CPSDActionKeyedItem::CPSDActionKeyedItem(CPSDActionKeyedItem *this, const char *__s, CPSDActionBaseComponent *a3)
{
  int v6;
  char *v7;

  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_QWORD *)this = &off_1E41A95C0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = a3;
  if (__s)
  {
    v6 = strlen(__s);
    *((_DWORD *)this + 14) = v6;
    v7 = (char *)malloc_type_malloc((v6 + 1), 0x2D3EBADAuLL);
    *((_QWORD *)this + 8) = v7;
    strcpy(v7, __s);
  }
  CPSDActionKeyedItem::SetItem(this, a3);
}

void sub_19EC17D58(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem *v1;

  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

void CPSDActionKeyedItem::~CPSDActionKeyedItem(CPSDActionKeyedItem *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A95C0;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x1A1AEEAF0](v2, 0x1000C8077774924);
  v3 = *((_QWORD *)this + 10);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  CPSDActionKeyedItem::~CPSDActionKeyedItem(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDActionKeyedItem::Load(CPSDActionKeyedItem *this, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  void (**v16)(CPSDDropShadowDescriptor *__hidden);
  uint64_t v18;
  int v19;

  v19 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v19);
  v4 = *((_DWORD *)this + 14);
  v5 = bswap32(v4);
  *((_DWORD *)this + 14) = v5;
  if (v4)
  {
    v6 = (char *)operator new[](v5, 0x1000C8077774924);
    *((_QWORD *)this + 8) = v6;
    CPSDBaseComponent::ReadFile(a2, v6, *((unsigned int *)this + 14), &v19);
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 60, 4uLL, &v19);
    *((_DWORD *)this + 15) = bswap32(*((_DWORD *)this + 15));
  }
  CPSDBaseComponent::ReadFile(a2, (char *)this + 72, 4uLL, &v19);
  v13 = bswap32(*((_DWORD *)this + 18));
  *((_DWORD *)this + 18) = v13;
  if (v13 <= 1651470187)
  {
    if (v13 > 1433302085)
    {
      if (v13 == 1433302086)
      {
        v14 = operator new(72, 0x10B1C403C8C186CLL);
        *(_DWORD *)(v14 + 16) = 0;
        *(_OWORD *)(v14 + 24) = 0u;
        *(_OWORD *)(v14 + 40) = 0u;
        *(_QWORD *)v14 = &off_1E41A96A8;
        *(_DWORD *)(v14 + 56) = 0;
        *(_QWORD *)(v14 + 64) = 0;
        goto LABEL_39;
      }
      if (v13 == 1449938035)
      {
        v14 = operator new(88, 0x10B1C40B59DE747);
        *(_DWORD *)(v14 + 16) = 0;
        *(_OWORD *)(v14 + 24) = 0u;
        *(_OWORD *)(v14 + 40) = 0u;
        *(_QWORD *)v14 = &off_1E41A9038;
        *(_OWORD *)(v14 + 56) = 0u;
        *(_OWORD *)(v14 + 72) = 0u;
        goto LABEL_39;
      }
      goto LABEL_27;
    }
    if (v13 != 1331849827)
    {
      if (v13 == 1413830740)
      {
        v14 = operator new(72, 0x10B1C4015F6298ELL);
        CPSDOSTypeText::CPSDOSTypeText((CPSDOSTypeText *)v14);
LABEL_39:
        *((_QWORD *)this + 10) = v14;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 16))(v14, a2);
        return 1;
      }
      goto LABEL_27;
    }
    v15 = *((_DWORD *)this + 15);
    if (v15 <= 1232229223)
    {
      switch(v15)
      {
        case 1148343144:
          v14 = operator new(120, 0x10B1C4022C5DBF1);
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
          v16 = &off_1E41A9DD0;
          goto LABEL_38;
        case 1198671468:
          v14 = operator new(128, 0x10B1C4032540B95);
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
          *(_QWORD *)v14 = &off_1E41A9AE0;
          *(_QWORD *)(v14 + 120) = 0;
          goto LABEL_39;
        case 1232226156:
          v14 = operator new(120, 0x10B1C4022C5DBF1);
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
          v16 = &off_1E41A9C70;
          goto LABEL_38;
      }
    }
    else if (v15 > 1399801448)
    {
      if (v15 == 1399801449)
      {
        v14 = operator new(120, 0x10B1C4022C5DBF1);
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
        v16 = &off_1E41A9EC0;
        goto LABEL_38;
      }
      if (v15 == 1700946540)
      {
        v14 = operator new(120, 0x10B1C4022C5DBF1);
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
        v16 = &off_1E41A9E20;
        goto LABEL_38;
      }
    }
    else
    {
      if (v15 == 1232229224)
      {
        v14 = operator new(120, 0x10B1C4022C5DBF1);
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
        v16 = &off_1E41A9E70;
        goto LABEL_38;
      }
      if (v15 == 1332889452)
      {
        v14 = operator new(120, 0x10B1C4022C5DBF1);
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
        v16 = &off_1E41A9D00;
LABEL_38:
        *(_QWORD *)v14 = v16;
        goto LABEL_39;
      }
    }
    v14 = operator new(120, 0x10B1C4022C5DBF1);
    CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v14);
    goto LABEL_39;
  }
  if (v13 > 1701737836)
  {
    if (v13 == 1701737837)
    {
      v14 = operator new(96, 0x10B1C4065EDEABDLL);
      *(_DWORD *)(v14 + 16) = 0;
      *(_OWORD *)(v14 + 24) = 0u;
      *(_OWORD *)(v14 + 40) = 0u;
      *(_QWORD *)v14 = &off_1E41A9898;
      *(_QWORD *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      *(_DWORD *)(v14 + 80) = 0;
      *(_QWORD *)(v14 + 88) = 0;
      goto LABEL_39;
    }
    if (v13 == 1819242087)
    {
      v14 = operator new(64, 0x10B1C40D02A791CLL);
      *(_DWORD *)(v14 + 16) = 0;
      *(_OWORD *)(v14 + 24) = 0u;
      *(_OWORD *)(v14 + 40) = 0u;
      *(_QWORD *)v14 = &off_1E41A93D8;
      *(_DWORD *)(v14 + 56) = 0;
      goto LABEL_39;
    }
  }
  else
  {
    if (v13 == 1651470188)
    {
      v14 = operator new(64, 0x10B1C40B4161B10);
      *(_DWORD *)(v14 + 16) = 0;
      *(_OWORD *)(v14 + 24) = 0u;
      *(_OWORD *)(v14 + 40) = 0u;
      *(_QWORD *)v14 = &off_1E41A9390;
      *(_BYTE *)(v14 + 56) = 0;
      goto LABEL_39;
    }
    if (v13 == 1685026146)
    {
      v14 = operator new(64, 0x10B1C40507B098BLL);
      *(_DWORD *)(v14 + 16) = 0;
      *(_OWORD *)(v14 + 24) = 0u;
      *(_OWORD *)(v14 + 40) = 0u;
      *(_QWORD *)v14 = &off_1E41A91C0;
      *(_QWORD *)(v14 + 56) = 0;
      goto LABEL_39;
    }
  }
LABEL_27:
  *((_QWORD *)this + 10) = 0;
  _CUILog(1, (uint64_t)"in keyed item Error parsing gradient fill info: This OSType cannot be parsed.\n", v7, v8, v9, v10, v11, v12, v18);
  return 1;
}

void sub_19EC18358(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C4032540B95);
  _Unwind_Resume(a1);
}

uint64_t CPSDActionKeyedItem::Save(CPSDActionKeyedItem *this, File *a2)
{
  uint64_t result;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 14))
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)this + 8));
  else
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 15));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 18));
  result = *((_QWORD *)this + 10);
  if (result)
    return (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)result + 24))(result, a2);
  return result;
}

size_t CPSDActionKeyedItem::Dump(CPSDActionKeyedItem *this, __sFILE *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;

  v6 = operator new[](a3, 0x1000C8077774924);
  if ((_DWORD)a3)
  {
    v7 = 0;
    do
      *(_BYTE *)(v6 + (unsigned __int16)v7++) = 9;
    while (a3 > (unsigned __int16)v7);
  }
  if (*((_DWORD *)this + 15))
    fprintf(a2, "%s\tKey: '%s', \t");
  else
    fprintf(a2, "%s\tKey: \"%s\", \t");
  v8 = *((_QWORD *)this + 10);
  if (v8)
    return (*(uint64_t (**)(uint64_t, __sFILE *, uint64_t))(*(_QWORD *)v8 + 48))(v8, a2, a3);
  else
    return fwrite("Unknown Key. Data could not be parsed.\n", 0x27uLL, 1uLL, a2);
}

void CPSDActionDescriptor::~CPSDActionDescriptor(CPSDActionDescriptor *this)
{
  uint64_t v2;
  void (***v3)(_QWORD);
  void (***v4)(_QWORD);
  void (***v5)(_QWORD);
  void (***v6)(_QWORD);
  void (**v7)(_QWORD);
  BOOL v8;
  uint64_t v9;
  void **v10;

  *(_QWORD *)this = &off_1E41A9730;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    MEMORY[0x1A1AEEB08](v2, 0x1000C4077774924);
    *((_QWORD *)this + 9) = 0;
  }
  v4 = (void (***)(_QWORD))*((_QWORD *)this + 12);
  v3 = (void (***)(_QWORD))*((_QWORD *)this + 13);
  if (v3 != v4)
  {
    v5 = v3 - 11;
    v6 = v3 - 11;
    do
    {
      v7 = *v6;
      v6 -= 11;
      (*v7)(v5);
      v8 = v5 == v4;
      v5 = v6;
    }
    while (!v8);
  }
  *((_QWORD *)this + 13) = v4;
  v10 = (void **)((char *)this + 96);
  std::vector<CPSDActionKeyedItem>::__destroy_vector::operator()[abi:ne180100](&v10);
  v9 = *((_QWORD *)this + 8);
  if (v9)
  {
    MEMORY[0x1A1AEEAF0](v9, 0x1000C80BDFB0063);
    *((_QWORD *)this + 8) = 0;
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDActionDescriptor::Load(CPSDActionDescriptor *this, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  char *v6;
  unsigned int *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v13;

  v13 = 0;
  CPSDString::Load((char **)this + 7, a2, &v13);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 80, 4uLL, &v13);
  v4 = *((_DWORD *)this + 20);
  v5 = bswap32(v4);
  *((_DWORD *)this + 20) = v5;
  if (v4)
  {
    v6 = (char *)operator new[](v5, 0x1000C8077774924);
    *((_QWORD *)this + 9) = v6;
    CPSDBaseComponent::ReadFile(a2, v6, *((unsigned int *)this + 20), &v13);
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 84, 4uLL, &v13);
    *((_DWORD *)this + 21) = bswap32(*((_DWORD *)this + 21));
  }
  v7 = (unsigned int *)((char *)this + 88);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 88, 4uLL, &v13);
  v8 = bswap32(*((_DWORD *)this + 22));
  *((_DWORD *)this + 22) = v8;
  v9 = (_QWORD *)((char *)this + 96);
  std::vector<CPSDActionKeyedItem>::resize((uint64_t *)this + 12, v8);
  if (*((_DWORD *)this + 22))
  {
    v10 = 0;
    v11 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*v9 + v10) + 16))(*v9 + v10, a2);
      ++v11;
      v10 += 88;
    }
    while (v11 < *v7);
  }
  return 1;
}

uint64_t *std::vector<CPSDActionKeyedItem>::resize(uint64_t *result, unint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t (***v8)(_QWORD);
  uint64_t (***v9)(_QWORD);
  uint64_t (**v10)(_QWORD);
  BOOL v11;

  v2 = result;
  v3 = result[1];
  v4 = 0x2E8BA2E8BA2E8BA3 * ((v3 - *result) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
    return (uint64_t *)std::vector<CPSDActionKeyedItem>::__append(result, v6);
  if (!v5)
  {
    v7 = *result + 88 * a2;
    if (v3 != v7)
    {
      v8 = (uint64_t (***)(_QWORD))(v3 - 88);
      v9 = (uint64_t (***)(_QWORD))(v3 - 88);
      do
      {
        v10 = *v9;
        v9 -= 11;
        result = (uint64_t *)(*v10)(v8);
        v11 = v8 == (uint64_t (***)(_QWORD))v7;
        v8 = v9;
      }
      while (!v11);
    }
    v2[1] = v7;
  }
  return result;
}

uint64_t CPSDActionDescriptor::Save(CPSDActionDescriptor *this, File *a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  (*(void (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 8), *((unsigned int *)this + 14));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 20));
  if (*((_DWORD *)this + 20))
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)this + 9));
  else
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 21));
  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 22));
  if (*((_DWORD *)this + 22))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, File *))(*(_QWORD *)(*((_QWORD *)this + 12) + v5) + 24))(*((_QWORD *)this + 12) + v5, a2);
      ++v6;
      v5 += 88;
    }
    while (v6 < *((unsigned int *)this + 22));
  }
  return result;
}

uint64_t CPSDActionDescriptor::DumpInset(const UniChar **this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6;
  const char *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char v16[256];

  v6 = operator new[](a3, 0x1000C8077774924);
  v7 = (const char *)v6;
  if (a3)
  {
    v8 = 0;
    do
      *(_BYTE *)(v6 + (unsigned __int16)v8++) = 9;
    while (a3 > (unsigned __int16)v8);
  }
  CPSDString::CopyStringValue(this + 7, v16, 0x100u);
  fprintf(a2, "%sDescriptor { Name = %s, ", v7, v16);
  if (*((_DWORD *)this + 20))
  {
    fwrite("ClassID", 7uLL, 1uLL, a2);
    if (*((_DWORD *)this + 20))
    {
      v9 = 0;
      do
        fputc(*((unsigned __int8 *)this[9] + v9++), a2);
      while (v9 < *((unsigned int *)this + 20));
    }
    fwrite(", ", 2uLL, 1uLL, a2);
  }
  else
  {
    fprintf(a2, "ClassID = '%s', ", (const char *)this + 84);
  }
  fprintf(a2, "Number of Items = %d:\n", *((_DWORD *)this + 22));
  v10 = *((unsigned int *)this + 22);
  if (0x2E8BA2E8BA2E8BA3 * (((char *)this[13] - (char *)this[12]) >> 3) == v10 && (_DWORD)v10 != 0)
  {
    v12 = 0;
    v13 = a3 + 1;
    do
    {
      v14 = (uint64_t)&this[12][44 * (unsigned __int16)v12];
      (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(_QWORD *)v14 + 48))(v14, a2, v13);
      ++v12;
    }
    while (*((_DWORD *)this + 22) > (unsigned __int16)v12);
  }
  return fprintf(a2, "%s}\n", v7);
}

uint64_t CPSDActionDescriptor::GetItemForKeyString(CPSDActionDescriptor *this, unsigned __int8 *a2)
{
  CFStringEncoding SystemEncoding;
  CFStringRef v5;
  unsigned int v6;
  unsigned __int16 v7;
  unsigned int v8;
  const UInt8 *v9;
  CFStringEncoding v10;
  const __CFString *v11;
  CFComparisonResult v12;

  SystemEncoding = CFStringGetSystemEncoding();
  v5 = CFStringCreateWithBytes(kCFAllocatorDefault, a2, 8, SystemEncoding, 0);
  v6 = *((_DWORD *)this + 22);
  if (!v6)
  {
LABEL_7:
    CFRelease(v5);
    return 0;
  }
  v7 = 0;
  while (1)
  {
    v8 = v7;
    v9 = *(const UInt8 **)(*((_QWORD *)this + 12) + 88 * v7 + 64);
    if (v9)
      break;
LABEL_6:
    v7 = v8 + 1;
    if (v6 <= (unsigned __int16)(v8 + 1))
      goto LABEL_7;
  }
  v10 = CFStringGetSystemEncoding();
  v11 = CFStringCreateWithBytes(kCFAllocatorDefault, v9, 8, v10, 0);
  v12 = CFStringCompare(v5, v11, 0);
  CFRelease(v11);
  if (v12)
  {
    v6 = *((_DWORD *)this + 22);
    goto LABEL_6;
  }
  CFRelease(v5);
  return *(_QWORD *)(*((_QWORD *)this + 12) + 88 * v8 + 80);
}

void CPSDActionDescriptor::CPSDActionDescriptor(CPSDActionDescriptor *this)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_QWORD *)this = &off_1E41A9730;
  *((_QWORD *)this + 8) = 0;
  CPSDString::AllocateCharData((CPSDActionDescriptor *)((char *)this + 56), 1u);
  **((_WORD **)this + 8) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
}

void sub_19EC18C40(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem *v1;

  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

BOOL CPSDDropShadowDescriptor::Load(CPSDDropShadowDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1148343144)
  {
    if (v3 <= ++v4)
      return 0;
  }
  return *(_QWORD *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDDropShadowDescriptor::DumpInset(CPSDDropShadowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  double Angle;
  double Distance;
  double BlurSize;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Drop Shadow:\n", v6);
  Angle = CPSDDropShadowDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  Distance = CPSDDropShadowDescriptor::GetDistance(this);
  fprintf(a2, "%s\tDistance: %f\n", v7, Distance);
  BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Drop Shadow\n", v7);
}

double CPSDDropShadowDescriptor::GetAngle(CPSDDropShadowDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 0.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1818322796)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

double CPSDDropShadowDescriptor::GetDistance(CPSDDropShadowDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 0.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1148417134)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

double CPSDDropShadowDescriptor::GetBlurSize(CPSDDropShadowDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 0.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1651275122)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

uint64_t CPSDDropShadowDescriptor::GetIsEnabled(CPSDDropShadowDescriptor *this)
{
  uint64_t v1;
  unsigned int v2;
  int v3;

  v1 = *((_QWORD *)this + 12);
  if (*(_DWORD *)(v1 + 60) == 1701732706)
  {
    v2 = 0;
  }
  else
  {
    v3 = 0;
    do
      v2 = (unsigned __int16)++v3;
    while (*(_DWORD *)(v1 + 88 * (unsigned __int16)v3 + 60) != 1701732706);
  }
  return *(unsigned __int8 *)(*(_QWORD *)(v1 + 88 * v2 + 80) + 56);
}

double CPSDDropShadowDescriptor::GetColor(CPSDDropShadowDescriptor *this, double *a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned __int16 v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  double result;
  uint64_t v15;
  uint64_t v16;

  v2 = *((_QWORD *)this + 12);
  if (*(_DWORD *)(v2 + 60) == 1131180576)
  {
    v3 = 0;
  }
  else
  {
    v4 = 0;
    do
      v3 = (unsigned __int16)++v4;
    while (*(_DWORD *)(v2 + 88 * (unsigned __int16)v4 + 60) != 1131180576);
  }
  v5 = 0;
  v6 = *(_QWORD *)(v2 + 88 * v3 + 80);
  v7 = *(_DWORD *)(v6 + 88);
  v8 = *(_QWORD *)(v6 + 96);
  while (*(_DWORD *)(v8 + 88 * v5 + 60) != 1382293536)
  {
    if (v7 <= ++v5)
    {
      v9 = 0;
      goto LABEL_10;
    }
  }
  v9 = *(_QWORD *)(v8 + 88 * v5 + 80);
LABEL_10:
  v10 = 0;
  while (*(_DWORD *)(v8 + 88 * v10 + 60) != 1198681632)
  {
    if (v7 <= ++v10)
    {
      v11 = 0;
      goto LABEL_15;
    }
  }
  v11 = *(_QWORD *)(v8 + 88 * v10 + 80);
LABEL_15:
  if (*(_DWORD *)(v8 + 60) == 1114382368)
  {
    v12 = 0;
  }
  else
  {
    v13 = 0;
    do
      v12 = (unsigned __int16)++v13;
    while (*(_DWORD *)(v8 + 88 * (unsigned __int16)v13 + 60) != 1114382368);
  }
  result = *(double *)(v9 + 56);
  v15 = *(_QWORD *)(v11 + 56);
  v16 = *(_QWORD *)(*(_QWORD *)(v8 + 88 * v12 + 80) + 56);
  *a2 = result;
  *((_QWORD *)a2 + 1) = v15;
  *((_QWORD *)a2 + 2) = v16;
  a2[3] = 1.0;
  return result;
}

uint64_t CPSDDropShadowDescriptor::GetBlendMode(CPSDDropShadowDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  CPSDOSTypeEnumerated *v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1298407456)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4)
    return CPSDOSTypeEnumerated::GetEnum(v4);
  else
    return 0;
}

uint64_t CPSDOSTypeEnumerated::GetEnum(CPSDOSTypeEnumerated *this)
{
  uint64_t v1;
  const char *v2;

  if (!*((_DWORD *)this + 15))
    return *((unsigned int *)this + 20);
  v1 = 1282240116;
  v2 = (const char *)*((_QWORD *)this + 11);
  if (strcmp(v2, "linearBurn"))
  {
    if (!strcmp(v2, "darkerColor"))
    {
      return 1282240117;
    }
    else if (!strcmp(v2, "linearDodge"))
    {
      return 1282240118;
    }
    else if (!strcmp(v2, "lighterColor"))
    {
      return 1282240119;
    }
    else if (!strcmp(v2, "vividLight"))
    {
      return 1282240120;
    }
    else if (!strcmp(v2, "linearLight"))
    {
      return 1282240121;
    }
    else if (!strcmp(v2, "pinLight"))
    {
      return 1282240122;
    }
    else if (!strcmp(v2, "hardMix"))
    {
      return 1282240123;
    }
    else if (!strcmp(v2, "blendSubtraction"))
    {
      return 1282240124;
    }
    else if (!strcmp(v2, "blendDivide"))
    {
      return 1282240125;
    }
    else
    {
      return 1316121964;
    }
  }
  return v1;
}

double CPSDDropShadowDescriptor::GetOpacity(CPSDDropShadowDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 100.0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1332765556)
  {
    if (v1 <= ++v2)
      return 100.0;
  }
  v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  if (v4)
    return round(*(double *)(v4 + 64));
  else
    return 100.0;
}

uint64_t CPSDDropShadowDescriptor::UseGlobalLightAngle(CPSDDropShadowDescriptor *this)
{
  uint64_t v1;
  unsigned int v2;
  int v3;

  v1 = *((_QWORD *)this + 12);
  if (*(_DWORD *)(v1 + 60) == 1969712231)
  {
    v2 = 0;
  }
  else
  {
    v3 = 0;
    do
      v2 = (unsigned __int16)++v3;
    while (*(_DWORD *)(v1 + 88 * (unsigned __int16)v3 + 60) != 1969712231);
  }
  return *(unsigned __int8 *)(*(_QWORD *)(v1 + 88 * v2 + 80) + 56);
}

double CPSDDropShadowDescriptor::GetSpread(CPSDDropShadowDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 0.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1131113844)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

BOOL CPSDInnerShadowDescriptor::Load(CPSDInnerShadowDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1232229224)
  {
    if (v3 <= ++v4)
      return 0;
  }
  return *(_QWORD *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDInnerShadowDescriptor::DumpInset(CPSDInnerShadowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  double Angle;
  double Distance;
  double BlurSize;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Inner Shadow:\n", v6);
  Angle = CPSDDropShadowDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  Distance = CPSDDropShadowDescriptor::GetDistance(this);
  fprintf(a2, "%s\tDistance: %f\n", v7, Distance);
  BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Inner Shadow\n", v7);
}

BOOL CPSDInnerGlowDescriptor::Load(CPSDInnerGlowDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1232226156)
  {
    if (v3 <= ++v4)
      return 0;
  }
  return *(_QWORD *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDInnerGlowDescriptor::DumpInset(CPSDInnerGlowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  double BlurSize;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Inner Glow:\n", v6);
  BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Inner Glow\n", v7);
}

BOOL CPSDOuterGlowDescriptor::Load(CPSDOuterGlowDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1332889452)
  {
    if (v3 <= ++v4)
      return 0;
  }
  return *(_QWORD *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDOuterGlowDescriptor::DumpInset(CPSDOuterGlowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  double BlurSize;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Outer Glow:\n", v6);
  BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Outer Glow\n", v7);
}

BOOL CPSDBevelEmbossDescriptor::Load(CPSDBevelEmbossDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1700946540)
  {
    if (v3 <= ++v4)
      return 0;
  }
  return *(_QWORD *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDBevelEmbossDescriptor::DumpInset(CPSDBevelEmbossDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  double Angle;
  double BlurSize;

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Bevel & Emboss:\n", v6);
  Angle = CPSDDropShadowDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Bevel & Emboss\n", v7);
}

uint64_t CPSDBevelEmbossDescriptor::GetBevelDirection(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  CPSDOSTypeEnumerated *v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1651928132)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4)
    return CPSDOSTypeEnumerated::GetEnum(v4);
  else
    return 0;
}

double CPSDBevelEmbossDescriptor::GetHighlightColor(CPSDBevelEmbossDescriptor *this, double *a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned __int16 v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  double result;
  uint64_t v15;
  uint64_t v16;

  v2 = *((_QWORD *)this + 12);
  if (*(_DWORD *)(v2 + 60) == 1751608387)
  {
    v3 = 0;
  }
  else
  {
    v4 = 0;
    do
      v3 = (unsigned __int16)++v4;
    while (*(_DWORD *)(v2 + 88 * (unsigned __int16)v4 + 60) != 1751608387);
  }
  v5 = 0;
  v6 = *(_QWORD *)(v2 + 88 * v3 + 80);
  v7 = *(_DWORD *)(v6 + 88);
  v8 = *(_QWORD *)(v6 + 96);
  while (*(_DWORD *)(v8 + 88 * v5 + 60) != 1382293536)
  {
    if (v7 <= ++v5)
    {
      v9 = 0;
      goto LABEL_10;
    }
  }
  v9 = *(_QWORD *)(v8 + 88 * v5 + 80);
LABEL_10:
  v10 = 0;
  while (*(_DWORD *)(v8 + 88 * v10 + 60) != 1198681632)
  {
    if (v7 <= ++v10)
    {
      v11 = 0;
      goto LABEL_15;
    }
  }
  v11 = *(_QWORD *)(v8 + 88 * v10 + 80);
LABEL_15:
  if (*(_DWORD *)(v8 + 60) == 1114382368)
  {
    v12 = 0;
  }
  else
  {
    v13 = 0;
    do
      v12 = (unsigned __int16)++v13;
    while (*(_DWORD *)(v8 + 88 * (unsigned __int16)v13 + 60) != 1114382368);
  }
  result = *(double *)(v9 + 56);
  v15 = *(_QWORD *)(v11 + 56);
  v16 = *(_QWORD *)(*(_QWORD *)(v8 + 88 * v12 + 80) + 56);
  *a2 = result;
  *((_QWORD *)a2 + 1) = v15;
  *((_QWORD *)a2 + 2) = v16;
  a2[3] = 1.0;
  return result;
}

uint64_t CPSDBevelEmbossDescriptor::GetHighlightBlendMode(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  CPSDOSTypeEnumerated *v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1751608397)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4)
    return CPSDOSTypeEnumerated::GetEnum(v4);
  else
    return 0;
}

double CPSDBevelEmbossDescriptor::GetHighlightOpacity(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 100.0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1751608399)
  {
    if (v1 <= ++v2)
      return 100.0;
  }
  v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  if (v4)
    return round(*(double *)(v4 + 64));
  else
    return 100.0;
}

double CPSDBevelEmbossDescriptor::GetShadowColor(CPSDBevelEmbossDescriptor *this, double *a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned __int16 v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  double result;
  uint64_t v15;
  uint64_t v16;

  v2 = *((_QWORD *)this + 12);
  if (*(_DWORD *)(v2 + 60) == 1935963971)
  {
    v3 = 0;
  }
  else
  {
    v4 = 0;
    do
      v3 = (unsigned __int16)++v4;
    while (*(_DWORD *)(v2 + 88 * (unsigned __int16)v4 + 60) != 1935963971);
  }
  v5 = 0;
  v6 = *(_QWORD *)(v2 + 88 * v3 + 80);
  v7 = *(_DWORD *)(v6 + 88);
  v8 = *(_QWORD *)(v6 + 96);
  while (*(_DWORD *)(v8 + 88 * v5 + 60) != 1382293536)
  {
    if (v7 <= ++v5)
    {
      v9 = 0;
      goto LABEL_10;
    }
  }
  v9 = *(_QWORD *)(v8 + 88 * v5 + 80);
LABEL_10:
  v10 = 0;
  while (*(_DWORD *)(v8 + 88 * v10 + 60) != 1198681632)
  {
    if (v7 <= ++v10)
    {
      v11 = 0;
      goto LABEL_15;
    }
  }
  v11 = *(_QWORD *)(v8 + 88 * v10 + 80);
LABEL_15:
  if (*(_DWORD *)(v8 + 60) == 1114382368)
  {
    v12 = 0;
  }
  else
  {
    v13 = 0;
    do
      v12 = (unsigned __int16)++v13;
    while (*(_DWORD *)(v8 + 88 * (unsigned __int16)v13 + 60) != 1114382368);
  }
  result = *(double *)(v9 + 56);
  v15 = *(_QWORD *)(v11 + 56);
  v16 = *(_QWORD *)(*(_QWORD *)(v8 + 88 * v12 + 80) + 56);
  *a2 = result;
  *((_QWORD *)a2 + 1) = v15;
  *((_QWORD *)a2 + 2) = v16;
  a2[3] = 1.0;
  return result;
}

uint64_t CPSDBevelEmbossDescriptor::GetShadowBlendMode(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  CPSDOSTypeEnumerated *v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1935963981)
  {
    if (v1 <= ++v2)
      return 0;
  }
  v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4)
    return CPSDOSTypeEnumerated::GetEnum(v4);
  else
    return 0;
}

double CPSDBevelEmbossDescriptor::GetShadowOpacity(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_DWORD *)this + 22);
  if (!v1)
    return 100.0;
  v2 = 0;
  v3 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1935963983)
  {
    if (v1 <= ++v2)
      return 100.0;
  }
  v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  if (v4)
    return round(*(double *)(v4 + 64));
  else
    return 100.0;
}

double CPSDBevelEmbossDescriptor::GetAltitude(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 30.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1281453156)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

double CPSDBevelEmbossDescriptor::GetSoftenSize(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 0.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1399223406)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64);
  }
  return result;
}

BOOL CPSDColorOverlayDescriptor::Load(CPSDColorOverlayDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1399801449)
  {
    if (v3 <= ++v4)
      return 0;
  }
  return *(_QWORD *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDColorOverlayDescriptor::DumpInset(CPSDColorOverlayDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v5;
  const char *v6;
  int v7;

  v5 = (const char *)operator new[](a3, 0x1000C8077774924);
  v6 = v5;
  if (a3)
  {
    v7 = 0;
    do
      v5[(unsigned __int16)v7++] = 9;
    while (a3 > (unsigned __int16)v7);
  }
  fprintf(a2, "%s{ Color Overlay:\n", v5);
  return fprintf(a2, "%s} // End Color Overlay\n", v6);
}

uint64_t CPSDGradientDescriptor::Load(CPSDGradientDescriptor *this, uint64_t a2)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 v11;
  uint64_t result;
  uint64_t v13;
  int v14;

  CPSDActionDescriptor::Load(this, a2);
  v3 = *((_DWORD *)this + 22);
  if (!v3)
    return 0;
  v4 = 0;
  v5 = *((_QWORD *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1198678372)
  {
    if (v3 <= ++v4)
      return 0;
  }
  v6 = *(_QWORD *)(v5 + 88 * v4 + 80);
  if (!v6)
    return 0;
  v7 = *(_DWORD *)(v6 + 88);
  if (!v7)
    return 0;
  v8 = 0;
  v9 = *(_QWORD *)(v6 + 96);
  while (*(_DWORD *)(v9 + 88 * v8 + 60) != 1131180659)
  {
    if (v7 <= ++v8)
      return 0;
  }
  v10 = *(_QWORD *)(v9 + 88 * v8 + 80);
  if (!v10)
    return 0;
  v11 = 0;
  while (*(_DWORD *)(v9 + 88 * v11 + 60) != 1416785523)
  {
    result = 0;
    if (v7 <= ++v11)
      return result;
  }
  v13 = *(_QWORD *)(v9 + 88 * v11 + 80);
  if (!v13)
    return 0;
  v14 = *(_DWORD *)(v13 + 56);
  *((_DWORD *)this + 30) = *(_DWORD *)(v10 + 56);
  *((_DWORD *)this + 31) = v14;
  return 1;
}

uint64_t CPSDGradientDescriptor::DumpInset(CPSDGradientDescriptor *this, __sFILE *a2, unsigned int a3)
{
  const char *v6;
  const char *v7;
  int v8;
  int Style;
  const char *v10;
  size_t v11;
  unsigned int v12;
  unsigned __int16 v13;
  uint64_t v14;
  double Angle;
  double Scale;
  int IsReversed;
  int IsDithered;
  const char *v19;
  const char *v20;
  int Type;
  const char *v22;
  double Smoothness;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t result;
  double v29;
  double v30;
  void *v31;
  uint64_t v32;
  double v33[4];
  char v34[256];

  v6 = (const char *)operator new[](a3, 0x1000C8077774924);
  v7 = v6;
  if (a3)
  {
    v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Gradient:\n", v6);
  CPSDGradientDescriptor::GetName(this, &v31);
  CPSDString::CopyStringValue((const UniChar **)&v31, v34, 0x100u);
  fprintf(a2, "%s\tName: %s\n", v7, v34);
  fprintf(a2, "%s\tStyle: ", v7);
  Style = CPSDGradientDescriptor::GetStyle(this);
  if (Style <= 1282306591)
  {
    if (Style == 1097754476)
    {
      v10 = "Angular (Sweep)\n";
      v11 = 16;
      goto LABEL_16;
    }
    if (Style != 1148022372)
      goto LABEL_44;
    v10 = "Diamond\n";
    v11 = 8;
LABEL_16:
    fwrite(v10, v11, 1uLL, a2);
    goto LABEL_17;
  }
  switch(Style)
  {
    case 1382444131:
      v10 = "Reflected\n";
      v11 = 10;
      goto LABEL_16;
    case 1382312992:
      v10 = "Radial\n";
      goto LABEL_14;
    case 1282306592:
      v10 = "Linear\n";
LABEL_14:
      v11 = 7;
      goto LABEL_16;
  }
LABEL_44:
  fprintf(a2, "%d, Style not recognized\n", Style);
LABEL_17:
  v12 = *((_DWORD *)this + 22);
  if (v12)
  {
    v13 = 0;
    v14 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v14 + 88 * v13 + 60) != 1332114292)
    {
      if (v12 <= ++v13)
        goto LABEL_24;
    }
    if (*(_QWORD *)(v14 + 88 * v13 + 80))
    {
      v33[0] = 0.0;
      v30 = 0.0;
      CPSDGradientDescriptor::GetOffset((uint64_t)this, v33, &v30);
      fprintf(a2, "%s\tOffset: (%f,%f)\n", v7, v33[0], v30);
    }
  }
LABEL_24:
  Angle = CPSDGradientDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  Scale = CPSDGradientDescriptor::GetScale(this);
  fprintf(a2, "%s\tScale: %.0f%%\n", v7, Scale * 100.0);
  IsReversed = CPSDGradientDescriptor::GetIsReversed(this);
  IsDithered = CPSDGradientDescriptor::GetIsDithered(this);
  v19 = "YES";
  if (IsReversed)
    v20 = "YES";
  else
    v20 = "NO";
  if (!IsDithered)
    v19 = "NO";
  fprintf(a2, "%s\tReverse: %s, Dither: %s\n", v7, v20, v19);
  fprintf(a2, "%s\tType: ", v7);
  Type = CPSDGradientDescriptor::GetType(this);
  if (Type == 1)
  {
    v22 = "Noise\n";
    goto LABEL_33;
  }
  if (!Type)
  {
    v22 = "Solid\n";
LABEL_33:
    fwrite(v22, 6uLL, 1uLL, a2);
    goto LABEL_35;
  }
  fprintf(a2, "%d, Type not recognized\n", 2);
LABEL_35:
  Smoothness = CPSDGradientDescriptor::GetSmoothness(this);
  fprintf(a2, "%s\tSmoothness: %.0f%%\n", v7, Smoothness * 100.0);
  fprintf(a2, "%s\tColor stops[%d]:\n", v7, *((_DWORD *)this + 30));
  if (*((_DWORD *)this + 30))
  {
    v24 = 0;
    v25 = 0;
    do
    {
      v29 = 0.0;
      v30 = 0.0;
      CPSDGradientDescriptor::GetColorStopAtIndex(this, (unsigned __int16)v25, v33, &v30, &v29);
      fprintf(a2, "%s\t\t[%d]: RGB: (%f, %f, %f), Location: %f, Midpoint: %f\n", v7, v24, v33[0], v33[1], v33[2], v30, v29);
      v24 = (unsigned __int16)++v25;
    }
    while (*((_DWORD *)this + 30) > (unsigned __int16)v25);
  }
  fprintf(a2, "%s\tOpacity stops[%d]:\n", v7, *((_DWORD *)this + 31));
  if (*((_DWORD *)this + 31))
  {
    v26 = 0;
    v27 = 0;
    do
    {
      v33[0] = 0.0;
      v29 = 0.0;
      v30 = 0.0;
      CPSDGradientDescriptor::GetOpacityStopAtIndex(this, (unsigned __int16)v27, v33, &v30, &v29);
      fprintf(a2, "%s\t\t[%d]: Opacity: %.0f%%, Location: %f, Midpoint: %f\n", v7, v26, v33[0], v30, v29);
      v26 = (unsigned __int16)++v27;
    }
    while (*((_DWORD *)this + 31) > (unsigned __int16)v27);
  }
  fprintf(a2, "%s} // End Gradient\n", v7);
  result = v32;
  if (v32)
    return MEMORY[0x1A1AEEAF0](v32, 0x1000C80BDFB0063);
  return result;
}

void sub_19EC1A480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19)
    MEMORY[0x1A1AEEAF0](a19, 0x1000C80BDFB0063);
  _Unwind_Resume(exception_object);
}

void *CPSDGradientDescriptor::GetName@<X0>(CPSDGradientDescriptor *this@<X0>, void **a2@<X8>)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  const void *v10;

  v3 = *((_QWORD *)this + 12);
  if (*(_DWORD *)(v3 + 60) == 1198678372)
  {
    v4 = 0;
  }
  else
  {
    v5 = 0;
    do
      v4 = (unsigned __int16)++v5;
    while (*(_DWORD *)(v3 + 88 * (unsigned __int16)v5 + 60) != 1198678372);
  }
  v6 = *(_QWORD *)(*(_QWORD *)(v3 + 88 * v4 + 80) + 96);
  if (*(_DWORD *)(v6 + 60) == 1315774496)
  {
    v7 = 0;
  }
  else
  {
    v8 = 0;
    do
      v7 = (unsigned __int16)++v8;
    while (*(_DWORD *)(v6 + 88 * (unsigned __int16)v8 + 60) != 1315774496);
  }
  v9 = *(_QWORD *)(v6 + 88 * v7 + 80);
  a2[1] = 0;
  v10 = *(const void **)(v9 + 64);
  CPSDString::AllocateCharData((CPSDString *)a2, *(_DWORD *)(v9 + 56));
  return memcpy(a2[1], v10, (2 * *(_DWORD *)a2));
}

uint64_t CPSDGradientDescriptor::GetOffset(uint64_t this, double *a2, double *a3)
{
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;

  v3 = *(_DWORD *)(this + 88);
  if (!v3)
    goto LABEL_11;
  v4 = 0;
  v5 = *(_QWORD *)(this + 96);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1332114292)
  {
    if (v3 <= ++v4)
      goto LABEL_11;
  }
  v6 = *(_QWORD *)(v5 + 88 * v4 + 80);
  if (v6)
  {
    v7 = 0;
    v8 = *(_DWORD *)(v6 + 88);
    v9 = *(_QWORD *)(v6 + 96);
    while (*(_DWORD *)(v9 + 88 * v7 + 60) != 1215461998)
    {
      if (v8 <= ++v7)
      {
        v10 = 0;
        goto LABEL_14;
      }
    }
    v10 = *(_QWORD *)(v9 + 88 * v7 + 80);
LABEL_14:
    if (*(_DWORD *)(v9 + 60) == 1450341475)
    {
      v12 = 0;
    }
    else
    {
      v13 = 0;
      do
        v12 = (unsigned __int16)++v13;
      while (*(_DWORD *)(v9 + 88 * (unsigned __int16)v13 + 60) != 1450341475);
    }
    v14 = *(_QWORD *)(v9 + 88 * v12 + 80);
    *a2 = *(double *)(v10 + 64);
    v11 = *(_QWORD *)(v14 + 64);
  }
  else
  {
LABEL_11:
    *a2 = 0.0;
    v11 = 0;
  }
  *(_QWORD *)a3 = v11;
  return this;
}

double CPSDGradientDescriptor::GetScale(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  double result;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_DWORD *)this + 22);
  result = 1.0;
  if (v1)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1399024672)
    {
      if (v1 <= ++v3)
        return result;
    }
    v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
    if (v5)
      return *(double *)(v5 + 64) / 100.0;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetType(CPSDGradientDescriptor *this)
{
  unsigned int v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;
  CPSDOSTypeEnumerated *v8;
  int Enum;
  unsigned int v10;

  v1 = *((_DWORD *)this + 22);
  if (v1)
  {
    v2 = 0;
    v3 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1198678372)
    {
      if (v1 <= ++v2)
        goto LABEL_5;
    }
    v4 = *(_QWORD *)(v3 + 88 * v2 + 80);
  }
  else
  {
LABEL_5:
    v4 = 0;
  }
  v5 = *(_DWORD *)(v4 + 88);
  if (v5)
  {
    v6 = 0;
    v7 = *(_QWORD *)(v4 + 96);
    while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198679110)
    {
      if (v5 <= ++v6)
        goto LABEL_11;
    }
    v8 = *(CPSDOSTypeEnumerated **)(v7 + 88 * v6 + 80);
  }
  else
  {
LABEL_11:
    v8 = 0;
  }
  Enum = CPSDOSTypeEnumerated::GetEnum(v8);
  if (Enum == 1131171443)
    v10 = 1;
  else
    v10 = 2;
  if (Enum == 1131639891)
    return 0;
  else
    return v10;
}

uint64_t CPSDGradientFillInfo::Load(CPSDGradientFillInfo *this, uint64_t a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 128, 4uLL, &v5);
  *((_DWORD *)this + 32) = bswap32(*((_DWORD *)this + 32));
  return CPSDGradientDescriptor::Load(this, a2);
}

uint64_t CPSDGradientFillInfo::Save(CPSDGradientFillInfo *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 32));
  return CPSDActionDescriptor::Save(this, a2);
}

size_t CPSDGradientFillInfo::Dump(CPSDGradientFillInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ GradientFillInfo: version=%d\n", *((_DWORD *)this + 32));
  fputs("Dump: ActionBaseComponent\n", a2);
  return fwrite("} // End GradientFillInfo\n", 0x1AuLL, 1uLL, a2);
}

uint64_t CPSDColorFillInfo::Load(CPSDColorFillInfo *this, uint64_t a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 120, 4uLL, &v5);
  *((_DWORD *)this + 30) = bswap32(*((_DWORD *)this + 30));
  CPSDActionDescriptor::Load(this, a2);
  return 1;
}

uint64_t CPSDColorFillInfo::Save(CPSDColorFillInfo *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 30));
  return CPSDActionDescriptor::Save(this, a2);
}

size_t CPSDColorFillInfo::Dump(CPSDColorFillInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ ColorFillInfo: version=%d\n", *((_DWORD *)this + 30));
  return fwrite("} // End ColorFillInfo\n", 0x17uLL, 1uLL, a2);
}

void CPSDObjectEffectsLayerInfo::~CPSDObjectEffectsLayerInfo(CPSDObjectEffectsLayerInfo *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

CPSDActionKeyedItem *CPSDObjectEffectsLayerInfo::MakeOffsetItem(CPSDObjectEffectsLayerInfo *this, float a2, float a3)
{
  CPSDActionDescriptor *v5;
  uint64_t v6;
  uint64_t v7;
  CPSDActionKeyedItem *v8;
  _BYTE v10[88];
  _BYTE v11[88];

  v5 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
  CPSDActionDescriptor::CPSDActionDescriptor(v5);
  *((_DWORD *)v5 + 21) = 1349415968;
  v6 = operator new(72, 0x10B1C403C8C186CLL);
  *(_DWORD *)(v6 + 16) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_QWORD *)v6 = &off_1E41A96A8;
  *(_DWORD *)(v6 + 56) = 592474723;
  *(double *)(v6 + 64) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v11, 1215461998, (CPSDActionBaseComponent *)v6);
  CPSDActionDescriptor::AdoptItem(v5, (CPSDActionKeyedItem *)v11);
  v7 = operator new(72, 0x10B1C403C8C186CLL);
  *(_DWORD *)(v7 + 16) = 0;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_QWORD *)v7 = &off_1E41A96A8;
  *(_DWORD *)(v7 + 56) = 592474723;
  *(double *)(v7 + 64) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v10, 1450341475, (CPSDActionBaseComponent *)v7);
  CPSDActionDescriptor::AdoptItem(v5, (CPSDActionKeyedItem *)v10);
  v8 = (CPSDActionKeyedItem *)operator new(88, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::CPSDActionKeyedItem(v8, 1332114292, v5);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v10);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v11);
  return v8;
}

void sub_19EC1ABB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  uint64_t v20;
  uint64_t v21;

  v21 = v20;
  MEMORY[0x1A1AEEB08](v21, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a9);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a20);
  _Unwind_Resume(a1);
}

uint64_t CPSDActionDescriptor::AdoptItem(CPSDActionDescriptor *this, CPSDActionKeyedItem *a2)
{
  unint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t result;

  v3 = *((_QWORD *)this + 13);
  if (v3 >= *((_QWORD *)this + 14))
  {
    result = std::vector<CPSDActionKeyedItem>::__push_back_slow_path<CPSDActionKeyedItem>((uint64_t *)this + 12, (uint64_t)a2);
  }
  else
  {
    *(_DWORD *)(v3 + 16) = 0;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    v4 = *((_QWORD *)a2 + 1);
    *(_QWORD *)v3 = &off_1E41A95C0;
    *(_QWORD *)(v3 + 8) = v4;
    v5 = *((_OWORD *)a2 + 1);
    *(_QWORD *)(v3 + 32) = *((_QWORD *)a2 + 4);
    *(_OWORD *)(v3 + 16) = v5;
    *(_OWORD *)(v3 + 40) = *(_OWORD *)((char *)a2 + 40);
    v6 = *(_OWORD *)((char *)a2 + 56);
    *(_OWORD *)(v3 + 72) = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)(v3 + 56) = v6;
    *((_QWORD *)a2 + 10) = 0;
    *((_QWORD *)a2 + 8) = 0;
    result = v3 + 88;
  }
  *((_QWORD *)this + 13) = result;
  ++*((_DWORD *)this + 22);
  return result;
}

CPSDActionKeyedItem *CPSDObjectEffectsLayerInfo::MakeRGBColor(CPSDObjectEffectsLayerInfo *this, double a2, double a3, double a4)
{
  CPSDActionDescriptor *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CPSDActionKeyedItem *v11;
  _BYTE v13[88];
  _BYTE v14[88];
  _BYTE v15[88];

  v7 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
  CPSDActionDescriptor::CPSDActionDescriptor(v7);
  *((_DWORD *)v7 + 21) = 1380401731;
  v8 = operator new(64, 0x10B1C40507B098BLL);
  *(_DWORD *)(v8 + 16) = 0;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_QWORD *)v8 = &off_1E41A91C0;
  *(double *)(v8 + 56) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v15, 1382293536, (CPSDActionBaseComponent *)v8);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v15);
  v9 = operator new(64, 0x10B1C40507B098BLL);
  *(_DWORD *)(v9 + 16) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_QWORD *)v9 = &off_1E41A91C0;
  *(double *)(v9 + 56) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v14, 1198681632, (CPSDActionBaseComponent *)v9);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v14);
  v10 = operator new(64, 0x10B1C40507B098BLL);
  *(_DWORD *)(v10 + 16) = 0;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_QWORD *)v10 = &off_1E41A91C0;
  *(double *)(v10 + 56) = a4;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v13, 1114382368, (CPSDActionBaseComponent *)v10);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v13);
  v11 = (CPSDActionKeyedItem *)operator new(88, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::CPSDActionKeyedItem(v11, 1131180576, v7);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v13);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v14);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v15);
  return v11;
}

void sub_19EC1AE70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v4 = v2;
  MEMORY[0x1A1AEEB08](v4, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v3 - 152));
  _Unwind_Resume(a1);
}

CPSDActionDescriptor *CPSDObjectEffectsLayerInfo::MakeColorStopObject(CPSDObjectEffectsLayerInfo *this, int a2, int a3, double a4, double a5, double a6)
{
  CPSDActionDescriptor *v11;
  CPSDObjectEffectsLayerInfo *v12;
  CPSDActionKeyedItem *RGBColor;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v18[88];
  _BYTE v19[88];
  _BYTE v20[88];

  v11 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
  CPSDActionDescriptor::CPSDActionDescriptor(v11);
  *((_DWORD *)v11 + 21) = 1131180660;
  RGBColor = CPSDObjectEffectsLayerInfo::MakeRGBColor(v12, a4, a5, a6);
  CPSDActionDescriptor::AdoptItem(v11, RGBColor);
  v14 = operator new(96, 0x10B1C4065EDEABDLL);
  *(_DWORD *)(v14 + 16) = 0;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_QWORD *)v14 = &off_1E41A9898;
  *(_QWORD *)(v14 + 56) = 0;
  *(_QWORD *)(v14 + 88) = 0;
  *(_DWORD *)(v14 + 64) = 1131180665;
  *(_DWORD *)(v14 + 80) = 1433629267;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v20, 1417244773, (CPSDActionBaseComponent *)v14);
  CPSDActionDescriptor::AdoptItem(v11, (CPSDActionKeyedItem *)v20);
  v15 = operator new(64, 0x10B1C40D02A791CLL);
  *(_DWORD *)(v15 + 16) = 0;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_QWORD *)v15 = &off_1E41A93D8;
  *(_DWORD *)(v15 + 56) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v19, 1281586286, (CPSDActionBaseComponent *)v15);
  CPSDActionDescriptor::AdoptItem(v11, (CPSDActionKeyedItem *)v19);
  v16 = operator new(64, 0x10B1C40D02A791CLL);
  *(_DWORD *)(v16 + 16) = 0;
  *(_OWORD *)(v16 + 24) = 0u;
  *(_OWORD *)(v16 + 40) = 0u;
  *(_QWORD *)v16 = &off_1E41A93D8;
  *(_DWORD *)(v16 + 56) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v18, 1298428014, (CPSDActionBaseComponent *)v16);
  CPSDActionDescriptor::AdoptItem(v11, (CPSDActionKeyedItem *)v18);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v18);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v19);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v20);
  return v11;
}

void sub_19EC1B0C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v2 - 168));
  _Unwind_Resume(a1);
}

CPSDActionDescriptor *CPSDObjectEffectsLayerInfo::MakeTransparencyStopObject(CPSDObjectEffectsLayerInfo *this, int a2, int a3, float a4)
{
  CPSDActionDescriptor *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[88];
  _BYTE v13[88];
  _BYTE v14[88];

  v7 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
  CPSDActionDescriptor::CPSDActionDescriptor(v7);
  *((_DWORD *)v7 + 21) = 1416785491;
  v8 = operator new(72, 0x10B1C403C8C186CLL);
  *(_DWORD *)(v8 + 16) = 0;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_QWORD *)v8 = &off_1E41A96A8;
  *(_DWORD *)(v8 + 56) = 592474723;
  *(double *)(v8 + 64) = a4;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v14, 1332765556, (CPSDActionBaseComponent *)v8);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v14);
  v9 = operator new(64, 0x10B1C40D02A791CLL);
  *(_DWORD *)(v9 + 16) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_QWORD *)v9 = &off_1E41A93D8;
  *(_DWORD *)(v9 + 56) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v13, 1281586286, (CPSDActionBaseComponent *)v9);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v13);
  v10 = operator new(64, 0x10B1C40D02A791CLL);
  *(_DWORD *)(v10 + 16) = 0;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_QWORD *)v10 = &off_1E41A93D8;
  *(_DWORD *)(v10 + 56) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v12, 1298428014, (CPSDActionBaseComponent *)v10);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v12);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v12);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v13);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v14);
  return v7;
}

void sub_19EC1B2BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v2 - 152));
  _Unwind_Resume(a1);
}

CPSDOSTypeList *CPSDObjectEffectsLayerInfo::MakeColorStopList(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CPSDOSTypeList *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CPSDActionBaseComponent *ColorStopObject;

  v3 = operator new(88, 0x10B1C40B59DE747);
  v4 = (CPSDOSTypeList *)v3;
  *(_DWORD *)(v3 + 16) = 0;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_QWORD *)v3 = &off_1E41A9038;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_DWORD *)(v3 + 60) = 1331849827;
  v5 = *(_QWORD *)(a2 + 96) - *(_QWORD *)(a2 + 88);
  if (v5)
  {
    v6 = 0;
    v7 = v5 >> 5;
    if (v7 <= 1)
      v8 = 1;
    else
      v8 = v7;
    do
    {
      v9 = *(_QWORD *)(a2 + 88) + v6;
      ColorStopObject = CPSDObjectEffectsLayerInfo::MakeColorStopObject((CPSDObjectEffectsLayerInfo *)v3, *(_DWORD *)(v9 + 24), *(_DWORD *)(v9 + 28), *(double *)v9, *(double *)(v9 + 8), *(double *)(v9 + 16));
      CPSDOSTypeList::AdoptItem(v4, ColorStopObject);
      v6 += 32;
      --v8;
    }
    while (v8);
  }
  return v4;
}

void CPSDOSTypeList::AdoptItem(CPSDOSTypeList *this, CPSDActionBaseComponent *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = *((_QWORD *)this + 10);
  v4 = (char *)this + 80;
  v5 = v6;
  v7 = (_QWORD *)*((_QWORD *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (void **)(v4 - 16);
    v10 = *((_QWORD *)v4 - 2);
    v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    v12 = v5 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerChannelGroup *>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = a2;
    v8 = v16 + 8;
    v19 = (char *)*((_QWORD *)this + 8);
    v18 = (char *)*((_QWORD *)this + 9);
    if (v18 != v19)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = (char *)*v9;
    }
    *((_QWORD *)this + 8) = v16;
    *((_QWORD *)this + 9) = v8;
    *((_QWORD *)this + 10) = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  *((_QWORD *)this + 9) = v8;
  ++*((_DWORD *)this + 14);
}

CPSDOSTypeList *CPSDObjectEffectsLayerInfo::MakeTransparencyStopList(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CPSDOSTypeList *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  CPSDActionBaseComponent *TransparencyStopObject;

  v3 = operator new(88, 0x10B1C40B59DE747);
  v4 = (CPSDOSTypeList *)v3;
  *(_DWORD *)(v3 + 16) = 0;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_QWORD *)v3 = &off_1E41A9038;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_DWORD *)(v3 + 60) = 1331849827;
  v5 = *(_QWORD *)(a2 + 120) - *(_QWORD *)(a2 + 112);
  if (v5)
  {
    v6 = 0;
    v7 = v5 >> 4;
    if (v7 <= 1)
      v8 = 1;
    else
      v8 = v7;
    do
    {
      v9 = *(_QWORD *)(a2 + 112) + v6;
      v10 = *(double *)v9;
      TransparencyStopObject = CPSDObjectEffectsLayerInfo::MakeTransparencyStopObject((CPSDObjectEffectsLayerInfo *)v3, *(_DWORD *)(v9 + 8), *(_DWORD *)(v9 + 12), v10);
      CPSDOSTypeList::AdoptItem(v4, TransparencyStopObject);
      v6 += 16;
      --v8;
    }
    while (v8);
  }
  return v4;
}

CPSDActionKeyedItem *CPSDObjectEffectsLayerInfo::MakeGradientDescriptor(uint64_t a1, uint64_t a2)
{
  CPSDActionDescriptor *v3;
  CPSDActionKeyedItem *v4;
  CPSDOSTypeText *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CPSDActionBaseComponent *ColorStopList;
  uint64_t v11;
  CPSDActionBaseComponent *TransparencyStopList;
  CPSDActionKeyedItem *v13;
  _BYTE v15[88];
  _BYTE v16[88];
  _BYTE v17[88];
  _BYTE v18[88];

  v3 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
  CPSDActionDescriptor::CPSDActionDescriptor(v3, "Gradient", 1198679150);
  v4 = (CPSDActionKeyedItem *)operator new(88, 0x10B1C40DEC6B036);
  v5 = (CPSDOSTypeText *)operator new(72, 0x10B1C4015F6298ELL);
  CPSDOSTypeText::CPSDOSTypeText(v5, "Custom");
  CPSDActionKeyedItem::CPSDActionKeyedItem(v4, 1315774496, v5);
  CPSDActionDescriptor::AdoptItem(v3, v4);
  v6 = operator new(96, 0x10B1C4065EDEABDLL);
  *(_DWORD *)(v6 + 16) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_QWORD *)v6 = &off_1E41A9898;
  *(_QWORD *)(v6 + 56) = 0;
  *(_QWORD *)(v6 + 88) = 0;
  *(_DWORD *)(v6 + 64) = 1198679110;
  *(_DWORD *)(v6 + 80) = 1131639891;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v18, 1198679110, (CPSDActionBaseComponent *)v6);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v18);
  v7 = operator new(64, 0x10B1C40507B098BLL);
  v8 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(v7 + 16) = 0;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_QWORD *)v7 = &off_1E41A91C0;
  *(_QWORD *)(v7 + 56) = v8;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v17, 1231975538, (CPSDActionBaseComponent *)v7);
  v9 = CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v17);
  ColorStopList = CPSDObjectEffectsLayerInfo::MakeColorStopList(v9, a2);
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v16, 1131180659, ColorStopList);
  v11 = CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v16);
  TransparencyStopList = CPSDObjectEffectsLayerInfo::MakeTransparencyStopList(v11, a2);
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v15, 1416785523, TransparencyStopList);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v15);
  v13 = (CPSDActionKeyedItem *)operator new(88, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::CPSDActionKeyedItem(v13, 1198678372, v3);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v15);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v16);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v17);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v18);
  return v13;
}

void sub_19EC1B7B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;
  uint64_t v32;

  MEMORY[0x1A1AEEB08](v31, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a9);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a20);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a31);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v32 - 136));
  _Unwind_Resume(a1);
}

void CPSDActionDescriptor::CPSDActionDescriptor(CPSDActionDescriptor *this, const char *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  CPSDActionDescriptor::CPSDActionDescriptor(this);
  *(_DWORD *)(v6 + 84) = a3;
  CPSDString::CPSDString((CPSDString *)&v7, a2);
  CPSDString::operator=((CPSDActionDescriptor *)((char *)this + 56), (uint64_t)&v7);
  if (v8)
    MEMORY[0x1A1AEEAF0](v8, 0x1000C80BDFB0063);
}

void sub_19EC1B8F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  CPSDActionDescriptor *v10;

  if (a10)
    MEMORY[0x1A1AEEAF0](a10, 0x1000C80BDFB0063);
  CPSDActionDescriptor::~CPSDActionDescriptor(v10);
  _Unwind_Resume(a1);
}

void CPSDOSTypeText::CPSDOSTypeText(CPSDOSTypeText *this, const char *a2)
{
  uint64_t v4;
  uint64_t v5;

  CPSDOSTypeText::CPSDOSTypeText(this);
  CPSDString::CPSDString((CPSDString *)&v4, a2);
  CPSDString::operator=((CPSDOSTypeText *)((char *)this + 56), (uint64_t)&v4);
  if (v5)
    MEMORY[0x1A1AEEAF0](v5, 0x1000C80BDFB0063);
}

void sub_19EC1B994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  CPSDOSTypeText *v10;

  if (a10)
    MEMORY[0x1A1AEEAF0](a10, 0x1000C80BDFB0063);
  CPSDOSTypeText::~CPSDOSTypeText(v10);
  _Unwind_Resume(a1);
}

CPSDActionDescriptor *CPSDObjectEffectsLayerInfo::MakeGradientOverlayObject(uint64_t a1, uint64_t a2)
{
  CPSDActionDescriptor *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CPSDActionKeyedItem *GradientDescriptor;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  CPSDObjectEffectsLayerInfo *v20;
  CPSDActionKeyedItem *OffsetItem;
  _BYTE v23[88];
  _BYTE v24[88];
  _BYTE v25[88];
  _BYTE v26[88];
  _BYTE v27[88];
  _BYTE v28[88];
  _BYTE v29[88];
  _BYTE v30[88];
  _BYTE v31[88];

  v3 = (CPSDActionDescriptor *)operator new(120, 0x10B1C4022C5DBF1);
  CPSDActionDescriptor::CPSDActionDescriptor(v3);
  *((_DWORD *)v3 + 21) = 1198671468;
  v4 = operator new(64, 0x10B1C40B4161B10);
  *(_DWORD *)(v4 + 16) = 0;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_QWORD *)v4 = &off_1E41A9390;
  *(_BYTE *)(v4 + 56) = 1;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v31, 1701732706, (CPSDActionBaseComponent *)v4);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v31);
  v5 = operator new(96, 0x10B1C4065EDEABDLL);
  *(_DWORD *)(v5 + 16) = 0;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_QWORD *)v5 = &off_1E41A9898;
  *(_QWORD *)(v5 + 56) = 0;
  *(_QWORD *)(v5 + 88) = 0;
  *(_DWORD *)(v5 + 64) = 1114402381;
  *(_DWORD *)(v5 + 80) = 1316121964;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v30, 1298407456, (CPSDActionBaseComponent *)v5);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v30);
  v6 = operator new(72, 0x10B1C403C8C186CLL);
  *(_DWORD *)(v6 + 16) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_QWORD *)v6 = &off_1E41A96A8;
  *(_DWORD *)(v6 + 56) = 592474723;
  *(_QWORD *)(v6 + 64) = 0x4059000000000000;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v29, 1332765556, (CPSDActionBaseComponent *)v6);
  v7 = CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v29);
  GradientDescriptor = CPSDObjectEffectsLayerInfo::MakeGradientDescriptor(v7, a2);
  CPSDActionDescriptor::AdoptItem(v3, GradientDescriptor);
  v9 = operator new(72, 0x10B1C403C8C186CLL);
  v10 = *(_QWORD *)a2;
  *(_DWORD *)(v9 + 16) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_QWORD *)v9 = &off_1E41A96A8;
  *(_DWORD *)(v9 + 56) = 591490663;
  *(_QWORD *)(v9 + 64) = v10;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v28, 1097754476, (CPSDActionBaseComponent *)v9);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v28);
  v11 = operator new(96, 0x10B1C4065EDEABDLL);
  v12 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v11 + 16) = 0;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_QWORD *)v11 = &off_1E41A9898;
  *(_QWORD *)(v11 + 56) = 0;
  *(_QWORD *)(v11 + 88) = 0;
  *(_DWORD *)(v11 + 64) = 1198679124;
  *(_DWORD *)(v11 + 80) = v12;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v27, 1417244773, (CPSDActionBaseComponent *)v11);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v27);
  v13 = operator new(64, 0x10B1C40B4161B10);
  v14 = *(_BYTE *)(a2 + 16);
  *(_DWORD *)(v13 + 16) = 0;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_QWORD *)v13 = &off_1E41A9390;
  *(_BYTE *)(v13 + 56) = v14;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v26, 1383494259, (CPSDActionBaseComponent *)v13);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v26);
  v15 = operator new(64, 0x10B1C40B4161B10);
  v16 = *(_BYTE *)(a2 + 17);
  *(_DWORD *)(v15 + 16) = 0;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_QWORD *)v15 = &off_1E41A9390;
  *(_BYTE *)(v15 + 56) = v16;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v25, 1148479602, (CPSDActionBaseComponent *)v15);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v25);
  v17 = operator new(64, 0x10B1C40B4161B10);
  v18 = *(_BYTE *)(a2 + 18);
  *(_DWORD *)(v17 + 16) = 0;
  *(_OWORD *)(v17 + 24) = 0u;
  *(_OWORD *)(v17 + 40) = 0u;
  *(_QWORD *)v17 = &off_1E41A9390;
  *(_BYTE *)(v17 + 56) = v18;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v24, 1097623406, (CPSDActionBaseComponent *)v17);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v24);
  v19 = operator new(72, 0x10B1C403C8C186CLL);
  *(_DWORD *)(v19 + 16) = 0;
  *(_OWORD *)(v19 + 24) = 0u;
  *(_OWORD *)(v19 + 40) = 0u;
  *(_QWORD *)v19 = &off_1E41A96A8;
  *(_DWORD *)(v19 + 56) = 592474723;
  *(_QWORD *)(v19 + 64) = 0x4059000000000000;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v23, 1399024672, (CPSDActionBaseComponent *)v19);
  v20 = (CPSDObjectEffectsLayerInfo *)CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v23);
  OffsetItem = CPSDObjectEffectsLayerInfo::MakeOffsetItem(v20, 0.0, 0.0);
  CPSDActionDescriptor::AdoptItem(v3, OffsetItem);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v23);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v24);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v25);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v26);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v27);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v28);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v29);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v30);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v31);
  return v3;
}

void sub_19EC1BE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a65;
  uint64_t v65;

  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a10);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a21);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a32);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a43);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a54);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a65);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&STACK[0x218]);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v65 - 240));
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v65 - 152));
  _Unwind_Resume(a1);
}

uint64_t CPSDObjectEffectsLayerInfo::Load(CPSDObjectEffectsLayerInfo *this, uint64_t a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 120, 4uLL, &v5);
  *((_DWORD *)this + 30) = bswap32(*((_DWORD *)this + 30));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 124, 4uLL, &v5);
  *((_DWORD *)this + 31) = bswap32(*((_DWORD *)this + 31));
  CPSDActionDescriptor::Load(this, a2);
  return 1;
}

uint64_t CPSDObjectEffectsLayerInfo::Save(CPSDObjectEffectsLayerInfo *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 30));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 31));
  return CPSDActionDescriptor::Save(this, a2);
}

size_t CPSDObjectEffectsLayerInfo::Dump(CPSDObjectEffectsLayerInfo *this, __sFILE *a2)
{
  double Scale;
  uint64_t ItemForKeyString;
  const char *v6;
  unsigned int v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int BlendModeForEffect;
  int IsEnabledForEffect;
  const char *v13;
  double OpacityForEffect;
  unsigned __int16 v15;
  uint64_t v16;
  CPSDDropShadowDescriptor *v17;
  unsigned int BlendMode;
  int v19;
  const char *v20;
  double Opacity;
  unsigned int v23;
  unsigned int v24;

  fprintf(a2, "{ ObjectEffectsLayerInfo: objectEffectsVersion=%d, descriptorVersion=%d\n", *((_DWORD *)this + 30), *((_DWORD *)this + 31));
  Scale = CPSDGradientDescriptor::GetScale(this);
  fprintf(a2, "\tScale: %.0f%%\n", Scale * 100.0);
  ItemForKeyString = CPSDActionDescriptor::GetItemForKeyString(this, "masterFXSwitch");
  if (ItemForKeyString && *(_BYTE *)(ItemForKeyString + 56))
    v6 = "YES";
  else
    v6 = "NO";
  fprintf(a2, "\tMasterFXSwitch: %s\n", v6);
  fwrite("\tEffects:\n", 0xAuLL, 1uLL, a2);
  v7 = *((_DWORD *)this + 22);
  if (v7)
  {
    v8 = 0;
    v9 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v9 + 88 * v8 + 60) != 1198671468)
    {
      if (v7 <= ++v8)
        goto LABEL_14;
    }
    v10 = *(_QWORD *)(v9 + 88 * v8 + 80);
    if (v10)
    {
      fwrite("\t\tGradient Overlay", 0x12uLL, 1uLL, a2);
      BlendModeForEffect = CPSDObjectEffectsLayerInfo::GetBlendModeForEffect((uint64_t)this, 1198671468);
      IsEnabledForEffect = CPSDObjectEffectsLayerInfo::GetIsEnabledForEffect((uint64_t)this, 1198671468);
      v13 = "YES";
      if (!IsEnabledForEffect)
        v13 = "NO";
      fprintf(a2, " <isEnabled: %s>\n", v13);
      v24 = bswap32(BlendModeForEffect);
      OpacityForEffect = CPSDObjectEffectsLayerInfo::GetOpacityForEffect((uint64_t)this, 1198671468);
      fprintf(a2, "\t\t\tBlend Mode: '%.4s'\n\t\t\tOpacity: %.0f%%\n", (const char *)&v24, OpacityForEffect);
      (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(_QWORD *)v10 + 48))(v10, a2, 3);
      v7 = *((_DWORD *)this + 22);
      if (!v7)
        return fwrite("} // End ObjectEffectsLayerInfo\n", 0x20uLL, 1uLL, a2);
    }
LABEL_14:
    v15 = 0;
    v16 = *((_QWORD *)this + 12);
    while (*(_DWORD *)(v16 + 88 * v15 + 60) != 1148343144)
    {
      if (v7 <= ++v15)
        return fwrite("} // End ObjectEffectsLayerInfo\n", 0x20uLL, 1uLL, a2);
    }
    v17 = *(CPSDDropShadowDescriptor **)(v16 + 88 * v15 + 80);
    if (v17)
    {
      fwrite("\t\tDrop Shadow", 0xDuLL, 1uLL, a2);
      BlendMode = CPSDDropShadowDescriptor::GetBlendMode(v17);
      v19 = CPSDObjectEffectsLayerInfo::GetIsEnabledForEffect((uint64_t)this, 1148343144);
      v20 = "YES";
      if (!v19)
        v20 = "NO";
      fprintf(a2, " <isEnabled: %s>\n", v20);
      v23 = bswap32(BlendMode);
      Opacity = CPSDDropShadowDescriptor::GetOpacity(v17);
      fprintf(a2, "\t\t\tBlend Mode: '%.4s'\n\t\t\tOpacity: %.0f%%\n", (const char *)&v23, Opacity);
      (*(void (**)(CPSDDropShadowDescriptor *, __sFILE *, uint64_t))(*(_QWORD *)v17 + 56))(v17, a2, 3);
    }
  }
  return fwrite("} // End ObjectEffectsLayerInfo\n", 0x20uLL, 1uLL, a2);
}

uint64_t CPSDObjectEffectsLayerInfo::GetMasterEffectsSwitch(CPSDObjectEffectsLayerInfo *this)
{
  uint64_t result;

  result = CPSDActionDescriptor::GetItemForKeyString(this, "masterFXSwitch");
  if (result)
    return *(unsigned __int8 *)(result + 56);
  return result;
}

uint64_t CPSDObjectEffectsLayerInfo::GetIsEnabledForEffect(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned __int16 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v9;

  v2 = *(_DWORD *)(a1 + 88);
  if (!v2)
    return 0;
  v3 = 0;
  v4 = *(_QWORD *)(a1 + 96);
  while (*(_DWORD *)(v4 + 88 * v3 + 60) != a2)
  {
    if (v2 <= ++v3)
      return 0;
  }
  v5 = *(_QWORD *)(v4 + 88 * v3 + 80);
  if (!v5)
    return 0;
  v6 = *(_QWORD *)(v5 + 96);
  if (*(_DWORD *)(v6 + 60) == 1701732706)
  {
    v7 = 0;
  }
  else
  {
    v9 = 0;
    do
      v7 = (unsigned __int16)++v9;
    while (*(_DWORD *)(v6 + 88 * (unsigned __int16)v9 + 60) != 1701732706);
  }
  return *(unsigned __int8 *)(*(_QWORD *)(v6 + 88 * v7 + 80) + 56);
}

uint64_t CPSDUnicodeLayerName::Load(CPSDUnicodeLayerName *this, int a2)
{
  _DWORD *v4;
  unsigned int v5;
  uint64_t result;
  unint64_t v7;
  _WORD *v8;
  unsigned int v9;

  v9 = 0;
  v4 = (_DWORD *)((char *)this + 56);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v9);
  v5 = bswap32(*((_DWORD *)this + 14));
  *((_DWORD *)this + 14) = v5;
  result = (uint64_t)malloc_type_calloc(v5 + 1, 2uLL, 0x1000040BDFB0063uLL);
  *((_QWORD *)this + 8) = result;
  if (result)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)result, (2 * *v4), &v9);
    if (v9 >= 2)
    {
      v7 = (unint64_t)v9 >> 1;
      v8 = (_WORD *)*((_QWORD *)this + 8);
      do
      {
        *v8 = bswap32((unsigned __int16)*v8) >> 16;
        ++v8;
        --v7;
      }
      while (v7);
    }
    return 1;
  }
  return result;
}

uint64_t CPSDUnicodeLayerName::Load(CPSDUnicodeLayerName *this, int a2, int a3)
{
  uint64_t result;
  unint64_t v6;
  _WORD *v7;
  unsigned int v8;

  *((_DWORD *)this + 14) = a3;
  result = (uint64_t)malloc_type_calloc((a3 + 1), 2uLL, 0x1000040BDFB0063uLL);
  *((_QWORD *)this + 8) = result;
  if (result)
  {
    v8 = 0;
    fprintf(__stderrp, "length of unicode string: %d\n", *((_DWORD *)this + 14));
    CPSDBaseComponent::ReadFile(a2, *((char **)this + 8), (2 * *((_DWORD *)this + 14)), &v8);
    if (v8 >= 2)
    {
      v6 = (unint64_t)v8 >> 1;
      v7 = (_WORD *)*((_QWORD *)this + 8);
      do
      {
        *v7 = bswap32((unsigned __int16)*v7) >> 16;
        ++v7;
        --v6;
      }
      while (v6);
    }
    return 1;
  }
  return result;
}

uint64_t CPSDUnicodeLayerName::Save(CPSDUnicodeLayerName *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  return (*(uint64_t (**)(File *, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *((_QWORD *)this + 8), *((unsigned int *)this + 14));
}

void CPSDUnicodeLayerName::~CPSDUnicodeLayerName(CPSDUnicodeLayerName *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E41A98E0;
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
    free(v2);
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  CPSDUnicodeLayerName::~CPSDUnicodeLayerName(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(CPSDAdditionalLayerInfoItem *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A9FB0;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(_QWORD *)this = &unk_1E41A9250;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
}

{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDSectionDivider::Load(CPSDSectionDivider *this, int a2)
{
  int v5;

  v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v5);
  *((_DWORD *)this + 14) = bswap32(*((_DWORD *)this + 14));
  if (*((_DWORD *)this + 4) >= 0xCu)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 60, 4uLL, &v5);
    *((_DWORD *)this + 15) = bswap32(*((_DWORD *)this + 15));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 64, 4uLL, &v5);
    *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
  }
  return 1;
}

uint64_t CPSDSectionDivider::Save(CPSDSectionDivider *this, File *a2)
{
  uint64_t result;

  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  result = (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 4) >= 0xCu)
  {
    (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 15));
    return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 16));
  }
  return result;
}

uint64_t CPSDFillOpacityObject::Load(CPSDFillOpacityObject *this, int a2)
{
  int v3;

  v3 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 1uLL, &v3);
  return 1;
}

uint64_t CPSDFillOpacityObject::Save(CPSDFillOpacityObject *this, File *a2)
{
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 11));
  (*(void (**)(File *, _QWORD))(*(_QWORD *)a2 + 80))(a2, *((unsigned int *)this + 4));
  return (*(uint64_t (**)(File *, _QWORD))(*(_QWORD *)a2 + 64))(a2, *((unsigned __int8 *)this + 56));
}

uint64_t CPSDBaseComponent::Dump(CPSDBaseComponent *this, __sFILE *a2)
{
  return fputs("Dump: BaseComponent\n", a2);
}

uint64_t CPSDChannelImage::GetComponentChannels(CPSDChannelImage *this)
{
  return *((unsigned __int16 *)this + 12);
}

uint64_t CPSDChannelImage::GetChannelImageWidth(CPSDChannelImage *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t CPSDChannelImage::GetChannelImageHeight(CPSDChannelImage *this)
{
  return *((unsigned int *)this + 3);
}

void CPSDLayerImage::~CPSDLayerImage(CPSDLayerImage *this)
{
  *(_QWORD *)this = off_1E41A9168;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
}

{
  *(_QWORD *)this = off_1E41A9168;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDLayerSliceImage::~CPSDLayerSliceImage(CPSDLayerSliceImage *this)
{
  *(_QWORD *)this = off_1E41A9168;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
}

{
  *(_QWORD *)this = off_1E41A9168;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  JUMPOUT(0x1A1AEEB08);
}

size_t CPSDLayerSliceImage::Dump(CPSDLayerSliceImage *this, __sFILE *__stream)
{
  return fwrite("LayerSliceImage ", 0x10uLL, 1uLL, __stream);
}

void CPSDCompositeImage::~CPSDCompositeImage(CPSDCompositeImage *this)
{
  *(_QWORD *)this = off_1E41A9168;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
}

{
  *(_QWORD *)this = off_1E41A9168;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDCompositeImage::FillChannelBuffers(CPSDCompositeImage *this)
{
  return 1;
}

void CPSDHeader::~CPSDHeader(CPSDHeader *this)
{
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDImageResourceBlock::Load(CPSDImageResourceBlock *this)
{
  return 1;
}

void CPSDDummyResourceItem::~CPSDDummyResourceItem(CPSDDummyResourceItem *this)
{
  CPSDDummyResourceItem::~CPSDDummyResourceItem(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A9968;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    MEMORY[0x1A1AEEAF0](v2, 0x1000C8077774924);
  *(_QWORD *)this = &unk_1E41A9250;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
}

void CPSDICCProfileResourceItem::~CPSDICCProfileResourceItem(CPSDICCProfileResourceItem *this)
{
  CPSDICCProfileResourceItem::~CPSDICCProfileResourceItem(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  void *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A9F10;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
    free(v2);
  *(_QWORD *)this = &unk_1E41A9250;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
}

uint64_t CPSDICCProfileResourceItem::GetProfileSize(CPSDICCProfileResourceItem *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t CPSDICCProfileResourceItem::GetProfile(CPSDICCProfileResourceItem *this)
{
  return *((_QWORD *)this + 6);
}

void CPSDICCUntaggedResourceItem::~CPSDICCUntaggedResourceItem(CPSDICCUntaggedResourceItem *this)
{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDICCUntaggedResourceItem::GetUntagged(CPSDICCUntaggedResourceItem *this)
{
  return *((unsigned __int8 *)this + 48);
}

void CPSDGlobalAngleResourceItem::~CPSDGlobalAngleResourceItem(CPSDGlobalAngleResourceItem *this)
{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDGlobalAngleResourceItem::GetGlobalAngle(CPSDGlobalAngleResourceItem *this)
{
  return *((unsigned int *)this + 12);
}

void CPSDGlobalAltitudeResourceItem::~CPSDGlobalAltitudeResourceItem(CPSDGlobalAltitudeResourceItem *this)
{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDGlobalAltitudeResourceItem::GetGlobalAltitude(CPSDGlobalAltitudeResourceItem *this)
{
  return *((unsigned int *)this + 12);
}

void CPSDSliceResource::~CPSDSliceResource(CPSDSliceResource *this)
{
  CPSDSliceResource::~CPSDSliceResource(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_1E41A9420;
  v2 = *((_QWORD *)this + 19);
  if (v2)
  {
    MEMORY[0x1A1AEEAF0](v2, 0x1000C80BDFB0063);
    *((_QWORD *)this + 19) = 0;
  }
  v3 = *((_QWORD *)this + 16);
  if (v3)
  {
    MEMORY[0x1A1AEEAF0](v3, 0x1000C80BDFB0063);
    *((_QWORD *)this + 16) = 0;
  }
  v4 = *((_QWORD *)this + 14);
  if (v4)
  {
    MEMORY[0x1A1AEEAF0](v4, 0x1000C80BDFB0063);
    *((_QWORD *)this + 14) = 0;
  }
  v5 = *((_QWORD *)this + 12);
  if (v5)
  {
    MEMORY[0x1A1AEEAF0](v5, 0x1000C80BDFB0063);
    *((_QWORD *)this + 12) = 0;
  }
  v6 = *((_QWORD *)this + 10);
  if (v6)
  {
    MEMORY[0x1A1AEEAF0](v6, 0x1000C80BDFB0063);
    *((_QWORD *)this + 10) = 0;
  }
  v7 = *((_QWORD *)this + 5);
  if (v7)
  {
    MEMORY[0x1A1AEEAF0](v7, 0x1000C80BDFB0063);
    *((_QWORD *)this + 5) = 0;
  }
}

uint64_t CPSDSliceResource::Load(CPSDSliceResource *this)
{
  return 0;
}

void CPSDUnicodeChannelNames::~CPSDUnicodeChannelNames(CPSDUnicodeChannelNames *this)
{
  CPSDUnicodeChannelNames::~CPSDUnicodeChannelNames(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E41A9D90;
  v3 = (void **)((char *)this + 48);
  std::vector<CPSDString>::__destroy_vector::operator()[abi:ne180100](&v3);
  *(_QWORD *)this = &unk_1E41A9250;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    MEMORY[0x1A1AEEAF0](v2, 0x1000C8077774924);
}

void CPSDPathDataRecord::~CPSDPathDataRecord(CPSDPathDataRecord *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDSubpathLengthRecord::~CPSDSubpathLengthRecord(CPSDSubpathLengthRecord *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDBezierKnotRecord::~CPSDBezierKnotRecord(CPSDBezierKnotRecord *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDClipboardRecord::~CPSDClipboardRecord(CPSDClipboardRecord *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDInitialFillRecord::~CPSDInitialFillRecord(CPSDInitialFillRecord *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDPathResource::~CPSDPathResource(CPSDPathResource *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E41A9208;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x20C8093837F09);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E41A9208;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x20C8093837F09);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDPathResource::Load(CPSDPathResource *this)
{
  return 1;
}

uint64_t CPSDPathResource::Dump(CPSDPathResource *this, __sFILE *a2)
{
  return (*(uint64_t (**)(CPSDPathResource *, __sFILE *, _QWORD))(*(_QWORD *)this + 48))(this, a2, 0);
}

uint64_t CPSDResourceItem::Load(CPSDResourceItem *this)
{
  return 1;
}

void CPSDXMPResourceItem::~CPSDXMPResourceItem(CPSDXMPResourceItem *this)
{
  CPSDXMPResourceItem::~CPSDXMPResourceItem(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A96F0;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    MEMORY[0x1A1AEEAF0](v2, 0x1000C8077774924);
  *(_QWORD *)this = &unk_1E41A9250;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
}

void CPSDChannelLengthInfo::~CPSDChannelLengthInfo(CPSDChannelLengthInfo *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDLayerMaskData::~CPSDLayerMaskData(CPSDLayerMaskData *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDVectorMaskData::~CPSDVectorMaskData(CPSDVectorMaskData *this)
{
  *(_QWORD *)this = &off_1E41A9580;
  CPSDPathsResourceItem::~CPSDPathsResourceItem((CPSDVectorMaskData *)((char *)this + 56));
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  *(_QWORD *)this = &off_1E41A9580;
  CPSDPathsResourceItem::~CPSDPathsResourceItem((CPSDVectorMaskData *)((char *)this + 56));
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDChannelBlendingInfo::~CPSDChannelBlendingInfo(CPSDChannelBlendingInfo *this)
{
  JUMPOUT(0x1A1AEEB08);
}

void CPSDOSTypeInteger::~CPSDOSTypeInteger(CPSDOSTypeInteger *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDOSTypeDouble::~CPSDOSTypeDouble(CPSDOSTypeDouble *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDOSTypeBoolean::~CPSDOSTypeBoolean(CPSDOSTypeBoolean *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDOSTypeUnitFloat::~CPSDOSTypeUnitFloat(CPSDOSTypeUnitFloat *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDOSTypeEnumerated::~CPSDOSTypeEnumerated(CPSDOSTypeEnumerated *this)
{
  CPSDOSTypeEnumerated::~CPSDOSTypeEnumerated(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E41A9898;
  if (*((_DWORD *)this + 14))
  {
    v2 = *((_QWORD *)this + 9);
    if (v2)
      MEMORY[0x1A1AEEAF0](v2, 0x1000C8077774924);
  }
  if (*((_DWORD *)this + 15))
  {
    v3 = *((_QWORD *)this + 11);
    if (v3)
      MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

uint64_t CPSDUnicodeLayerName::Dump(const UniChar **this, __sFILE *a2)
{
  char v5[256];

  CPSDUnicodeLayerName::CopyStringValue(this, v5, 0x100u);
  return fprintf(a2, "{ UnicodeLayerName: %s mUnicodeLayerNameLength=%u }\n", v5, *((_DWORD *)this + 14));
}

void CPSDSectionDivider::~CPSDSectionDivider(CPSDSectionDivider *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDFillOpacityObject::~CPSDFillOpacityObject(CPSDFillOpacityObject *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDDropShadowDescriptor::~CPSDDropShadowDescriptor(CPSDDropShadowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDInnerShadowDescriptor::~CPSDInnerShadowDescriptor(CPSDInnerShadowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDInnerGlowDescriptor::~CPSDInnerGlowDescriptor(CPSDInnerGlowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDOuterGlowDescriptor::~CPSDOuterGlowDescriptor(CPSDOuterGlowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDBevelEmbossDescriptor::~CPSDBevelEmbossDescriptor(CPSDBevelEmbossDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDColorOverlayDescriptor::~CPSDColorOverlayDescriptor(CPSDColorOverlayDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDGradientDescriptor::~CPSDGradientDescriptor(CPSDGradientDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDGradientFillInfo::~CPSDGradientFillInfo(CPSDGradientFillInfo *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDColorFillInfo::~CPSDColorFillInfo(CPSDColorFillInfo *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDChannelData::Load(CPSDChannelData *this)
{
  return 0;
}

uint64_t CPSDChannelData::Dump(CPSDChannelData *this, __sFILE *a2)
{
  return fprintf(a2, "[%d] bytes;", *((_DWORD *)this + 4));
}

void CPSDLayerChannelGroup::~CPSDLayerChannelGroup(CPSDLayerChannelGroup *this)
{
  CPSDLayerChannelGroup::~CPSDLayerChannelGroup(this);
  JUMPOUT(0x1A1AEEB08);
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_1E41A9A28;
  v1 = *((_QWORD *)this + 4);
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = v1 - 56;
      v5 = 56 * v3;
      do
      {
        CPSDChannelData::~CPSDChannelData((CPSDChannelData *)(v4 + v5));
        v5 -= 56;
      }
      while (v5);
    }
    MEMORY[0x1A1AEEAF0](v2, 0x10B1C8014B8BDFCLL);
  }
}

size_t CPSDLayerChannelGroup::Dump(CPSDLayerChannelGroup *this, __sFILE *__stream)
{
  uint64_t v4;
  unint64_t v5;

  fwrite("ChannelData: {", 0xEuLL, 1uLL, __stream);
  if (*((_DWORD *)this + 6))
  {
    v4 = 0;
    v5 = 0;
    do
    {
      fprintf(__stream, "[%d] = ", v5);
      (*(void (**)(uint64_t, __sFILE *))(*(_QWORD *)(*((_QWORD *)this + 4) + v4) + 40))(*((_QWORD *)this + 4) + v4, __stream);
      ++v5;
      v4 += 56;
    }
    while (v5 < *((unsigned int *)this + 6));
  }
  return fwrite("}\n", 2uLL, 1uLL, __stream);
}

void CPSDGlobalLayerMaskInfo::~CPSDGlobalLayerMaskInfo(CPSDGlobalLayerMaskInfo *this)
{
  JUMPOUT(0x1A1AEEB08);
}

uint64_t CPSDGlobalLayerMaskInfo::Load(CPSDGlobalLayerMaskInfo *this, int a2)
{
  CPSDGlobalLayerMaskInfo::Load(this, a2, 0);
  return 1;
}

uint64_t CPSDPathsResourceItem::Dump(CPSDPathsResourceItem *this, __sFILE *a2)
{
  return (*(uint64_t (**)(CPSDPathsResourceItem *, __sFILE *, _QWORD))(*(_QWORD *)this + 48))(this, a2, 0);
}

uint64_t CPSDImageLoad::Dump(CPSDImageLoad *this, __sFILE *a2)
{
  return fprintf(a2, "PSDImageLoad: { %dx%d x %d channels, mode = %d }\n", *((_DWORD *)this + 9), *((_DWORD *)this + 10), *((unsigned __int16 *)this + 22), *((unsigned __int16 *)this + 29));
}

uint64_t std::vector<CPSDLayerRecord>::__push_back_slow_path<CPSDLayerRecord>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x4FBCDA3AC10C9715 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x864B8A7DE6D1D6)
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x4FBCDA3AC10C9715 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x4325C53EF368EBLL)
    v9 = 0x864B8A7DE6D1D6;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerRecord>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = &v10[488 * v4];
  v16 = &v10[488 * v9];
  CPSDLayerRecord::CPSDLayerRecord((uint64_t)v14, a2);
  v15 = v14 + 488;
  std::vector<CPSDLayerRecord>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_19EC1D598(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerRecord::CPSDLayerRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = &off_1E41A9120;
  *(_QWORD *)(a1 + 8) = v4;
  v5 = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  v6 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = &off_1E41A9350;
  *(_QWORD *)(a1 + 88) = v6;
  v7 = *(_OWORD *)(a2 + 96);
  v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 122) = *(_OWORD *)(a2 + 122);
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 112) = v8;
  v9 = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 144) = off_1E41A9CC0;
  *(_QWORD *)(a1 + 152) = v9;
  v10 = *(_QWORD *)(a2 + 160);
  LODWORD(v9) = *(_DWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 176) = 0;
  v11 = a1 + 176;
  *(_DWORD *)(v11 - 8) = v9;
  *(_QWORD *)(v11 - 16) = v10;
  *(_QWORD *)(v11 + 8) = 0;
  *(_QWORD *)(v11 + 16) = 0;
  std::vector<CPSDChannelBlendingInfo>::__init_with_size[abi:ne180100]<CPSDChannelBlendingInfo*,CPSDChannelBlendingInfo*>((char *)v11, *(_QWORD *)(a2 + 176), *(_QWORD *)(a2 + 184), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 184) - *(_QWORD *)(a2 + 176)) >> 3));
  v12 = *(_OWORD *)(a2 + 200);
  v13 = *(_OWORD *)(a2 + 216);
  v14 = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v14;
  *(_OWORD *)(a1 + 216) = v13;
  *(_OWORD *)(a1 + 200) = v12;
  v15 = *(_OWORD *)(a2 + 264);
  v16 = *(_OWORD *)(a2 + 280);
  v17 = *(_OWORD *)(a2 + 312);
  *(_OWORD *)(a1 + 296) = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 312) = v17;
  *(_OWORD *)(a1 + 264) = v15;
  *(_OWORD *)(a1 + 280) = v16;
  v18 = *(_OWORD *)(a2 + 328);
  v19 = *(_OWORD *)(a2 + 344);
  v20 = *(_OWORD *)(a2 + 376);
  *(_OWORD *)(a1 + 360) = *(_OWORD *)(a2 + 360);
  *(_OWORD *)(a1 + 376) = v20;
  *(_OWORD *)(a1 + 328) = v18;
  *(_OWORD *)(a1 + 344) = v19;
  v21 = *(_OWORD *)(a2 + 392);
  v22 = *(_OWORD *)(a2 + 408);
  v23 = *(_OWORD *)(a2 + 440);
  *(_OWORD *)(a1 + 424) = *(_OWORD *)(a2 + 424);
  *(_OWORD *)(a1 + 440) = v23;
  *(_OWORD *)(a1 + 392) = v21;
  *(_OWORD *)(a1 + 408) = v22;
  *(_QWORD *)(a1 + 456) = &off_1E41A9BB0;
  *(_DWORD *)(a1 + 472) = *(_DWORD *)(a2 + 472);
  *(_DWORD *)(a2 + 472) = 0;
  *(_QWORD *)(a1 + 480) = *(_QWORD *)(a2 + 480);
  *(_QWORD *)(a2 + 480) = 0;
  return a1;
}

void sub_19EC1D710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *std::vector<CPSDChannelBlendingInfo>::__init_with_size[abi:ne180100]<CPSDChannelBlendingInfo*,CPSDChannelBlendingInfo*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  _QWORD *i;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CPSDChannelBlendingInfo>::__vallocate[abi:ne180100](result, a4);
    for (i = (_QWORD *)*((_QWORD *)v6 + 1); a2 != a3; i += 3)
    {
      v8 = *(_QWORD *)(a2 + 8);
      *i = &off_1E41A9BF0;
      i[1] = v8;
      i[2] = *(_QWORD *)(a2 + 16);
      a2 += 24;
    }
    *((_QWORD *)v6 + 1) = i;
  }
  return result;
}

void sub_19EC1D7A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CPSDChannelBlendingInfo>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_19EC1D8A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 24;
      v7 = v4 - 24;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 24;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CPSDLayerRecord>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDLayerRecord>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerRecord>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x864B8A7DE6D1D7)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(488 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDLayerRecord>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v10 = 0;
  v11 = a7 - 488;
  while (a3 + v10 != a5)
  {
    v12 = v11 + v10;
    v10 -= 488;
    CPSDLayerRecord::CPSDLayerRecord(v12, v10 + a3);
  }
  return a6;
}

uint64_t std::__split_buffer<CPSDLayerRecord>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 488;
    (**(void (***)(uint64_t))(i - 488))(i - 488);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<CPSDChannelLengthInfo>::__append(char **a1, unint64_t a2)
{
  uint64_t result;
  char *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v6[-v7] >> 3) >= a2)
  {
    if (a2)
    {
      v13 = v7 + 24 * a2;
      do
      {
        *(_QWORD *)v7 = &off_1E41A9928;
        *(_WORD *)(v7 + 16) = 0;
        *(_DWORD *)(v7 + 20) = 0;
        v7 += 24;
      }
      while (v7 != v13);
      v7 = v13;
    }
    a1[1] = (char *)v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)*a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v28 = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>(result, v11);
    else
      v12 = 0;
    v14 = &v12[24 * v8];
    v15 = &v12[24 * v11];
    v27 = v15;
    v16 = &v14[24 * a2];
    v17 = v14;
    do
    {
      *(_QWORD *)v17 = &off_1E41A9928;
      *((_WORD *)v17 + 8) = 0;
      *((_DWORD *)v17 + 5) = 0;
      v17 += 24;
    }
    while (v17 != v16);
    v26.i64[1] = (uint64_t)&v14[24 * a2];
    v19 = *a1;
    v18 = (unint64_t)a1[1];
    if ((char *)v18 == *a1)
    {
      v23 = vdupq_n_s64(v18);
    }
    else
    {
      v20 = 0;
      do
      {
        v21 = &v14[v20];
        v22 = *(_QWORD *)(v18 + v20 - 16);
        *((_QWORD *)v21 - 3) = &off_1E41A9928;
        *((_QWORD *)v21 - 2) = v22;
        *((_QWORD *)v21 - 1) = *(_QWORD *)(v18 + v20 - 8);
        v20 -= 24;
      }
      while ((char *)(v18 + v20) != v19);
      v23 = *(int64x2_t *)a1;
      v14 += v20;
      v16 = (char *)v26.i64[1];
      v15 = v27;
    }
    *a1 = v14;
    a1[1] = v16;
    v26 = v23;
    v24 = a1[2];
    a1[2] = v15;
    v27 = v24;
    v25 = v23.i64[0];
    return std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer((uint64_t)&v25);
  }
  return result;
}

uint64_t std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 24);
    *(_QWORD *)(a1 + 16) = i - 24;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<CPSDLayerChannelGroup *>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerChannelGroup *>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerChannelGroup *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void CPSDLayerChannelGroup::CPSDLayerChannelGroup(CPSDLayerChannelGroup *this, CPSDLayerRecord *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  *(_QWORD *)this = &off_1E41A9A28;
  *((_QWORD *)this + 2) = a2;
  v3 = *((unsigned __int16 *)a2 + 16);
  *((_DWORD *)this + 6) = v3;
  v4 = (_QWORD *)operator new[](56 * v3 + 16, 0x10B1C8014B8BDFCLL);
  *v4 = 56;
  v4[1] = v3;
  v5 = v4 + 2;
  if (v3)
  {
    v6 = v4 + 2;
    do
    {
      *v6 = &off_1E41A90C8;
      v6[2] = 0;
      *((_WORD *)v6 + 12) = 0;
      v6[4] = 0;
      v6[5] = 0;
      *((_DWORD *)v6 + 12) = 0;
      v6 += 7;
    }
    while (v6 != &v5[7 * v3]);
  }
  *((_QWORD *)this + 4) = v5;
}

_QWORD *CPSDLayerRecord::GetFillOpacityObject(CPSDLayerRecord *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 60); i; i = (_QWORD *)i[6])
  {
      break;
  }
  return i;
}

void CPSDResourceItem::~CPSDResourceItem(CPSDResourceItem *this)
{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E41A9250;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x1A1AEEAF0](v1, 0x1000C8077774924);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDSlicesResourceItem::CPSDSlicesResourceItem(CPSDSlicesResourceItem *this, CPSDImageResourceBlock *a2, int a3)
{
  *((_DWORD *)this + 4) = a3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E41A9B70;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = a2;
  *((_DWORD *)this + 16) = 0;
  CPSDString::AllocateCharData((CPSDSlicesResourceItem *)((char *)this + 72), 1u);
  **((_WORD **)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0;
}

void sub_19EC1E04C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &unk_1E41A9250;
  v3 = v1[4];
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void CPSDXMPResourceItem::CPSDXMPResourceItem(CPSDXMPResourceItem *this, CPSDImageResourceBlock *a2, int a3)
{
  *((_DWORD *)this + 4) = a3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = a2;
  *(_QWORD *)this = &off_1E41A96F0;
  *((_QWORD *)this + 6) = operator new[]((a3 + 1), 0x1000C8077774924);
}

void sub_19EC1E0D8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &unk_1E41A9250;
  v3 = v1[4];
  if (v3)
    MEMORY[0x1A1AEEAF0](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *std::vector<CPSDString>::__construct_one_at_end[abi:ne180100]<CPSDString const&>(uint64_t a1, uint64_t a2)
{
  void **v3;
  const void *v4;
  void *result;

  v3 = *(void ***)(a1 + 8);
  v3[1] = 0;
  v4 = *(const void **)(a2 + 8);
  CPSDString::AllocateCharData((CPSDString *)v3, *(_DWORD *)a2);
  result = memcpy(v3[1], v4, (2 * *(_DWORD *)v3));
  *(_QWORD *)(a1 + 8) = v3 + 2;
  return result;
}

void sub_19EC1E168(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<CPSDString>::__push_back_slow_path<CPSDString const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  void **v11;
  const void *v12;
  uint64_t v13;
  _QWORD v15[2];
  void **v16;
  char *v17;
  uint64_t *v18;

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 4;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60)
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 3 > v5)
    v5 = v8 >> 3;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
    v9 = 0xFFFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v18 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDString>>(v7, v9);
  else
    v10 = 0;
  v11 = (void **)&v10[16 * v4];
  v15[0] = v10;
  v15[1] = v11;
  v16 = v11;
  v17 = &v10[16 * v9];
  v11[1] = 0;
  v12 = *(const void **)(a2 + 8);
  CPSDString::AllocateCharData((CPSDString *)v11, *(_DWORD *)a2);
  memcpy(v11[1], v12, (2 * *(_DWORD *)v11));
  v16 += 2;
  std::vector<CPSDString>::__swap_out_circular_buffer(a1, v15);
  v13 = a1[1];
  std::__split_buffer<CPSDString>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_19EC1E268(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CPSDString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CPSDString>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDString>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  const void *v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  v15 = 0;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v10 = *(_DWORD *)(v9 - 16);
      v9 -= 16;
      *(_QWORD *)(v7 - 8) = 0;
      v11 = *(const void **)(v9 + 8);
      CPSDString::AllocateCharData((CPSDString *)(v7 - 16), v10);
      memcpy(*(void **)(v7 - 8), v11, (2 * *(_DWORD *)(v7 - 16)));
      v7 = *((_QWORD *)&v17 + 1) - 16;
      *((_QWORD *)&v17 + 1) -= 16;
    }
    while (v9 != a5);
    v12 = v17;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

void sub_19EC1E3E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>::operator()[abi:ne180100](a1);
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>::operator()[abi:ne180100](uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(result + 8) + 8);
  while (v1 != v2)
  {
    result = *(_QWORD *)(v1 + 8);
    if (result)
    {
      result = MEMORY[0x1A1AEEAF0](result, 0x1000C80BDFB0063);
      *(_QWORD *)(v1 + 8) = 0;
    }
    v1 += 16;
  }
  return result;
}

uint64_t std::__split_buffer<CPSDString>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<CPSDString>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__split_buffer<CPSDString>::__destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 16);
  if (v2 != a2)
  {
    v4 = result;
    do
    {
      *(_QWORD *)(v4 + 16) = v2 - 16;
      result = *(_QWORD *)(v2 - 8);
      if (result)
      {
        result = MEMORY[0x1A1AEEAF0](result, 0x1000C80BDFB0063);
        *(_QWORD *)(v2 - 8) = 0;
        v2 = *(_QWORD *)(v4 + 16);
      }
      else
      {
        v2 -= 16;
      }
    }
    while (v2 != a2);
  }
  return result;
}

void CPSDSliceResource::CPSDSliceResource(CPSDSliceResource *this)
{
  *(_QWORD *)this = &off_1E41A9420;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 32), 1u);
  **((_WORD **)this + 5) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 72), 1u);
  **((_WORD **)this + 10) = 0;
  *((_QWORD *)this + 12) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 88), 1u);
  **((_WORD **)this + 12) = 0;
  *((_QWORD *)this + 14) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 104), 1u);
  **((_WORD **)this + 14) = 0;
  *((_QWORD *)this + 16) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 120), 1u);
  **((_WORD **)this + 16) = 0;
  *((_BYTE *)this + 136) = 0;
  *((_QWORD *)this + 19) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 144), 1u);
  **((_WORD **)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
}

void sub_19EC1E6E0(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = v1[16];
  if (v3)
  {
    MEMORY[0x1A1AEEAF0](v3, 0x1000C80BDFB0063);
    v1[16] = 0;
  }
  v4 = v1[14];
  if (v4)
  {
    MEMORY[0x1A1AEEAF0](v4, 0x1000C80BDFB0063);
    v1[14] = 0;
  }
  v5 = v1[12];
  if (v5)
  {
    MEMORY[0x1A1AEEAF0](v5, 0x1000C80BDFB0063);
    v1[12] = 0;
  }
  v6 = v1[10];
  if (v6)
  {
    MEMORY[0x1A1AEEAF0](v6, 0x1000C80BDFB0063);
    v1[10] = 0;
  }
  v7 = v1[5];
  if (v7)
  {
    MEMORY[0x1A1AEEAF0](v7, 0x1000C80BDFB0063);
    v1[5] = 0;
  }
  _Unwind_Resume(exception_object);
}

void std::vector<CPSDLayerRecord>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  if (a2)
  {
    v4 = v3 + 488 * a2;
    do
    {
      *(_QWORD *)v3 = &off_1E41A9120;
      *(_QWORD *)(v3 + 16) = 0;
      *(_QWORD *)(v3 + 24) = 0;
      *(_WORD *)(v3 + 32) = 0;
      *(_OWORD *)(v3 + 40) = 0u;
      *(_OWORD *)(v3 + 56) = 0u;
      *(_QWORD *)(v3 + 72) = 0;
      *(_QWORD *)(v3 + 80) = &off_1E41A9350;
      *(_QWORD *)(v3 + 104) = 0;
      *(_QWORD *)(v3 + 112) = 0;
      *(_QWORD *)(v3 + 96) = 0;
      *(_QWORD *)(v3 + 144) = off_1E41A9CC0;
      *(_QWORD *)(v3 + 160) = 0;
      *(_DWORD *)(v3 + 168) = 0;
      *(_QWORD *)(v3 + 184) = 0;
      *(_QWORD *)(v3 + 192) = 0;
      *(_QWORD *)(v3 + 176) = 0;
      *(_QWORD *)(v3 + 456) = &off_1E41A9BB0;
      *(_DWORD *)(v3 + 472) = 0;
      *(_QWORD *)(v3 + 480) = 0;
      bzero((void *)(v3 + 200), 0x100uLL);
      v3 += 488;
    }
    while (v3 != v4);
    v3 = v4;
  }
  *(_QWORD *)(a1 + 8) = v3;
}

void std::vector<CPSDLayerRecord>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void (***v2)(_QWORD);
  void (***v4)(_QWORD);
  void *v5;
  void (***v6)(_QWORD);
  BOOL v7;

  v1 = *a1;
  v2 = (void (***)(_QWORD))**a1;
  if (v2)
  {
    v4 = (void (***)(_QWORD))v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 61;
      do
      {
        (**v6)(v6);
        v7 = v6 == v2;
        v6 -= 61;
      }
      while (!v7);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CPSDLayerRecord>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x4FBCDA3AC10C9715 * ((v6 - v7) >> 3) >= a2)
  {
    std::vector<CPSDLayerRecord>::__construct_at_end((uint64_t)a1, a2);
  }
  else
  {
    v8 = 0x4FBCDA3AC10C9715 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x864B8A7DE6D1D6)
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    v10 = 0x4FBCDA3AC10C9715 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x4325C53EF368EBLL)
      v11 = 0x864B8A7DE6D1D6;
    else
      v11 = v9;
    v17 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerRecord>>(v4, v11);
    else
      v12 = 0;
    v13 = v12;
    v14 = &v12[488 * v8];
    v15 = v14;
    v16 = &v12[488 * v11];
    std::__split_buffer<CPSDLayerRecord>::__construct_at_end((uint64_t)&v13, a2);
    std::vector<CPSDLayerRecord>::__swap_out_circular_buffer(a1, &v13);
    std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)&v13);
  }
}

void sub_19EC1EA18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__split_buffer<CPSDLayerRecord>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 16);
  if (a2)
  {
    v4 = v3 + 488 * a2;
    do
    {
      *(_QWORD *)v3 = &off_1E41A9120;
      *(_QWORD *)(v3 + 16) = 0;
      *(_QWORD *)(v3 + 24) = 0;
      *(_WORD *)(v3 + 32) = 0;
      *(_OWORD *)(v3 + 40) = 0u;
      *(_OWORD *)(v3 + 56) = 0u;
      *(_QWORD *)(v3 + 72) = 0;
      *(_QWORD *)(v3 + 80) = &off_1E41A9350;
      *(_QWORD *)(v3 + 104) = 0;
      *(_QWORD *)(v3 + 112) = 0;
      *(_QWORD *)(v3 + 96) = 0;
      *(_QWORD *)(v3 + 144) = off_1E41A9CC0;
      *(_QWORD *)(v3 + 160) = 0;
      *(_DWORD *)(v3 + 168) = 0;
      *(_QWORD *)(v3 + 184) = 0;
      *(_QWORD *)(v3 + 192) = 0;
      *(_QWORD *)(v3 + 176) = 0;
      *(_QWORD *)(v3 + 456) = &off_1E41A9BB0;
      *(_DWORD *)(v3 + 472) = 0;
      *(_QWORD *)(v3 + 480) = 0;
      bzero((void *)(v3 + 200), 0x100uLL);
      v3 += 488;
    }
    while (v3 != v4);
    v3 = v4;
  }
  *(_QWORD *)(a1 + 16) = v3;
}

uint64_t std::vector<CPSDChannelBlendingInfo>::__append(char **a1, unint64_t a2)
{
  uint64_t result;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = &v7[24 * a2];
      do
      {
        *(_QWORD *)v7 = &off_1E41A9BF0;
        *((_QWORD *)v7 + 2) = 0;
        v7 += 24;
      }
      while (v7 != v13);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v28 = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>(result, v11);
    else
      v12 = 0;
    v14 = &v12[24 * v8];
    v15 = &v12[24 * v11];
    v27 = v15;
    v16 = &v14[24 * a2];
    v17 = v14;
    do
    {
      *(_QWORD *)v17 = &off_1E41A9BF0;
      *((_QWORD *)v17 + 2) = 0;
      v17 += 24;
    }
    while (v17 != v16);
    v26.i64[1] = (uint64_t)&v14[24 * a2];
    v19 = *a1;
    v18 = (unint64_t)a1[1];
    if ((char *)v18 == *a1)
    {
      v23 = vdupq_n_s64(v18);
    }
    else
    {
      v20 = 0;
      do
      {
        v21 = &v14[v20];
        v22 = *(_QWORD *)(v18 + v20 - 16);
        *((_QWORD *)v21 - 3) = &off_1E41A9BF0;
        *((_QWORD *)v21 - 2) = v22;
        *((_QWORD *)v21 - 1) = *(_QWORD *)(v18 + v20 - 8);
        v20 -= 24;
      }
      while ((char *)(v18 + v20) != v19);
      v23 = *(int64x2_t *)a1;
      v14 += v20;
      v16 = (char *)v26.i64[1];
      v15 = v27;
    }
    *a1 = v14;
    a1[1] = v16;
    v26 = v23;
    v24 = a1[2];
    a1[2] = v15;
    v27 = v24;
    v25 = v23.i64[0];
    return std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer((uint64_t)&v25);
  }
  return result;
}

void CPSDOSTypeText::CPSDOSTypeText(CPSDOSTypeText *this)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_QWORD *)this = &off_1E41A9080;
  *((_QWORD *)this + 8) = 0;
  CPSDString::AllocateCharData((CPSDOSTypeText *)((char *)this + 56), 1u);
  **((_WORD **)this + 8) = 0;
}

void sub_19EC1ECD8(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem *v1;

  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

void std::vector<CPSDActionKeyedItem>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 88;
      v7 = v4 - 88;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 88;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CPSDActionKeyedItem>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (0x2E8BA2E8BA2E8BA3 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = v7 + 88 * a2;
      v14 = 88 * a2;
      v15 = v7 + 56;
      do
      {
        *(_DWORD *)(v15 - 40) = 0;
        *(_OWORD *)(v15 - 32) = 0uLL;
        *(_OWORD *)(v15 - 16) = 0uLL;
        *(_QWORD *)(v15 - 56) = &off_1E41A95C0;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)v15 = 0;
        *(_QWORD *)(v15 + 8) = 0;
        *(_DWORD *)(v15 + 16) = 0;
        v15 += 88;
        v14 -= 88;
      }
      while (v14);
    }
    else
    {
      v13 = *(_QWORD *)(result - 8);
    }
    a1[1] = v13;
  }
  else
  {
    v8 = 0x2E8BA2E8BA2E8BA3 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2E8BA2E8BA2E8BALL)
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    v10 = 0x2E8BA2E8BA2E8BA3 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1745D1745D1745DLL)
      v11 = 0x2E8BA2E8BA2E8BALL;
    else
      v11 = v9;
    v23 = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDActionKeyedItem>>(result, v11);
    else
      v12 = 0;
    v19 = v12;
    v20 = &v12[88 * v8];
    v22 = &v12[88 * v11];
    v16 = 88 * a2;
    v17 = &v20[88 * a2];
    v18 = v20 + 56;
    do
    {
      *((_DWORD *)v18 - 10) = 0;
      *((_OWORD *)v18 - 2) = 0uLL;
      *((_OWORD *)v18 - 1) = 0uLL;
      *((_QWORD *)v18 - 7) = &off_1E41A95C0;
      *((_QWORD *)v18 + 3) = 0;
      *(_QWORD *)v18 = 0;
      *((_QWORD *)v18 + 1) = 0;
      *((_DWORD *)v18 + 4) = 0;
      v18 += 88;
      v16 -= 88;
    }
    while (v16);
    v21 = v17;
    std::vector<CPSDActionKeyedItem>::__swap_out_circular_buffer(a1, &v19);
    return std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)&v19);
  }
  return result;
}

void sub_19EC1EF0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<CPSDActionKeyedItem>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *result;
  v3 = result[1];
  v4 = a2[1];
  if (v3 != *result)
  {
    do
    {
      *(_QWORD *)(v4 - 88) = &off_1E41A95C0;
      v4 -= 88;
      *(_DWORD *)(v4 + 16) = 0;
      *(_OWORD *)(v4 + 24) = 0uLL;
      *(_OWORD *)(v4 + 40) = 0uLL;
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(v3 - 80);
      v5 = *(_OWORD *)(v3 - 72);
      *(_QWORD *)(v4 + 32) = *(_QWORD *)(v3 - 56);
      *(_OWORD *)(v4 + 16) = v5;
      *(_OWORD *)(v4 + 40) = *(_OWORD *)(v3 - 48);
      v6 = *(_OWORD *)(v3 - 32);
      *(_OWORD *)(v4 + 72) = *(_OWORD *)(v3 - 16);
      *(_OWORD *)(v4 + 56) = v6;
      *(_QWORD *)(v3 - 8) = 0;
      *(_QWORD *)(v3 - 24) = 0;
      v3 -= 88;
    }
    while (v3 != v2);
  }
  a2[1] = v4;
  v7 = *result;
  *result = v4;
  a2[1] = v7;
  v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDActionKeyedItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(88 * a2);
}

uint64_t std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 88);
    *(_QWORD *)(a1 + 16) = i - 88;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<CPSDActionKeyedItem>::__push_back_slow_path<CPSDActionKeyedItem>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  _QWORD v16[5];

  v3 = *a1;
  v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL)
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x1745D1745D1745DLL)
    v9 = 0x2E8BA2E8BA2E8BALL;
  else
    v9 = v5;
  v16[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDActionKeyedItem>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[88 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[88 * v9];
  *((_DWORD *)v11 + 4) = 0;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_QWORD *)v11 = &off_1E41A95C0;
  *((_QWORD *)v11 + 1) = *(_QWORD *)(a2 + 8);
  v12 = *(_OWORD *)(a2 + 16);
  *((_QWORD *)v11 + 4) = *(_QWORD *)(a2 + 32);
  *((_OWORD *)v11 + 1) = v12;
  *(_OWORD *)(v11 + 40) = *(_OWORD *)(a2 + 40);
  v13 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v11 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v11 + 56) = v13;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  v16[2] = v11 + 88;
  std::vector<CPSDActionKeyedItem>::__swap_out_circular_buffer(a1, v16);
  v14 = a1[1];
  std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_19EC1F1B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void CPSDString::CPSDString(CPSDString *this, const char *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  *((_QWORD *)this + 1) = 0;
  CPSDString::AllocateCharData(this, 1u);
  **((_WORD **)this + 1) = 0;
  v4 = strlen(a2) + 1;
  CPSDString::AllocateCharData(this, v4);
  if (v4)
  {
    v5 = 0;
    v6 = *((_QWORD *)this + 1);
    do
    {
      v7 = *a2++;
      *(_BYTE *)(v6 + v5) = v7;
      *(_BYTE *)(v6 + (v5 + 1)) = 0;
      v5 += 2;
    }
    while (2 * v4 != v5);
  }
}

void sub_19EC1F248(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 8);
  if (v3)
  {
    MEMORY[0x1A1AEEAF0](v3, 0x1000C80BDFB0063);
    *(_QWORD *)(v1 + 8) = 0;
  }
  _Unwind_Resume(exception_object);
}

CPSDString *CPSDString::operator=(CPSDString *this, uint64_t a2)
{
  uint64_t v4;
  const void *v5;

  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    MEMORY[0x1A1AEEAF0](v4, 0x1000C80BDFB0063);
    *((_QWORD *)this + 1) = 0;
  }
  v5 = *(const void **)(a2 + 8);
  CPSDString::AllocateCharData(this, *(_DWORD *)a2);
  memcpy(*((void **)this + 1), v5, (2 * *(_DWORD *)this));
  return this;
}

void std::vector<CPSDString>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<CPSDString>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

uint64_t std::vector<CPSDString>::__base_destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;

  v3 = result;
  for (i = *(_QWORD *)(result + 8); i != a2; i -= 16)
  {
    result = *(_QWORD *)(i - 8);
    if (result)
    {
      result = MEMORY[0x1A1AEEAF0](result, 0x1000C80BDFB0063);
      *(_QWORD *)(i - 8) = 0;
    }
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void CPSDUnicodeLayerName::CopyStringValue(const UniChar **this, char *a2, unsigned int a3)
{
  const __CFString *v5;
  CFStringEncoding SystemEncoding;

  v5 = CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, this[8], *((unsigned int *)this + 14), kCFAllocatorNull);
  SystemEncoding = CFStringGetSystemEncoding();
  CFStringGetCString(v5, a2, a3, SystemEncoding);
  CFRelease(v5);
}

__CFData *__CUIImageCompressedWithDeepmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  __CFData *Mutable;
  const char *v14;
  uint64_t v16;
  UInt8 bytes[4];
  int v18;
  CFIndex v19;
  UInt8 *v20;
  uint64_t v21;
  int v22;

  v4 = a2;
  v20 = 0;
  v21 = a3;
  v22 = a4;
  v5 = vImageDeepmapEncodeCreateBuffer(a1, a2, &v21, &v20);
  if (!v5)
  {
    v14 = "CoreUI: DeepmapEncodeImageCreateBuffer() returned 0.";
LABEL_8:
    _CUILog(4, (uint64_t)v14, v6, v7, v8, v9, v10, v11, v16);
    return 0;
  }
  v12 = v5;
  if (!v20)
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "CFDataRef __CUIImageCompressedWithDeepmap(vImage_Buffer, vImageDeepmapPixelFormat, vImageDeepmapCompressionOptions)"), CFSTR("CUIDeepmapCompression.m"), 124, CFSTR("Expects non-null pointer."));
  if ((v21 - 1) >= 4)
  {
    v16 = v21;
    v14 = "CoreUI: vImageDeepmapEncodeCreateBuffer() returned unrecognized compression method: %lu [%s]";
    goto LABEL_8;
  }
  *(_DWORD *)bytes = 5;
  v18 = v4;
  v19 = v12;
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, v12 + 16);
  CFDataAppendBytes(Mutable, bytes, 16);
  CFDataAppendBytes(Mutable, v20, v12);
  free(v20);
  return Mutable;
}

id CUIImageCompressedWithDeepmap(unsigned int *a1, __int128 *a2, uint64_t a3, _DWORD *a4, __int16 *a5, _QWORD *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v11;
  __int16 v12;
  id v13;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __CFData *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __CFData *v28;
  unint64_t v29;
  __int128 v30;
  __CFData *v31;
  __CFData *v32;
  __int128 v33;
  __int128 v34;

  if (*(_QWORD *)a2 && *((_QWORD *)a2 + 3) && (v9 = *((_QWORD *)a2 + 2)) != 0 && *((_QWORD *)a2 + 1))
  {
    if (*a1 == 8 || *a1 == 16)
    {
      if (*((_QWORD *)a1 + 1))
      {
        if ((int)a3 > 1195456543)
        {
          if ((_DWORD)a3 == 1195456544)
          {
            v12 = 2;
            v11 = 2;
          }
          else
          {
            if ((_DWORD)a3 != 1380401751)
            {
LABEL_35:
              _CUILog(4, (uint64_t)"CoreUI: Unrecognized input pixel format: %d [%s]", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, a3);
              return 0;
            }
            v11 = 20;
            v12 = 4;
          }
        }
        else
        {
          if ((_DWORD)a3 != 1095911234)
          {
            if ((_DWORD)a3 == 1195454774)
            {
              v11 = 18;
              v12 = 6;
              goto LABEL_22;
            }
            goto LABEL_35;
          }
          v11 = 4;
          v12 = 1;
        }
LABEL_22:
        *a4 = a3;
        *a5 = v12;
        *a6 = CGBitmapGetAlignedBytesPerRow(v9 * ((unint64_t)a1[1] >> 3));
        v13 = objc_alloc_init((Class)NSMutableArray);
        v15 = *((_QWORD *)a2 + 1);
        if (v15 * *((_QWORD *)a2 + 3) < 0x5000)
        {
          v30 = a2[1];
          v33 = *a2;
          v34 = v30;
          v31 = __CUIImageCompressedWithDeepmap((uint64_t)&v33, v11, 0x100000000, 10);
          if (!v31)
          {
LABEL_36:
            _CUILog(4, (uint64_t)"CoreUI: Deepmap compressed failed in %s [%s:%lu]", v22, v23, v24, v25, v26, v27, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");

            return 0;
          }
          v32 = v31;
          objc_msgSend(v13, "addObject:", v31);
          CFRelease(v32);
          v29 = *((_QWORD *)a2 + 1);
        }
        else
        {
          v16 = (v15 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64;
          v17 = (v15 / 3);
          if (!(v15 / 3))
            CUIImageCompressedWithDeepmap_cold_1();
          if (v15)
          {
            v18 = *(_QWORD *)a2;
            do
            {
              v19 = v15 >= v17 ? v17 : v15;
              *(_QWORD *)a2 = v18;
              *((_QWORD *)a2 + 1) = v19;
              v20 = a2[1];
              v33 = *a2;
              v34 = v20;
              v21 = __CUIImageCompressedWithDeepmap((uint64_t)&v33, v11, 0x100000000, 10);
              if (!v21)
                goto LABEL_36;
              v28 = v21;
              objc_msgSend(v13, "addObject:", v21);
              CFRelease(v28);
              v18 += *((_QWORD *)a2 + 3) * v19;
              v15 -= v19;
            }
            while (v15);
          }
          v29 = v16 >> 1;
        }
        *a7 = v29;
        return v13;
      }
      _CUILog(4, (uint64_t)"CoreUI: Missing image color space to perform Deemap compression [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: unsupported bpc for Deepmap compression: %d [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, *a1);
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: invalid input image buffer in %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
  }
  return 0;
}

uint64_t CUIUncompressDeepmapImageData(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int *v12;
  int v13;
  uint64_t v14;
  id v15;
  unsigned int *v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  id v21;
  char *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  _BOOL4 v34;
  int v35;
  _QWORD block[5];
  _QWORD v39[12];
  unsigned int v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  char v44;

  if (!a1)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL buffer in [%s]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  if (!a4)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL destination in [%s]", a3, 0, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  v10 = a3;
  v12 = a1;
  if ((int)a8 > 1195456543)
  {
    if ((_DWORD)a8 != 1195456544)
    {
      v13 = 1380401751;
      goto LABEL_10;
    }
  }
  else if ((_DWORD)a8 != 1095911234)
  {
    v13 = 1195454774;
LABEL_10:
    if ((_DWORD)a8 == v13)
      goto LABEL_11;
    _CUILog(4, (uint64_t)"CoreUI: %s got unsupported pixel format [%d]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
LABEL_11:
  v41 = 0;
  v42 = &v41;
  v43 = 0x2020000000;
  v44 = 1;
  if ((_DWORD)a3)
  {
    v14 = a1[3];
    a2 = a1[4];
    v34 = *a1 == 1262699075;
    v15 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", a3);
    v16 = v12;
    v12 += 5;
  }
  else
  {
    v34 = 0;
    v15 = 0;
    v16 = 0;
    v14 = a6;
  }
  v17 = 0;
  v18 = 0;
  if (v10 <= 1)
    v19 = 1;
  else
    v19 = v10;
  v35 = v19 - 1;
  do
  {
    if (v10)
    {
      if (v17 >= v10)
        -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)"), CFSTR("CUIDeepmapCompression.m"), 358, CFSTR("Invalid chunk index"));
      if (!v16 || v14 - 1 >= a6)
      {
        _CUILog(4, (uint64_t)"CoreUI: Invalid chunk rows of %lu in image of height %lu", a3, a4, a5, a6, a7, a8, v14);
        if (!v15)
          goto LABEL_43;
        goto LABEL_42;
      }
    }
    if (*v12 >= 6)
    {
      _CUILog(4, (uint64_t)"CoreUI: Encoded Deepmap blob version %lu greater than decoder version %lu", a3, a4, a5, a6, a7, a8, *v12);
      *((_BYTE *)v42 + 24) = 0;
      if (!v15)
        goto LABEL_43;
LABEL_42:

      goto LABEL_43;
    }
    v20 = v12[1];
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 3221225472;
    v39[2] = __CUIUncompressDeepmapImageData_block_invoke;
    v39[3] = &unk_1E41AB178;
    v39[6] = v14;
    v39[7] = a7;
    v39[8] = a4;
    v39[9] = v18;
    v39[10] = v12;
    v39[11] = v12;
    v40 = v20;
    v39[4] = &v41;
    v39[5] = a5;
    if (!v10)
    {
      __CUIUncompressDeepmapImageData_block_invoke((uint64_t)v39);
      goto LABEL_38;
    }
    if (!v15)
      v15 = objc_alloc_init((Class)NSMutableArray);
    v21 = objc_msgSend(v39, "copy");
    objc_msgSend(v15, "addObject:", v21);

    if (v35 == v17)
      break;
    v22 = (char *)v16 + a2;
    v16 = (unsigned int *)((char *)v16 + a2 + 20);
    v23 = *((_DWORD *)v22 + 8);
    if (v34)
    {
      v23 = bswap32(v23);
      v24 = bswap32(v16[4]);
    }
    else
    {
      v24 = v16[4];
    }
    v18 += v14;
    v14 = v23;
    a2 = v24;
    v12 = v16 + 5;
    ++v17;
  }
  while (v18 < a6);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __CUIUncompressDeepmapImageData_block_invoke_2;
  block[3] = &unk_1E41AB150;
  block[4] = v15;
  dispatch_apply((size_t)objc_msgSend(v15, "count"), 0, block);

LABEL_38:
  if (*((_BYTE *)v42 + 24))
  {
    v31 = 1;
    goto LABEL_44;
  }
  _CUILog(4, (uint64_t)"CoreUI: CUIUncompressDeepmapImageData() fails.", v25, v26, v27, v28, v29, v30, v33);
LABEL_43:
  v31 = 0;
LABEL_44:
  _Block_object_dispose(&v41, 8);
  return v31;
}

void sub_19EC20224(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

Class initMDLMeshBufferMap()
{
  id v0;
  Class result;
  const char *v2;
  const char *v3;
  const char *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  char __str[1024];
  _QWORD v10[3];

  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
  v0 = objc_msgSend((id)__NSGetFrameworkReference_table_0, "objectForKey:", CFSTR("ModelIO"));
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
  if (!v0)
  {
    memset(v10, 0, sizeof(v10));
    v2 = (const char *)objc_msgSend(CFSTR("ModelIO"), "UTF8String");
    if (v2)
    {
      v3 = v2;
      v4 = "/System/Library/Frameworks/";
      v5 = 1;
      while (1)
      {
        if (snprintf(__str, 0x400uLL, "%s%s.framework/%s", v4, v3, v3) <= 1023)
        {
          v6 = dlopen(__str, 2);
          if (v6)
            break;
        }
        v4 = (const char *)v10[v5++];
        if (!v4)
          goto LABEL_2;
      }
      v7 = v6;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
      v8 = (id)__NSGetFrameworkReference_table_0;
      if (!__NSGetFrameworkReference_table_0)
      {
        v8 = objc_msgSend(objc_alloc((Class)NSMapTable), "initWithKeyOptions:valueOptions:capacity:", 0, 2, 0);
        __NSGetFrameworkReference_table_0 = (uint64_t)v8;
      }
      if (!objc_msgSend(v8, "objectForKey:", CFSTR("ModelIO")))
        objc_msgSend((id)__NSGetFrameworkReference_table_0, "setObject:forKey:", v7, CFSTR("ModelIO"));
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
    }
  }
LABEL_2:
  result = objc_getClass("MDLMeshBufferMap");
  classMDLMeshBufferMap = (uint64_t)result;
  if (!result)
    initMDLMeshBufferMap_cold_1();
  getMDLMeshBufferMapClass[0] = MDLMeshBufferMapFunction;
  return result;
}

uint64_t MDLMeshBufferMapFunction()
{
  return classMDLMeshBufferMap;
}

void CPSDMeshedARGBStream::CPSDMeshedARGBStream(CPSDMeshedARGBStream *this, CPSDChannelImage *a2)
{
  unsigned int v2;
  uint64_t *v3;
  int v4;
  uint64_t v5;
  uint64_t *v6;

  v2 = (*((_DWORD *)a2 + 2) * *((unsigned __int16 *)a2 + 8) + 7) >> 3;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 5) = v2;
  *((_DWORD *)this + 6) = 0;
  *(_QWORD *)this = &off_1E41A9860;
  *((_QWORD *)this + 1) = a2;
  v3 = (uint64_t *)*((_QWORD *)a2 + 6);
  v4 = *((unsigned __int8 *)a2 + 28);
  *((_BYTE *)this + 64) = *((_BYTE *)a2 + 28) != 0;
  if (v4)
  {
    v5 = *v3++;
    v6 = (uint64_t *)((char *)this + 40);
    *((_QWORD *)this + 4) = v5;
  }
  else
  {
    v6 = (uint64_t *)((char *)this + 32);
  }
  *v6 = *v3;
  v6[1] = v3[1];
  v6[2] = v3[2];
}

uint64_t CPSDMeshedARGBStream::convert(uint64_t this, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  unsigned __int8 *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;

  v2 = (*(_DWORD *)(this + 24) * *(_DWORD *)(this + 16));
  v3 = *(_QWORD *)(this + 8);
  if (*(_BYTE *)(this + 64))
  {
    v4 = (uint64_t *)(this + 40);
    v5 = (unsigned __int8 *)(*(_QWORD *)(this + 32) + v2);
  }
  else
  {
    v5 = 0;
    v4 = (uint64_t *)(this + 32);
  }
  if (*(_DWORD *)(v3 + 8))
  {
    v6 = 0;
    v7 = *(unsigned __int16 *)(v3 + 18);
    v9 = v4[1];
    v8 = v4[2];
    v10 = *v4;
    v11 = (v7 >> 3);
    do
    {
      if (*(_BYTE *)(this + 64))
      {
        *a2 = *v5;
        a2 += v11;
        v5 += v11;
      }
      *a2 = *(_BYTE *)(v10 + v2);
      a2[v11] = *(_BYTE *)(v9 + v2);
      v12 = &a2[v11 + v11];
      *v12 = *(_BYTE *)(v8 + v2);
      a2 = &v12[v11];
      ++v6;
      v2 += v11;
    }
    while (v6 < *(unsigned int *)(*(_QWORD *)(this + 8) + 8));
  }
  return this;
}

unint64_t CPSDMeshedARGBStream::GetBytes(CPSDMeshedARGBStream *this, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unsigned int v13;
  uint64_t v14;

  if (a3 % *((unsigned int *)this + 5))
  {
    _CUILog(1, (uint64_t)"ERROR (CPSDMeshedARGBStream): count is not a multiple of bytesPerRow.", a3, a4, a5, a6, a7, a8, v14);
    return 0;
  }
  if (!a3)
    return 0;
  v8 = 0;
  v13 = *((_DWORD *)this + 6);
  do
  {
    if (v13 >= *(_DWORD *)(*((_QWORD *)this + 1) + 12))
      break;
    (*(void (**)(CPSDMeshedARGBStream *, char *))(*(_QWORD *)this + 24))(this, &a2[v8]);
    v8 += *((unsigned int *)this + 5);
    v13 = *((_DWORD *)this + 6) + 1;
    *((_DWORD *)this + 6) = v13;
  }
  while (v8 < a3);
  return v8;
}

uint64_t CPSDMeshedARGBStream::SkipBytes(CPSDMeshedARGBStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t vars0;

  v8 = *((unsigned int *)this + 5);
  if (a2 % v8)
  {
    _CUILog(1, (uint64_t)"ERROR (CPSDMeshedARGBStream): count is not a multiple of bytesPerRow.", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
  else
  {
    v9 = *((_DWORD *)this + 6) + a2 / v8;
    if (v9 >= *(_DWORD *)(*((_QWORD *)this + 1) + 12))
      v9 = *(_DWORD *)(*((_QWORD *)this + 1) + 12);
    *((_DWORD *)this + 6) = v9;
  }
  return a2;
}

CGImageRef CPSDMeshedARGBStream::CreateCGImageRef(CPSDMeshedARGBStream *this)
{
  uint64_t v1;
  int v2;
  BOOL v3;
  CGBitmapInfo v5;
  CGColorSpace *v6;
  CGColorSpace *SRGB;
  CGDataProvider *Sequential;
  CGImageRef v10;

  v1 = *((_QWORD *)this + 1);
  if (*(_WORD *)(v1 + 26) != 3)
    return 0;
  v2 = *(unsigned __int16 *)(v1 + 18);
  v3 = v2 == 16 || v2 == 8;
  if (!v3 || *(unsigned __int16 *)(v1 + 24) < 3u || !*(_DWORD *)(v1 + 8) || !*(_DWORD *)(v1 + 12))
    return 0;
  v5 = 4 * (*(_BYTE *)(v1 + 28) != 0);
  v6 = (CGColorSpace *)(*(uint64_t (**)(CPSDMeshedARGBStream *))(*(_QWORD *)this + 32))(this);
  if (v6)
  {
    SRGB = v6;
    CFAutorelease(v6);
  }
  else
  {
    SRGB = (CGColorSpace *)_CUIColorSpaceGetSRGB();
  }
  Sequential = CGDataProviderCreateSequential(this, &psdStreamCallbacks);
  v10 = CGImageCreate(*(unsigned int *)(*((_QWORD *)this + 1) + 8), *(unsigned int *)(*((_QWORD *)this + 1) + 12), *(unsigned __int16 *)(*((_QWORD *)this + 1) + 18), *(unsigned __int16 *)(*((_QWORD *)this + 1) + 16), *((unsigned int *)this + 5), SRGB, v5, Sequential, 0, 0, kCGRenderingIntentDefault);
  CGDataProviderRelease(Sequential);
  return v10;
}

CGColorSpaceRef CPSDMeshedARGBStream::GetColorSpace(CPSDMeshedARGBStream *this)
{
  uint64_t v1;
  CFIndex v2;
  const UInt8 *v3;
  size_t v4;
  const __CFData *v6;
  CGDataProvider *v7;
  CGColorSpaceRef ICCBased;

  v1 = *((_QWORD *)this + 1);
  v2 = *(unsigned int *)(v1 + 32);
  if (!(_DWORD)v2)
    return 0;
  v3 = *(const UInt8 **)(v1 + 40);
  if (!v3)
    return 0;
  v4 = *(unsigned __int16 *)(v1 + 26);
  if ((_DWORD)v4 != 1)
  {
    if ((_DWORD)v4 == 4)
    {
      v4 = 4;
    }
    else if ((_DWORD)v4 == 3)
    {
      v4 = 3;
    }
    else
    {
      v4 = *(unsigned __int16 *)(v1 + 24);
    }
  }
  v6 = CFDataCreate(kCFAllocatorDefault, v3, v2);
  v7 = CGDataProviderCreateWithCFData(v6);
  ICCBased = CGColorSpaceCreateICCBased(v4, 0, v7, 0);
  CGDataProviderRelease(v7);
  CFRelease(v6);
  return ICCBased;
}

void CPSDAlphaChannelStream::CPSDAlphaChannelStream(CPSDAlphaChannelStream *this, CPSDChannelImage *a2, uint64_t a3)
{
  unsigned int v3;

  v3 = (*((_DWORD *)a2 + 2) * *((unsigned __int16 *)a2 + 8) + 7) >> 3;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 5) = v3;
  *((_DWORD *)this + 6) = 0;
  *(_QWORD *)this = &off_1E41A9AB0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 4) = *(_QWORD *)(*((_QWORD *)a2 + 6) + 8 * a3);
  *((_DWORD *)this + 10) = a3;
  *((_DWORD *)this + 4) = ((*(unsigned int (**)(CPSDChannelImage *, uint64_t))(*(_QWORD *)a2 + 40))(a2, a3)
                         * *((unsigned __int16 *)a2 + 9)) >> 3;
}

void sub_19EC20F3C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = off_1E41A9290;
  v3 = v1[1];
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

CGImageRef CPSDAlphaChannelStream::CreateCGImageRef(CPSDAlphaChannelStream *this)
{
  _WORD *v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v8;
  CGDataProvider *v9;
  size_t v10;
  CGImageRef v11;
  __int128 v12;

  v12 = xmmword_19EC72B00;
  v2 = (_WORD *)*((_QWORD *)this + 1);
  if (v2[13] != 3 || v2[9] != 8 || (unsigned __int16)v2[12] < 4u)
    return 0;
  v3 = (*(uint64_t (**)(_WORD *, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((unsigned int *)this + 10));
  v4 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1), *((unsigned int *)this + 10));
  if (!v3 || v4 == 0)
    return 0;
  v8 = v4;
  LODWORD(v5) = *((_DWORD *)this + 4);
  v9 = CGDataProviderCreateWithData(this, *((const void **)this + 4), (unint64_t)((double)v4 * (double)v5), (CGDataProviderReleaseDataCallback)alphaStreamReleaseData);
  v10 = *(unsigned __int16 *)(*((_QWORD *)this + 1) + 18);
  v11 = CGImageMaskCreate(v3, v8, v10, v10, *((unsigned int *)this + 4), v9, (const CGFloat *)&v12, 0);
  CGDataProviderRelease(v9);
  return v11;
}

uint64_t alphaStreamReleaseData(uint64_t result, const void *a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void CPSDMeshedARGBStream::~CPSDMeshedARGBStream(CPSDMeshedARGBStream *this)
{
  uint64_t v1;

  *(_QWORD *)this = off_1E41A9290;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = off_1E41A9290;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x1A1AEEB08);
}

void CPSDAlphaChannelStream::~CPSDAlphaChannelStream(CPSDAlphaChannelStream *this)
{
  uint64_t v1;

  *(_QWORD *)this = off_1E41A9290;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = off_1E41A9290;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x1A1AEEB08);
}

uint64_t psdRewind(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t psdRelease(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

double CUIEdgeInsetsInsetRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8;
  double v9;
  double v10;

  v8 = a1 + a6;
  v9 = a3 - (a8 + a6);
  v10 = v9 * 0.5;
  if (v9 > 0.0)
    v10 = -0.0;
  return v8 + v10;
}

double CUIEdgeInsetsOutsetRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8;
  double v9;
  double v10;

  v8 = a1 - a6;
  v9 = a3 - (-a6 - a8);
  v10 = v9 * 0.5;
  if (v9 > 0.0)
    v10 = -0.0;
  return v8 + v10;
}

double CUIEdgeInsetsMake(double a1, double a2, double a3, double a4)
{
  return a4;
}

double CUIEdgeInsetsToCGRect(double a1, double a2)
{
  return a2;
}

double CUIEdgeInsetsFromCGRect(double a1, double a2, double a3, double a4)
{
  return a4;
}

BOOL CUIEdgeInsetsEqualToEdgeInsets(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  return a2 == a6 && a3 == a7 && a4 == a8 && a1 == a5;
}

BOOL CUIEdgeInsetsValid(double a1, double a2, double a3, double a4)
{
  return a2 != -INFINITY || a3 != INFINITY || a4 != INFINITY || a1 != -INFINITY;
}

void sub_19EC249D4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19EC24AB0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19EC24CD4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19EC24D5C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19EC24E18(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19EC24F68(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double CUIGetSVGAttributeUnitScale(uint64_t a1)
{
  void *v1;
  double v2;

  if (!a1)
    return 1.0;
  v1 = (void *)CGSVGAttributeCopyString(a1);
  if ((objc_msgSend(v1, "hasSuffix:", CFSTR("mm")) & 1) != 0)
  {
    v2 = 2.83464567;
  }
  else if ((objc_msgSend(v1, "hasSuffix:", CFSTR("cm")) & 1) != 0)
  {
    v2 = 28.3464567;
  }
  else if (objc_msgSend(v1, "hasSuffix:", CFSTR("in")))
  {
    v2 = 72.0;
  }
  else
  {
    v2 = 1.0;
  }

  return v2;
}

uint64_t CUIAccumulateSVGShapesIntoJoinedPath(uint64_t a1, __int128 *a2, uint64_t a3)
{
  __int128 v3;
  _QWORD v5[4];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = __CUIAccumulateSVGShapesIntoJoinedPath_block_invoke;
  v5[3] = &__block_descriptor_88_e27_v28__0__CGSVGNode__8i16_B20l;
  v3 = a2[1];
  v6 = *a2;
  v7 = v3;
  v8 = a2[2];
  v9 = a3;
  return CGSVGNodeEnumerate(a1, v5);
}

CGAffineTransform *CUISVGNodeGetTransform@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  CGAffineTransform *result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v9;

  v5 = *(_OWORD *)&CGAffineTransformIdentity.c;
  v6 = *(_OWORD *)&CGAffineTransformIdentity.a;
  *(_OWORD *)a2 = *(_OWORD *)&CGAffineTransformIdentity.a;
  *(_OWORD *)(a2 + 16) = v5;
  v4 = *(_OWORD *)&CGAffineTransformIdentity.tx;
  *(_OWORD *)(a2 + 32) = v4;
  result = (CGAffineTransform *)CGSVGNodeFindAttribute(a1, 63);
  if (result)
  {
    result = (CGAffineTransform *)CGSVGAttributeGetFloats(result, &v9);
    if ((_DWORD)result)
    {
      *(_OWORD *)&t1.a = v6;
      *(_OWORD *)&t1.c = v5;
      *(_OWORD *)&t1.tx = v4;
      t2 = v9;
      return CGAffineTransformConcat((CGAffineTransform *)a2, &t1, &t2);
    }
  }
  return result;
}

CGMutablePathRef CUICreateJoinedPathFromSVGNode(uint64_t a1, __int128 *a2)
{
  CGMutablePathRef Mutable;
  __int128 v5;
  _QWORD v7[4];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  CGMutablePathRef v11;

  Mutable = CGPathCreateMutable();
  v5 = a2[1];
  v8 = *a2;
  v9 = v5;
  v10 = a2[2];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = __CUIAccumulateSVGShapesIntoJoinedPath_block_invoke;
  v7[3] = &__block_descriptor_88_e27_v28__0__CGSVGNode__8i16_B20l;
  v11 = Mutable;
  CGSVGNodeEnumerate(a1, v7);
  return Mutable;
}

NSMutableData *CUICreateClipStrokeKeyframeDataFromString(void *a1, float a2)
{
  id v3;
  NSMutableData *result;
  unint64_t v5;
  NSMutableData *v6;
  unint64_t i;
  unsigned int v8;
  int v9;
  float v10;
  float v11;
  uint64_t v12;
  int v13;
  unsigned int v14;

  v3 = objc_msgSend(a1, "componentsSeparatedByString:", CFSTR(" "));
  result = (NSMutableData *)objc_msgSend(v3, "count");
  if (result)
  {
    v5 = (unint64_t)result;
    if (objc_msgSend(objc_msgSend(v3, "firstObject"), "integerValue") || (((_BYTE)v5 - 1) & 3) != 0)
    {
      return 0;
    }
    else
    {
      v6 = +[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", v5 - 4);
      if (v5 >= 2)
      {
        for (i = 1; i < v5; i += 4)
        {
          v14 = 0;
          v8 = objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i), "integerValue");
          v13 = 0;
          v14 = v8;
          objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i + 1), "floatValue");
          v13 = v9;
          HIDWORD(v12) = 0;
          objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i + 2), "floatValue");
          *((float *)&v12 + 1) = v10 + a2;
          LODWORD(v12) = 0;
          objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i + 3, v12), "floatValue");
          *(float *)&v12 = v11 + a2;
          -[NSMutableData appendBytes:length:](v6, "appendBytes:length:", &v14, 4, v12);
          -[NSMutableData appendBytes:length:](v6, "appendBytes:length:", &v13, 4);
          -[NSMutableData appendBytes:length:](v6, "appendBytes:length:", (char *)&v12 + 4, 4);
          -[NSMutableData appendBytes:length:](v6, "appendBytes:length:", &v12, 4);
        }
      }
      return v6;
    }
  }
  return result;
}

uint64_t CUICreateClipStrokeKeyframeDataFromNode(uint64_t a1, float a2)
{
  uint64_t AttributeMap;
  uint64_t result;
  void *v5;
  NSMutableData *v6;

  AttributeMap = CGSVGNodeGetAttributeMap(a1);
  if (CUIVectorGlyphClipStrokeKeyframesAtom_onceToken != -1)
    dispatch_once(&CUIVectorGlyphClipStrokeKeyframesAtom_onceToken, &__block_literal_global_5);
  result = CGSVGAttributeMapGetAttribute(AttributeMap, CUIVectorGlyphClipStrokeKeyframesAtom_atom);
  if (result)
  {
    v5 = (void *)CGSVGAttributeCopyString();
    v6 = CUICreateClipStrokeKeyframeDataFromString(v5, a2);

    return (uint64_t)v6;
  }
  return result;
}

id CUIStringFromClipStrokeKeyframeData(void *a1)
{
  id v2;
  id v3;
  unint64_t v4;
  unint64_t i;
  uint64_t v7;
  uint64_t v8;

  if (!a1)
    return 0;
  v2 = objc_msgSend(a1, "length");
  v3 = 0;
  if (v2)
  {
    v4 = (unint64_t)v2;
    if ((v2 & 0xF) == 0)
    {
      v3 = +[NSMutableString string](NSMutableString, "string");
      objc_msgSend(v3, "appendString:", CFSTR("0"));
      for (i = 0; i < v4; i += 16)
      {
        v7 = 0;
        v8 = 0;
        objc_msgSend(a1, "getBytes:range:", (char *)&v8 + 4, i, 4);
        objc_msgSend(a1, "getBytes:range:", &v8, i + 4, 4);
        objc_msgSend(a1, "getBytes:range:", (char *)&v7 + 4, i + 8, 4);
        objc_msgSend(a1, "getBytes:range:", &v7, i + 12, 4);
        objc_msgSend(v3, "appendString:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR(" %u %f %f %f"), HIDWORD(v8), *(float *)&v8, *((float *)&v7 + 1), *(float *)&v7));
      }
    }
  }
  return v3;
}

id CUIAddClipStrokeKeyframeDataToNode(uint64_t a1, void *a2)
{
  id result;
  id v4;
  uint64_t v5;

  result = CUIStringFromClipStrokeKeyframeData(a2);
  if (result)
  {
    v4 = result;
    if (CUIVectorGlyphClipStrokeKeyframesAtom_onceToken != -1)
      dispatch_once(&CUIVectorGlyphClipStrokeKeyframesAtom_onceToken, &__block_literal_global_5);
    v5 = CGSVGAttributeCreateWithString(CUIVectorGlyphClipStrokeKeyframesAtom_atom, v4);
    CGSVGNodeSetAttribute(a1, v5);
    return (id)CGSVGAttributeRelease(v5);
  }
  return result;
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

id CUICreatePathFromSVGShapeNode(uint64_t a1, const CGAffineTransform *a2)
{
  int Primitive;
  const CGPath *CGPath;
  CGPath *Mutable;
  int v7;
  uint64_t FloatCount;
  unint64_t v9;
  CGFloat *v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  id v14;

  if (CGSVGNodeGetType(a1) != 2)
    return 0;
  Primitive = CGSVGShapeNodeGetPrimitive(a1);
  if (Primitive != 42)
  {
    v7 = Primitive;
    if ((Primitive & 0xFFFFFFFE) != 0x2C)
      return 0;
    FloatCount = CGSVGShapeNodeGetFloatCount(a1);
    if (!FloatCount)
      return 0;
    v9 = FloatCount;
    v10 = (CGFloat *)malloc_type_malloc(8 * FloatCount, 0x100004000313F17uLL);
    CGSVGShapeNodeGetFloats(a1, v10);
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, a2, *v10, v10[1]);
    if (v9 >= 3)
    {
      v11 = 0;
      do
      {
        CGPathAddLineToPoint(Mutable, a2, v10[v11 + 2], v10[v11 + 3]);
        v12 = v11 + 4;
        v11 += 2;
      }
      while (v12 < v9);
    }
    if (v7 == 44)
      CGPathCloseSubpath(Mutable);
    free(v10);
    if (!Mutable)
      return 0;
LABEL_14:
    v13 = (void *)CUICreateClipStrokeKeyframeDataFromNode(a1, 0.0);
    v14 = +[CUIVectorGlyphPath createWithPath:clipStrokeKeyframes:](CUIVectorGlyphPath, "createWithPath:clipStrokeKeyframes:", Mutable, v13);
    CGPathRelease(Mutable);

    return v14;
  }
  if (CGSVGShapeNodeGetPath(a1))
  {
    CGPath = (const CGPath *)CGSVGPathCreateCGPath();
    Mutable = (CGPath *)MEMORY[0x1A1AEE52C](CGPath, a2);
    CGPathRelease(CGPath);
    if (Mutable)
      goto LABEL_14;
  }
  return 0;
}

void CUIAddPathToSVGShapeNode(uint64_t a1, void *a2)
{
  const void *v4;

  v4 = (const void *)CGSVGPathCreateWithCGPath(objc_msgSend(a2, "path"));
  CGSVGShapeNodeSetPath(a1, v4);
  CUIAddClipStrokeKeyframeDataToNode(a1, objc_msgSend(a2, "clipStrokeKeyframes"));
  CFRelease(v4);
}

id CUICreateSubpathArrayFromCGPath(const CGPath *a1)
{
  id v2;
  _QWORD v4[6];
  _QWORD v5[4];

  if (!a1)
    return 0;
  v2 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 0);
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2020000000;
  v5[3] = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = __CUICreateSubpathArrayFromCGPath_block_invoke;
  v4[3] = &unk_1E41AB618;
  v4[4] = v2;
  v4[5] = v5;
  CGPathApplyWithBlock(a1, v4);
  _Block_object_dispose(v5, 8);
  return v2;
}

void sub_19EC25C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id CUICreateSubpathsFromSVGNode(id result)
{
  id v1;
  id v2;

  if (result)
  {
    v1 = CUICreatePathFromSVGNode(result, (__int128 *)&CGAffineTransformIdentity);
    v2 = objc_msgSend(v1, "createSubpaths");

    return v2;
  }
  return result;
}

vImage_Error CUIComputeImageColorHistogramARGB(CGImage *a1, const vImage_Buffer *a2, vImagePixelCount *a3)
{
  vImagePixelCount *histogram[4];

  histogram[0] = a3;
  histogram[1] = a3 + 1024;
  histogram[2] = a3 + 2048;
  histogram[3] = a3 + 3072;
  if (CGImageGetBitsPerComponent(a1) < 9)
    return vImageHistogramCalculation_ARGB8888(a2, histogram, 0x100u);
  else
    return vImageHistogramCalculation_ARGBFFFF(a2, histogram, 0x400u, 0.0, 1.0, 0x100u);
}

BOOL CUIColorHistogramARGBIsMonochrome(uint64_t a1)
{
  return !memcmp((const void *)(a1 + 0x2000), (const void *)(a1 + 0x4000), 0x2000uLL)
      && memcmp((const void *)(a1 + 0x4000), (const void *)(a1 + 24576), 0x2000uLL) == 0;
}

double CUIColorHistogramARGBIntersection(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int64x2_t v3;
  int64x2_t v4;
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v2 = 0;
  v3 = 0uLL;
  v4 = 0uLL;
  v5 = 0uLL;
  do
  {
    v6 = *(int64x2_t *)(a1 + v2 + 0x2000);
    v7 = *(int64x2_t *)(a2 + v2 + 0x2000);
    v8 = *(int64x2_t *)(a1 + v2 + 0x4000);
    v9 = *(int64x2_t *)(a2 + v2 + 0x4000);
    v10 = *(int64x2_t *)(a1 + v2 + 24576);
    v11 = *(int64x2_t *)(a2 + v2 + 24576);
    v5 = vaddq_s64(vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v7, (uint64x2_t)v6), (int8x16_t)v6, (int8x16_t)v7), v5), vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v9, (uint64x2_t)v8), (int8x16_t)v8, (int8x16_t)v9), (int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v11, (uint64x2_t)v10), (int8x16_t)v10, (int8x16_t)v11)));
    v4 = vaddq_s64(vaddq_s64(v6, v4), vaddq_s64(v8, v10));
    v3 = vaddq_s64(vaddq_s64(v7, v3), vaddq_s64(v9, v11));
    v2 += 16;
  }
  while (v2 != 0x2000);
  v12 = vaddvq_s64(v5);
  v13 = vaddvq_s64(v4);
  v14 = vaddvq_s64(v3);
  if (v13 >= v14)
    v15 = v14;
  else
    v15 = v13;
  return (double)v12 / (double)v15;
}

id CUIStartFocusRingInternal()
{
  return +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
}

void DrawThemeImageWithOperation(void *a1, CGContextRef c, CGBlendMode a3, int a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9)
{
  double v18;
  CGImage *v19;
  CGRect v20;

  CGContextSaveGState(c);
  if (a4)
    +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
  if (a3)
    CGContextSetBlendMode(c, a3);
  v18 = fabs(a9);
  if (v18 != 1.0)
    CGContextSetAlpha(c, v18);
  v19 = (CGImage *)objc_msgSend(a1, "image");
  if (v19)
  {
    v20.origin.x = a5;
    v20.origin.y = a6;
    v20.size.width = a7;
    v20.size.height = a8;
    CGContextDrawImage(c, v20, v19);
  }
  if (a4)
    +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
  CGContextRestoreGState(c);
}

void DrawOnePartElementFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12, int a13, void *a14)
{
  id v26;
  double v27;
  double v28;
  unsigned int v29;
  id v30;
  void *v31;
  CGBlendMode v32;
  double v33;
  double v34;
  CGFloat v35;
  CGFloat v36;
  CGContext *v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  NSRect v43;
  NSRect v44;

  if (!objc_msgSend(a8, "isTiled"))
  {
    v29 = objc_msgSend(a8, "isScaled");
    v30 = objc_msgSend(a8, "imageForSliceIndex:", a13);
    v31 = v30;
    if (v29)
    {
      if (a5 >= 0.0)
        v32 = a12;
      else
        v32 = kCGBlendModeSourceAtop;
      v33 = a1;
      v34 = a2;
      v35 = a3;
      v36 = a4;
      v37 = a9;
      v38 = a5;
    }
    else
    {
      objc_msgSend(a8, "scale");
      v40 = v39;
      v44.origin.x = a1;
      v44.origin.y = a2;
      v44.size.width = a3;
      v44.size.height = a4;
      if (NSIsEmptyRect(v44))
        return;
      if (a5 < 0.0)
        a12 = kCGBlendModeSourceAtop;
      objc_msgSend(v31, "size");
      v35 = v41;
      v36 = v42;
      v33 = a1 + floor((a3 - v41 * a6 / v40) * 0.5);
      v34 = a2 + floor((a4 - v42 * a6 / v40) * 0.5);
      v30 = v31;
      v37 = a9;
      v38 = a5;
      v32 = a12;
    }
    DrawOnePartImageWithOperation(v30, v37, v32, a10, a14, v33, v34, v35, v36, v38);
    return;
  }
  v26 = objc_msgSend(a8, "imageForSliceIndex:", a13);
  objc_msgSend(a8, "scale");
  v28 = v27;
  if (a5 < 0.0)
    a12 = kCGBlendModeSourceAtop;
  v43.origin.x = a1;
  v43.origin.y = a2;
  v43.size.width = a3;
  v43.size.height = a4;
  if (!NSIsEmptyRect(v43))
  {
    CGContextSaveGState(a9);
    if (a10)
    {
      +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
      _CUITileImageWithOperation(v26, a9, a12, a1, a2, a3, a4, v28, a5, a6);
      +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
    }
    else
    {
      _CUITileImageWithOperation(v26, a9, a12, a1, a2, a3, a4, v28, a5, a6);
    }
    CGContextRestoreGState(a9);
  }
}

void DrawOnePartImageWithOperation(void *a1, CGContext *a2, CGBlendMode a3, int a4, void *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v24;
  CGImage *v25;
  CGImage *v26;
  double v27;
  CGRect v28;
  CGRect ClipBoundingBox;
  CGRect v30;
  CGRect v31;

  if (!NSIsEmptyRect(*(NSRect *)&a6))
  {
    v27 = a10;
    CGContextSaveGState(a2);
    if (a4)
      +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
    v28.origin.x = a6;
    v28.origin.y = a7;
    v28.size.width = a8;
    v28.size.height = a9;
    CGContextClipToRect(a2, v28);
    ClipBoundingBox = CGContextGetClipBoundingBox(a2);
    x = ClipBoundingBox.origin.x;
    y = ClipBoundingBox.origin.y;
    width = ClipBoundingBox.size.width;
    height = ClipBoundingBox.size.height;
    if (a3)
      CGContextSetBlendMode(a2, a3);
    v24 = fabs(v27);
    if (v24 != 1.0)
      CGContextSetAlpha(a2, v24);
    v30.origin.x = x;
    v30.origin.y = y;
    v30.size.width = width;
    v30.size.height = height;
    if (!CGRectIsEmpty(v30))
    {
      v25 = (CGImage *)objc_msgSend(a1, "image");
      v26 = v25;
      if (a5)
        v26 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v25, 1, 1.0);
      else
        CGImageRetain(v25);
      v31.origin.x = a6;
      v31.origin.y = a7;
      v31.size.width = a8;
      v31.size.height = a9;
      CGContextDrawImage(a2, v31, v26);
      CGImageRelease(v26);
    }
    if (a4)
      +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
    CGContextRestoreGState(a2);
  }
}

void DrawOnePartMaskFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, uint64_t a6, void *a7, CGContext *a8, int a9, uint64_t a10, CGBlendMode a11, int a12)
{
  id v20;
  CGBlendMode v21;

  v20 = objc_msgSend(a7, "maskForSliceIndex:", a12);
  if (a5 >= 0.0)
    v21 = a11;
  else
    v21 = kCGBlendModeSourceAtop;
  DrawOnePartImageWithOperation(v20, a8, v21, a9, 0, a1, a2, a3, a4, a5);
}

void DrawAbsoluteAnimationFrameWithOperation(void *a1, CGContext *a2, CGBlendMode a3, int a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, uint64_t a11, uint64_t a12)
{
  _QWORD v12[5];

  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = __DrawAbsoluteAnimationFrameWithOperation_block_invoke;
  v12[3] = &__block_descriptor_40_e8_q16__0q8l;
  *(double *)&v12[4] = a5;
  DrawQualifiedAnimationFrameWithOperation((uint64_t)v12, a1, a2, a3, a4, a6, a7, a8, a9, a10, a12, 0);
}

void DrawQualifiedAnimationFrameWithOperation(uint64_t a1, void *a2, CGContext *a3, CGBlendMode a4, int a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, uint64_t a11, void *a12)
{
  double v21;
  CUIImage *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  uint64_t v35;
  CGImage *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  CGImage *v43;
  double v44;
  double v45;
  double v46;
  CGImage *v47;
  double v48;
  double v49;
  double v50;
  CGImage *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  double v58;
  double v59;
  double v60;
  double v61;
  NSRect v62;
  CGRect v63;

  v21 = a6;
  if (!NSIsEmptyRect(*(NSRect *)&a6))
  {
    v61 = a10;
    v23 = +[CUIImage imageWithCGImage:](CUIImage, "imageWithCGImage:", objc_msgSend(a2, "unslicedImage"));
    -[CUIImage size](v23, "size");
    v25 = v24;
    v27 = v26;
    objc_msgSend(objc_msgSend(a2, "imageForSliceIndex:", 0), "size");
    v30 = v28;
    v31 = v29;
    if (v28 >= v25)
    {
      v34 = 0.0;
      if (v29 == 0.0)
        v33 = 1.0;
      else
        v33 = v27 / v29 + -1.0;
      v32 = v29;
    }
    else
    {
      v32 = 0.0;
      if (v28 == 0.0)
        v33 = 1.0;
      else
        v33 = v25 / v28 + -1.0;
      v34 = v30;
    }
    v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a1, (uint64_t)v33);
    v36 = -[CUIImage image](v23, "image");
    if (v36)
    {
      v43 = v36;
      v44 = v34 * (double)v35;
      v45 = v32 * (double)v35;
      if (a12)
      {
        v46 = v44;
        objc_msgSend(a2, "scale");
        v47 = (CGImage *)objc_msgSend(a12, "newFlattenedImageFromShapeCGImage:withScale:cache:", v43, 1);
        v44 = v46;
        if (v47)
          v43 = v47;
      }
      v48 = v45;
      v49 = v30;
      v50 = v31;
      v51 = CGImageCreateWithImageInRect(v43, *(CGRect *)&v44);
      if (!v51)
      {
        v62.origin.x = v21;
        v62.origin.y = a7;
        v62.size.width = a8;
        v62.size.height = a9;
        NSStringFromRect(v62);
        _CUILog(4, (uint64_t)"CoreUI: error %s got a invalid subimage '%@' for rendition %@", v52, v53, v54, v55, v56, v57, (uint64_t)"void DrawQualifiedAnimationFrameWithOperation(CFIndex (^)(NSInteger), NSRect, CUIThemeRendition *, CGContextRef, CGBlendMode, CGFloat, CUIFocusRingType, CGColorRef, CUIShapeEffectStack *)");
      }
      v58 = v21 + floor(a8 * 0.5 - v30 * 0.5);
      if (a8 > v30)
      {
        v21 = v58;
        a8 = v30;
      }
      v59 = a7 + floor(a9 * 0.5 - v31 * 0.5);
      if (a9 > v31)
      {
        a7 = v59;
        a9 = v31;
      }
      CGContextSaveGState(a3);
      if (a5)
        +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
      if (a4)
        CGContextSetBlendMode(a3, a4);
      v60 = fabs(v61);
      if (v60 != 1.0)
        CGContextSetAlpha(a3, v60);
      v63.origin.x = v21;
      v63.origin.y = a7;
      v63.size.width = a8;
      v63.size.height = a9;
      CGContextDrawImage(a3, v63, v51);
      if (a5)
        +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
      CGContextRestoreGState(a3);
      CGImageRelease(v51);
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: error %s got a couldn't find an image for %@", v37, v38, v39, v40, v41, v42, (uint64_t)"void DrawQualifiedAnimationFrameWithOperation(CFIndex (^)(NSInteger), NSRect, CUIThemeRendition *, CGContextRef, CGBlendMode, CGFloat, CUIFocusRingType, CGColorRef, CUIShapeEffectStack *)");
    }
  }
}

void DrawAnimationFrameMappedFrom0_1RangedValue(void *a1, CGContext *a2, CGBlendMode a3, int a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, uint64_t a11, void *a12)
{
  _QWORD v12[5];

  if (a5 < 0.0)
    a5 = 0.0;
  if (a5 > 1.0)
    a5 = 1.0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = __DrawAnimationFrameMappedFrom0_1RangedValue_block_invoke;
  v12[3] = &__block_descriptor_40_e8_q16__0q8l;
  *(double *)&v12[4] = a5;
  DrawQualifiedAnimationFrameWithOperation((uint64_t)v12, a1, a2, a3, a4, a6, a7, a8, a9, a10, (uint64_t)a12, a12);
}

void DrawThreePartElementFromRenditionWithOperation(CGFloat a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12, int a13, int a14, int a15, void *a16)
{
  id v27;
  id v28;
  id v29;
  _BOOL4 v30;
  double v31;

  v27 = objc_msgSend(a8, "imageForSliceIndex:", a13);
  v28 = objc_msgSend(a8, "imageForSliceIndex:", a14);
  v29 = objc_msgSend(a8, "imageForSliceIndex:", a15);
  v30 = objc_msgSend(a8, "type") == (id)2;
  objc_msgSend(a8, "scale");
  DrawThreePartImageWithOperation(v27, v29, v28, v30, a9, a12, a10, a16, a1, a2, a3, a4, v31, a5, a6);
}

void DrawThreePartImageWithOperation(void *a1, void *a2, void *a3, int a4, CGContext *a5, CGBlendMode a6, int a7, void *a8, CGFloat a9, double a10, double a11, double a12, double a13, double a14, double a15)
{
  double v25;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  CGFloat v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  CGFloat x;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  CGImage *v63;
  CGImage *v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  CGImage *v70;
  CGImage *v71;
  double v72;
  CGImage *v73;
  CGImage *v74;
  double v75;
  CGImage *v76;
  CGImage *v77;
  CGImage *v78;
  CGImage *v79;
  uint64_t v80;
  double v81;
  CGImage *v82;
  CGImage *v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  uint64_t i;
  double v90;
  double v91;
  double v92;
  double v93;
  CGImage **v94;
  CGImage *v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  NSRect aRect;
  double v102;
  double v103;
  double v104;
  double v105;
  double v106;
  double v107;
  double v108;
  double v109;
  double v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v123;
  CGImage *v124;
  CGImage *v125;
  CGImage *v126;
  CGRect v127;
  CGRect v128;

  if (a12 == 0.0 || a11 == 0.0)
    return;
  v25 = a12;
  aRect.origin.x = a9;
  objc_msgSend(a1, "size");
  v30 = v29;
  v32 = v31;
  objc_msgSend(a2, "size");
  v99 = v34;
  v100 = v33;
  v124 = 0;
  v125 = 0;
  v126 = 0;
  CGContextSaveGState(a5);
  if (a7)
    +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
  if (a6)
    CGContextSetBlendMode(a5, a6);
  v35 = fabs(a14);
  if (v35 != 1.0)
    CGContextSetAlpha(a5, v35);
  v96 = a13;
  v36 = a15 / a13;
  if (!a4)
  {
    v49 = v36 * v30;
    v50 = v36 * v32;
    v51 = v36 * v100;
    v52 = a11;
    if (v50 == 0.0)
    {
      v53 = a10;
    }
    else
    {
      v53 = a10;
      if (v25 - v50 != 0.0)
      {
        x = aRect.origin.x;
        v55 = a10;
        v56 = v25;
        *(NSRect *)(&v52 - 2) = NSInsetRect(*(NSRect *)(&v52 - 2), 0.0, (v25 - v50) * 0.5);
        v58 = v57;
        v25 = v59;
        v53 = floor(v60 + 0.001);
LABEL_29:
        v65 = v52 * 0.5;
        v66 = ceil(v52 * 0.5);
        if (v49 <= v52 * 0.5)
          v67 = v49;
        else
          v67 = v66;
        v68 = floor(v65);
        if (v51 <= v65)
          v69 = v36 * v100;
        else
          v69 = v68;
        aRect.origin.x = v52;
        if (v49 + v51 > v52)
        {
          v49 = v67;
          v51 = v69;
        }
        v70 = (CGImage *)objc_msgSend(a1, "image", *(_QWORD *)&v96);
        v71 = v70;
        if (a8)
          v71 = (CGImage *)objc_msgSend(a8, "newFlattenedImageFromShapeCGImage:withScale:cache:", v70, 1, a15);
        else
          CGImageRetain(v70);
        v75 = v36 * v99;
        v124 = v71;
        v112 = v58;
        v113 = v53;
        v114 = v49;
        v115 = v50;
        aRect.size.width = v58;
        aRect.size.height = v53;
        v102 = v49;
        v103 = v50;
        v76 = (CGImage *)objc_msgSend(a2, "image");
        v77 = v76;
        if (a8)
          v77 = (CGImage *)objc_msgSend(a8, "newFlattenedImageFromShapeCGImage:withScale:cache:", v76, 1, a15);
        else
          CGImageRetain(v76);
        v125 = v77;
        v116 = v58 + aRect.origin.x - v51;
        v117 = v53;
        v118 = v51;
        v119 = v75;
        v104 = v116;
        v105 = v53;
        v106 = v51;
        v107 = v75;
        v81 = v58 + v49;
        v82 = (CGImage *)objc_msgSend(a3, "image");
        v83 = v82;
        if (a8)
        {
          v84 = a15;
          v83 = (CGImage *)objc_msgSend(a8, "newFlattenedImageFromShapeCGImage:withScale:cache:", v82, 1, a15);
        }
        else
        {
          CGImageRetain(v82);
          v84 = a15;
        }
        objc_msgSend(a3, "size");
        v86 = v85 * v84 / v98;
        v88 = v87 * v84 / v98;
        v127.origin.x = v81;
        v127.origin.y = v53;
        v127.size.width = aRect.origin.x - v49 - v51;
        v127.size.height = v25;
        v126 = v83;
        v120 = v81;
        v121 = CGRectGetMaxY(v127) - v88;
        v122 = v86;
        v123 = v88;
        v108 = v81;
        v109 = v53;
        v110 = aRect.origin.x - v49 - v51;
        v111 = v25;
        CGContextDrawImages(a5, &v112, &v124, &aRect.size, 3);
        for (i = 0; i != 24; i += 8)
          CGImageRelease(*(CGImage **)((char *)&v124 + i));
        goto LABEL_61;
      }
    }
    v58 = aRect.origin.x;
    goto LABEL_29;
  }
  v37 = v36 * v32;
  v38 = v36 * v30;
  v39 = v36 * v99;
  v40 = a11;
  if (v38 == 0.0)
  {
    v41 = a10;
    goto LABEL_17;
  }
  v41 = a10;
  if (v40 - v38 == 0.0)
  {
LABEL_17:
    v48 = aRect.origin.x;
    goto LABEL_18;
  }
  v42 = aRect.origin.x;
  v43 = a10;
  v44 = v25;
  *(NSRect *)(&v40 - 2) = NSInsetRect(*(NSRect *)(&v40 - 2), (v40 - v38) * 0.5, 0.0);
  v41 = v45;
  v25 = v46;
  v48 = floor(v47 + 0.001);
LABEL_18:
  aRect.origin.x = v40;
  if (v37 + v39 > v25)
  {
    v61 = v25 * 0.5;
    if (v37 <= v25 * 0.5)
      v62 = v37;
    else
      v62 = v25 * 0.5;
    v37 = ceil(v62);
    if (v39 <= v61)
      v61 = v36 * v99;
    v39 = floor(v61);
  }
  v63 = (CGImage *)objc_msgSend(a1, "image", *(_QWORD *)&v96);
  v64 = v63;
  if (a8)
    v64 = (CGImage *)objc_msgSend(a8, "newFlattenedImageFromShapeCGImage:withScale:cache:", v63, 1, a15);
  else
    CGImageRetain(v63);
  v72 = v36 * v100;
  v124 = v64;
  v112 = v48;
  v113 = v41 + v25 - v37;
  v114 = v38;
  v115 = v37;
  aRect.size.width = v48;
  aRect.size.height = v113;
  v102 = v38;
  v103 = v37;
  v73 = (CGImage *)objc_msgSend(a2, "image");
  v74 = v73;
  if (a8)
    v74 = (CGImage *)objc_msgSend(a8, "newFlattenedImageFromShapeCGImage:withScale:cache:", v73, 1, a15);
  else
    CGImageRetain(v73);
  v125 = v74;
  v116 = v48;
  v117 = v41;
  v118 = v72;
  v119 = v39;
  v104 = v48;
  v105 = v41;
  v106 = v72;
  v107 = v39;
  if (v25 - (v39 + v37) <= 0.0)
  {
    v80 = 2;
  }
  else
  {
    v78 = (CGImage *)objc_msgSend(a3, "image");
    v79 = v78;
    if (a8)
      v79 = (CGImage *)objc_msgSend(a8, "newFlattenedImageFromShapeCGImage:withScale:cache:", v78, 1, a15);
    else
      CGImageRetain(v78);
    objc_msgSend(a3, "size");
    v91 = v90 * a15 / v97;
    v93 = v92 * a15 / v97;
    v128.origin.x = v48;
    v128.origin.y = v41 + v39;
    v128.size.width = aRect.origin.x;
    v128.size.height = v25 - (v39 + v37);
    v126 = v79;
    v120 = v48;
    v121 = CGRectGetMaxY(v128) - v93;
    v122 = v91;
    v123 = v93;
    v108 = v48;
    v109 = v41 + v39;
    v110 = aRect.origin.x;
    v111 = v25 - (v39 + v37);
    v80 = 3;
  }
  v94 = &v124;
  CGContextDrawImages(a5, &v112, &v124, &aRect.size, v80);
  do
  {
    v95 = *v94++;
    CGImageRelease(v95);
    --v80;
  }
  while (v80);
LABEL_61:
  if (a7)
    +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
  CGContextRestoreGState(a5);
}

void DrawThreePartMaskFromRenditionWithOperation(CGFloat a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12)
{
  id v22;
  id v23;
  id v24;
  _BOOL4 v25;
  double v26;

  v22 = objc_msgSend(a8, "maskForSliceIndex:", 0);
  v23 = objc_msgSend(a8, "maskForSliceIndex:", 2);
  v24 = objc_msgSend(a8, "maskForSliceIndex:", 1);
  v25 = objc_msgSend(a8, "type") == (id)2;
  objc_msgSend(a8, "scale");
  DrawThreePartImageWithOperation(v22, v23, v24, v25, a9, a12, a10, 0, a1, a2, a3, a4, v26, a5, a6);
}

void DrawPulsedElementFromRenditionKey(uint64_t a1, void *a2, CGContext *a3, int a4, CGFloat a5, double a6, double a7, double a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  void *v24;
  id v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  _UNKNOWN **v34;
  char v35;
  uint64_t v36;
  id v37;
  void *v38;
  _BOOL4 v39;
  id v40;
  int v41;
  uint64_t v42;
  id v43;
  void *v44;
  double v45;
  id v46;
  id v47;
  id v48;
  id v49;
  void *v50;
  double v51;
  char v52;

  v24 = (void *)_LookupStructuredThemeProvider(a1, a2);
  if (a10 > 1.0 && (objc_msgSend(v24, "canGetRenditionWithKey:", objc_msgSend(a2, "keyList")) & 1) == 0)
    objc_msgSend(a2, "setThemeScale:", 1);
  v25 = objc_msgSend(v24, "renditionWithKey:", objc_msgSend(a2, "keyList"));
  v26 = objc_msgSend(v25, "type");
  if ((unint64_t)v26 >= 3)
  {
    _CUILog(4, (uint64_t)"Can only pulse one- and three-part renditions", v27, v28, v29, v30, v31, v32, a15);
  }
  else
  {
    v33 = v26;
    v34 = &CGContextSetTextMatrix_ptr;
    if (a4)
      +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
    CGContextBeginTransparencyLayer(a3, 0);
    v35 = objc_opt_respondsToSelector(a2, sel_setThemeLayer_);
    v36 = 0;
    if ((v35 & 1) != 0)
    {
      LOWORD(v36) = (unsigned __int16)objc_msgSend(a2, "themeLayer");
      objc_msgSend(a2, "setThemeLayer:", 3);
      v36 = (unsigned __int16)v36;
    }
    v37 = objc_msgSend(v25, "imageForSliceIndex:", 0);
    v38 = v37;
    if (v33)
    {
      v39 = v33 == (id)2;
      v40 = objc_msgSend(v25, "imageForSliceIndex:", 2);
      v52 = v35;
      v41 = a4;
      v42 = v36;
      v43 = objc_msgSend(v25, "imageForSliceIndex:", 1);
      objc_msgSend(v25, "scale");
      v44 = v40;
      v34 = &CGContextSetTextMatrix_ptr;
      DrawThreePartImageWithOperation(v38, v44, v43, v39, a3, kCGBlendModeCopy, 0, 0, a5, a6, a7, a8, v45, 1.0 - a9, a10);
      v46 = objc_msgSend(v24, "renditionWithKey:", objc_msgSend(a2, "keyList"));
      v47 = objc_msgSend(v46, "imageForSliceIndex:", 0);
      v48 = objc_msgSend(v46, "imageForSliceIndex:", 2);
      v49 = objc_msgSend(v46, "imageForSliceIndex:", 1);
      v50 = v46;
      v36 = v42;
      a4 = v41;
      v35 = v52;
      objc_msgSend(v50, "scale");
      DrawThreePartImageWithOperation(v47, v48, v49, v39, a3, kCGBlendModePlusLighter, 0, 0, a5, a6, a7, a8, v51, a9, a10);
    }
    else
    {
      DrawThemeImageWithOperation(v37, a3, kCGBlendModeCopy, 0, a5, a6, a7, a8, 1.0 - a9);
      DrawThemeImageWithOperation(objc_msgSend(objc_msgSend(v24, "renditionWithKey:", objc_msgSend(a2, "keyList")), "imageForSliceIndex:", 0), a3, kCGBlendModeNormal, 0, a5, a6, a7, a8, a9);
    }
    CGContextEndTransparencyLayer(a3);
    if (a4)
      objc_msgSend(v34[246], "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
    if ((v35 & 1) != 0)
      objc_msgSend(a2, "setThemeLayer:", v36);
  }
}

void DrawNinePartElementFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12, void *a13)
{
  unsigned __int8 v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  double v30;
  uint64_t v31;
  _CUINineImagePieces *v36;
  _CUINineImagePieces *v37;

  v20 = objc_msgSend(a8, "edgesOnly");
  v36 = [_CUINineImagePieces alloc];
  if ((v20 & 1) != 0)
    v21 = 0;
  else
    v21 = objc_msgSend(a8, "imageForSliceIndex:", 4);
  v22 = objc_msgSend(a8, "imageForSliceIndex:", 0);
  v23 = objc_msgSend(a8, "imageForSliceIndex:", 1);
  v24 = objc_msgSend(a8, "imageForSliceIndex:", 2);
  v25 = objc_msgSend(a8, "imageForSliceIndex:", 5);
  v26 = objc_msgSend(a8, "imageForSliceIndex:", 8);
  v27 = objc_msgSend(a8, "imageForSliceIndex:", 7);
  v28 = objc_msgSend(a8, "imageForSliceIndex:", 6);
  v29 = objc_msgSend(a8, "imageForSliceIndex:", 3);
  LOBYTE(v31) = objc_msgSend(a8, "isTiled");
  v37 = -[_CUINineImagePieces initWithCenter:topLeft:top:topRight:right:bottomRight:bottom:bottomLeft:left:tileCenterAndEdges:](v36, "initWithCenter:topLeft:top:topRight:right:bottomRight:bottom:bottomLeft:left:tileCenterAndEdges:", v21, v22, v23, v24, v25, v26, v27, v28, v29, v31);
  objc_msgSend(a8, "scale");
  DrawNinePartImageWithOperation(v37, a9, a12, a10, a13, a1, a2, a3, a4, v30, a5, a6);

}

void DrawNinePartImageWithOperation(void *a1, CGContext *a2, CGBlendMode a3, int a4, void *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, double a11, double a12)
{
  double v24;
  id v25;
  double v26;
  double v27;
  double v28;
  double v29;
  CGImage *v30;
  CGImage *v31;
  double v32;
  uint64_t v33;
  id v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  CGImage *v41;
  CGImage *v42;
  double *v43;
  double *v44;
  _QWORD *v45;
  id v46;
  double v47;
  double v48;
  double v49;
  double v50;
  CGImage *v51;
  CGImage *v52;
  CGFloat *v53;
  CGFloat *v54;
  id v55;
  double v56;
  double v57;
  CGImage *v58;
  CGImage *v59;
  double v60;
  CGFloat *v61;
  CGFloat *v62;
  id v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  CGFloat x;
  CGFloat width;
  double v71;
  unsigned int v72;
  CGImage *v73;
  CGImage *v74;
  double v75;
  CGFloat MaxY;
  CGFloat *v77;
  CGFloat *v78;
  CGFloat *v79;
  double *v80;
  id v81;
  double v82;
  double v83;
  double v84;
  double v85;
  CGFloat v86;
  CGFloat v87;
  double v88;
  CGFloat v89;
  unsigned int v90;
  CGImage *v91;
  CGImage *v92;
  double v93;
  CGFloat v94;
  CGFloat *v95;
  CGFloat *v96;
  CGFloat *v97;
  CGFloat *v98;
  id v99;
  double v100;
  double v101;
  double v102;
  double v103;
  double v104;
  double v105;
  CGFloat v106;
  CGFloat height;
  unsigned int v108;
  CGImage *v109;
  CGImage *v110;
  double v111;
  CGFloat v112;
  CGFloat *v113;
  CGFloat *v114;
  CGFloat *v115;
  CGFloat *v116;
  id v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  CGFloat v123;
  CGFloat v124;
  unsigned int v125;
  CGImage *v126;
  CGImage *v127;
  double v128;
  CGFloat v129;
  double *v130;
  CGFloat *v131;
  CGFloat *v132;
  CGFloat *v133;
  id v134;
  CGFloat v135;
  void *v136;
  CGFloat v137;
  CGFloat v138;
  CGFloat v139;
  CGFloat v140;
  CGFloat v141;
  unsigned int v142;
  CGImage *v143;
  CGImage *v144;
  double v145;
  double v146;
  double v147;
  double v148;
  double v149;
  CGFloat v150;
  CGFloat *v151;
  CGFloat *v152;
  CGFloat *v153;
  CGFloat *v154;
  CGImage **v155;
  CGImage *v156;
  NSExceptionName v157;
  CGFloat v158;
  CGFloat v159;
  CGFloat v160;
  CGFloat v161;
  CGFloat v162;
  CGFloat v163;
  CGFloat v164;
  CGFloat MinY;
  CGFloat v166;
  CGFloat v167;
  CGFloat v168;
  CGFloat v169;
  CGColorSpace *DeviceRGB;
  CGColor *v171;
  double v172;
  CGFloat r1;
  double r1_8;
  double r1_16;
  double r1_16a;
  double r1_24;
  double v178;
  double v179;
  double v180;
  double v181;
  CGFloat MinX;
  double r2;
  CGFloat r2a;
  CGFloat r2_8;
  CGRect r2_8a;
  CGFloat r2_16;
  CGFloat r2_24;
  CGFloat y;
  CGFloat rect;
  CGFloat recta;
  CGFloat components[2];
  __int128 v193;
  CGRect rects;
  CGFloat v195;
  CGFloat v196;
  uint64_t v197;
  CGFloat v198;
  CGFloat v199;
  CGFloat v200;
  CGFloat v201;
  uint64_t v202;
  CGFloat v203;
  CGFloat v204;
  uint64_t v205;
  CGFloat v206;
  _OWORD v207[4];
  uint64_t v208;
  _QWORD v209[36];
  CGFloat v210;
  double v211;
  double v212;
  double v213;
  CGRect v214;
  CGRect ClipBoundingBox;
  CGRect v216;
  CGRect v217;
  CGRect v218;
  CGRect v219;
  CGRect v220;
  CGRect v221;
  CGRect v222;
  CGRect v223;
  CGRect v224;
  CGRect v225;
  CGRect v226;
  CGRect v227;
  CGRect v228;
  CGRect v229;
  CGRect v230;
  CGRect v231;
  CGRect v232;
  CGRect v233;
  CGRect v234;
  CGRect v235;
  CGRect v236;
  CGRect v237;
  CGRect v238;
  CGRect v239;
  CGRect v240;
  CGRect v241;
  CGRect v242;
  CGRect v243;
  CGRect v244;
  CGRect v245;
  CGRect v246;
  CGRect v247;
  CGRect v248;
  CGRect v249;
  CGRect v250;
  CGRect v251;
  CGRect v252;
  CGRect v253;
  CGRect v254;
  CGRect v255;
  CGRect v256;
  CGRect v257;
  CGRect v258;
  CGRect v259;
  CGRect v260;

  if (!NSIsEmptyRect(*(NSRect *)&a6))
  {
    v208 = 0;
    memset(v207, 0, sizeof(v207));
    CGContextSaveGState(a2);
    if (a4 == 1)
      +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
    v214.origin.x = a6;
    v214.origin.y = a7;
    v214.size.width = a8;
    v214.size.height = a9;
    CGContextClipToRect(a2, v214);
    ClipBoundingBox = CGContextGetClipBoundingBox(a2);
    y = ClipBoundingBox.origin.y;
    rect = ClipBoundingBox.origin.x;
    r2_16 = ClipBoundingBox.size.height;
    r2_24 = ClipBoundingBox.size.width;
    if (a3)
      CGContextSetBlendMode(a2, a3);
    v24 = fabs(a11);
    if (v24 != 1.0)
      CGContextSetAlpha(a2, v24);
    v25 = objc_msgSend(a1, "topLeft");
    objc_msgSend(v25, "size");
    v172 = a10;
    v26 = a12 / a10;
    r1_16 = a12 / a10 * v27;
    v29 = a12 / a10 * v28;
    v30 = (CGImage *)objc_msgSend(v25, "image");
    v31 = v30;
    if (a5)
      v31 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v30, 1, a12);
    else
      CGImageRetain(v30);
    v180 = a9;
    v32 = a7 + a9 - v29;
    v216.origin.x = a6;
    v216.origin.y = v32;
    v216.size.width = r1_16;
    v216.size.height = v29;
    v252.origin.y = y;
    v252.origin.x = rect;
    v252.size.height = r2_16;
    v252.size.width = r2_24;
    v217 = CGRectIntersection(v216, v252);
    r2 = a12;
    r2_8 = a7;
    r1_8 = v29;
    if (CGRectIsEmpty(v217))
    {
      CGImageRelease(v31);
      v33 = 0;
    }
    else
    {
      v210 = a6;
      v211 = a7 + a9 - v29;
      v212 = r1_16;
      v213 = v29;
      *(CGFloat *)v209 = a6;
      *(double *)&v209[1] = v211;
      *(double *)&v209[2] = r1_16;
      *(double *)&v209[3] = v29;
      v33 = 1;
      *(_QWORD *)&v207[0] = v31;
    }
    v34 = objc_msgSend(a1, "topRight");
    objc_msgSend(v34, "size");
    v35 = v26;
    v37 = v26 * v36;
    v39 = v26 * v38;
    v181 = a8;
    r1_24 = a6 + a8;
    v40 = a6 + a8 - v26 * v36;
    v41 = (CGImage *)objc_msgSend(v34, "image");
    v42 = v41;
    if (a5)
      v42 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v41, 1, r2);
    else
      CGImageRetain(v41);
    v218.origin.x = v40;
    v218.origin.y = v32;
    v218.size.width = v37;
    v218.size.height = v39;
    v253.origin.y = y;
    v253.origin.x = rect;
    v253.size.height = r2_16;
    v253.size.width = r2_24;
    v219 = CGRectIntersection(v218, v253);
    if (CGRectIsEmpty(v219))
    {
      CGImageRelease(v42);
    }
    else
    {
      v43 = &v210 + 4 * v33;
      *v43 = v40;
      v43[1] = v32;
      v43[2] = v37;
      v43[3] = v39;
      v44 = (double *)&v209[4 * v33];
      *v44 = v40;
      v44[1] = v32;
      v44[2] = v37;
      v44[3] = v39;
      v45 = (_QWORD *)((unint64_t)v207 | (8 * v33++));
      *v45 = v42;
    }
    v46 = objc_msgSend(a1, "bottomLeft");
    objc_msgSend(v46, "size");
    v48 = v26 * v47;
    v50 = v26 * v49;
    v51 = (CGImage *)objc_msgSend(v46, "image");
    v52 = v51;
    if (a5)
      v52 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v51, 1, r2);
    else
      CGImageRetain(v51);
    v220.origin.x = a6;
    v220.origin.y = r2_8;
    v220.size.width = v48;
    v220.size.height = v50;
    v254.origin.y = y;
    v254.origin.x = rect;
    v254.size.height = r2_16;
    v254.size.width = r2_24;
    v221 = CGRectIntersection(v220, v254);
    if (CGRectIsEmpty(v221))
    {
      CGImageRelease(v52);
    }
    else
    {
      v53 = &v210 + 4 * v33;
      *v53 = a6;
      v53[1] = r2_8;
      v53[2] = v48;
      v53[3] = v50;
      *((_QWORD *)v207 + v33) = v52;
      v54 = (CGFloat *)&v209[4 * v33];
      *v54 = a6;
      v54[1] = r2_8;
      ++v33;
      v54[2] = v48;
      v54[3] = v50;
    }
    v55 = objc_msgSend(a1, "bottomRight");
    objc_msgSend(v55, "size");
    v57 = v26 * v56;
    v58 = (CGImage *)objc_msgSend(v55, "image");
    v59 = v58;
    v179 = a6;
    if (a5)
      v59 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v58, 1, r2);
    else
      CGImageRetain(v58);
    v60 = r1_24 - v57;
    v222.origin.x = r1_24 - v57;
    v255.size.height = r2_16;
    v222.origin.y = r2_8;
    v222.size.width = v57;
    v222.size.height = v50;
    v255.origin.y = y;
    v255.origin.x = rect;
    v255.size.width = r2_24;
    v223 = CGRectIntersection(v222, v255);
    v178 = v50;
    if (CGRectIsEmpty(v223))
    {
      CGImageRelease(v59);
    }
    else
    {
      v61 = &v210 + 4 * v33;
      *v61 = v60;
      v61[1] = r2_8;
      v61[2] = v57;
      v61[3] = v50;
      *((_QWORD *)v207 + v33) = v59;
      v62 = (CGFloat *)&v209[4 * v33];
      *v62 = v60;
      v62[1] = r2_8;
      ++v33;
      v62[2] = v57;
      v62[3] = v50;
    }
    v63 = objc_msgSend(a1, "top");
    objc_msgSend(v63, "size");
    v65 = v64;
    v67 = v35 * v66;
    v68 = a6 + r1_16;
    v224.origin.x = v179 + r1_16;
    v224.origin.y = v32;
    r1_16a = v181 - r1_16 - v37;
    v224.size.width = r1_16a;
    v224.size.height = v67;
    v256.origin.y = y;
    v256.origin.x = rect;
    v256.size.height = r2_16;
    v256.size.width = r2_24;
    v225 = CGRectIntersection(v224, v256);
    x = v225.origin.x;
    width = v225.size.width;
    v225.origin.y = v32;
    v225.size.height = v67;
    if (CGRectIsEmpty(v225))
    {
      v71 = v180;
    }
    else
    {
      v72 = objc_msgSend(a1, "tileCenterAndEdges");
      v73 = (CGImage *)objc_msgSend(v63, "image");
      v74 = v73;
      if (v72)
      {
        v75 = v35 * v65;
        if (a5)
          v74 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v73, 1, r2);
        else
          CGImageRetain(v73);
        v71 = v180;
        v226.origin.x = x;
        v226.origin.y = v32;
        v226.size.width = width;
        v226.size.height = v67;
        MaxY = CGRectGetMaxY(v226);
        *((_QWORD *)v207 + v33) = v74;
        v77 = (CGFloat *)&v209[4 * v33];
        *v77 = x;
        v77[1] = MaxY - v67;
        v77[2] = v75;
        v77[3] = v67;
        v78 = &v210 + 4 * v33;
        *v78 = x;
        v78[1] = v32;
        v78[2] = width;
        v78[3] = v67;
        ++v33;
      }
      else
      {
        if (a5)
          v74 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v73, 1, r2);
        else
          CGImageRetain(v73);
        v71 = v180;
        v79 = &v210 + 4 * v33;
        *v79 = x;
        v79[1] = v32;
        v79[2] = width;
        v79[3] = v67;
        *((_QWORD *)v207 + v33) = v74;
        v80 = (double *)&v209[4 * v33];
        *v80 = x;
        v80[1] = v32;
        ++v33;
        v80[2] = width;
        v80[3] = v67;
      }
    }
    v81 = objc_msgSend(a1, "bottom");
    objc_msgSend(v81, "size");
    v83 = v82;
    v85 = v35 * v84;
    r1 = v68;
    v227.origin.x = v68;
    v257.size.height = r2_16;
    v227.origin.y = r2_8;
    v227.size.width = r1_16a;
    v227.size.height = v85;
    v257.origin.y = y;
    v257.origin.x = rect;
    v257.size.width = r2_24;
    v228 = CGRectIntersection(v227, v257);
    v86 = v228.origin.x;
    v87 = v228.size.width;
    v228.origin.y = r2_8;
    v228.size.height = v85;
    if (CGRectIsEmpty(v228))
    {
      v88 = r2_8;
      v89 = v179;
    }
    else
    {
      v90 = objc_msgSend(a1, "tileCenterAndEdges");
      v91 = (CGImage *)objc_msgSend(v81, "image");
      v92 = v91;
      v89 = v179;
      if (v90)
      {
        v93 = v35 * v83;
        if (a5)
          v92 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v91, 1, r2);
        else
          CGImageRetain(v91);
        v229.origin.x = v86;
        v88 = r2_8;
        v229.origin.y = r2_8;
        v229.size.width = v87;
        v229.size.height = v85;
        v94 = CGRectGetMaxY(v229);
        *((_QWORD *)v207 + v33) = v92;
        v95 = (CGFloat *)&v209[4 * v33];
        *v95 = v86;
        v95[1] = v94 - v85;
        v95[2] = v93;
        v95[3] = v85;
        v96 = &v210 + 4 * v33;
        *v96 = v86;
        v96[1] = r2_8;
        v96[2] = v87;
        v96[3] = v85;
        ++v33;
      }
      else
      {
        if (a5)
          v92 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v91, 1, r2);
        else
          CGImageRetain(v91);
        v88 = r2_8;
        v97 = &v210 + 4 * v33;
        *v97 = v86;
        v97[1] = r2_8;
        v97[2] = v87;
        v97[3] = v85;
        *((_QWORD *)v207 + v33) = v92;
        v98 = (CGFloat *)&v209[4 * v33];
        *v98 = v86;
        v98[1] = r2_8;
        ++v33;
        v98[2] = v87;
        v98[3] = v85;
      }
    }
    v99 = objc_msgSend(a1, "left");
    objc_msgSend(v99, "size");
    v101 = v100;
    v103 = v35 * v102;
    v104 = v88 + v178;
    v105 = v71 - v178 - r1_8;
    v230.origin.x = v89;
    v230.origin.y = v88 + v178;
    v230.size.width = v103;
    v230.size.height = v105;
    v258.origin.y = y;
    v258.origin.x = rect;
    v258.size.height = r2_16;
    v258.size.width = r2_24;
    v231 = CGRectIntersection(v230, v258);
    v106 = v231.origin.y;
    height = v231.size.height;
    v231.origin.x = v89;
    v231.size.width = v103;
    if (!CGRectIsEmpty(v231))
    {
      v108 = objc_msgSend(a1, "tileCenterAndEdges");
      v109 = (CGImage *)objc_msgSend(v99, "image");
      v110 = v109;
      if (v108)
      {
        v111 = v35 * v101;
        if (a5)
          v110 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v109, 1, r2);
        else
          CGImageRetain(v109);
        v232.origin.x = v89;
        v232.origin.y = v106;
        v232.size.width = v103;
        v232.size.height = height;
        v112 = CGRectGetMaxY(v232);
        *((_QWORD *)v207 + v33) = v110;
        v113 = (CGFloat *)&v209[4 * v33];
        *v113 = v89;
        v113[1] = v112 - v111;
        v113[2] = v103;
        v113[3] = v111;
        v114 = &v210 + 4 * v33;
        *v114 = v89;
        v114[1] = v106;
        v114[2] = v103;
        v114[3] = height;
        ++v33;
      }
      else
      {
        if (a5)
          v110 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v109, 1, r2);
        else
          CGImageRetain(v109);
        v115 = &v210 + 4 * v33;
        *v115 = v89;
        v115[1] = v106;
        v115[2] = v103;
        v115[3] = height;
        *((_QWORD *)v207 + v33) = v110;
        v116 = (CGFloat *)&v209[4 * v33];
        *v116 = v89;
        v116[1] = v106;
        ++v33;
        v116[2] = v103;
        v116[3] = height;
      }
    }
    v117 = objc_msgSend(a1, "right");
    objc_msgSend(v117, "size");
    v119 = v118;
    v121 = v35 * v120;
    v233.origin.x = r1_24 - v35 * v120;
    v122 = v233.origin.x;
    v233.origin.y = v104;
    v233.size.width = v121;
    v233.size.height = v105;
    v259.origin.y = y;
    v259.origin.x = rect;
    v259.size.height = r2_16;
    v259.size.width = r2_24;
    v234 = CGRectIntersection(v233, v259);
    v123 = v234.origin.y;
    v124 = v234.size.height;
    v234.origin.x = v122;
    v234.size.width = v121;
    if (!CGRectIsEmpty(v234))
    {
      v125 = objc_msgSend(a1, "tileCenterAndEdges");
      v126 = (CGImage *)objc_msgSend(v117, "image");
      v127 = v126;
      if (v125)
      {
        v128 = v35 * v119;
        if (a5)
          v127 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v126, 1, r2);
        else
          CGImageRetain(v126);
        v235.origin.x = v122;
        v235.origin.y = v123;
        v235.size.width = v121;
        v235.size.height = v124;
        v129 = CGRectGetMaxY(v235);
        *((_QWORD *)v207 + v33) = v127;
        v130 = (double *)&v209[4 * v33];
        *v130 = v122;
        v130[1] = v129 - v128;
        v130[2] = v121;
        v130[3] = v128;
        v131 = &v210 + 4 * v33;
        *v131 = v122;
        v131[1] = v123;
        v131[2] = v121;
        v131[3] = v124;
        ++v33;
      }
      else
      {
        if (a5)
          v127 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v126, 1, r2);
        else
          CGImageRetain(v126);
        v132 = &v210 + 4 * v33;
        *v132 = v122;
        v132[1] = v123;
        v132[2] = v121;
        v132[3] = v124;
        *((_QWORD *)v207 + v33) = v127;
        v133 = (CGFloat *)&v209[4 * v33];
        *v133 = v122;
        v133[1] = v123;
        ++v33;
        v133[2] = v121;
        v133[3] = v124;
      }
    }
    v134 = objc_msgSend(a1, "center");
    v135 = v181;
    if (!v134)
      goto LABEL_76;
    v136 = v134;
    v236.size.width = r1_16a;
    v236.size.height = v180 - r1_8 - v178;
    v236.origin.x = r1;
    v236.origin.y = v104;
    v260.origin.y = y;
    v260.origin.x = rect;
    v260.size.height = r2_16;
    v260.size.width = r2_24;
    v237 = CGRectIntersection(v236, v260);
    v137 = v237.origin.x;
    v138 = v237.origin.y;
    v139 = v237.size.width;
    v140 = v237.size.height;
    if (!CGRectIsEmpty(v237))
    {
      v142 = objc_msgSend(a1, "tileCenterAndEdges");
      v143 = (CGImage *)objc_msgSend(v136, "image");
      v144 = v143;
      if (v142)
      {
        if (a5)
        {
          v145 = r2;
          v144 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v143, 1, r2);
        }
        else
        {
          CGImageRetain(v143);
          v145 = r2;
        }
        objc_msgSend(v136, "size");
        v147 = v146 * v145 / v172;
        v149 = v148 * v145 / v172;
        v238.origin.x = v137;
        v238.origin.y = v138;
        v238.size.width = v139;
        v238.size.height = v140;
        v150 = CGRectGetMaxY(v238);
        *((_QWORD *)v207 + v33) = v144;
        v151 = (CGFloat *)&v209[4 * v33];
        *v151 = v137;
        v151[1] = v150 - v149;
        v151[2] = v147;
        v151[3] = v149;
        v152 = &v210 + 4 * v33;
        *v152 = v137;
        v152[1] = v138;
        v152[2] = v139;
        v152[3] = v140;
        v135 = v181;
      }
      else
      {
        if (a5)
          v144 = (CGImage *)objc_msgSend(a5, "newFlattenedImageFromShapeCGImage:withScale:cache:", v143, 1, r2);
        else
          CGImageRetain(v143);
        v153 = &v210 + 4 * v33;
        *v153 = v137;
        v153[1] = v138;
        v153[2] = v139;
        v153[3] = v140;
        v154 = (CGFloat *)&v209[4 * v33];
        *v154 = v137;
        v154[1] = v138;
        v154[2] = v139;
        v154[3] = v140;
        *((_QWORD *)v207 + v33) = v144;
      }
      CGContextDrawImages(a2, v209, v207, &v210, ++v33);
      v141 = r2_8;
    }
    else
    {
LABEL_76:
      CGContextDrawImages(a2, v209, v207, &v210, v33);
      v141 = r2_8;
      if (!v33)
        goto LABEL_90;
    }
    v155 = (CGImage **)v207;
    do
    {
      v156 = *v155++;
      CGImageRelease(v156);
      --v33;
    }
    while (v33);
LABEL_90:
    if (a4)
    {
      if (a4 == 1)
      {
        v157 = NSGenericException;
LABEL_95:
        +[NSException raise:format:](NSException, "raise:format:", v157, CFSTR("Focus Ring drawing not supported"));
        goto LABEL_96;
      }
      if (a4 == 2)
      {
        v239.origin.x = v89;
        v239.origin.y = v141;
        v239.size.width = v135;
        v239.size.height = v180;
        r2_8a = CGRectInset(v239, 3.0, 3.0);
        v240 = CGRectInset(r2_8a, 1.0, 1.0);
        v158 = v89;
        v159 = v240.origin.x;
        v160 = v240.origin.y;
        recta = v240.origin.y;
        v161 = v240.size.width;
        v162 = v240.size.height;
        v240.origin.x = v158;
        v240.origin.y = v141;
        v240.size.width = v135;
        v240.size.height = v180;
        MinX = CGRectGetMinX(v240);
        v241.origin.x = v159;
        v241.origin.y = v160;
        v241.size.width = v161;
        v241.size.height = v162;
        v163 = CGRectGetMaxY(v241);
        v242.origin.x = v158;
        v242.origin.y = v141;
        v242.size.width = v135;
        v242.size.height = v180;
        rects.origin.x = MinX;
        rects.origin.y = v163;
        rects.size.width = CGRectGetWidth(v242);
        rects.size.height = 4.0;
        v243.origin.x = v158;
        v243.origin.y = v141;
        v243.size.width = v135;
        v243.size.height = v180;
        v164 = CGRectGetMaxX(v243) + -4.0;
        r2a = v159;
        v244.origin.x = v159;
        v244.origin.y = recta;
        v244.size.width = v161;
        v244.size.height = v162;
        MinY = CGRectGetMinY(v244);
        v245.origin.x = v158;
        v245.origin.y = v141;
        v245.size.width = v135;
        v245.size.height = v180;
        v195 = v164;
        v196 = MinY;
        v197 = 0x4010000000000000;
        v198 = CGRectGetHeight(v245);
        v246.origin.x = v158;
        v246.origin.y = v141;
        v246.size.width = v135;
        v246.size.height = v180;
        v166 = CGRectGetMinX(v246);
        v247.origin.x = v158;
        v247.origin.y = v141;
        v247.size.width = v135;
        v247.size.height = v180;
        v167 = CGRectGetMinY(v247);
        v248.origin.x = v158;
        v248.origin.y = v141;
        v248.size.width = v135;
        v248.size.height = v180;
        v199 = v166;
        v200 = v167;
        v201 = CGRectGetWidth(v248);
        v202 = 0x4010000000000000;
        v249.origin.x = v158;
        v249.origin.y = v141;
        v249.size.width = v135;
        v249.size.height = v180;
        v168 = CGRectGetMinX(v249);
        v250.origin.x = r2a;
        v250.origin.y = recta;
        v250.size.width = v161;
        v250.size.height = v162;
        v169 = CGRectGetMinY(v250);
        v251.origin.x = v158;
        v251.origin.y = v141;
        v251.size.width = v135;
        v251.size.height = v180;
        v203 = v168;
        v204 = v169;
        v205 = 0x4010000000000000;
        v206 = CGRectGetHeight(v251);
        +[NSException raise:format:](NSException, "raise:format:", NSGenericException, CFSTR("Focus Ring drawing not supported"));
        DeviceRGB = CGColorSpaceCreateDeviceRGB();
        *(_OWORD *)components = xmmword_19EC72C50;
        v193 = unk_19EC72C60;
        v171 = CGColorCreate(DeviceRGB, components);
        CGContextSetFillColorWithColor(a2, v171);
        CGContextClipToRects(a2, &rects, 4uLL);
        CGContextFillRect(a2, r2_8a);
        CGColorSpaceRelease(DeviceRGB);
        CGColorRelease(v171);
        v157 = NSGenericException;
        goto LABEL_95;
      }
    }
LABEL_96:
    CGContextRestoreGState(a2);
  }
}

void DrawNinePartMaskFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12)
{
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  double v28;
  uint64_t v29;
  _CUINineImagePieces *v33;
  _CUINineImagePieces *v34;

  v33 = [_CUINineImagePieces alloc];
  v19 = objc_msgSend(a8, "maskForSliceIndex:", 4);
  v20 = objc_msgSend(a8, "maskForSliceIndex:", 0);
  v21 = objc_msgSend(a8, "maskForSliceIndex:", 1);
  v22 = objc_msgSend(a8, "maskForSliceIndex:", 2);
  v23 = objc_msgSend(a8, "maskForSliceIndex:", 5);
  v24 = objc_msgSend(a8, "maskForSliceIndex:", 8);
  v25 = objc_msgSend(a8, "maskForSliceIndex:", 7);
  v26 = objc_msgSend(a8, "maskForSliceIndex:", 6);
  v27 = objc_msgSend(a8, "maskForSliceIndex:", 3);
  LOBYTE(v29) = objc_msgSend(a8, "isTiled");
  v34 = -[_CUINineImagePieces initWithCenter:topLeft:top:topRight:right:bottomRight:bottom:bottomLeft:left:tileCenterAndEdges:](v33, "initWithCenter:topLeft:top:topRight:right:bottomRight:bottom:bottomLeft:left:tileCenterAndEdges:", v19, v20, v21, v22, v23, v24, v25, v26, v27, v29);
  objc_msgSend(a8, "scale");
  DrawNinePartImageWithOperation(v34, a9, a12, a10, 0, a1, a2, a3, a4, v28, a5, a6);

}

void _CUITileImageWithOperation(void *a1, CGContext *a2, CGBlendMode a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, double a8, double a9, double a10)
{
  double v20;
  double v21;
  id v22;
  _QWORD v23[3];
  double v24;
  _QWORD v25[4];
  CGRect v26;

  if (a1 && !NSIsEmptyRect(*(NSRect *)&a4))
  {
    CGContextSaveGState(a2);
    if (a3)
      CGContextSetBlendMode(a2, a3);
    CGContextSetAlpha(a2, fabs(a9));
    *(CGFloat *)v25 = a4;
    *(CGFloat *)&v25[1] = a5;
    *(CGFloat *)&v25[2] = a6;
    *(CGFloat *)&v25[3] = a7;
    *(CGFloat *)v23 = a4;
    objc_msgSend(a1, "size");
    *(double *)&v23[2] = v20 * a10 / a8;
    v24 = v21 * a10 / a8;
    v26.origin.x = a4;
    v26.origin.y = a5;
    v26.size.width = a6;
    v26.size.height = a7;
    *(double *)&v23[1] = CGRectGetMaxY(v26) - v24;
    v22 = objc_msgSend(a1, "image");
    CGContextDrawImages(a2, v23, &v22, v25, 1);
    CGContextRestoreGState(a2);
  }
}

void sub_19EC2A6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_19EC2A8EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void FrameIntersectionWithAxis(double *a1, double *a2, double a3, double a4, double a5, double a6, long double a7)
{
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  char v19;
  double v20;
  double v21;
  double v22;
  double v23;

  v13 = remainder(a7, 360.0);
  if (v13 <= 90.0)
  {
    if (v13 >= -90.0)
    {
      v15 = a6 * 0.5;
      v16 = a4 + a6 * 0.5;
      if (v13 == 0.0)
      {
        v17 = a3 + a5;
        a4 = a4 + a6 * 0.5;
        goto LABEL_13;
      }
      v19 = 0;
      v18 = a5 * 0.5;
      v17 = a3 + a5 * 0.5;
LABEL_11:
      if (fabs(v13) == 90.0)
      {
        v16 = a4 + a6;
        a3 = v17;
        if (v13 < 0.0)
          goto LABEL_14;
      }
      else
      {
        v22 = tan(v13 * 3.14159265 / 180.0);
        v23 = v18 * v22;
        if (fabs(v18 * v22) <= v15)
        {
          a4 = v16 - v23;
          v17 = a3 + a5;
          v16 = v16 + v23;
        }
        else
        {
          a3 = v17 - v15 / v22;
          v17 = v17 + v15 / v22;
          v16 = a4 + a6;
          if (v22 < 0.0)
          {
            if ((v19 & 1) == 0)
              goto LABEL_14;
            goto LABEL_13;
          }
        }
        if ((v19 & 1) != 0)
          goto LABEL_14;
      }
LABEL_13:
      v20 = v17;
      v21 = v16;
      v17 = a3;
      v16 = a4;
      a3 = v20;
      a4 = v21;
      goto LABEL_14;
    }
    v14 = 180.0;
  }
  else
  {
    v14 = -180.0;
  }
  v13 = v13 + v14;
  v15 = a6 * 0.5;
  v16 = a4 + a6 * 0.5;
  if (v13 != 0.0)
  {
    v18 = a5 * 0.5;
    v17 = a3 + a5 * 0.5;
    v19 = 1;
    goto LABEL_11;
  }
  v17 = a3 + a5;
  a4 = a4 + a6 * 0.5;
LABEL_14:
  *a1 = v17;
  a1[1] = v16;
  *a2 = a3;
  a2[1] = a4;
}

id LinearGradientShaderFunction(void *a1, double *a2, _QWORD *a3)
{
  id result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = objc_msgSend(a1, "_smoothedGradientColorAtLocation:", *a2);
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

void GradientEvaluatorRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

Class initMDLVertexAttribute()
{
  Class result;

  __NSGetFrameworkReference_0();
  result = objc_getClass("MDLVertexAttribute");
  classMDLVertexAttribute = (uint64_t)result;
  if (!result)
    initMDLVertexAttribute_cold_1();
  getMDLVertexAttributeClass[0] = MDLVertexAttributeFunction;
  return result;
}

void __NSGetFrameworkReference_0()
{
  id v0;
  const char *v1;
  const char *v2;
  const char *v3;
  uint64_t i;
  void *v5;
  void *v6;
  id v7;
  char __str[1024];
  _QWORD v9[3];

  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
  v0 = objc_msgSend((id)__NSGetFrameworkReference_table_1, "objectForKey:", CFSTR("ModelIO"));
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
  if (!v0)
  {
    memset(v9, 0, sizeof(v9));
    v1 = (const char *)objc_msgSend(CFSTR("ModelIO"), "UTF8String");
    if (v1)
    {
      v2 = v1;
      v3 = "/System/Library/Frameworks/";
      for (i = 1; ; ++i)
      {
        if (snprintf(__str, 0x400uLL, "%s%s.framework/%s", v3, v2, v2) <= 1023)
        {
          v5 = dlopen(__str, 2);
          if (v5)
            break;
        }
        v3 = (const char *)v9[i];
        if (!v3)
          return;
      }
      v6 = v5;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
      v7 = (id)__NSGetFrameworkReference_table_1;
      if (!__NSGetFrameworkReference_table_1)
      {
        v7 = objc_msgSend(objc_alloc((Class)NSMapTable), "initWithKeyOptions:valueOptions:capacity:", 0, 2, 0);
        __NSGetFrameworkReference_table_1 = (uint64_t)v7;
      }
      if (!objc_msgSend(v7, "objectForKey:", CFSTR("ModelIO")))
        objc_msgSend((id)__NSGetFrameworkReference_table_1, "setObject:forKey:", v6, CFSTR("ModelIO"));
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
    }
  }
}

uint64_t MDLVertexAttributeFunction()
{
  return classMDLVertexAttribute;
}

Class initMDLVertexBufferLayout()
{
  Class result;

  __NSGetFrameworkReference_0();
  result = objc_getClass("MDLVertexBufferLayout");
  classMDLVertexBufferLayout = (uint64_t)result;
  if (!result)
    initMDLVertexBufferLayout_cold_1();
  getMDLVertexBufferLayoutClass[0] = MDLVertexBufferLayoutFunction;
  return result;
}

uint64_t MDLVertexBufferLayoutFunction()
{
  return classMDLVertexBufferLayout;
}

Class initMDLVertexDescriptor()
{
  Class result;

  __NSGetFrameworkReference_0();
  result = objc_getClass("MDLVertexDescriptor");
  classMDLVertexDescriptor = (uint64_t)result;
  if (!result)
    initMDLVertexDescriptor_cold_1();
  getMDLVertexDescriptorClass = MDLVertexDescriptorFunction;
  return result;
}

uint64_t MDLVertexDescriptorFunction()
{
  return classMDLVertexDescriptor;
}

Class initMDLMesh()
{
  Class result;

  __NSGetFrameworkReference_0();
  result = objc_getClass("MDLMesh");
  classMDLMesh = (uint64_t)result;
  if (!result)
    initMDLMesh_cold_1();
  getMDLMeshClass[0] = MDLMeshFunction;
  return result;
}

uint64_t MDLMeshFunction()
{
  return classMDLMesh;
}

uint64_t CUIThemeInfoVersion()
{
  return 1;
}

BOOL __copyBlock(uint64_t a1, uint64_t a2, const char *a3)
{
  unsigned int NamedBlock;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v27;

  NamedBlock = BOMStorageGetNamedBlock(a1, a3);
  if (!NamedBlock)
    return 1;
  v7 = NamedBlock;
  v8 = BOMStorageNewNamedBlock(a2, a3);
  v15 = BOMStorageSizeOfBlock(a1, v7, v9, v10, v11, v12, v13, v14);
  v16 = malloc_type_malloc(v15, 0xA14CACC5uLL);
  if (BOMStorageCopyFromBlock(a1, v7, v16, v17, v18, v19, v20, v21))
  {
    free(v16);
    return 0;
  }
  v27 = BOMStorageCopyToBlock(a2, v8, v16, v15, v22, v23, v24, v25);
  free(v16);
  if (v27)
    return 0;
  return BOMStorageCommit(a2) == 0;
}

uint64_t __copyTree(uint64_t a1, uint64_t a2, const char *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  char v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t **i;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _BOOL8 v63;

  v7 = BOMTreeOpenWithName(a1, a3, 0);
  if (!v7)
    return 1;
  v8 = v7;
  if (BOMTreePageSize(v7) <= 0x400)
    a4 = BOMTreePageSize(v8);
  v9 = BOMTreeUsesNumericKeys(v8);
  v10 = BOMTreeNewWithOptions(a2, 0, a3, a4, v9);
  if (!v10)
    return 0;
  v11 = (uint64_t)v10;
  v12 = (uint64_t **)BOMTreeIteratorNew(v8, 0, 0, 0);
  if (!v12)
    return 0;
  for (i = v12;
        !BOMTreeIteratorIsAtEnd((uint64_t)i, v13, v14, v15, v16, v17, v18, v19);
        BOMTreeIteratorNext((uint64_t)i, v56, v57, v58, v59, v60, v61, v62))
  {
    v28 = (void *)BOMTreeIteratorKey((uint64_t)i, v21, v22, v23, v24, v25, v26, v27);
    v36 = BOMTreeIteratorKeySize((uint64_t)i, v29, v30, v31, v32, v33, v34, v35);
    v44 = (const void *)BOMTreeIteratorValue((uint64_t)i, v37, v38, v39, v40, v41, v42, v43);
    v52 = BOMTreeIteratorValueSize(i, v45, v46, v47, v48, v49, v50, v51);
    BOMTreeSetValue(v11, v28, v36, v44, v52, v53, v54, v55);
  }
  v63 = BOMStorageCommit(a2) == 0;
  BOMTreeIteratorFree(i);
  BOMTreeFree(v11);
  return v63;
}

Class initMDLAsset()
{
  id v0;
  Class result;
  const char *v2;
  const char *v3;
  const char *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  char __str[1024];
  _QWORD v10[3];

  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
  v0 = objc_msgSend((id)__NSGetFrameworkReference_table_2, "objectForKey:", CFSTR("ModelIO"));
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
  if (!v0)
  {
    memset(v10, 0, sizeof(v10));
    v2 = (const char *)objc_msgSend(CFSTR("ModelIO"), "UTF8String");
    if (v2)
    {
      v3 = v2;
      v4 = "/System/Library/Frameworks/";
      v5 = 1;
      while (1)
      {
        if (snprintf(__str, 0x400uLL, "%s%s.framework/%s", v4, v3, v3) <= 1023)
        {
          v6 = dlopen(__str, 2);
          if (v6)
            break;
        }
        v4 = (const char *)v10[v5++];
        if (!v4)
          goto LABEL_2;
      }
      v7 = v6;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
      v8 = (id)__NSGetFrameworkReference_table_2;
      if (!__NSGetFrameworkReference_table_2)
      {
        v8 = objc_msgSend(objc_alloc((Class)NSMapTable), "initWithKeyOptions:valueOptions:capacity:", 0, 2, 0);
        __NSGetFrameworkReference_table_2 = (uint64_t)v8;
      }
      if (!objc_msgSend(v8, "objectForKey:", CFSTR("ModelIO")))
        objc_msgSend((id)__NSGetFrameworkReference_table_2, "setObject:forKey:", v7, CFSTR("ModelIO"));
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
    }
  }
LABEL_2:
  result = objc_getClass("MDLAsset");
  classMDLAsset = (uint64_t)result;
  if (!result)
    initMDLAsset_cold_1();
  getMDLAssetClass[0] = MDLAssetFunction;
  return result;
}

uint64_t MDLAssetFunction()
{
  return classMDLAsset;
}

vImage_Error CUIConvertCGImageFormat(CGImage *a1, CGColorSpace *a2, const vImage_CGImageFormat *a3, vImage_Buffer *a4)
{
  vImage_Error v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  vImageConverterRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  vImageConverter *v23;
  uint64_t rowBytes;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  vImage_Error error;
  vImage_CGImageFormat format;
  vImage_Buffer buf;

  memset(&buf, 0, sizeof(buf));
  format.bitsPerComponent = CGImageGetBitsPerComponent(a1);
  format.bitsPerPixel = CGImageGetBitsPerPixel(a1);
  format.colorSpace = a2;
  format.bitmapInfo = CGImageGetBitmapInfo(a1);
  memset(&format.version, 0, 20);
  v8 = vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0x100u);
  error = v8;
  if (v8)
  {
    _CUILog(4, (uint64_t)"CoreUI: CUIConvertCGImageFormat() [vImageBuffer_InitWithCGImage] failed error:'%d'", v9, v10, v11, v12, v13, v14, v8);
  }
  else
  {
    v15 = vImageConverter_CreateWithCGImageFormat(&format, a3, 0, 0x100u, &error);
    if (error)
    {
      _CUILog(4, (uint64_t)"CoreUI: CUIConvertCGImageFormat() [vImageConverter_CreateWithCGImageFormat] failed error:'%d'", v16, v17, v18, v19, v20, v21, error);
    }
    else
    {
      v23 = v15;
      rowBytes = a4->rowBytes;
      if (!rowBytes)
      {
        rowBytes = CGBitmapGetAlignedBytesPerRow(a4->width * ((unint64_t)a3->bitsPerPixel >> 3));
        a4->rowBytes = rowBytes;
      }
      if (!a4->data)
        a4->data = (void *)CGBitmapAllocateData(a4->height * rowBytes);
      error = vImageConvert_AnyToAny(v23, &buf, a4, 0, 0x100u);
      free(buf.data);
      if (error)
        _CUILog(4, (uint64_t)"CoreUI: CUIConvertCGImageFormat() [vImageConvert_AnyToAny] failed error:'%d'", v25, v26, v27, v28, v29, v30, error);
      vImageConverter_Release(v23);
    }
  }
  return error;
}

uint64_t CUICGImageGetAlphaInfo(CGImage *a1)
{
  uint64_t AlphaInfo;
  uint64_t v3;
  uint64_t v5;
  unsigned __int8 *data;
  unsigned __int8 *v7;
  vImagePixelCount width;
  int v9;
  vImage_Buffer dest;
  vImage_CGImageFormat format;
  vImage_Buffer buf;

  AlphaInfo = CGImageGetAlphaInfo(a1);
  v3 = AlphaInfo;
  if (AlphaInfo < 8 && ((0xE1u >> AlphaInfo) & 1) != 0)
    return dword_19EC72D80[(int)AlphaInfo];
  memset(&buf, 0, sizeof(buf));
  *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
  format.colorSpace = (CGColorSpaceRef)_CUIColorSpaceGetSRGB();
  format.bitmapInfo = 8194;
  memset(&format.version, 0, 20);
  if (!vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0x100u))
  {
    dest.height = buf.height;
    dest.width = buf.width;
    dest.rowBytes = buf.width;
    dest.data = malloc_type_malloc(buf.width * buf.height, 0xB4F88C1BuLL);
    if (vImageExtractChannel_ARGB8888(&buf, &dest, 3, 0))
    {
LABEL_5:
      free(buf.data);
      free(dest.data);
      return v3;
    }
    if (dest.height)
    {
      v5 = 0;
      data = (unsigned __int8 *)dest.data;
      while (1)
      {
        v7 = data;
        width = dest.width;
        if (dest.width)
          break;
LABEL_13:
        ++v5;
        data += dest.rowBytes;
        if (v5 == dest.height)
          goto LABEL_14;
      }
      while (1)
      {
        v9 = *v7++;
        if (v9 != 255)
          goto LABEL_5;
        if (!--width)
          goto LABEL_13;
      }
    }
LABEL_14:
    free(buf.data);
    free(dest.data);
    if ((v3 - 1) < 4)
      return dword_19EC72DA0[(int)v3 - 1];
  }
  return v3;
}

uint64_t CUIImageIsMonochrome(CGImage *a1)
{
  CGColorSpace *ColorSpace;
  uint64_t v3;
  vImagePixelCount height;
  vImagePixelCount width;
  size_t rowBytes;
  char *data;
  size_t v8;
  char *v9;
  size_t v10;
  char *v11;
  vImagePixelCount v12;
  vImage_Buffer v14;
  vImage_Buffer destR;
  vImage_Buffer destA;
  vImage_Buffer destB;
  vImage_CGImageFormat format;
  vImage_Buffer buf;

  ColorSpace = CGImageGetColorSpace(a1);
  if (CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelMonochrome)
    return 1;
  memset(&buf, 0, sizeof(buf));
  memset(&destB, 0, sizeof(destB));
  *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
  format.colorSpace = (CGColorSpaceRef)_CUIColorSpaceGetSRGB();
  format.bitmapInfo = 8194;
  memset(&format.version, 0, 20);
  if (!vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0x100u))
  {
    v14.height = buf.height;
    v14.width = buf.width;
    destR.height = buf.height;
    destR.width = buf.width;
    destA.height = buf.height;
    destA.width = buf.width;
    destB.height = buf.height;
    destB.width = buf.width;
    v14.rowBytes = buf.width;
    destR.rowBytes = buf.width;
    destA.rowBytes = buf.width;
    destB.rowBytes = buf.width;
    destB.data = malloc_type_malloc(buf.width * buf.height, 0xB5B2A470uLL);
    destA.data = malloc_type_malloc(buf.width * buf.height, 0x6EC18429uLL);
    destR.data = malloc_type_malloc(buf.width * buf.height, 0xE02BC0E1uLL);
    v14.data = malloc_type_malloc(buf.width * buf.height, 0x2779B308uLL);
    if (!vImageConvert_ARGB8888toPlanar8(&buf, &destA, &destR, &v14, &destB, 0))
    {
      height = destA.height;
      if (!destA.height)
      {
LABEL_12:
        free(buf.data);
        free(destA.data);
        v3 = 1;
        goto LABEL_13;
      }
      width = destA.width;
      rowBytes = destA.rowBytes;
      v8 = v14.rowBytes;
      data = (char *)destR.data;
      v10 = destR.rowBytes;
      v9 = (char *)destA.data;
      v11 = (char *)v14.data;
      v12 = v14.width;
      while (!memcmp(v9, data, width) && !memcmp(v11, data, v12))
      {
        v11 += v8;
        data += v10;
        v9 += rowBytes;
        if (!--height)
          goto LABEL_12;
      }
    }
    free(buf.data);
    free(destA.data);
    v3 = 0;
LABEL_13:
    free(destR.data);
    free(v14.data);
    free(destB.data);
    return v3;
  }
  return 0;
}

CGFloat CUICalcNonAlphaAreaOfImage(CGImage *a1)
{
  CGFloat y;
  double x;
  size_t Width;
  double v5;
  size_t Height;
  char *v7;
  vImage_Error v8;
  double v10;
  double v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  uint64_t v18;
  double v19;
  char *v20;
  int v21;
  char *v22;
  double v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  double v27;
  int v28;
  char *v29;
  double v30;
  vImage_Buffer dest;
  vImage_CGImageFormat format;
  vImage_Buffer buf;
  CGPoint v34;
  CGRect v35;

  memset(&buf, 0, sizeof(buf));
  x = CGRectZero.origin.x;
  y = CGRectZero.origin.y;
  Width = CGImageGetWidth(a1);
  v5 = (double)Width;
  Height = CGImageGetHeight(a1);
  v7 = (char *)malloc_type_malloc((unint64_t)((double)Width * (double)Height), 0x8BE3499DuLL);
  *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
  format.colorSpace = (CGColorSpaceRef)_CUIColorSpaceGetSRGB();
  format.bitmapInfo = 8195;
  memset(&format.version, 0, 20);
  if (vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0x100u)
    || (dest.width = buf.width,
        dest.rowBytes = buf.width,
        dest.data = v7,
        dest.height = buf.height,
        v8 = vImageExtractChannel_ARGB8888(&buf, &dest, 0, 0),
        free(buf.data),
        v8))
  {
    free(v7);
  }
  else
  {
    v10 = (double)Height;
    v11 = y;
    if (Height)
    {
      v12 = 0;
      v13 = v7;
      v11 = y;
      v10 = (double)Height;
      while (!Width)
      {
LABEL_11:
        v11 = v11 + 1.0;
        v10 = v10 + -1.0;
        ++v12;
        v13 += (unint64_t)v5;
        if ((double)(int)v12 >= (double)Height)
          goto LABEL_12;
      }
      v14 = 0;
      while (!v13[v14])
      {
        if ((double)(int)++v14 >= v5)
          goto LABEL_11;
      }
    }
LABEL_12:
    LODWORD(v15) = (int)(v10 + v11 + -1.0);
    if (v11 <= (double)(int)v15)
    {
      v15 = (int)v15;
      v25 = &v7[(unint64_t)v5 * (int)v15];
      while (!Width)
      {
LABEL_28:
        v10 = v10 + -1.0;
        --v15;
        v25 -= (unint64_t)v5;
        if (v11 > (double)(int)v15)
          goto LABEL_13;
      }
      v26 = 0;
      while (!v25[v26])
      {
        if ((double)(int)++v26 >= v5)
          goto LABEL_28;
      }
    }
LABEL_13:
    v16 = (double)Width;
    v17 = CGRectZero.origin.x;
    if (Width)
    {
      v18 = 0;
      v19 = v11 + v10;
      v20 = &v7[(unint64_t)v5 * (int)v11];
      v17 = CGRectZero.origin.x;
      v16 = (double)Width;
      while (1)
      {
        v21 = (int)v11 + 1;
        v22 = v20;
        if (v19 > (double)(int)v11)
          break;
LABEL_18:
        v17 = v17 + 1.0;
        v16 = v16 + -1.0;
        ++v18;
        ++v20;
        if ((double)(int)v18 >= v5)
          goto LABEL_19;
      }
      while (!*v22)
      {
        v22 += (unint64_t)v5;
        v23 = (double)v21++;
        if (v19 <= v23)
          goto LABEL_18;
      }
    }
LABEL_19:
    LODWORD(v24) = (int)(v16 + v17 + -1.0);
    if (v17 <= (double)(int)v24)
    {
      v27 = v11 + v10;
      v24 = (int)v24;
      while (1)
      {
        v28 = (int)v11 + 1;
        v29 = &v7[(unint64_t)v5 * (int)v11];
        if (v27 > (double)(int)v11)
          break;
LABEL_34:
        v16 = v16 + -1.0;
        if (v17 > (double)(int)--v24)
          goto LABEL_20;
      }
      while (!v29[v24])
      {
        v29 += (unint64_t)v5;
        v30 = (double)v28++;
        if (v27 <= v30)
          goto LABEL_34;
      }
    }
LABEL_20:
    free(v7);
    v35.origin.x = CGRectZero.origin.x;
    v35.origin.y = y;
    v35.size.width = (double)Width;
    v35.size.height = (double)Height;
    v34.x = v17;
    v34.y = v11;
    if (CGRectContainsPoint(v35, v34))
      return v17;
    else
      return CGPointZero.x;
  }
  return x;
}

uint64_t CUICalculateExtrusionMaskOfImage()
{
  return 29;
}

void CUIDrawExtrudedImageInContext(CGContext *a1, int a2, CGImageRef image, CGFloat a4, CGFloat a5, double a6, double a7)
{
  double Width;
  double Height;
  double v16;
  double v17;
  double v18;
  double v19;

  Width = (double)CGImageGetWidth(image);
  Height = (double)CGImageGetHeight(image);
  v19 = a5 + a7;
  if ((a2 & 0x10) != 0)
    __drawTextureInContext(a1, image, 0.0, 0.0, Width, 1.0, a4, v19);
  v18 = Height + -1.0;
  if ((a2 & 8) != 0)
    __drawTextureInContext(a1, image, 0.0, v18, Width, 1.0, a4, a5 + -1.0);
  if ((a2 & 1) != 0)
    __drawTextureInContext(a1, image, 0.0, 0.0, 1.0, Height, a4 + -1.0, a5);
  v16 = Width + -1.0;
  v17 = a4 + a6;
  if ((a2 & 4) != 0)
    __drawTextureInContext(a1, image, v16, 0.0, 1.0, Height, v17, a5);
  if ((~a2 & 0x11) == 0)
    __drawTextureInContext(a1, image, 0.0, 0.0, 1.0, 1.0, a4 + -1.0, v19);
  if ((~a2 & 9) == 0)
    __drawTextureInContext(a1, image, 0.0, v18, 1.0, 1.0, a4 + -1.0, a5 + -1.0);
  if ((~a2 & 0x14) == 0)
    __drawTextureInContext(a1, image, v16, 0.0, 1.0, 1.0, v17, v19);
  if ((~a2 & 0xC) == 0)
    __drawTextureInContext(a1, image, v16, v18, 1.0, 1.0, v17, a5 + -1.0);
}

void __drawTextureInContext(CGContext *a1, CGImageRef image, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGImage *v13;
  CGRect v14;

  if (image)
  {
    v13 = CGImageCreateWithImageInRect(image, *(CGRect *)&a3);
    v14.origin.x = a7;
    v14.origin.y = a8;
    v14.size.width = a5;
    v14.size.height = a6;
    CGContextDrawImage(a1, v14, v13);
    CGImageRelease(v13);
  }
}

CGImage *CUIConvertDeepImageTo8(CGImage *a1, CGColorSpace *a2)
{
  vImagePixelCount Height;
  vImagePixelCount Width;
  unsigned int v6;
  CGImageAlphaInfo AlphaInfo;
  uint32_t BitsPerComponent;
  uint32_t BitsPerPixel;
  int v10;
  BOOL v11;
  int v12;
  uint32_t v13;
  char v14;
  vImageConverter *v15;
  vImageConverter *v16;
  CGImage *v17;
  CGImageRef CopyWithColorSpace;
  vImage_Error v20;
  vImage_Error v21;
  vImage_CGImageFormat v22;
  vImage_Buffer dest;
  vImage_CGImageFormat destFormat;
  vImage_Error error;
  vImage_CGImageFormat format;
  vImage_Buffer dests;
  vImage_Buffer buf;

  dest.data = 0;
  v21 = 0;
  dest.rowBytes = 0;
  Height = CGImageGetHeight(a1);
  dest.height = Height;
  Width = CGImageGetWidth(a1);
  dest.width = Width;
  v22.bitsPerComponent = 8;
  v6 = 8 * CGImageGetBitsPerPixel(a1);
  v22.bitsPerPixel = v6 / CGImageGetBitsPerComponent(a1);
  AlphaInfo = CGImageGetAlphaInfo(a1);
  v22.bitmapInfo = AlphaInfo & 0xFFFFF0FF;
  v22.colorSpace = a2;
  memset(&v22.version, 0, 20);
  memset(&buf, 0, sizeof(buf));
  memset(&dests, 0, sizeof(dests));
  *((_DWORD *)&format.renderingIntent + 1) = 0;
  BitsPerComponent = CGImageGetBitsPerComponent(a1);
  format.bitsPerComponent = BitsPerComponent;
  BitsPerPixel = CGImageGetBitsPerPixel(a1);
  format.bitsPerPixel = BitsPerPixel;
  format.colorSpace = CGImageGetColorSpace(a1);
  format.bitmapInfo = CGImageGetBitmapInfo(a1);
  format.version = 0;
  format.decode = CGImageGetDecode(a1);
  format.renderingIntent = CGImageGetRenderingIntent(a1);
  if (vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0))
    return 0;
  v10 = BitsPerPixel / BitsPerComponent;
  *(_OWORD *)&destFormat.bitsPerComponent = *(_OWORD *)&v22.bitsPerComponent;
  *(_OWORD *)&destFormat.bitmapInfo = *(_OWORD *)&v22.bitmapInfo;
  v11 = (int)(BitsPerPixel / BitsPerComponent) > 4 || v10 == 2;
  if (v11)
    v12 = 8448;
  else
    v12 = 4096;
  if (v11)
    v13 = 32;
  else
    v13 = 16;
  destFormat.bitmapInfo = AlphaInfo & 0xFFFF80FF | v12;
  destFormat.decode = format.decode;
  *(_QWORD *)&destFormat.renderingIntent = *(_QWORD *)&v22.renderingIntent;
  if (v11)
    v14 = 5;
  else
    v14 = 4;
  destFormat.bitsPerComponent = v13;
  destFormat.bitsPerPixel = v10 << v14;
  error = vImageBuffer_Init(&dests, Height, Width, v10 << v14, 0);
  if (error)
  {
    free(buf.data);
    return 0;
  }
  v15 = vImageConverter_CreateWithCGImageFormat(&format, &destFormat, 0, 0, &error);
  if (error)
    goto LABEL_19;
  v16 = v15;
  error = vImageConvert_AnyToAny(v15, &buf, &dests, 0, 0);
  if (error)
  {
    vImageConverter_Release(v16);
LABEL_19:
    free(buf.data);
    free(dests.data);
    goto LABEL_20;
  }
  dest.rowBytes = CGBitmapGetAlignedBytesPerRow(dest.width * v10);
  dest.data = (void *)CGBitmapAllocateData(dest.height * dest.rowBytes);
  switch(v10)
  {
    case 1:
      v20 = vImageConvert_Planar16UtoPlanar8_dithered(&dests, &dest, 268435458, 0);
      break;
    case 3:
      v20 = vImageConvert_RGB16UtoRGB888_dithered(&dests, &dest, 268435458, 0);
      break;
    case 4:
      v20 = vImageConvert_ARGB16UtoARGB8888_dithered(&dests, &dest, 268435458, 0, 0);
      break;
    default:
      error = -21778;
      goto LABEL_33;
  }
  error = v20;
LABEL_33:
  free(buf.data);
  if (dests.data)
    free(dests.data);
  if (v16)
    vImageConverter_Release(v16);
LABEL_20:
  v21 = error;
  if (error)
    return 0;
  v17 = vImageCreateCGImageFromBuffer(&dest, &v22, 0, 0, 0x100u, &v21);
  if (CGImageGetColorSpace(v17) != a2)
  {
    CopyWithColorSpace = CGImageCreateCopyWithColorSpace(v17, a2);
    CGImageRelease(v17);
    return CopyWithColorSpace;
  }
  return v17;
}

BOOL CUIImageIsWideGamut(CGImage *a1)
{
  CGColorSpace *ColorSpace;

  ColorSpace = CGImageGetColorSpace(a1);
  if (!CGColorSpaceIsWideGamutRGB(ColorSpace))
    return 0;
  if (__CUIImageIsInsideSRGB___onceToken != -1)
    dispatch_once(&__CUIImageIsInsideSRGB___onceToken, &__block_literal_global_9);
  return !__CUIImageIsInsideSRGB___imageIsInsideSRGB || !__CUIImageIsInsideSRGB___imageIsInsideSRGB(a1);
}

vImage_Error CUIGetRGBAImageBuffer(CGImage *a1, uint64_t a2, vImage_Buffer *a3)
{
  CGColorSpace *ColorSpace;
  uint64_t ExtendedRangeSRGB;
  __int128 v8;
  uint64_t SRGB;
  vImage_CGImageFormat v11;

  if (CGImageGetBitsPerComponent(a1) < 9)
  {
    SRGB = _CUIColorSpaceGetSRGB();
    *(_QWORD *)a2 = 0x2000000008;
    *(_QWORD *)(a2 + 8) = SRGB;
    *(_DWORD *)(a2 + 16) = 2;
    *(_QWORD *)(a2 + 28) = 0;
    *(_QWORD *)(a2 + 20) = 0;
    return vImageBuffer_InitWithCGImage(a3, (vImage_CGImageFormat *)a2, 0, a1, 0x100u);
  }
  else
  {
    ColorSpace = CGImageGetColorSpace(a1);
    ExtendedRangeSRGB = _CUIColorSpaceGetExtendedRangeSRGB();
    *(_QWORD *)a2 = 0x8000000020;
    *(_QWORD *)(a2 + 8) = ExtendedRangeSRGB;
    *(_DWORD *)(a2 + 16) = 8452;
    *(_QWORD *)(a2 + 28) = 0;
    *(_QWORD *)(a2 + 20) = 0;
    v8 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&v11.bitsPerComponent = *(_OWORD *)a2;
    *(_OWORD *)&v11.bitmapInfo = v8;
    *(_QWORD *)&v11.renderingIntent = *(_QWORD *)(a2 + 32);
    return CUIConvertCGImageFormat(a1, ColorSpace, &v11, a3);
  }
}

void CUIDeallocateRGBAImageBuffer(uint64_t a1, void **a2)
{
  const void *v4;

  if (*a2)
  {
    if (*(_DWORD *)a1 == 8)
      free(*a2);
    else
      CGBitmapFreeData();
    *a2 = 0;
  }
  v4 = *(const void **)(a1 + 8);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t CUISDFTexturesSupported()
{
  return 0;
}

uint64_t CUICreateSDFEdgeTextureFromImage()
{
  os_variant_is_darwinos("com.apple.coreui");
  return 0;
}

uint64_t CUICreateSDFGradientTextureFromImage()
{
  os_variant_is_darwinos("com.apple.coreui");
  return 0;
}

uint64_t CUICreateSDFEdgeTexturePixelFormat()
{
  return 55;
}

uint64_t CUICreateSDFGradientTexturePixelFormat()
{
  return 32;
}

float64x2_t CG::Cubic::Cubic(CG::Cubic *this, const Point *a2, const Point *a3, const Point *a4, const Point *a5)
{
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t result;

  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  *((_OWORD *)this + 3) = *(_OWORD *)&a5->v;
  v5 = *((float64x2_t *)this + 1);
  v6 = vsubq_f64(v5, *(float64x2_t *)this);
  *((double *)this + 8) = 3.0 * v6.f64[0];
  *((double *)this + 9) = vmuld_lane_f64(3.0, v6, 1);
  v7 = *((float64x2_t *)this + 2);
  v8 = *((float64x2_t *)this + 3);
  v9 = vsubq_f64(v7, v5);
  v10 = vsubq_f64(v9, v6);
  *((double *)this + 10) = 3.0 * v10.f64[0];
  *((double *)this + 11) = vmuld_lane_f64(3.0, v10, 1);
  result = vaddq_f64(v6, vsubq_f64(vsubq_f64(v8, v7), vaddq_f64(v9, v9)));
  *((float64x2_t *)this + 6) = result;
  return result;
}

double cube::length(cube *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v27;
  double v28;
  _QWORD v30[319];

  v10 = (a5 - a3) * (a5 - a3) + (a4 - a2) * (a4 - a2);
  v11 = (a9 - a7) * (a9 - a7) + (a8 - a6) * (a8 - a6);
  v12 = 3.40282347e38;
  v13 = 3.40282347e38;
  if (v10 > 0.0)
    v13 = 1.0 / sqrt(v10);
  v14 = v10 * v13;
  if (v11 > 0.0)
    v12 = 1.0 / sqrt(v11);
  v15 = v11 * v12;
  v16 = fabs(v14 + v11 * v12);
  v17 = 0.0;
  if (v16 <= 0x7FEFFFFFFFFFFFFFLL)
  {
    LODWORD(v18) = 0;
    v19 = 1024;
    v20 = 1.0;
    do
    {
      v21 = (a7 - a5) * (a7 - a5) + (a6 - a4) * (a6 - a4);
      v22 = 3.40282347e38;
      if (v21 > 0.0)
        v22 = 1.0 / sqrt(v21);
      v23 = (a9 - a3) * (a9 - a3) + (a8 - a2) * (a8 - a2);
      v24 = 3.40282347e38;
      if (v23 > 0.0)
        v24 = 1.0 / sqrt(v23);
      v25 = v15 + v14 + v21 * v22;
      if (v25 - v23 * v24 > v20 * a10 && (int)v18 < 29)
      {
        v20 = v20 * 0.5;
        *(double *)&v30[(int)v18] = v20;
        *(double *)&v30[(int)v18 + 203] = a8;
        *(double *)&v30[(int)v18 + 29] = a9;
        *(double *)&v30[(int)v18 + 232] = (a6 + a8) * 0.5;
        *(double *)&v30[(int)v18 + 58] = (a7 + a9) * 0.5;
        *(double *)&v30[(int)v18 + 261] = (a8 + a4 + a6 * 2.0) * 0.25;
        *(double *)&v30[(int)v18 + 87] = (a9 + a5 + a7 * 2.0) * 0.25;
        a8 = (a8 + a2 + (a6 + a4) * 3.0) * 0.125;
        *(double *)&v30[(int)v18 + 290] = a8;
        a9 = (a9 + a3 + (a7 + a5) * 3.0) * 0.125;
        *(double *)&v30[(int)v18 + 116] = a9;
        a6 = (a6 + a2 + a4 * 2.0) * 0.25;
        *(double *)&v30[(int)v18 + 145] = v15 * 0.5;
        a7 = (a7 + a3 + a5 * 2.0) * 0.25;
        v27 = (a9 - a7) * (a9 - a7) + (a8 - a6) * (a8 - a6);
        if (v27 <= 0.0)
          v28 = 3.40282347e38;
        else
          v28 = 1.0 / sqrt(v27);
        a4 = (a4 + a2) * 0.5;
        a5 = (a5 + a3) * 0.5;
        v14 = v14 * 0.5;
        v15 = v27 * v28;
        *(double *)&v30[(int)v18 + 174] = v15;
        LODWORD(v18) = v18 + 1;
      }
      else
      {
        v17 = v17 + (v25 + v23 * v24) * 0.5;
        if (!(_DWORD)v18)
          return v17;
        v18 = (int)v18 - 1;
        a2 = *(double *)&v30[v18 + 290];
        a3 = *(double *)&v30[v18 + 116];
        a4 = *(double *)&v30[v18 + 261];
        a5 = *(double *)&v30[v18 + 87];
        a6 = *(double *)&v30[v18 + 232];
        a7 = *(double *)&v30[v18 + 58];
        a8 = *(double *)&v30[v18 + 203];
        a9 = *(double *)&v30[v18 + 29];
        v14 = *(double *)&v30[v18 + 174];
        v15 = *(double *)&v30[v18 + 145];
        v20 = *(double *)&v30[v18];
      }
      --v19;
    }
    while (v19);
    return 1.0;
  }
  return v17;
}

double CG::Cubic::length(CG::Cubic *this, double a2)
{
  return cube::length(this, *(double *)this, *((double *)this + 1), *((double *)this + 2), *((double *)this + 3), *((double *)this + 4), *((double *)this + 5), *((double *)this + 6), *((double *)this + 7), a2);
}

BOOL CUIEqualRenditionKeys(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  return CUICompareRenditionKey(a1, a2, a3) == 0;
}

id CUIPlaceHolderRendition(uint64_t a1, uint64_t a2)
{
  id result;
  uint64_t v3;
  int v4;

  result = (id)CUIPlaceHolderRendition_placeHolderRendition;
  if (!CUIPlaceHolderRendition_placeHolderRendition)
  {
    v4 = 0;
    v3 = 3538945;
    result = objc_msgSend((id)_LookupStructuredThemeProvider(0, a2), "renditionWithKey:", &v3);
    CUIPlaceHolderRendition_placeHolderRendition = (uint64_t)result;
  }
  return result;
}

void sub_19EC3DF1C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *__csiBlockDataProviderGetBytePointer(uint64_t a1)
{
  id *v2;
  unsigned __int16 *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *Weak;
  void *v26;
  uint64_t v27;
  int v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v43;
  NSString *v44;
  NSAssertionHandler *v45;

  v2 = (id *)(a1 + 48);
  v3 = (unsigned __int16 *)objc_msgSend(objc_loadWeak((id *)(a1 + 48)), "key");
  v4 = CUIRenditionKeyValueForAttribute(v3, 17);
  v5 = CUIRenditionKeyValueForAttribute(v3, 1);
  v6 = CUIRenditionKeyValueForAttribute(v3, 2);
  kdebug_trace(726663177, 3, v4, v5, v6);
  v7 = (unsigned int *)objc_msgSend(*(id *)(a1 + 24), "bytes");
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 16);
  v10 = v7[3];
  v11 = v7[4];
  v12 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8) - 2;
  v14 = (v12 >= 0xA || ((0x3CFu >> v12) & 1) == 0) && ((_DWORD)v10 != (_DWORD)v9 || (_DWORD)v11 != HIDWORD(v9));
  v15 = *(_QWORD *)(a1 + 8);
  v16 = v7[6];
  if (v16 <= 1195456543)
  {
    if (v16 == 1095911234)
    {
      v17 = 1;
      v18 = 1;
      if (!v14)
        goto LABEL_25;
      goto LABEL_37;
    }
    if (v16 == 1195454774)
    {
      v17 = 0;
      v18 = 5;
      if (v14)
        goto LABEL_37;
      goto LABEL_25;
    }
LABEL_36:
    v45 = +[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler");
    v44 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "const void * _Nullable __CUIBlockDataProviderGetBytePointer(void * _Nullable)");
    objc_msgSend(objc_loadWeak(v2), "name");
    v43 = "const void * _Nullable __CUIBlockDataProviderGetBytePointer(void * _Nullable)";
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](v45, "handleFailureInFunction:file:lineNumber:description:", v44, CFSTR("CUIThemeRendition.m"), 1707, CFSTR("CoreUI: %s unknown pixel format %d rendition '%@'"));
    v17 = 0;
    v18 = 0xFFFFFFFFLL;
    if (!v14)
      goto LABEL_25;
LABEL_37:
    v37 = (char *)-[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v9, SHIDWORD(v9), *(_QWORD *)(a1 + 112), v18);
    v38 = (uint64_t)v37;
    if (v37)
    {
      strlcpy(v37 + 48, (const char *)v8 + 40, 0x80uLL);
      *(_DWORD *)(v38 + 8) = v8[6];
      -[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:](v38, *(const UInt8 **)(a1 + 32), v15, v9, 1, v39, v40, v41);
      v26 = *(void **)(v38 + 16);
    }
    else
    {
      v26 = 0;
    }
    *(_QWORD *)(a1 + 80) = v38;
    goto LABEL_40;
  }
  if (v16 == 1195456544)
  {
    v18 = 2;
    v17 = 1;
    if (v14)
      goto LABEL_37;
    goto LABEL_25;
  }
  if (v16 == 1380401717)
  {
    v17 = 0;
    v18 = 6;
    if (v14)
      goto LABEL_37;
    goto LABEL_25;
  }
  if (v16 != 1380401751)
    goto LABEL_36;
  v17 = 0;
  v18 = 4;
  if (v14)
    goto LABEL_37;
LABEL_25:
  if (_CSIAcquireCachedBlockData(a1, v18))
  {
    if (v17 && (Weak = objc_loadWeak((id *)(a1 + 8 * v18 + 56))) != 0)
    {
      v26 = (void *)(Weak[2]
                   + 4 * (v8[6] == 1095911234) * *(_DWORD *)(a1 + 8)
                   + Weak[4] * *(unsigned int *)(a1 + 12));
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: image data is not available, returning a 1,1 image instead that is all black", v19, v20, v21, v22, v23, v24, (uint64_t)v43);
      v26 = &__CUIBlockDataProviderGetBytePointer___imageData;
    }
  }
  else
  {
    v27 = v10 | (v11 << 32);
    v28 = __bppFromBlockPixelFormat(v18);
    v29 = -[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v10, v11, *(_QWORD *)(a1 + 112), v18);
    v33 = v29;
    if (v29)
    {
      strlcpy((char *)v29 + 48, (const char *)v8 + 40, 0x80uLL);
      v33[2] = v8[6];
    }
    -[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:]((uint64_t)v33, *(const UInt8 **)(a1 + 32), 0, v27, 1, v30, v31, v32);
    v34 = _CSIStoreBlockData(a1, v33, v18);
    if (v34)
    {
      v35 = v34[2];
      v36 = v34[4];
    }
    else
    {
      v35 = 0;
      v36 = 0;
    }
    v26 = (void *)(v35 + (*(_DWORD *)(a1 + 8) * v28) + v36 * *(unsigned int *)(a1 + 12));
    *(_QWORD *)(a1 + 80) = v34;
  }
LABEL_40:
  kdebug_trace(726663178, 3, 0, 0, 0);
  return v26;
}

void __csiBlockDataReleaseBytePointer(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 80);
  *(_QWORD *)(a1 + 80) = 0;

}

void __csiImageProviderReleaseData(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));

  *(_QWORD *)(a1 + 24) = 0;
  v1 = *(void **)(a1 + 88);
  if (v1)
    objc_msgSend((id)+[_CSIRenditionBlockData sharedCache](), "removeObjectForKey:", v1);

  *(_QWORD *)(a1 + 88) = 0;
  v2 = *(void **)(a1 + 96);
  if (v2)
    objc_msgSend((id)+[_CSIRenditionBlockData sharedCache](), "removeObjectForKey:", v2);

  *(_QWORD *)(a1 + 96) = 0;
  v3 = *(void **)(a1 + 104);
  if (v3)
    objc_msgSend((id)+[_CSIRenditionBlockData sharedCache](), "removeObjectForKey:", v3);

  *(_QWORD *)(a1 + 104) = 0;
  objc_storeWeak((id *)(a1 + 56), 0);
  objc_storeWeak((id *)(a1 + 64), 0);
  objc_storeWeak((id *)(a1 + 72), 0);
  objc_storeWeak((id *)(a1 + 48), 0);

}

const UInt8 *__csiTextureDataLockData(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex *a4)
{
  *a4 = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  return CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
}

void _UnRegisterThemeRef(uint64_t a1)
{
  _QWORD v1[5];

  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = ___UnRegisterThemeRef_block_invoke;
  v1[3] = &__block_descriptor_40_e20_v16__0__NSMapTable_8l;
  v1[4] = a1;
  __PerformBlockWithThemeRegistry((uint64_t)v1);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

float64x2_t CG::Quadratic::Quadratic(CG::Quadratic *this, const Point *a2, const Point *a3, const Point *a4)
{
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t result;

  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  v4 = *((float64x2_t *)this + 1);
  v5 = vsubq_f64(v4, *(float64x2_t *)this);
  *((double *)this + 6) = v5.f64[0] + v5.f64[0];
  *((double *)this + 7) = v5.f64[1] + v5.f64[1];
  result = vsubq_f64(vsubq_f64(*((float64x2_t *)this + 2), v4), v5);
  *((float64x2_t *)this + 4) = result;
  return result;
}

BOOL CG::Quadratic::is_flat(CG::Quadratic *this, double a2)
{
  double v2;
  double v3;
  double v4;
  double v5;

  v2 = *((double *)this + 2);
  if (*(double *)this != v2 || *((double *)this + 1) != *((double *)this + 3))
  {
    v3 = *((double *)this + 4);
    if (v2 != v3)
    {
      v4 = *((double *)this + 5);
      v5 = *((double *)this + 3);
      return (v4 - v5 + *((double *)this + 1) - v5) * (v4 - v5 + *((double *)this + 1) - v5)
           + (*(double *)this - v2 + v3 - v2) * (*(double *)this - v2 + v3 - v2) < a2 * 16.0 * a2;
    }
    v5 = *((double *)this + 3);
    v4 = *((double *)this + 5);
    if (v5 != v4)
      return (v4 - v5 + *((double *)this + 1) - v5) * (v4 - v5 + *((double *)this + 1) - v5)
           + (*(double *)this - v2 + v3 - v2) * (*(double *)this - v2 + v3 - v2) < a2 * 16.0 * a2;
  }
  return 1;
}

uint64_t CG::Quadratic::length(CG::Quadratic *this, int a2)
{
  uint64_t result;
  _BYTE v5[80];
  uint64_t v6;

  result = CG::Quadratic::is_flat(this, 0.5);
  if (a2 <= 32 && !(_DWORD)result)
  {
    CG::Quadratic::split(this, 0.5, (uint64_t)v5);
    CG::Quadratic::length((CG::Quadratic *)v5, a2 + 1);
    return CG::Quadratic::length((CG::Quadratic *)&v6, a2 + 1);
  }
  return result;
}

double CG::Quadratic::split@<D0>(CG::Quadratic *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double result;

  v3 = *((double *)this + 2);
  v4 = *((double *)this + 3);
  v5 = *((double *)this + 1);
  v6 = *(double *)this + (v3 - *(double *)this) * a2;
  v7 = v5 + (v4 - v5) * a2;
  v8 = *((double *)this + 4);
  v9 = *((double *)this + 5);
  v10 = v3 + (v8 - v3) * a2;
  v11 = v4 + (v9 - v4) * a2;
  v12 = v6 + (v10 - v6) * a2;
  v13 = v7 + (v11 - v7) * a2;
  v14 = v6 - *(double *)this;
  v15 = v11 - v13 + v11 - v13;
  *(_QWORD *)a3 = *(_QWORD *)this;
  *(double *)(a3 + 8) = v5;
  *(double *)(a3 + 16) = v6;
  *(double *)(a3 + 24) = v7;
  *(double *)(a3 + 32) = v12;
  *(double *)(a3 + 40) = v13;
  *(double *)(a3 + 48) = v14 + v14;
  *(double *)(a3 + 56) = v7 - v5 + v7 - v5;
  *(double *)(a3 + 64) = v12 - v6 - v14;
  *(double *)(a3 + 72) = v13 - v7 - (v7 - v5);
  *(double *)(a3 + 80) = v12;
  *(double *)(a3 + 88) = v13;
  *(double *)(a3 + 96) = v10;
  *(double *)(a3 + 104) = v11;
  *(double *)(a3 + 112) = v8;
  *(double *)(a3 + 120) = v9;
  result = v9 - v11 - (v11 - v13);
  *(double *)(a3 + 128) = v10 - v12 + v10 - v12;
  *(double *)(a3 + 136) = v15;
  *(double *)(a3 + 144) = v8 - v10 - (v10 - v12);
  *(double *)(a3 + 152) = result;
  return result;
}

const __CFString *CUIEffectBlendModeToString(int a1)
{
  const __CFString *result;
  int v3;
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  int v10;
  BOOL v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  BOOL v17;
  const __CFString *v18;
  int v19;
  const __CFString *v20;
  const __CFString *v21;
  int v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;

  result = CFSTR("<unknown>");
  if (a1 > 1749838195)
  {
    if (a1 > 1852797548)
    {
      if (a1 > 1935766559)
      {
        v3 = 1984719219;
        v4 = CFSTR("CUIEffectBlendModeVividLight");
        v13 = CFSTR("CUIEffectBlendModeVibrantColorSourceOver");
        if (a1 != 1986229103)
          v13 = CFSTR("<unknown>");
        if (a1 == 1986227573)
          v14 = CFSTR("CUIEffectBlendModeVibrantColorMultiply");
        else
          v14 = v13;
        if (a1 != 1984719220)
          v4 = v14;
        v7 = 1935766560;
        v8 = CFSTR("CUIEffectBlendModeSaturation");
        v9 = CFSTR("CUIEffectBlendModeScreen");
        v10 = 1935897198;
        v11 = a1 == 1936553316;
        v12 = CFSTR("CUIEffectBlendModeExclusion");
        goto LABEL_24;
      }
      v3 = 1884055923;
      v24 = CFSTR("CUIEffectBlendModePassThrough");
      v25 = CFSTR("CUIEffectBlendModeSoftLight");
      if (a1 != 1934387572)
        v25 = CFSTR("<unknown>");
      if (a1 != 1885434739)
        v24 = v25;
      if (a1 == 1884055924)
        v4 = CFSTR("CUIEffectBlendModePinLight");
      else
        v4 = v24;
      v7 = 1852797549;
      v8 = CFSTR("CUIEffectBlendModeNormal");
      v22 = 1870030194;
      v23 = CFSTR("CUIEffectBlendModeOverlay");
    }
    else
    {
      if (a1 > 1818391149)
      {
        v3 = 1818850404;
        v4 = CFSTR("CUIEffectBlendModeLighten");
        v5 = CFSTR("CUIEffectBlendModeMultiply");
        if (a1 != 1836411936)
          v5 = CFSTR("<unknown>");
        if (a1 == 1819634976)
          v6 = CFSTR("CUIEffectBlendModeLuminosity");
        else
          v6 = v5;
        if (a1 != 1818850405)
          v4 = v6;
        v7 = 1818391150;
        v8 = CFSTR("CUIEffectBlendModeLinearBurn");
        v9 = CFSTR("CUIEffectBlendModeLinearDodge");
        v10 = 1818518631;
        v11 = a1 == 1818706796;
        v12 = CFSTR("CUIEffectBlendModeLighterColor");
LABEL_24:
        if (!v11)
          v12 = CFSTR("<unknown>");
        if (a1 != v10)
          v9 = v12;
        goto LABEL_55;
      }
      v3 = 1752524063;
      v20 = CFSTR("CUIEffectBlendModeColorBurn");
      v21 = CFSTR("CUIEffectBlendModeLinearLight");
      if (a1 != 1816947060)
        v21 = CFSTR("<unknown>");
      if (a1 != 1768188278)
        v20 = v21;
      if (a1 == 1752524064)
        v4 = CFSTR("CUIEffectBlendModeHue");
      else
        v4 = v20;
      v7 = 1749838196;
      v8 = CFSTR("CUIEffectBlendModeHardLight");
      v22 = 1749903736;
      v23 = CFSTR("CUIEffectBlendModeHardMix");
    }
    if (a1 == v22)
      v9 = v23;
    else
      v9 = CFSTR("<unknown>");
LABEL_55:
    if (a1 == v7)
      v16 = v8;
    else
      v16 = v9;
LABEL_68:
    if (a1 <= v3)
      return v16;
    else
      return v4;
  }
  if (a1 > 1668246641)
  {
    if (a1 > 1684633119)
    {
      v3 = 1717856629;
      v26 = CFSTR("CUIEffectBlendModeSubtract");
      if (a1 != 1718842722)
        v26 = CFSTR("<unknown>");
      if (a1 == 1717856630)
        v4 = CFSTR("CUIEffectBlendModeDivide");
      else
        v4 = v26;
      v16 = CFSTR("CUIEffectBlendModeColorDodge");
      v17 = a1 == 1684751212;
      v18 = CFSTR("CUIEffectBlendModeDarkerColor");
      v19 = 1684633120;
    }
    else
    {
      v3 = 1684629093;
      v15 = CFSTR("CUIEffectBlendModeDissolve");
      if (a1 != 1684632435)
        v15 = CFSTR("<unknown>");
      if (a1 == 1684629094)
        v4 = CFSTR("CUIEffectBlendModeDifference");
      else
        v4 = v15;
      v16 = CFSTR("CUIEffectBlendModeColor");
      v17 = a1 == 1684107883;
      v18 = CFSTR("CUIEffectBlendModeDarken");
      v19 = 1668246642;
    }
    if (!v17)
      v18 = CFSTR("<unknown>");
    if (a1 != v19)
      v16 = v18;
    goto LABEL_68;
  }
  switch(a1)
  {
    case 0:
      result = CFSTR("CUIEffectBlendModeSourceOver");
      break;
    case 16:
      result = CFSTR("CUIEffectBlendModeClear");
      break;
    case 17:
      result = CFSTR("CUIEffectBlendModeCopy");
      break;
    case 18:
      result = CFSTR("CUIEffectBlendModeSourceIn");
      break;
    case 19:
      result = CFSTR("CUIEffectBlendModeSourceOut");
      break;
    case 20:
      result = CFSTR("CUIEffectBlendModeSourceAtop");
      break;
    case 21:
      result = CFSTR("CUIEffectBlendModeDestinationOver");
      break;
    case 22:
      result = CFSTR("CUIEffectBlendModeDestinationIn");
      break;
    case 23:
      result = CFSTR("CUIEffectBlendModeDestinationOut");
      break;
    case 24:
      result = CFSTR("CUIEffectBlendModeDestinationAtop");
      break;
    case 25:
      result = CFSTR("CUIEffectBlendModeXOR");
      break;
    case 26:
      result = CFSTR("CUIEffectBlendModePlusDarker");
      break;
    case 27:
      result = CFSTR("CUIEffectBlendModePlusLighter");
      break;
    default:
      return result;
  }
  return result;
}

const __CFString *CUIEffectBlendModeDescription(int a1)
{
  int v1;
  char **i;
  int v3;

  if (a1)
    v1 = a1;
  else
    v1 = 1852797549;
  if ("Normal")
  {
    if (v1 == *(_DWORD *)"mron")
      return (const __CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    for (i = &off_1E41B2620; *i; i += 3)
    {
      v3 = *((_DWORD *)i - 4);
      if (v1 == v3)
        return (const __CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    }
  }
  return CFSTR("<unknown>");
}

const __CFString *CUIEffectBevelStyleDescription(int a1)
{
  char **i;
  int v2;

  if ("Outer")
  {
    if (!a1)
      return (const __CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    for (i = &off_1E41B2B48; *i; i += 3)
    {
      v2 = *((_DWORD *)i - 4);
      if (v2 == a1)
        return (const __CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    }
  }
  return CFSTR("<unknown>");
}

CFStringRef CUICopyFingerPrintForImage(CGImage *a1)
{
  vImage_Error v2;
  CFStringRef result;
  vImageConverterRef v4;
  uint64_t v5;
  uint64_t v6;
  vImageConverter *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BOOL8 v12;
  _BOOL8 v13;
  vImage_Buffer dest;
  vImage_Buffer dests;
  CGFloat backgroundColor;
  vImage_CGImageFormat destFormat;
  vImage_Error error;
  vImage_CGImageFormat format;
  vImage_Buffer buf;
  _BYTE v21[64];

  memset(&buf, 0, sizeof(buf));
  format.bitsPerComponent = CGImageGetBitsPerComponent(a1);
  format.bitsPerPixel = CGImageGetBitsPerPixel(a1);
  format.colorSpace = CGImageGetColorSpace(a1);
  format.bitmapInfo = CGImageGetBitmapInfo(a1);
  memset(&format.version, 0, 20);
  v2 = vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0x100u);
  result = 0;
  error = v2;
  if (!v2)
  {
    *(_QWORD *)&destFormat.bitsPerComponent = 0x800000008;
    memset(&destFormat.bitmapInfo, 0, 24);
    destFormat.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
    backgroundColor = 0.0;
    v4 = vImageConverter_CreateWithCGImageFormat(&format, &destFormat, &backgroundColor, 0x100u, &error);
    v5 = 0;
    v6 = 0;
    if (!error)
    {
      v7 = v4;
      dests.height = buf.height;
      dests.width = buf.width;
      dests.rowBytes = buf.width * destFormat.bitsPerPixel;
      dests.data = malloc_type_calloc(dests.rowBytes * buf.height, 1uLL, 0x8379E552uLL);
      v5 = 0;
      v6 = 0;
      error = vImageConvert_AnyToAny(v7, &buf, &dests, 0, 0x110u);
      if (!error)
      {
        *(int64x2_t *)&dest.height = vdupq_n_s64(8uLL);
        dest.rowBytes = 8;
        dest.data = v21;
        v5 = 0;
        v6 = 0;
        error = vImageScale_Planar8(&dests, &dest, 0, 0x120u);
        if (!error)
        {
          if (dest.height)
          {
            v8 = 0;
            v9 = 0;
            v6 = 0;
            v5 = 0;
            v10 = v21;
            do
            {
              if (dest.width)
              {
                v11 = 0;
                do
                {
                  v12 = (unint64_t)(v8 + v11 + 1) <= 0x40
                     && v10[v11] < v10[v11 + 1];
                  v13 = dest.width + v8 + v11 <= 0x40
                     && v10[v11] < v10[dest.width + v11];
                  v5 = v12 | (2 * v5);
                  v6 = v13 | (2 * v6);
                  ++v11;
                }
                while (dest.width != v11);
              }
              ++v9;
              v10 += dest.width;
              v8 += dest.width;
            }
            while (v9 != dest.height);
          }
          else
          {
            v5 = 0;
            v6 = 0;
          }
        }
        free(dests.data);
      }
      vImageConverter_Release(v7);
    }
    free(buf.data);
    CGColorSpaceRelease(destFormat.colorSpace);
    if (error)
      return 0;
    else
      return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%llx%llx"), v5, v6);
  }
  return result;
}

BOOL _CUIDebugUseSimplifiedTextAntialiasing()
{
  if (__CUIDebugAllowDebugging___once != -1)
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_16);
  return __CUIDebugAllowDebugging___AllowDebugPrefs
      && -[NSUserDefaults BOOLForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "BOOLForKey:", CFSTR("CUIUseSimplifiedTextAntialiasing"));
}

uint64_t _CUIDebugUseSimplifiedTextEffects()
{
  id v0;

  if (__CUIDebugAllowDebugging___once != -1)
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_16);
  if (__CUIDebugAllowDebugging___AllowDebugPrefs
    && (v0 = -[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("CUIUseSimplifiedTextEffects"))) != 0)
  {
    return (uint64_t)objc_msgSend(v0, "BOOLValue");
  }
  else
  {
    return 1;
  }
}

id _CUIDebugAllowHardwareRendering()
{
  id v0;

  if (__CUIDebugAllowDebugging___once != -1)
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_16);
  if (__CUIDebugAllowDebugging___AllowDebugPrefs
    && (v0 = -[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("CUIAllowHardwareRendering"))) != 0)
  {
    return objc_msgSend(v0, "BOOLValue");
  }
  else
  {
    return 0;
  }
}

BOOL _CUIDebugUseStandardRendering()
{
  if (__CUIDebugAllowDebugging___once != -1)
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_16);
  return __CUIDebugAllowDebugging___AllowDebugPrefs
      && -[NSUserDefaults BOOLForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "BOOLForKey:", CFSTR("CUIUseStandardRendering"));
}

BOOL _CUIDebugShowGraphicVariantMetrics()
{
  if (__CUIDebugAllowDebugging___once != -1)
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_16);
  return __CUIDebugAllowDebugging___AllowDebugPrefs
      && -[NSUserDefaults BOOLForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "BOOLForKey:", CFSTR("CUIShowGraphicVariantMetrics"));
}

const void *CUIConstantToMapID(void *key)
{
  if (InitializeDictionaries(void)::sMutexInitConstantsDict == -1)
  {
    if (key)
      return CFDictionaryGetValue((CFDictionaryRef)gConstants, key);
  }
  else
  {
    dispatch_once(&InitializeDictionaries(void)::sMutexInitConstantsDict, &__block_literal_global_18);
    if (key)
      return CFDictionaryGetValue((CFDictionaryRef)gConstants, key);
  }
  return 0;
}

CFDictionaryRef ___ZL22InitializeDictionariesv_block_invoke()
{
  CFDictionaryRef result;
  const void *__dst[1228];
  const void *v2[1228];

  memcpy(v2, off_1E41B6578, sizeof(v2));
  memcpy(__dst, &unk_19EC73290, sizeof(__dst));
  gConstants = (uint64_t)CFDictionaryCreate(kCFAllocatorDefault, v2, __dst, 1228, &kCFTypeDictionaryKeyCallBacks, 0);
  result = CFDictionaryCreate(kCFAllocatorDefault, __dst, v2, 1228, 0, &kCFTypeDictionaryValueCallBacks);
  gIDs = (uint64_t)result;
  return result;
}

void sub_19EC4AD58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1AEEB08](v1, 0x10B1C407992E97CLL);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSDGradientColorStop>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

CGContext *CreateARGBBitmapContext(CGFloat a1, CGFloat a2, CGFloat a3)
{
  CGColorSpace *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CGColorSpace *v13;
  CGContext *BitmapContext;
  uint64_t v16;

  v6 = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);
  if (v6)
  {
    v13 = v6;
    BitmapContext = CreateBitmapContext(4, v6, 2, a1, a2, a3, v8, v9, v10, v11, v12);
    CGColorSpaceRelease(v13);
    return BitmapContext;
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CreateARGBBitmapContext() couldln't lookup colorspace kCGColorSpaceSRGB", v7, v8, v9, v10, v11, v12, v16);
    return 0;
  }
}

CGContext *CreateBitmapContext(uint64_t a1, CGColorSpaceRef space, uint64_t a3, CGFloat a4, CGFloat a5, CGFloat a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CGContext *v20;
  uint64_t v22;
  CGRect v23;

  v20 = CUICGBitmapContextCreate((unint64_t)(a4 * a6), (unint64_t)(a5 * a6), 8uLL, (unint64_t)(a4 * a6) * a1, space, a3, a10, a11);
  if (!v20)
    _CUILog(4, (uint64_t)"CoreUI: CreateBitmapContext() Context not created!", v14, v15, v16, v17, v18, v19, v22);
  CGContextScaleCTM(v20, a6, a6);
  v23.origin.x = 0.0;
  v23.origin.y = 0.0;
  v23.size.width = a4;
  v23.size.height = a5;
  CGContextClearRect(v20, v23);
  return v20;
}

unint64_t CUIGetChannelDataForImage(CGImage *a1, void **a2, CGFloat a3, CGFloat a4)
{
  CGContext *ARGBBitmapContext;
  CGContext *v9;
  size_t Width;
  size_t Height;
  void *Data;
  unint64_t v13;
  unint64_t v14;
  void *v15;
  void *v16;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  vImage_Error v23;
  vImage_Buffer destB;
  vImage_Buffer destG;
  vImage_Buffer destR;
  vImage_Buffer destA;
  vImage_Buffer dest;
  vImage_Buffer src;
  CGRect v31;

  ARGBBitmapContext = CreateARGBBitmapContext(a3, a4, 1.0);
  if (ARGBBitmapContext)
  {
    v9 = ARGBBitmapContext;
    Width = CGImageGetWidth(a1);
    Height = CGImageGetHeight(a1);
    v31.size.width = (double)Width;
    v31.size.height = (double)Height;
    v31.origin.x = 0.0;
    v31.origin.y = 0.0;
    CGContextDrawImage(v9, v31, a1);
    Data = CGBitmapContextGetData(v9);
    if (Data)
    {
      v13 = (unint64_t)a3;
      v14 = (unint64_t)a4;
      src.data = Data;
      src.height = (unint64_t)a4;
      src.width = (unint64_t)a3;
      src.rowBytes = 4 * (unint64_t)a3;
      v15 = malloc_type_malloc(src.rowBytes * (unint64_t)a4, 0x96826F0EuLL);
      dest.data = v15;
      dest.height = (unint64_t)a4;
      dest.width = (unint64_t)a3;
      dest.rowBytes = src.rowBytes;
      if (vImageUnpremultiplyData_ARGB8888(&src, &dest, 0))
      {
        v16 = v15;
      }
      else
      {
        v18 = 0;
        v17 = v14 * v13;
        do
          a2[v18++] = malloc_type_malloc(v14 * v13, 0xC0EBB067uLL);
        while (v18 != 4);
        v19 = malloc_type_malloc(v14 * v13, 0xAA606C00uLL);
        destA.data = *a2;
        destA.height = (unint64_t)a4;
        destA.width = (unint64_t)a3;
        destA.rowBytes = (unint64_t)a3;
        v20 = malloc_type_malloc(v14 * v13, 0x14244FFDuLL);
        destR.data = a2[1];
        destR.height = (unint64_t)a4;
        destR.width = (unint64_t)a3;
        destR.rowBytes = (unint64_t)a3;
        v21 = malloc_type_malloc(v14 * v13, 0xBA518CB1uLL);
        destG.data = a2[2];
        destG.height = (unint64_t)a4;
        destG.width = (unint64_t)a3;
        destG.rowBytes = (unint64_t)a3;
        v22 = malloc_type_malloc(v14 * v13, 0x15196A3CuLL);
        destB.data = a2[3];
        destB.height = (unint64_t)a4;
        destB.width = (unint64_t)a3;
        destB.rowBytes = (unint64_t)a3;
        v23 = vImageConvert_ARGB8888toPlanar8(&dest, &destA, &destR, &destG, &destB, 0);
        free(v15);
        if (!v23)
          goto LABEL_12;
        free(v19);
        free(v20);
        free(v21);
        v16 = v22;
      }
      free(v16);
    }
    v17 = 0;
LABEL_12:
    CGContextRelease(v9);
    return v17;
  }
  return 0;
}

double _CUIEffectiveScaleForContext(CGContext *a1)
{
  double v1;
  double v2;
  double result;
  CGAffineTransform v4;

  if (!a1)
    return 1.0;
  CGContextGetCTM(&v4, a1);
  v1 = v4.a * v4.d - v4.b * v4.c;
  v2 = sqrt(v1);
  result = sqrt(-v1);
  if (v1 >= 0.0)
    return v2;
  return result;
}

uint64_t _CUICreateNewContinuousRoundedRect(__n128 a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  return CGPathCreateWithContinuousRoundedRect(0, a1, a2, a3, a4, a5, a5.n128_f64[0]);
}

void sub_19EC4D104(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_19EC4DBB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19EC4DE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CUIRenditionKey *CUICreateRenditionKeyWithShapeEffectState(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 a6)
{
  __int16 v6;
  __int16 v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  _WORD v12[14];
  int v13;

  if (a1 > 0x17)
    v6 = 0;
  else
    v6 = word_19EC75942[a1];
  v7 = 0;
  v8 = 1;
  switch(a2)
  {
    case 1:
      v7 = 2;
      goto LABEL_9;
    case 2:
      v7 = 4;
      goto LABEL_9;
    case 3:
      v7 = 1;
      goto LABEL_9;
    case 4:
      goto LABEL_14;
    case 5:
      v7 = 5;
      goto LABEL_9;
    default:
LABEL_9:
      if (a4 == 1)
      {
        v8 = 1;
      }
      else if (a4 == 2)
      {
        v8 = 2;
      }
      else
      {
        v8 = 0;
      }
LABEL_14:
      v12[0] = 1;
      v12[1] = v6;
      v12[2] = 2;
      if (a5 == 1)
        v9 = 179;
      else
        v9 = 178;
      v12[3] = v9;
      v12[4] = 10;
      v12[5] = v7;
      v12[6] = 6;
      v12[7] = v8;
      v12[8] = 14;
      v12[9] = a3 == 1;
      v12[10] = 8;
      v12[11] = a6;
      v12[12] = 12;
      if (a5 == 144)
        v10 = 2;
      else
        v10 = 1;
      v12[13] = v10;
      v13 = 0;
      return -[CUIRenditionKey initWithKeyList:]([CUIRenditionKey alloc], "initWithKeyList:", v12);
  }
}

uint64_t CGBitmapDataProviderReleaseData(uint64_t a1, uint64_t a2)
{
  return CGBitmapFreeData(a2);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t CUIGetDeviceArtworkDisplayGamut()
{
  if (__getDeviceTraits___getDeviceTraits_once != -1)
    dispatch_once(&__getDeviceTraits___getDeviceTraits_once, &__block_literal_global_464);
  return __getDeviceTraits___deviceDisplayGamut;
}

uint64_t __blockSetRetain(uint64_t a1, uint64_t a2)
{
  return CGImageBlockSetRetain(a2);
}

uint64_t __blockSetRelease(uint64_t a1, uint64_t a2)
{
  return CGImageBlockSetRelease(a2);
}

uint64_t _StreamSys_init_read(unint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;

  v16 = 0;
  if (!(a1 | a2) || BomSys_init(&v16, a2))
    return 0xFFFFFFFFLL;
  BomSys_set_read(v16, (uint64_t)__StreamSys_read, v3, v4, v5, v6, v7, v8);
  BomSys_set_close(v16, (uint64_t)__StreamSys_close, v10, v11, v12, v13, v14, v15);
  result = 0;
  if (a1)
    *(_QWORD *)a1 = v16;
  return result;
}

CFIndex __StreamSys_read(__CFReadStream *a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  return CFReadStreamRead(a1, buffer, bufferLength);
}

uint64_t __StreamSys_close(__CFReadStream *a1)
{
  CFReadStreamClose(a1);
  return 0;
}

uint64_t _StreamSys_init_write(unint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;

  v16 = 0;
  if (!(a1 | a2) || BomSys_init(&v16, a2))
    return 0xFFFFFFFFLL;
  BomSys_set_write(v16, (uint64_t)__StreamSys_write, v3, v4, v5, v6, v7, v8);
  BomSys_set_close(v16, (uint64_t)__StreamSys_close, v10, v11, v12, v13, v14, v15);
  result = 0;
  if (a1)
    *(_QWORD *)a1 = v16;
  return result;
}

CFIndex __StreamSys_write(__CFWriteStream *a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  return CFWriteStreamWrite(a1, buffer, bufferLength);
}

uint64_t _BOMFileNewFromCFReadStreamSys(_QWORD *a1, __int128 *a2, char a3)
{
  if (BOMFileNewFromFDWithSys(a1, 0, a3, "r", a2))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t _BOMFileNewFromCFWriteStreamSys(_QWORD *a1, __int128 *a2, char a3)
{
  if (BOMFileNewFromFDWithSys(a1, 0, a3, "w", a2))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

BOOL sub_19EC5EF2C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t sub_19EC5EF40()
{
  sub_19EC66F00();
  sub_19EC66F0C();
  return sub_19EC66F18();
}

uint64_t sub_19EC5EF84()
{
  return sub_19EC66F0C();
}

uint64_t sub_19EC5EFAC()
{
  sub_19EC66F00();
  sub_19EC66F0C();
  return sub_19EC66F18();
}

uint64_t sub_19EC5EFEC()
{
  _BYTE *v0;
  uint64_t v1;

  v1 = 0x70616C7265766FLL;
  if (*v0 != 1)
    v1 = 0x7265746661;
  if (*v0)
    return v1;
  else
    return 0x65726F666562;
}

unint64_t sub_19EC5F044()
{
  unint64_t result;

  result = qword_1EE534380;
  if (!qword_1EE534380)
  {
    result = MEMORY[0x1A1AEF408](&unk_19EC75AFC, &type metadata for BezierPath.Segment.RelativePosition);
    atomic_store(result, (unint64_t *)&qword_1EE534380);
  }
  return result;
}

ValueMetadata *type metadata accessor for BezierPath()
{
  return &type metadata for BezierPath;
}

uint64_t initializeBufferWithCopyOfBuffer for BezierPath.Segment(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a2;
  *a1 = *a2;
  v3 = v2 + 16;
  swift_retain(v2);
  return v3;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for BezierPath.Segment(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 64))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for BezierPath.Segment(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_QWORD *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = (a2 - 1);
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 64) = v3;
  return result;
}

ValueMetadata *type metadata accessor for BezierPath.Segment()
{
  return &type metadata for BezierPath.Segment;
}

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for BezierPath.Segment.RelativePosition(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFE)
    goto LABEL_17;
  if (a2 + 2 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 2) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 2;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 2;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 2;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 3;
  v8 = v6 - 3;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for BezierPath.Segment.RelativePosition(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_19EC5F234 + 4 * byte_19EC75AF5[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_19EC5F268 + 4 * byte_19EC75AF0[v4]))();
}

uint64_t sub_19EC5F268(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_19EC5F270(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x19EC5F278);
  return result;
}

uint64_t sub_19EC5F284(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x19EC5F28CLL);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_19EC5F290(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_19EC5F298(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_19EC5F2A4(unsigned __int8 *a1)
{
  return *a1;
}

_BYTE *sub_19EC5F2AC(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

ValueMetadata *type metadata accessor for BezierPath.Segment.RelativePosition()
{
  return &type metadata for BezierPath.Segment.RelativePosition;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t sub_19EC5F2D0(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 16))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

uint64_t sub_19EC5F2F0(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_QWORD *)result = (a2 - 1);
    *(_QWORD *)(result + 8) = 0;
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 16) = v3;
  return result;
}

void type metadata accessor for CGPoint(uint64_t a1)
{
  sub_19EC5F42C(a1, &qword_1EE534388, (uint64_t)&unk_1E41A8698);
}

void type metadata accessor for CGMutablePath(uint64_t a1)
{
  sub_19EC5F42C(a1, &qword_1EE534390, (uint64_t)&unk_1EE533CE0);
}

uint64_t sub_19EC5F340(uint64_t a1)
{
  uint64_t v2;

  type metadata accessor for CGPath(255);
  *(_QWORD *)(a1 + 16) = v2;
  return 0;
}

void type metadata accessor for CGPath(uint64_t a1)
{
  sub_19EC5F42C(a1, &qword_1EE534398, (uint64_t)&unk_1E41A8718);
}

uint64_t sub_19EC5F384(uint64_t a1, int a2)
{
  int v3;

  if (!a2)
    return 0;
  if (a2 != 1 && *(_BYTE *)(a1 + 16))
    return (*(_DWORD *)a1 + 2);
  if (*(_QWORD *)(a1 + 8))
    v3 = -1;
  else
    v3 = 0;
  return (v3 + 1);
}

uint64_t sub_19EC5F3C8(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(_QWORD *)result = a2 - 2;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 2)
      *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    if (a3 >= 2)
      *(_BYTE *)(result + 16) = 0;
    if (a2)
      *(_QWORD *)(result + 8) = 0;
  }
  return result;
}

void type metadata accessor for CGPathElement(uint64_t a1)
{
  sub_19EC5F42C(a1, &qword_1EE5343A0, (uint64_t)&unk_1E41A85F8);
}

void type metadata accessor for CGPathElementType(uint64_t a1)
{
  sub_19EC5F42C(a1, &qword_1EE5343A8, (uint64_t)&unk_1E41A8678);
}

void sub_19EC5F42C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t ForeignTypeMetadata;
  uint64_t v5;

  if (!*a2)
  {
    ForeignTypeMetadata = swift_getForeignTypeMetadata(0, a3);
    if (!v5)
      atomic_store(ForeignTypeMetadata, a2);
  }
}

_QWORD *BOMBufferAllocate(size_t a1)
{
  _QWORD *v2;
  void *v3;

  v2 = BOM_malloczero(0x48uLL);
  v3 = malloc_type_valloc(a1, 0xA28A8515uLL);
  v2[3] = v3;
  *v2 = a1;
  if (v3)
  {
    __CFSetLastAllocationEventName(v3, "CUIBOM_BOMBufferAllocate");
  }
  else
  {
    free(v2);
    return 0;
  }
  return v2;
}

void BOMBufferDeallocate(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    a1[8] = 0;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

_QWORD *BOMBufferPoolAllocate(size_t a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v6;

  v4 = BOM_malloczero(0xA0uLL);
  if (pthread_cond_init((pthread_cond_t *)v4 + 1, 0))
    goto LABEL_4;
  if (pthread_mutex_init((pthread_mutex_t *)(v4 + 12), 0))
  {
    pthread_cond_destroy((pthread_cond_t *)v4 + 1);
LABEL_4:
    free(v4);
    return 0;
  }
  *v4 = 0;
  v4[1] = 0;
  v4[2] = a2;
  v4[3] = a1;
  v4[4] = 0;
  v4[5] = v4 + 4;
  if (a2 >= 0x40)
    a2 = 64;
  if (a2)
  {
    while (1)
    {
      v6 = BOMBufferAllocate(a1);
      if (!v6)
        break;
      --v4[2];
      BOMBufferPoolAddBuffer((uint64_t)v4, (uint64_t)v6);
      if (!--a2)
        return v4;
    }
    BOMBufferPoolDeallocate((uint64_t)v4);
    return 0;
  }
  return v4;
}

void BOMBufferPoolDeallocate(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 96);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)) && !pthread_mutex_unlock(v2))
    {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 48));
      pthread_mutex_destroy(v2);
      while (1)
      {
        v3 = *(_QWORD *)(a1 + 32);
        if (!v3)
          break;
        v4 = *(_QWORD *)(v3 + 56);
        v5 = *(_QWORD **)(v3 + 64);
        if (v4)
        {
          *(_QWORD *)(v4 + 64) = v5;
          v5 = *(_QWORD **)(v3 + 64);
        }
        else
        {
          *(_QWORD *)(a1 + 40) = v5;
        }
        *v5 = v4;
        BOMBufferDeallocate((void **)v3);
      }
      *(_QWORD *)(a1 + 64) = 0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
  }
}

uint64_t BOMBufferPoolAddBuffer(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  v4 = (pthread_mutex_t *)(a1 + 96);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!(_DWORD)result)
  {
    v6 = (_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a2 + 56) = v7;
    if (v7)
      v8 = (_QWORD *)(v7 + 64);
    else
      v8 = (_QWORD *)(a1 + 40);
    *v8 = a2 + 56;
    *v6 = a2;
    *(_QWORD *)(a2 + 64) = v6;
    *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a1, vdupq_n_s64(1uLL));
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  }
  return result;
}

_QWORD *BOMBufferPoolRequestBuffer(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;

  v2 = (pthread_mutex_t *)(a1 + 96);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)))
    return 0;
  while (1)
  {
    v5 = *(_QWORD *)(a1 + 8);
    if (v5)
      break;
    v6 = *(_QWORD *)(a1 + 16);
    if (v6)
    {
      *(_QWORD *)(a1 + 16) = v6 - 1;
      ++*(_QWORD *)a1;
      pthread_mutex_unlock(v2);
      v7 = BOMBufferAllocate(*(_QWORD *)(a1 + 24));
      if (v7)
        return v7;
      if (pthread_mutex_lock(v2))
        return 0;
      ++*(_QWORD *)(a1 + 16);
      --*(_QWORD *)a1;
    }
    else if (pthread_cond_wait((pthread_cond_t *)(a1 + 48), v2))
    {
      return 0;
    }
  }
  v3 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v3 + 56);
  v9 = *(_QWORD **)(v3 + 64);
  if (v8)
  {
    *(_QWORD *)(v8 + 64) = v9;
    v9 = *(_QWORD **)(v3 + 64);
  }
  else
  {
    *(_QWORD *)(a1 + 40) = v9;
  }
  *v9 = v8;
  *(_QWORD *)(a1 + 8) = v5 - 1;
  pthread_mutex_unlock(v2);
  pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  return (_QWORD *)v3;
}

uint64_t BOMBufferPoolReturnBuffer(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v4 = (pthread_mutex_t *)(a1 + 96);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!(_DWORD)result)
  {
    v7 = *(_QWORD *)(a1 + 32);
    v6 = a1 + 32;
    *(_QWORD *)(a2 + 56) = v7;
    v8 = (_QWORD *)(v7 + 64);
    if (v7)
      v9 = v8;
    else
      v9 = (_QWORD *)(v6 + 8);
    *v9 = a2 + 56;
    *(_QWORD *)v6 = a2;
    *(_QWORD *)(a2 + 64) = v6;
    ++*(_QWORD *)(v6 - 24);
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(v6 + 16));
  }
  return result;
}

char *BOMBufferFIFOCreate()
{
  char *v0;

  v0 = (char *)BOM_malloczero(0x88uLL);
  if (!pthread_cond_init((pthread_cond_t *)(v0 + 24), 0))
  {
    if (!pthread_mutex_init((pthread_mutex_t *)(v0 + 72), 0))
    {
      *(_QWORD *)v0 = 0;
      *((_QWORD *)v0 + 1) = 0;
      *((_QWORD *)v0 + 2) = v0 + 8;
      return v0;
    }
    pthread_cond_destroy((pthread_cond_t *)(v0 + 24));
  }
  free(v0);
  return 0;
}

void BOMBufferFIFODestroy(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int *v11;
  char v12;

  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 72);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
    {
      if (*(_QWORD *)a1)
      {
        v10 = BOMExceptionHandlerMessage("Attempting to destroy a non-empty FIFO!", v3, v4, v5, v6, v7, v8, v9, v12);
        v11 = __error();
        _BOMFatalException(v10, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMBufferManager.c", 311, *v11);
      }
      if (!pthread_mutex_unlock(v2))
      {
        pthread_cond_destroy((pthread_cond_t *)(a1 + 24));
        pthread_mutex_destroy(v2);
        free((void *)a1);
      }
    }
  }
}

uint64_t BOMBufferFIFOEnqueue(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  _QWORD *v6;

  v4 = (pthread_mutex_t *)(a1 + 72);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 56) = 0;
    v6 = *(_QWORD **)(a1 + 16);
    *(_QWORD *)(a2 + 64) = v6;
    *v6 = a2;
    *(_QWORD *)(a1 + 16) = a2 + 56;
    ++*(_QWORD *)a1;
    pthread_mutex_unlock(v4);
    return pthread_cond_broadcast((pthread_cond_t *)(a1 + 24));
  }
  return result;
}

uint64_t BOMBufferFIFODequeue(uint64_t *a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  pthread_cond_t *v9;

  v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9)))
    return 0;
  while (1)
  {
    v3 = *a1;
    if (*a1)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 3), v2))
      return 0;
  }
  v4 = a1[1];
  v6 = *(_QWORD *)(v4 + 56);
  v7 = *(_QWORD **)(v4 + 64);
  if (v6)
  {
    *(_QWORD *)(v6 + 64) = v7;
    v7 = *(_QWORD **)(v4 + 64);
  }
  else
  {
    a1[2] = (uint64_t)v7;
  }
  *v7 = v6;
  v8 = v3 - 1;
  *a1 = v3 - 1;
  pthread_mutex_unlock(v2);
  v9 = (pthread_cond_t *)(a1 + 3);
  if (v8)
    pthread_cond_signal(v9);
  else
    pthread_cond_broadcast(v9);
  return v4;
}

uint64_t BOMBufferFIFOCount(uint64_t *a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;

  v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9)))
    return 0;
  v3 = *a1;
  pthread_mutex_unlock(v2);
  return v3;
}

void __defaultHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24))
    _CUILog(4, (uint64_t)"[%s:%u] %s", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 16));
  else
    _CUILog(4, (uint64_t)"%s", a3, a4, a5, a6, a7, a8, *(_QWORD *)a1);
  if (*(_BYTE *)(a1 + 8))
    abort();
}

void _BOMFatalException(void *a1, const char *a2, int a3, int a4)
{
  void (*v8)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void (*v9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  const char *v10;
  _QWORD v11[3];
  int v12;
  int v13;

  v8 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))__BOMGlobalExceptionHandler();
  if (!a1)
    a1 = __BOMExceptionMessageString();
  v9 = __defaultHandler;
  if (v8)
    v9 = v8;
  v11[0] = a1;
  v11[1] = 1;
  if (a2)
    v10 = a2;
  else
    v10 = "";
  v11[2] = v10;
  v12 = a3;
  v13 = a4;
  ((void (*)(_QWORD *))v9)(v11);
  abort();
}

void *__BOMGlobalExceptionHandler()
{
  if (__BOMExceptionHandlerKey___onceHandler != -1)
    dispatch_once(&__BOMExceptionHandlerKey___onceHandler, &__block_literal_global_21);
  return pthread_getspecific(__BOMExceptionHandlerKey___key);
}

void *__BOMExceptionMessageString()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  if (__BOMExceptionMessageString___onceMessage != -1)
    dispatch_once(&__BOMExceptionMessageString___onceMessage, &__block_literal_global_5_0);
  v0 = pthread_getspecific(__BOMExceptionMessageString___key);
  if (!v0)
  {
    v0 = malloc_type_calloc(0x1000uLL, 1uLL, 0x100004077774924uLL);
    __CFSetLastAllocationEventName(v0, "__BOMExceptionMessageString");
    if (pthread_setspecific(__BOMExceptionMessageString___key, v0))
      _CUILog(4, (uint64_t)"__BOMExceptionMessageString couldn't pthread_setspecific", v1, v2, v3, v4, v5, v6, v8);
  }
  return v0;
}

uint64_t (*_BOMExceptionHandlerCall(void *a1, unsigned __int8 a2, const char *a3, int a4, int a5))(_QWORD *)
{
  uint64_t (*result)(_QWORD *);
  uint64_t (*v11)(_QWORD *);
  const char *v12;
  _QWORD v13[3];
  int v14;
  int v15;

  result = (uint64_t (*)(_QWORD *))__BOMGlobalExceptionHandler();
  if (result)
  {
    v11 = result;
    if (!a1)
      a1 = __BOMExceptionMessageString();
    v13[0] = a1;
    v12 = "";
    v13[1] = a2;
    if (a3)
      v12 = a3;
    v13[2] = v12;
    v14 = a4;
    v15 = a5;
    return (uint64_t (*)(_QWORD *))v11(v13);
  }
  return result;
}

char *BOMExceptionHandlerMessage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;

  v10 = (char *)__BOMExceptionMessageString();
  vsnprintf(v10, 0x1000uLL, a1, &a9);
  return v10;
}

uint64_t BOMFileNewFromFDWithSys(_QWORD *a1, uint64_t a2, char a3, unsigned __int8 *a4, __int128 *a5)
{
  _DWORD *v10;
  _DWORD *v11;
  _QWORD *v12;
  uint64_t result;
  _QWORD *v14;
  _QWORD *v15;
  int v16;

  v10 = BOM_malloczero(0xF8uLL);
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  if (a5)
  {
    if ((a3 & 0x10) == 0)
      goto LABEL_5;
    goto LABEL_4;
  }
  a5 = BomSys_default();
  if ((a3 & 0x10) != 0)
LABEL_4:
    (*((void (**)(_QWORD, uint64_t, uint64_t, uint64_t))a5 + 4))(*((_QWORD *)a5 + 1), a2, 48, 1);
LABEL_5:
  *v11 = *a4 == 119;
  v11[2] = a2;
  if (_BOMFileInit(v11, a3 & 0xF, a5))
  {
LABEL_6:
    v12 = v11;
LABEL_7:
    _freeBOMFile(v12);
    return 0xFFFFFFFFLL;
  }
  if ((a3 & 0x20) != 0)
  {
    if (getenv("BOM_ASYNC_DEBUG"))
    {
      gBOMAsyncDebug = 1;
    }
    else if (gBOMAsyncDebug != 1)
    {
LABEL_17:
      v14 = BOM_malloczero(0xF8uLL);
      if (!v14)
        goto LABEL_6;
      v15 = v14;
      if (*v11 == 1)
        v16 = 5;
      else
        v16 = 4;
      *(_DWORD *)v14 = v16;
      v14[1] = v11;
      if (_BOMFileInit(v14, 0, a5))
      {
        v12 = v15;
        goto LABEL_7;
      }
      v11 = v15;
      goto LABEL_12;
    }
    fprintf(__stderrp, "async compression enabled for %d\n", a2);
    goto LABEL_17;
  }
LABEL_12:
  result = 0;
  *a1 = v11;
  return result;
}

uint64_t _BOMFileInit(_DWORD *a1, int a2, __int128 *a3)
{
  int v5;
  int v6;
  BOOL v7;
  _BOOL4 v8;
  int v9;
  size_t Raw;
  uint64_t result;
  _QWORD *v15;
  pthread_t *v16;
  void *(__cdecl *v17)(void *);
  _QWORD *v18;
  UInt8 __src[16];

  if (!a3)
    a3 = BomSys_default();
  *((_QWORD *)a1 + 30) = a3;
  if (a2 == 4)
    v5 = 3;
  else
    v5 = 0;
  if (a2 == 5)
    v6 = 4;
  else
    v6 = v5;
  v7 = a2 == 1;
  if (a2 == 1)
    v8 = 1;
  else
    v8 = v6;
  v9 = v7;
  a1[6] = v8;
  switch(*a1)
  {
    case 0:
    case 3:
      if (v9)
      {
        memset(__src, 0, 11);
        Raw = _BOMFileReadRaw((uint64_t)a1, __src, 11);
        if (Raw == -1)
          goto LABEL_50;
        v8 = a1[6] == 1 && __src[0] == 31 && __src[1] == 139 && __src[2] == 8;
        a1[6] = v8;
        *((_QWORD *)a1 + 8) = Raw;
        a1[18] = 1;
        memcpy(a1 + 19, __src, Raw);
      }
      if ((v8 - 3) < 2)
        return _BOMFileCompressionLibrary_Setup((uint64_t)a1, 0);
      if (!v8)
        return 0;
      return _BOMFileSetupGzip((uint64_t)a1, 0);
    case 1:
    case 2:
      if ((v8 - 3) < 2)
        return _BOMFileCompressionLibrary_Setup((uint64_t)a1, 1);
      if (v8)
      {
        *(_DWORD *)&__src[7] = 196608;
        *(_QWORD *)__src = 559903;
        if (_BOMFileSetupGzip((uint64_t)a1, 1) || _BOMFileWriteRaw((uint64_t)a1, __src, 10) <= 9)
          goto LABEL_50;
      }
      return 0;
    case 4:
      if (gBufferPoolOnce != -1)
        dispatch_once(&gBufferPoolOnce, &__block_literal_global_11_0);
      v15 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v15)
        goto LABEL_50;
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v15);
      *((_QWORD *)a1 + 11) = BOMBufferFIFOCreate();
      *((_QWORD *)a1 + 12) = 0;
      *((_QWORD *)a1 + 28) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 40), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 28), 0))
        goto LABEL_46;
      v16 = (pthread_t *)(a1 + 26);
      v17 = (void *(__cdecl *)(void *))_asyncReadThread;
      goto LABEL_55;
    case 5:
      if (gBufferPoolOnce != -1)
        dispatch_once(&gBufferPoolOnce, &__block_literal_global_22);
      v18 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v18)
        goto LABEL_50;
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v18);
      *((_QWORD *)a1 + 11) = BOMBufferFIFOCreate();
      *((_QWORD *)a1 + 12) = 0;
      *((_QWORD *)a1 + 28) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 40), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 28), 0))
      {
LABEL_46:
        result = 1;
      }
      else
      {
        v16 = (pthread_t *)(a1 + 26);
        v17 = (void *(__cdecl *)(void *))_asyncWriteThread;
LABEL_55:
        result = pthread_create(v16, 0, v17, a1) != 0;
      }
      break;
    default:
LABEL_50:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

void _freeBOMFile(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = (void *)a1[4];
  if (v2)
  {
    free(v2);
    a1[4] = 0;
  }
  v3 = (void *)a1[5];
  if (v3)
  {
    free(v3);
    a1[5] = 0;
  }
  v4 = a1[11];
  if (v4)
    BOMBufferFIFODestroy(v4);
  free(a1);
}

BOOL BOMFileIsEOF(uint64_t a1)
{
  return *(_BYTE *)(a1 + 56) != 0;
}

uint64_t BOMFileClose(uint64_t a1)
{
  int v2;
  int v3;
  compression_stream *v4;
  char v5;
  z_stream *v6;
  uInt avail_out;
  BOOL v8;
  uint64_t v9;
  int v10;
  CFIndex v11;
  UInt8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uLong total_in;
  uint64_t v19;
  uint64_t v20;
  CFIndex v21;
  UInt8 *v22;
  uint64_t v23;
  int v25;
  void *v26;
  uint64_t v27;
  size_t v28;
  int v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v36;
  uint64_t v37;
  UInt8 v38[4];
  UInt8 buffer[4];

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) <= 1)
  {
    v3 = *(_DWORD *)(a1 + 24);
    if ((v3 - 3) >= 2)
    {
      if (v3 == 1)
      {
        v6 = *(z_stream **)(a1 + 32);
        avail_out = v6->avail_out;
        if (avail_out)
          goto LABEL_10;
        v8 = 0;
        while (1)
        {
          v11 = 0x20000 - avail_out;
          v12 = *(UInt8 **)(a1 + 40);
          while (v11)
          {
            v13 = _BOMFileWriteRaw(a1, v12, v11);
            v11 -= v13;
            v12 += v13;
            if (v13 == -1)
              return 0xFFFFFFFFLL;
          }
          v6->next_out = *(Bytef **)(a1 + 40);
          v6->avail_out = 0x20000;
          if (v8)
            break;
LABEL_10:
          v10 = deflate(v6, 4);
          if (v10)
          {
            if (v10 != 1)
              return 0xFFFFFFFFLL;
            avail_out = v6->avail_out;
            v8 = 1;
          }
          else
          {
            avail_out = v6->avail_out;
            v8 = avail_out != 0;
          }
        }
        v14 = 0;
        v15 = *(_QWORD *)(a1 + 48);
        *(_QWORD *)(a1 + 48) = v15;
        *(_DWORD *)buffer = v15;
        while (v14 != 4)
        {
          v16 = _BOMFileWriteRaw(a1, buffer, 4 - v14);
          v14 += v16;
          if (v16 < 0)
            return 0xFFFFFFFFLL;
        }
        v17 = 0;
        total_in = v6->total_in;
        v6->total_in = total_in;
        *(_DWORD *)v38 = total_in;
        while (v17 != 4)
        {
          v19 = _BOMFileWriteRaw(a1, v38, 4 - v17);
          v17 += v19;
          if (v19 < 0)
            return 0xFFFFFFFFLL;
        }
        deflateEnd(v6);
      }
    }
    else
    {
      v4 = *(compression_stream **)(a1 + 32);
      if (v4->dst_size)
        goto LABEL_28;
      v5 = 1;
      while (1)
      {
        v21 = 0x20000 - v4->dst_size;
        v22 = *(UInt8 **)(a1 + 40);
        while (v21)
        {
          v23 = _BOMFileWriteRaw(a1, v22, v21);
          v21 -= v23;
          v22 += v23;
          if (v23 == -1)
            return 0xFFFFFFFFLL;
        }
        v4->dst_ptr = *(uint8_t **)(a1 + 40);
        v4->dst_size = 0x20000;
        if ((v5 & 1) == 0)
          break;
LABEL_28:
        v5 = 1;
        v20 = compression_stream_process(v4, 1);
        if ((_DWORD)v20 == 1)
        {
          v5 = 0;
        }
        else
        {
          v9 = v20;
          if ((_DWORD)v20 == -1)
            return v9;
        }
      }
      compression_stream_destroy(v4);
    }
    v2 = *(_DWORD *)a1;
  }
  if (v2 == 3 || v2 == 0)
  {
    v25 = *(_DWORD *)(a1 + 24);
    if ((v25 - 3) >= 2)
    {
      if (v25 == 1)
      {
        v27 = *(_QWORD *)(a1 + 32);
        v26 = *(void **)(a1 + 40);
        v28 = *(unsigned int *)(v27 + 8);
        *(_QWORD *)(a1 + 64) = v28;
        *(_DWORD *)(a1 + 72) = 0;
        memmove(v26, *(const void **)v27, v28);
        if (inflateEnd(*(z_streamp *)(a1 + 32)))
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      compression_stream_destroy(*(compression_stream **)(a1 + 32));
    }
  }
  v29 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 0xFFFFFFFE) == 4)
  {
    if (v29 == 4)
    {
      if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
      {
        v31 = *(_QWORD *)(a1 + 96);
        if (v31)
        {
          BOMBufferPoolReturnBuffer(gBufferPool, v31);
          *(_QWORD *)(a1 + 96) = 0;
        }
        while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 88)))
        {
          v32 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
          BOMBufferPoolReturnBuffer(gBufferPool, v32);
        }
        v33 = *(_DWORD *)(a1 + 224);
        if (!v33)
        {
          v33 = 1;
          *(_DWORD *)(a1 + 224) = 1;
        }
        if (gBOMAsyncDebug == 1)
        {
          fwrite("waiting for async read thread to finish...", 0x2AuLL, 1uLL, __stderrp);
          v33 = *(_DWORD *)(a1 + 224);
        }
        if (v33 != 2)
        {
          while (!pthread_cond_wait((pthread_cond_t *)(a1 + 112), (pthread_mutex_t *)(a1 + 160)))
          {
            if (*(_DWORD *)(a1 + 224) == 2)
              goto LABEL_65;
          }
          return 0xFFFFFFFFLL;
        }
LABEL_65:
        if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)) && !pthread_join(*(pthread_t *)(a1 + 104), 0))
        {
          while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 88)))
          {
            v34 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
            BOMBufferPoolReturnBuffer(gBufferPool, v34);
          }
          if (gBOMAsyncDebug != 1)
            goto LABEL_71;
LABEL_70:
          fwrite("done\n", 5uLL, 1uLL, __stderrp);
LABEL_71:
          v29 = *(_DWORD *)a1;
          goto LABEL_72;
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (v29 == 5)
    {
      v30 = *(_QWORD **)(a1 + 96);
      if (v30)
      {
        *(_QWORD *)(a1 + 96) = 0;
      }
      else
      {
        v30 = BOMBufferPoolRequestBuffer(gBufferPool);
        v30[1] = 0;
        v30[2] = 0;
      }
      *((_DWORD *)v30 + 12) |= 1u;
      BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 88), (uint64_t)v30);
      if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
      {
        v36 = *(_DWORD *)(a1 + 224);
        if (!v36)
        {
          v36 = 1;
          *(_DWORD *)(a1 + 224) = 1;
        }
        if (gBOMAsyncDebug == 1)
        {
          fwrite("waiting for async write thread to finish...", 0x2BuLL, 1uLL, __stderrp);
          v36 = *(_DWORD *)(a1 + 224);
        }
        if (v36 != 2)
        {
          while (!pthread_cond_wait((pthread_cond_t *)(a1 + 112), (pthread_mutex_t *)(a1 + 160)))
          {
            if (*(_DWORD *)(a1 + 224) == 2)
              goto LABEL_91;
          }
          return 0xFFFFFFFFLL;
        }
LABEL_91:
        if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)) && !pthread_join(*(pthread_t *)(a1 + 104), 0))
        {
          if (gBOMAsyncDebug == 1)
            fwrite("async write thread terminated. Draining FIFO...", 0x2FuLL, 1uLL, __stderrp);
          while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 88)))
          {
            v37 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
            BOMBufferPoolReturnBuffer(gBufferPool, v37);
          }
          if ((gBOMAsyncDebug & 1) == 0)
            goto LABEL_71;
          goto LABEL_70;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
LABEL_72:
  switch(v29)
  {
    case 0:
    case 1:
      v9 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 240) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 240) + 8), *(unsigned int *)(a1 + 8));
      *(_DWORD *)(a1 + 8) = -1;
      break;
    case 2:
      CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 8));
      goto LABEL_78;
    case 3:
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 8));
LABEL_78:
      v9 = 0;
      goto LABEL_79;
    case 4:
    case 5:
      v9 = BOMFileClose(*(_QWORD *)(a1 + 8));
LABEL_79:
      *(_QWORD *)(a1 + 8) = 0;
      break;
    default:
      v9 = 0;
      break;
  }
  _freeBOMFile((_QWORD *)a1);
  return v9;
}

size_t BOMFileRead(uint64_t a1, UInt8 *buffer, unint64_t bufferLength)
{
  unint64_t v3;
  UInt8 *v4;
  int v6;
  int v7;
  z_stream *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  size_t dst_size;
  _QWORD *v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  size_t v17;
  int v18;
  int v19;
  compression_stream *v20;
  int v21;
  BOOL v22;
  uint64_t Raw;
  compression_status v24;
  unint64_t v25;
  char *v26;
  size_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!a1)
    return -1;
  v3 = bufferLength;
  v4 = buffer;
  v6 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
LABEL_5:
    if (!bufferLength)
      return 0;
    if (!buffer)
      return -1;
    v7 = *(_DWORD *)(a1 + 24);
    if ((v7 - 3) < 2)
    {
      v20 = *(compression_stream **)(a1 + 32);
      v20->dst_ptr = buffer;
      v20->dst_size = bufferLength;
      while (1)
      {
        v21 = *(unsigned __int8 *)(a1 + 56);
        if (v20->src_size)
          v22 = 0;
        else
          v22 = v21 == 0;
        if (v22)
        {
          Raw = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 40), 0x20000);
          if (Raw)
          {
            if (Raw == -1)
              goto LABEL_57;
            v20->src_ptr = *(const uint8_t **)(a1 + 40);
            v20->src_size = Raw;
            v21 = *(unsigned __int8 *)(a1 + 56);
          }
          else
          {
            v21 = 1;
            *(_BYTE *)(a1 + 56) = 1;
          }
        }
        v24 = compression_stream_process(v20, v21 != 0);
        if (v24 == COMPRESSION_STATUS_END)
          break;
        if (v24 == COMPRESSION_STATUS_ERROR)
        {
LABEL_57:
          *(_BYTE *)(a1 + 56) = 1;
          return -1;
        }
        dst_size = v20->dst_size;
        if (!dst_size)
          return v3 - dst_size;
      }
      dst_size = v20->dst_size;
    }
    else
    {
      if (!v7)
      {
        v25 = *(_QWORD *)(a1 + 64);
        if (v25)
        {
          if (*(_DWORD *)(a1 + 72))
            v26 = (char *)(a1 + 76);
          else
            v26 = *(char **)(a1 + 40);
          if (v25 >= bufferLength)
            v28 = bufferLength;
          else
            v28 = *(_QWORD *)(a1 + 64);
          memcpy(buffer, v26, v28);
          v29 = *(_QWORD *)(a1 + 64);
          v3 -= v28;
          *(_DWORD *)(a1 + 236) -= v28;
          v4 += v28;
          *(_QWORD *)(a1 + 64) = v29 - v28;
          if (v29 != v28)
            memmove(v26, &v26[v28], v29 - v28);
        }
        else
        {
          v28 = 0;
        }
        v30 = _BOMFileReadRaw(a1, v4, v3);
        v10 = v30;
        if (v30 != -1)
        {
          if (!v30)
            *(_BYTE *)(a1 + 56) = 1;
          return v30 + v28;
        }
        return v10;
      }
      if (v7 != 1)
        return -1;
      v8 = *(z_stream **)(a1 + 32);
      v8->next_out = buffer;
      v8->avail_out = bufferLength;
      while (1)
      {
        if (!v8->avail_in && !*(_BYTE *)(a1 + 56))
        {
          v9 = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 40), 0x20000);
          v10 = v9;
          if (v9)
          {
            if (v9 == -1)
              return v10;
          }
          else
          {
            *(_BYTE *)(a1 + 56) = 1;
          }
          *(_DWORD *)(a1 + 236) = v9;
          v8->avail_in = v9;
          v8->next_in = *(Bytef **)(a1 + 40);
        }
        v11 = inflate(v8, 0);
        if (v11)
        {
          if (v11 != 1)
            goto LABEL_57;
          *(_BYTE *)(a1 + 56) = 1;
        }
        dst_size = v8->avail_out;
        if (!(_DWORD)dst_size || dst_size != v3)
          break;
        if (*(_BYTE *)(a1 + 56))
        {
          dst_size = v3;
          return v3 - dst_size;
        }
      }
    }
    return v3 - dst_size;
  }
  if (v6 != 4)
  {
    if (v6 != 3)
      return -1;
    goto LABEL_5;
  }
  v10 = 0;
  if (!bufferLength)
    goto LABEL_38;
  while (1)
  {
    v13 = *(_QWORD **)(a1 + 96);
    if (!v13)
    {
      v13 = (_QWORD *)BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
      *(_QWORD *)(a1 + 96) = v13;
    }
    v14 = v13[1];
    if (v3 >= v13[2] - v14)
      v15 = v13[2] - v14;
    else
      v15 = v3;
    memcpy(v4, (const void *)(v13[3] + v14), v15);
    v16 = v13[2];
    v17 = v13[1] + v15;
    v13[1] = v17;
    v10 += v15;
    if (v16 != v17)
      goto LABEL_37;
    if (!v17)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
        goto LABEL_38;
      v19 = *(_DWORD *)(a1 + 224);
      v18 = *(_DWORD *)(a1 + 228);
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)))
        goto LABEL_38;
      if ((v19 - 1) <= 1)
        break;
    }
    BOMBufferPoolReturnBuffer(gBufferPool, (uint64_t)v13);
    *(_QWORD *)(a1 + 96) = 0;
LABEL_37:
    v4 += v15;
    v3 -= v15;
    if (!v3)
      goto LABEL_38;
  }
  if (v18)
  {
    *__error() = v18;
    return -1;
  }
LABEL_38:
  *(_QWORD *)(a1 + 16) += v10;
  return v10;
}

unint64_t BOMFileWrite(uint64_t a1, UInt8 *buffer, unint64_t bufferLength)
{
  unint64_t v3;
  Bytef *v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  size_t v12;
  int64x2_t v13;
  int v14;
  int v15;
  uint8_t *v16;
  compression_stream *v17;
  CFIndex v18;
  UInt8 *v19;
  uint64_t v20;
  z_stream *v21;
  uInt avail_out;
  CFIndex v24;
  UInt8 *v25;
  uint64_t v26;

  if (!a1)
    return -1;
  v3 = bufferLength;
  v4 = buffer;
  if ((*(_DWORD *)a1 - 1) < 2)
  {
    if (!bufferLength)
      return 0;
    if (!buffer)
      return -1;
    v6 = *(_DWORD *)(a1 + 24);
    if ((v6 - 3) >= 2)
    {
      if (v6 == 1)
      {
        v21 = *(z_stream **)(a1 + 32);
        v21->next_in = buffer;
        v21->avail_in = bufferLength;
        if ((_DWORD)bufferLength)
        {
          avail_out = v21->avail_out;
          if (avail_out)
            goto LABEL_44;
          while (1)
          {
            v24 = 0x20000 - avail_out;
            v25 = *(UInt8 **)(a1 + 40);
            v8 = -1;
            while (v24)
            {
              v26 = _BOMFileWriteRaw(a1, v25, v24);
              v25 += v26;
              v24 -= v26;
              if (v26 < 0)
                return v8;
            }
            v21->avail_out = 0x20000;
            v21->next_out = *(Bytef **)(a1 + 40);
            if (!v21->avail_in)
              break;
LABEL_44:
            if (deflate(v21, 0))
              return -1;
            avail_out = v21->avail_out;
          }
        }
        *(_QWORD *)(a1 + 48) = crc32(*(_QWORD *)(a1 + 48), v4, v3);
        return v3;
      }
      else
      {
        if (v6)
          return -1;
        v7 = 0;
        v8 = -1;
        while (v3)
        {
          v9 = _BOMFileWriteRaw(a1, v4, v3);
          v7 += v9;
          v3 -= v9;
          if (v9 < 0)
            return v8;
        }
        return v7;
      }
    }
    v17 = *(compression_stream **)(a1 + 32);
    v16 = *(uint8_t **)(a1 + 40);
    v17->src_ptr = buffer;
    v17->src_size = bufferLength;
    v17->dst_ptr = v16;
    v17->dst_size = 0x20000;
    while (compression_stream_process(v17, 0) != COMPRESSION_STATUS_ERROR)
    {
      v18 = 0x20000 - v17->dst_size;
      v19 = *(UInt8 **)(a1 + 40);
      while (v18)
      {
        v20 = _BOMFileWriteRaw(a1, v19, v18);
        v19 += v20;
        v18 -= v20;
        if (v20 < 0)
          return -1;
      }
      v17->dst_ptr = *(uint8_t **)(a1 + 40);
      v17->dst_size = 0x20000;
      if (!v17->src_size)
        return v3;
    }
    return -1;
  }
  if (*(_DWORD *)a1 != 5)
    return -1;
  v8 = 0;
  if (!bufferLength)
    goto LABEL_26;
  while (1)
  {
    v10 = *(_QWORD **)(a1 + 96);
    if (v10)
    {
      v11 = v10[1];
    }
    else
    {
      v10 = BOMBufferPoolRequestBuffer(gBufferPool);
      v11 = 0;
      v10[1] = 0;
      v10[2] = 0;
      *(_QWORD *)(a1 + 96) = v10;
    }
    if (v3 >= *v10 - v11)
      v12 = *v10 - v11;
    else
      v12 = v3;
    memcpy((void *)(v10[3] + v11), v4, v12);
    v13 = vaddq_s64(*(int64x2_t *)(v10 + 1), vdupq_n_s64(v12));
    *(int64x2_t *)(v10 + 1) = v13;
    v8 += v12;
    if (*v10 != v13.i64[0])
      goto LABEL_25;
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
      goto LABEL_26;
    v15 = *(_DWORD *)(a1 + 224);
    v14 = *(_DWORD *)(a1 + 228);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)))
      goto LABEL_26;
    if ((v15 - 1) <= 1)
      break;
    BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 88), (uint64_t)v10);
    *(_QWORD *)(a1 + 96) = 0;
LABEL_25:
    v4 += v12;
    v3 -= v12;
    if (!v3)
      goto LABEL_26;
  }
  if (v14)
  {
    *__error() = v14;
    return -1;
  }
LABEL_26:
  *(_QWORD *)(a1 + 16) += v8;
  return v8;
}

uint64_t _BOMFileReadRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;

  v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 3)
    {
      v7 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1)
    {
      v7 = -1;
    }
    else
    {
      v7 = (*(uint64_t (**)(_QWORD, _QWORD, UInt8 *, CFIndex))(*(_QWORD *)(a1 + 240) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 240) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1)
      break;
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(_QWORD *)(a1 + 16) += v6;
  if (v7 < 0)
    return -1;
  else
    return v6;
}

uint64_t _BOMFileSetupGzip(uint64_t a1, int a2)
{
  z_stream *v4;
  z_streamp *v5;
  Bytef *v6;
  _QWORD *v7;
  size_t v8;
  Bytef *v9;
  uint64_t result;
  uLong v11;

  v5 = (z_streamp *)(a1 + 32);
  v4 = *(z_stream **)(a1 + 32);
  if (!v4)
  {
    v4 = (z_stream *)BOM_malloc(0x70uLL);
    *v5 = v4;
    if (!v4)
      return 0xFFFFFFFFLL;
  }
  v6 = *(Bytef **)(a1 + 40);
  if (!v6)
  {
    v6 = (Bytef *)BOM_malloc(0x20000uLL);
    *(_QWORD *)(a1 + 40) = v6;
    v4 = *(z_stream **)(a1 + 32);
    if (!v6)
    {
      free(*(void **)(a1 + 32));
      goto LABEL_14;
    }
  }
  v4->zalloc = 0;
  (*v5)->zfree = 0;
  (*v5)->opaque = 0;
  v7 = *v5;
  if (a2)
  {
    *v7 = 0;
    (*v5)->next_out = v6;
    (*v5)->avail_in = 0;
    (*v5)->avail_out = 0x20000;
    if (deflateInit2_(*v5, -1, 8, -15, 8, 0, "1.2.12", 112))
    {
LABEL_7:
      free(*(void **)(a1 + 32));
      free(*(void **)(a1 + 40));
      v5[1] = 0;
LABEL_14:
      *v5 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *v7 = v6;
    v8 = *(_QWORD *)(a1 + 64);
    if (v8)
    {
      if (*(_DWORD *)(a1 + 72))
        v9 = (Bytef *)(a1 + 76);
      else
        v9 = v6;
      memcpy(**(void ***)(a1 + 32), v9, v8);
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8) = *(_QWORD *)(a1 + 64);
      *(_QWORD *)(a1 + 64) = 0;
    }
    else
    {
      (*v5)->avail_in = 0;
    }
    (*v5)->next_out = 0;
    (*v5)->avail_out = 0;
    if (inflateInit2_(*v5, 47, "1.2.12", 112))
      goto LABEL_7;
  }
  v11 = crc32(0, 0, 0);
  result = 0;
  *(_QWORD *)(a1 + 48) = v11;
  *(_BYTE *)(a1 + 56) = 0;
  return result;
}

uint64_t _BOMFileCompressionLibrary_Setup(uint64_t a1, int a2)
{
  void *v4;
  void *v5;
  int v6;
  compression_algorithm v7;
  uint64_t result;
  uLong v9;

  if (!*(_QWORD *)(a1 + 32))
  {
    v4 = BOM_malloc(0x28uLL);
    *(_QWORD *)(a1 + 32) = v4;
    if (!v4)
      return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)(a1 + 40))
  {
    v5 = BOM_malloc(0x20000uLL);
    *(_QWORD *)(a1 + 40) = v5;
    if (!v5)
      goto LABEL_12;
  }
  v6 = *(_DWORD *)(a1 + 24);
  switch(v6)
  {
    case 1:
      v7 = COMPRESSION_ZLIB;
      break;
    case 4:
      v7 = COMPRESSION_LZFSE;
      break;
    case 3:
      v7 = 2304;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  if (compression_stream_init(*(compression_stream **)(a1 + 32), (compression_stream_operation)(a2 == 0), v7))
  {
LABEL_12:
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    return 0xFFFFFFFFLL;
  }
  v9 = crc32(0, 0, 0);
  result = 0;
  *(_QWORD *)(a1 + 48) = v9;
  *(_BYTE *)(a1 + 56) = 0;
  return result;
}

uint64_t _BOMFileWriteRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;

  v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 2)
    {
      v7 = CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1 == 1)
    {
      v7 = (*(uint64_t (**)(_QWORD, _QWORD, UInt8 *, CFIndex))(*(_QWORD *)(a1 + 240) + 48))(*(_QWORD *)(*(_QWORD *)(a1 + 240) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    else
    {
      v7 = -1;
    }
    v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1)
      break;
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(_QWORD *)(a1 + 16) += v6;
  if (v7 < 0)
    return -1;
  else
    return v6;
}

_QWORD *_initBufferPool()
{
  _QWORD *result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  int *v9;

  result = BOMBufferPoolAllocate(gBOMAsyncBufferSize, gBOMAsyncBufferCount);
  if (!result)
  {
    v8 = BOMExceptionHandlerMessage("Unable to allocate BOM buffer pool gBOMAsyncBufferSize=%lu gBOMAsyncBufferCount=%u!\n", v1, v2, v3, v4, v5, v6, v7, gBOMAsyncBufferSize);
    v9 = __error();
    _BOMFatalException(v8, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMFile.c", 1744, *v9);
  }
  gBufferPool = (uint64_t)result;
  return result;
}

uint64_t _asyncWriteThread(uint64_t a1)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  int v6;
  FILE *v7;
  int *v8;

  if (gBOMAsyncDebug == 1)
    fwrite("async write thread starting\n", 0x1CuLL, 1uLL, __stderrp);
  v2 = 0;
  do
  {
    v3 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
    v4 = BOMFileWrite(*(_QWORD *)(a1 + 8), *(UInt8 **)(v3 + 24), *(_QWORD *)(v3 + 16));
    v5 = *(_DWORD *)(v3 + 48);
    if ((v5 & 1) != 0 && gBOMAsyncDebug == 1)
      fwrite("async write thread asked to finish\n", 0x23uLL, 1uLL, __stderrp);
    if (v4 == -1)
    {
      if (gBOMAsyncDebug == 1)
      {
        v7 = __stderrp;
        v8 = __error();
        fprintf(v7, "async write thread finished file (errno=%d)\n", *v8);
      }
      v2 = *__error();
      v6 = 1;
    }
    else
    {
      v6 = v5 & 1;
    }
    ++*(_QWORD *)(v3 + 40);
    BOMBufferPoolReturnBuffer(gBufferPool, v3);
  }
  while (!v6);
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
  {
    *(_DWORD *)(a1 + 224) = 2;
    *(_DWORD *)(a1 + 228) = v2;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 112))
      && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160))
      && gBOMAsyncDebug == 1)
    {
      fwrite("async write thread terminating\n", 0x1FuLL, 1uLL, __stderrp);
    }
  }
  return 0;
}

uint64_t _asyncReadThread(uint64_t a1)
{
  unint64_t *i;
  int v3;
  size_t v4;
  int v5;
  FILE *v6;
  int *v7;

  if (gBOMAsyncDebug == 1)
    fwrite("async read thread starting\n", 0x1BuLL, 1uLL, __stderrp);
  for (i = BOMBufferPoolRequestBuffer(gBufferPool); ; i = BOMBufferPoolRequestBuffer(gBufferPool))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 160))
      || (v3 = *(_DWORD *)(a1 + 224), pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160))))
    {
      v5 = 0;
      goto LABEL_20;
    }
    if (v3 == 1)
    {
      if (gBOMAsyncDebug == 1)
      {
        fwrite("async read thread asked to finish\n", 0x22uLL, 1uLL, __stderrp);
LABEL_13:
        if (gBOMAsyncDebug == 1)
          fwrite("async read thread finished file\n", 0x20uLL, 1uLL, __stderrp);
      }
      v5 = 0;
      goto LABEL_19;
    }
    v4 = BOMFileRead(*(_QWORD *)(a1 + 8), (UInt8 *)i[3], *i);
    if (v4 == -1)
      break;
    if (!v4)
      goto LABEL_13;
    i[1] = 0;
    i[2] = v4;
    ++i[5];
    BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 88), (uint64_t)i);
  }
  if (gBOMAsyncDebug == 1)
  {
    v6 = __stderrp;
    v7 = __error();
    fprintf(v6, "async read thread finished file (errno=%d)\n", *v7);
  }
  v5 = *__error();
LABEL_19:
  i[1] = 0;
  i[2] = 0;
  ++i[5];
LABEL_20:
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
  {
    *(_DWORD *)(a1 + 224) = 2;
    *(_DWORD *)(a1 + 228) = v5;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 112)) && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)))
    {
      if (i)
        BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 88), (uint64_t)i);
      if (gBOMAsyncDebug == 1)
        fwrite("async read thread terminating\n", 0x1EuLL, 1uLL, __stderrp);
    }
  }
  return 0;
}

void **BOMStackNew()
{
  void **v0;
  void **v1;
  void *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int *v12;
  char v13;

  v0 = (void **)BOM_calloc(1uLL, 0x18uLL);
  v1 = v0;
  if (v0)
  {
    v0[1] = (void *)1024;
    v2 = BOM_malloczero(0x2000uLL);
    *v1 = v2;
    if (!v2)
    {
      BOMStackFree(v1);
      v11 = BOMExceptionHandlerMessage("Allocating BOMStack failed", v4, v5, v6, v7, v8, v9, v10, v13);
      v12 = __error();
      _BOMFatalException(v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMStack.c", 38, *v12);
    }
  }
  return v1;
}

void BOMStackFree(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      free(v2);
    free(a1);
  }
}

uint64_t *BOMStackPop(uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = *result;
    if (*result && (v2 = result[2]) != 0)
    {
      v3 = v2 - 1;
      result[2] = v3;
      result = *(uint64_t **)(v1 + 8 * v3);
      *(_QWORD *)(v1 + 8 * v3) = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *BOMStackPeek(_QWORD *result)
{
  uint64_t v1;

  if (result)
  {
    if (*result && (v1 = result[2]) != 0)
      return *(_QWORD **)(*result + 8 * v1 - 8);
    else
      return 0;
  }
  return result;
}

char *BOMStackPush(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int *v22;
  char *v23;
  int *v24;
  char v25;

  if (result)
  {
    v8 = result;
    result = *(char **)result;
    if (result)
    {
      v11 = v8[1];
      v10 = v8[2];
      v12 = v10 + 1;
      if (v10 + 1 >= v11)
      {
        if (v11 == 0xFFFFFFF)
        {
          v21 = BOMExceptionHandlerMessage("BOMStack is full can't grow anymore", a2, a3, a4, a5, a6, a7, a8, v25);
          v22 = __error();
          _BOMFatalException(v21, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMStack.c", 103, *v22);
        }
        v13 = 2 * v11;
        if (2 * v11 >= 0xFFFFFFF)
          v13 = 0xFFFFFFFLL;
        v8[1] = v13;
        result = BOM_realloczero(result, 8 * v11, 8 * v13);
        *v8 = result;
        if (!result)
        {
          v23 = BOMExceptionHandlerMessage("BOMStack got blown", v14, v15, v16, v17, v18, v19, v20, v25);
          v24 = __error();
          _BOMFatalException(v23, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMStack.c", 122, *v24);
        }
        v10 = v8[2];
        v12 = v10 + 1;
      }
      v8[2] = v12;
      *(_QWORD *)&result[8 * v10] = a2;
    }
  }
  return result;
}

BOOL BOMStackIsEmpty(uint64_t a1)
{
  return !a1 || !*(_QWORD *)a1 || *(_DWORD *)(a1 + 16) < 1;
}

uint64_t BomSys_init(_QWORD *a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v4 = BOM_malloc(0x80uLL);
  result = 0;
  v4[4] = xmmword_1E41AA710;
  v4[5] = *(_OWORD *)&off_1E41AA720;
  v4[6] = xmmword_1E41AA730;
  v4[7] = *(_OWORD *)&off_1E41AA740;
  *v4 = gDefaultSys;
  v4[1] = *(_OWORD *)&off_1E41AA6E0;
  v4[2] = xmmword_1E41AA6F0;
  v4[3] = *(_OWORD *)&off_1E41AA700;
  *((_QWORD *)v4 + 1) = a2;
  *a1 = v4;
  return result;
}

void BomSys_free(void *a1)
{
  if (a1 != &gDefaultNOMMAPSys && a1 != 0 && a1 != &gDefaultSys)
    free(a1);
}

void BomSys_set_close(__int128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;

  v9 = a1 == (__int128 *)&gDefaultNOMMAPSys || a1 == 0 || a1 == &gDefaultSys;
  if (v9 || *(_QWORD *)a1)
  {
    _CUILog(4, (uint64_t)"%s ignoring call to alter shared Sys", a3, a4, a5, a6, a7, a8, (uint64_t)"void BomSys_set_close(BomSys *, BomSys_close_call)");
  }
  else if (a2)
  {
    *((_QWORD *)a1 + 3) = a2;
  }
  else
  {
    *((_QWORD *)a1 + 3) = BomSys_close;
  }
}

uint64_t BomSys_fcntl(int a1, int a2, int a3, uint64_t a4)
{
  return fcntl(a2, a3, a4);
}

void BomSys_set_read(__int128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;

  v9 = a1 == (__int128 *)&gDefaultNOMMAPSys || a1 == 0 || a1 == &gDefaultSys;
  if (v9 || *(_QWORD *)a1)
  {
    _CUILog(4, (uint64_t)"%s ignoring call to alter shared Sys", a3, a4, a5, a6, a7, a8, (uint64_t)"void BomSys_set_read(BomSys *, BomSys_read_call)");
  }
  else if (a2)
  {
    *((_QWORD *)a1 + 5) = a2;
  }
  else
  {
    *((_QWORD *)a1 + 5) = BomSys_read;
  }
}

void BomSys_set_write(__int128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;

  v9 = a1 == (__int128 *)&gDefaultNOMMAPSys || a1 == 0 || a1 == &gDefaultSys;
  if (v9 || *(_QWORD *)a1)
  {
    _CUILog(4, (uint64_t)"%s ignoring call to alter shared Sys", a3, a4, a5, a6, a7, a8, (uint64_t)"void BomSys_set_write(BomSys *, BomSys_write_call)");
  }
  else if (a2)
  {
    *((_QWORD *)a1 + 6) = a2;
  }
  else
  {
    *((_QWORD *)a1 + 6) = BomSys_write;
  }
}

ssize_t BomSys_write(int a1, int __fd, void *__buf, size_t __nbyte)
{
  return write(__fd, __buf, __nbyte);
}

uint64_t BomSys_fsync(int a1, int a2)
{
  return fsync(a2);
}

uint64_t BomSys_fstatfs(int a1, int a2, statfs *a3)
{
  return fstatfs(a2, a3);
}

void BomSys_rename(int a1, std::__fs::filesystem::path *__from, std::__fs::filesystem::path *__to)
{
  rename(__from, __to, (std::error_code *)__to);
}

uint64_t BomSys_munmap(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

void *BomSys_defaultNoMMAP()
{
  return &gDefaultNOMMAPSys;
}

uint64_t BomSys_fchmod(int a1, int a2, mode_t a3)
{
  return fchmod(a2, a3);
}

uint64_t BomSys_fchown(int a1, int a2, uid_t a3, gid_t a4)
{
  return fchown(a2, a3, a4);
}

void *BOM_realloc(void *a1, size_t a2)
{
  char v2;
  void *v3;
  void *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int *v14;

  v2 = a2;
  v3 = reallocf(a1, a2);
  v4 = v3;
  if (v3)
  {
    __CFSetLastAllocationEventName(v3, "CUIBOM_realloc");
  }
  else
  {
    v5 = __error();
    strerror(*v5);
    v13 = BOMExceptionHandlerMessage("BOM_realloc: (%zd bytes) %s\n", v6, v7, v8, v9, v10, v11, v12, v2);
    v14 = __error();
    _BOMExceptionHandlerCall(v13, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 70, *v14);
  }
  return v4;
}

char *BOM_realloczero(void *a1, unint64_t a2, size_t __size)
{
  char *v5;
  char *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int *v16;

  v5 = (char *)reallocf(a1, __size);
  v6 = v5;
  if (v5)
  {
    __CFSetLastAllocationEventName(v5, "CUIBOM_realloczero");
    if (__size > a2)
      bzero(&v6[a2], __size - a2);
  }
  else
  {
    v7 = __error();
    strerror(*v7);
    v15 = BOMExceptionHandlerMessage("BOM_realloczero: (%zd bytes) %s\n", v8, v9, v10, v11, v12, v13, v14, __size);
    v16 = __error();
    _BOMExceptionHandlerCall(v15, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 85, *v16);
  }
  return v6;
}

uint64_t _dense_initialize(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;

  if ((a3 & 7) == 0 && (int)(a3 >> 3) >= 1)
  {
    v5 = result;
    v6 = (a3 >> 3);
    v7 = (unsigned int *)(a2 + 4);
    do
    {
      v8 = *(v7 - 1);
      v9 = bswap32(v8);
      v10 = bswap32(*v7);
      if (a4)
        v11 = v9;
      else
        v11 = v8;
      if (a4)
        v12 = v10;
      else
        v12 = *v7;
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 + 40))(v5, v11, v12);
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  return result;
}

_DWORD *_dense_serialize(uint64_t **a1, int a2, size_t *a3)
{
  uint64_t *v4;
  size_t v5;
  _DWORD *result;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t *v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;

  v4 = *a1;
  v5 = 8 * *((int *)a1 + 2);
  *a3 = v5;
  result = BOM_malloc(v5);
  if (result)
  {
    v7 = *((_DWORD *)v4 + 4);
    if (v7 < 1)
    {
      v9 = 0;
    }
    else
    {
      v8 = 0;
      v9 = 0;
      v10 = *v4;
      do
      {
        v11 = *(uint64_t **)(v10 + 8 * v8);
        if (v11)
        {
          v12 = 2 * v9;
          do
          {
            v13 = *((_DWORD *)v11 + 2);
            v14 = *((_DWORD *)v11 + 3);
            v15 = bswap32(v13);
            v16 = bswap32(v14);
            if (a2)
            {
              v13 = v15;
              v14 = v16;
            }
            result[v12] = v13;
            result[v12 + 1] = v14;
            v11 = (uint64_t *)*v11;
            v12 += 2;
            ++v9;
          }
          while (v11);
          v7 = *((_DWORD *)v4 + 4);
        }
        ++v8;
      }
      while (v8 < v7);
    }
    v17 = (uint64_t *)v4[1];
    if (v17)
    {
      v18 = 2 * v9;
      do
      {
        v19 = *((_DWORD *)v17 + 2);
        v20 = *((_DWORD *)v17 + 3);
        v21 = bswap32(v19);
        v22 = bswap32(v20);
        if (a2)
          v19 = v21;
        result[v18] = v19;
        if (a2)
          v23 = v22;
        else
          v23 = v20;
        result[v18 + 1] = v23;
        v17 = (uint64_t *)*v17;
        v18 += 2;
      }
      while (v17);
    }
  }
  return result;
}

void _dense_deallocate(uint64_t a1)
{
  void **v2;

  v2 = *(void ***)a1;
  (*(void (**)(void))(a1 + 56))();
  free(*v2);
  free(v2);
  *(_QWORD *)a1 = 0;
}

_QWORD *_dense_clear(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  uint64_t i;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *result;
  _QWORD *v7;

  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 16);
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD **)(*(_QWORD *)v1 + 8 * i);
      *(_QWORD *)(*(_QWORD *)v1 + 8 * i) = 0;
      if (v4)
      {
        do
        {
          v5 = (_QWORD *)*v4;
          free(v4);
          v4 = v5;
        }
        while (v5);
        v2 = *(_DWORD *)(v1 + 16);
      }
    }
  }
  result = *(_QWORD **)(v1 + 8);
  *(_QWORD *)(v1 + 8) = 0;
  if (result)
  {
    do
    {
      v7 = (_QWORD *)*result;
      free(result);
      result = v7;
    }
    while (v7);
  }
  return result;
}

_DWORD *_dense_addFreeRange(_DWORD *result, int a2, unint64_t a3)
{
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  char *v10;
  uint64_t v11;

  if (a3)
  {
    v5 = result;
    v6 = *(_QWORD *)result;
    if (a3 < 0x10000)
    {
      v8 = *(int *)(v6 + 16);
      if (v8 <= a3)
      {
        v9 = a3 + 1;
        v10 = (char *)BOM_realloc(*(void **)v6, (8 * (a3 + 1)));
        *(_QWORD *)v6 = v10;
        if ((int)v8 <= (int)a3)
          bzero(&v10[8 * *(int *)(v6 + 16)], 8 * (v9 - (int)v8));
        *(_DWORD *)(v6 + 16) = v9;
        v6 = *(_QWORD *)v5;
      }
      v11 = *(_QWORD *)(*(_QWORD *)v6 + 8 * a3);
      result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(_QWORD *)result = v11;
      *(_QWORD *)(*(_QWORD *)v6 + 8 * a3) = result;
    }
    else
    {
      v7 = *(_QWORD *)(v6 + 8);
      result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(_QWORD *)result = v7;
      *(_QWORD *)(v6 + 8) = result;
    }
    ++v5[2];
  }
  return result;
}

uint64_t _dense_allocateRange(uint64_t a1, unint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  void **v13;
  _QWORD *v14;
  void **v15;
  unint64_t v16;
  void **v17;
  void **v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;

  v4 = *(_QWORD **)a1;
  v5 = *(int *)(*(_QWORD *)a1 + 16);
  if (v5 > a2)
  {
    v6 = *(unsigned int **)(*v4 + 8 * a2);
    if (v6)
    {
      v7 = v6[2];
      v8 = *(_QWORD *)v6;
      free(v6);
      *(_QWORD *)(*v4 + 8 * a2) = v8;
      --*(_DWORD *)(a1 + 8);
      return v7;
    }
  }
  LODWORD(v9) = 0;
  while (1)
  {
    v10 = (a2 + 1 + v9);
    if (v10 >= v5)
      break;
    v11 = *(unsigned int **)(*v4 + 8 * v10);
    v9 = (v9 + 1);
    if (v11)
    {
      v7 = v11[2];
      v12 = *(_QWORD *)v11;
      free(v11);
      *(_QWORD *)(*v4 + 8 * v10) = v12;
      --*(_DWORD *)(a1 + 8);
      (*(void (**)(uint64_t, _QWORD, uint64_t))(a1 + 40))(a1, (v7 + a2), v9);
      return v7;
    }
  }
  v15 = (void **)v4[1];
  v14 = v4 + 1;
  v13 = v15;
  if (!v15)
    return 0;
  v16 = *((unsigned int *)v13 + 3);
  if (v16 < a2)
  {
    while (1)
    {
      v17 = v13;
      v13 = (void **)*v13;
      if (!v13)
        return 0;
      v16 = *((unsigned int *)v13 + 3);
      if (v16 >= a2)
        goto LABEL_15;
    }
  }
  v17 = 0;
LABEL_15:
  v18 = (void **)*v13;
  v7 = *((unsigned int *)v13 + 2);
  v19 = (v7 + a2);
  v20 = (v16 - a2);
  free(v13);
  if (v17)
    v21 = v17;
  else
    v21 = v14;
  *v21 = v18;
  --*(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v19, v20);
  return v7;
}

uint64_t _dense_print(uint64_t result, FILE *__stream, int a3)
{
  uint64_t v5;
  int v6;
  uint64_t i;
  _QWORD *v8;
  int v9;
  const char *v10;
  uint64_t *v11;
  int v12;
  const char *v13;

  v5 = *(_QWORD *)result;
  v6 = *(_DWORD *)(*(_QWORD *)result + 16);
  if (v6 >= 1)
  {
    for (i = 0; i < v6; ++i)
    {
      v8 = *(_QWORD **)(*(_QWORD *)v5 + 8 * i);
      if (v8)
      {
        v9 = 0;
        do
        {
          ++v9;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
        if (v9 == 1)
          v10 = "y";
        else
          v10 = "ies";
        result = fprintf(__stream, "Size %d: %d entr%s\n", i, v9, v10);
        v6 = *(_DWORD *)(v5 + 16);
      }
    }
  }
  v11 = *(uint64_t **)(v5 + 8);
  if (v11)
  {
    if (a3)
      fwrite("Large sizes:\n\t", 0xEuLL, 1uLL, __stream);
    v12 = 1;
    if (!a3)
      goto LABEL_17;
    while (1)
    {
      fprintf(__stream, "%d ", *((_DWORD *)v11 + 3));
      v11 = (uint64_t *)*v11;
      if (!v11)
        break;
      while (1)
      {
        ++v12;
        if (a3)
          break;
LABEL_17:
        v11 = (uint64_t *)*v11;
        if (!v11)
        {
          v13 = "ies";
          if (v12 == 1)
            v13 = "y";
          return fprintf(__stream, "Large sizes: %d entr%s\n", v12, v13);
        }
      }
    }
    return fputc(10, __stream);
  }
  return result;
}

uint64_t BOMStorageNewWithOptionsAndSys(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 *v3;
  uint64_t v5;
  uint64_t v6;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE v15[1028];
  int v16;
  __int128 *v17;

  v3 = a3;
  if (!a3)
    v3 = BomSys_default();
  v5 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))v3 + 2))(*((_QWORD *)v3 + 1), a1, 1538, 420);
  if ((_DWORD)v5 == -1)
  {
    v8 = __error();
    strerror(*v8);
    _CUILog(4, (uint64_t)"%s can't open: '%s' %s", v9, v10, v11, v12, v13, v14, (uint64_t)"BOMStorage BOMStorageNewWithOptionsAndSys(const char *, CFDictionaryRef, BomSys *)");
  }
  else
  {
    v6 = v5;
    bzero(v15, 0x470uLL);
    v16 = v6;
    v17 = v3;
    if (!_WriteRootPage((uint64_t)v15))
    {
      (*((void (**)(_QWORD, uint64_t))v3 + 3))(*((_QWORD *)v3 + 1), v6);
      return BOMStorageOpenWithSys(a1, 1, v3);
    }
  }
  return 0;
}

uint64_t _WriteRootPage(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(_QWORD *);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;

  if (a1)
    v2 = *(_QWORD *)(a1 + 1120);
  else
    v2 = 0;
  v3 = 1;
  v4 = BOMStreamWithFileAndSys(*(_DWORD *)(a1 + 1028), 0, 0x200uLL, 1, 0, (__int128 *)v2);
  if (v4)
  {
    v11 = (uint64_t (*)(_QWORD *))v4;
    BOMStreamWriteUInt32((uint64_t (*)(_QWORD *))v4, 1112493395, v5, v6, v7, v8, v9, v10);
    BOMStreamWriteUInt32(v11, 1953460837, v12, v13, v14, v15, v16, v17);
    BOMStreamWriteUInt32(v11, 1, v18, v19, v20, v21, v22, v23);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1056), v24, v25, v26, v27, v28, v29);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1060), v30, v31, v32, v33, v34, v35);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1064), v36, v37, v38, v39, v40, v41);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1096), v42, v43, v44, v45, v46, v47);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1100), v48, v49, v50, v51, v52, v53);
    v3 = BOMStreamFree((uint64_t)v11, v54, v55, v56, v57, v58, v59, v60);
    if ((*(unsigned int (**)(_QWORD, _QWORD))(v2 + 64))(*(_QWORD *)(v2 + 8), *(unsigned int *)(a1 + 1028)))
    {
      v61 = __error();
      strerror(*v61);
      _CUILog(4, (uint64_t)"%s fsync: '%s'", v62, v63, v64, v65, v66, v67, (uint64_t)"int _WriteRootPage(BOMStorage)");
      return 1;
    }
  }
  return v3;
}

void _CreateMapAddress(uint64_t a1, unsigned int a2)
{
  vm_size_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = a2 % vm_page_size;
  if (v3)
    v4 = vm_page_size - v3;
  else
    v4 = 0;
  v5 = v4 + a2;
  v6 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 1120)
                                                                                             + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 1120) + 8), 0, v5, 3, 4098, 0xFFFFFFFFLL, 0);
  *(_QWORD *)(a1 + 1040) = v6;
  if (v6 == -1)
  {
    v7 = __error();
    strerror(*v7);
    _CUILog(4, (uint64_t)"%s can't mmap memory of size '%d' error: '%s'", v8, v9, v10, v11, v12, v13, (uint64_t)"int _CreateMapAddress(BOMStorage, unsigned int)");
    *(_QWORD *)(a1 + 1040) = 0;
  }
  *(_DWORD *)(a1 + 1048) = v5;
}

_QWORD *BOMStorageOpenInRAM(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  int v9;
  char *v10;
  int v11;
  char v12;
  int v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int UInt32;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  BOOL v91;
  unsigned int v92;
  char *v93;
  char *v94;
  int v95;
  char *v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char *v105;
  char *v107;
  int *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  char *v123;
  int v124;
  int v125;
  unsigned int v126;
  char *v127;
  char *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int *v151;
  char v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  char *v160;
  char v161;

  if (a2 <= 0x1FF)
  {
    v8 = BOMExceptionHandlerMessage("stream invalid; root page is outside of address range",
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           v161);
    v9 = *__error();
    v10 = v8;
    v11 = 486;
    goto LABEL_14;
  }
  v12 = a3;
  v13 = a2;
  v15 = BOMStreamWithAddress(a1, 512, 0);
  if (!v15)
  {
    v105 = BOMExceptionHandlerMessage("can't read from memory %p", v16, v17, v18, v19, v20, v21, v22, a1);
    v9 = *__error();
    v10 = v105;
    v11 = 494;
    goto LABEL_14;
  }
  v23 = v15;
  if (BOMStreamReadUInt32(v15, v16, v17, v18, v19, v20, v21, v22) == 1112493395
    && BOMStreamReadUInt32(v23, v24, v25, v26, v27, v28, v29, v30) == 1953460837)
  {
    UInt32 = BOMStreamReadUInt32(v23, v24, v25, v26, v27, v28, v29, v30);
    if (UInt32 == 1)
    {
      v39 = BOM_malloczero(0x470uLL);
      if (!v39)
      {
        v108 = __error();
        strerror(*v108);
        _CUILog(4, (uint64_t)"%s: malloc: %s", v109, v110, v111, v112, v113, v114, (uint64_t)"BOMStorage BOMStorageOpenInRAM(void *, size_t, Boolean)");
        BOMStreamFree(v23, v115, v116, v117, v118, v119, v120, v121);
        return v39;
      }
      v39[140] = BomSys_default();
      *((_DWORD *)v39 + 257) = -1;
      *((_DWORD *)v39 + 258) = v13;
      *((_DWORD *)v39 + 259) = v13;
      *((_DWORD *)v39 + 263) = *((_DWORD *)v39 + 263) & 0xFFFFFFF6 | v12 & 1;
      *((_DWORD *)v39 + 264) = BOMStreamReadUInt32(v23, v40, v41, v42, v43, v44, v45, v46);
      *((_DWORD *)v39 + 265) = BOMStreamReadUInt32(v23, v47, v48, v49, v50, v51, v52, v53);
      *((_DWORD *)v39 + 266) = BOMStreamReadUInt32(v23, v54, v55, v56, v57, v58, v59, v60);
      *((_DWORD *)v39 + 274) = BOMStreamReadUInt32(v23, v61, v62, v63, v64, v65, v66, v67);
      *((_DWORD *)v39 + 275) = BOMStreamReadUInt32(v23, v68, v69, v70, v71, v72, v73, v74);
      *((_DWORD *)v39 + 263) |= 6u;
      BOMStreamFree(v23, v75, v76, v77, v78, v79, v80, v81);
      v89 = *((_DWORD *)v39 + 265);
      v90 = *((_DWORD *)v39 + 266);
      v91 = __CFADD__(v90, v89);
      v92 = v90 + v89;
      if (v91)
      {
        v93 = BOMExceptionHandlerMessage(" <memory>: stream invalid; overflow of admin offset+size",
                v82,
                v83,
                v84,
                v85,
                v86,
                v87,
                v88,
                v161);
        v9 = *__error();
        v10 = v93;
        v11 = 549;
      }
      else
      {
        v122 = *((_DWORD *)v39 + 258);
        if (v92 <= v122)
        {
          v124 = *((_DWORD *)v39 + 274);
          v125 = *((_DWORD *)v39 + 275);
          v91 = __CFADD__(v125, v124);
          v126 = v125 + v124;
          if (v91)
          {
            v127 = BOMExceptionHandlerMessage("<memory>: stream invalid; overflow of toc offset+size",
                     v82,
                     v83,
                     v84,
                     v85,
                     v86,
                     v87,
                     v88,
                     v161);
            v9 = *__error();
            v10 = v127;
            v11 = 561;
          }
          else
          {
            if (v126 <= v122)
            {
              *((_DWORD *)v39 + 262) = v122;
              v39[130] = a1;
              _CreateBlockTable(v39);
              v129 = *((unsigned int *)v39 + 265);
              if ((_DWORD)v129)
              {
                v130 = BOMStreamWithAddress(v39[130] + v129, *((unsigned int *)v39 + 266), 0);
                if (!v130)
                {
                  v151 = __error();
                  v152 = strerror(*v151);
                  v160 = BOMExceptionHandlerMessage("can't read from <memory>: %s", v153, v154, v155, v156, v157, v158, v159, v152);
                  v9 = *__error();
                  v10 = v160;
                  v11 = 585;
                  goto LABEL_14;
                }
                v137 = v130;
                if (_ReadBlockTable((uint64_t)v39, v130, v131, v132, v133, v134, v135, v136)
                  || _ReadFreeList((uint64_t)v39, v137, v138, v139, v140, v141, v142, v143))
                {
                  return 0;
                }
                BOMStreamFree(v137, v144, v145, v146, v147, v148, v149, v150);
              }
              else
              {
                v39[136] = _BOMFreeListAllocate();
              }
              __strlcpy_chk(v39, "<memory>", 1025, 1025);
              return v39;
            }
            v128 = BOMExceptionHandlerMessage("<memory>: stream invalid; toc range is outside file",
                     v82,
                     v83,
                     v84,
                     v85,
                     v86,
                     v87,
                     v88,
                     v161);
            v9 = *__error();
            v10 = v128;
            v11 = 567;
          }
        }
        else
        {
          v123 = BOMExceptionHandlerMessage("<memory>: stream invalid; admin range is outside of file",
                   v82,
                   v83,
                   v84,
                   v85,
                   v86,
                   v87,
                   v88,
                   v161);
          v9 = *__error();
          v10 = v123;
          v11 = 555;
        }
      }
LABEL_14:
      _BOMExceptionHandlerCall(v10, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v11, v9);
      return 0;
    }
    v107 = BOMExceptionHandlerMessage("<memory> has an unknown version: 0x%X", v32, v33, v34, v35, v36, v37, v38, UInt32);
    v95 = *__error();
    v96 = v107;
    v97 = 514;
  }
  else
  {
    v94 = BOMExceptionHandlerMessage("%s is not a BOMStorage file", v24, v25, v26, v27, v28, v29, v30, (char)"<memory>");
    v95 = *__error();
    v96 = v94;
    v97 = 501;
  }
  _BOMExceptionHandlerCall(v96, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v97, v95);
  BOMStreamFree(v23, v98, v99, v100, v101, v102, v103, v104);
  return 0;
}

uint64_t BOMStorageFree(_BYTE *a1)
{
  void *v3;
  void *v4;
  void (**v5)(_QWORD);
  int v6;
  int v7;
  int *v8;
  void *v9;

  if (!a1)
    return 1;
  if ((a1[1052] & 0x10) != 0 && BOMStorageCommit((uint64_t)a1))
    return 1;
  v3 = (void *)*((_QWORD *)a1 + 134);
  if (v3)
  {
    if ((a1[1052] & 1) != 0)
    {
      free(v3);
      v4 = (void *)*((_QWORD *)a1 + 135);
      if (v4)
        free(v4);
    }
  }
  v5 = (void (**)(_QWORD))*((_QWORD *)a1 + 136);
  if (v5)
  {
    v5[4](*((_QWORD *)a1 + 136));
    free(v5);
  }
  if (*((_QWORD *)a1 + 130))
  {
    if ((*((_DWORD *)a1 + 263) & 8) != 0)
    {
      v6 = *((_DWORD *)a1 + 263) & 3;
      v7 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)a1 + 140) + 104))(*(_QWORD *)(*((_QWORD *)a1 + 140) + 8));
      if (v6 != 2 && v7 == -1)
      {
        v8 = __error();
        _BOMExceptionHandlerCall("munmap failed", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1505, *v8);
      }
    }
  }
  if (*((_DWORD *)a1 + 257) != -1)
    (*(void (**)(_QWORD))(*((_QWORD *)a1 + 140) + 24))(*(_QWORD *)(*((_QWORD *)a1 + 140) + 8));
  v9 = (void *)*((_QWORD *)a1 + 141);
  if (v9)
    free(v9);
  free(a1);
  return 0;
}

uint64_t BOMStorageCommit(uint64_t a1)
{
  int v2;
  _BOOL8 v3;
  uint64_t v5;
  int v6;
  size_t v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)(_QWORD *);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t (*v42)(uint64_t, _BOOL8, size_t *);
  _BOOL8 v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  size_t __len;

  if (!a1)
    return 1;
  v2 = *(_DWORD *)(a1 + 1052);
  if ((v2 & 0x10) == 0)
    return 0;
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    v3 = 0;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    goto LABEL_8;
  }
  _FlushWriteCache(a1);
  if (_AdjustFileSize(a1, 0, 0))
    return 1;
  v5 = *(_QWORD *)(a1 + 1088);
  v6 = 8 * (*(_DWORD *)(a1 + 1068) + *(_DWORD *)(v5 + 8));
  v7 = (v6 + 24);
  if (v6 == -24)
  {
    v8 = 0;
  }
  else
  {
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(v5 + 48))(v5, (v6 + 39) & 0xFFFFFFF0);
    if (!v8)
      v8 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
  }
  v9 = *(_DWORD *)(a1 + 1060);
  v10 = *(_DWORD *)(a1 + 1064);
  *(_DWORD *)(a1 + 1060) = v8;
  *(_DWORD *)(a1 + 1064) = v7;
  if (v9 && v10)
    (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
  v11 = v8;
  v3 = 1;
  v12 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v11, v7, 1, 0);
  if (v12)
  {
    v19 = (uint64_t (*)(_QWORD *))v12;
    v20 = *(unsigned int *)(a1 + 1068);
    BOMStreamWriteUInt32((uint64_t (*)(_QWORD *))v12, v20, v13, v14, v15, v16, v17, v18);
    if ((_DWORD)v20)
    {
      v27 = 0;
      v28 = 0;
      do
      {
        if (v28 >= *(unsigned int *)(a1 + 1068))
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v21, v22, v23, v24, v25, v26, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
          v31 = 0xFFFFFFFFLL;
        }
        else
        {
          v29 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v27);
          v30 = bswap32(v29);
          if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
            v31 = v29;
          else
            v31 = v30;
        }
        BOMStreamWriteUInt32(v19, v31, v21, v22, v23, v24, v25, v26);
        if (v28 >= *(unsigned int *)(a1 + 1068))
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v32, v33, v34, v35, v36, v37, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
          v40 = 0;
        }
        else
        {
          v38 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v27 + 4);
          v39 = bswap32(v38);
          if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
            v40 = v38;
          else
            v40 = v39;
        }
        BOMStreamWriteUInt32(v19, v40, v32, v33, v34, v35, v36, v37);
        ++v28;
        v27 += 8;
      }
      while (8 * v20 != v27);
    }
    BOMStreamWriteUInt32(v19, *(unsigned int *)(*(_QWORD *)(a1 + 1088) + 8), v21, v22, v23, v24, v25, v26);
    __len = 0;
    v41 = *(_QWORD *)(a1 + 1088);
    v42 = *(uint64_t (**)(uint64_t, _BOOL8, size_t *))(v41 + 24);
    v43 = BOMStreamGetByteOrder((uint64_t)v19) == 1;
    v44 = (void *)v42(v41, v43, &__len);
    BOMStreamWriteBuffer((uint64_t)v19, v44, __len, v45, v46, v47, v48, v49);
    free(v44);
    v57 = BOMStreamFree((uint64_t)v19, v50, v51, v52, v53, v54, v55, v56);
    if (_AdjustFileSize(a1, 0, 0))
      return 1;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    v3 = (_WriteRootPage(a1) | v57) != 0;
    v2 = *(_DWORD *)(a1 + 1052);
LABEL_8:
    *(_DWORD *)(a1 + 1052) = v2 & 0xFFFFFFEF;
  }
  return v3;
}

uint64_t BOMStorageGetSys(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 1120);
  return result;
}

uint64_t BOMStorageNewBlock(uint64_t a1)
{
  uint64_t v1;
  unsigned int v3;

  if (!a1 || (*(_BYTE *)(a1 + 1052) & 1) == 0)
    return 0;
  v1 = (*(_DWORD *)(a1 + 1056) + 1);
  *(_DWORD *)(a1 + 1056) = v1;
  v3 = *(_DWORD *)(a1 + 1068);
  if (v1 >= v3)
    _ExpandBlockTable((char *)a1, v3 + 8);
  return v1;
}

char *_ExpandBlockTable(char *result, unsigned int a2)
{
  char *v2;
  uint64_t v3;
  int *v5;

  v2 = result;
  v3 = *((unsigned int *)result + 267);
  if (v3 < a2)
  {
    *((_QWORD *)result + 134) = BOM_realloczero(*((void **)result + 134), 8 * v3, 8 * a2);
    result = BOM_realloczero(*((void **)v2 + 135), 4 * *((unsigned int *)v2 + 267), 4 * a2);
    *((_QWORD *)v2 + 135) = result;
    *((_DWORD *)v2 + 267) = a2;
  }
  if (!*((_QWORD *)v2 + 134) || !*((_QWORD *)v2 + 135))
  {
    v5 = __error();
    return (char *)_BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1672, *v5);
  }
  return result;
}

uint64_t BOMStorageNewNamedBlock(uint64_t a1, const char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int UInt32;
  uint64_t (*v35)(_QWORD *);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t (*v42)(_QWORD *);
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t UInt8;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int i;
  _BYTE __dst[255];

  if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
    return 0;
  if (_tocGet(a1, a2))
  {
    _CUILog(4, (uint64_t)"%s: block named '%s' already exists", v4, v5, v6, v7, v8, v9, (uint64_t)"BOMBlockID BOMStorageNewNamedBlock(BOMStorage, const char *)");
    return 0;
  }
  v10 = BOMStorageNewBlock(a1);
  v12 = strnlen(a2, 0xFFuLL);
  v19 = v12;
  if (v12 < 0xFF)
  {
    if (*(_DWORD *)(a1 + 1096))
      v20 = *(_DWORD *)(a1 + 1100);
    else
      v20 = 4;
    v21 = v12 + v20;
    v22 = v21 + 5;
    if (v21 == -5)
    {
      v23 = 0;
    }
    else
    {
      v23 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 48))();
      if (!v23)
        v23 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
    }
    _ExpandMapAddress(a1, v23 + v22);
    v24 = *(unsigned int *)(a1 + 1096);
    if ((_DWORD)v24)
    {
      v25 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v24, *(unsigned int *)(a1 + 1100), 0);
      if (!v25)
        return v10;
      v33 = v25;
      UInt32 = BOMStreamReadUInt32(v25, v26, v27, v28, v29, v30, v31, v32);
    }
    else
    {
      UInt32 = 0;
      v33 = 0;
    }
    v35 = (uint64_t (*)(_QWORD *))BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v23, v22, 1);
    if (v35)
    {
      v42 = v35;
      v43 = v19;
      BOMStreamWriteUInt32(v35, (UInt32 + 1), v36, v37, v38, v39, v40, v41);
      if (v33)
      {
        for (i = v23; UInt32; --UInt32)
        {
          v51 = BOMStreamReadUInt32(v33, v44, v45, v46, v47, v48, v49, v50);
          UInt8 = BOMStreamReadUInt8(v33, v52, v53, v54, v55, v56, v57, v58);
          BOMStreamReadBuffer(v33, __dst, UInt8, v60, v61, v62, v63, v64);
          BOMStreamWriteUInt32(v42, v51, v65, v66, v67, v68, v69, v70);
          BOMStreamWriteUInt8(v42, UInt8, v71, v72, v73, v74, v75, v76);
          BOMStreamWriteBuffer((uint64_t)v42, __dst, UInt8, v77, v78, v79, v80, v81);
        }
        BOMStreamFree(v33, v44, v45, v46, v47, v48, v49, v50);
        if (*(_DWORD *)(a1 + 1096))
        {
          v45 = *(unsigned int *)(a1 + 1100);
          if ((_DWORD)v45)
            (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
        }
        v23 = i;
        v43 = v19;
      }
      BOMStreamWriteUInt32(v42, v10, v45, v46, v47, v48, v49, v50);
      BOMStreamWriteUInt8(v42, v19, v82, v83, v84, v85, v86, v87);
      BOMStreamWriteBuffer((uint64_t)v42, a2, v43, v88, v89, v90, v91, v92);
      BOMStreamFree((uint64_t)v42, v93, v94, v95, v96, v97, v98, v99);
      *(_DWORD *)(a1 + 1096) = v23;
      *(_DWORD *)(a1 + 1100) = v22;
      _AdjustFileSize(a1, v23, v22);
      if (*(_DWORD *)(a1 + 1028) != -1)
        _AddToWriteCache(a1, v23, v22);
      *(_DWORD *)(a1 + 1052) |= 0x10u;
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"%s: name length '%s' is > %d", v13, v14, v15, v16, v17, v18, (uint64_t)"void _tocSet(BOMStorage, BOMBlockID, const char *)");
  }
  return v10;
}

double BOMStorageFreeBlock(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v11;
  int v12;
  double result;
  unsigned int v14;
  unsigned int v15;

  if (a1 && a2 && *(_DWORD *)(a1 + 1056) >= a2)
  {
    v10 = *(_DWORD *)(a1 + 1068);
    if (v10 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
      v10 = *(_DWORD *)(a1 + 1068);
      v12 = -1;
    }
    else
    {
      v11 = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2));
      if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
        v12 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2);
      else
        v12 = v11;
    }
    if (v10 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
LABEL_19:
      result = NAN;
      *(_QWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2) = -1;
      return result;
    }
    v14 = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4));
    if ((*(_BYTE *)(a1 + 1052) & 1) != 0)
      v15 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
    else
      v15 = v14;
    if (v12 != -1 || v15 != -1)
    {
      if (v12)
      {
        if (v15)
          (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
      }
      goto LABEL_19;
    }
  }
  return result;
}

void BOMStorageFreeNamedBlock(uint64_t a1, const char *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(_QWORD *);
  int UInt32;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  size_t UInt8;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char __s1[256];

  if (a1)
  {
    if (a2)
    {
      v4 = _tocGet(a1, a2);
      if (v4)
      {
        BOMStorageFreeBlock(a1, v4, v5, v6, v7, v8, v9, v10);
        if (*(_DWORD *)(a1 + 1096))
        {
          v11 = strlen(a2);
          v12 = *(_DWORD *)(a1 + 1100);
          if (v12)
          {
            v13 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 48))();
            if (!v13)
              v13 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
          }
          else
          {
            v13 = 0;
          }
          v14 = (v12 - v11 - 5);
          _ExpandMapAddress(a1, v13 + v14);
          v15 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + *(unsigned int *)(a1 + 1096), *(unsigned int *)(a1 + 1100), 0);
          if (v15)
          {
            v16 = v15;
            v17 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v13, v14, 1);
            if (v17)
            {
              v25 = (uint64_t (*)(_QWORD *))v17;
              UInt32 = BOMStreamReadUInt32(v16, v18, v19, v20, v21, v22, v23, v24);
              BOMStreamWriteUInt32(v25, (UInt32 - 1), v27, v28, v29, v30, v31, v32);
              for (; UInt32; --UInt32)
              {
                v40 = BOMStreamReadUInt32(v16, v33, v34, v35, v36, v37, v38, v39);
                UInt8 = BOMStreamReadUInt8(v16, v41, v42, v43, v44, v45, v46, v47);
                BOMStreamReadBuffer(v16, __s1, UInt8, v49, v50, v51, v52, v53);
                __s1[UInt8] = 0;
                if (strcmp(__s1, a2))
                {
                  BOMStreamWriteUInt32(v25, v40, v34, v35, v36, v37, v38, v39);
                  BOMStreamWriteUInt8(v25, UInt8, v54, v55, v56, v57, v58, v59);
                  BOMStreamWriteBuffer((uint64_t)v25, __s1, UInt8, v60, v61, v62, v63, v64);
                }
              }
              BOMStreamFree(v16, v33, v34, v35, v36, v37, v38, v39);
              BOMStreamFree((uint64_t)v25, v65, v66, v67, v68, v69, v70, v71);
              if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100))
                (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
              *(_DWORD *)(a1 + 1096) = v13;
              *(_DWORD *)(a1 + 1100) = v14;
              _AdjustFileSize(a1, v13, v14);
              if (*(_DWORD *)(a1 + 1028) != -1)
                _AddToWriteCache(a1, v13, v14);
              *(_DWORD *)(a1 + 1052) |= 0x10u;
            }
          }
        }
      }
    }
  }
}

uint64_t BOMStorageCopyToBlock(uint64_t a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v13;

  if (!a1 || !(_DWORD)a2 || *(_DWORD *)(a1 + 1056) < a2 || (*(_BYTE *)(a1 + 1052) & 1) == 0)
    return 1;
  if (*(_DWORD *)(a1 + 1068) <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    v13 = 0;
  }
  else
  {
    v13 = *(unsigned int *)(*(_QWORD *)(a1 + 1072) + 8 * a2 + 4);
  }
  return BOMStorageCopyToBlockRange(a1, a2, a3, a4, 0, v13, a7, a8);
}

uint64_t BOMStorageCopyToBlockRange(uint64_t a1, uint64_t a2, const void *a3, size_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned int v10;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  int v22;
  char *v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  char *v33;
  unsigned int *v34;
  unint64_t v35;
  const void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int v53;
  const void *v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  size_t v58;
  unsigned int v59;
  uint64_t v60;
  unsigned int v61;
  char *v62;
  int *v63;
  int v64;
  char *v65;
  char *v66;
  char *v67;
  char v68;
  unint64_t v69;

  result = 1;
  if (a1)
  {
    v10 = a2;
    if ((_DWORD)a2)
    {
      if (*(_DWORD *)(a1 + 1056) >= a2 && (*(_BYTE *)(a1 + 1052) & 1) != 0)
      {
        v15 = *(_DWORD *)(a1 + 1068);
        if (v15 <= a2)
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
          v15 = *(_DWORD *)(a1 + 1068);
          v16 = -1;
        }
        else
        {
          v16 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * a2);
        }
        if (v15 <= v10)
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
          v17 = 0;
        }
        else
        {
          v17 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v10 + 4);
          v18 = bswap32(v17);
          if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
            v17 = v18;
        }
        v19 = a6 + a5;
        v20 = v17;
        v21 = v17 - (a6 + a5);
        if (v17 < a6 + a5)
        {
          v22 = *__error();
          v23 = "BOMStorageCopyToBlockRange: length extends beyond block size";
          v24 = 826;
          goto LABEL_31;
        }
        if (v17 <= a5)
          v25 = a5;
        else
          v25 = v17;
        v26 = v25 + a4;
        if (((v25 + a4) | v25 | a4) >> 32)
        {
          v27 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"BOMStorageCopyToBlockRange");
          v22 = *__error();
          v23 = v27;
          v24 = 843;
          goto LABEL_31;
        }
        v28 = v26 - a6;
        if ((v26 - a6) >> 32 || HIDWORD(a6))
        {
          v33 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"BOMStorageCopyToBlockRange");
          v22 = *__error();
          v23 = v33;
          v24 = 845;
          goto LABEL_31;
        }
        if ((_DWORD)v20 != (_DWORD)v28 || (v29 = v16, v16 < *(_DWORD *)(a1 + 1036)))
        {
          if (v16 && (_DWORD)v20)
          {
            v30 = v28;
            (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
            v28 = v30;
          }
          if ((_DWORD)v28)
          {
            v31 = v28;
            v32 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 48))();
            v28 = v31;
            v29 = v32;
            if (!v32)
              v29 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
          }
          else
          {
            v29 = 0;
          }
          v34 = (unsigned int *)(*(_QWORD *)(a1 + 1072) + 8 * v10);
          *v34 = v29;
          v34[1] = v28;
        }
        result = 0;
        if (v29 && (_DWORD)v28)
        {
          v69 = v28;
          v35 = v28 + v29;
          if (HIDWORD(v35))
          {
            v65 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", v35, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"BOMStorageCopyToBlockRange");
            v22 = *__error();
            v23 = v65;
            v24 = 882;
          }
          else
          {
            if (_ExpandMapAddress(a1, v35))
              return 1;
            v43 = v29;
            v44 = v16;
            if (a5 && (v45 = *(_QWORD *)(a1 + 1040), (v36 = (const void *)(v45 + v16)) != 0) && v45 + v29)
            {
              memmove((void *)(v45 + v29), v36, a5);
              v44 = v16;
              v43 = v29;
              v46 = a5;
            }
            else
            {
              v46 = 0;
            }
            v47 = v19 + v44;
            if ((v19 | (v19 + v44)) >> 32)
            {
              v48 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
              v22 = *__error();
              v23 = v48;
              v24 = 905;
            }
            else
            {
              v49 = a5 + a4 + v43;
              if (!(((a5 + a4) | v49) >> 32))
              {
                if (v20 <= a5 || v29 < v16 || v29 >= v20 + v16)
                {
                  if (a4)
                  {
                    v54 = a3;
                    v55 = v46;
                    v56 = v43;
                    v57 = v47;
                    memmove((void *)(*(_QWORD *)(a1 + 1040) + v43 + v46), v54, a4);
                    v47 = v57;
                    v43 = v56;
                    v46 = v55 + a4;
                  }
                  if (v46 < v69)
                  {
                    v58 = v69 - v46;
                    if (HIDWORD(v58))
                    {
                      v67 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
                      v22 = *__error();
                      v23 = v67;
                      v24 = 945;
                      goto LABEL_31;
                    }
                    v59 = v46;
                    memmove((void *)(*(_QWORD *)(a1 + 1040) + v43 + v46), (const void *)(*(_QWORD *)(a1 + 1040) + v47), v58);
                    v46 = v59 + v58;
                  }
                }
                else
                {
                  if (HIDWORD(v21))
                  {
                    v66 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
                    v22 = *__error();
                    v23 = v66;
                    v24 = 917;
                    goto LABEL_31;
                  }
                  if ((_DWORD)v21)
                  {
                    v51 = v46;
                    v52 = v43;
                    memmove((void *)(*(_QWORD *)(a1 + 1040) + v49), (const void *)(*(_QWORD *)(a1 + 1040) + v47), v21);
                    v43 = v52;
                    v46 = v51;
                  }
                  if (a4)
                  {
                    v53 = v46;
                    memmove((void *)(*(_QWORD *)(a1 + 1040) + v43 + v46), a3, a4);
                    v46 = v53 + a4;
                  }
                  v46 += v21;
                }
                v60 = *(_QWORD *)(a1 + 1080);
                if (v60)
                {
                  *(_BYTE *)(v60 + 4 * v10) |= 1u;
                }
                else
                {
                  v61 = v46;
                  v62 = BOMExceptionHandlerMessage("BOM blockShadowTable is null", (uint64_t)v36, v37, v38, v39, v40, v41, v42, v68);
                  v63 = __error();
                  _BOMExceptionHandlerCall(v62, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 957, *v63);
                  v46 = v61;
                }
                v64 = v69;
                if (v46 == (_DWORD)v69)
                {
                  if (*(_DWORD *)(a1 + 1028) == -1)
                  {
                    if (v29 + v69 > *(_DWORD *)(a1 + 1032))
                      *(_DWORD *)(a1 + 1032) = v29 + v69;
                  }
                  else
                  {
                    _AddToWriteCache(a1, v29, v69);
                    v64 = v69;
                  }
                  result = _AdjustFileSize(a1, v29, v64);
                  if (!(_DWORD)result)
                  {
                    *(_DWORD *)(a1 + 1052) |= 0x10u;
                    return result;
                  }
                  return 1;
                }
                v22 = *__error();
                v23 = "BOMStorageCopyToBlockRange: internal consistency error";
                v24 = 962;
                goto LABEL_31;
              }
              v50 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
              v22 = *__error();
              v23 = v50;
              v24 = 906;
            }
          }
LABEL_31:
          _BOMExceptionHandlerCall(v23, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v24, v22);
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t _ExpandMapAddress(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  vm_address_t v7;
  vm_address_t v8;
  int *v9;
  int *v10;
  uint64_t v11;
  int v12;
  char *v13;
  int v14;

  v3 = *(_DWORD *)(a1 + 1048);
  if (v3 < a2)
  {
    if (v3 >= 0x100000)
      LODWORD(v4) = v3 + 0x100000;
    else
      LODWORD(v4) = 2 * v3;
    if (v4 <= a2)
      v4 = a2;
    else
      v4 = v4;
    v5 = vm_page_size - v4 % vm_page_size;
    if (!(v4 % vm_page_size))
      v5 = 0;
    v6 = (v5 + v4);
    v7 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 1120)
                                                                                               + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 1120) + 8), 0, v6, 3, 4098, 0xFFFFFFFFLL, 0);
    if (v7 == -1)
    {
      v12 = *__error();
      v13 = "mmap failed";
      v11 = 1;
      v14 = 1531;
    }
    else
    {
      v8 = v7;
      if (vm_copy(mach_task_self_, *(_QWORD *)(a1 + 1040), *(unsigned int *)(a1 + 1048), v7))
      {
        v9 = __error();
        _BOMExceptionHandlerCall("vm_copy failed", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1535, *v9);
      }
      if ((*(unsigned int (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 1120) + 104))(*(_QWORD *)(*(_QWORD *)(a1 + 1120) + 8), *(_QWORD *)(a1 + 1040), *(unsigned int *)(a1 + 1048)) != -1)
      {
        *(_QWORD *)(a1 + 1040) = v8;
        *(_DWORD *)(a1 + 1048) = v6;
        if (!v8)
          goto LABEL_17;
        return 0;
      }
      v12 = *__error();
      v13 = "munmap failed";
      v11 = 1;
      v14 = 1538;
    }
    _BOMExceptionHandlerCall(v13, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v14, v12);
    return v11;
  }
  if (!*(_QWORD *)(a1 + 1040))
  {
LABEL_17:
    v10 = __error();
    _BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1551, *v10);
  }
  return 0;
}

void _AddToWriteCache(uint64_t a1, unsigned int a2, int a3)
{
  _DWORD *v5;
  unsigned int v6;
  _DWORD *v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  _DWORD *v12;
  int v13;
  _DWORD *v14;
  _QWORD *v15;
  unsigned int v16;
  _DWORD *v17;
  int *v18;

  if (!a2 || !a3)
    return;
  v5 = *(_DWORD **)(a1 + 1104);
  if (v5)
  {
    v6 = v5[2];
    if (v6 <= a2)
    {
      while (1)
      {
        v7 = v5;
        v5 = *(_DWORD **)v5;
        if (!v5)
          break;
        v8 = v5[2];
        if (v8 >= a2)
        {
          v10 = v7[3];
          if (v10 + v7[2] != a2)
            goto LABEL_6;
          v7[3] = v10 + a3;
          if (a3 + a2 == v5[2])
          {
            v7[3] = v5[3] + v10 + a3;
            *(_QWORD *)v7 = *(_QWORD *)v5;
            free(v5);
            v11 = *(_DWORD *)(a1 + 1112) - 1;
            goto LABEL_23;
          }
          goto LABEL_24;
        }
      }
      v13 = v7[3];
      if (v13 + v7[2] == a2)
      {
        v7[3] = v13 + a3;
        goto LABEL_24;
      }
      v12 = _newFreeListEntry(a2, a3);
      if (v12)
      {
        *(_QWORD *)v12 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      v7 = 0;
      v8 = v5[2];
LABEL_6:
      if (a3 + a2 == v8)
      {
        v9 = v5[3] + a3;
        v5[2] = a2;
        v5[3] = v9;
        goto LABEL_24;
      }
      v12 = _newFreeListEntry(a2, a3);
      if (v12)
      {
        *(_QWORD *)v12 = v5;
        if (v6 <= a2)
LABEL_21:
          *(_QWORD *)v7 = v12;
        else
          *(_QWORD *)(a1 + 1104) = v12;
        v11 = *(_DWORD *)(a1 + 1112) + 1;
        goto LABEL_23;
      }
    }
    v18 = __error();
    _BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 2104, *v18);
    return;
  }
  *(_QWORD *)(a1 + 1104) = _newFreeListEntry(a2, a3);
  v11 = 1;
LABEL_23:
  *(_DWORD *)(a1 + 1112) = v11;
LABEL_24:
  if (*(_DWORD *)(a1 + 1112) < 0x10u)
  {
    v14 = *(_DWORD **)(a1 + 1104);
    if (v14)
    {
      v15 = 0;
      do
      {
        v16 = v14[3];
        if (v16 < 0xFFFF)
        {
          v17 = *(_DWORD **)v14;
          v15 = v14;
        }
        else
        {
          v17 = *(_DWORD **)v14;
          if (v15)
          {
            *v15 = v17;
            v17 = *(_DWORD **)v14;
          }
          else
          {
            *(_QWORD *)(a1 + 1104) = v17;
          }
          _WriteAddress(a1, v14[2], v16);
          free(v14);
          --*(_DWORD *)(a1 + 1112);
        }
        v14 = v17;
      }
      while (v17);
    }
  }
  else
  {
    _FlushWriteCache(a1);
  }
}

uint64_t _AdjustFileSize(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2)
  {
    if ((a3 + a2) <= *(_DWORD *)(a1 + 1032))
    {
      return 0;
    }
    else
    {
      result = 0;
      *(_DWORD *)(a1 + 1032) = a3 + a2;
    }
  }
  else
  {
    v5 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 1120) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 1120) + 8), *(unsigned int *)(a1 + 1028), 0, 2);
    if (v5 == -1)
    {
      v7 = __error();
      strerror(*v7);
      _CUILog(4, (uint64_t)"%s: lseek: %s", v8, v9, v10, v11, v12, v13, (uint64_t)"int _AdjustFileSize(BOMStorage, unsigned int, unsigned int)");
      return 1;
    }
    else
    {
      v6 = v5;
      result = 0;
      *(_DWORD *)(a1 + 1032) = v6;
    }
  }
  return result;
}

void _FlushWriteCache(uint64_t a1)
{
  _DWORD *i;

  for (i = *(_DWORD **)(a1 + 1104); i; i = *(_DWORD **)(a1 + 1104))
  {
    *(_QWORD *)(a1 + 1104) = *(_QWORD *)i;
    _WriteAddress(a1, i[2], i[3]);
    free(i);
  }
  *(_DWORD *)(a1 + 1112) = 0;
}

uint64_t BOMStorageCompact(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  size_t v53;
  unsigned int v54;
  _BYTE *v55;
  _BYTE *v56;
  int *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  void *v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  char __s[1025];
  _BYTE v85[1025];

  if (!a1 || (*(_BYTE *)(a1 + 1052) & 1) == 0 || *(_DWORD *)(a1 + 1028) == -1)
    return 1;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v75 = 0u;
  v2 = *(_QWORD *)(a1 + 1120);
  BOMStorageCommit(a1);
  __strlcpy_chk(v85, a1, 1025, 1025);
  v3 = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *))(v2 + 72))(*(_QWORD *)(v2 + 8), *(unsigned int *)(a1 + 1028), &v75);
  if (v3 == -1)
  {
    v4 = __error();
    v5 = strerror(*v4);
    v13 = BOMExceptionHandlerMessage("fstat: %s", v6, v7, v8, v9, v10, v11, v12, v5);
    v14 = __error();
    _BOMExceptionHandlerCall(v13, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1303, *v14);
  }
  __strlcpy_chk(__s, v85, 1025, 1025);
  v15 = strrchr(__s, 47);
  if (v15)
    *v15 = 0;
  else
    __strlcpy_chk(__s, ".", 1025, 1025);
  __strlcat_chk(__s, "/tmp.XXXXXX", 1025, 1025);
  if (!mktemp(__s))
  {
    _CUILog(4, (uint64_t)"%s: mktemp can't get temp file %s", v17, v18, v19, v20, v21, v22, (uint64_t)"int BOMStorageCompact(BOMStorage)");
    return 1;
  }
  v23 = BOMStorageNewWithOptionsAndSys((uint64_t)__s, v16, (__int128 *)v2);
  if (!v23)
    goto LABEL_56;
  v24 = v23;
  if (*(_DWORD *)(a1 + 1056))
  {
    v25 = 1;
    do
    {
      if ((_DWORD)v25 != BOMStorageNewBlock(v24))
      {
        _CUILog(4, (uint64_t)"%s: unable to reserve block %d", v26, v27, v28, v29, v30, v31, (uint64_t)"int BOMStorageCompact(BOMStorage)");
        goto LABEL_56;
      }
      v32 = *(_DWORD *)(a1 + 1068);
      if (v32 <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v26, v27, v28, v29, v30, v31, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
        v32 = *(_DWORD *)(a1 + 1068);
      }
      else
      {
        v33 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v25);
        v34 = bswap32(v33);
        if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
          v33 = v34;
        if (v33 != -1)
          goto LABEL_26;
      }
      if (v32 <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v26, v27, v28, v29, v30, v31, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        v32 = *(_DWORD *)(a1 + 1068);
      }
      else
      {
        v35 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v25 + 4);
        v36 = bswap32(v35);
        if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
          v35 = v36;
        if (v35 == -1)
        {
          BOMStorageFreeBlock(v24, v25, v26, v27, v28, v29, v30, v31);
          goto LABEL_39;
        }
      }
LABEL_26:
      if (v32 <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v26, v27, v28, v29, v30, v31, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        v37 = 0;
      }
      else
      {
        v37 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v25 + 4);
        v38 = bswap32(v37);
        if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
          v37 = v38;
      }
      v39 = BOM_malloc(v37);
      if (BOMStorageCopyFromBlock(a1, v25, v39, v40, v41, v42, v43, v44))
        goto LABEL_45;
      if (*(_DWORD *)(a1 + 1068) <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v45, v46, v47, v48, v49, v50, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        v51 = 0;
      }
      else
      {
        v51 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8 * v25 + 4);
        v52 = bswap32(v51);
        if ((*(_BYTE *)(a1 + 1052) & 1) == 0)
          v51 = v52;
      }
      if (BOMStorageCopyToBlock(v24, v25, v39, v51, v47, v48, v49, v50))
      {
LABEL_45:
        _CUILog(4, (uint64_t)"%s: unable to copy block %d", v45, v46, v47, v48, v49, v50, (uint64_t)"int BOMStorageCompact(BOMStorage)");
        free(v39);
        goto LABEL_56;
      }
      free(v39);
LABEL_39:
      v25 = (v25 + 1);
    }
    while (v25 <= *(_DWORD *)(a1 + 1056));
  }
  if (*(_DWORD *)(a1 + 1096))
  {
    v53 = *(unsigned int *)(a1 + 1100);
    *(_DWORD *)(v24 + 1100) = v53;
    if ((_DWORD)v53)
    {
      v54 = (*(uint64_t (**)(void))(*(_QWORD *)(v24 + 1088) + 48))();
      if (!v54)
        v54 = (*(_DWORD *)(v24 + 1032) + 15) & 0xFFFFFFF0;
    }
    else
    {
      v54 = 0;
    }
    *(_DWORD *)(v24 + 1096) = v54;
    _ExpandMapAddress(v24, v54 + v53);
    memmove((void *)(*(_QWORD *)(v24 + 1040) + *(unsigned int *)(v24 + 1096)), (const void *)(*(_QWORD *)(a1 + 1040) + *(unsigned int *)(a1 + 1096)), v53);
    _AdjustFileSize(v24, v54, v53);
    if (*(_DWORD *)(v24 + 1028) != -1)
      _AddToWriteCache(v24, v54, v53);
    *(_DWORD *)(v24 + 1052) |= 0x10u;
  }
  BOMStorageCommit(v24);
  v55 = BOM_malloc(0x470uLL);
  if (!v55)
  {
    BOMStorageFree((_BYTE *)v24);
    v67 = __error();
    strerror(*v67);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v68, v69, v70, v71, v72, v73, (uint64_t)"int BOMStorageCompact(BOMStorage)");
LABEL_56:
    unlink(__s);
    return 1;
  }
  v56 = v55;
  memcpy(v55, (const void *)a1, 0x470uLL);
  BOMStorageFree(v56);
  if ((*(unsigned int (**)(_QWORD, char *, _BYTE *))(v2 + 88))(*(_QWORD *)(v2 + 8), __s, v85))
  {
    v57 = __error();
    strerror(*v57);
    _CUILog(4, (uint64_t)"%s: rename: '%s' '%s' failed %s", v58, v59, v60, v61, v62, v63, (uint64_t)"int BOMStorageCompact(BOMStorage)");
    BOMStorageFree((_BYTE *)v24);
    v64 = 1;
    v65 = (void *)BOMStorageOpenWithSys((uint64_t)v85, 1, (__int128 *)v2);
    if (v65)
    {
      v66 = v65;
      memcpy((void *)a1, v65, 0x470uLL);
      free(v66);
    }
  }
  else
  {
    if (v3 != -1)
    {
      (*(void (**)(_QWORD, _QWORD, _QWORD))(v2 + 112))(*(_QWORD *)(v2 + 8), *(unsigned int *)(v24 + 1028), WORD2(v75));
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(v2 + 120))(*(_QWORD *)(v2 + 8), *(unsigned int *)(v24 + 1028), v76, DWORD1(v76));
    }
    memcpy((void *)a1, (const void *)v24, 0x470uLL);
    __strlcpy_chk(a1, v85, 1025, 1025);
    free((void *)v24);
    return 0;
  }
  return v64;
}

_DWORD *_newFreeListEntry(int a1, int a2)
{
  _DWORD *v4;
  _DWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = BOM_malloc(0x10uLL);
  v5 = v4;
  if (v4)
  {
    *(_QWORD *)v4 = 0;
    v4[2] = a1;
    v4[3] = a2;
  }
  else
  {
    v6 = __error();
    strerror(*v6);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v7, v8, v9, v10, v11, v12, (uint64_t)"FreeListEntry _newFreeListEntry(unsigned int, unsigned int)");
  }
  return v5;
}

uint64_t (*_WriteAddress(uint64_t a1, unsigned int a2, unsigned int a3))(_QWORD *)
{
  _QWORD *v3;
  void *v4;
  int *v6;

  v3 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), a2, a3, 1, (char *)(*(_QWORD *)(a1 + 1040) + a2));
  if (v3)
  {
    v4 = v3;
    BOMStreamFlush();
    return (uint64_t (*)(_QWORD *))BOMStreamFree(v4);
  }
  else
  {
    v6 = __error();
    return _BOMExceptionHandlerCall("Unable to create write stream.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 2177, *v6);
  }
}

uint64_t BOMStreamWithBlockID(uint64_t a1, unsigned int a2, size_t a3, int a4)
{
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v8 = BOM_malloczero(0x58uLL);
  v15 = (uint64_t)v8;
  if (!v8)
  {
    v28 = __error();
    strerror(*v28);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v29, v30, v31, v32, v33, v34, (uint64_t)"BOMStreamWithBlockID");
    return v15;
  }
  v8[1] = 1;
  v16 = BOMStorageSizeOfBlock(a1, a2, v9, v10, v11, v12, v13, v14);
  *(_QWORD *)(v15 + 72) = BOMStorageGetSys(a1);
  *(_DWORD *)v15 = 0;
  *(_QWORD *)(v15 + 8) = a1;
  *(_DWORD *)(v15 + 16) = a2;
  if (a3)
    v17 = a3;
  else
    v17 = v16;
  *(_QWORD *)(v15 + 32) = v17;
  *(_DWORD *)(v15 + 40) = a4;
  if (v16 <= a3)
    v18 = a3;
  else
    v18 = v16;
  v19 = (char *)BOM_malloczero(v18);
  *(_QWORD *)(v15 + 48) = v19;
  if (!v19)
  {
    v35 = __error();
    strerror(*v35);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v36, v37, v38, v39, v40, v41, (uint64_t)"BOMStreamWithBlockID");
    goto LABEL_16;
  }
  v26 = (uint64_t)v19;
  *(_BYTE *)(v15 + 80) |= 1u;
  v27 = *(_QWORD *)(v15 + 32);
  *(_QWORD *)(v15 + 56) = v19;
  *(_QWORD *)(v15 + 64) = &v19[v27];
  if ((*(_DWORD *)(v15 + 40) | 2) != 2)
    goto LABEL_12;
  if (BOMStorageCopyFromBlock(a1, a2, v19, v21, v22, v23, v24, v25))
  {
LABEL_16:
    BOMStreamFree(v15, v20, v26, v21, v22, v23, v24, v25);
    return 0;
  }
  v27 = *(_QWORD *)(v15 + 32);
LABEL_12:
  if (!v27)
    goto LABEL_16;
  return v15;
}

_QWORD *BOMStreamWithFile(int a1, uint64_t a2, size_t a3, int a4, char *a5)
{
  return BOMStreamWithFileAndSys(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMStreamFlush(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t result;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (!a1)
  {
    _CUILog(4, (uint64_t)"%s: bad stream!", a3, a4, a5, a6, a7, a8, (uint64_t)"BOMStreamFlush");
    return 1;
  }
  if (!a1[10])
    goto LABEL_13;
  v9 = *a1;
  if (*a1 == 2)
    goto LABEL_13;
  if (v9 == 1)
  {
    if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1 + 9) + 56))(*(_QWORD *)(*((_QWORD *)a1 + 9) + 8), a1[5], *((_QWORD *)a1 + 3), 0) == -1)
    {
      v18 = __error();
      strerror(*v18);
      _CUILog(4, (uint64_t)"%s: lseek: %s", v19, v20, v21, v22, v23, v24, (uint64_t)"BOMStreamFlush");
    }
    else
    {
      if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1 + 9) + 48))(*(_QWORD *)(*((_QWORD *)a1 + 9) + 8), a1[5], *((_QWORD *)a1 + 6), *((_QWORD *)a1 + 4)) == *((_QWORD *)a1 + 4))
      {
LABEL_13:
        result = 0;
        goto LABEL_14;
      }
      v11 = __error();
      strerror(*v11);
      _CUILog(4, (uint64_t)"%s: write: %s", v12, v13, v14, v15, v16, v17, (uint64_t)"BOMStreamFlush");
    }
    return 1;
  }
  if (v9)
  {
    _CUILog(4, (uint64_t)"%s: unknown stream type: %d", a3, a4, a5, a6, a7, a8, (uint64_t)"BOMStreamFlush");
    goto LABEL_13;
  }
  result = BOMStorageCopyToBlock(*((_QWORD *)a1 + 1), a1[4], *((const void **)a1 + 6), *((_QWORD *)a1 + 4), a5, a6, a7, a8);
LABEL_14:
  *((_BYTE *)a1 + 80) &= ~2u;
  return result;
}

uint64_t BOMStreamGetByteOrder(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 4);
  return result;
}

uint64_t (*BOMStreamWriteUInt32(uint64_t (*result)(_QWORD *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(_QWORD *)
{
  unsigned int v8;
  int v9;
  _DWORD *v10;
  char *v11;
  int v12;
  char *v13;
  unsigned __int8 v14;
  int v15;
  char *v16;

  v8 = bswap32(a2);
  if (*((_DWORD *)result + 1) == 2)
    v9 = a2;
  else
    v9 = v8;
  if (!*((_DWORD *)result + 10))
  {
    v16 = BOMExceptionHandlerMessage("%s write called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt32");
    v12 = *__error();
    v13 = v16;
    v14 = 0;
    v15 = 371;
    return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
  }
  v10 = (_DWORD *)*((_QWORD *)result + 7);
  if ((unint64_t)(v10 + 1) > *((_QWORD *)result + 8))
  {
    v11 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt32");
    v12 = *__error();
    v13 = v11;
    v14 = 1;
    v15 = 373;
    return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
  }
  *v10 = v9;
  *((_QWORD *)result + 7) += 4;
  *((_BYTE *)result + 80) |= 2u;
  return result;
}

uint64_t (*BOMStreamWriteUInt16(uint64_t (*result)(_QWORD *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(_QWORD *)
{
  __int16 v8;
  __int16 v9;
  _WORD *v10;
  char *v11;
  int v12;
  char *v13;
  unsigned __int8 v14;
  int v15;
  char *v16;

  v8 = __rev16(a2);
  if (*((_DWORD *)result + 1) == 2)
    v9 = a2;
  else
    v9 = v8;
  if (!*((_DWORD *)result + 10))
  {
    v16 = BOMExceptionHandlerMessage("%s write called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt16");
    v12 = *__error();
    v13 = v16;
    v14 = 0;
    v15 = 390;
    return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
  }
  v10 = (_WORD *)*((_QWORD *)result + 7);
  if ((unint64_t)(v10 + 1) > *((_QWORD *)result + 8))
  {
    v11 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt16");
    v12 = *__error();
    v13 = v11;
    v14 = 1;
    v15 = 392;
    return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
  }
  *v10 = v9;
  *((_QWORD *)result + 7) += 2;
  *((_BYTE *)result + 80) |= 2u;
  return result;
}

uint64_t (*BOMStreamWriteUInt8(uint64_t (*result)(_QWORD *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(_QWORD *)
{
  _BYTE *v8;
  char *v9;
  int v10;
  char *v11;
  unsigned __int8 v12;
  int v13;
  char *v14;

  if (!*((_DWORD *)result + 10))
  {
    v14 = BOMExceptionHandlerMessage("%s write called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt8");
    v10 = *__error();
    v11 = v14;
    v12 = 0;
    v13 = 403;
    return _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
  }
  v8 = (_BYTE *)*((_QWORD *)result + 7);
  if ((unint64_t)(v8 + 1) > *((_QWORD *)result + 8))
  {
    v9 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt8");
    v10 = *__error();
    v11 = v9;
    v12 = 1;
    v13 = 405;
    return _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
  }
  *v8 = a2;
  ++*((_QWORD *)result + 7);
  *((_BYTE *)result + 80) |= 2u;
  return result;
}

uint64_t (*BOMStreamWriteBuffer(uint64_t a1, const void *a2, size_t __len, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(_QWORD *)
{
  void *v10;
  char *v11;
  int v12;
  char *v13;
  unsigned __int8 v14;
  int v15;
  char *v16;
  uint64_t (*result)(_QWORD *);

  if (!*(_DWORD *)(a1 + 40))
  {
    v16 = BOMExceptionHandlerMessage("%s write called on read-only buffer", (uint64_t)a2, __len, a4, a5, a6, a7, a8, (char)"BOMStreamWriteBuffer");
    v12 = *__error();
    v13 = v16;
    v14 = 0;
    v15 = 416;
    return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
  }
  v10 = *(void **)(a1 + 56);
  if ((unint64_t)v10 + __len > *(_QWORD *)(a1 + 64))
  {
    v11 = BOMExceptionHandlerMessage("%s buffer overflow", (uint64_t)a2, __len, a4, a5, a6, a7, a8, (char)"BOMStreamWriteBuffer");
    v12 = *__error();
    v13 = v11;
    v14 = 1;
    v15 = 418;
    return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
  }
  result = (uint64_t (*)(_QWORD *))memmove(v10, a2, __len);
  *(_QWORD *)(a1 + 56) += __len;
  *(_BYTE *)(a1 + 80) |= 2u;
  return result;
}

_DWORD *BOMTreeNewWithName(uint64_t a1, const char *a2)
{
  unsigned int v4;

  if (a1 && a2 && (v4 = BOMStorageNewNamedBlock(a1, a2)) != 0)
    return _BOMTreeNew(a1, a2, v4, 0, 0);
  else
    return 0;
}

_DWORD *_BOMTreeNew(uint64_t a1, const char *a2, unsigned int a3, int a4, char a5)
{
  _DWORD *result;
  uint64_t v11;
  int v12;
  unsigned int v13;
  _QWORD *v14;

  result = _newBOMTree(a1, a2);
  if (result)
  {
    v11 = (uint64_t)result;
    result[4] = a3;
    if ((a4 - 1) >= 0x2F)
      v12 = a4;
    else
      v12 = 48;
    if (!v12)
      v12 = 4096;
    result[76] = v12;
    v13 = v12 - 16;
    result[77] = v13 >> 3;
    result[78] = (v13 >> 3) + 1;
    result[79] = v13 >> 4;
    result[89] = result[89] & 0xFFFFFFFB | (4 * (a5 & 1));
    v14 = _NewPage((uint64_t)result, 0);
    *(_QWORD *)(v11 + 24) = v14;
    *((_WORD *)v14 + 2) |= 1u;
    *(_DWORD *)(v11 + 356) |= 1u;
    BOMTreeFree(v11);
    return (_DWORD *)_BOMTreeOpen(a1, a2, a3, 1);
  }
  return result;
}

_DWORD *BOMTreeNewWithOptions(uint64_t a1, unsigned int a2, const char *a3, int a4, char a5)
{
  unsigned int v8;

  if (a1 && ((v8 = a2) != 0 || a3) && (a2 || (v8 = BOMStorageNewNamedBlock(a1, a3)) != 0))
    return _BOMTreeNew(a1, a3, v8, a4, a5);
  else
    return 0;
}

uint64_t BOMTreeFree(uint64_t result)
{
  uint64_t v1;
  uint64_t i;
  _WORD *v3;
  void *v4;
  const void *v5;
  void *v6;
  void *v7;

  if (result)
  {
    v1 = result;
    if ((*(_BYTE *)(result + 356) & 1) != 0 && BOMTreeCommit(result))
    {
      return 1;
    }
    else
    {
      for (i = 32; i != 288; i += 8)
      {
        v3 = *(_WORD **)(v1 + i);
        if (v3)
        {
          if ((v3[2] & 2) != 0)
            _WritePage(v1, *(_QWORD *)(v1 + i));
          _FreePage(v1, v3);
          *(_QWORD *)(v1 + i) = 0;
        }
      }
      _FreePage(v1, *(void **)(v1 + 24));
      *(_QWORD *)(v1 + 24) = 0;
      v4 = *(void **)(v1 + 8);
      if (v4 && (*(_BYTE *)(v1 + 356) & 0x20) != 0)
      {
        free(v4);
        *(_QWORD *)(v1 + 8) = 0;
      }
      v5 = *(const void **)(v1 + 296);
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)(v1 + 296) = 0;
      }
      v6 = *(void **)(v1 + 336);
      if (v6)
      {
        free(v6);
        *(_QWORD *)(v1 + 336) = 0;
      }
      v7 = *(void **)(v1 + 320);
      if (v7)
        free(v7);
      free((void *)v1);
      return 0;
    }
  }
  return result;
}

uint64_t BOMTreeCommit(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v5;
  uint64_t (*v6)(_QWORD *);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(_QWORD *);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;

  if (!a1 || (*(_BYTE *)(a1 + 356) & 1) == 0)
    return 0;
  for (i = 32; i != 288; i += 8)
  {
    v5 = *(_QWORD *)(a1 + i);
    if (v5 && (*(_WORD *)(v5 + 4) & 2) != 0)
      _WritePage(a1, v5);
  }
  _WritePage(a1, *(_QWORD *)(a1 + 24));
  v2 = 1;
  v6 = (uint64_t (*)(_QWORD *))BOMStreamWithBlockID(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), 0x1DuLL, 1);
  if (v6)
  {
    v13 = v6;
    BOMStreamWriteUInt32(v6, 1953654117, v7, v8, v9, v10, v11, v12);
    BOMStreamWriteUInt32(v13, 1, v14, v15, v16, v17, v18, v19);
    BOMStreamWriteUInt32(v13, **(unsigned int **)(a1 + 24), v20, v21, v22, v23, v24, v25);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a1 + 304), v26, v27, v28, v29, v30, v31);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a1 + 20), v32, v33, v34, v35, v36, v37);
    BOMStreamWriteUInt8(v13, (*(unsigned __int8 *)(a1 + 356) >> 2) & 1, v38, v39, v40, v41, v42, v43);
    if ((*(_BYTE *)(a1 + 356) & 4) != 0)
      v50 = 0;
    else
      v50 = *(unsigned int *)(a1 + 348);
    BOMStreamWriteUInt32(v13, v50, v44, v45, v46, v47, v48, v49);
    BOMStreamWriteUInt32(v13, 0, v51, v52, v53, v54, v55, v56);
    if (!BOMStreamFree((uint64_t)v13, v57, v58, v59, v60, v61, v62, v63))
    {
      v2 = 0;
      *(_DWORD *)(a1 + 356) &= ~1u;
    }
  }
  return v2;
}

void _FreePage(uint64_t a1, void *a2)
{
  if (a2)
  {
    *(_DWORD *)a2 = -1;
    *((_QWORD *)a2 + 1) = -1;
    *((_QWORD *)a2 + 4) = 0;
    if ((*(_BYTE *)(a1 + 356) & 0x40) == 0)
      free(*((void **)a2 + 3));
    free(a2);
  }
}

uint64_t BOMTreeRemoveAndFree(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  void *v51;
  const void *v52;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)result;
    v3 = BOMTreeIteratorNew(result, 0, 0, 0);
    if (v3)
    {
      for (i = v3;
            !BOMTreeIteratorIsAtEnd((uint64_t)i, v4, v5, v6, v7, v8, v9, v10);
            BOMTreeIteratorNext((uint64_t)i, v31, v32, v33, v34, v35, v36, v37))
      {
        v19 = (void *)BOMTreeIteratorKey((uint64_t)i, v12, v13, v14, v15, v16, v17, v18);
        v27 = BOMTreeIteratorKeySize((uint64_t)i, v20, v21, v22, v23, v24, v25, v26);
        BOMTreeRemoveValue(v1, v19, v27, v28, v29, v30);
      }
      BOMTreeIteratorFree(i);
      BOMStorageFreeBlock(v2, **(_DWORD **)(v1 + 24), v38, v39, v40, v41, v42, v43);
      _FreePage(v1, *(void **)(v1 + 24));
      *(_QWORD *)(v1 + 24) = 0;
      v50 = *(const char **)(v1 + 8);
      if (v50)
        BOMStorageFreeNamedBlock(v2, v50);
      else
        BOMStorageFreeBlock(v2, *(_DWORD *)(v1 + 16), v44, v45, v46, v47, v48, v49);
      v51 = *(void **)(v1 + 8);
      if (v51 && (*(_BYTE *)(v1 + 356) & 0x20) != 0)
      {
        free(v51);
        *(_QWORD *)(v1 + 8) = 0;
      }
      v52 = *(const void **)(v1 + 296);
      if (v52)
        CFRelease(v52);
      free((void *)v1);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMTreeRemoveValue(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  int v8;
  uint64_t v9;

  result = 1;
  if (a1)
  {
    if (a2)
    {
      v8 = *(_DWORD *)(a1 + 356);
      if (a3 || (v8 & 4) != 0)
      {
        if ((v8 & 2) != 0)
        {
          v9 = *(_QWORD *)(a1 + 24);
          result = _findRemove(a1, &v9, 0, 0, 0, 0, a2, a3, 0);
          if (!(_DWORD)result)
          {
            --*(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 356) |= 1u;
          }
        }
        else
        {
          _CUILog(4, (uint64_t)"%s BOMTree '%s' is read-only can't remove value", a3, a4, a5, a6, (uint64_t)a2, a3, (uint64_t)"int BOMTreeRemoveValue(BOMTree, void *, size_t)");
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t (*_WritePage(uint64_t a1, uint64_t a2))(_QWORD *)
{
  size_t v4;
  int v5;
  uint64_t (*result)(_QWORD *);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(_QWORD *);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  int *v77;

  v4 = *(unsigned int *)(a1 + 304);
  if ((*(_BYTE *)(a1 + 356) & 4) == 0)
  {
    v5 = *(_DWORD *)(a1 + 348);
    if (v5 >= 1)
      v4 += v5 * (unint64_t)*(unsigned __int16 *)(a2 + 16);
  }
  result = (uint64_t (*)(_QWORD *))BOMStreamWithBlockID(*(_QWORD *)a1, *(_DWORD *)a2, v4, 1);
  if (result)
  {
    v13 = result;
    BOMStreamWriteUInt16(result, *(_WORD *)(a2 + 4) & 1, v7, v8, v9, v10, v11, v12);
    BOMStreamWriteUInt16(v13, *(unsigned __int16 *)(a2 + 16), v14, v15, v16, v17, v18, v19);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a2 + 8), v20, v21, v22, v23, v24, v25);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a2 + 12), v26, v27, v28, v29, v30, v31);
    if (*(_WORD *)(a2 + 16))
    {
      v38 = 0;
      v39 = 0;
      do
      {
        BOMStreamWriteUInt32(v13, *(unsigned int *)(*(_QWORD *)(a2 + 24) + v38), v32, v33, v34, v35, v36, v37);
        BOMStreamWriteUInt32(v13, *(unsigned int *)(*(_QWORD *)(a2 + 24) + v38 + 4), v40, v41, v42, v43, v44, v45);
        ++v39;
        v46 = *(unsigned __int16 *)(a2 + 16);
        v38 += 8;
      }
      while (v39 < v46);
    }
    else
    {
      v46 = 0;
    }
    BOMStreamWriteUInt32(v13, *(unsigned int *)(*(_QWORD *)(a2 + 24) + 8 * v46), v32, v33, v34, v35, v36, v37);
    if ((*(_BYTE *)(a1 + 356) & 4) == 0)
    {
      v54 = *(unsigned int *)(a1 + 348);
      if ((int)v54 >= 1)
      {
        v61 = BOM_malloc(v54);
        if (*(_WORD *)(a2 + 16))
        {
          v62 = 0;
          v63 = 4;
          do
          {
            if (BOMStorageSizeOfBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(a2 + 24) + v63), v55, v56, v57, v58, v59, v60) != *(_DWORD *)(a1 + 348))
            {
              v76 = BOMExceptionHandlerMessage("%s blockSize %d != tree->keySize %d", v64, v65, v66, v67, v68, v69, v70, (char)"_WritePage");
              v77 = __error();
              _BOMFatalException(v76, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 1408, *v77);
            }
            BOMStorageCopyFromBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(a2 + 24) + v63), v61, v66, v67, v68, v69, v70);
            BOMStreamWriteBuffer((uint64_t)v13, v61, *(int *)(a1 + 348), v71, v72, v73, v74, v75);
            ++v62;
            v63 += 8;
          }
          while (v62 < *(unsigned __int16 *)(a2 + 16));
        }
        free(v61);
      }
    }
    result = (uint64_t (*)(_QWORD *))BOMStreamFree((uint64_t)v13, v47, v48, v49, v50, v51, v52, v53);
    *(_WORD *)(a2 + 4) &= ~2u;
  }
  return result;
}

uint64_t BOMTreeSetValue(uint64_t a1, void *a2, unint64_t a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v14;
  void **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unsigned int IndexForKey;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  int v40;
  BOOL v42;

  v42 = 0;
  v8 = 1;
  if (a1)
  {
    if (a2)
    {
      v14 = *(_DWORD *)(a1 + 356);
      if (a3 || (v14 & 4) != 0)
      {
        if ((v14 & 2) == 0)
        {
          _CUILog(4, (uint64_t)"%s: BOMTree '%s' is read-only tree can't update values", a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"int BOMTreeSetValue(BOMTree, void *, size_t, void *, size_t)");
          return v8;
        }
        v15 = BOMStackNew();
        if (!_findPagesForKey(a1, (char *)v15, a2, a3, v16, v17, v18, v19))
        {
          BOMStackFree(v15);
          return v8;
        }
        if (v15)
        {
          if ((*(_BYTE *)(a1 + 356) & 4) != 0)
          {
            v31 = (int)a2;
          }
          else
          {
            v20 = BOMStackPeek(v15);
            if (!v20)
            {
              v33 = 0;
              goto LABEL_27;
            }
            v24 = v20;
            IndexForKey = _findIndexForKey(a1, (uint64_t)v20, a2, a3, &v42, v21, v22, v23);
            if (v42)
            {
              v30 = (unsigned int *)(v24[3] + 8 * IndexForKey);
              v32 = *v30;
              v31 = v30[1];
              if ((_DWORD)v32)
              {
LABEL_17:
                if (!BOMStorageCopyToBlock(*(_QWORD *)a1, v32, a4, a5, v26, v27, v28, v29)
                  && !_PageSetValue(a1, (uint64_t *)v15, a2, a3, v31, v32))
                {
                  if (!v42)
                    ++*(_DWORD *)(a1 + 20);
                  v8 = 0;
                  *(_DWORD *)(a1 + 356) |= 1u;
                  v33 = 1;
LABEL_27:
                  while (!BOMStackIsEmpty((uint64_t)v15))
                  {
                    v39 = BOMStackPop((uint64_t *)v15);
                    *((_WORD *)v39 + 2) &= ~8u;
                  }
                  BOMStackFree(v15);
                  if (v33)
                  {
                    if ((*(_BYTE *)(a1 + 356) & 4) == 0)
                    {
                      v40 = *(_DWORD *)(a1 + 348);
                      if (v40 != -1)
                      {
                        if (!v40)
                        {
                          v8 = 0;
                          *(_DWORD *)(a1 + 348) = a3;
                          return v8;
                        }
                        if (v40 != a3)
                        {
                          v8 = 0;
                          *(_DWORD *)(a1 + 348) = -1;
                          return v8;
                        }
                      }
                    }
                    return 0;
                  }
                  return v8;
                }
LABEL_25:
                v33 = 0;
                v8 = 1;
                goto LABEL_27;
              }
            }
            else
            {
              v34 = BOMStorageNewBlock(*(_QWORD *)a1);
              if (!(_DWORD)v34)
                goto LABEL_25;
              v31 = v34;
              if (BOMStorageCopyToBlock(*(_QWORD *)a1, v34, a2, a3, v35, v36, v37, v38))
                goto LABEL_25;
            }
          }
          v32 = BOMStorageNewBlock(*(_QWORD *)a1);
          if (!(_DWORD)v32)
            goto LABEL_25;
          goto LABEL_17;
        }
      }
    }
  }
  return v8;
}

uint64_t _PageSetValue(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t *v13;
  uint64_t v14;
  _BOOL4 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int IndexForKey;
  uint64_t v20;
  unsigned __int16 v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int *v37;
  int v38;
  int v39;
  int v40;
  _QWORD *Page;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int16 v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD *v52;
  uint64_t v53;
  unsigned int v54;
  _QWORD *v55;
  _QWORD *v56;
  _DWORD *v57;
  int v58;
  char *v59;
  int v60;
  BOOL v62;

  v62 = 0;
  v6 = 1;
  if (a5)
  {
    if (a6)
    {
      v13 = BOMStackPop(a2);
      if (v13)
      {
        v14 = (uint64_t)v13;
        v15 = (*((_WORD *)v13 + 2) & 1) == 0;
        _invalidateIteratorsForPageID(a1, *(_DWORD *)v13);
        IndexForKey = _findIndexForKey(a1, v14, a3, a4, &v62, v16, v17, v18);
        v20 = *(_QWORD *)(v14 + 24);
        if (v62)
        {
          v21 = *(_WORD *)(v14 + 16);
        }
        else
        {
          if (*(_DWORD *)(v20 + 8 * IndexForKey + 4))
          {
            v22 = *(_DWORD *)(a1 + 356);
            if ((v22 & 8) != 0)
            {
              *(_DWORD *)(a1 + 356) = v22 & 0xFFFFFFF7;
              v20 = *(_QWORD *)(v14 + 24);
            }
            v23 = *(unsigned __int16 *)(v14 + 16);
            LODWORD(v24) = v23 - IndexForKey;
            if (v23 != IndexForKey)
            {
              if (v24 <= 1)
                v24 = 1;
              else
                v24 = v24;
              v25 = v15 + v23;
              v26 = *(unsigned __int16 *)(v14 + 16);
              do
              {
                v27 = v20 + 8 * v26--;
                v28 = 8 * v25--;
                v29 = *(_DWORD *)(v20 + 8 * v25);
                *(_DWORD *)(v27 + 4) = *(_DWORD *)(v20 + 8 * v26 + 4);
                *(_DWORD *)(v20 + v28) = v29;
                --v24;
              }
              while (v24);
            }
          }
          else
          {
            LOWORD(v23) = *(_WORD *)(v14 + 16);
          }
          *(_DWORD *)(v20 + 8 * IndexForKey + 4) = a5;
          v21 = v23 + 1;
          *(_WORD *)(v14 + 16) = v23 + 1;
        }
        *(_DWORD *)(v20 + 8 * (IndexForKey + v15)) = a6;
        *(_WORD *)(v14 + 4) |= 2u;
        if (*(_DWORD *)(a1 + 308) >= v21)
        {
          v6 = 0;
        }
        else
        {
          v30 = _NewPage(a1, 0);
          if (v30)
          {
            v37 = (unsigned int *)v30;
            *((_WORD *)v30 + 2) = *((_WORD *)v30 + 2) & 0xFFFC | *(_WORD *)(v14 + 4) & 1 | 2;
            if ((*(_WORD *)(v14 + 4) & 1) == 0
              || (v38 = *(_DWORD *)v30,
                  v39 = *(_DWORD *)v14,
                  *((_DWORD *)v30 + 2) = *(_DWORD *)(v14 + 8),
                  *(_DWORD *)(v14 + 8) = v38,
                  *((_DWORD *)v30 + 3) = v39,
                  (v40 = *((_DWORD *)v30 + 2)) == 0))
            {
LABEL_25:
              if ((*(_BYTE *)(a1 + 356) & 8) != 0)
              {
                LODWORD(v43) = *(_DWORD *)(a1 + 308) - 1;
                v42 = *(unsigned __int16 *)(v14 + 16);
              }
              else
              {
                v42 = *(unsigned __int16 *)(v14 + 16);
                LODWORD(v43) = v42 >> 1;
              }
              v44 = *(_QWORD *)(v14 + 24);
              v45 = *((_QWORD *)v37 + 3);
              if ((int)v43 + 1 >= (int)v42)
              {
                v47 = *((_WORD *)v37 + 8);
                v43 = (int)v43;
                v49 = v42;
              }
              else
              {
                v43 = (int)v43;
                v46 = (int)v43 + 1;
                v47 = *((_WORD *)v37 + 8);
                do
                {
                  v48 = (_QWORD *)(v44 + 8 * v46);
                  *(_QWORD *)(v45 + 8 * v47++) = *v48;
                  *((_WORD *)v37 + 8) = v47;
                  *v48 = 0;
                  ++v46;
                  v49 = *(unsigned __int16 *)(v14 + 16);
                }
                while (v46 < v49);
                LOWORD(v42) = *(_WORD *)(v14 + 16);
              }
              v50 = 8 * v49;
              *(_DWORD *)(v45 + 8 * v47) = *(_DWORD *)(v44 + v50);
              *(_DWORD *)(v44 + v50) = 0;
              *(_WORD *)(v14 + 16) = v42 - v47;
              v51 = v44 + 8 * v43;
              v54 = *(_DWORD *)(v51 + 4);
              v52 = (_DWORD *)(v51 + 4);
              v53 = v54;
              if ((*(_BYTE *)(v14 + 4) & 1) == 0)
              {
                *v52 = 0;
                *(_WORD *)(v14 + 16) = v42 - v47 - 1;
              }
              _addPageToCache(a1, (uint64_t)v37);
              if (BOMStackIsEmpty((uint64_t)a2))
              {
                v55 = _NewPage(a1, 0);
                v6 = 1;
                if (v55)
                {
                  v56 = v55;
                  v57 = (_DWORD *)v55[3];
                  *v57 = *(_DWORD *)v14;
                  v57[1] = v53;
                  v57[2] = *v37;
                  *((_WORD *)v55 + 8) = 1;
                  *((_WORD *)v55 + 2) |= 2u;
                  _addPageToCache(a1, v14);
                  v6 = 0;
                  *(_QWORD *)(a1 + 24) = v56;
                }
              }
              else
              {
                v6 = _PageSetValue(a1, a2, a3, a4, v53, *v37);
              }
              goto LABEL_44;
            }
            Page = _findPage(a1, v40, v31, v32, v33, v34, v35, v36);
            if (Page)
            {
              if (*((_DWORD *)Page + 3) == *(_DWORD *)v14)
              {
                *((_DWORD *)Page + 3) = *v37;
                *((_WORD *)Page + 2) |= 2u;
                goto LABEL_25;
              }
              v58 = *__error();
              v59 = "internal btree error";
              v6 = 1;
              v60 = 2201;
            }
            else
            {
              v58 = *__error();
              v59 = "missing tree page";
              v6 = 1;
              v60 = 2197;
            }
            _BOMExceptionHandlerCall(v59, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", v60, v58);
          }
          else
          {
            v6 = 1;
          }
        }
LABEL_44:
        *(_WORD *)(v14 + 4) &= ~8u;
      }
    }
  }
  return v6;
}

uint64_t _findRemove(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, unint64_t a8, char *a9)
{
  uint64_t v11;
  uint64_t *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unsigned int IndexForKey;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  _QWORD *v27;
  __int16 v28;
  _BOOL4 v29;
  uint64_t result;
  char v31;
  _QWORD *v32;
  __int16 v33;
  uint64_t v34;
  char v35;
  _QWORD *v36;
  uint64_t v37;
  __int16 v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  __int16 v46;
  unsigned int v47;
  unsigned int v48;
  _WORD *v49;
  uint64_t v50;
  uint64_t v51;
  _BOOL4 v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  _WORD *Page;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  BOOL v66;
  _BOOL4 v67;
  _WORD *v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  _DWORD *v74;
  int v75;
  char v76;
  unsigned __int16 v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int *v84;
  uint64_t v85;
  void *v86;
  unint64_t v87;
  _BOOL4 v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t *v91;
  uint64_t v92;
  char *v94;
  char v95;
  _QWORD *v96;
  BOOL v97;

  v11 = a6;
  v14 = a2;
  v15 = a1;
  v16 = a9;
  v97 = 0;
  v17 = *a2;
  v96 = 0;
  v95 = 0;
  if (!a9)
    v16 = &v95;
  v94 = v16;
  IndexForKey = _findIndexForKey(a1, v17, a7, a8, &v97, a6, (uint64_t)a7, a8);
  v25 = IndexForKey;
  *(_DWORD *)(v17 + 20) = IndexForKey;
  if ((*(_BYTE *)(v17 + 4) & 1) != 0)
  {
    v29 = v97;
    result = 1;
    if (!v97)
      return result;
LABEL_42:
    if (v29)
    {
      _invalidateIteratorsForPageID(v15, *(_DWORD *)v17);
LABEL_45:
      v39 = *(unsigned __int16 *)(v17 + 16);
      v40 = *(_QWORD *)(v17 + 24);
      LODWORD(v41) = v39 - v25;
      if (v39 == v25)
      {
        v42 = 0;
        v43 = 0;
        *(_DWORD *)(v40 + 8 * (v25 - 1) + 4) = 0;
      }
      else
      {
        v44 = (unsigned int *)(v40 + 8 * v25);
        v43 = *v44;
        v42 = v44[1];
        if (v41 <= 1)
          v41 = 1;
        else
          v41 = v41;
        v45 = v25;
        do
        {
          *(_QWORD *)(v40 + 8 * v45) = *(_QWORD *)(v40 + 8 * (v45 + 1));
          ++v45;
          --v41;
        }
        while (v41);
      }
      *(_DWORD *)(v40 + 8 * v39) = 0;
      *(_WORD *)(v17 + 16) = v39 - 1;
      if ((*(_WORD *)(v17 + 4) & 1) != 0)
      {
        if ((*(_BYTE *)(v15 + 356) & 4) == 0 && v42)
          BOMStorageFreeBlock(*(_QWORD *)v15, v42, v19, v20, v21, v22, v23, v24);
        if (v43)
          BOMStorageFreeBlock(*(_QWORD *)v15, v43, v19, v20, v21, v22, v23, v24);
      }
      v46 = *(_WORD *)(v17 + 4);
      *(_WORD *)(v17 + 4) = v46 | 2;
      v47 = *(unsigned __int16 *)(v17 + 16);
      if ((v46 & 1) != 0 && v11 && v25 == v47)
      {
        *(_DWORD *)(*(_QWORD *)(v11 + 24) + 8 * *(unsigned int *)(v11 + 20) + 4) = *(_DWORD *)(*(_QWORD *)(v17 + 24)
                                                                                               + 8 * (v25 - 1)
                                                                                               + 4);
        *(_WORD *)(v11 + 4) |= 2u;
        v47 = *(unsigned __int16 *)(v17 + 16);
      }
      v48 = *(_DWORD *)(v15 + 316);
      if (v48 <= v47)
      {
        result = 0;
        *v94 = 0;
        return result;
      }
      if (v17 != *(_QWORD *)(v15 + 24))
      {
        v49 = (_WORD *)*v14;
        if (!(a3 | a4))
        {
LABEL_111:
          result = 0;
          *v14 = (uint64_t)v49;
          return result;
        }
        v89 = a3;
        v91 = v14;
        if (a3)
          v50 = a3;
        else
          v50 = a4;
        v51 = a5;
        if (!a3)
          v51 = v11;
        if (a4)
          v52 = a3 != 0;
        else
          v52 = 0;
        v88 = v52;
        if (v52)
        {
          v53 = *(unsigned __int16 *)(a3 + 16);
          v54 = *(unsigned __int16 *)(a4 + 16);
          if (v53 >= v54)
          {
            if (v53 <= v54)
            {
              v63 = *(_DWORD *)(*(_QWORD *)(v11 + 24) + 8 * *(unsigned int *)(v11 + 20));
              if (*(_DWORD *)v49 == v63)
                v50 = a4;
              else
                v50 = a3;
              if (*(_DWORD *)v49 != v63)
                v11 = a5;
            }
            else
            {
              v50 = a3;
              v11 = a5;
            }
          }
          else
          {
            v50 = a4;
          }
        }
        else
        {
          v11 = v51;
        }
        v64 = *(unsigned __int16 *)(v50 + 16);
        v65 = a4;
        v66 = v50 == a4;
        v67 = v50 == a4;
        if (v66)
          v68 = (_WORD *)*v14;
        else
          v68 = (_WORD *)v50;
        if ((v49[2] & 1) != 0)
          _invalidateIteratorsForPageID(v15, *(_DWORD *)v50);
        v69 = v11;
        v70 = *(_DWORD *)(v11 + 20) - (v50 != v65);
        if ((v68[2] & 1) == 0)
        {
          v71 = (unsigned __int16)v68[8];
          *(_DWORD *)(*((_QWORD *)v68 + 3) + 8 * v71 + 4) = *(_DWORD *)(*(_QWORD *)(v69 + 24) + 8 * v70 + 4);
          v68[8] = v71 + 1;
          v68[2] |= 2u;
        }
        if (v48 < v64)
        {
          _shiftKeysAndValues(v15, (uint64_t)v49, v50, v67);
          v72 = *(_DWORD *)(*((_QWORD *)v68 + 3) + 8 * (unsigned __int16)v68[8] - 4);
          v73 = *(_QWORD *)(v69 + 24) + 8 * v70;
          v75 = *(_DWORD *)(v73 + 4);
          v74 = (_DWORD *)(v73 + 4);
          if (v75 != v72)
          {
            *v74 = v72;
            *(_WORD *)(v69 + 4) |= 2u;
          }
          v14 = v91;
          v76 = 0;
          if ((v68[2] & 1) == 0)
          {
            v77 = v68[8] - 1;
            v68[8] = v77;
            *(_DWORD *)(*((_QWORD *)v68 + 3) + 8 * v77 + 4) = 0;
            v68[2] |= 2u;
          }
          goto LABEL_110;
        }
        _shiftKeysAndValues(v15, v50, (uint64_t)v49, v50 != v65);
        if (v88)
        {
          v14 = v91;
          *(_DWORD *)(v89 + 8) = *(_DWORD *)v65;
          *(_DWORD *)(v65 + 12) = *(_DWORD *)v89;
          *(_WORD *)(v89 + 4) |= 2u;
        }
        else if (v89)
        {
          *(_DWORD *)(v89 + 8) = 0;
          v65 = v89;
          v14 = v91;
        }
        else
        {
          v14 = v91;
          if (!v65)
          {
LABEL_109:
            v49[2] &= ~8u;
            _removePageFromCache(v15, v49);
            BOMStorageFreeBlock(*(_QWORD *)v15, *(_DWORD *)v49, v78, v79, v80, v81, v82, v83);
            _FreePage(v15, v49);
            v49 = 0;
            v76 = 1;
LABEL_110:
            *v94 = v76;
            goto LABEL_111;
          }
          *(_DWORD *)(v65 + 12) = 0;
        }
        *(_WORD *)(v65 + 4) |= 2u;
        goto LABEL_109;
      }
      if (!(*(_WORD *)(v17 + 4) & 1 | v47))
      {
        v55 = **(_DWORD **)(v17 + 24);
        if (v55)
        {
          Page = _findPage(v15, v55, v19, v20, v21, v22, v23, v24);
          Page[2] &= ~8u;
          _removePageFromCache(v15, Page);
          *(_QWORD *)(v15 + 24) = Page;
          BOMStorageFreeBlock(*(_QWORD *)v15, *(_DWORD *)v17, v57, v58, v59, v60, v61, v62);
          _FreePage(v15, (void *)v17);
        }
      }
      return 0;
    }
LABEL_44:
    if (!*v94)
      return 0;
    goto LABEL_45;
  }
  v92 = v11;
  if (IndexForKey)
  {
    v26 = v15;
    v27 = _findPage(v15, *(_DWORD *)(*(_QWORD *)(v17 + 24) + 8 * (IndexForKey - 1)), v19, v20, v21, v22, v23, v24);
    v28 = *((_WORD *)v27 + 2);
    if ((v28 & 8) == 0)
    {
      v85 = v17;
LABEL_12:
      v31 = 0;
      *((_WORD *)v27 + 2) = v28 | 8;
      goto LABEL_16;
    }
    v31 = 1;
    v85 = v17;
  }
  else if (a3)
  {
    v26 = v15;
    v27 = _findPage(v15, *(_DWORD *)(*(_QWORD *)(a3 + 24) + 8 * *(unsigned __int16 *)(a3 + 16)), v19, v20, v21, v22, v23, v24);
    v28 = *((_WORD *)v27 + 2);
    if ((v28 & 8) == 0)
    {
      v85 = a5;
      goto LABEL_12;
    }
    v31 = 1;
    v85 = a5;
  }
  else
  {
    v26 = v15;
    v85 = 0;
    v27 = 0;
    v31 = 1;
  }
LABEL_16:
  v90 = v14;
  v87 = a8;
  v86 = a7;
  if (v25 == *(unsigned __int16 *)(v17 + 16))
  {
    if (a4)
    {
      v32 = _findPage(v26, **(_DWORD **)(a4 + 24), v19, v20, v21, v22, v23, v24);
      v33 = *((_WORD *)v32 + 2);
      if ((v33 & 8) == 0)
      {
        v34 = v92;
LABEL_22:
        v35 = 0;
        *((_WORD *)v32 + 2) = v33 | 8;
        goto LABEL_26;
      }
      v35 = 1;
      v34 = v92;
    }
    else
    {
      v34 = 0;
      v32 = 0;
      v35 = 1;
    }
  }
  else
  {
    v32 = _findPage(v26, *(_DWORD *)(*(_QWORD *)(v17 + 24) + 8 * (v25 + 1)), v19, v20, v21, v22, v23, v24);
    v33 = *((_WORD *)v32 + 2);
    if ((v33 & 8) == 0)
    {
      v34 = v17;
      goto LABEL_22;
    }
    v35 = 1;
    v34 = v17;
  }
LABEL_26:
  v36 = _findPage(v26, *(_DWORD *)(*(_QWORD *)(v17 + 24) + 8 * v25), v19, v20, v21, v22, v23, v24);
  v96 = v36;
  if (!v36)
  {
    v84 = __error();
    _BOMFatalException("BOMTree in invalid state - nextNode is NULL!", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 1810, *v84);
  }
  v37 = v34;
  v38 = *((_WORD *)v36 + 2);
  if ((v38 & 8) == 0)
    *((_WORD *)v36 + 2) = v38 | 8;
  if (a3)
    *(_WORD *)(a3 + 4) &= ~4u;
  if (a4)
    *(_WORD *)(a4 + 4) &= ~4u;
  *((_WORD *)v36 + 2) &= ~4u;
  result = _findRemove(v26, &v96, v27, v32, v85, v37, v86, v87, v94);
  if ((v31 & 1) == 0)
    *((_WORD *)v27 + 2) &= ~8u;
  if ((v35 & 1) == 0)
    *((_WORD *)v32 + 2) &= ~8u;
  v15 = v26;
  if ((v38 & 8) == 0 && v96)
    *((_WORD *)v96 + 2) &= ~8u;
  v14 = v90;
  v11 = v92;
  if (!(_DWORD)result)
  {
    v29 = v97;
    if ((*(_WORD *)(v17 + 4) & 1) == 0)
      goto LABEL_44;
    goto LABEL_42;
  }
  return result;
}

uint64_t BOMTreeIteratorValueSize(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;

  if (!a1 || (*((_BYTE *)a1 + 57) & 8) != 0)
    return 0;
  if ((*((_BYTE *)a1 + 57) & 1) != 0 || (v9 = a1[1]) == 0 || *(_DWORD *)v9 != *((_DWORD *)a1 + 4))
  {
    if (_revalidateIterator((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8))
    {
      v9 = a1[1];
      goto LABEL_8;
    }
    *((_BYTE *)a1 + 57) |= 8u;
    return 0;
  }
LABEL_8:
  v10 = *(_DWORD *)(v9[3] + 8 * *((int *)a1 + 5));
  v11 = bswap32(v10);
  if ((*((_DWORD *)*a1 + 89) & 0x40) != 0)
    v12 = v11;
  else
    v12 = v10;
  return BOMStorageSizeOfBlock(**a1, v12, a3, a4, a5, a6, a7, a8);
}

uint64_t BOMTreeUsesNumericKeys(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 356) >> 2) & 1;
}

uint64_t BOMTreePageSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 304);
}

void _invalidateIteratorsForPageID(uint64_t a1, unsigned int a2)
{
  const __CFArray *v3;
  CFIndex v5;
  CFIndex v6;
  CFIndex v7;
  CFRange v8;

  v3 = *(const __CFArray **)(a1 + 296);
  if (v3)
  {
    v5 = BOMCFArrayMaxRange(v3);
    v7 = v6;
    v8.location = v5;
    v8.length = v7;
    CFArrayApplyFunction(*(CFArrayRef *)(a1 + 296), v8, (CFArrayApplierFunction)_invalidateIterator, (void *)a2);
  }
}

void _addPageToCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  _WORD *v5;
  _WORD *v6;
  __int16 v8;
  int v9;
  BOOL v10;
  int v11;
  int v12;
  uint64_t v13;
  _WORD *v14;

  v3 = a1 + 8 * *(int *)(a1 + 288);
  v6 = *(_WORD **)(v3 + 32);
  v4 = (_QWORD *)(v3 + 32);
  v5 = v6;
  if (v6)
  {
    while (1)
    {
      v8 = v5[2];
      if ((v8 & 0xC) == 4)
        break;
      v5[2] = v8 | 4;
      v9 = *(_DWORD *)(a1 + 288) + 1;
      v10 = -v9 < 0;
      v11 = -v9 & 0x1F;
      v12 = v9 & 0x1F;
      if (!v10)
        v12 = -v11;
      *(_DWORD *)(a1 + 288) = v12;
      v13 = a1 + 8 * v12;
      v14 = *(_WORD **)(v13 + 32);
      v4 = (_QWORD *)(v13 + 32);
      v5 = v14;
      if (!v14)
        goto LABEL_10;
    }
    if ((v8 & 2) != 0)
      _WritePage(a1, (uint64_t)v5);
    _FreePage(a1, v5);
    v4 = (_QWORD *)(a1 + 8 * *(int *)(a1 + 288) + 32);
  }
LABEL_10:
  *v4 = a2;
}

uint64_t _invalidateIterator(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  size_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;

  if (result)
  {
    v8 = result;
    if (*(_DWORD *)(result + 16) == a2 && (*(_BYTE *)(result + 57) & 9) == 0)
    {
      result = *(_QWORD *)(result + 8);
      if (!result || *(_DWORD *)result != a2)
      {
        result = (uint64_t)_findPage(*(_QWORD *)v8, a2, a3, a4, a5, a6, a7, a8);
        *(_QWORD *)(v8 + 8) = result;
        if (!result)
          goto LABEL_27;
      }
      v9 = *(_QWORD *)v8;
      v10 = *(_DWORD *)(*(_QWORD *)v8 + 356);
      if ((v10 & 4) != 0)
      {
        v12 = *(_DWORD *)(*(_QWORD *)(result + 24) + 8 * *(int *)(v8 + 20) + 4);
        v13 = bswap32(v12);
        if ((v10 & 0x40) != 0)
          v14 = v13;
        else
          v14 = v12;
        *(_QWORD *)(v8 + 24) = v14;
        *(_QWORD *)(v8 + 32) = 0;
        goto LABEL_27;
      }
      if ((v10 & 0x40) != 0)
      {
        v15 = *(unsigned int *)(v9 + 348);
        if ((int)v15 >= 1)
        {
LABEL_17:
          *(_QWORD *)(v8 + 32) = v15;
          v16 = *(void **)(v8 + 24);
          if (v16)
          {
            free(v16);
            *(_QWORD *)(v8 + 24) = 0;
            v15 = *(_QWORD *)(v8 + 32);
          }
          v17 = BOM_malloc(v15);
          *(_QWORD *)(v8 + 24) = v17;
          if (!v17)
          {
            v28 = __error();
            _BOMFatalException("BOMTree iterator cannot cache keys. This is a fatal error (!it->key).", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2773, *v28);
          }
          v23 = *(_QWORD *)v8;
          if ((*(_BYTE *)(*(_QWORD *)v8 + 356) & 0x40) != 0)
          {
            v25 = *(unsigned int *)(v23 + 348);
            v26 = *(_QWORD *)(v8 + 8);
            if ((int)v25 >= 1)
            {
              v27 = *(_QWORD *)(v26 + 32);
              if (!v27)
              {
                v30 = __error();
                _BOMFatalException("BOMTree iterator cannot cache keys. This is a fatal error (__getKeyIDValuePTR return 0).", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2781, *v30);
              }
              result = (uint64_t)memcpy(v17, (const void *)(v27 + *(int *)(v8 + 20) * v25), v25);
              goto LABEL_27;
            }
            v24 = bswap32(*(_DWORD *)(*(_QWORD *)(v26 + 24) + 8 * *(int *)(v8 + 20) + 4));
          }
          else
          {
            v24 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
          }
          result = BOMStorageCopyFromBlock(*(_QWORD *)v23, v24, v17, v18, v19, v20, v21, v22);
          if ((_DWORD)result)
          {
            v29 = __error();
            _BOMFatalException("BOMTree iterator cannot cache keys. This is a fatal error (BOMStorageCopyFromBlock returned an error).", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2786, *v29);
          }
LABEL_27:
          *(_BYTE *)(v8 + 57) |= 1u;
          return result;
        }
        v11 = bswap32(*(_DWORD *)(*(_QWORD *)(result + 24) + 8 * *(int *)(v8 + 20) + 4));
      }
      else
      {
        v11 = *(_DWORD *)(*(_QWORD *)(result + 24) + 8 * *(int *)(v8 + 20) + 4);
      }
      v15 = BOMStorageSizeOfBlock(*(_QWORD *)v9, v11, a3, a4, a5, a6, a7, a8);
      goto LABEL_17;
    }
  }
  return result;
}

void _removePageFromCache(uint64_t a1, _WORD *a2)
{
  uint64_t i;
  const __CFArray *v5;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  CFRange v9;

  if ((a2[2] & 8) == 0)
  {
    for (i = 32; i != 288; i += 8)
    {
      if (*(_WORD **)(a1 + i) == a2)
      {
        v5 = *(const __CFArray **)(a1 + 296);
        if (v5)
        {
          v6 = BOMCFArrayMaxRange(v5);
          v8 = v7;
          v9.location = v6;
          v9.length = v8;
          CFArrayApplyFunction(*(CFArrayRef *)(a1 + 296), v9, (CFArrayApplierFunction)_pageRemovedCallback, a2);
        }
        *(_QWORD *)(a1 + i) = 0;
      }
    }
    if ((a2[2] & 2) != 0)
      _WritePage(a1, (uint64_t)a2);
  }
}

uint64_t _pageRemovedCallback(uint64_t result, uint64_t a2)
{
  if (result && a2 && *(_QWORD *)(result + 8) == a2)
    *(_QWORD *)(result + 8) = 0;
  return result;
}

uint64_t _shiftKeysAndValues(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  __int16 v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v4 = *(unsigned __int16 *)(a3 + 16);
  v5 = *(_DWORD *)(result + 316);
  v6 = v4 >= v5;
  v8 = v4 - v5;
  v7 = v8 != 0 && v6;
  v9 = (v8 + 1) >> 1;
  if (v7)
    v10 = v9;
  else
    v10 = *(unsigned __int16 *)(a3 + 16);
  v11 = *(unsigned __int16 *)(a2 + 16);
  v12 = v10 + v11;
  v13 = v4 - v10;
  if (a4)
  {
    v14 = 0;
    if (!v10)
      goto LABEL_14;
    goto LABEL_10;
  }
  v15 = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(v15 + 8 * (v10 + v11)) = *(_DWORD *)(v15 + 8 * v11);
  if ((_DWORD)v11)
  {
    do
    {
      v16 = v10 - 1 + v11--;
      *(_QWORD *)(v15 + 8 * v16) = *(_QWORD *)(v15 + 8 * v11);
    }
    while (v11);
  }
  v14 = v4 - v10;
  if (v10)
  {
LABEL_10:
    v17 = *(_QWORD *)(a3 + 24);
    v18 = *(_QWORD *)(a2 + 24);
    v11 = v11;
    v19 = v10;
    do
    {
      *(_QWORD *)(v18 + 8 * v11) = *(_QWORD *)(v17 + 8 * v14);
      if (!a4)
        *(_QWORD *)(v17 + 8 * v14) = 0;
      ++v11;
      ++v14;
      --v19;
    }
    while (v19);
  }
LABEL_14:
  if (a4)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0 && (_DWORD)v4 == v10)
    {
      v20 = *(_QWORD *)(a3 + 24);
      v21 = 8 * v14;
      *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * v11) = *(_DWORD *)(v20 + v21);
      *(_DWORD *)(v20 + v21) = 0;
    }
    if ((_DWORD)v4 != v10)
    {
      if ((_DWORD)v4)
      {
        v22 = 0;
        v23 = v13 + v10;
        v24 = 8 * v10;
        v25 = 8 * v23;
        do
        {
          if (v22 >= v13)
          {
            v26 = *(_QWORD *)(a3 + 24);
            if (v13 == v22)
              *(_QWORD *)(v26 + 8 * v13) = *(unsigned int *)(v26 + v25);
            else
              *(_QWORD *)(v26 + 8 * v22) = 0;
          }
          else
          {
            v26 = *(_QWORD *)(a3 + 24);
            *(_QWORD *)(v26 + 8 * v22) = *(_QWORD *)(v26 + 8 * v22 + v24);
          }
          ++v22;
        }
        while (v4 != v22);
      }
      else
      {
        v26 = *(_QWORD *)(a3 + 24);
      }
      *(_DWORD *)(v26 + 8 * v4) = 0;
    }
  }
  *(_WORD *)(a2 + 16) = v12;
  *(_WORD *)(a2 + 4) |= 2u;
  *(_WORD *)(a3 + 16) = v13;
  *(_WORD *)(a3 + 4) |= 2u;
  return result;
}

void CUIBitVectorToString_cold_1()
{
  __assert_rtn("CUIBitVectorToString", "CUIBitVector.c", 332, "index < (int)size");
}

void _segmentForValue_cold_1()
{
  __assert_rtn("_segmentForValue", "CUINamedVectorGlyph.m", 3332, "numSegments > 0");
}

void CUIFillRenditionKeyForCARKeyArray_cold_1()
{
  __assert_rtn("CUIFillRenditionKeyForCARKeyArray", "CUIThemeRendition_Support.m", 37, "CARKeyArray && key");
}

void CUIRenditionKeySetValueForAttribute_cold_1()
{
  __assert_rtn("CUIRenditionKeySetValueForAttribute", "CUIThemeRendition_Support.m", 513, "maxCountIncludingZeroTerminator > 0");
}

void CUIRenditionKeySetValueForAttribute_cold_2()
{
  __assert_rtn("CUIRenditionKeySetValueForAttribute", "CUIThemeRendition_Support.m", 525, "tokenCount < maxCountIncludingZeroTerminator - 1");
}

void CUIRenditionKeySetValueForAttribute_cold_3()
{
  __assert_rtn("CUIRenditionKeySetValueForAttribute", "CUIThemeRendition_Support.m", 538, "tokenCount < maxCountIncludingZeroTerminator");
}

void CUIFillCARKeyArrayForRenditionKey2_cold_1()
{
  __assert_rtn("CUIFillCARKeyArrayForRenditionKey2", "CUIThemeRendition_Support.m", 580, "CARKeyArray && key");
}

void CUIRenditionKeyCopy_cold_1()
{
  __assert_rtn("CUIRenditionKeyCopy", "CUIThemeRendition_Support.m", 868, "result && key");
}

void CUIRenditionKeyCopy_cold_2()
{
  __assert_rtn("CUIRenditionKeyCopy", "CUIThemeRendition_Support.m", 871, "maxCountIncludingZeroTerminator > 0 && tokenCount < maxCountIncludingZeroTerminator");
}

void CUICopyKeySignatureWithPrefix_cold_1()
{
  __assert_rtn("CUICopyKeySignatureWithPrefix", "CUIThemeRendition_Support.m", 755, "keyFormat");
}

void File::CopyToBuffer()
{
  __assert_rtn("CopyToBuffer", "WinFile.cpp", 130, "(_ioBufferPosition + size) <= kIOBufferSize");
}

void initMDLMaterial_cold_1()
{
  __assert_rtn("initMDLMaterial", "_CUIThemeModelSubmeshRendition.m", 19, "classMDLMaterial");
}

void initMDLTexture_cold_1()
{
  __assert_rtn("initMDLTexture", "_CUIThemeModelSubmeshRendition.m", 21, "classMDLTexture");
}

void initMDLTextureSampler_cold_1()
{
  __assert_rtn("initMDLTextureSampler", "_CUIThemeModelSubmeshRendition.m", 22, "classMDLTextureSampler");
}

void initMDLMaterialProperty_cold_1()
{
  __assert_rtn("initMDLMaterialProperty", "_CUIThemeModelSubmeshRendition.m", 20, "classMDLMaterialProperty");
}

void initMDLSubmesh_cold_1()
{
  __assert_rtn("initMDLSubmesh", "_CUIThemeModelSubmeshRendition.m", 18, "classMDLSubmesh");
}

void CUIATECompressedDataFromBuffer_cold_1()
{
  __assert_rtn("CUIATECompressedDataFromBuffer", "CUIATECompression.m", 1135, "blockdim_y > 0");
}

void __CUISubtypeFromIndex_cold_1(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFString *v7;

  v7 = CUIPlatformNameForPlatform(a1);
  OUTLINED_FUNCTION_0((uint64_t)v7, (uint64_t)"CoreUI: %s got a index %d that doesn't map to a known device subtype in platform %d:'%@'", v1, v2, v3, v4, v5, v6, (uint64_t)"int32_t __CUISubtypeFromIndex(CUIThemeSchemaPlatform, u_int32_t)");
  abort();
}

void CPSDLayerChannelGroup::Init()
{
  __assert_rtn("Init", "PSDLoader.cpp", 3638, "mChannelCount == kDefaultChannelCount");
}

void CPSDLayerChannelGroup::ComputeSizeForChannel()
{
  __assert_rtn("ComputeSizeForChannel", "PSDLoader.cpp", 3672, "channelIndex < mChannelCount");
}

void CPSDFile::LoadImageData()
{
  __assert_rtn("LoadImageData", "PSDLoader.cpp", 4763, "mCompositeBuffer");
}

void CPSDChannelData::LoadChannelData()
{
  __assert_rtn("LoadChannelData", "PSDLoader.cpp", 3616, "dwBytesRead == mpDataSize");
}

void CPSDImageLoad::UncompressChannelImageData()
{
  __assert_rtn("UncompressChannelImageData", "PSDLoader.cpp", 4893, "byteCounts");
}

{
  __assert_rtn("UncompressChannelImageData", "PSDLoader.cpp", 4894, "buffer");
}

void CUIImageCompressedWithDeepmap_cold_1()
{
  __assert_rtn("CUIImageCompressedWithDeepmap", "CUIDeepmapCompression.m", 244, "encodedChunkSize && \"Invalid chunkSize\"");
}

void initMDLMeshBufferMap_cold_1()
{
  __assert_rtn("initMDLMeshBufferMap", "CUIMeshBuffer.m", 14, "classMDLMeshBufferMap");
}

void initMDLVertexAttribute_cold_1()
{
  __assert_rtn("initMDLVertexAttribute", "_CUIThemeModelMeshRendition.m", 19, "classMDLVertexAttribute");
}

void initMDLVertexBufferLayout_cold_1()
{
  __assert_rtn("initMDLVertexBufferLayout", "_CUIThemeModelMeshRendition.m", 20, "classMDLVertexBufferLayout");
}

void initMDLVertexDescriptor_cold_1()
{
  __assert_rtn("initMDLVertexDescriptor", "_CUIThemeModelMeshRendition.m", 21, "classMDLVertexDescriptor");
}

void initMDLMesh_cold_1()
{
  __assert_rtn("initMDLMesh", "_CUIThemeModelMeshRendition.m", 18, "classMDLMesh");
}

void _CUIRenditionKeySetIntegerValueForAttribute_cold_1(unsigned __int16 a1)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = CUIThemeAttributeNameToString(a1);
  _CUILog(4, (uint64_t)"CoreUI: Value passed for rendition key attribute out of bounds for u_int16_t identifier:'%s:%d' value:'%d'", v2, v3, v4, v5, v6, v7, (uint64_t)v1);
  __assert_rtn("_CUIRenditionKeySetIntegerValueForAttribute", "CUIRenditionKey.m", 28, "0");
}

void initMDLAsset_cold_1()
{
  __assert_rtn("initMDLAsset", "_CUIThemeModelAssetRendition.h", 14, "classMDLAsset");
}

void CUICGBitmapContextCreate_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t vars0;

  _CUILog(4, (uint64_t)"CoreUI: CUICGBitmapContextCreate() called with a bogus bitmapInfo", a3, a4, a5, a6, a7, a8, vars0);
  abort();
}

uint64_t sub_19EC66F00()
{
  return off_1E41A6A70();
}

uint64_t sub_19EC66F0C()
{
  return off_1E41A6A78();
}

uint64_t sub_19EC66F18()
{
  return off_1E41A6A80();
}

id objc_msgSend_CGColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_CGColor);
}

id objc_msgSend_CUIEffectDataRepresentation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_CUIEffectDataRepresentation);
}

id objc_msgSend_URLByDeletingPathExtension(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_URLByDeletingPathExtension);
}

id objc_msgSend_URLForResource_withExtension_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_URLForResource_withExtension_);
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_UTF8String);
}

id objc_msgSend___initGroupWithName_index_sublayers_attributes_style_passthrough_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel___initGroupWithName_index_sublayers_attributes_style_passthrough_delegate_);
}

id objc_msgSend___initTreeWithName_index_sublayers_attributes_style_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel___initTreeWithName_index_sublayers_attributes_style_delegate_);
}

id objc_msgSend__addBitmapIndexForNameIdentifier_attribute_withValue_toDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__addBitmapIndexForNameIdentifier_attribute_withValue_toDictionary_);
}

id objc_msgSend__addRenditionInfoForImageWithName_andKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__addRenditionInfoForImageWithName_andKey_);
}

id objc_msgSend__allocateExtendedMetadata(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__allocateExtendedMetadata);
}

id objc_msgSend__alwaysBreathesAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__alwaysBreathesAtom);
}

id objc_msgSend__alwaysPulsesAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__alwaysPulsesAtom);
}

id objc_msgSend__alwaysRotatesAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__alwaysRotatesAtom);
}

id objc_msgSend__anyLayerAlwaysPulses(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__anyLayerAlwaysPulses);
}

id objc_msgSend__anyLayerAlwaysRotates(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__anyLayerAlwaysRotates);
}

id objc_msgSend__applyFixedAttributesToKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__applyFixedAttributesToKey_);
}

id objc_msgSend__areValid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__areValid);
}

id objc_msgSend__assetPackBundleForBundle_withAssetPackID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__assetPackBundleForBundle_withAssetPackID_);
}

id objc_msgSend__backgroundImageNamesAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__backgroundImageNamesAtom);
}

id objc_msgSend__backgroundShapeBoundsForTargetSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__backgroundShapeBoundsForTargetSize_scale_);
}

id objc_msgSend__baseKeyForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__baseKeyForName_);
}

id objc_msgSend__baseVectorGlyphForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__baseVectorGlyphForName_);
}

id objc_msgSend__bevelEmbossFromLayerEffectsInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__bevelEmbossFromLayerEffectsInfo_);
}

id objc_msgSend__blackInterpolationSource(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__blackInterpolationSource);
}

id objc_msgSend__blackRendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__blackRendition);
}

id objc_msgSend__blendModeAtAbsluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__blendModeAtAbsluteIndex_);
}

id objc_msgSend__bomStorage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__bomStorage);
}

id objc_msgSend__bottomRightCapSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__bottomRightCapSize);
}

id objc_msgSend__boundsAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__boundsAtAbsoluteIndex_);
}

id objc_msgSend__bringHeaderInfoUpToDate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__bringHeaderInfoUpToDate);
}

id objc_msgSend__buildBitmapInfoIntoDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__buildBitmapInfoIntoDictionary_);
}

id objc_msgSend__bundleNameForResolvedDesignSystem_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__bundleNameForResolvedDesignSystem_);
}

id objc_msgSend__cacheRenditionProperties(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__cacheRenditionProperties);
}

id objc_msgSend__canGetRenditionForKey_withDrawingLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__canGetRenditionForKey_withDrawingLayer_);
}

id objc_msgSend__canUsePathConcatenation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__canUsePathConcatenation);
}

id objc_msgSend__catalog(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__catalog);
}

id objc_msgSend__catalogPathComponentForDesignSystem_colorScheme_contrast_styling_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__catalogPathComponentForDesignSystem_colorScheme_contrast_styling_error_);
}

id objc_msgSend__catalogsForDesignSystem_colorScheme_contrast_styling_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__catalogsForDesignSystem_colorScheme_contrast_styling_error_);
}

id objc_msgSend__cgImageRef(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__cgImageRef);
}

id objc_msgSend__classesContainRenderModeClass_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__classesContainRenderModeClass_);
}

id objc_msgSend__cleanedUpMidpointLocationsFromLocations_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__cleanedUpMidpointLocationsFromLocations_);
}

id objc_msgSend__cleanupEffectSettings(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__cleanupEffectSettings);
}

id objc_msgSend__clearBehindAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__clearBehindAtom);
}

id objc_msgSend__colorForVariableThreshold_variableMinValue_variableMaxValue_onFillColor_offFillColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__colorForVariableThreshold_variableMinValue_variableMaxValue_onFillColor_offFillColor_);
}

id objc_msgSend__colorFromShapeEffectValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__colorFromShapeEffectValue_);
}

id objc_msgSend__colorNameForRenderingStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__colorNameForRenderingStyle_);
}

id objc_msgSend__colorNameStringFromNameEnum_palette_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__colorNameStringFromNameEnum_palette_);
}

id objc_msgSend__colorOverlayFromLayerEffectsInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__colorOverlayFromLayerEffectsInfo_);
}

id objc_msgSend__commonInit(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__commonInit);
}

id objc_msgSend__commonInitWithStorage_forWritting_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__commonInitWithStorage_forWritting_);
}

id objc_msgSend__containsWideGamutColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__containsWideGamutColor);
}

id objc_msgSend__copyCGImageAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__copyCGImageAtAbsoluteIndex_);
}

id objc_msgSend__copySublayerInfoAtAbsoluteIndex_atRoot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__copySublayerInfoAtAbsoluteIndex_atRoot_);
}

id objc_msgSend__createAdoptingPath_clipStrokeKeyframes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createAdoptingPath_clipStrokeKeyframes_);
}

id objc_msgSend__createBackgroundGradientWithColors_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createBackgroundGradientWithColors_);
}

id objc_msgSend__createBackgroundImageOfSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createBackgroundImageOfSize_scale_);
}

id objc_msgSend__createBackgroundShapeInRect_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createBackgroundShapeInRect_scale_);
}

id objc_msgSend__createContentEffectsForTargetSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createContentEffectsForTargetSize_scale_);
}

id objc_msgSend__createGraphicVariantImageAtScale_backgroundImage_symbolImage_destinationRect_disableColorFill_outputScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createGraphicVariantImageAtScale_backgroundImage_symbolImage_destinationRect_disableColorFill_outputScale_);
}

id objc_msgSend__createLayerWithLayerTreeNode_layerName_index_subpaths_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createLayerWithLayerTreeNode_layerName_index_subpaths_delegate_);
}

id objc_msgSend__createMaskFromAlphaChannel_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createMaskFromAlphaChannel_);
}

id objc_msgSend__createMaskFromSlice_atAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createMaskFromSlice_atAbsoluteIndex_);
}

id objc_msgSend__createOrderedStops_midpoints_fromStops_midpoints_edgePixel_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createOrderedStops_midpoints_fromStops_midpoints_edgePixel_);
}

id objc_msgSend__createPathFromStyle_subpaths_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createPathFromStyle_subpaths_);
}

id objc_msgSend__createRadialGradientImageWithWidth_height_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createRadialGradientImageWithWidth_height_);
}

id objc_msgSend__createShapeEffectsForTargetSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createShapeEffectsForTargetSize_scale_);
}

id objc_msgSend__createShapeGroupSubpaths(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createShapeGroupSubpaths);
}

id objc_msgSend__createShapeLayerWithLayerTreeNode_layerName_index_shapes_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createShapeLayerWithLayerTreeNode_layerName_index_shapes_delegate_);
}

id objc_msgSend__createSimpleLayerWithLayerTreeNode_layerName_index_subpaths_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createSimpleLayerWithLayerTreeNode_layerName_index_subpaths_delegate_);
}

id objc_msgSend__createTreeWithLayerTreeNode_modePrefix_layerName_index_subpaths_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__createTreeWithLayerTreeNode_modePrefix_layerName_index_subpaths_delegate_);
}

id objc_msgSend__dataWithName_deviceIdiom_deviceSubtype_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__dataWithName_deviceIdiom_deviceSubtype_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_);
}

id objc_msgSend__defaultLayerStackWithScaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__defaultLayerStackWithScaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend__defaultNamedAssetWithScaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__defaultNamedAssetWithScaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend__defaultScaledContentRectForBackgroundSize_safeContentArea_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__defaultScaledContentRectForBackgroundSize_safeContentArea_);
}

id objc_msgSend__destinationFrame(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__destinationFrame);
}

id objc_msgSend__distilledInVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__distilledInVersion);
}

id objc_msgSend__doRadiosityBlurOnPixelBuffer_bytesPerRow_bitsPerPixel_width_height_scaleFactor_usesGaussianBlur_adjustedSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__doRadiosityBlurOnPixelBuffer_bytesPerRow_bitsPerPixel_width_height_scaleFactor_usesGaussianBlur_adjustedSize_);
}

id objc_msgSend__doStyledQuartzDrawingInContext_inBounds_stylePresetName_styleConfiguration_drawingHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__doStyledQuartzDrawingInContext_inBounds_stylePresetName_styleConfiguration_drawingHandler_);
}

id objc_msgSend__drawBackgroundShapeInContext_targetSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawBackgroundShapeInContext_targetSize_scale_);
}

id objc_msgSend__drawHierarchicalLayersInContext_scaleFactor_targetSize_colorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawHierarchicalLayersInContext_scaleFactor_targetSize_colorResolver_);
}

id objc_msgSend__drawMulticolorLayersInContext_scaleFactor_targetSize_colorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawMulticolorLayersInContext_scaleFactor_targetSize_colorResolver_);
}

id objc_msgSend__drawPaletteLayersInContext_scaleFactor_targetSize_colorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawPaletteLayersInContext_scaleFactor_targetSize_colorResolver_);
}

id objc_msgSend__drawShadow_forGlyphs_inContext_usingFont_atPositions_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawShadow_forGlyphs_inContext_usingFont_atPositions_count_);
}

id objc_msgSend__drawShadow_forGlyphs_inContext_usingFont_withAdvances_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawShadow_forGlyphs_inContext_usingFont_withAdvances_count_);
}

id objc_msgSend__drawShadow_usingQuartz_inContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawShadow_usingQuartz_inContext_);
}

id objc_msgSend__drawSpecificRenditionKey_inFrame_context_alpha_operation_isFocused_isFlipped_effects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__drawSpecificRenditionKey_inFrame_context_alpha_operation_isFocused_isFlipped_effects_);
}

id objc_msgSend__dropShadowFromLayerEffectsInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__dropShadowFromLayerEffectsInfo_);
}

id objc_msgSend__effectStyle_state_presentationState_value_resolution_dimension1_appearance_fromStyleConfiguration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__effectStyle_state_presentationState_value_resolution_dimension1_appearance_fromStyleConfiguration_);
}

id objc_msgSend__effectiveCenteringStyle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__effectiveCenteringStyle);
}

id objc_msgSend__facetWithKeyList_andRenditionKeyClass_orRenditionKey_fromTheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__facetWithKeyList_andRenditionKeyClass_orRenditionKey_fromTheme_);
}

id objc_msgSend__fillActionAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__fillActionAtom);
}

id objc_msgSend__fillColorFromStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__fillColorFromStyle_);
}

id objc_msgSend__fillOpacityAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__fillOpacityAtAbsoluteIndex_);
}

id objc_msgSend__fillSampleAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__fillSampleAtAbsoluteIndex_);
}

id objc_msgSend__fontValueForFontType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__fontValueForFontType_);
}

id objc_msgSend__formatStorageKeyArrayBytes_length_fromKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__formatStorageKeyArrayBytes_length_fromKey_);
}

id objc_msgSend__generateReferenceImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__generateReferenceImage);
}

id objc_msgSend__getAnchor_inRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__getAnchor_inRendition_);
}

id objc_msgSend__getMetricCenterInRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__getMetricCenterInRendition_);
}

id objc_msgSend__getOutlineNodeForDocument_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__getOutlineNodeForDocument_);
}

id objc_msgSend__gradientAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__gradientAtAbsoluteIndex_);
}

id objc_msgSend__gradientOverlayFromLayerEffectsAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__gradientOverlayFromLayerEffectsAtAbsoluteIndex_);
}

id objc_msgSend__hasImageFillsAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__hasImageFillsAtom);
}

id objc_msgSend__imageAtAbsoluteIndex_isZeroSizeImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__imageAtAbsoluteIndex_isZeroSizeImage_);
}

id objc_msgSend__imageFromSlice_atAbsoluteIndex_isEmptyImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__imageFromSlice_atAbsoluteIndex_isEmptyImage_);
}

id objc_msgSend__imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_);
}

id objc_msgSend__indexFromStyleSuffix_integer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__indexFromStyleSuffix_integer_);
}

id objc_msgSend__initDefaultHeaderVersion_versionString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initDefaultHeaderVersion_versionString_);
}

id objc_msgSend__initWithBaseGlyph_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initWithBaseGlyph_options_);
}

id objc_msgSend__initWithCSIData_forKey_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initWithCSIData_forKey_version_);
}

id objc_msgSend__initWithCSIHeader_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initWithCSIHeader_version_);
}

id objc_msgSend__initWithGradientEvaluator_colorSpace_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initWithGradientEvaluator_colorSpace_);
}

id objc_msgSend__initWithName_index_shape_strokeWidth_attributes_style_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initWithName_index_shape_strokeWidth_attributes_style_delegate_);
}

id objc_msgSend__initWithName_index_sublayers_attributes_style_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initWithName_index_sublayers_attributes_style_delegate_);
}

id objc_msgSend__initalizeMetadataFromCSIData_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initalizeMetadataFromCSIData_version_);
}

id objc_msgSend__initializeCompositingOptionsFromCSIData_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initializeCompositingOptionsFromCSIData_version_);
}

id objc_msgSend__initializeCoreUIOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initializeCoreUIOptions_);
}

id objc_msgSend__initializePropertiesFromCSIData_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initializePropertiesFromCSIData_version_);
}

id objc_msgSend__initializeRenditionKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initializeRenditionKey_);
}

id objc_msgSend__initializeTypeIdentifiersWithLayout_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__initializeTypeIdentifiersWithLayout_);
}

id objc_msgSend__innerGlowFromLayerEffectsInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__innerGlowFromLayerEffectsInfo_);
}

id objc_msgSend__innerShadowFromLayerEffectsInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__innerShadowFromLayerEffectsInfo_);
}

id objc_msgSend__insertEffectTuple_atEffectIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__insertEffectTuple_atEffectIndex_);
}

id objc_msgSend__interiorAlignmentRectUnroundedForTargetSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interiorAlignmentRectUnroundedForTargetSize_);
}

id objc_msgSend__interpolatedAlignmentRectInsetsWithWeight_glyphSize_fromUltralight_regular_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedAlignmentRectInsetsWithWeight_glyphSize_fromUltralight_regular_black_);
}

id objc_msgSend__interpolatedAnchorWithWeight_glyphSize_fromUltralight_regular_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedAnchorWithWeight_glyphSize_fromUltralight_regular_black_);
}

id objc_msgSend__interpolatedBaselineOffsetWithWeight_glyphSize_fromUltralight_regular_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedBaselineOffsetWithWeight_glyphSize_fromUltralight_regular_black_);
}

id objc_msgSend__interpolatedCanvasSizeWithWeight_glyphSize_fromUltralight_regular_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedCanvasSizeWithWeight_glyphSize_fromUltralight_regular_black_);
}

id objc_msgSend__interpolatedCapHeightWithWeight_glyphSize_fromUltralight_regular_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedCapHeightWithWeight_glyphSize_fromUltralight_regular_black_);
}

id objc_msgSend__interpolatedPathWithWeight_glyphSize_fromUltralightSmall_regularSmall_blackSmall_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedPathWithWeight_glyphSize_fromUltralightSmall_regularSmall_blackSmall_);
}

id objc_msgSend__interpolatedStrokeWidthWithWeight_glyphSize_fromUltralight_regular_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolatedStrokeWidthWithWeight_glyphSize_fromUltralight_regular_black_);
}

id objc_msgSend__interpolationData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__interpolationData);
}

id objc_msgSend__isButtonGlyph(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__isButtonGlyph);
}

id objc_msgSend__isGroupType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__isGroupType_);
}

id objc_msgSend__layerEffectsAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerEffectsAtAbsoluteIndex_);
}

id objc_msgSend__layerHierarchyStyleNames(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerHierarchyStyleNames);
}

id objc_msgSend__layerIndexFromLayerNames_indexRangeBegin_indexRangeEnd_isTopLevel_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerIndexFromLayerNames_indexRangeBegin_indexRangeEnd_isTopLevel_);
}

id objc_msgSend__layerInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerInfo);
}

id objc_msgSend__layerNameForDrawingLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerNameForDrawingLayer_);
}

id objc_msgSend__layerNameForState_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerNameForState_);
}

id objc_msgSend__layerNamesForRenderingMode_inRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerNamesForRenderingMode_inRendition_);
}

id objc_msgSend__layerRefAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerRefAtAbsoluteIndex_);
}

id objc_msgSend__layerStackWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerStackWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend__layerTagsAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__layerTagsAtom);
}

id objc_msgSend__legacy_drawHierarchicalLayerNamed_inContext_scaleFactor_targetSize_colorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__legacy_drawHierarchicalLayerNamed_inContext_scaleFactor_targetSize_colorResolver_);
}

id objc_msgSend__legacy_drawMonochromeLayerNamed_inContext_scaleFactor_targetSize_onFillColor_offFillColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__legacy_drawMonochromeLayerNamed_inContext_scaleFactor_targetSize_onFillColor_offFillColor_);
}

id objc_msgSend__legacy_drawMulticolorLayerNamed_inContext_scaleFactor_targetSize_colorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__legacy_drawMulticolorLayerNamed_inContext_scaleFactor_targetSize_colorResolver_);
}

id objc_msgSend__lineCapFromStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__lineCapFromStyle_);
}

id objc_msgSend__lineJoinFromStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__lineJoinFromStyle_);
}

id objc_msgSend__loadExtendedMetadata(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__loadExtendedMetadata);
}

id objc_msgSend__lookupCatalogImageForIdiom_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__lookupCatalogImageForIdiom_locale_);
}

id objc_msgSend__modelWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__modelWithName_);
}

id objc_msgSend__motionGroupAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__motionGroupAtom);
}

id objc_msgSend__nameAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__nameAtAbsoluteIndex_);
}

id objc_msgSend__nameForLocalizationIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__nameForLocalizationIdentifier_);
}

id objc_msgSend__namedImageAtlasWithName_scaleFactor_deviceIdiom_displayGamut_deviceSubtype_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__namedImageAtlasWithName_scaleFactor_deviceIdiom_displayGamut_deviceSubtype_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_);
}

id objc_msgSend__namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_);
}

id objc_msgSend__namedTextureWithName_scaleFactor_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__namedTextureWithName_scaleFactor_appearanceName_);
}

id objc_msgSend__namedTextureWithName_scaleFactor_displayGamut_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__namedTextureWithName_scaleFactor_displayGamut_appearanceName_);
}

id objc_msgSend__namedVectorImageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceIdentifier_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__namedVectorImageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceIdentifier_locale_);
}

id objc_msgSend__namesOfSublayers_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__namesOfSublayers_);
}

id objc_msgSend__newFlattenedImageFromShapeCGImage_withScale_ciContext_blendOverImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__newFlattenedImageFromShapeCGImage_withScale_ciContext_blendOverImage_);
}

id objc_msgSend__newPattern(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__newPattern);
}

id objc_msgSend__newRenditionKeyDataFromKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__newRenditionKeyDataFromKey_);
}

id objc_msgSend__normalizeEffectParameters(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__normalizeEffectParameters);
}

id objc_msgSend__opacityAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__opacityAtAbsoluteIndex_);
}

id objc_msgSend__outerGlowFromLayerEffectsInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__outerGlowFromLayerEffectsInfo_);
}

id objc_msgSend__parameterCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__parameterCount);
}

id objc_msgSend__partialLocale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__partialLocale);
}

id objc_msgSend__patternFromSlice_atAbsoluteIndex_isZeroSizeImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__patternFromSlice_atAbsoluteIndex_isZeroSizeImage_);
}

id objc_msgSend__precompositeColorOverlayInnerGradient(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__precompositeColorOverlayInnerGradient);
}

id objc_msgSend__psdFileWithLayers_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__psdFileWithLayers_);
}

id objc_msgSend__psdImageRef(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__psdImageRef);
}

id objc_msgSend__psdLayerRecord(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__psdLayerRecord);
}

id objc_msgSend__psdLayerRecordAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__psdLayerRecordAtAbsoluteIndex_);
}

id objc_msgSend__readAppearances(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__readAppearances);
}

id objc_msgSend__readCSSAttributes_styleAttributes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__readCSSAttributes_styleAttributes_);
}

id objc_msgSend__recognitionImageWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__recognitionImageWithName_);
}

id objc_msgSend__recognitionObjectWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__recognitionObjectWithName_);
}

id objc_msgSend__regularRendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__regularRendition);
}

id objc_msgSend__removeRenditionInfoForImageWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__removeRenditionInfoForImageWithName_);
}

id objc_msgSend__rendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__rendition);
}

id objc_msgSend__renditionForKey_inThemeRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__renditionForKey_inThemeRef_);
}

id objc_msgSend__renditionForSpecificKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__renditionForSpecificKey_);
}

id objc_msgSend__renditionsSortedIntoLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__renditionsSortedIntoLayers);
}

id objc_msgSend__requestedPointSizeRatio(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__requestedPointSizeRatio);
}

id objc_msgSend__resolveInterpolationSourceRenditionKeysUltralight_regular_black_forName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_appearanceIdentifier_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__resolveInterpolationSourceRenditionKeysUltralight_regular_black_forName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_appearanceIdentifier_locale_);
}

id objc_msgSend__resolvedRenditionKeyForName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_withBaseKeySelector_adjustRenditionKeyWithBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__resolvedRenditionKeyForName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_withBaseKeySelector_adjustRenditionKeyWithBlock_);
}

id objc_msgSend__resolvedRenditionKeyFromThemeRef_withBaseKey_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_adjustRenditionKeyWithBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__resolvedRenditionKeyFromThemeRef_withBaseKey_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_adjustRenditionKeyWithBlock_);
}

id objc_msgSend__rotatesClockwiseAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__rotatesClockwiseAtom);
}

id objc_msgSend__safeContentAreaBoundsForBackgroundSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__safeContentAreaBoundsForBackgroundSize_);
}

id objc_msgSend__saveBitmapInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__saveBitmapInfo);
}

id objc_msgSend__scalarsForGlyphContinuousWeight_inDictionary_shouldClamp_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__scalarsForGlyphContinuousWeight_inDictionary_shouldClamp_);
}

id objc_msgSend__scaledContentRectForBackgroundSize_baseContentRect_snappingScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__scaledContentRectForBackgroundSize_baseContentRect_snappingScale_);
}

id objc_msgSend__setAllLayersAlwaysPulse_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setAllLayersAlwaysPulse_);
}

id objc_msgSend__setAllLayersAlwaysRotate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setAllLayersAlwaysRotate_);
}

id objc_msgSend__setBevelEmbossAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setBevelEmbossAtIndex_fromPreset_index_);
}

id objc_msgSend__setBlackInterpolationSource_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setBlackInterpolationSource_);
}

id objc_msgSend__setCanUsePathConcatenation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setCanUsePathConcatenation_);
}

id objc_msgSend__setCatalog_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setCatalog_);
}

id objc_msgSend__setColorFillAtIndex_FromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setColorFillAtIndex_FromPreset_index_);
}

id objc_msgSend__setContainsNamedColorStyles_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setContainsNamedColorStyles_);
}

id objc_msgSend__setEngraveShadowAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setEngraveShadowAtIndex_fromPreset_index_);
}

id objc_msgSend__setExtraShadowAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setExtraShadowAtIndex_fromPreset_index_);
}

id objc_msgSend__setFlippable_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setFlippable_);
}

id objc_msgSend__setGlyphSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setGlyphSize_);
}

id objc_msgSend__setGlyphWeight_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setGlyphWeight_);
}

id objc_msgSend__setHueSaturationAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setHueSaturationAtIndex_fromPreset_index_);
}

id objc_msgSend__setImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setImage_);
}

id objc_msgSend__setInnerGlowAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setInnerGlowAtIndex_fromPreset_index_);
}

id objc_msgSend__setInnerShadowAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setInnerShadowAtIndex_fromPreset_index_);
}

id objc_msgSend__setInteriorGradientAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setInteriorGradientAtIndex_fromPreset_index_);
}

id objc_msgSend__setLayoutDirection_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setLayoutDirection_);
}

id objc_msgSend__setOuterGlowAtIndex_fromPreset_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setOuterGlowAtIndex_fromPreset_index_);
}

id objc_msgSend__setOutputOpacityFromPreset_atIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setOutputOpacityFromPreset_atIndex_);
}

id objc_msgSend__setPointSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setPointSize_);
}

id objc_msgSend__setPreferredLocalization_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setPreferredLocalization_);
}

id objc_msgSend__setScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setScale_);
}

id objc_msgSend__setShapeOpacityFromPreset_atIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setShapeOpacityFromPreset_atIndex_);
}

id objc_msgSend__setStructuredThemeStore_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setStructuredThemeStore_);
}

id objc_msgSend__setUltralightInterpolationSource_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__setUltralightInterpolationSource_);
}

id objc_msgSend__sizeOfBackgroundShape(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__sizeOfBackgroundShape);
}

id objc_msgSend__sliceIndexForSlice_ofRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__sliceIndexForSlice_ofRendition_);
}

id objc_msgSend__smoothedGradientColorAtLocation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__smoothedGradientColorAtLocation_);
}

id objc_msgSend__smoothedInterpolationOfLocation_betweenLower_upper_scaledMidpoint_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__smoothedInterpolationOfLocation_betweenLower_upper_scaledMidpoint_);
}

id objc_msgSend__sortedEffectDefinitions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__sortedEffectDefinitions);
}

id objc_msgSend__sortedElementDefinitions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__sortedElementDefinitions);
}

id objc_msgSend__sourceRendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__sourceRendition);
}

id objc_msgSend__storageRefForRendition_representsODRContent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__storageRefForRendition_representsODRContent_);
}

id objc_msgSend__storagefileTimestamp(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__storagefileTimestamp);
}

id objc_msgSend__strokeColorFromStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__strokeColorFromStyle_);
}

id objc_msgSend__strokeWidthForNode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__strokeWidthForNode_);
}

id objc_msgSend__stylePrefixForRenderingMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__stylePrefixForRenderingMode_);
}

id objc_msgSend__subImageTexturingShouldBeSupported(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__subImageTexturingShouldBeSupported);
}

id objc_msgSend__subpathIndicesAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__subpathIndicesAtom);
}

id objc_msgSend__suffixForNamedStyleWithPrefix_styles_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__suffixForNamedStyleWithPrefix_styles_);
}

id objc_msgSend__swapHeader(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__swapHeader);
}

id objc_msgSend__swapKeyFormat(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__swapKeyFormat);
}

id objc_msgSend__swapRenditionKeyArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__swapRenditionKeyArray_);
}

id objc_msgSend__swapRenditionKeyToken_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__swapRenditionKeyToken_);
}

id objc_msgSend__symbolDefaults(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__symbolDefaults);
}

id objc_msgSend__texturedImageWithKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__texturedImageWithKey_);
}

id objc_msgSend__themeRef(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__themeRef);
}

id objc_msgSend__themeStore(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__themeStore);
}

id objc_msgSend__themeStoreForThemeIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__themeStoreForThemeIndex_);
}

id objc_msgSend__thumbnailSizeForRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__thumbnailSizeForRendition_);
}

id objc_msgSend__topLeftCapSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__topLeftCapSize);
}

id objc_msgSend__treatDividerAsLayer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__treatDividerAsLayer);
}

id objc_msgSend__ultralightInterpolationSource(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__ultralightInterpolationSource);
}

id objc_msgSend__ultralightRendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__ultralightRendition);
}

id objc_msgSend__updateKeyWithCompatibilityMapping_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__updateKeyWithCompatibilityMapping_);
}

id objc_msgSend__updateRenderStrategyFromEffect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__updateRenderStrategyFromEffect_);
}

id objc_msgSend__updateSpecificRenditionKey_isFocused_owner_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__updateSpecificRenditionKey_isFocused_owner_userInfo_);
}

id objc_msgSend__variableColorContinuousAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__variableColorContinuousAtom);
}

id objc_msgSend__variableThresholdAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__variableThresholdAtom);
}

id objc_msgSend__vibrantColorMatrixBrightnessSaturationForColor_saturation_brightness_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__vibrantColorMatrixBrightnessSaturationForColor_saturation_brightness_);
}

id objc_msgSend__visibilityAtAbsoluteIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__visibilityAtAbsoluteIndex_);
}

id objc_msgSend__wiggleAngleAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__wiggleAngleAtom);
}

id objc_msgSend__wiggleStyleAtom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__wiggleStyleAtom);
}

id objc_msgSend__writeOutKeyFormatWithWorkaround(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel__writeOutKeyFormatWithWorkaround);
}

id objc_msgSend_addAnimation_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addAnimation_forKey_);
}

id objc_msgSend_addBevelEmbossWithHighlightColorRed_green_blue_opacity_shadowColorRed_green_blue_opacity_blur_soften_bevelStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addBevelEmbossWithHighlightColorRed_green_blue_opacity_shadowColorRed_green_blue_opacity_blur_soften_bevelStyle_);
}

id objc_msgSend_addColorFillWithRed_green_blue_opacity_blendMode_tintable_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addColorFillWithRed_green_blue_opacity_blendMode_tintable_);
}

id objc_msgSend_addColorValueRed_green_blue_forParameter_withNewEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addColorValueRed_green_blue_forParameter_withNewEffectType_);
}

id objc_msgSend_addDropShadowWithColorRed_green_blue_opacity_blur_spread_offset_angle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addDropShadowWithColorRed_green_blue_opacity_blur_spread_offset_angle_);
}

id objc_msgSend_addEntriesFromDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addEntriesFromDictionary_);
}

id objc_msgSend_addExtraShadowWithColorRed_green_blue_opacity_blur_spread_offset_angle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addExtraShadowWithColorRed_green_blue_opacity_blur_spread_offset_angle_);
}

id objc_msgSend_addFloatValue_forParameter_withNewEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addFloatValue_forParameter_withNewEffectType_);
}

id objc_msgSend_addGradientFillWithTopColorRed_green_blue_bottomColorRed_green_blue_opacity_blendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addGradientFillWithTopColorRed_green_blue_bottomColorRed_green_blue_opacity_blendMode_);
}

id objc_msgSend_addHueSaturationWithColorRed_green_blue_angle_width_tintable_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addHueSaturationWithColorRed_green_blue_angle_width_tintable_);
}

id objc_msgSend_addIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addIndex_);
}

id objc_msgSend_addInnerGlowWithColorRed_green_blue_opacity_blur_blendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addInnerGlowWithColorRed_green_blue_opacity_blur_blendMode_);
}

id objc_msgSend_addInnerShadowWithColorRed_green_blue_opacity_blur_offset_angle_blendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addInnerShadowWithColorRed_green_blue_opacity_blur_offset_angle_blendMode_);
}

id objc_msgSend_addLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addLayer_);
}

id objc_msgSend_addLayerEffectComponent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addLayerEffectComponent_);
}

id objc_msgSend_addLayoutMetricsChannel_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addLayoutMetricsChannel_);
}

id objc_msgSend_addLayoutMetricsToPSDImageRef_withRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addLayoutMetricsToPSDImageRef_withRendition_);
}

id objc_msgSend_addObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addObject_);
}

id objc_msgSend_addObjectsFromArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addObjectsFromArray_);
}

id objc_msgSend_addObserver_selector_name_object_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addObserver_selector_name_object_);
}

id objc_msgSend_addOrReplaceAttribute_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addOrReplaceAttribute_);
}

id objc_msgSend_addOrUpdateSlicesWithSliceRects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addOrUpdateSlicesWithSliceRects_);
}

id objc_msgSend_addOuterGlowWithColorRed_green_blue_opacity_blur_spread_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addOuterGlowWithColorRed_green_blue_opacity_blur_spread_);
}

id objc_msgSend_addOutputOpacityWithOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addOutputOpacityWithOpacity_);
}

id objc_msgSend_addShapeOpacityWithOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addShapeOpacityWithOpacity_);
}

id objc_msgSend_addStatesAndDrawingLayersToPSDLayers_forPresentationState_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addStatesAndDrawingLayersToPSDLayers_forPresentationState_);
}

id objc_msgSend_addStatisticAllocatedImageSize_roundedSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addStatisticAllocatedImageSize_roundedSize_);
}

id objc_msgSend_addSublayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addSublayer_);
}

id objc_msgSend_addValue_forParameter_withEffectType_atEffectIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addValue_forParameter_withEffectType_atEffectIndex_);
}

id objc_msgSend_addValue_forParameter_withNewEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addValue_forParameter_withNewEffectType_);
}

id objc_msgSend_addValueOrDim1LayersToPSDLayers_forPresentationState_state_drawingLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_addValueOrDim1LayersToPSDLayers_forPresentationState_state_drawingLayer_);
}

id objc_msgSend_adjustEffectColorsToTemperature_onlyTintableColors_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_adjustEffectColorsToTemperature_onlyTintableColors_);
}

id objc_msgSend_adjustOpacity_by_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_adjustOpacity_by_);
}

id objc_msgSend_aliasForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_aliasForName_);
}

id objc_msgSend_alignment(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alignment);
}

id objc_msgSend_alignmentEdgeInsets(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alignmentEdgeInsets);
}

id objc_msgSend_alignmentRect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alignmentRect);
}

id objc_msgSend_alignmentRectForTargetSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alignmentRectForTargetSize_scale_);
}

id objc_msgSend_alignmentRectUnrounded(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alignmentRectUnrounded);
}

id objc_msgSend_allImageNames(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allImageNames);
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allKeys);
}

id objc_msgSend_allRenditionNames(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allRenditionNames);
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allValues);
}

id objc_msgSend_allocWithZone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allocWithZone_);
}

id objc_msgSend_allowsCompactCompression(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsCompactCompression);
}

id objc_msgSend_allowsDeepmap2ImageCompression(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsDeepmap2ImageCompression);
}

id objc_msgSend_allowsDeepmapImageCompression(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsDeepmapImageCompression);
}

id objc_msgSend_allowsHevcCompression(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsHevcCompression);
}

id objc_msgSend_allowsKeyedCoding(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsKeyedCoding);
}

id objc_msgSend_allowsMultiPassEncoding(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsMultiPassEncoding);
}

id objc_msgSend_allowsOptimalRowbytesPacking(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsOptimalRowbytesPacking);
}

id objc_msgSend_allowsPaletteImageCompression(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_allowsPaletteImageCompression);
}

id objc_msgSend_alpha(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alpha);
}

id objc_msgSend_alphaCroppedRect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alphaCroppedRect);
}

id objc_msgSend_alphaWithKeyAdjustment_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alphaWithKeyAdjustment_);
}

id objc_msgSend_altitude(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_altitude);
}

id objc_msgSend_alwaysPulses(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_alwaysPulses);
}

id objc_msgSend_angle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_angle);
}

id objc_msgSend_animationWithKeyPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_animationWithKeyPath_);
}

id objc_msgSend_anyEffectAllowsTintSubstitution(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_anyEffectAllowsTintSubstitution);
}

id objc_msgSend_anyObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_anyObject);
}

id objc_msgSend_appearanceIdentifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appearanceIdentifier);
}

id objc_msgSend_appearanceIdentifierForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appearanceIdentifierForName_);
}

id objc_msgSend_appearanceName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appearanceName);
}

id objc_msgSend_appearancedb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appearancedb);
}

id objc_msgSend_appearances(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appearances);
}

id objc_msgSend_appendAngleValue_forParameter_withEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendAngleValue_forParameter_withEffectType_);
}

id objc_msgSend_appendBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendBytes_length_);
}

id objc_msgSend_appendColorValueRed_green_blue_forParameter_withEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendColorValueRed_green_blue_forParameter_withEffectType_);
}

id objc_msgSend_appendData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendData_);
}

id objc_msgSend_appendEnumValue_forParameter_withEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendEnumValue_forParameter_withEffectType_);
}

id objc_msgSend_appendFloatValue_forParameter_withEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendFloatValue_forParameter_withEffectType_);
}

id objc_msgSend_appendFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendFormat_);
}

id objc_msgSend_appendIntValue_forParameter_withEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendIntValue_forParameter_withEffectType_);
}

id objc_msgSend_appendString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendString_);
}

id objc_msgSend_appendValue_forParameter_withEffectType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_appendValue_forParameter_withEffectType_);
}

id objc_msgSend_applyCustomForegroundColor_tintEffectColors_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_applyCustomForegroundColor_tintEffectColors_);
}

id objc_msgSend_applyDeltasWithScalars_andTransform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_applyDeltasWithScalars_andTransform_);
}

id objc_msgSend_archivedData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_archivedData);
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_array);
}

id objc_msgSend_arrayByAddingObjectsFromArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_arrayByAddingObjectsFromArray_);
}

id objc_msgSend_arrayWithArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_arrayWithArray_);
}

id objc_msgSend_arrayWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_arrayWithCapacity_);
}

id objc_msgSend_arrayWithObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_arrayWithObject_);
}

id objc_msgSend_arrayWithObjects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_arrayWithObjects_);
}

id objc_msgSend_arrayWithObjects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_arrayWithObjects_count_);
}

id objc_msgSend_asset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_asset);
}

id objc_msgSend_assetExistsForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_assetExistsForKey_);
}

id objc_msgSend_assetExistsForKeyData_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_assetExistsForKeyData_length_);
}

id objc_msgSend_assetForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_assetForKey_);
}

id objc_msgSend_assetKeysMatchingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_assetKeysMatchingBlock_);
}

id objc_msgSend_assetPackIdentifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_assetPackIdentifier);
}

id objc_msgSend_attributePresent_withValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_attributePresent_withValue_);
}

id objc_msgSend_attributes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_attributes);
}

id objc_msgSend_attributesForLayerNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_attributesForLayerNamed_);
}

id objc_msgSend_attributesForLayerNamed_inRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_attributesForLayerNamed_inRendition_);
}

id objc_msgSend_authoredWithSchemaVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_authoredWithSchemaVersion);
}

id objc_msgSend_backgroundType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_backgroundType);
}

id objc_msgSend_baseLanguageFromLanguage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_baseLanguageFromLanguage_);
}

id objc_msgSend_baselineOffset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_baselineOffset);
}

id objc_msgSend_baselineOffsetUnrounded(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_baselineOffsetUnrounded);
}

id objc_msgSend_bestMatchUsingImages_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bestMatchUsingImages_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_bestMatchUsingObjects_getAttributeValueUsing_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_deploymentTarget_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsFeatureSetClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bestMatchUsingObjects_getAttributeValueUsing_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_deploymentTarget_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsFeatureSetClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_);
}

id objc_msgSend_bestMatchUsingObjects_getAttributeValueUsing_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_deploymentTarget_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsFeatureSetClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_platform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bestMatchUsingObjects_getAttributeValueUsing_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_deploymentTarget_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsFeatureSetClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_platform_);
}

id objc_msgSend_bevelEmbossFrom_withSize_soften_angle_altitude_highlightRed_highlightGreen_highlightBlue_highlightOpacity_shadowRed_shadowGreen_shadowBlue_shadowOpacity_bevelStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bevelEmbossFrom_withSize_soften_angle_altitude_highlightRed_highlightGreen_highlightBlue_highlightOpacity_shadowRed_shadowGreen_shadowBlue_shadowOpacity_bevelStyle_);
}

id objc_msgSend_bitmapContext(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bitmapContext);
}

id objc_msgSend_bitmapEncoding(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bitmapEncoding);
}

id objc_msgSend_bitmapKeydb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bitmapKeydb);
}

id objc_msgSend_blackDeltas(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blackDeltas);
}

id objc_msgSend_blend_over_blendKind_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blend_over_blendKind_);
}

id objc_msgSend_blendMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blendMode);
}

id objc_msgSend_blendModeAsCAFilterString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blendModeAsCAFilterString);
}

id objc_msgSend_blendModeAsCAFilterStringWithKeyAjustment_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blendModeAsCAFilterStringWithKeyAjustment_);
}

id objc_msgSend_blendModeWithKeyAdjustment_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blendModeWithKeyAdjustment_);
}

id objc_msgSend_blurSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_blurSize);
}

id objc_msgSend_BOOLForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_BOOLForKey_);
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_BOOLValue);
}

id objc_msgSend_borderColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_borderColor);
}

id objc_msgSend_borderWidth(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_borderWidth);
}

id objc_msgSend_bottom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bottom);
}

id objc_msgSend_bottomLeft(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bottomLeft);
}

id objc_msgSend_bottomRight(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bottomRight);
}

id objc_msgSend_bounds(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bounds);
}

id objc_msgSend_boundsAtLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_boundsAtLayer_);
}

id objc_msgSend_brightnessMultiplier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_brightnessMultiplier);
}

id objc_msgSend_buffer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_buffer);
}

id objc_msgSend_bufferAllocator(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bufferAllocator);
}

id objc_msgSend_bufferIndex(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bufferIndex);
}

id objc_msgSend_bundleForClass_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bundleForClass_);
}

id objc_msgSend_bundleID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bundleID);
}

id objc_msgSend_bundleIdentifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bundleIdentifier);
}

id objc_msgSend_bundleWithIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bundleWithIdentifier_);
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bytes);
}

id objc_msgSend_bytesPerImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bytesPerImage);
}

id objc_msgSend_bytesPerRow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_bytesPerRow);
}

id objc_msgSend_caAllowSubimageOfImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_caAllowSubimageOfImage_);
}

id objc_msgSend_caFilterFromCUIEffectBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_caFilterFromCUIEffectBlendMode_);
}

id objc_msgSend_cacheKey(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cacheKey);
}

id objc_msgSend_calculateColumLefts_rowTops_totalSize_forPartFeatures_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_calculateColumLefts_rowTops_totalSize_forPartFeatures_);
}

id objc_msgSend_canGetRenditionWithKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_canGetRenditionWithKey_);
}

id objc_msgSend_canGetShapeEffectRenditionWithKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_canGetShapeEffectRenditionWithKey_);
}

id objc_msgSend_canvasSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_canvasSize);
}

id objc_msgSend_capHeightUnrounded(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_capHeightUnrounded);
}

id objc_msgSend_caseInsensitiveCompare_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_caseInsensitiveCompare_);
}

id objc_msgSend_catalogForDesignSystem_colorScheme_contrast_styling_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_catalogForDesignSystem_colorScheme_contrast_styling_error_);
}

id objc_msgSend_catalogGlobalData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_catalogGlobalData);
}

id objc_msgSend_center(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_center);
}

id objc_msgSend_cgAffineTransformValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgAffineTransformValue);
}

id objc_msgSend_cgBlendModeForOutputBlending(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgBlendModeForOutputBlending);
}

id objc_msgSend_cgBlendModeForPSDLayerOrLayerEffectBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgBlendModeForPSDLayerOrLayerEffectBlendMode_);
}

id objc_msgSend_cgBlendModeFromCUIEffectBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgBlendModeFromCUIEffectBlendMode_);
}

id objc_msgSend_cgColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgColor);
}

id objc_msgSend_cgImageRef(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgImageRef);
}

id objc_msgSend_cgPathFrom_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cgPathFrom_);
}

id objc_msgSend_checkResourceIsReachableAndReturnError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_checkResourceIsReachableAndReturnError_);
}

id objc_msgSend_clearCachedImageResources(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_clearCachedImageResources);
}

id objc_msgSend_clearRenditionCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_clearRenditionCache);
}

id objc_msgSend_clipStrokeKeyframes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_clipStrokeKeyframes);
}

id objc_msgSend_clipStrokeKeyframesForPath_scalars_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_clipStrokeKeyframesForPath_scalars_);
}

id objc_msgSend_color(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_color);
}

id objc_msgSend_colorComponents(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorComponents);
}

id objc_msgSend_colorFromDocumentColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorFromDocumentColor_);
}

id objc_msgSend_colorLocation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorLocation);
}

id objc_msgSend_colorMidpointLocations(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorMidpointLocations);
}

id objc_msgSend_colorOverlay(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorOverlay);
}

id objc_msgSend_colorOverlayCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorOverlayCount);
}

id objc_msgSend_colorOverlayOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorOverlayOpacity);
}

id objc_msgSend_colorScheme(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorScheme);
}

id objc_msgSend_colorSpaceID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorSpaceID);
}

id objc_msgSend_colorStopWithLocation_gradientColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorStopWithLocation_gradientColor_);
}

id objc_msgSend_colorStops(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorStops);
}

id objc_msgSend_colorTemperature(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorTemperature);
}

id objc_msgSend_colorUsingCGColorSpace_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorUsingCGColorSpace_);
}

id objc_msgSend_colorWithCGColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithCGColor_);
}

id objc_msgSend_colorWithName_designSystem_palette_colorScheme_contrast_styling_displayGamut_hierarchyLevel_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithName_designSystem_palette_colorScheme_contrast_styling_displayGamut_hierarchyLevel_error_);
}

id objc_msgSend_colorWithName_displayGamut_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithName_displayGamut_appearanceName_);
}

id objc_msgSend_colorWithName_displayGamut_deviceIdiom_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithName_displayGamut_deviceIdiom_appearanceName_);
}

id objc_msgSend_colorWithName_palette_displayGamut_hierarchyLevel_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithName_palette_displayGamut_hierarchyLevel_error_);
}

id objc_msgSend_colorWithRed_green_blue_alpha_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithRed_green_blue_alpha_);
}

id objc_msgSend_colorWithSRGBRed_green_blue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithSRGBRed_green_blue_);
}

id objc_msgSend_colorWithSRGBRed_green_blue_alpha_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colorWithSRGBRed_green_blue_alpha_);
}

id objc_msgSend_colordb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_colordb);
}

id objc_msgSend_compare_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compare_);
}

id objc_msgSend_componentsJoinedByString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_componentsJoinedByString_);
}

id objc_msgSend_componentsSeparatedByCharactersInSet_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_componentsSeparatedByCharactersInSet_);
}

id objc_msgSend_componentsSeparatedByString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_componentsSeparatedByString_);
}

id objc_msgSend_composite_into_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_composite_into_);
}

id objc_msgSend_composite_over_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_composite_over_);
}

id objc_msgSend_compositeCatalogForDesignSystem_colorScheme_contrast_styling_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compositeCatalogForDesignSystem_colorScheme_contrast_styling_error_);
}

id objc_msgSend_compositeEffectStackWithShapeImage_withScale_blendOntoImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compositeEffectStackWithShapeImage_withScale_blendOntoImage_);
}

id objc_msgSend_compositingFilterForStylePresetWithName_styleConfiguration_foregroundColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compositingFilterForStylePresetWithName_styleConfiguration_foregroundColor_);
}

id objc_msgSend_compressedData_usedEncoding_andRowChunkSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compressedData_usedEncoding_andRowChunkSize_);
}

id objc_msgSend_compressionQuality(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compressionQuality);
}

id objc_msgSend_compressionType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_compressionType);
}

id objc_msgSend_computeLengthData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_computeLengthData);
}

id objc_msgSend_configureVibrantColorMatrixFilter_withOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_configureVibrantColorMatrixFilter_withOptions_);
}

id objc_msgSend_conformsToProtocol_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_conformsToProtocol_);
}

id objc_msgSend_containsLookupForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsLookupForName_);
}

id objc_msgSend_containsMulticolorLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsMulticolorLayers);
}

id objc_msgSend_containsNamedColorStyles(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsNamedColorStyles);
}

id objc_msgSend_containsObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsObject_);
}

id objc_msgSend_containsString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsString_);
}

id objc_msgSend_containsVectorGlyphInterpolationSources(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsVectorGlyphInterpolationSources);
}

id objc_msgSend_containsVectorGlyphWithWeight_size_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_containsVectorGlyphWithWeight_size_);
}

id objc_msgSend_contentBoundsUnrounded(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_contentBoundsUnrounded);
}

id objc_msgSend_contentEffect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_contentEffect);
}

id objc_msgSend_contentInsets(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_contentInsets);
}

id objc_msgSend_contentNames(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_contentNames);
}

id objc_msgSend_contentPresentForAttribute_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_contentPresentForAttribute_);
}

id objc_msgSend_contextWithOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_contextWithOptions_);
}

id objc_msgSend_convertDistance0_distance1_elementIndex0Out_distance0Out_elementIndex1Out_distance1Out_forSubpath_data_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_convertDistance0_distance1_elementIndex0Out_distance0Out_elementIndex1Out_distance1Out_forSubpath_data_);
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copy);
}

id objc_msgSend_copyClipShape(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyClipShape);
}

id objc_msgSend_copyColorSpace(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyColorSpace);
}

id objc_msgSend_copyDefaultICCProfileData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyDefaultICCProfileData);
}

id objc_msgSend_copyFromLinearBytes_linearOffset_linearBytesPerRow_linearBytesPerImage_toTextureMemory_textureSlice_textureLevel_textureRegion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyFromLinearBytes_linearOffset_linearBytesPerRow_linearBytesPerImage_toTextureMemory_textureSlice_textureLevel_textureRegion_);
}

id objc_msgSend_copyKeySignatureForKey_withBytesNoCopy_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyKeySignatureForKey_withBytesNoCopy_length_);
}

id objc_msgSend_copyLayerImageContentsAndCenter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyLayerImageContentsAndCenter_);
}

id objc_msgSend_copyLayerImageContentsAndCenter_renditionKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyLayerImageContentsAndCenter_renditionKey_);
}

id objc_msgSend_copyLookupKeySignatureForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyLookupKeySignatureForKey_);
}

id objc_msgSend_copySharedBlockDataWithPixelFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copySharedBlockDataWithPixelFormat_);
}

id objc_msgSend_copyValuesFromKeyList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyValuesFromKeyList_);
}

id objc_msgSend_copyWithZone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_copyWithZone_);
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_count);
}

id objc_msgSend_countByEnumeratingWithState_objects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_countByEnumeratingWithState_objects_count_);
}

id objc_msgSend_createCGImage_fromRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createCGImage_fromRect_);
}

id objc_msgSend_createCGImage_fromRect_format_colorSpace_deferred_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createCGImage_fromRect_format_colorSpace_deferred_);
}

id objc_msgSend_createCGImageAtLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createCGImageAtLayer_);
}

id objc_msgSend_createCompositeCGImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createCompositeCGImage);
}

id objc_msgSend_createConcatenatingPaths_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createConcatenatingPaths_);
}

id objc_msgSend_createCopyApplyingTransform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createCopyApplyingTransform_);
}

id objc_msgSend_createFromSubpaths_indices_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createFromSubpaths_indices_);
}

id objc_msgSend_createImageFromPDFRenditionWithScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createImageFromPDFRenditionWithScale_);
}

id objc_msgSend_createLayerGroupWithLayerNames_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createLayerGroupWithLayerNames_delegate_);
}

id objc_msgSend_createLayerGroupWithLayerTree_modePrefix_shapes_delegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createLayerGroupWithLayerTree_modePrefix_shapes_delegate_);
}

id objc_msgSend_createRadiosityImageWithImage_displayScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createRadiosityImageWithImage_displayScale_);
}

id objc_msgSend_createSubpaths(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createSubpaths);
}

id objc_msgSend_createWithPath_clipStrokeKeyframeProvider_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createWithPath_clipStrokeKeyframeProvider_);
}

id objc_msgSend_createWithPath_clipStrokeKeyframes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_createWithPath_clipStrokeKeyframes_);
}

id objc_msgSend_csiTextStyle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_csiTextStyle);
}

id objc_msgSend_cuiEffectBlendModeFromCGBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cuiEffectBlendModeFromCGBlendMode_);
}

id objc_msgSend_cuiPSDGradientWithColors_locations_midpointLocations_angle_isRadial_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cuiPSDGradientWithColors_locations_midpointLocations_angle_isRadial_);
}

id objc_msgSend_cuiPSDGradientWithColors_locations_midpointLocations_angle_style_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_cuiPSDGradientWithColors_locations_midpointLocations_angle_style_);
}

id objc_msgSend_currentHandler(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_currentHandler);
}

id objc_msgSend_currentLocale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_currentLocale);
}

id objc_msgSend_customizeForDistance_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_customizeForDistance_);
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_data);
}

id objc_msgSend_dataStart(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataStart);
}

id objc_msgSend_dataUsingEncoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataUsingEncoding_);
}

id objc_msgSend_dataWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithBytes_length_);
}

id objc_msgSend_dataWithBytesNoCopy_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithBytesNoCopy_length_);
}

id objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithBytesNoCopy_length_freeWhenDone_);
}

id objc_msgSend_dataWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithCapacity_);
}

id objc_msgSend_dataWithLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithLength_);
}

id objc_msgSend_dataWithName_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithName_appearanceName_);
}

id objc_msgSend_dataWithName_deviceIdiom_deviceSubtype_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dataWithName_deviceIdiom_deviceSubtype_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_);
}

id objc_msgSend_debugDescription(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_debugDescription);
}

id objc_msgSend_debugDescriptionForKeyList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_debugDescriptionForKeyList_);
}

id objc_msgSend_debugDescriptionWithIndentLevel_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_debugDescriptionWithIndentLevel_);
}

id objc_msgSend_decimalDigitCharacterSet(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decimalDigitCharacterSet);
}

id objc_msgSend_decodeBytesForKey_returnedLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeBytesForKey_returnedLength_);
}

id objc_msgSend_decodeBytesWithReturnedLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeBytesWithReturnedLength_);
}

id objc_msgSend_decodeDoubleForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeDoubleForKey_);
}

id objc_msgSend_decodeIntegerForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeIntegerForKey_);
}

id objc_msgSend_decodeObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeObject);
}

id objc_msgSend_decodeObjectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeObjectForKey_);
}

id objc_msgSend_decodeValueOfObjCType_at_size_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeValueOfObjCType_at_size_);
}

id objc_msgSend_decodeValuesOfObjCTypes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decodeValuesOfObjCTypes_);
}

id objc_msgSend_decrementValue_forAttribute_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_decrementValue_forAttribute_);
}

id objc_msgSend_defaultAppearanceName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_defaultAppearanceName);
}

id objc_msgSend_defaultCenter(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_defaultCenter);
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_defaultManager);
}

id objc_msgSend_delegate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_delegate);
}

id objc_msgSend_deltaArrayFrom_to_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_deltaArrayFrom_to_);
}

id objc_msgSend_deltaScalarsValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_deltaScalarsValue);
}

id objc_msgSend_deploymentPlatform(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_deploymentPlatform);
}

id objc_msgSend_deploymentPlatformString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_deploymentPlatformString);
}

id objc_msgSend_deploymentPlatformVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_deploymentPlatformVersion);
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_description);
}

id objc_msgSend_destinationRect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_destinationRect);
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dictionary);
}

id objc_msgSend_dictionaryWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dictionaryWithCapacity_);
}

id objc_msgSend_dictionaryWithObjects_forKeys_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dictionaryWithObjects_forKeys_count_);
}

id objc_msgSend_dictionaryWithObjectsAndKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dictionaryWithObjectsAndKeys_);
}

id objc_msgSend_dimension1(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dimension1);
}

id objc_msgSend_dimension1LocalizedString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dimension1LocalizedString);
}

id objc_msgSend_dimension2(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dimension2);
}

id objc_msgSend_dimensions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_dimensions);
}

id objc_msgSend_direction(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_direction);
}

id objc_msgSend_displayGamut(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_displayGamut);
}

id objc_msgSend_displayNameForRenditionType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_displayNameForRenditionType_);
}

id objc_msgSend_distance(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_distance);
}

id objc_msgSend_distilledInCoreUIVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_distilledInCoreUIVersion);
}

id objc_msgSend_diverseContentPresentForAttribute_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_diverseContentPresentForAttribute_);
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_doubleValue);
}

id objc_msgSend_drain(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drain);
}

id objc_msgSend_drawAngleGradientInRect_relativeCenterPosition_withContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawAngleGradientInRect_relativeCenterPosition_withContext_);
}

id objc_msgSend_drawAnimationFrameMappedFrom0_1RangedValue_destinationFrame_isFocused_focusRingColor_context_effects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawAnimationFrameMappedFrom0_1RangedValue_destinationFrame_isFocused_focusRingColor_context_effects_);
}

id objc_msgSend_drawFromPoint_toPoint_options_withContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawFromPoint_toPoint_options_withContext_);
}

id objc_msgSend_drawGlyphs_inContext_usingFont_atPositions_count_lineHeight_inBounds_atScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawGlyphs_inContext_usingFont_atPositions_count_lineHeight_inBounds_atScale_);
}

id objc_msgSend_drawGradientInFrame_angle_alpha_operation_isFocused_focusRingColor_keyAdjustment_context_effects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawGradientInFrame_angle_alpha_operation_isFocused_focusRingColor_keyAdjustment_context_effects_);
}

id objc_msgSend_drawHighlightInFrame_alpha_operation_keyAdjustment_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawHighlightInFrame_alpha_operation_keyAdjustment_context_);
}

id objc_msgSend_drawHighlightInFrame_alpha_operation_owner_userInfo_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawHighlightInFrame_alpha_operation_owner_userInfo_context_);
}

id objc_msgSend_drawHighlightInFrame_alpha_owner_userInfo_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawHighlightInFrame_alpha_owner_userInfo_context_);
}

id objc_msgSend_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_colorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_colorResolver_);
}

id objc_msgSend_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_hierarchicalColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_hierarchicalColorResolver_);
}

id objc_msgSend_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_onFillColor_offFillColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_onFillColor_offFillColor_);
}

id objc_msgSend_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_paletteColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInContext_scaleFactor_targetSize_variableMinValue_variableMaxValue_paletteColorResolver_);
}

id objc_msgSend_drawInFrame_alpha_operation_isFocused_focusRingColor_context_effects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInFrame_alpha_operation_isFocused_focusRingColor_context_effects_);
}

id objc_msgSend_drawInFrame_alpha_operation_isFocused_focusRingColor_keyAdjustment_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInFrame_alpha_operation_isFocused_focusRingColor_keyAdjustment_context_);
}

id objc_msgSend_drawInFrame_alpha_operation_owner_userInfo_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInFrame_alpha_operation_owner_userInfo_context_);
}

id objc_msgSend_drawInFrame_alpha_owner_userInfo_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInFrame_alpha_owner_userInfo_context_);
}

id objc_msgSend_drawInRect_angle_options_withContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInRect_angle_options_withContext_);
}

id objc_msgSend_drawInRect_angle_withContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawInRect_angle_withContext_);
}

id objc_msgSend_drawMaskInFrame_alpha_operation_isFocused_focusRingColor_keyAdjustment_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawMaskInFrame_alpha_operation_isFocused_focusRingColor_keyAdjustment_context_);
}

id objc_msgSend_drawMaskInFrame_alpha_owner_userInfo_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawMaskInFrame_alpha_owner_userInfo_context_);
}

id objc_msgSend_drawPaletteLayerAtIndex_inContext_withColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawPaletteLayerAtIndex_inContext_withColorResolver_);
}

id objc_msgSend_drawProcessedMask_atBounds_inContext_withScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawProcessedMask_atBounds_inContext_withScale_);
}

id objc_msgSend_drawRadialGradientInRect_relativeCenterPosition_withContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawRadialGradientInRect_relativeCenterPosition_withContext_);
}

id objc_msgSend_drawUsingQuartz_inContext_inBounds_atScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawUsingQuartz_inContext_inBounds_atScale_);
}

id objc_msgSend_drawingAngle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawingAngle);
}

id objc_msgSend_drawingLayer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawingLayer);
}

id objc_msgSend_drawingLayerLocalizedString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_drawingLayerLocalizedString);
}

id objc_msgSend_edgeBottomLeftMargin(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_edgeBottomLeftMargin);
}

id objc_msgSend_edgeInsets(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_edgeInsets);
}

id objc_msgSend_edgeInsets_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_edgeInsets_);
}

id objc_msgSend_edgeTopRightMargin(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_edgeTopRightMargin);
}

id objc_msgSend_edgesOnly(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_edgesOnly);
}

id objc_msgSend_effectCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectCount);
}

id objc_msgSend_effectDefinitionCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectDefinitionCount);
}

id objc_msgSend_effectInsetsWithScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectInsetsWithScale_);
}

id objc_msgSend_effectList(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectList);
}

id objc_msgSend_effectPaddingWithScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectPaddingWithScale_);
}

id objc_msgSend_effectPreset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectPreset);
}

id objc_msgSend_effectScale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectScale);
}

id objc_msgSend_effectShowsValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectShowsValue);
}

id objc_msgSend_effectType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectType);
}

id objc_msgSend_effectTypeAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_effectTypeAtIndex_);
}

id objc_msgSend_elementCategoryAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_elementCategoryAtIndex_);
}

id objc_msgSend_elementCategoryCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_elementCategoryCount);
}

id objc_msgSend_elementDefinitionCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_elementDefinitionCount);
}

id objc_msgSend_emptyData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_emptyData);
}

id objc_msgSend_emptyImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_emptyImage);
}

id objc_msgSend_encodeBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeBytes_length_);
}

id objc_msgSend_encodeBytes_length_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeBytes_length_forKey_);
}

id objc_msgSend_encodeDouble_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeDouble_forKey_);
}

id objc_msgSend_encodeInteger_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeInteger_forKey_);
}

id objc_msgSend_encodeObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeObject_);
}

id objc_msgSend_encodeObject_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeObject_forKey_);
}

id objc_msgSend_encodeValueOfObjCType_at_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeValueOfObjCType_at_);
}

id objc_msgSend_encodeValuesOfObjCTypes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_encodeValuesOfObjCTypes_);
}

id objc_msgSend_engraveShadow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_engraveShadow);
}

id objc_msgSend_engraveShadowCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_engraveShadowCount);
}

id objc_msgSend_enumerateIndexesUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_enumerateIndexesUsingBlock_);
}

id objc_msgSend_enumerateKeysAndObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_enumerateKeysAndObjectsUsingBlock_);
}

id objc_msgSend_enumerateObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_enumerateObjectsUsingBlock_);
}

id objc_msgSend_enumeratorWithPSDImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_enumeratorWithPSDImage_);
}

id objc_msgSend_enumeratorWithPSDLayerGroup_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_enumeratorWithPSDLayerGroup_);
}

id objc_msgSend_environment(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_environment);
}

id objc_msgSend_equivalentForegroundColorForStylePresetWithName_styleConfiguration_baseForegroundColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_equivalentForegroundColorForStylePresetWithName_styleConfiguration_baseForegroundColor_);
}

id objc_msgSend_errorWithDomain_code_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_errorWithDomain_code_userInfo_);
}

id objc_msgSend_evaluator(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_evaluator);
}

id objc_msgSend_exceptionWithName_reason_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_exceptionWithName_reason_userInfo_);
}

id objc_msgSend_exifOrientation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_exifOrientation);
}

id objc_msgSend_expressableByColorFillCheckingOutputBlending_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_expressableByColorFillCheckingOutputBlending_);
}

id objc_msgSend_extendClipStrokeKeyframes_withKeyframes_subpathOffset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_extendClipStrokeKeyframes_withKeyframes_subpathOffset_);
}

id objc_msgSend_extendedMetadata(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_extendedMetadata);
}

id objc_msgSend_extent(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_extent);
}

id objc_msgSend_externalTags(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_externalTags);
}

id objc_msgSend_extraShadow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_extraShadow);
}

id objc_msgSend_extraShadowCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_extraShadowCount);
}

id objc_msgSend_facetKeysdb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_facetKeysdb);
}

id objc_msgSend_facetWithElement_part_dimension1_dimension2_fromTheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_facetWithElement_part_dimension1_dimension2_fromTheme_);
}

id objc_msgSend_fileExistsAtPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fileExistsAtPath_);
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fileSystemRepresentation);
}

id objc_msgSend_fileSystemRepresentationWithPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fileSystemRepresentationWithPath_);
}

id objc_msgSend_fileURLWithPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fileURLWithPath_);
}

id objc_msgSend_fill(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fill);
}

id objc_msgSend_fillColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillColor);
}

id objc_msgSend_fillColorName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillColorName);
}

id objc_msgSend_fillColors(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillColors);
}

id objc_msgSend_fillImageNames(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillImageNames);
}

id objc_msgSend_fillImageWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillImageWithName_);
}

id objc_msgSend_fillSampleAtLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillSampleAtLayer_);
}

id objc_msgSend_fillStyledPath_inContext_stylePresetName_styleConfiguration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fillStyledPath_inContext_stylePresetName_styleConfiguration_);
}

id objc_msgSend_filterWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_filterWithName_);
}

id objc_msgSend_filterWithName_keysAndValues_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_filterWithName_keysAndValues_);
}

id objc_msgSend_filterWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_filterWithString_);
}

id objc_msgSend_filterWithType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_filterWithType_);
}

id objc_msgSend_filteredArrayUsingPredicate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_filteredArrayUsingPredicate_);
}

id objc_msgSend_finalizeNamedVectorGlyphLookupWithResult_name_glyphContinuousSize_glyphContinuousWeight_pointSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_finalizeNamedVectorGlyphLookupWithResult_name_glyphContinuousSize_glyphContinuousWeight_pointSize_);
}

id objc_msgSend_finalizeTextureMemory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_finalizeTextureMemory_);
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_firstObject);
}

id objc_msgSend_fixedFrame(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fixedFrame);
}

id objc_msgSend_flipped(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_flipped);
}

id objc_msgSend_float2Value(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_float2Value);
}

id objc_msgSend_float3Value(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_float3Value);
}

id objc_msgSend_float4Value(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_float4Value);
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_floatValue);
}

id objc_msgSend_fontMatchingScaleFactor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fontMatchingScaleFactor);
}

id objc_msgSend_fontSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fontSize);
}

id objc_msgSend_fontSizeForFontSizeType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fontSizeForFontSizeType_);
}

id objc_msgSend_fontdb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fontdb);
}

id objc_msgSend_fontsizedb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_fontsizedb);
}

id objc_msgSend_foregroundColorShouldTintEffects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_foregroundColorShouldTintEffects);
}

id objc_msgSend_format(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_format);
}

id objc_msgSend_frame(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_frame);
}

id objc_msgSend_geometryType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_geometryType);
}

id objc_msgSend_getBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getBytes_length_);
}

id objc_msgSend_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_);
}

id objc_msgSend_getBytes_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getBytes_range_);
}

id objc_msgSend_getCharacters_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getCharacters_);
}

id objc_msgSend_getColor_forName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getColor_forName_);
}

id objc_msgSend_getFontName_baselineOffset_forFontType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getFontName_baselineOffset_forFontType_);
}

id objc_msgSend_getMidpointLocationFromArray_atIndex_withPolicy_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getMidpointLocationFromArray_atIndex_withPolicy_);
}

id objc_msgSend_getPhysicalColor_withName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getPhysicalColor_withName_);
}

id objc_msgSend_getUUIDBytes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getUUIDBytes_);
}

id objc_msgSend_getValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_getValue_);
}

id objc_msgSend_globals(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_globals);
}

id objc_msgSend_glyphContinuousSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_glyphContinuousSize);
}

id objc_msgSend_glyphContinuousWeight(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_glyphContinuousWeight);
}

id objc_msgSend_glyphSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_glyphSize);
}

id objc_msgSend_glyphWeight(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_glyphWeight);
}

id objc_msgSend_gradient(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradient);
}

id objc_msgSend_gradientByApplyingEffects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradientByApplyingEffects_);
}

id objc_msgSend_gradientColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradientColor);
}

id objc_msgSend_gradientDrawingAngle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradientDrawingAngle);
}

id objc_msgSend_gradientStyle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradientStyle);
}

id objc_msgSend_gradientWithKeyAdjustment_angle_style_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradientWithKeyAdjustment_angle_style_);
}

id objc_msgSend_gradientWithParameters_inRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_gradientWithParameters_inRect_);
}

id objc_msgSend_graphicsClass(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_graphicsClass);
}

id objc_msgSend_handleFailureInFunction_file_lineNumber_description_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_handleFailureInFunction_file_lineNumber_description_);
}

id objc_msgSend_handleFailureInMethod_object_file_lineNumber_description_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_handleFailureInMethod_object_file_lineNumber_description_);
}

id objc_msgSend_hasAlignmentEdgeMargins(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasAlignmentEdgeMargins);
}

id objc_msgSend_hasAlignmentInformation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasAlignmentInformation);
}

id objc_msgSend_hasBevelEmboss(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasBevelEmboss);
}

id objc_msgSend_hasColorForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasColorForName_);
}

id objc_msgSend_hasColorOverlay(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasColorOverlay);
}

id objc_msgSend_hasEdgePixel(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasEdgePixel);
}

id objc_msgSend_hasEffects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasEffects);
}

id objc_msgSend_hasEngraveShadow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasEngraveShadow);
}

id objc_msgSend_hasExtraShadow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasExtraShadow);
}

id objc_msgSend_hasHueSaturation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasHueSaturation);
}

id objc_msgSend_hasImageFills(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasImageFills);
}

id objc_msgSend_hasInnerGlow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasInnerGlow);
}

id objc_msgSend_hasInnerGradient(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasInnerGradient);
}

id objc_msgSend_hasInnerShadow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasInnerShadow);
}

id objc_msgSend_hasLayerMask(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasLayerMask);
}

id objc_msgSend_hasOuterGlow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasOuterGlow);
}

id objc_msgSend_hasPrefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasPrefix_);
}

id objc_msgSend_hasStylePresetWithName_styleConfiguration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasStylePresetWithName_styleConfiguration_);
}

id objc_msgSend_hasSuffix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasSuffix_);
}

id objc_msgSend_hasVectorMask(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hasVectorMask);
}

id objc_msgSend_hash(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hash);
}

id objc_msgSend_hash64(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hash64);
}

id objc_msgSend_header(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_header);
}

id objc_msgSend_height(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_height);
}

id objc_msgSend_hierarchicalLayerThresholds(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hierarchicalLayerThresholds);
}

id objc_msgSend_hierarchicalLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hierarchicalLayers);
}

id objc_msgSend_hierarchyLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hierarchyLayers);
}

id objc_msgSend_hierarchyLevel(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hierarchyLevel);
}

id objc_msgSend_highlightBlendMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_highlightBlendMode);
}

id objc_msgSend_highlightColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_highlightColor);
}

id objc_msgSend_highlightOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_highlightOpacity);
}

id objc_msgSend_hueSaturationFrom_withCenterAngle_width_tintRed_tintGreen_tintBlue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_hueSaturationFrom_withCenterAngle_width_tintRed_tintGreen_tintBlue_);
}

id objc_msgSend_iconImageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_desiredSize_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_iconImageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_desiredSize_appearanceName_);
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_identifier);
}

id objc_msgSend_idiom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_idiom);
}

id objc_msgSend_image(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_image);
}

id objc_msgSend_image_withAdjustedOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_image_withAdjustedOpacity_);
}

id objc_msgSend_imageAlignment(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageAlignment);
}

id objc_msgSend_imageByApplyingTransform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageByApplyingTransform_);
}

id objc_msgSend_imageCentering(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageCentering);
}

id objc_msgSend_imageExistsWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageExistsWithName_);
}

id objc_msgSend_imageForSliceIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageForSliceIndex_);
}

id objc_msgSend_imageForState_value_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageForState_value_);
}

id objc_msgSend_imageForState_value_size_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageForState_value_size_);
}

id objc_msgSend_imageFromBlendWithMask_foreground_background_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageFromBlendWithMask_foreground_background_);
}

id objc_msgSend_imageFromRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageFromRef_);
}

id objc_msgSend_imageInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageInfo);
}

id objc_msgSend_imageNamedShouldFlip_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageNamedShouldFlip_);
}

id objc_msgSend_imageOffset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageOffset);
}

id objc_msgSend_imageRef(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageRef);
}

id objc_msgSend_imageScaling(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageScaling);
}

id objc_msgSend_imageSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageSize);
}

id objc_msgSend_imageType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageType);
}

id objc_msgSend_imageWithBevelEmbossOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithBevelEmbossOfImage_effect_);
}

id objc_msgSend_imageWithCGImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithCGImage_);
}

id objc_msgSend_imageWithColorOverlayOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithColorOverlayOfImage_effect_);
}

id objc_msgSend_imageWithColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithColorResolver_);
}

id objc_msgSend_imageWithEngraveShadowOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithEngraveShadowOfImage_effect_);
}

id objc_msgSend_imageWithExtraShadowOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithExtraShadowOfImage_effect_);
}

id objc_msgSend_imageWithHierarchyColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithHierarchyColorResolver_);
}

id objc_msgSend_imageWithHueSaturationOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithHueSaturationOfImage_effect_);
}

id objc_msgSend_imageWithInnerGlowOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithInnerGlowOfImage_effect_);
}

id objc_msgSend_imageWithInnerShadowOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithInnerShadowOfImage_effect_);
}

id objc_msgSend_imageWithInteriorGradientFillOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithInteriorGradientFillOfImage_effect_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_appearanceName_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_appearanceName_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_memoryClass_graphicsClass_appearanceIdentifier_graphicsFallBackOrder_deviceSubtypeFallBackOrder_locale_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_appearanceName_);
}

id objc_msgSend_imageWithName_scaleFactor_deviceIdiom_layoutDirection_locale_adjustRenditionKeyWithBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithName_scaleFactor_deviceIdiom_layoutDirection_locale_adjustRenditionKeyWithBlock_);
}

id objc_msgSend_imageWithOuterGlowOfImage_effect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithOuterGlowOfImage_effect_);
}

id objc_msgSend_imageWithPaletteColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithPaletteColorResolver_);
}

id objc_msgSend_imageWithPaletteColors_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithPaletteColors_);
}

id objc_msgSend_imageWithSingleBlurShapeEffectOfImage_withInteriorFill_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imageWithSingleBlurShapeEffectOfImage_withInteriorFill_);
}

id objc_msgSend_imagedb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imagedb);
}

id objc_msgSend_images(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_images);
}

id objc_msgSend_imagesWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_imagesWithName_);
}

id objc_msgSend_increaseLengthBy_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_increaseLengthBy_);
}

id objc_msgSend_incrementIndex_inValues_forAttribute_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_incrementIndex_inValues_forAttribute_);
}

id objc_msgSend_incrementMissedLookup(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_incrementMissedLookup);
}

id objc_msgSend_incrementStaticsInitialLookup(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_incrementStaticsInitialLookup);
}

id objc_msgSend_incrementStaticsProbe(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_incrementStaticsProbe);
}

id objc_msgSend_incrementStatisticDidShortCircuitImageLookup(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_incrementStatisticDidShortCircuitImageLookup);
}

id objc_msgSend_incrementStatisticLookup(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_incrementStatisticLookup);
}

id objc_msgSend_index(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_index);
}

id objc_msgSend_indexBuffer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_indexBuffer);
}

id objc_msgSend_indexCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_indexCount);
}

id objc_msgSend_indexOfObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_indexOfObject_);
}

id objc_msgSend_indexSet(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_indexSet);
}

id objc_msgSend_indexType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_indexType);
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_init);
}

id objc_msgSend_initFileURLWithPath_isDirectory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initFileURLWithPath_isDirectory_);
}

id objc_msgSend_initForArchiving_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initForArchiving_);
}

id objc_msgSend_initForArchiving_withMeshRenditionKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initForArchiving_withMeshRenditionKeys_);
}

id objc_msgSend_initForArchiving_withSubmeshRenditionKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initForArchiving_withSubmeshRenditionKeys_);
}

id objc_msgSend_initLayerMaskWithLayerRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initLayerMaskWithLayerRef_);
}

id objc_msgSend_initVectorMaskWithLayerRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initVectorMaskWithLayerRef_);
}

id objc_msgSend_initWithArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithArray_);
}

id objc_msgSend_initWithArray_copyItems_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithArray_copyItems_);
}

id objc_msgSend_initWithBitmapData_bytesPerRow_size_format_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBitmapData_bytesPerRow_size_format_options_);
}

id objc_msgSend_initWithBytes_andLength_ofType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBytes_andLength_ofType_);
}

id objc_msgSend_initWithBytes_deallocator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBytes_deallocator_);
}

id objc_msgSend_initWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBytes_length_);
}

id objc_msgSend_initWithBytes_length_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBytes_length_encoding_);
}

id objc_msgSend_initWithBytesNoCopy_length_encoding_freeWhenDone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBytesNoCopy_length_encoding_freeWhenDone_);
}

id objc_msgSend_initWithBytesNoCopy_length_freeWhenDone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithBytesNoCopy_length_freeWhenDone_);
}

id objc_msgSend_initWithCGColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCGColor_);
}

id objc_msgSend_initWithCGImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCGImage_);
}

id objc_msgSend_initWithCGImage_bufferAllocator_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCGImage_bufferAllocator_options_error_);
}

id objc_msgSend_initWithCGImage_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCGImage_options_);
}

id objc_msgSend_initWithCGImage_withDescription_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCGImage_withDescription_forKey_);
}

id objc_msgSend_initWithCGImageRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCGImageRef_);
}

id objc_msgSend_initWithCSIData_forKey_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCSIData_forKey_version_);
}

id objc_msgSend_initWithCanvasSize_sliceCount_layout_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCanvasSize_sliceCount_layout_);
}

id objc_msgSend_initWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCapacity_);
}

id objc_msgSend_initWithCatalogs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCatalogs_);
}

id objc_msgSend_initWithCenter_topLeft_top_topRight_right_bottomRight_bottom_bottomLeft_left_tileCenterAndEdges_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCenter_topLeft_top_topRight_right_bottomRight_bottom_bottomLeft_left_tileCenterAndEdges_);
}

id objc_msgSend_initWithCharacters_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithCharacters_length_);
}

id objc_msgSend_initWithColor_blendMode_displayGamut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithColor_blendMode_displayGamut_);
}

id objc_msgSend_initWithColorStops_colorMidpoints_opacityStops_opacityMidpoints_smoothingCoefficient_fillColor_dither_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithColorStops_colorMidpoints_opacityStops_opacityMidpoints_smoothingCoefficient_fillColor_dither_);
}

id objc_msgSend_initWithColors_colorlocations_colorMidpoints_opacities_opacityLocations_opacityMidpoints_smoothingCoefficient_fillColor_colorSpace_dither_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithColors_colorlocations_colorMidpoints_opacities_opacityLocations_opacityMidpoints_smoothingCoefficient_fillColor_colorSpace_dither_);
}

id objc_msgSend_initWithContentsOfURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithContentsOfURL_error_);
}

id objc_msgSend_initWithData_keyFormat_andPlatform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithData_keyFormat_andPlatform_);
}

id objc_msgSend_initWithData_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithData_range_);
}

id objc_msgSend_initWithDataSourceProvider_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithDataSourceProvider_);
}

id objc_msgSend_initWithDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithDictionary_);
}

id objc_msgSend_initWithDouble_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithDouble_);
}

id objc_msgSend_initWithEffectData_forScaleFactor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithEffectData_forScaleFactor_);
}

id objc_msgSend_initWithEffectFromPreset_atIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithEffectFromPreset_atIndex_);
}

id objc_msgSend_initWithEffectPreset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithEffectPreset_);
}

id objc_msgSend_initWithEvaluator_drawingAngle_gradientStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithEvaluator_drawingAngle_gradientStyle_);
}

id objc_msgSend_initWithFloat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithFloat_);
}

id objc_msgSend_initWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithFormat_);
}

id objc_msgSend_initWithFormat_arguments_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithFormat_arguments_);
}

id objc_msgSend_initWithGradient_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithGradient_);
}

id objc_msgSend_initWithIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithIdentifier_);
}

id objc_msgSend_initWithImage_dimensions_pixelFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithImage_dimensions_pixelFormat_);
}

id objc_msgSend_initWithImageRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithImageRef_);
}

id objc_msgSend_initWithImageRef_layerIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithImageRef_layerIndex_);
}

id objc_msgSend_initWithInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithInt_);
}

id objc_msgSend_initWithKeyFormat_andPlatform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithKeyFormat_andPlatform_);
}

id objc_msgSend_initWithKeyList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithKeyList_);
}

id objc_msgSend_initWithKeyList_themeIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithKeyList_themeIndex_);
}

id objc_msgSend_initWithKeyOptions_valueOptions_capacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithKeyOptions_valueOptions_capacity_);
}

id objc_msgSend_initWithLayerStackData_type_withCanvasSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithLayerStackData_type_withCanvasSize_);
}

id objc_msgSend_initWithLocation_gradientColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithLocation_gradientColor_);
}

id objc_msgSend_initWithLocation_leadInColor_leadOutColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithLocation_leadInColor_leadOutColor_);
}

id objc_msgSend_initWithLocation_leadInOpacity_leadOutOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithLocation_leadInOpacity_leadOutOpacity_);
}

id objc_msgSend_initWithLocation_opacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithLocation_opacity_);
}

id objc_msgSend_initWithLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithLongLong_);
}

id objc_msgSend_initWithName_contentsFromCatalog_usingRenditionKey_fromTheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_contentsFromCatalog_usingRenditionKey_fromTheme_);
}

id objc_msgSend_initWithName_format_offset_bufferIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_format_offset_bufferIndex_);
}

id objc_msgSend_initWithName_fromBundle_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_fromBundle_error_);
}

id objc_msgSend_initWithName_indexBuffer_indexCount_indexType_geometryType_material_topology_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_indexBuffer_indexCount_indexType_geometryType_material_topology_);
}

id objc_msgSend_initWithName_scaleFactor_deviceIdiom_pointSize_continuousWeight_continuousSize_interpolatedFromRegular_ultralight_black_fromCatalog_themeRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_scaleFactor_deviceIdiom_pointSize_continuousWeight_continuousSize_interpolatedFromRegular_ultralight_black_fromCatalog_themeRef_);
}

id objc_msgSend_initWithName_scaleFactor_deviceIdiom_pointSize_continuousWeight_continuousSize_interpolatedFromRegular_ultralight_black_fromCatalog_themeRef_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_scaleFactor_deviceIdiom_pointSize_continuousWeight_continuousSize_interpolatedFromRegular_ultralight_black_fromCatalog_themeRef_locale_);
}

id objc_msgSend_initWithName_scaleFactor_deviceIdiom_pointSize_fromCatalog_usingRenditionKey_themeRef_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_scaleFactor_deviceIdiom_pointSize_fromCatalog_usingRenditionKey_themeRef_locale_);
}

id objc_msgSend_initWithName_scatteringFunction_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_scatteringFunction_);
}

id objc_msgSend_initWithName_semantic_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_);
}

id objc_msgSend_initWithName_semantic_color_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_color_);
}

id objc_msgSend_initWithName_semantic_float2_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_float2_);
}

id objc_msgSend_initWithName_semantic_float3_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_float3_);
}

id objc_msgSend_initWithName_semantic_float4_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_float4_);
}

id objc_msgSend_initWithName_semantic_float_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_float_);
}

id objc_msgSend_initWithName_semantic_matrix4x4_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_matrix4x4_);
}

id objc_msgSend_initWithName_semantic_string_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_string_);
}

id objc_msgSend_initWithName_semantic_textureSampler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_semantic_textureSampler_);
}

id objc_msgSend_initWithName_usingRenditionKey_fromTheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_usingRenditionKey_fromTheme_);
}

id objc_msgSend_initWithName_usingRenditionKey_fromTheme_resolvingWithBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_usingRenditionKey_fromTheme_resolvingWithBlock_);
}

id objc_msgSend_initWithName_usingRenditionKey_withContents_contentsFromCatalog_fromTheme_withSourceThemeRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithName_usingRenditionKey_withContents_contentsFromCatalog_fromTheme_withSourceThemeRef_);
}

id objc_msgSend_initWithObjectsAndKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithObjectsAndKeys_);
}

id objc_msgSend_initWithPSDImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithPSDImage_);
}

id objc_msgSend_initWithPSDLayerGroup_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithPSDLayerGroup_);
}

id objc_msgSend_initWithPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithPath_);
}

id objc_msgSend_initWithPath_forWriting_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithPath_forWriting_);
}

id objc_msgSend_initWithPixelWidth_pixelHeight_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithPixelWidth_pixelHeight_);
}

id objc_msgSend_initWithPointSize_regular_ultralight_black_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithPointSize_regular_ultralight_black_);
}

id objc_msgSend_initWithRenditionKey_fromTheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithRenditionKey_fromTheme_);
}

id objc_msgSend_initWithRenditionType_destinationRect_topLeftInset_bottomRightInset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithRenditionType_destinationRect_topLeftInset_bottomRightInset_);
}

id objc_msgSend_initWithRenditions_name_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithRenditions_name_index_);
}

id objc_msgSend_initWithRenditions_part_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithRenditions_part_);
}

id objc_msgSend_initWithSize_index_idiom_subtype_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithSize_index_idiom_subtype_);
}

id objc_msgSend_initWithSliceInformation_destinationRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithSliceInformation_destinationRect_);
}

id objc_msgSend_initWithStop_midpoint_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithStop_midpoint_);
}

id objc_msgSend_initWithStride_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithStride_);
}

id objc_msgSend_initWithURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithURL_);
}

id objc_msgSend_initWithURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithURL_error_);
}

id objc_msgSend_initWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithUTF8String_);
}

id objc_msgSend_initWithUUIDBytes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithUUIDBytes_);
}

id objc_msgSend_initWithUnsignedShort_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithUnsignedShort_);
}

id objc_msgSend_initWithVertexBuffers_vertexCount_descriptor_submeshes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initWithVertexBuffers_vertexCount_descriptor_submeshes_);
}

id objc_msgSend_initializeTextureMemory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_initializeTextureMemory_);
}

id objc_msgSend_innerGlowCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_innerGlowCount);
}

id objc_msgSend_innerGlowFrom_withRadius_red_green_blue_opacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_innerGlowFrom_withRadius_red_green_blue_opacity_);
}

id objc_msgSend_innerGradient(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_innerGradient);
}

id objc_msgSend_innerGradientOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_innerGradientOpacity);
}

id objc_msgSend_innerShadowFrom_withOffset_radius_red_green_blue_opacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_innerShadowFrom_withOffset_radius_red_green_blue_opacity_);
}

id objc_msgSend_insertCGImage_withName_andDescription_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_insertCGImage_withName_andDescription_);
}

id objc_msgSend_insertObject_atIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_insertObject_atIndex_);
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_intValue);
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_integerValue);
}

id objc_msgSend_interiorAlignmentRectForTargetSize_scale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_interiorAlignmentRectForTargetSize_scale_);
}

id objc_msgSend_interiorAlignmentRectUnrounded(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_interiorAlignmentRectUnrounded);
}

id objc_msgSend_internalName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_internalName);
}

id objc_msgSend_internalScale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_internalScale);
}

id objc_msgSend_interpolatedColorAtLocation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_interpolatedColorAtLocation_);
}

id objc_msgSend_isASTC_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isASTC_);
}

id objc_msgSend_isAlphaCropped(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isAlphaCropped);
}

id objc_msgSend_isColorStop(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isColorStop);
}

id objc_msgSend_isDithered(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isDithered);
}

id objc_msgSend_isDoubleStop(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isDoubleStop);
}

id objc_msgSend_isEqual_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isEqual_);
}

id objc_msgSend_isEqualToArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isEqualToArray_);
}

id objc_msgSend_isEqualToNamedRenditionInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isEqualToNamedRenditionInfo_);
}

id objc_msgSend_isEqualToString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isEqualToString_);
}

id objc_msgSend_isEraserLayer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isEraserLayer);
}

id objc_msgSend_isFileURL(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isFileURL);
}

id objc_msgSend_isFlippable(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isFlippable);
}

id objc_msgSend_isGroupEnd(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isGroupEnd);
}

id objc_msgSend_isGroupStart(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isGroupStart);
}

id objc_msgSend_isInternalLink(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isInternalLink);
}

id objc_msgSend_isInterpolatable(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isInterpolatable);
}

id objc_msgSend_isKnockoutEnabledForHierarchicalLayerAtIndex_opacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isKnockoutEnabledForHierarchicalLayerAtIndex_opacity_);
}

id objc_msgSend_isLayerGroup(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isLayerGroup);
}

id objc_msgSend_isMemberOfClass_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isMemberOfClass_);
}

id objc_msgSend_isOpacityStop(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isOpacityStop);
}

id objc_msgSend_isOpaque(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isOpaque);
}

id objc_msgSend_isScaled(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isScaled);
}

id objc_msgSend_isStart(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isStart);
}

id objc_msgSend_isTiled(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isTiled);
}

id objc_msgSend_isTintable(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isTintable);
}

id objc_msgSend_isValidAssetStorageWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isValidAssetStorageWithBytes_length_);
}

id objc_msgSend_isValidAssetStorageWithURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isValidAssetStorageWithURL_);
}

id objc_msgSend_isValidPSDResourceAtPath_withLayerCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isValidPSDResourceAtPath_withLayerCount_);
}

id objc_msgSend_isVectorBased(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_isVectorBased);
}

id objc_msgSend_key(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "key");
}

id objc_msgSend_keyAttributeIndex(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keyAttributeIndex);
}

id objc_msgSend_keyFormat(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keyFormat);
}

id objc_msgSend_keyList(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keyList);
}

id objc_msgSend_keyScale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keyScale);
}

id objc_msgSend_keySemantics(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keySemantics);
}

id objc_msgSend_keySignature(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keySignature);
}

id objc_msgSend_keyfmt(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keyfmt);
}

id objc_msgSend_keysSortedByValueUsingComparator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_keysSortedByValueUsingComparator_);
}

id objc_msgSend_knownAvailableVectorSizes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_knownAvailableVectorSizes);
}

id objc_msgSend_languageCode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_languageCode);
}

id objc_msgSend_lastIndex(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lastIndex);
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lastObject);
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lastPathComponent);
}

id objc_msgSend_layer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layer);
}

id objc_msgSend_layerEnumerator(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerEnumerator);
}

id objc_msgSend_layerIndex(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerIndex);
}

id objc_msgSend_layerRefAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerRefAtIndex_);
}

id objc_msgSend_layerReferences(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerReferences);
}

id objc_msgSend_layerStackWithName_scaleFactor_deviceIdiom_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerStackWithName_scaleFactor_deviceIdiom_);
}

id objc_msgSend_layerStackWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerStackWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_layerWithRenditions_name_index_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layerWithRenditions_name_index_);
}

id objc_msgSend_layers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layers);
}

id objc_msgSend_layoutDirection(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layoutDirection);
}

id objc_msgSend_layouts(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_layouts);
}

id objc_msgSend_leadInColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_leadInColor);
}

id objc_msgSend_leadInOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_leadInOpacity);
}

id objc_msgSend_leadOutColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_leadOutColor);
}

id objc_msgSend_leadOutOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_leadOutOpacity);
}

id objc_msgSend_left(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_left);
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_length);
}

id objc_msgSend_lengthData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lengthData);
}

id objc_msgSend_lineCap(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lineCap);
}

id objc_msgSend_lineJoin(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lineJoin);
}

id objc_msgSend_linkingToRendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_linkingToRendition);
}

id objc_msgSend_loadPSDFileWithLayers_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_loadPSDFileWithLayers_);
}

id objc_msgSend_localObjectCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localObjectCache);
}

id objc_msgSend_localeWithLocaleIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localeWithLocaleIdentifier_);
}

id objc_msgSend_localization(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localization);
}

id objc_msgSend_localizationIdentifierForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localizationIdentifierForName_);
}

id objc_msgSend_localizationWorkaroundForKeyList_withLocale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localizationWorkaroundForKeyList_withLocale_);
}

id objc_msgSend_localizationdb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localizationdb);
}

id objc_msgSend_localizations(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localizations);
}

id objc_msgSend_localizedStringForKey_value_table_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localizedStringForKey_value_table_);
}

id objc_msgSend_localizedStringFromNumber_numberStyle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_localizedStringFromNumber_numberStyle_);
}

id objc_msgSend_location(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_location);
}

id objc_msgSend_lock(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lock);
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_longLongValue);
}

id objc_msgSend_lookupAssetForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lookupAssetForKey_);
}

id objc_msgSend_lookupCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_lookupCache);
}

id objc_msgSend_mainBundle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mainBundle);
}

id objc_msgSend_makeObjectsPerformSelector_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_makeObjectsPerformSelector_);
}

id objc_msgSend_map(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_map);
}

id objc_msgSend_mappedAliases(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mappedAliases);
}

id objc_msgSend_maskForSliceIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_maskForSliceIndex_);
}

id objc_msgSend_maskFromCompositeAlphaChannel_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_maskFromCompositeAlphaChannel_);
}

id objc_msgSend_material(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_material);
}

id objc_msgSend_materialFace(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_materialFace);
}

id objc_msgSend_matrix4x4(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_matrix4x4);
}

id objc_msgSend_maxPointSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_maxPointSize);
}

id objc_msgSend_maximumRenditionKeyTokenCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_maximumRenditionKeyTokenCount);
}

id objc_msgSend_memoryClass(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_memoryClass);
}

id objc_msgSend_meshKeys(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_meshKeys);
}

id objc_msgSend_methodForSelector_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_methodForSelector_);
}

id objc_msgSend_metrics(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_metrics);
}

id objc_msgSend_metricsInMask_forRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_metricsInMask_forRect_);
}

id objc_msgSend_midpoint(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_midpoint);
}

id objc_msgSend_minPointSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_minPointSize);
}

id objc_msgSend_minimumShadowSpread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_minimumShadowSpread);
}

id objc_msgSend_mipLevels(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mipLevels);
}

id objc_msgSend_modelAsset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_modelAsset);
}

id objc_msgSend_modelMesh(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_modelMesh);
}

id objc_msgSend_modelSubmesh(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_modelSubmesh);
}

id objc_msgSend_modtime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_modtime);
}

id objc_msgSend_monochromeForegroundColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_monochromeForegroundColor);
}

id objc_msgSend_monochromeLayerNamesInRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_monochromeLayerNamesInRendition_);
}

id objc_msgSend_monochromeVibrantColorMatrixOptions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_monochromeVibrantColorMatrixOptions);
}

id objc_msgSend_mostPreferredLanguageOf_withPreferredLanguages_forUsage_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mostPreferredLanguageOf_withPreferredLanguages_forUsage_options_);
}

id objc_msgSend_motionGroup(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_motionGroup);
}

id objc_msgSend_mutableBytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mutableBytes);
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mutableCopy);
}

id objc_msgSend_mutableCopyWithZone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_mutableCopyWithZone_);
}

id objc_msgSend_name(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_name);
}

id objc_msgSend_nameForAppearanceIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_nameForAppearanceIdentifier_);
}

id objc_msgSend_nameForLocalizationIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_nameForLocalizationIdentifier_);
}

id objc_msgSend_nameOfAttributeName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_nameOfAttributeName_);
}

id objc_msgSend_namedImageAtlasWithName_scaleFactor_deviceIdiom_displayGamut_deviceSubtype_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedImageAtlasWithName_scaleFactor_deviceIdiom_displayGamut_deviceSubtype_memoryClass_graphicsClass_graphicsFallBackOrder_deviceSubtypeFallBackOrder_);
}

id objc_msgSend_namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_);
}

id objc_msgSend_namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedLookupWithName_scaleFactor_deviceIdiom_deviceSubtype_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_namedTexture(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedTexture);
}

id objc_msgSend_namedTextureWithName_scaleFactor_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedTextureWithName_scaleFactor_appearanceName_);
}

id objc_msgSend_namedTextureWithName_scaleFactor_displayGamut_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedTextureWithName_scaleFactor_displayGamut_appearanceName_);
}

id objc_msgSend_namedVectorGlyphWithName_scaleFactor_deviceIdiom_layoutDirection_glyphContinuousSize_glyphContinuousWeight_glyphPointSize_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorGlyphWithName_scaleFactor_deviceIdiom_layoutDirection_glyphContinuousSize_glyphContinuousWeight_glyphPointSize_appearanceName_locale_);
}

id objc_msgSend_namedVectorGlyphWithName_scaleFactor_deviceIdiom_layoutDirection_glyphSize_glyphWeight_glyphPointSize_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorGlyphWithName_scaleFactor_deviceIdiom_layoutDirection_glyphSize_glyphWeight_glyphPointSize_appearanceName_);
}

id objc_msgSend_namedVectorGlyphWithName_scaleFactor_deviceIdiom_layoutDirection_glyphSize_glyphWeight_glyphPointSize_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorGlyphWithName_scaleFactor_deviceIdiom_layoutDirection_glyphSize_glyphWeight_glyphPointSize_appearanceName_locale_);
}

id objc_msgSend_namedVectorImageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorImageWithName_scaleFactor_deviceIdiom_deviceSubtype_displayGamut_layoutDirection_sizeClassHorizontal_sizeClassVertical_appearanceName_locale_);
}

id objc_msgSend_namedVectorImageWithName_scaleFactor_displayGamut_layoutDirection_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorImageWithName_scaleFactor_displayGamut_layoutDirection_);
}

id objc_msgSend_namedVectorImageWithName_scaleFactor_displayGamut_layoutDirection_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorImageWithName_scaleFactor_displayGamut_layoutDirection_appearanceName_);
}

id objc_msgSend_namedVectorImageWithName_scaleFactor_displayGamut_layoutDirection_appearanceName_locale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_namedVectorImageWithName_scaleFactor_displayGamut_layoutDirection_appearanceName_locale_);
}

id objc_msgSend_needsWideGamut(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_needsWideGamut);
}

id objc_msgSend_negativeCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_negativeCache);
}

id objc_msgSend_newBackgroundPatternColorWithSize_contentScale_forContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newBackgroundPatternColorWithSize_contentScale_forContext_);
}

id objc_msgSend_newBezierPathAtScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newBezierPathAtScale_);
}

id objc_msgSend_newBufferWithLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newBufferWithLength_);
}

id objc_msgSend_newColorByAdjustingLightnessOfColor_darker_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newColorByAdjustingLightnessOfColor_darker_);
}

id objc_msgSend_newColorByProcessingColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newColorByProcessingColor_);
}

id objc_msgSend_newFlattenedImageFromShapeCGImage_withScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newFlattenedImageFromShapeCGImage_withScale_);
}

id objc_msgSend_newFlattenedImageFromShapeCGImage_withScale_cache_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newFlattenedImageFromShapeCGImage_withScale_cache_);
}

id objc_msgSend_newFlattenedImageFromShapeCGImage_withScale_ciContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newFlattenedImageFromShapeCGImage_withScale_ciContext_);
}

id objc_msgSend_newGlyphMaskContextForBounds_fromContext_withScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newGlyphMaskContextForBounds_fromContext_withScale_);
}

id objc_msgSend_newImageFromSourceImage_newPixelFormat_bufferAllocator_gammaDegamma_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newImageFromSourceImage_newPixelFormat_bufferAllocator_gammaDegamma_error_);
}

id objc_msgSend_newImageFromSourceImage_scaledDimensions_bufferAllocattor_filter_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newImageFromSourceImage_scaledDimensions_bufferAllocattor_filter_error_);
}

id objc_msgSend_newPSDGradientFromCUIPSDGradient_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newPSDGradientFromCUIPSDGradient_);
}

id objc_msgSend_newPixelFormatSetForCGImage_displayGamut_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newPixelFormatSetForCGImage_displayGamut_options_);
}

id objc_msgSend_newShapeEffectPresetForStylePresetName_styleConfiguration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newShapeEffectPresetForStylePresetName_styleConfiguration_);
}

id objc_msgSend_newShapeEffectPresetWithRenditionKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newShapeEffectPresetWithRenditionKey_);
}

id objc_msgSend_newShapeEffectStackForStylePresetName_styleConfiguration_foregroundColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newShapeEffectStackForStylePresetName_styleConfiguration_foregroundColor_);
}

id objc_msgSend_newSliceRectsArray_withSliceRects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newSliceRectsArray_withSliceRects_);
}

id objc_msgSend_newSliceRectsArray_withXCutPositions_yCutPositions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newSliceRectsArray_withXCutPositions_yCutPositions_);
}

id objc_msgSend_newTextEffectStackForStylePresetName_styleConfiguration_foregroundColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newTextEffectStackForStylePresetName_styleConfiguration_foregroundColor_);
}

id objc_msgSend_newTextureLayoutWithDescriptor_isHeapOrBufferBacked_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newTextureLayoutWithDescriptor_isHeapOrBufferBacked_);
}

id objc_msgSend_newUInt32CArray_withNSArray_prependNumber_appendNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newUInt32CArray_withNSArray_prependNumber_appendNumber_);
}

id objc_msgSend_newWithSublayerCount_indexSet_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_newWithSublayerCount_indexSet_);
}

id objc_msgSend_nextObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_nextObject);
}

id objc_msgSend_nextSizeSmaller(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_nextSizeSmaller);
}

id objc_msgSend_numberOfBitsSet(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberOfBitsSet);
}

id objc_msgSend_numberOfHierarchyLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberOfHierarchyLayers);
}

id objc_msgSend_numberOfLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberOfLayers);
}

id objc_msgSend_numberOfSlices(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberOfSlices);
}

id objc_msgSend_numberOfSublayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberOfSublayers);
}

id objc_msgSend_numberWithBool_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithBool_);
}

id objc_msgSend_numberWithDouble_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithDouble_);
}

id objc_msgSend_numberWithFloat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithFloat_);
}

id objc_msgSend_numberWithInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithInt_);
}

id objc_msgSend_numberWithInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithInteger_);
}

id objc_msgSend_numberWithUnsignedInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithUnsignedInt_);
}

id objc_msgSend_numberWithUnsignedInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithUnsignedInteger_);
}

id objc_msgSend_numberWithUnsignedLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithUnsignedLongLong_);
}

id objc_msgSend_numberWithUnsignedShort_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberWithUnsignedShort_);
}

id objc_msgSend_numberingSystem(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_numberingSystem);
}

id objc_msgSend_objCType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_objCType);
}

id objc_msgSend_object(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_object);
}

id objc_msgSend_objectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_objectAtIndex_);
}

id objc_msgSend_objectAtIndexedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_objectAtIndexedSubscript_);
}

id objc_msgSend_objectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_objectForKey_);
}

id objc_msgSend_objectForKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_objectForKeyedSubscript_);
}

id objc_msgSend_objectVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_objectVersion);
}

id objc_msgSend_offset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_offset);
}

id objc_msgSend_offset_by_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_offset_by_);
}

id objc_msgSend_opacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_opacity);
}

id objc_msgSend_opacityLocation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_opacityLocation);
}

id objc_msgSend_opacityMidpointLocations(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_opacityMidpointLocations);
}

id objc_msgSend_opacityStops(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_opacityStops);
}

id objc_msgSend_openImageFile(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_openImageFile);
}

id objc_msgSend_optOutOfThinning(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_optOutOfThinning);
}

id objc_msgSend_optimizedSingleBlurEffectCompositeWithShapeImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_optimizedSingleBlurEffectCompositeWithShapeImage_);
}

id objc_msgSend_options(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_options);
}

id objc_msgSend_orderedSetWithArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_orderedSetWithArray_);
}

id objc_msgSend_originPoints(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_originPoints);
}

id objc_msgSend_originalUncroppedSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_originalUncroppedSize);
}

id objc_msgSend_outerGlowFrom_withSize_spread_red_green_blue_opacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_outerGlowFrom_withSize_spread_red_green_blue_opacity_);
}

id objc_msgSend_outerShadowFrom_withOffset_size_spread_red_green_blue_opacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_outerShadowFrom_withOffset_size_spread_red_green_blue_opacity_);
}

id objc_msgSend_outputBlendMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_outputBlendMode);
}

id objc_msgSend_outputImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_outputImage);
}

id objc_msgSend_outputOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_outputOpacity);
}

id objc_msgSend_packageWithData_type_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_packageWithData_type_options_error_);
}

id objc_msgSend_parentNamedImageAtlasForImageNamed_scaleFactor_displayGamut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_parentNamedImageAtlasForImageNamed_scaleFactor_displayGamut_);
}

id objc_msgSend_partFeatures(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_partFeatures);
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_path);
}

id objc_msgSend_pathAtScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pathAtScale_);
}

id objc_msgSend_pathForLayerNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pathForLayerNamed_);
}

id objc_msgSend_pathForResource_ofType_inDirectory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pathForResource_ofType_inDirectory_);
}

id objc_msgSend_pathForScalars_andTransform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pathForScalars_andTransform_);
}

id objc_msgSend_pattern(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pattern);
}

id objc_msgSend_pdfDocument(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pdfDocument);
}

id objc_msgSend_pdfDocumentWithName_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pdfDocumentWithName_appearanceName_);
}

id objc_msgSend_performSelector_withObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_performSelector_withObject_);
}

id objc_msgSend_physicalSizeInMeters(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_physicalSizeInMeters);
}

id objc_msgSend_pixelData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pixelData);
}

id objc_msgSend_pixelFormat(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pixelFormat);
}

id objc_msgSend_platform(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_platform);
}

id objc_msgSend_pointArrayFromPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pointArrayFromPath_);
}

id objc_msgSend_pointSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pointSize);
}

id objc_msgSend_pointValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_pointValue);
}

id objc_msgSend_positionOfSliceBoundary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_positionOfSliceBoundary_);
}

id objc_msgSend_predicateWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_predicateWithFormat_);
}

id objc_msgSend_preferredCIContextOptions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_preferredCIContextOptions);
}

id objc_msgSend_preferredLocalizations(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_preferredLocalizations);
}

id objc_msgSend_preferredLocalizationsFromArray_forPreferences_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_preferredLocalizationsFromArray_forPreferences_);
}

id objc_msgSend_presentationState(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_presentationState);
}

id objc_msgSend_preserveForArchiveOnly(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_preserveForArchiveOnly);
}

id objc_msgSend_preservedVectorRepresentation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_preservedVectorRepresentation);
}

id objc_msgSend_previousState(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_previousState);
}

id objc_msgSend_previousStateLocalizedString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_previousStateLocalizedString);
}

id objc_msgSend_previousValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_previousValue);
}

id objc_msgSend_previousValueLocalizedString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_previousValueLocalizedString);
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_processInfo);
}

id objc_msgSend_processedImageFromImage_withScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_processedImageFromImage_withScale_);
}

id objc_msgSend_processedImageFromShapeImage_withScale_invertShadows_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_processedImageFromShapeImage_withScale_invertShadows_);
}

id objc_msgSend_properties(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_properties);
}

id objc_msgSend_provideImageInfoAtLevel_element_face_withBufferAllocator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_provideImageInfoAtLevel_element_face_withBufferAllocator_);
}

id objc_msgSend_provideTextureInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_provideTextureInfo);
}

id objc_msgSend_psd(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "psd");
}

id objc_msgSend_psdFile(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_psdFile);
}

id objc_msgSend_psdFileForComposite(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_psdFileForComposite);
}

id objc_msgSend_psdLayerBlendModeForCGBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_psdLayerBlendModeForCGBlendMode_);
}

id objc_msgSend_raise(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_raise);
}

id objc_msgSend_raise_format_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_raise_format_);
}

id objc_msgSend_rangeOfString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rangeOfString_);
}

id objc_msgSend_rangeOfString_options_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rangeOfString_options_range_);
}

id objc_msgSend_rasterizeImageUsingScaleFactor_forTargetSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rasterizeImageUsingScaleFactor_forTargetSize_);
}

id objc_msgSend_rasterizeImageUsingScaleFactor_forTargetSize_withColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rasterizeImageUsingScaleFactor_forTargetSize_withColorResolver_);
}

id objc_msgSend_rasterizeImageUsingScaleFactor_forTargetSize_withHierarchyColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rasterizeImageUsingScaleFactor_forTargetSize_withHierarchyColorResolver_);
}

id objc_msgSend_rasterizeImageUsingScaleFactor_forTargetSize_withPaletteColorResolver_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rasterizeImageUsingScaleFactor_forTargetSize_withPaletteColorResolver_);
}

id objc_msgSend_rasterizeImageUsingScaleFactor_forTargetSize_withPaletteColors_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rasterizeImageUsingScaleFactor_forTargetSize_withPaletteColors_);
}

id objc_msgSend_rawData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rawData);
}

id objc_msgSend_realloc_cgfloat_array_withNewCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_realloc_cgfloat_array_withNewCount_);
}

id objc_msgSend_realloc_float_array_withNewCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_realloc_float_array_withNewCount_);
}

id objc_msgSend_realloc_length_array_withNewCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_realloc_length_array_withNewCount_);
}

id objc_msgSend_realloc_long_array_withNewCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_realloc_long_array_withNewCount_);
}

id objc_msgSend_recognitionImageWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_recognitionImageWithName_);
}

id objc_msgSend_recognitionObjectWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_recognitionObjectWithName_);
}

id objc_msgSend_rectValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rectValue);
}

id objc_msgSend_referenceCanvasSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_referenceCanvasSize);
}

id objc_msgSend_referenceImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_referenceImage);
}

id objc_msgSend_referenceKey(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_referenceKey);
}

id objc_msgSend_referenceOriginTransformation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_referenceOriginTransformation);
}

id objc_msgSend_referencePointSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_referencePointSize);
}

id objc_msgSend_referenceShape(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_referenceShape);
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeAllObjects);
}

id objc_msgSend_removeAssetForKey_withLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeAssetForKey_withLength_);
}

id objc_msgSend_removeAssetNameKey_withLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeAssetNameKey_withLength_);
}

id objc_msgSend_removeImageNamed_withDescription_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeImageNamed_withDescription_);
}

id objc_msgSend_removeImagesNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeImagesNamed_);
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeLastObject);
}

id objc_msgSend_removeObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeObject_);
}

id objc_msgSend_removeObjectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeObjectAtIndex_);
}

id objc_msgSend_removeObjectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeObjectForKey_);
}

id objc_msgSend_removeObserver_name_object_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_removeObserver_name_object_);
}

id objc_msgSend_render_toBitmap_rowBytes_bounds_format_colorSpace_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_render_toBitmap_rowBytes_bounds_format_colorSpace_);
}

id objc_msgSend_rendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rendition);
}

id objc_msgSend_renditionClassForRenditionType_andPixelFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionClassForRenditionType_andPixelFormat_);
}

id objc_msgSend_renditionCoordinatesForPartFeatures_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionCoordinatesForPartFeatures_);
}

id objc_msgSend_renditionCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionCount);
}

id objc_msgSend_renditionFlags(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionFlags);
}

id objc_msgSend_renditionForSpecificKeyWrapper_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionForSpecificKeyWrapper_);
}

id objc_msgSend_renditionInfoCacheLock(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionInfoCacheLock);
}

id objc_msgSend_renditionInfoForIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionInfoForIdentifier_);
}

id objc_msgSend_renditionKey(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKey);
}

id objc_msgSend_renditionKeyForAssetWithName_withDescription_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForAssetWithName_withDescription_);
}

id objc_msgSend_renditionKeyForName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForName_);
}

id objc_msgSend_renditionKeyForName_cursorHotSpot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForName_cursorHotSpot_);
}

id objc_msgSend_renditionKeyForName_hotSpot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForName_hotSpot_);
}

id objc_msgSend_renditionKeyForShapeEffectPresetForStylePresetName_styleConfiguration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForShapeEffectPresetForStylePresetName_styleConfiguration_);
}

id objc_msgSend_renditionKeyForShapeEffectPresetWithStyleID_state_presentationState_value_resolution_dimension1_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForShapeEffectPresetWithStyleID_state_presentationState_value_resolution_dimension1_);
}

id objc_msgSend_renditionKeyForShapeEffectPresetWithStylePresetName_state_presentationState_value_resolution_dimension1_appearance_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyForShapeEffectPresetWithStylePresetName_state_presentationState_value_resolution_dimension1_appearance_);
}

id objc_msgSend_renditionKeyFormat(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyFormat);
}

id objc_msgSend_renditionKeyWithKeyList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionKeyWithKeyList_);
}

id objc_msgSend_renditionNameForKeyBaseList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionNameForKeyBaseList_);
}

id objc_msgSend_renditionNameForKeyList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionNameForKeyList_);
}

id objc_msgSend_renditionType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionType);
}

id objc_msgSend_renditionWithKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionWithKey_);
}

id objc_msgSend_renditionWithKey_usingKeySignature_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditionWithKey_usingKeySignature_);
}

id objc_msgSend_renditions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_renditions);
}

id objc_msgSend_resizingMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_resizingMode);
}

id objc_msgSend_resizingModeWithSubtype_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_resizingModeWithSubtype_);
}

id objc_msgSend_resourcePath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_resourcePath);
}

id objc_msgSend_reverseObjectEnumerator(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_reverseObjectEnumerator);
}

id objc_msgSend_right(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_right);
}

id objc_msgSend_rootLayer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rootLayer);
}

id objc_msgSend_roundedRectCornerRadius(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_roundedRectCornerRadius);
}

id objc_msgSend_rowbytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_rowbytes);
}

id objc_msgSend_sanitizeEdgeInsets(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sanitizeEdgeInsets);
}

id objc_msgSend_saveWithCompletionHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_saveWithCompletionHandler_);
}

id objc_msgSend_scalarsForGlyphContinuousWeight_glyphContinuousSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scalarsForGlyphContinuousWeight_glyphContinuousSize_);
}

id objc_msgSend_scale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scale);
}

id objc_msgSend_scaleBrightnessOfEffectColorsByAmount_onlyTintableColors_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scaleBrightnessOfEffectColorsByAmount_onlyTintableColors_);
}

id objc_msgSend_scaleEffectParametersBy_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scaleEffectParametersBy_);
}

id objc_msgSend_scalefactor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scalefactor);
}

id objc_msgSend_scalingStyle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scalingStyle);
}

id objc_msgSend_scanInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scanInt_);
}

id objc_msgSend_scanInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scanInteger_);
}

id objc_msgSend_scanUpToCharactersFromSet_intoString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scanUpToCharactersFromSet_intoString_);
}

id objc_msgSend_scannerWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scannerWithString_);
}

id objc_msgSend_scatteringFunction(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_scatteringFunction);
}

id objc_msgSend_schemaForPlatform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_schemaForPlatform_);
}

id objc_msgSend_schemaLayersAndLayerGroups(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_schemaLayersAndLayerGroups);
}

id objc_msgSend_schemaVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_schemaVersion);
}

id objc_msgSend_semantic(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_semantic);
}

id objc_msgSend_set(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_set);
}

id objc_msgSend_setAllowsDeepmap2ImageCompression_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAllowsDeepmap2ImageCompression_);
}

id objc_msgSend_setAllowsDeepmapImageCompression_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAllowsDeepmapImageCompression_);
}

id objc_msgSend_setAllowsHevcCompression_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAllowsHevcCompression_);
}

id objc_msgSend_setAllowsPaletteImageCompression_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAllowsPaletteImageCompression_);
}

id objc_msgSend_setAlphaInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAlphaInfo_);
}

id objc_msgSend_setAltitude_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAltitude_);
}

id objc_msgSend_setAngle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAngle_);
}

id objc_msgSend_setAppearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAppearanceName_);
}

id objc_msgSend_setAppearancedb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAppearancedb_);
}

id objc_msgSend_setArrayLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setArrayLength_);
}

id objc_msgSend_setAsset_forKey_withLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAsset_forKey_withLength_);
}

id objc_msgSend_setAttributePresent_withValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setAttributePresent_withValue_);
}

id objc_msgSend_setBitmapKeydb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBitmapKeydb_);
}

id objc_msgSend_setBlackDeltas_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBlackDeltas_);
}

id objc_msgSend_setBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBlendMode_);
}

id objc_msgSend_setBlurSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBlurSize_);
}

id objc_msgSend_setBounds_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBounds_);
}

id objc_msgSend_setBuffer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBuffer_);
}

id objc_msgSend_setBufferAllocator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBufferAllocator_);
}

id objc_msgSend_setBundleID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBundleID_);
}

id objc_msgSend_setBypassColorFills_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBypassColorFills_);
}

id objc_msgSend_setBytesPerImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBytesPerImage_);
}

id objc_msgSend_setBytesPerRow_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setBytesPerRow_);
}

id objc_msgSend_setCalculationMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setCalculationMode_);
}

id objc_msgSend_setColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColor_);
}

id objc_msgSend_setColorMap_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColorMap_);
}

id objc_msgSend_setColorOverlayCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColorOverlayCount_);
}

id objc_msgSend_setColorScheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColorScheme_);
}

id objc_msgSend_setColorSpaceHandling_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColorSpaceHandling_);
}

id objc_msgSend_setColorSpaceID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColorSpaceID_);
}

id objc_msgSend_setColorStops_midpoints_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColorStops_midpoints_);
}

id objc_msgSend_setColordb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setColordb_);
}

id objc_msgSend_setCompositingFilter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setCompositingFilter_);
}

id objc_msgSend_setCompressionQuality_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setCompressionQuality_);
}

id objc_msgSend_setCompressionType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setCompressionType_);
}

id objc_msgSend_setContents_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setContents_);
}

id objc_msgSend_setContentsCenter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setContentsCenter_);
}

id objc_msgSend_setContentsRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setContentsRect_);
}

id objc_msgSend_setContentsScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setContentsScale_);
}

id objc_msgSend_setContentsScaling_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setContentsScaling_);
}

id objc_msgSend_setContrast_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setContrast_);
}

id objc_msgSend_setCountLimit_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setCountLimit_);
}

id objc_msgSend_setCubemap_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setCubemap_);
}

id objc_msgSend_setDesignSystem_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setDesignSystem_);
}

id objc_msgSend_setDimension1_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setDimension1_);
}

id objc_msgSend_setDimensions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setDimensions_);
}

id objc_msgSend_setDirection_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setDirection_);
}

id objc_msgSend_setDistance_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setDistance_);
}

id objc_msgSend_setDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setDuration_);
}

id objc_msgSend_setEdgeInsets_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEdgeInsets_);
}

id objc_msgSend_setEffectPreset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEffectPreset_);
}

id objc_msgSend_setEffectScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEffectScale_);
}

id objc_msgSend_setEnabled_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEnabled_);
}

id objc_msgSend_setEndPoint_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEndPoint_);
}

id objc_msgSend_setEngraveShadowCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEngraveShadowCount_);
}

id objc_msgSend_setError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setError_);
}

id objc_msgSend_setEvictsObjectsWithDiscardedContent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setEvictsObjectsWithDiscardedContent_);
}

id objc_msgSend_setExifOrientation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setExifOrientation_);
}

id objc_msgSend_setExtendedMetadata_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setExtendedMetadata_);
}

id objc_msgSend_setFacetKeysdb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFacetKeysdb_);
}

id objc_msgSend_setFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFile_);
}

id objc_msgSend_setFileURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFileURL_);
}

id objc_msgSend_setFillMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFillMode_);
}

id objc_msgSend_setFixedFrame_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFixedFrame_);
}

id objc_msgSend_setFontMatchingScaleFactor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFontMatchingScaleFactor_);
}

id objc_msgSend_setFontdb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFontdb_);
}

id objc_msgSend_setFontsizedb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFontsizedb_);
}

id objc_msgSend_setForegroundColorShouldTintEffects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setForegroundColorShouldTintEffects_);
}

id objc_msgSend_setFrame_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setFrame_);
}

id objc_msgSend_setGlobals_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setGlobals_);
}

id objc_msgSend_setGradient_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setGradient_);
}

id objc_msgSend_setHighlightBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setHighlightBlendMode_);
}

id objc_msgSend_setHighlightColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setHighlightColor_);
}

id objc_msgSend_setHighlightOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setHighlightOpacity_);
}

id objc_msgSend_setIdiom_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setIdiom_);
}

id objc_msgSend_setImageRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setImageRef_);
}

id objc_msgSend_setImagedb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setImagedb_);
}

id objc_msgSend_setIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setIndex_);
}

id objc_msgSend_setInnerGlowCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setInnerGlowCount_);
}

id objc_msgSend_setInnerGradientCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setInnerGradientCount_);
}

id objc_msgSend_setInnerShadowCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setInnerShadowCount_);
}

id objc_msgSend_setInternalName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setInternalName_);
}

id objc_msgSend_setInternalScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setInternalScale_);
}

id objc_msgSend_setInternalTemplateRenderingMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setInternalTemplateRenderingMode_);
}

id objc_msgSend_setIsStart_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setIsStart_);
}

id objc_msgSend_setKeyTimes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setKeyTimes_);
}

id objc_msgSend_setKeyfmt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setKeyfmt_);
}

id objc_msgSend_setLayerIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setLayerIndex_);
}

id objc_msgSend_setLocalizationdb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setLocalizationdb_);
}

id objc_msgSend_setLocation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setLocation_);
}

id objc_msgSend_setMainBundle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setMainBundle_);
}

id objc_msgSend_setMinimumObjectCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setMinimumObjectCount_);
}

id objc_msgSend_setMinimumShadowSpread_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setMinimumShadowSpread_);
}

id objc_msgSend_setMipmapLevelCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setMipmapLevelCount_);
}

id objc_msgSend_setMultiplyAlpha_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setMultiplyAlpha_);
}

id objc_msgSend_setName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setName_);
}

id objc_msgSend_setNamedTexture_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setNamedTexture_);
}

id objc_msgSend_setNextSizeSmaller_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setNextSizeSmaller_);
}

id objc_msgSend_setObject_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setObject_forKey_);
}

id objc_msgSend_setObject_forKey_cost_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setObject_forKey_cost_);
}

id objc_msgSend_setObject_forKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setObject_forKeyedSubscript_);
}

id objc_msgSend_setOffset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setOffset_);
}

id objc_msgSend_setOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setOpacity_);
}

id objc_msgSend_setOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setOptions_);
}

id objc_msgSend_setOriginOperation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setOriginOperation_);
}

id objc_msgSend_setOriginPoints_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setOriginPoints_);
}

id objc_msgSend_setPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setPath_);
}

id objc_msgSend_setPixelData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setPixelData_);
}

id objc_msgSend_setPixelFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setPixelFormat_);
}

id objc_msgSend_setPointSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setPointSize_);
}

id objc_msgSend_setProperty_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setProperty_);
}

id objc_msgSend_setPsd_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setPsd_);
}

id objc_msgSend_setReferenceKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setReferenceKey_);
}

id objc_msgSend_setRemovedOnCompletion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setRemovedOnCompletion_);
}

id objc_msgSend_setRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setRendition_);
}

id objc_msgSend_setRenditions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setRenditions_);
}

id objc_msgSend_setRepresentsOnDemandContent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setRepresentsOnDemandContent_);
}

id objc_msgSend_setScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setScale_);
}

id objc_msgSend_setShadowBlendMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setShadowBlendMode_);
}

id objc_msgSend_setShadowColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setShadowColor_);
}

id objc_msgSend_setShadowOpacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setShadowOpacity_);
}

id objc_msgSend_setSharedBlockData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setSharedBlockData_);
}

id objc_msgSend_setSoftenSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setSoftenSize_);
}

id objc_msgSend_setSourceAlphaInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setSourceAlphaInfo_);
}

id objc_msgSend_setSpread_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setSpread_);
}

id objc_msgSend_setStartPoint_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setStartPoint_);
}

id objc_msgSend_setStorageRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setStorageRef_);
}

id objc_msgSend_setStyling_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setStyling_);
}

id objc_msgSend_setSubmeshes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setSubmeshes_);
}

id objc_msgSend_setSubtype_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setSubtype_);
}

id objc_msgSend_setTargetPlatform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setTargetPlatform_);
}

id objc_msgSend_setTexture_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setTexture_);
}

id objc_msgSend_setThemeAppearance_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeAppearance_);
}

id objc_msgSend_setThemeDeploymentTarget_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeDeploymentTarget_);
}

id objc_msgSend_setThemeDimension1_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeDimension1_);
}

id objc_msgSend_setThemeDimension2_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeDimension2_);
}

id objc_msgSend_setThemeDirection_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeDirection_);
}

id objc_msgSend_setThemeDisplayGamut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeDisplayGamut_);
}

id objc_msgSend_setThemeElement_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeElement_);
}

id objc_msgSend_setThemeGlyphSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeGlyphSize_);
}

id objc_msgSend_setThemeGlyphWeight_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeGlyphWeight_);
}

id objc_msgSend_setThemeGraphicsClass_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeGraphicsClass_);
}

id objc_msgSend_setThemeIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeIdentifier_);
}

id objc_msgSend_setThemeIdiom_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeIdiom_);
}

id objc_msgSend_setThemeIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeIndex_);
}

id objc_msgSend_setThemeLayer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeLayer_);
}

id objc_msgSend_setThemeLocalization_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeLocalization_);
}

id objc_msgSend_setThemeMemoryClass_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeMemoryClass_);
}

id objc_msgSend_setThemePart_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemePart_);
}

id objc_msgSend_setThemePresentationState_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemePresentationState_);
}

id objc_msgSend_setThemeScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeScale_);
}

id objc_msgSend_setThemeSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeSize_);
}

id objc_msgSend_setThemeSizeClassHorizontal_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeSizeClassHorizontal_);
}

id objc_msgSend_setThemeSizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeSizeClassVertical_);
}

id objc_msgSend_setThemeState_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeState_);
}

id objc_msgSend_setThemeSubtype_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeSubtype_);
}

id objc_msgSend_setThemeValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setThemeValue_);
}

id objc_msgSend_setTotalCostLimit_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setTotalCostLimit_);
}

id objc_msgSend_setType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setType_);
}

id objc_msgSend_setUltralightDeltas_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setUltralightDeltas_);
}

id objc_msgSend_setUseSimplifiedEffect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setUseSimplifiedEffect_);
}

id objc_msgSend_setValue_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setValue_forKey_);
}

id objc_msgSend_setValues_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setValues_);
}

id objc_msgSend_setValuesFromKeyList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setValuesFromKeyList_);
}

id objc_msgSend_setVariableMaxValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setVariableMaxValue_);
}

id objc_msgSend_setVariableMinValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setVariableMinValue_);
}

id objc_msgSend_setVersion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setVersion_);
}

id objc_msgSend_setVisible_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setVisible_);
}

id objc_msgSend_setWithArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setWithArray_);
}

id objc_msgSend_setWithObjects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_setWithObjects_);
}

id objc_msgSend_shadowBlendMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shadowBlendMode);
}

id objc_msgSend_shadowColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shadowColor);
}

id objc_msgSend_shadowOpacity(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shadowOpacity);
}

id objc_msgSend_shape(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shape);
}

id objc_msgSend_shapeAtScale_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shapeAtScale_);
}

id objc_msgSend_shapeEffect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shapeEffect);
}

id objc_msgSend_shapeEffectPresetWithName_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shapeEffectPresetWithName_error_);
}

id objc_msgSend_shapeEffectSingleBlurFrom_withInteriorFill_offset_blurSize_innerGlowRed_innerGlowGreen_innerGlowBlue_innerGlowOpacity_innerShadowRed_innerShadowGreen_innerShadowBlue_innerShadowOpacity_outerGlowRed_outerGlowGreen_outerGlowBlue_outerGlowOpacity_outerShadowRed_outerShadowGreen_outerShadowBlue_outerShadowOpacity_hasInsideShadowBlur_hasOutsideShadowBlur_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shapeEffectSingleBlurFrom_withInteriorFill_offset_blurSize_innerGlowRed_innerGlowGreen_innerGlowBlue_innerGlowOpacity_innerShadowRed_innerShadowGreen_innerShadowBlue_innerShadowOpacity_outerGlowRed_outerGlowGreen_outerGlowBlue_outerGlowOpacity_outerShadowRed_outerShadowGreen_outerShadowBlue_outerShadowOpacity_hasInsideShadowBlur_hasOutsideShadowBlur_);
}

id objc_msgSend_sharedCIContext(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sharedCIContext);
}

id objc_msgSend_sharedRuntimeStatistics(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sharedRuntimeStatistics);
}

id objc_msgSend_shouldIgnoreForegroundColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shouldIgnoreForegroundColor);
}

id objc_msgSend_shouldRespectOutputBlending(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_shouldRespectOutputBlending);
}

id objc_msgSend_size(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_size);
}

id objc_msgSend_sizeClassHorizontal(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sizeClassHorizontal);
}

id objc_msgSend_sizeClassVertical(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sizeClassVertical);
}

id objc_msgSend_sizeIndexes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sizeIndexes);
}

id objc_msgSend_sizeValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sizeValue);
}

id objc_msgSend_sizesByIndex(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sizesByIndex);
}

id objc_msgSend_sliceInformation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sliceInformation);
}

id objc_msgSend_sliceRects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sliceRects);
}

id objc_msgSend_smoothingCoefficient(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_smoothingCoefficient);
}

id objc_msgSend_softenSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_softenSize);
}

id objc_msgSend_sortUsingComparator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sortUsingComparator_);
}

id objc_msgSend_sortUsingSelector_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sortUsingSelector_);
}

id objc_msgSend_sortedArrayUsingComparator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sortedArrayUsingComparator_);
}

id objc_msgSend_sortedArrayUsingFunction_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sortedArrayUsingFunction_context_);
}

id objc_msgSend_sortedArrayUsingSelector_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sortedArrayUsingSelector_);
}

id objc_msgSend_sourceAlphaInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sourceAlphaInfo);
}

id objc_msgSend_sourceRowbytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sourceRowbytes);
}

id objc_msgSend_spread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_spread);
}

id objc_msgSend_srcData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_srcData);
}

id objc_msgSend_standardEffectCompositeWithShapeImage_blendOntoImage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_standardEffectCompositeWithShapeImage_blendOntoImage_);
}

id objc_msgSend_standardUserDefaults(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_standardUserDefaults);
}

id objc_msgSend_standardVibrantColorMatrixOptionsForColor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_standardVibrantColorMatrixOptionsForColor_);
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_state);
}

id objc_msgSend_stateLocalizedString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stateLocalizedString);
}

id objc_msgSend_stop(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stop);
}

id objc_msgSend_storageRef(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_storageRef);
}

id objc_msgSend_storageVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_storageVersion);
}

id objc_msgSend_store(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_store);
}

id objc_msgSend_stride(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stride);
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_string);
}

id objc_msgSend_stringByAppendingFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringByAppendingFormat_);
}

id objc_msgSend_stringByAppendingPathComponent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringByAppendingPathComponent_);
}

id objc_msgSend_stringByAppendingString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringByAppendingString_);
}

id objc_msgSend_stringByDeletingPathExtension(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringByDeletingPathExtension);
}

id objc_msgSend_stringByReplacingCharactersInRange_withString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringByReplacingCharactersInRange_withString_);
}

id objc_msgSend_stringByReplacingOccurrencesOfString_withString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringByReplacingOccurrencesOfString_withString_);
}

id objc_msgSend_stringForState_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringForState_);
}

id objc_msgSend_stringForValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringForValue_);
}

id objc_msgSend_stringValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringValue);
}

id objc_msgSend_stringWithCString_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringWithCString_encoding_);
}

id objc_msgSend_stringWithFileSystemRepresentation_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringWithFileSystemRepresentation_length_);
}

id objc_msgSend_stringWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringWithFormat_);
}

id objc_msgSend_stringWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringWithString_);
}

id objc_msgSend_stringWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_stringWithUTF8String_);
}

id objc_msgSend_strokeColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_strokeColor);
}

id objc_msgSend_strokeColorName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_strokeColorName);
}

id objc_msgSend_strokeWidth(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_strokeWidth);
}

id objc_msgSend_strokeWidthForLayerNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_strokeWidthForLayerNamed_);
}

id objc_msgSend_strokeWidthForLayerNamed_inRendition_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_strokeWidthForLayerNamed_inRendition_);
}

id objc_msgSend_styleForLayerName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_styleForLayerName_);
}

id objc_msgSend_styling(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_styling);
}

id objc_msgSend_subarrayWithRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_subarrayWithRange_);
}

id objc_msgSend_sublayerAtIndex_isValid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sublayerAtIndex_isValid_);
}

id objc_msgSend_sublayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_sublayers);
}

id objc_msgSend_submeshKeys(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_submeshKeys);
}

id objc_msgSend_subpathCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_subpathCount);
}

id objc_msgSend_substituteWithSystemColor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_substituteWithSystemColor);
}

id objc_msgSend_substringFromIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_substringFromIndex_);
}

id objc_msgSend_substringToIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_substringToIndex_);
}

id objc_msgSend_subtype(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_subtype);
}

id objc_msgSend_svgDocument(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_svgDocument);
}

id objc_msgSend_swapped(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_swapped);
}

id objc_msgSend_symbolDefaults(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_symbolDefaults);
}

id objc_msgSend_systemColorName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_systemColorName);
}

id objc_msgSend_targetPlatform(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_targetPlatform);
}

id objc_msgSend_templateRenderingMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_templateRenderingMode);
}

id objc_msgSend_templateVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_templateVersion);
}

id objc_msgSend_textStyleWithName_deviceIdiom_deviceSubtype_displayGamut_sizeClassHorizontal_sizeClassVertical_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textStyleWithName_deviceIdiom_deviceSubtype_displayGamut_sizeClassHorizontal_sizeClassVertical_);
}

id objc_msgSend_textStyleWithName_deviceIdiom_deviceSubtype_displayGamut_sizeClassHorizontal_sizeClassVertical_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textStyleWithName_deviceIdiom_deviceSubtype_displayGamut_sizeClassHorizontal_sizeClassVertical_appearanceName_);
}

id objc_msgSend_textStyleWithName_displayGamut_appearanceName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textStyleWithName_displayGamut_appearanceName_);
}

id objc_msgSend_texture2DDescriptorWithPixelFormat_width_height_mipmapped_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_texture2DDescriptorWithPixelFormat_width_height_mipmapped_);
}

id objc_msgSend_textureImages(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textureImages);
}

id objc_msgSend_textureInterpretation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textureInterpretation);
}

id objc_msgSend_textureNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textureNamed_);
}

id objc_msgSend_textureWithBufferAllocator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_textureWithBufferAllocator_);
}

id objc_msgSend_themeAppearance(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeAppearance);
}

id objc_msgSend_themeDeploymentTarget(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeDeploymentTarget);
}

id objc_msgSend_themeDimension1(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeDimension1);
}

id objc_msgSend_themeDimension2(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeDimension2);
}

id objc_msgSend_themeDirection(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeDirection);
}

id objc_msgSend_themeDisplayGamut(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeDisplayGamut);
}

id objc_msgSend_themeElement(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeElement);
}

id objc_msgSend_themeGlyphSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeGlyphSize);
}

id objc_msgSend_themeGlyphWeight(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeGlyphWeight);
}

id objc_msgSend_themeGraphicsClass(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeGraphicsClass);
}

id objc_msgSend_themeIdentifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeIdentifier);
}

id objc_msgSend_themeIdiom(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeIdiom);
}

id objc_msgSend_themeIndex(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeIndex);
}

id objc_msgSend_themeLayer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeLayer);
}

id objc_msgSend_themeLocalization(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeLocalization);
}

id objc_msgSend_themeMemoryClass(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeMemoryClass);
}

id objc_msgSend_themeNamed_forBundleIdentifier_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeNamed_forBundleIdentifier_error_);
}

id objc_msgSend_themePart(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themePart);
}

id objc_msgSend_themeRendition(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeRendition);
}

id objc_msgSend_themeScale(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeScale);
}

id objc_msgSend_themeSchemaLayers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeSchemaLayers);
}

id objc_msgSend_themeSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeSize);
}

id objc_msgSend_themeSizeClassHorizontal(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeSizeClassHorizontal);
}

id objc_msgSend_themeSizeClassVertical(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeSizeClassVertical);
}

id objc_msgSend_themeState(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeState);
}

id objc_msgSend_themeStore(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeStore);
}

id objc_msgSend_themeSubtype(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeSubtype);
}

id objc_msgSend_themeUnregisterThemeRef_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeUnregisterThemeRef_);
}

id objc_msgSend_themeValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeValue);
}

id objc_msgSend_themeWithBytes_length_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeWithBytes_length_error_);
}

id objc_msgSend_themeWithContentsOfURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_themeWithContentsOfURL_error_);
}

id objc_msgSend_thinnedWithCoreUIVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_thinnedWithCoreUIVersion);
}

id objc_msgSend_thinningArguments(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_thinningArguments);
}

id objc_msgSend_thumbnail(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_thumbnail);
}

id objc_msgSend_tileCenterAndEdges(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_tileCenterAndEdges);
}

id objc_msgSend_timeIntervalSince1970(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_timeIntervalSince1970);
}

id objc_msgSend_top(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "top");
}

id objc_msgSend_topLeft(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_topLeft);
}

id objc_msgSend_topRight(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_topRight);
}

id objc_msgSend_transformForGlyphContinuousSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_transformForGlyphContinuousSize_);
}

id objc_msgSend_transformForGlyphSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_transformForGlyphSize_);
}

id objc_msgSend_transformation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_transformation);
}

id objc_msgSend_translateFromWidthsOrHeightsToLeftsOrTops_leftsOrTops_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_translateFromWidthsOrHeightsToLeftsOrTops_leftsOrTops_);
}

id objc_msgSend_type(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_type);
}

id objc_msgSend_ultralightDeltas(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_ultralightDeltas);
}

id objc_msgSend_unarchivedObjectOfClasses_fromData_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_unarchivedObjectOfClasses_fromData_error_);
}

id objc_msgSend_uncroppedImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_uncroppedImage);
}

id objc_msgSend_unlock(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_unlock);
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_unsignedIntegerValue);
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_unsignedShortValue);
}

id objc_msgSend_unslicedImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_unslicedImage);
}

id objc_msgSend_unslicedSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_unslicedSize);
}

id objc_msgSend_updateLayer_effects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_updateLayer_effects_);
}

id objc_msgSend_updateLayerEffectPreset_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_updateLayerEffectPreset_error_);
}

id objc_msgSend_updateOutputBlendingWithInteriorFillHeuristic(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_updateOutputBlendingWithInteriorFillHeuristic);
}

id objc_msgSend_updateRenditionKey_getFocus_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_updateRenditionKey_getFocus_userInfo_);
}

id objc_msgSend_useCoreImageRendering(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_useCoreImageRendering);
}

id objc_msgSend_useSimplifiedEffect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_useSimplifiedEffect);
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_userInfo);
}

id objc_msgSend_usesCUISystemThemeRenditionKey(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_usesCUISystemThemeRenditionKey);
}

id objc_msgSend_utiType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_utiType);
}

id objc_msgSend_value(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_value);
}

id objc_msgSend_valueForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueForKey_);
}

id objc_msgSend_valueForKeyPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueForKeyPath_);
}

id objc_msgSend_valueForParameter_inEffectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueForParameter_inEffectAtIndex_);
}

id objc_msgSend_valueForTokenIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueForTokenIdentifier_);
}

id objc_msgSend_valueLocalizedString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueLocalizedString);
}

id objc_msgSend_valueThreshold(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueThreshold);
}

id objc_msgSend_valueWithBytes_objCType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueWithBytes_objCType_);
}

id objc_msgSend_valueWithCAColorMatrix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueWithCAColorMatrix_);
}

id objc_msgSend_valueWithCGAffineTransform_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueWithCGAffineTransform_);
}

id objc_msgSend_valueWithDeltaScalars_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueWithDeltaScalars_);
}

id objc_msgSend_valueWithPoint_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueWithPoint_);
}

id objc_msgSend_valueWithRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_valueWithRect_);
}

id objc_msgSend_variableMaxValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_variableMaxValue);
}

id objc_msgSend_variableMinValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_variableMinValue);
}

id objc_msgSend_vectorGlyphAlignmentRectInsets(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphAlignmentRectInsets);
}

id objc_msgSend_vectorGlyphAvailableSizes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphAvailableSizes);
}

id objc_msgSend_vectorGlyphBaseline(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphBaseline);
}

id objc_msgSend_vectorGlyphCapLine(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphCapLine);
}

id objc_msgSend_vectorGlyphReferencePointSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphReferencePointSize);
}

id objc_msgSend_vectorGlyphRenderingMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphRenderingMode);
}

id objc_msgSend_vectorGlyphTemplateVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorGlyphTemplateVersion);
}

id objc_msgSend_vectorWithCGRect_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorWithCGRect_);
}

id objc_msgSend_vectorWithX_Y_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorWithX_Y_);
}

id objc_msgSend_vectorWithX_Y_Z_W_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vectorWithX_Y_Z_W_);
}

id objc_msgSend_version(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_version);
}

id objc_msgSend_versionForClassName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_versionForClassName_);
}

id objc_msgSend_vertexAttributeDataForAttributeNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vertexAttributeDataForAttributeNamed_);
}

id objc_msgSend_vertexBuffers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vertexBuffers);
}

id objc_msgSend_vertexCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vertexCount);
}

id objc_msgSend_vertexDescriptor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vertexDescriptor);
}

id objc_msgSend_vibrantColorMatrixOptionsWithColor_saturation_brightness_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_vibrantColorMatrixOptionsWithColor_saturation_brightness_);
}

id objc_msgSend_visible(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_visible);
}

id objc_msgSend_whitespaceCharacterSet(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_whitespaceCharacterSet);
}

id objc_msgSend_width(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_width);
}

id objc_msgSend_workingFormat(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_workingFormat);
}

id objc_msgSend_writeToData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_writeToData_);
}

id objc_msgSend_writeToDiskAndCompact_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_writeToDiskAndCompact_);
}
