uint64_t CFRetainedFinalize(_QWORD *a1)
{
  uint64_t result;

  result = a1[2];
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void SVGAttribute::~SVGAttribute(SVGAttribute *this)
{
  SVGAttribute::~SVGAttribute(this);
  JUMPOUT(0x20BCFC038);
}

{
  unsigned int v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;

  *(_QWORD *)this = &off_24BFD8C08;
  v2 = *((_DWORD *)this + 20);
  if (v2 <= 8)
  {
    if (((1 << v2) & 0x1D8) != 0)
    {
      CFRetained::release(*((_QWORD *)this + 11));
    }
    else if (v2 == 1)
    {
      v5 = *((_QWORD *)this + 11);
      if (v5)
      {
        v6 = *(void **)v5;
        if (*(_QWORD *)v5)
        {
          *(_QWORD *)(v5 + 8) = v6;
          operator delete(v6);
        }
        MEMORY[0x20BCFC038](v5, 0x80C40D6874129);
      }
    }
  }
  v3 = *((_QWORD *)this + 12);
  if (v3)
  {
    v4 = *(void **)v3;
    if (*(_QWORD *)v3)
    {
      *(_QWORD *)(v3 + 8) = v4;
      operator delete(v4);
    }
    MEMORY[0x20BCFC038](v3, 0x20C40960023A9);
  }
  if (*((char *)this + 79) < 0)
    operator delete(*((void **)this + 7));
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

void SVGPaint::~SVGPaint(SVGPaint *this)
{
  *(_QWORD *)this = &off_24BFD8EA8;
  CFRetained::release(*((_QWORD *)this + 13));
  CFRetained::release(*((_QWORD *)this + 14));
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  SVGPaint::~SVGPaint(this);
  JUMPOUT(0x20BCFC038);
}

void CFRetained::release(uint64_t a1)
{
  if (a1)
    CFRelease(*(CFTypeRef *)(a1 + 40));
}

void SVGStyle::addDefinitionsFromCSS(uint64_t **this, SVGParser *a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  SVGAttributeMap *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t **v10;
  uint64_t *v11;
  SVGAttributeMap *v12;
  uint64_t v13;
  _QWORD v14[5];
  std::string v15;
  SVGAttributeMap *v16;
  _QWORD v17[5];
  std::string v18;
  std::string v19;
  std::string v20;
  __int128 *v21;
  __int128 *v22;
  std::string v23;
  uint64_t v24[3];
  std::string v25;
  uint64_t v26;
  uint64_t v27;

  SVGParser::ParseRulesetList(a2, &v26);
  v3 = v26;
  v13 = v27;
  if (v26 != v27)
  {
    v4 = MEMORY[0x24BDAC760];
    do
    {
      if (*(char *)(v3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v25, *(const std::string::value_type **)v3, *(_QWORD *)(v3 + 8));
      }
      else
      {
        v5 = *(_OWORD *)v3;
        v25.__r_.__value_.__r.__words[2] = *(_QWORD *)(v3 + 16);
        *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v5;
      }
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v23, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
      else
        v23 = v25;
      SVGParser::ParseSelectorListFromRuleset((char *)&v23, v24);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v23.__r_.__value_.__l.__data_);
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v20, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
      else
        v20 = v25;
      SVGParser::ParseDeclarationBlockFromRuleset((char *)&v20, 0, (uint64_t *)&v21);
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v20.__r_.__value_.__l.__data_);
      v6 = (SVGAttributeMap *)operator new();
      SVGAttributeMap::SVGAttributeMap(v6);
      memset(&v19, 0, sizeof(v19));
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v19, v21, v22, 0xAAAAAAAAAAAAAAABLL * (((char *)v22 - (char *)v21) >> 3));
      SVGParser::ParseDeclarationBlockIntoAttributeMap((__int128 **)&v19, (uint64_t)v6);
      v15.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
      v7 = v24[0];
      v8 = v24[1];
      while (v7 != v8)
      {
        if (*(char *)(v7 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)v7, *(_QWORD *)(v7 + 8));
        }
        else
        {
          v9 = *(_OWORD *)v7;
          v18.__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 16);
          *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v9;
        }
        v10 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::find<std::string>((uint64_t)this, (uint64_t)&v18);
        if (this + 1 == v10)
        {
          v12 = (SVGAttributeMap *)operator new();
          SVGAttributeMap::SVGAttributeMap(v12, v6);
          if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&v15, v18.__r_.__value_.__l.__data_, v18.__r_.__value_.__l.__size_);
          else
            v15 = v18;
          v16 = v12;
          std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGAttributeMap *>>(this, (uint64_t)&v15, (uint64_t)&v15);
          if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v15.__r_.__value_.__l.__data_);
        }
        else
        {
          v11 = v10[7];
          v17[0] = v4;
          v17[1] = 0x40000000;
          v17[2] = ___ZN8SVGStyle21addDefinitionsFromCSSEPKc_block_invoke;
          v17[3] = &__block_descriptor_tmp_4;
          v17[4] = v11;
          SVGAttributeMap::enumerate((uint64_t)v6, (uint64_t)v17);
        }
        if (!*((_BYTE *)this + 24))
        {
          v14[0] = v4;
          v14[1] = 0x40000000;
          v14[2] = ___ZN8SVGStyle21addDefinitionsFromCSSEPKc_block_invoke_2;
          v14[3] = &__block_descriptor_tmp_2;
          v14[4] = this;
          SVGAttributeMap::enumerate((uint64_t)v6, (uint64_t)v14);
        }
        if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v18.__r_.__value_.__l.__data_);
        v7 += 24;
      }
      CFRetained::release((CFTypeRef *)v6);
      v15.__r_.__value_.__r.__words[0] = (std::string::size_type)&v21;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
      v15.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v25.__r_.__value_.__l.__data_);
      v3 += 24;
    }
    while (v3 != v13);
  }
  v15.__r_.__value_.__r.__words[0] = (std::string::size_type)&v26;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
}

void sub_20676AB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43)
{
  uint64_t v43;

  a15 = (void *)(v43 - 184);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  if (*(char *)(v43 - 137) < 0)
    operator delete(*(void **)(v43 - 160));
  a15 = (void *)(v43 - 136);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::find<std::string>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, (uint64_t)(v3 + 4), a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v6 == v2
    || std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, a2, (uint64_t)(v6 + 4)))
  {
    return v2;
  }
  return v6;
}

void SVGAttributeMap::SVGAttributeMap(SVGAttributeMap *this, const SVGAttributeMap *a2)
{
  uint64_t v4;
  _QWORD v5[5];
  void *__p[2];
  char v7;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttributeMap::kSVGAttributeMapClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v7 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8CF8;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 6) = (char *)this + 56;
  v4 = MEMORY[0x24BDAC760];
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v5[0] = v4;
  v5[1] = 0x40000000;
  v5[2] = ___ZN15SVGAttributeMapC2ERKS__block_invoke;
  v5[3] = &__block_descriptor_tmp_0;
  v5[4] = this;
  SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v5);
}

void sub_20676AD94(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::destroy(v2, *(_QWORD **)(v1 + 56));
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void SVGParser::ParseDeclarationBlockFromRuleset(char *__s@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  char *v4;
  int64_t v6;
  char *v7;
  char *v8;
  char *v9;
  int64_t v10;
  char *v11;
  int64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  char *v16;
  int64_t v17;
  size_t v18;
  char *v19;
  size_t v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  __int128 v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  int v28;
  void *__p[2];
  uint64_t v30;

  v4 = __s;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (__s[23] < 0)
    v4 = *(char **)__s;
  v6 = strlen(v4);
  if (v6)
  {
    v7 = &v4[v6];
    if ((a2 & 1) == 0)
    {
      v8 = v4;
      if (v6 >= 1)
      {
        do
        {
          if (*v8 == 123)
            break;
          ++v8;
        }
        while (v8 < v7);
      }
      v9 = v8 + 1;
      if (v8 + 1 >= v7)
        return;
      v10 = &v4[v6] - v8;
      v11 = &v4[v6];
      v12 = v10 - 1;
      v7 = v9;
      while (*v7 != 125)
      {
        ++v7;
        if (!--v12)
        {
          v4 = v9;
          v7 = v11;
          goto LABEL_14;
        }
      }
      v4 = v9;
    }
LABEL_14:
    if (v4 < v7)
    {
      v13 = MEMORY[0x24BDAC740];
      do
      {
        do
        {
          v14 = *v4;
          if ((v14 & 0x80000000) != 0)
            v15 = __maskrune(v14, 0x4000uLL);
          else
            v15 = *(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000;
          if (!v15)
            break;
          ++v4;
        }
        while (v4 < v7);
        v16 = v4;
        if (v4 < v7)
        {
          v17 = v7 - v4;
          v16 = v4;
          while (*v16 != 59)
          {
            ++v16;
            if (!--v17)
            {
              v16 = v7;
              break;
            }
          }
        }
        v18 = v16 - v4;
        v19 = v16 - 1;
        do
        {
          v20 = v18;
          if (v19 <= v4)
            break;
          v21 = *v19;
          v22 = (v21 & 0x80000000) != 0 ? __maskrune(v21, 0x4000uLL) : *(_DWORD *)(v13 + 4 * v21 + 60) & 0x4000;
          v18 = v20 - 1;
          --v19;
        }
        while (v22);
        if ((uint64_t)(v20 - 1) < -1)
          break;
        std::string::basic_string[abi:ne180100](__p, v4, v20);
        v23 = a3[1];
        if (v23 >= a3[2])
        {
          v25 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a3, (__int128 *)__p);
        }
        else
        {
          if (SHIBYTE(v30) < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)a3[1], (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
          }
          else
          {
            v24 = *(_OWORD *)__p;
            *(_QWORD *)(v23 + 16) = v30;
            *(_OWORD *)v23 = v24;
          }
          v25 = v23 + 24;
          a3[1] = v23 + 24;
        }
        a3[1] = v25;
        v26 = v16 + 1;
        do
        {
          v4 = v26;
          if (v26 >= v7)
            break;
          v27 = *v26;
          v28 = (v27 & 0x80000000) != 0 ? __maskrune(v27, 0x4000uLL) : *(_DWORD *)(v13 + 4 * v27 + 60) & 0x4000;
          v26 = v4 + 1;
        }
        while (v28);
        if (SHIBYTE(v30) < 0)
          operator delete(__p[0]);
      }
      while (v4 < v7);
    }
  }
}

void sub_20676B024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _QWORD *v15;
  uint64_t v16;

  v15[1] = v16;
  if (a15 < 0)
    operator delete(__p);
  __p = v15;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void SVGParser::ParseDeclarationBlockIntoAttributeMap(__int128 **a1, uint64_t a2)
{
  __int128 *v2;
  __int128 *v3;
  uint64_t v5;
  __int128 v6;
  std::string *v7;
  int64_t v8;
  int64_t v9;
  std::string *v10;
  std::string *v11;
  unsigned int v12;
  int v13;
  int64_t v14;
  int v15;
  const char *v16;
  unint64_t v17;
  std::string::size_type size;
  char v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  CFTypeRef *v23;
  std::string *p_p;
  std::string v25;
  std::string v26;
  std::string __p;
  void *__dst[2];
  unsigned __int8 v29;
  std::string v30;

  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    v5 = MEMORY[0x24BDAC740];
    while (1)
    {
      if (*((char *)v2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
      }
      else
      {
        v6 = *v2;
        v30.__r_.__value_.__r.__words[2] = *((_QWORD *)v2 + 2);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v6;
      }
      if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v7 = &v30;
      else
        v7 = (std::string *)v30.__r_.__value_.__r.__words[0];
      v8 = strlen((const char *)v7);
      if (!v8)
      {
        v15 = 2;
        if ((*((_BYTE *)&v30.__r_.__value_.__s + 23) & 0x80) == 0)
          goto LABEL_54;
        goto LABEL_53;
      }
      v9 = v8;
      v10 = (std::string *)((char *)v7 + v8);
      v11 = v7;
      if (v8 >= 1)
      {
        do
        {
          v12 = v11->__r_.__value_.__s.__data_[0];
          if ((v12 & 0x80000000) != 0)
            v13 = __maskrune(v12, 0x4000uLL);
          else
            v13 = *(_DWORD *)(v5 + 4 * v12 + 60) & 0x4000;
          if (v13)
            break;
          if (v11->__r_.__value_.__s.__data_[0] == 58)
            break;
          v11 = (std::string *)((char *)v11 + 1);
        }
        while (v11 < v10);
      }
      std::string::basic_string[abi:ne180100](__dst, v7, (char *)v11 - (char *)v7);
      if (v11 >= v10)
      {
LABEL_22:
        if (!v11->__r_.__value_.__s.__data_[0])
        {
          v15 = 1;
          goto LABEL_50;
        }
      }
      else
      {
        v14 = (char *)v7 + v9 - (char *)v11;
        while (v11->__r_.__value_.__s.__data_[0] != 58)
        {
          v11 = (std::string *)((char *)v11 + 1);
          if (!--v14)
          {
            v11 = (std::string *)((char *)v7 + v9);
            goto LABEL_22;
          }
        }
      }
      std::string::basic_string[abi:ne180100](&__p, (char *)&v11->__r_.__value_.__l.__data_ + 1, (size_t)v10 + ~(unint64_t)v11);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v25, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      else
        v25 = __p;
      SVGParser::StripLeadingTrailingWhitespace(&v25, &v26);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      __p = v26;
      *((_BYTE *)&v26.__r_.__value_.__s + 23) = 0;
      v26.__r_.__value_.__s.__data_[0] = 0;
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v25.__r_.__value_.__l.__data_);
      if ((v29 & 0x80u) == 0)
        v17 = v29;
      else
        v17 = (unint64_t)__dst[1];
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      v19 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if (v17)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = __p.__r_.__value_.__l.__size_;
        if (size)
        {
          if ((v29 & 0x80u) == 0)
            v20 = __dst;
          else
            v20 = (void **)__dst[0];
          v21 = SVGAtom::ToName((SVGAtom *)v20, v16);
          v22 = operator new();
          v23 = (CFTypeRef *)v22;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_p = &__p;
          else
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          SVGAttribute::SVGAttribute(v22, v21, p_p);
          SVGAttributeMap::setAttribute(a2, (uint64_t)v23, 0);
          CFRetained::release(v23);
          v19 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
      }
      if (v19 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v15 = 0;
LABEL_50:
      if ((char)v29 < 0)
        operator delete(__dst[0]);
      if ((*((_BYTE *)&v30.__r_.__value_.__s + 23) & 0x80) == 0)
        goto LABEL_54;
LABEL_53:
      operator delete(v30.__r_.__value_.__l.__data_);
LABEL_54:
      if (!v15)
      {
        v2 = (__int128 *)((char *)v2 + 24);
        if (v2 != v3)
          continue;
      }
      return;
    }
  }
}

void sub_20676B3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  MEMORY[0x20BCFC038](v35, 0x10B3C405B4D0908);
  if (a23 < 0)
    operator delete(__p);
  if (a29 < 0)
    operator delete(a24);
  if (a35 < 0)
    operator delete(a30);
  _Unwind_Resume(a1);
}

std::string *SVGParser::StripLeadingTrailingWhitespace@<X0>(std::string *this@<X0>, std::string *a2@<X8>)
{
  std::string *v2;
  std::string::size_type size;
  std::string::size_type v5;
  uint64_t v6;
  unsigned int v7;
  std::string::size_type v8;
  unsigned int v9;
  int v10;
  char v11;

  v2 = this;
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    if (*((_BYTE *)&this->__r_.__value_.__s + 23))
      goto LABEL_3;
LABEL_13:
    *a2 = *this;
    *(_OWORD *)&this->__r_.__value_.__r.__words[1] = 0uLL;
    this->__r_.__value_.__r.__words[0] = 0;
    return this;
  }
  size = this->__r_.__value_.__l.__size_;
  if (!size)
    goto LABEL_13;
LABEL_3:
  v5 = 0;
  v6 = MEMORY[0x24BDAC740];
  do
  {
    v7 = *std::string::at(v2, v5);
    if ((v7 & 0x80000000) != 0)
    {
      if (!__maskrune(v7, 0x4000uLL))
        goto LABEL_10;
    }
    else if ((*(_DWORD *)(v6 + 4 * v7 + 60) & 0x4000) == 0)
    {
      goto LABEL_10;
    }
    ++v5;
  }
  while (size != v5);
  v5 = size;
LABEL_10:
  if (v5 > size - 1)
    return (std::string *)std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_20679A6BE);
  v8 = size + 1;
  do
  {
    v9 = *std::string::at(v2, v8 - 2);
    if ((v9 & 0x80000000) != 0)
      v10 = __maskrune(v9, 0x4000uLL);
    else
      v10 = *(_DWORD *)(v6 + 4 * v9 + 60) & 0x4000;
    --v8;
  }
  while (v10);
  return std::string::basic_string(a2, v2, v5, v8 - v5, (std::allocator<char> *)&v11);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, uint64_t a3)
{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  MEMORY[0x20BCFBFCC](a1 + 56, a3);
  return a1;
}

{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 3;
  *(_QWORD *)(a1 + 88) = a3;
  CFRetained::retain(a3);
  return a1;
}

{
  _QWORD *v6;
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  v6 = (_QWORD *)operator new();
  *v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v6, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  *(_QWORD *)(a1 + 88) = v6;
  return a1;
}

{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 4;
  *(_QWORD *)(a1 + 88) = a3;
  CFRetained::retain(a3);
  return a1;
}

{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 7;
  *(_QWORD *)(a1 + 88) = a3;
  CFRetained::retain(a3);
  return a1;
}

{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 6;
  *(_QWORD *)(a1 + 88) = a3;
  CFRetained::retain(a3);
  return a1;
}

{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  void *__p[2];
  char v35;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v35 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  v6 = (_QWORD *)operator new();
  *v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  *(_QWORD *)(a1 + 88) = v6;
  v7 = *(_QWORD **)a3;
  v8 = *(_QWORD **)(a3 + 8);
  if (*(_QWORD **)a3 != v8)
  {
    do
    {
      v9 = *(_QWORD *)(a1 + 88);
      v10 = *(_QWORD **)(v9 + 8);
      v11 = *(_QWORD *)(v9 + 16);
      if ((unint64_t)v10 >= v11)
      {
        v13 = *(_QWORD **)v9;
        v14 = ((uint64_t)v10 - *(_QWORD *)v9) >> 3;
        v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61)
          goto LABEL_38;
        v16 = v11 - (_QWORD)v13;
        if (v16 >> 2 > v15)
          v15 = v16 >> 2;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v15;
        if (v17)
        {
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v9 + 16, v17);
          v13 = *(_QWORD **)v9;
          v10 = *(_QWORD **)(v9 + 8);
        }
        else
        {
          v18 = 0;
        }
        v19 = &v18[8 * v14];
        *(_QWORD *)v19 = *v7;
        v12 = v19 + 8;
        while (v10 != v13)
        {
          v20 = *--v10;
          *((_QWORD *)v19 - 1) = v20;
          v19 -= 8;
        }
        *(_QWORD *)v9 = v19;
        *(_QWORD *)(v9 + 8) = v12;
        *(_QWORD *)(v9 + 16) = &v18[8 * v17];
        if (v13)
          operator delete(v13);
      }
      else
      {
        *v10 = *v7;
        v12 = v10 + 1;
      }
      *(_QWORD *)(v9 + 8) = v12;
      v21 = *(_QWORD *)(a1 + 88);
      v22 = *(_QWORD **)(v21 + 8);
      v23 = *(_QWORD *)(v21 + 16);
      if ((unint64_t)v22 >= v23)
      {
        v25 = *(_QWORD **)v21;
        v26 = ((uint64_t)v22 - *(_QWORD *)v21) >> 3;
        v27 = v26 + 1;
        if ((unint64_t)(v26 + 1) >> 61)
LABEL_38:
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v28 = v23 - (_QWORD)v25;
        if (v28 >> 2 > v27)
          v27 = v28 >> 2;
        if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
          v29 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v29 = v27;
        if (v29)
        {
          v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v21 + 16, v29);
          v25 = *(_QWORD **)v21;
          v22 = *(_QWORD **)(v21 + 8);
        }
        else
        {
          v30 = 0;
        }
        v31 = &v30[8 * v26];
        *(_QWORD *)v31 = v7[1];
        v24 = v31 + 8;
        while (v22 != v25)
        {
          v32 = *--v22;
          *((_QWORD *)v31 - 1) = v32;
          v31 -= 8;
        }
        *(_QWORD *)v21 = v31;
        *(_QWORD *)(v21 + 8) = v24;
        *(_QWORD *)(v21 + 16) = &v30[8 * v29];
        if (v25)
          operator delete(v25);
      }
      else
      {
        *v22 = v7[1];
        v24 = v22 + 1;
      }
      *(_QWORD *)(v21 + 8) = v24;
      v7 += 2;
    }
    while (v7 != v8);
  }
  return a1;
}

{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 8;
  *(_QWORD *)(a1 + 88) = a3;
  CFRetained::retain(a3);
  return a1;
}

void sub_20676B61C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void SVGParser::ParseSelectorListFromRuleset(char *__s@<X0>, uint64_t *a2@<X8>)
{
  char *v2;
  size_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  int v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  int64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  void *__p[2];
  uint64_t v21;

  v2 = __s;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (__s[23] < 0)
    v2 = *(char **)__s;
  v4 = strlen(v2);
  if (v4)
  {
    v5 = &v2[v4];
    v6 = &v2[v4];
    v7 = MEMORY[0x24BDAC740];
    do
    {
      if (v2 >= v5)
        break;
      v8 = 0;
      v9 = v2;
      while (1)
      {
        v10 = v2[v8];
        if ((v10 & 0x80000000) != 0 ? __maskrune(v10, 0x4000uLL) : *(_DWORD *)(v7 + 4 * v10 + 60) & 0x4000)
          break;
        v12 = v2[v8];
        if (v12 == 44 || v12 == 123)
        {
          v9 = &v2[v8];
          break;
        }
        ++v9;
        if (v6 - v2 == ++v8)
        {
          v9 = v6;
          break;
        }
      }
      std::string::basic_string[abi:ne180100](__p, v2, v9 - v2);
      v13 = a2[1];
      if (v13 >= a2[2])
      {
        v15 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (__int128 *)__p);
      }
      else
      {
        if (SHIBYTE(v21) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)a2[1], (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
        }
        else
        {
          v14 = *(_OWORD *)__p;
          *(_QWORD *)(v13 + 16) = v21;
          *(_OWORD *)v13 = v14;
        }
        v15 = v13 + 24;
        a2[1] = v13 + 24;
      }
      a2[1] = v15;
      if (v9 < v5)
      {
        v16 = v6 - v9;
        do
        {
          v17 = *v9;
          if ((v17 & 0x80000000) != 0)
            v18 = __maskrune(v17, 0x4000uLL);
          else
            v18 = *(_DWORD *)(v7 + 4 * v17 + 60) & 0x4000;
          v19 = *v9;
          if (v18)
          {
            if (v19 == 123)
              goto LABEL_34;
          }
          else if (v19 != 44)
          {
            goto LABEL_34;
          }
          ++v9;
          --v16;
        }
        while (v16);
        v9 = v6;
      }
      v19 = *v9;
LABEL_34:
      v2 = v9;
      if (SHIBYTE(v21) < 0)
        operator delete(__p[0]);
    }
    while (v19 != 123);
  }
}

void sub_20676B824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;

  v17 = v16;
  v15[1] = v17;
  if (a15 < 0)
    operator delete(__p);
  __p = v15;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void SVGReader::parseXMLNodeAttributes(SVGReader *this, _xmlNode *a2, SVGAttributeMap *a3)
{
  _xmlAttr *i;
  SVGReader *v7;
  uint64_t v8;
  int v9;
  std::string __p;

  for (i = a2->properties; i; i = i->next)
  {
    v7 = (SVGReader *)SVGAtom::ToName((SVGAtom *)i->name, (const char *)a2);
    v9 = (int)v7;
    if (*(_QWORD *)this && *(_BYTE *)(*(_QWORD *)this + 8) && v7 >= 0x9F)
    {
      SVGReader::report(v7, (SVGParser *)"Attribute: '%s' is not allowed in strict mode", a2->line, v8, i->name);
    }
    else if ((_DWORD)v7)
    {
      std::string::basic_string[abi:ne180100]<0>(&__p, (char *)i->children->content);
      SVGAttributeMap::setAttribute((uint64_t)a3, v9, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_20676B930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGAtom::ToName(SVGAtom *this, const char *a2)
{
  if (SVGAtom::SharedInstance(void)::onceToken != -1)
    dispatch_once(&SVGAtom::SharedInstance(void)::onceToken, &__block_literal_global);
  return SVGAtom::toName((os_unfair_lock_s *)SVGAtom::SharedInstance(void)::instance, (char *)this);
}

void SVGAttributeMap::setAttribute(uint64_t a1, int a2, const std::string *a3)
{
  uint64_t v6;

  v6 = operator new();
  SVGAttribute::SVGAttribute(v6, a2, a3);
  SVGAttributeMap::setAttribute(a1, v6, 1);
}

void sub_20676B9FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, const std::string *a3)
{
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  std::string::operator=((std::string *)(a1 + 56), a3);
  return a1;
}

void sub_20676BAB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

SVGPath *SVGParser::ParseCommandList(SVGParser *this, const char *a2)
{
  char *v2;
  SVGPath *v3;
  char v4;
  char *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef *v10;
  _BOOL4 v11;
  _BOOL4 v12;
  int v13;
  const char *v14;
  void *__p;
  void *v17;
  uint64_t v18;
  char *v19;

  v2 = (char *)this;
  v19 = (char *)this;
  v3 = (SVGPath *)operator new();
  SVGPath::SVGPath(v3);
  while (1)
  {
    if (SVGParser::IsAllowedSeparator((SVGParser *)*v2))
    {
      do
      {
        v5 = v19;
        if (!*v19)
          break;
        ++v19;
      }
      while (SVGParser::IsAllowedSeparator((SVGParser *)v5[1]));
    }
    if (!*v19)
      break;
    v6 = SVGPathCommand::TypeFromCharacter((SVGPathCommand *)*v19, v4);
    if (!(_DWORD)v6)
    {
      SVGUtilities::log((SVGUtilities *)"Malformed path detected", v7);
      return v3;
    }
    v8 = v6;
    ++v19;
    v9 = SVGPathCommand::ExpectedFloatCount(v6);
    v10 = (CFTypeRef *)operator new();
    SVGPathCommand::SVGPathCommand(v10, v8);
    if (v9)
    {
      __p = 0;
      v17 = 0;
      v18 = 0;
      v11 = (v8 & 0xFFFFFFDF) == 0x41
          ? SVGParser::ParseCGFloatListEllipticalArcCurve(v19, &v19, (uint64_t)&__p)
          : SVGParser::ParseCGFloatList(v19, &v19, (uint64_t)&__p);
      v12 = v11;
      if (v11)
      {
        SVGPathCommand::appendFloats((uint64_t)v10, (char **)&__p);
      }
      else
      {
        v13 = SVGPathCommand::CharacterFromType(v8);
        SVGUtilities::error((SVGUtilities *)"Failed to parse SVGVectors list for command: %c\n", v14, v13);
        CFRetained::release((CFTypeRef *)v3);
        CFRetained::release(v10);
      }
      if (__p)
      {
        v17 = __p;
        operator delete(__p);
      }
      if (!v12)
        return 0;
    }
    SVGPath::addCommand(v3, (SVGPathCommand *)v10);
    CFRetained::release(v10);
    v2 = v19;
  }
  return v3;
}

void sub_20676BCA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  uint64_t v12;

  MEMORY[0x20BCFC038](v12, 0x10F3C40176D6E88);
  _Unwind_Resume(a1);
}

uint64_t CFRetained::retain(uint64_t a1)
{
  if (a1)
    CFRetain(*(CFTypeRef *)(a1 + 40));
  return a1;
}

BOOL SVGParser::ParseCGFloatList(char *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v20;
  char *v21;

  v3 = 0;
  if (a1 && a3)
  {
    v21 = a1;
    v6 = MEMORY[0x24BDAC740];
    while (1)
    {
      if (SVGParser::IsAllowedSeparator((SVGParser *)*a1))
      {
        do
          ++v21;
        while (SVGParser::IsAllowedSeparator((SVGParser *)*v21));
      }
      v7 = *v21;
      if ((v7 - 45) >= 2
        && (_DWORD)v7 != 43
        && (!*v21 || (v7 & 0x80) != 0 || (*(_DWORD *)(v6 + 4 * v7 + 60) & 0x400) == 0))
      {
        break;
      }
      v20 = 0;
      if (!SVGParser::ParseCGFloat(v21, (double *)&v20, &v21, 0))
        break;
      v9 = *(_QWORD **)(a3 + 8);
      v8 = *(_QWORD *)(a3 + 16);
      if ((unint64_t)v9 >= v8)
      {
        v11 = *(_QWORD **)a3;
        v12 = ((uint64_t)v9 - *(_QWORD *)a3) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v14 = v8 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a3 + 16, v15);
          v11 = *(_QWORD **)a3;
          v9 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v20;
        v10 = v17 + 8;
        while (v9 != v11)
        {
          v18 = *--v9;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        *(_QWORD *)a3 = v17;
        *(_QWORD *)(a3 + 8) = v10;
        *(_QWORD *)(a3 + 16) = &v16[8 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v9 = v20;
        v10 = v9 + 1;
      }
      *(_QWORD *)(a3 + 8) = v10;
      a1 = v21;
    }
    if (a2)
      *a2 = v21;
    return *(_QWORD *)(a3 + 8) != *(_QWORD *)a3;
  }
  return v3;
}

BOOL SVGParser::IsAllowedSeparator(SVGParser *this)
{
  int v2;

  if ((_DWORD)this == 44)
    return 1;
  if ((this & 0x80000000) != 0)
    v2 = __maskrune((__darwin_ct_rune_t)this, 0x4000uLL);
  else
    v2 = *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * this + 60) & 0x4000;
  return v2 != 0;
}

BOOL SVGParser::ParseCGFloat(const char *a1, double *a2, char **a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  _BOOL8 result;
  double v12;
  char *v13;
  double v14;
  char *v15;

  v8 = MEMORY[0x24BDAC740];
  while (1)
  {
    v9 = *(unsigned __int8 *)a1;
    v10 = v9 > 0x2E || ((1 << v9) & 0x680000000000) == 0;
    if (!v10 || (v9 & 0x80) == 0 && (*(_DWORD *)(v8 + 4 * v9 + 60) & 0x400) != 0)
      break;
    result = SVGParser::IsAllowedSeparator((SVGParser *)(char)v9);
    if (!result)
      return result;
    ++a1;
  }
  *__error() = 0;
  v15 = 0;
  if (GetLocaleC(void)::onceToken != -1)
    dispatch_once(&GetLocaleC(void)::onceToken, &__block_literal_global_2);
  v12 = strtod_l(a1, &v15, (locale_t)GetLocaleC(void)::localeC);
  v13 = v15;
  if (a1 == v15)
    return 0;
  v14 = v12;
  if (a4)
  {
    *a4 = 1;
    while (a1 <= v13)
    {
      if (*a1 == 46)
      {
        *a4 = 0;
        break;
      }
      ++a1;
    }
  }
  if (a3)
    *a3 = v13;
  if (*__error())
    return 0;
  *a2 = v14;
  return 1;
}

void SVGAttributeMap::~SVGAttributeMap(SVGAttributeMap *this)
{
  SVGAttributeMap::~SVGAttributeMap(this);
  JUMPOUT(0x20BCFC038);
}

{
  *(_QWORD *)this = &off_24BFD8CF8;
  SVGAttributeMap::enumerate((uint64_t)this, (uint64_t)&__block_literal_global_0);
  std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::destroy((uint64_t)this + 48, *((_QWORD **)this + 7));
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

void std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t SVGAttributeMap::enumerate(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  char v8;

  v8 = 0;
  v2 = *(_QWORD **)(result + 48);
  v3 = (_QWORD *)(result + 56);
  if (v2 != (_QWORD *)(result + 56))
  {
    do
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, char *))(a2 + 16))(a2, *((unsigned int *)v2 + 8), v2[5], &v8);
      if (v8)
        break;
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void CFRetained::release(CFTypeRef *this)
{
  CFRelease(this[5]);
}

void ___ZN14SVGViewBoxNode17updatedAttributesEP15SVGAttributeMap_block_invoke(uint64_t a1, unsigned int a2, os_unfair_lock_s *a3)
{
  uint64_t v5;
  uint64_t v6;
  double *v7;
  _QWORD *v8;
  const char *v9;

  v5 = *(_QWORD *)(a1 + 32);
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 64))(v5) & 1) == 0)
  {
    switch(a2)
    {
      case 'A':
        if ((SVGAttribute::rectValue(a3, (CGRect *)(v5 + 232)) & 1) == 0)
          goto LABEL_14;
        return;
      case 'B':
        v7 = (double *)(v5 + 216);
        goto LABEL_13;
      case 'C':
        v7 = (double *)(v5 + 200);
        goto LABEL_13;
      case 'D':
      case 'E':
        return;
      case 'F':
        v7 = (double *)(v5 + 208);
        goto LABEL_13;
      default:
        if (a2 != 30)
        {
          if (a2 != 46)
            return;
          v6 = SVGAttribute::stringValue((SVGAttribute *)a3);
          if (SVGViewBoxNode::ParseAspectRatio(v5, v6))
            return;
LABEL_14:
          v8 = SVGAtom::ToString(a2);
          SVGUtilities::log((SVGUtilities *)"Failed to parse %s for node name \"svg\"", v9, v8);
          return;
        }
        v7 = (double *)(v5 + 224);
LABEL_13:
        if ((SVGAttribute::floatValue(a3, v7) & 1) == 0)
          goto LABEL_14;
        break;
    }
  }
}

uint64_t SVGViewBoxNode::updatedSpecificAttribute()
{
  return 0;
}

void ___ZN15SVGAttributeMapD2Ev_block_invoke(int a1, int a2, CFTypeRef *this)
{
  if (this)
    CFRetained::release(this);
}

uint64_t SVGPath::addCommand(SVGPath *this, SVGPathCommand *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = *((_QWORD *)this + 8);
  v4 = (char *)this + 64;
  v5 = v6;
  v7 = (_QWORD *)*((_QWORD *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (void **)(v4 - 16);
    v10 = *((_QWORD *)v4 - 2);
    v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v12 = v5 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = a2;
    v8 = v16 + 8;
    v19 = (char *)*((_QWORD *)this + 6);
    v18 = (char *)*((_QWORD *)this + 7);
    if (v18 != v19)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = (char *)*v9;
    }
    *((_QWORD *)this + 6) = v16;
    *((_QWORD *)this + 7) = v8;
    *((_QWORD *)this + 8) = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  *((_QWORD *)this + 7) = v8;
  return CFRetained::retain((uint64_t)a2);
}

uint64_t SVGPathCommand::SVGPathCommand(uint64_t a1, int a2)
{
  _QWORD *v4;
  void *__p[2];
  char v7;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPathCommand::kSVGPathCommandClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v7 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C78;
  *(_DWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 56) = 0;
  if (SVGPathCommand::ExpectedFloatCount(a2))
  {
    v4 = (_QWORD *)operator new();
    *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    *(_QWORD *)(a1 + 56) = v4;
  }
  return a1;
}

void sub_20676C43C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t SVGPathCommand::ExpectedFloatCount(int a1)
{
  uint64_t result;

  result = 0;
  switch(a1)
  {
    case 'A':
LABEL_7:
      result = 7;
      break;
    case 'B':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'I':
    case 'J':
    case 'K':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'U':
      return result;
    case 'C':
LABEL_8:
      result = 6;
      break;
    case 'H':
    case 'V':
LABEL_5:
      result = 1;
      break;
    case 'L':
    case 'M':
    case 'T':
LABEL_4:
      result = 2;
      break;
    case 'Q':
    case 'S':
LABEL_6:
      result = 4;
      break;
    default:
      switch(a1)
      {
        case 'a':
          goto LABEL_7;
        case 'c':
          goto LABEL_8;
        case 'h':
        case 'v':
          goto LABEL_5;
        case 'l':
        case 'm':
        case 't':
          goto LABEL_4;
        case 'q':
        case 's':
          goto LABEL_6;
        default:
          return result;
      }
  }
  return result;
}

char *SVGPathCommand::appendFloats(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 56);
  if (!v4)
    SVGPathCommand::appendFloats();
  return std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<double const*>,std::__wrap_iter<double const*>>(v4, *(_QWORD *)(v4 + 8), a3, a4, (a4 - a3) >> 3);
}

char *SVGPathCommand::appendFloats(uint64_t a1, char **a2)
{
  return SVGPathCommand::appendFloats(a1, (uint64_t)a2, *a2, a2[1]);
}

char *std::vector<double>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

_QWORD *std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, a3, (uint64_t)(v4 + 4)))break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

_QWORD *std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::find<std::string>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, (uint64_t)(v3 + 4), a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v6 == v2
    || std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, a2, (uint64_t)(v6 + 4)))
  {
    return v2;
  }
  return v6;
}

void SVGAttributeMap::SVGAttributeMap(SVGAttributeMap *this)
{
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttributeMap::kSVGAttributeMapClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8CF8;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 6) = (char *)this + 56;
}

void sub_20676C788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *CFRetained::CFRetained(_QWORD *a1, uint64_t a2)
{
  uint64_t Instance;

  *a1 = off_24BFD8A68;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  CFRetained::getTypeID(a2);
  Instance = _CFRuntimeCreateInstance();
  a1[5] = Instance;
  *(_QWORD *)(Instance + 16) = a1;
  return a1;
}

void sub_20676C810(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t CFRetained::getTypeID(uint64_t a1)
{
  uint64_t **v2;
  uint64_t v3;
  _QWORD *v4;
  const char *v5;
  std::string __p;
  uint64_t v8;
  _QWORD *v9;

  os_unfair_lock_lock((os_unfair_lock_t)&CFRetained::getTypeID(std::string const&)::lock);
  if (GetClassRegistry(void)::onceToken != -1)
    dispatch_once(&GetClassRegistry(void)::onceToken, &__block_literal_global_22);
  v2 = (uint64_t **)GetClassRegistry(void)::classRegistry;
  if (std::__tree<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>>>::__count_unique<std::string>(GetClassRegistry(void)::classRegistry, (const void **)a1))
  {
    v3 = *(_QWORD *)std::map<std::string,std::pair<unsigned long,__CFRuntimeClass *>>::at((uint64_t)v2, (const void **)a1);
  }
  else
  {
    v4 = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
    if (*(char *)(a1 + 23) >= 0)
      v5 = (const char *)a1;
    else
      v5 = *(const char **)a1;
    v4[1] = strdup(v5);
    v4[4] = CFRetainedFinalize;
    v3 = _CFRuntimeRegisterClass();
    if (*(char *)(a1 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    else
      __p = *(std::string *)a1;
    v8 = v3;
    v9 = v4;
    std::__tree<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::pair<unsigned long,__CFRuntimeClass *>>>(v2, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CFRetained::getTypeID(std::string const&)::lock);
  return v3;
}

void sub_20676C968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::map<std::string,std::pair<unsigned long,__CFRuntimeClass *>>::at(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__find_equal<std::string>(a1, &v4, a2);
  if (!v2)
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  return v2 + 56;
}

_QWORD *std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t std::__tree<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>>>::__count_unique<std::string>(uint64_t a1, const void **a2)
{
  const void **v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    v4 = a1 + 16;
    v5 = 1;
    do
    {
      if (!std::less<std::string>::operator()[abi:ne180100](v4, a2, v2 + 4))
      {
        if (!std::less<std::string>::operator()[abi:ne180100](v4, v2 + 4, a2))
          return v5;
        ++v2;
      }
      v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t SVGAtom::toName(os_unfair_lock_s *this, char *a2)
{
  os_unfair_lock_s *v4;
  unsigned int *v5;
  uint64_t v6;
  void *__p[2];
  char v9;

  if (!a2 || !*a2)
    return 0;
  v4 = this + 22;
  os_unfair_lock_lock(this + 22);
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v5 = (unsigned int *)std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::find<std::string>((uint64_t)this, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  if (&this[2] == (os_unfair_lock_s *)v5)
  {
    os_unfair_lock_unlock(v4);
    return SVGAtom::insert((uint64_t)this, a2, 0);
  }
  v6 = v5[14];
  os_unfair_lock_unlock(v4);
  if (!(_DWORD)v6)
    return SVGAtom::insert((uint64_t)this, a2, 0);
  return v6;
}

void sub_20676CC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20676CCAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void SVGAttribute::SVGAttribute(SVGAttribute *this, const SVGAttribute *a2)
{
  int v4;
  SVGPaint *v5;
  uint64_t v6;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8C08;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  std::string::operator=((std::string *)((char *)this + 56), (const std::string *)((char *)a2 + 56));
  v4 = *((_DWORD *)a2 + 20);
  *((_DWORD *)this + 20) = v4;
  *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
  switch(v4)
  {
    case 1:
      v5 = (SVGPaint *)operator new();
      v6 = *((_QWORD *)a2 + 11);
      *((_QWORD *)v5 + 1) = 0;
      *((_QWORD *)v5 + 2) = 0;
      *(_QWORD *)v5 = 0;
      std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v5, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3);
      goto LABEL_11;
    case 2:
      *((_DWORD *)this + 22) = *((_DWORD *)a2 + 22);
      return;
    case 3:
      v5 = (SVGPaint *)operator new();
      SVGPaint::SVGPaint(v5, *((const SVGPaint **)a2 + 11));
      goto LABEL_11;
    case 4:
      v5 = (SVGPaint *)operator new();
      SVGPath::SVGPath(v5, *((const SVGPath **)a2 + 11));
      goto LABEL_11;
    case 6:
      v5 = (SVGPaint *)operator new();
      SVGClipPath::SVGClipPath(v5, *((const SVGClipPath **)a2 + 11));
      goto LABEL_11;
    case 7:
      v5 = (SVGPaint *)operator new();
      SVGMask::SVGMask(v5, *((const SVGAttributeMap ***)a2 + 11));
      goto LABEL_11;
    case 8:
      v5 = (SVGPaint *)operator new();
      SVGFilter::SVGFilter(v5, *((const SVGAttributeMap ***)a2 + 11));
LABEL_11:
      *((_QWORD *)this + 11) = v5;
      break;
    default:
      return;
  }
}

void sub_20676CEAC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;

  MEMORY[0x20BCFC038](v3, 0x10B3C40B295622DLL);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v2);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, unsigned int a2, int a3)
{
  _QWORD *v6;
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 2;
  v6 = SVGAtom::ToString(a2);
  MEMORY[0x20BCFBFCC](a1 + 56, v6);
  *(_DWORD *)(a1 + 88) = a3;
  return a1;
}

void sub_20676D034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

BOOL ___ZN8SVGStyle21addDefinitionsFromCSSEPKc_block_invoke_2(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  SVGParser *v3;
  const char *v4;
  _BOOL8 result;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (SVGParser *)SVGAtom::ToString(a2);
  result = SVGParser::StringBeginsWith(v3, "--", v4);
  if (result)
    *(_BYTE *)(v2 + 24) = 1;
  return result;
}

_QWORD *SVGAtom::toString(uint64_t a1, unsigned int a2)
{
  os_unfair_lock_s *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  uint64_t *v15;
  _QWORD *v16;
  unsigned int v18;
  std::string __p;
  std::string v20;
  unsigned int v21;

  v4 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (!*(_QWORD *)(a1 + 40))
  {
    v5 = *(_QWORD **)a1;
    if (*(_QWORD *)a1 != a1 + 8)
    {
      do
      {
        if (*((char *)v5 + 55) < 0)
          std::string::__init_copy_ctor_external(&v20, (const std::string::value_type *)v5[4], v5[5]);
        else
          v20 = *(std::string *)(v5 + 4);
        v21 = *((_DWORD *)v5 + 14);
        v18 = v21;
        if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external(&__p, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
        else
          __p = v20;
        std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__emplace_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name,std::string>>((uint64_t **)(a1 + 24), &v18, (uint64_t)&v18);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v20.__r_.__value_.__l.__data_);
        v6 = (_QWORD *)v5[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = (_QWORD *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            v7 = (_QWORD *)v5[2];
            v8 = *v7 == (_QWORD)v5;
            v5 = v7;
          }
          while (!v8);
        }
        v5 = v7;
      }
      while (v7 != (_QWORD *)(a1 + 8));
    }
  }
  v11 = *(_QWORD *)(a1 + 32);
  v10 = a1 + 32;
  v9 = v11;
  if (!v11)
    goto LABEL_30;
  v12 = v10;
  do
  {
    v13 = *(_DWORD *)(v9 + 32);
    v14 = v13 >= a2;
    if (v13 >= a2)
      v15 = (uint64_t *)v9;
    else
      v15 = (uint64_t *)(v9 + 8);
    if (v14)
      v12 = v9;
    v9 = *v15;
  }
  while (*v15);
  if (v12 != v10 && *(_DWORD *)(v12 + 32) <= a2)
  {
    v16 = (_QWORD *)(v12 + 40);
    if (*(char *)(v12 + 63) < 0)
      v16 = (_QWORD *)*v16;
  }
  else
  {
LABEL_30:
    v16 = 0;
  }
  os_unfair_lock_unlock(v4);
  return v16;
}

void sub_20676D258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *SVGAtom::ToString(unsigned int a1)
{
  if (SVGAtom::SharedInstance(void)::onceToken != -1)
    dispatch_once(&SVGAtom::SharedInstance(void)::onceToken, &__block_literal_global);
  return SVGAtom::toString(SVGAtom::SharedInstance(void)::instance, a1);
}

BOOL SVGParser::StringBeginsWith(SVGParser *this, const char *a2, const char *a3)
{
  _BOOL8 result;
  size_t v6;
  size_t v7;

  result = 0;
  if (this && a2)
  {
    v6 = strlen((const char *)this);
    v7 = strlen(a2);
    return v6 >= v7 && strncasecmp((const char *)this, a2, v7) == 0;
  }
  return result;
}

void ___ZN15SVGAttributeMap13setAttributesERKS__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SVGAttributeMap::setAttribute(*(_QWORD *)(a1 + 32), a3, 0);
}

void ___ZN12SVGShapeNode17updatedAttributesEP15SVGAttributeMap_block_invoke(uint64_t a1, signed int a2, os_unfair_lock_s *this)
{
  double *v4;
  double *v5;
  _QWORD *v6;
  const char *v7;

  v4 = *(double **)(a1 + 32);
  if (a2 <= 46)
  {
    switch(a2)
    {
      case 9:
        v5 = v4 + 33;
        break;
      case 10:
        v5 = v4 + 34;
        break;
      case 30:
        v5 = v4 + 30;
        break;
      default:
        return;
    }
  }
  else
  {
    switch(a2)
    {
      case '3':
        v5 = v4 + 31;
        break;
      case '4':
        v5 = v4 + 32;
        break;
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'A':
        return;
      case 'B':
        v5 = v4 + 29;
        break;
      case 'C':
      case 'D':
        v5 = v4 + 25;
        break;
      case 'E':
        v5 = v4 + 27;
        break;
      case 'F':
      case 'G':
        v5 = v4 + 26;
        break;
      case 'H':
        v5 = v4 + 28;
        break;
      default:
        if (a2 != 47)
          return;
        v5 = v4 + 35;
        break;
    }
  }
  if ((SVGAttribute::floatValue(this, v5) & 1) == 0)
  {
    v6 = SVGAtom::ToString(a2);
    SVGUtilities::error((SVGUtilities *)"SVGShapeNode: Error parsing atom: %s\n", v7, v6);
  }
}

void ___ZN15SVGAttributeMap19addUniqueAttributesEPKS__block_invoke(uint64_t a1, unsigned int a2, SVGAttribute *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  uint64_t *v10;
  SVGAttribute *v11;
  SVGAttribute *v12;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(v5 + 56);
  if (!v6)
    goto LABEL_14;
  v7 = v5 + 56;
  do
  {
    v8 = *(_DWORD *)(v6 + 32);
    v9 = v8 >= a2;
    if (v8 >= a2)
      v10 = (uint64_t *)v6;
    else
      v10 = (uint64_t *)(v6 + 8);
    if (v9)
      v7 = v6;
    v6 = *v10;
  }
  while (*v10);
  if (v7 == v5 + 56
    || *(_DWORD *)(v7 + 32) > a2
    || (v11 = *(SVGAttribute **)(v7 + 40)) == 0
    || (SVGAttribute::isEqual(v11, a3) & 1) == 0)
  {
LABEL_14:
    v12 = (SVGAttribute *)operator new();
    SVGAttribute::SVGAttribute(v12, a3);
    SVGAttributeMap::setAttribute(v5, (uint64_t)v12, 0);
    CFRetained::release((CFTypeRef *)v12);
    SVGAttributeMap::setAttribute(*(_QWORD *)(a1 + 40), (uint64_t)v12, 0);
  }
}

void sub_20676D520(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void SVGParser::ParseRulesetList(SVGParser *this@<X0>, uint64_t *a2@<X8>)
{
  SVGParser *v3;
  int64_t v5;
  SVGParser *v6;
  SVGParser *v7;
  uint64_t v8;
  uint64_t v9;
  SVGParser *v10;
  unsigned int v11;
  int v12;
  int64_t v13;
  _BOOL4 v14;
  SVGParser *v15;
  SVGParser *v16;
  uint64_t v17;
  SVGParser *v18;
  SVGParser *v19;
  char v20;
  std::string *p_p;
  std::string *v22;
  __int128 v23;
  uint64_t v24;
  std::string v25;
  std::string v26;
  std::string __p;

  v3 = this;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v5 = strlen((const char *)this);
  if (v5 >= 1)
  {
    v6 = (SVGParser *)((char *)v3 + v5);
    v7 = (SVGParser *)((char *)v3 + v5);
    v8 = (uint64_t)v3 + v5 - 1;
    v9 = MEMORY[0x24BDAC740];
    do
    {
      v10 = v3;
      do
      {
        v11 = *(char *)v10;
        if ((v11 & 0x80000000) != 0)
          v12 = __maskrune(v11, 0x4000uLL);
        else
          v12 = *(_DWORD *)(v9 + 4 * v11 + 60) & 0x4000;
        if (!v12)
          break;
        v10 = (SVGParser *)((char *)v10 + 1);
      }
      while (v10 < v6);
      if (v10 < v6)
      {
        v13 = v7 - v10;
        while (*(_BYTE *)v10 != 123)
        {
          v10 = (SVGParser *)((char *)v10 + 1);
          if (!--v13)
          {
            v10 = v7;
            break;
          }
        }
      }
      if (v10 >= v6)
      {
        v14 = 0;
      }
      else if (*(_BYTE *)v10 == 125)
      {
        v14 = 1;
      }
      else
      {
        v15 = v7;
        v16 = (SVGParser *)((char *)v10 + 1);
        v17 = v8 - (_QWORD)v10;
        while (1)
        {
          v18 = v16;
          if (!v17)
            break;
          v16 = (SVGParser *)((char *)v16 + 1);
          --v17;
          if (*(_BYTE *)v18 == 125)
          {
            v15 = v18;
            break;
          }
        }
        v14 = v18 < v6;
        v10 = v15;
      }
      v19 = (SVGParser *)((char *)v10 + v14);
      std::string::basic_string[abi:ne180100](&__p, v3, v19 - v3);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v25, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      else
        v25 = __p;
      SVGParser::StripLeadingTrailingWhitespace(&v25, &v26);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      __p = v26;
      *((_BYTE *)&v26.__r_.__value_.__s + 23) = 0;
      v26.__r_.__value_.__s.__data_[0] = 0;
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v25.__r_.__value_.__l.__data_);
      v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        if (!__p.__r_.__value_.__l.__size_)
          goto LABEL_49;
        if (__p.__r_.__value_.__l.__size_ != 1)
        {
          v22 = (std::string *)a2[1];
          if ((unint64_t)v22 >= a2[2])
            goto LABEL_46;
LABEL_44:
          std::string::__init_copy_ctor_external(v22, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          goto LABEL_45;
        }
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      else
      {
        if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
          goto LABEL_50;
        if (HIBYTE(__p.__r_.__value_.__r.__words[2]) != 1)
        {
          v22 = (std::string *)a2[1];
          if ((unint64_t)v22 >= a2[2])
            goto LABEL_46;
          goto LABEL_42;
        }
        p_p = &__p;
      }
      if (!p_p->__r_.__value_.__s.__data_[0])
        goto LABEL_48;
      v22 = (std::string *)a2[1];
      if ((unint64_t)v22 >= a2[2])
      {
LABEL_46:
        v24 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (__int128 *)&__p);
        goto LABEL_47;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_44;
LABEL_42:
      v23 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      v22->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
      *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v23;
LABEL_45:
      v24 = (uint64_t)&v22[1];
      a2[1] = (uint64_t)&v22[1];
LABEL_47:
      a2[1] = v24;
      v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
LABEL_48:
      if (v20 < 0)
LABEL_49:
        operator delete(__p.__r_.__value_.__l.__data_);
LABEL_50:
      v3 = v19;
    }
    while (v19 < v6);
  }
}

void sub_20676D7A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;

  v25 = v24;
  v23[1] = v25;
  if (a23 < 0)
    operator delete(__p);
  __p = v23;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::pair<unsigned long,__CFRuntimeClass *>>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>>>::__construct_node<std::pair<std::string const,std::pair<unsigned long,__CFRuntimeClass *>>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

__n128 std::__tree<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<unsigned long,__CFRuntimeClass *>>>>::__construct_node<std::pair<std::string const,std::pair<unsigned long,__CFRuntimeClass *>>>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;
  __n128 result;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x48uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v6 + 56) = result;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20676D960(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void ___ZL33ApplyUniqueAttributesToAttributesP15SVGAttributeMapS0__block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  SVGAttribute *v5;

  if (!SVGAttributeMap::attribute(*(_QWORD *)(a1 + 32), a3[12]))
  {
    v5 = (SVGAttribute *)operator new();
    SVGAttribute::SVGAttribute(v5, (const SVGAttribute *)a3);
    SVGAttributeMap::setAttribute(*(_QWORD *)(a1 + 32), (uint64_t)v5, 0);
    CFRetained::release((CFTypeRef *)v5);
  }
}

void sub_20676D9FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void SVGPathCommand::appendFloats()
{
  __assert_rtn("appendFloats", "SVGPath.cpp", 137, "_floats != nullptr");
}

SVGNode *CGSVGNodeFindChildWithStringIdentifier(uint64_t a1, const __CFString *this)
{
  char *v3;
  SVGNode *ChildWithCStringIdentifier;
  void *__p[2];
  char v7;

  if (!this)
    return 0;
  SVGUtilities::StringWithCFString(this, __p);
  if (v7 >= 0)
    v3 = (char *)__p;
  else
    v3 = (char *)__p[0];
  ChildWithCStringIdentifier = CGSVGNodeFindChildWithCStringIdentifier(a1, v3);
  if (v7 < 0)
    operator delete(__p[0]);
  return ChildWithCStringIdentifier;
}

void sub_20676DADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const __CFString *CGSVGDocumentGetNamedStyle(uint64_t a1, const char *a2)
{
  const __CFString *v2;
  void *v3;
  uint64_t v4;
  uint64_t NamedStyle;
  uint64_t v6;
  void *__p[2];
  char v9;

  v2 = (const __CFString *)a2;
  v3 = CFRetained::getObject<SVGDocument>(a1, a2);
  if (!v3)
    return 0;
  v4 = (uint64_t)v3;
  SVGUtilities::StringWithCFString(v2, __p);
  NamedStyle = SVGDocument::findNamedStyle(v4, (uint64_t)__p);
  v6 = NamedStyle;
  if (NamedStyle)
    v2 = *(const __CFString **)(NamedStyle + 40);
  if (v9 < 0)
  {
    operator delete(__p[0]);
    if (v6)
      return v2;
    return 0;
  }
  if (!NamedStyle)
    return 0;
  return v2;
}

void sub_20676DB74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SVGAtom *CGSVGAtomFromString(const __CFString *a1)
{
  SVGAtom *v1;
  const char *v2;
  void *v3;
  _QWORD v5[2];
  char v6;

  if (!a1)
    return 0;
  v1 = (SVGAtom *)v5;
  SVGUtilities::StringWithCFString(a1, v5);
  if (v6 < 0)
  {
    v1 = (SVGAtom *)v5[0];
    if (!v5[0])
    {
      v3 = 0;
      goto LABEL_8;
    }
  }
  v1 = (SVGAtom *)SVGAtom::ToName(v1, v2);
  if (v6 < 0)
  {
    v3 = (void *)v5[0];
LABEL_8:
    operator delete(v3);
  }
  return v1;
}

void sub_20676DC00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGUtilities::StringWithCFString(const __CFString *this@<X0>, _QWORD *a2@<X8>)
{
  CFTypeID v5;
  const char *CStringPtr;
  char *v7;
  CFIndex Length;
  CFIndex v9;
  char *v10;

  if (!this || (v5 = CFGetTypeID(this), v5 != CFStringGetTypeID()))
  {
    v7 = (char *)&unk_20679A6BE;
    goto LABEL_6;
  }
  CStringPtr = CFStringGetCStringPtr(this, 0x8000100u);
  if (CStringPtr)
  {
    v7 = (char *)CStringPtr;
LABEL_6:
    std::string::basic_string[abi:ne180100]<0>(a2, v7);
    return;
  }
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_20679A6BE);
  Length = CFStringGetLength(this);
  v9 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v10 = (char *)malloc_type_malloc(v9, 0x515BE0F3uLL);
  if (v10)
  {
    if (CFStringGetCString(this, v10, v9, 0x8000100u))
      MEMORY[0x20BCFBFD8](a2, v10, v9);
    free(v10);
  }
}

void sub_20676DD14(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

double CGSVGDocumentGetCanvasSize(uint64_t a1, const char *a2)
{
  SVGDocument *v2;
  double result;

  v2 = (SVGDocument *)CFRetained::getObject<SVGDocument>(a1, a2);
  if (!v2)
    return *MEMORY[0x24BDBF148];
  *(_QWORD *)&result = SVGDocument::canvasSize(v2).u64[0];
  return result;
}

_QWORD *CGSVGDocumentGetRootNode(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v3;

  result = CFRetained::getObject<SVGDocument>(a1, a2);
  if (result)
  {
    v3 = result[6];
    if (v3)
      return *(_QWORD **)(v3 + 40);
    else
      return 0;
  }
  return result;
}

void *CFRetained::getObject<SVGDocument>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

uint64_t CGSVGDocumentCreateFromData(const __CFData *a1, const __CFDictionary *a2)
{
  SVGDocument *v4;
  SVGReaderOptions *Options;
  BOOL v6;

  v4 = (SVGDocument *)operator new();
  SVGDocument::SVGDocument(v4);
  Options = (SVGReaderOptions *)CreateReadOptions(a2);
  v6 = SVGDocument::read(v4, a1, Options);
  if (Options)
  {
    SVGReaderOptions::~SVGReaderOptions(Options);
    MEMORY[0x20BCFC038]();
  }
  if (v6)
  {
    SVGDocument::validateSizes(v4);
    return *((_QWORD *)v4 + 5);
  }
  else
  {
    CFRetained::release((CFTypeRef *)v4);
    return 0;
  }
}

void sub_20676DE7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4079506790);
  _Unwind_Resume(a1);
}

BOOL SVGDocument::read(SVGDocument *this, const __CFData *a2, SVGReaderOptions *a3)
{
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  char **v9;
  char *v10;
  char **v11;
  BOOL v12;
  char **v14;
  char *v15[2];
  _BYTE v16[8];
  uint64_t v17;
  uint64_t v18;

  if (!a2)
    return 0;
  v6 = *((_QWORD *)this + 6);
  if (v6)
  {
    if (*(_QWORD *)(v6 + 96) != *(_QWORD *)(v6 + 88))
    {
      SVGUtilities::error((SVGUtilities *)"Root Node is already populated in SVGDocument. Skipping read.", (const char *)a2);
      return 0;
    }
    CFRetained::release((CFTypeRef *)v6);
  }
  SVGReader::SVGReader((SVGReader *)v16, a2, a3);
  v8 = v17;
  *((_QWORD *)this + 6) = v17;
  CFRetained::retain(v8);
  if (v18)
  {
    std::map<std::string,SVGAttributeMap *,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,SVGAttributeMap *>>>::map[abi:ne180100]((uint64_t *)&v14, v18);
    v9 = v14;
    if (v14 != v15)
    {
      do
      {
        SVGDocument::addNamedStyle((uint64_t)this, (uint64_t)(v9 + 4), (CFTypeRef *)v9[7]);
        v10 = v9[1];
        if (v10)
        {
          do
          {
            v11 = (char **)v10;
            v10 = *(char **)v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            v11 = (char **)v9[2];
            v12 = *v11 == (char *)v9;
            v9 = v11;
          }
          while (!v12);
        }
        v9 = v11;
      }
      while (v11 != v15);
    }
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy((uint64_t)&v14, v15[0]);
  }
  v7 = (!a3 || *((_DWORD *)a3 + 8) != 1 || SVGDocument::checkProfileSettings(this, a2)) && *((_QWORD *)this + 6) != 0;
  SVGReader::~SVGReader((SVGReader *)v16);
  return v7;
}

void sub_20676DFE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  SVGReader::~SVGReader((SVGReader *)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

void SVGDocument::addNamedStyle(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  SVGStyle *v6;

  if (a3)
  {
    v6 = *(SVGStyle **)(a1 + 64);
    if (!v6)
    {
      v6 = (SVGStyle *)operator new();
      SVGStyle::SVGStyle(v6);
      *(_QWORD *)(a1 + 64) = v6;
    }
    SVGStyle::addNamedStyle((uint64_t **)v6, a2, a3);
  }
}

void sub_20676E0D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x1020C402C28E7A6);
  _Unwind_Resume(a1);
}

void SVGStyle::SVGStyle(SVGStyle *this)
{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  *((_BYTE *)this + 24) = 0;
}

void SVGReader::~SVGReader(SVGReader *this)
{
  SVGStyle *v2;
  void *v3;

  CFRetained::release(*((_QWORD *)this + 1));
  v2 = (SVGStyle *)*((_QWORD *)this + 2);
  if (v2)
  {
    SVGStyle::~SVGStyle(v2);
    MEMORY[0x20BCFC038]();
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
}

void SVGDocument::validateSizes(SVGDocument *this)
{
  double v2;
  double v3;
  uint64_t v4;
  double BoundingBox;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(double *)SVGDocument::canvasSize(this).i64;
  v4 = *((_QWORD *)this + 6);
  *(_OWORD *)(v4 + 200) = *MEMORY[0x24BDBEFB0];
  if (v2 < 1.0 || v3 < 1.0)
  {
    BoundingBox = SVGNode::getBoundingBox((SVGNode *)v4, 0, 2);
    if (BoundingBox < 0.0)
      BoundingBox = 0.0;
    v10 = *((_QWORD *)this + 6);
    if (v7 < 0.0)
      v7 = 0.0;
    *(double *)(v10 + 232) = BoundingBox;
    *(double *)(v10 + 240) = v7;
    *(_QWORD *)(v10 + 248) = v8;
    *(_QWORD *)(v10 + 256) = v9;
  }
}

int8x16_t SVGDocument::canvasSize(SVGDocument *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 6);
  if (v1)
  {
    __asm { FMOV            V2.2D, #1.0 }
    return vbslq_s8(vandq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)(v1 + 248), _Q2), (int8x16_t)vcgtq_f64(_Q2, *(float64x2_t *)(v1 + 216))), *(int8x16_t *)(v1 + 248), *(int8x16_t *)(v1 + 216));
  }
  else
  {
    return *(int8x16_t *)MEMORY[0x24BDBF148];
  }
}

uint64_t CreateReadOptions(const __CFDictionary *a1)
{
  uint64_t v2;
  SVGAttributeMap *v3;
  const __CFBoolean *Value;
  const __CFBoolean *v5;
  CFTypeID v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  CFTypeID v9;
  const __CFBoolean *v10;
  const __CFBoolean *v11;
  CFTypeID v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  CFTypeID v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  CFTypeID v18;

  if (!a1 || CFDictionaryGetCount(a1) < 1)
    return 0;
  v2 = operator new();
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_QWORD *)(v2 + 32) = 0;
  *(_BYTE *)(v2 + 28) = 1;
  v3 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v3);
  *(_QWORD *)v2 = v3;
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("strict"));
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
      *(_BYTE *)(v2 + 8) = CFBooleanGetValue(v5) != 0;
  }
  v7 = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("securityLevel"));
  if (v7)
  {
    v8 = v7;
    v9 = CFGetTypeID(v7);
    if (v9 == CFNumberGetTypeID())
      CFNumberGetValue(v8, kCFNumberIntType, (void *)(v2 + 24));
  }
  v10 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("showPlaceholder"));
  if (v10)
  {
    v11 = v10;
    v12 = CFGetTypeID(v10);
    if (v12 == CFBooleanGetTypeID())
      *(_BYTE *)(v2 + 28) = CFBooleanGetValue(v11) != 0;
  }
  v13 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("variables"));
  if (v13)
  {
    v14 = v13;
    v15 = CFGetTypeID(v13);
    if (v15 == CFDictionaryGetTypeID())
      CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)CopyOptionsIntoMap, *(void **)v2);
  }
  v16 = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("baseProfile"));
  if (v16)
  {
    v17 = v16;
    v18 = CFGetTypeID(v16);
    if (v18 == CFNumberGetTypeID())
      CFNumberGetValue(v17, kCFNumberIntType, (void *)(v2 + 32));
  }
  return v2;
}

void sub_20676E3FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

void SVGDocument::SVGDocument(SVGDocument *this)
{
  SVGRootNode *v2;
  void *__p[2];
  char v4;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGDocument::kSVGDocumentClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v4 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8B38;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  v2 = (SVGRootNode *)operator new();
  SVGRootNode::SVGRootNode(v2);
  *((_QWORD *)this + 6) = v2;
}

void sub_20676E4AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v2;
  MEMORY[0x20BCFC038](v3, 0x10F3C40BD1137ACLL);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void SVGStyle::~SVGStyle(char **this)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  BOOL v6;
  std::string __p;
  CFTypeRef *v8;

  v2 = (char *)(this + 1);
  v3 = *this;
  if (*this != (char *)(this + 1))
  {
    do
    {
      if (v3[55] < 0)
        std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)v3 + 4), *((_QWORD *)v3 + 5));
      else
        __p = *(std::string *)(v3 + 32);
      v8 = (CFTypeRef *)*((_QWORD *)v3 + 7);
      CFRetained::release(v8);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v4 = (char *)*((_QWORD *)v3 + 1);
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = *(char **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (char *)*((_QWORD *)v3 + 2);
          v6 = *(_QWORD *)v5 == (_QWORD)v3;
          v3 = v5;
        }
        while (!v6);
      }
      v3 = v5;
    }
    while (v5 != v2);
  }
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy((uint64_t)this, this[1]);
}

uint64_t SVGStyle::findNamedStyle(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  v3 = std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::find<std::string>(a1, a2);
  if ((_QWORD *)(a1 + 8) == v3)
    return 0;
  else
    return v3[7];
}

uint64_t SVGDocument::findNamedStyle(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 64);
  if (result)
    return SVGStyle::findNamedStyle(result, a2);
  return result;
}

SVGNode *CGSVGNodeFindChildWithCStringIdentifier(uint64_t a1, char *a2)
{
  SVGNode *result;

  result = (SVGNode *)CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    result = (SVGNode *)SVGNode::findChildWithIdentifier(result, a2);
    if (result)
      return (SVGNode *)*((_QWORD *)result + 5);
  }
  return result;
}

uint64_t SVGNode::findChildWithIdentifier(SVGNode *this, char *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  SVGNode **v8;
  SVGNode **v9;
  uint64_t ChildWithIdentifier;
  void *__p[2];
  char v13;

  if (!a2)
    return 0;
  v4 = (char *)this + 136;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v5 = std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__count_unique<std::string>((uint64_t)v4, (uint64_t)__p);
  v6 = v5;
  if ((v13 & 0x80000000) == 0)
  {
    if (v5)
      goto LABEL_4;
    goto LABEL_7;
  }
  operator delete(__p[0]);
  if (!v6)
  {
LABEL_7:
    v9 = (SVGNode **)*((_QWORD *)this + 11);
    v8 = (SVGNode **)*((_QWORD *)this + 12);
    while (v9 != v8)
    {
      ChildWithIdentifier = SVGNode::findChildWithIdentifier(*v9, a2);
      if (ChildWithIdentifier)
        return ChildWithIdentifier;
      ++v9;
    }
    return 0;
  }
LABEL_4:
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v7 = std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>((uint64_t)v4, (uint64_t)__p)[7];
  if (v13 < 0)
    operator delete(__p[0]);
  return v7;
}

void sub_20676E72C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__count_unique<std::string>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v4 = a1 + 16;
    v5 = 1;
    do
    {
      if ((std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v4, a2, (uint64_t)(v2 + 4)) & 1) == 0)
      {
        if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v4, (uint64_t)(v2 + 4), a2))return v5;
        ++v2;
      }
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t *std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,unsigned int> const&>(uint64_t **a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__find_equal<std::string>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__construct_node<std::pair<std::string const,unsigned int> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v10, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__construct_node<std::pair<std::string const,unsigned int> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  *((_DWORD *)v6 + 14) = *(_DWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_20676E8D0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__find_equal<std::string>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, uint64_t a5)
{
  _QWORD *v9;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  _QWORD *v18;

  v9 = a1 + 1;
  if (a1 + 1 == a2
    || std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (uint64_t)(a2 + 4)))
  {
    if ((_QWORD *)*a1 == a2)
    {
      v12 = a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    v11 = (_QWORD *)*a2;
    if (*a2)
    {
      do
      {
        v12 = v11;
        v11 = (_QWORD *)v11[1];
      }
      while (v11);
    }
    else
    {
      v16 = a2;
      do
      {
        v12 = (_QWORD *)v16[2];
        v17 = *v12 == (_QWORD)v16;
        v16 = v12;
      }
      while (v17);
    }
    if (std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (uint64_t)(v12 + 4), a5))goto LABEL_16;
    return std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
  }
  if (std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (uint64_t)(a2 + 4), a5))
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (_QWORD *)a2[1];
      do
      {
        v15 = v14;
        v14 = (_QWORD *)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = a2;
      do
      {
        v15 = (_QWORD *)v18[2];
        v17 = *v15 == (_QWORD)v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (uint64_t)(v15 + 4)))return std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
      v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  *a3 = a2;
  *a4 = (uint64_t)a2;
  return a4;
}

_QWORD *std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, (uint64_t)(v3 + 4), a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v6 == v2
    || std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, a2, (uint64_t)(v6 + 4)))
  {
    return v2;
  }
  return v6;
}

uint64_t *std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,SVGAttributeMap *> const&>(uint64_t **a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__find_equal<std::string>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__construct_node<std::pair<std::string const,SVGAttributeMap *> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v10, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__construct_node<std::pair<std::string const,SVGAttributeMap *> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v6 + 7) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_20676EC18(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__find_equal<std::string>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, uint64_t a5)
{
  _QWORD *v9;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  _QWORD *v18;

  v9 = a1 + 1;
  if (a1 + 1 == a2
    || std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (uint64_t)(a2 + 4)))
  {
    if ((_QWORD *)*a1 == a2)
    {
      v12 = a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    v11 = (_QWORD *)*a2;
    if (*a2)
    {
      do
      {
        v12 = v11;
        v11 = (_QWORD *)v11[1];
      }
      while (v11);
    }
    else
    {
      v16 = a2;
      do
      {
        v12 = (_QWORD *)v16[2];
        v17 = *v12 == (_QWORD)v16;
        v16 = v12;
      }
      while (v17);
    }
    if (std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (uint64_t)(v12 + 4), a5))goto LABEL_16;
    return std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
  }
  if (std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (uint64_t)(a2 + 4), a5))
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (_QWORD *)a2[1];
      do
      {
        v15 = v14;
        v14 = (_QWORD *)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = a2;
      do
      {
        v15 = (_QWORD *)v18[2];
        v17 = *v15 == (_QWORD)v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (uint64_t)(v15 + 4)))return std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
      v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  *a3 = a2;
  *a4 = (uint64_t)a2;
  return a4;
}

void SVGStyle::addNamedStyle(uint64_t **a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t **v6;
  uint64_t v7;
  std::string __p;
  CFTypeRef *v9;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::find<std::string>((uint64_t)a1, a2);
  if (a1 + 1 != v6)
  {
    v7 = (uint64_t)v6;
    CFRetained::release((CFTypeRef *)v6[7]);
    std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::erase(a1, v7);
  }
  CFRetained::retain(a3);
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  v9 = a3;
  std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGAttributeMap *>>(a1, (uint64_t)&__p, (uint64_t)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_20676EE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL SVGStyle::getAttributeMapForIdentifier(SVGStyle *this, char *a2, SVGAttributeMap *a3)
{
  _QWORD *v5;
  uint64_t v6;
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v5 = std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::find<std::string>((uint64_t)this, (uint64_t)__p);
  if ((_QWORD *)((char *)this + 8) == v5)
    v6 = 0;
  else
    v6 = v5[7];
  if (v9 < 0)
    operator delete(__p[0]);
  if (v6)
    SVGAttributeMap::setAttributes((uint64_t)a3, v6);
  return v6 != 0;
}

void sub_20676EF14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGAttributeMap *>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__construct_node<std::pair<std::string const,SVGAttributeMap *>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__construct_node<std::pair<std::string const,SVGAttributeMap *>>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v6 + 7) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_20676F034(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, a3, (uint64_t)(v4 + 4)))break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t SVGAttributeMap::setAttributes(uint64_t a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN15SVGAttributeMap13setAttributesERKS__block_invoke;
  v3[3] = &__block_descriptor_tmp_15;
  v3[4] = a1;
  return SVGAttributeMap::enumerate(a2, (uint64_t)v3);
}

SVGAttributeMap *SVGAttributeMap::CreateWithDefaults(SVGAttributeMap *this)
{
  SVGAttributeMap *v1;
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  SVGPaint *v9;
  SVGColor *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  SVGPaint *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  SVGPaint *v23;
  SVGColor *v24;
  uint64_t v25;
  _QWORD v27[3];
  _BYTE v28[40];
  _OWORD v29[3];

  v1 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v1);
  v2 = operator new();
  v3 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  v29[0] = *MEMORY[0x24BDBD8B8];
  v29[1] = v3;
  v29[2] = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  SVGAttribute::SVGAttribute(v2, 63, v29);
  SVGAttributeMap::setAttribute((uint64_t)v1, v2, 1);
  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, 41, 1.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v4, 1);
  v5 = operator new();
  SVGAttribute::SVGAttribute(v5, 23, (uint64_t)"Times");
  SVGAttributeMap::setAttribute((uint64_t)v1, v5, 1);
  v6 = operator new();
  SVGAttribute::SVGAttribute(v6, 25, 400.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v6, 1);
  v7 = operator new();
  SVGAttribute::SVGAttribute(v7, 24, 16.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v7, 1);
  v8 = operator new();
  SVGAttribute::SVGAttribute(v8, 10000, 0.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v8, 1);
  v9 = (SVGPaint *)operator new();
  SVGColor::SVGColor((SVGColor *)v28, (SVGColor *)"black", v10);
  SVGPaint::SVGPaint(v9, (const SVGColor *)v28);
  v11 = operator new();
  SVGAttribute::SVGAttribute(v11, 18, (uint64_t)v9);
  SVGAttributeMap::setAttribute((uint64_t)v1, v11, 1);
  CFRetained::release((CFTypeRef *)v9);
  v12 = operator new();
  SVGAttribute::SVGAttribute(v12, 19, 1.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v12, 1);
  v13 = operator new();
  SVGAttribute::SVGAttribute(v13, 0x14u, 39);
  SVGAttributeMap::setAttribute((uint64_t)v1, v13, 1);
  v14 = (SVGPaint *)operator new();
  SVGPaint::SVGPaint(v14);
  v15 = operator new();
  SVGAttribute::SVGAttribute(v15, 57, (uint64_t)v14);
  SVGAttributeMap::setAttribute((uint64_t)v1, v15, 1);
  CFRetained::release((CFTypeRef *)v14);
  v16 = operator new();
  SVGAttribute::SVGAttribute(v16, 58, 1.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v16, 1);
  v17 = operator new();
  SVGAttribute::SVGAttribute(v17, 59, 1.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v17, 1);
  v18 = operator new();
  SVGAttribute::SVGAttribute(v18, 0x23u, 37);
  SVGAttributeMap::setAttribute((uint64_t)v1, v18, 1);
  v19 = operator new();
  SVGAttribute::SVGAttribute(v19, 0x22u, 2);
  SVGAttributeMap::setAttribute((uint64_t)v1, v19, 1);
  v20 = operator new();
  SVGAttribute::SVGAttribute(v20, 38, 4.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v20, 1);
  memset(v27, 0, sizeof(v27));
  v21 = operator new();
  SVGAttribute::SVGAttribute(v21, 12, (uint64_t)v27);
  SVGAttributeMap::setAttribute((uint64_t)v1, v21, 1);
  v22 = operator new();
  SVGAttribute::SVGAttribute(v22, 13, 0.0);
  SVGAttributeMap::setAttribute((uint64_t)v1, v22, 1);
  v23 = (SVGPaint *)operator new();
  SVGColor::SVGColor((SVGColor *)v28, (SVGColor *)"black", v24);
  SVGPaint::SVGPaint(v23, (const SVGColor *)v28);
  v25 = operator new();
  SVGAttribute::SVGAttribute(v25, 158, (uint64_t)v23);
  SVGAttributeMap::setAttribute((uint64_t)v1, v25, 1);
  CFRetained::release((CFTypeRef *)v23);
  return v1;
}

void sub_20676F650(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void SVGAttributeMap::setAttribute(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  BOOL v11;
  uint64_t *v12;
  SVGNode **v13;
  __int128 v14;

  v6 = *(_QWORD *)(a1 + 56);
  v7 = (uint64_t **)(a1 + 48);
  v8 = *(_DWORD *)(a2 + 48);
  if (v6)
  {
    v9 = a1 + 56;
    do
    {
      v10 = *(_DWORD *)(v6 + 32);
      v11 = v10 >= v8;
      if (v10 >= v8)
        v12 = (uint64_t *)v6;
      else
        v12 = (uint64_t *)(v6 + 8);
      if (v11)
        v9 = v6;
      v6 = *v12;
    }
    while (*v12);
    if (v9 != a1 + 56 && v8 >= *(_DWORD *)(v9 + 32))
    {
      CFRetained::release(*(CFTypeRef **)(v9 + 40));
      std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__remove_node_pointer(v7, (uint64_t *)v9);
      operator delete((void *)v9);
      v8 = *(_DWORD *)(a2 + 48);
    }
  }
  LODWORD(v14) = v8;
  *((_QWORD *)&v14 + 1) = a2;
  std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__emplace_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name const,SVGAttribute *>>(v7, (unsigned int *)&v14, &v14);
  if (!a3)
    CFRetained::retain((CFTypeRef *)a2);
  v13 = *(SVGNode ***)(a1 + 72);
  if (v13)
    SVGNode::updatedAttribute(v13, (SVGAttribute *)a2);
}

uint64_t **std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__emplace_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name const,SVGAttribute *>>(uint64_t **a1, unsigned int *a2, _OWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

CFTypeRef CFRetained::retain(CFTypeRef *this)
{
  return CFRetain(this[5]);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, double a3)
{
  _QWORD *v6;
  double *v7;
  void *__p[2];
  char v10;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v10 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  v6 = (_QWORD *)operator new();
  *v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  v7 = (double *)operator new(8uLL);
  *v6 = v7;
  *v7++ = a3;
  v6[1] = v7;
  v6[2] = v7;
  *(_QWORD *)(a1 + 88) = v6;
  return a1;
}

void sub_20676F96C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  uint64_t v4;

  v4 = v2;
  MEMORY[0x20BCFC038](v4, 0x80C40D6874129);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_20676FA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

void SVGPaint::SVGPaint(SVGPaint *this, const SVGColor *a2)
{
  _BYTE v4[40];
  void *__p[2];
  char v6;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EA8;
  *((_DWORD *)this + 12) = 1;
  SVGColor::SVGColor((uint64_t)this + 56, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  SVGColor::SVGColor((uint64_t)v4, (uint64_t)a2);
  SVGColor::operator=((uint64_t)this + 56, (uint64_t)v4);
}

void sub_20676FBF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  *(_QWORD *)v19 = off_24BFD8A68;
  if (*(char *)(v19 + 31) < 0)
    operator delete(*(void **)(v19 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t SVGColor::SVGColor(uint64_t result, int a2, double a3, double a4, double a5, double a6)
{
  int v6;

  *(_DWORD *)(result + 32) = 53;
  *(double *)result = a3;
  *(double *)(result + 8) = a4;
  *(double *)(result + 16) = a5;
  *(double *)(result + 24) = a6;
  if (a2 == 2)
  {
    v6 = 73;
  }
  else
  {
    if (a2 != 1)
      return result;
    v6 = 15;
  }
  *(_DWORD *)(result + 32) = v6;
  return result;
}

__n128 SVGColor::operator=(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  *(__n128 *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return result;
}

__n128 SVGColor::SVGColor(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 32) = 53;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  *(__n128 *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return result;
}

void SVGColor::SVGColor(SVGColor *this, SVGColor *a2, SVGColor *a3)
{
  *((_DWORD *)this + 8) = 53;
  if (!SVGColor::GetColorWithString(a2, (double *)this, a3))
  {
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
}

BOOL SVGColor::GetColorWithString(SVGColor *this, double *a2, SVGColor *a3)
{
  const char *v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  int8x8_t v9;
  uint64x2_t v10;
  double v11;
  size_t v13;
  const char *v14;
  size_t v15;
  unsigned int v16;
  const char *v17;
  char ColorValues;
  const char *v19;
  const char *v20;
  unsigned int v21;
  double v22;
  int8x8_t v23;
  uint64x2_t v24;
  const char *v25;
  const char *v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v45;
  float64x2_t v48;
  int8x16_t v49;
  int8x16_t v51;
  void *__p[2];
  char v54;
  char __s;
  char v56[3];
  char v57;
  char v58;
  _BYTE v59[66];

  *(_QWORD *)&v59[58] = *MEMORY[0x24BDAC8D0];
  v5 = (const char *)strlen((const char *)this);
  if (!SVGParser::StripLeadingTrailingWhitespace(this, v5, (uint64_t)&__s, (char *)0x40))
    return 0;
  if (NameToColorMap(void)::__onceToken != -1)
    dispatch_once(&NameToColorMap(void)::__onceToken, &__block_literal_global_1);
  v6 = NameToColorMap(void)::__colorMap;
  std::string::basic_string[abi:ne180100]<0>(__p, &__s);
  v7 = std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>(v6, (uint64_t)__p);
  if (v54 < 0)
    operator delete(__p[0]);
  if ((_QWORD *)(v6 + 8) != v7)
  {
    v8 = *((_DWORD *)v7 + 14);
    v9 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v8), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v10.i64[0] = v9.u32[0];
    v10.i64[1] = v9.u32[1];
    *(float64x2_t *)a2 = vdivq_f64(vcvtq_f64_u64(v10), (float64x2_t)vdupq_n_s64(0x406FE00000000000uLL));
    v11 = (double)v8 / 255.0;
LABEL_8:
    a2[2] = v11;
    a2[3] = 1.0;
    return 1;
  }
  v13 = strlen(&__s);
  if (__s == 35)
  {
    v15 = v13;
    if (v13 == 7 || v13 == 4)
    {
      *__error() = 0;
      v16 = strtoul(v56, 0, 16);
      if (!*__error())
      {
        if (v15 == 4)
          v21 = 15;
        else
          v21 = 255;
        v22 = 255.0;
        if (v15 == 4)
          v22 = 15.0;
        v23 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)vneg_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v15 == 4), 0x1FuLL)), (int8x8_t)0x400000008, (int8x8_t)0x800000010))), (int8x8_t)vdup_n_s32(v21));
        v24.i64[0] = v23.u32[0];
        v24.i64[1] = v23.u32[1];
        *(float64x2_t *)a2 = vdivq_f64(vcvtq_f64_u64(v24), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22, 0));
        v11 = (double)(v21 & v16) / v22;
        goto LABEL_8;
      }
    }
  }
  *a2 = 0.0;
  a2[1] = 0.0;
  a2[2] = 0.0;
  a2[3] = 1.0;
  if (SVGParser::StringBeginsWith((SVGParser *)&__s, "rgb(", v14))
  {
    ColorValues = ReadColorValues((SVGParser *)&v57, (SVGColor *)a2);
  }
  else if (SVGParser::StringBeginsWith((SVGParser *)&__s, "rgba(", v17))
  {
    ColorValues = ReadColorValues((SVGParser *)&v58, (SVGColor *)a2);
  }
  else
  {
    if (!SVGParser::StringBeginsWith((SVGParser *)&__s, "color(", v19))
    {
      if (SVGParser::StringBeginsWith((SVGParser *)&__s, "hsl(", v20))
      {
        if ((ReadColorValues((SVGParser *)&v57, (SVGColor *)a2) & 1) == 0)
          return 0;
      }
      else
      {
        if (!SVGParser::StringBeginsWith((SVGParser *)&__s, "hsla(", v25))
        {
          if (SVGParser::StringBeginsWith((SVGParser *)&__s, "none", v26))
          {
            a2[3] = 0.0;
            return 1;
          }
          return 0;
        }
        if (!ReadColorValues((SVGParser *)&v58, (SVGColor *)a2))
          return 0;
      }
      v27 = *a2;
      v28 = a2[1];
      v29 = a2[2];
      v30 = v28 + v29 - v29 * v28;
      v31 = v29 * (v28 + 1.0);
      if (v29 > 0.5)
        v31 = v30;
      v32 = -(v31 - v29 * 2.0);
      v33 = v31 - v32;
      v34 = (v27 + -3.33333333 - floor(v27 + -3.33333333)) * 6.0;
      if (v34 + -4.0 >= 0.0)
        v35 = v32;
      else
        v35 = v32 + (v31 - v32) * (4.0 - v34);
      if (v34 + -3.0 < 0.0)
        v35 = v31;
      v36 = v34 + -1.0;
      v37 = v32 + v33 * v34;
      if (v36 >= 0.0)
        v37 = v35;
      v38.f64[1] = *a2;
      v38.f64[0] = v27 + 3.33333333;
      v39 = vsubq_f64(v38, vrndmq_f64(v38));
      __asm { FMOV            V4.2D, #6.0 }
      v45 = vmulq_f64(v39, _Q4);
      __asm
      {
        FMOV            V4.2D, #-4.0
        FMOV            V6.2D, #4.0
      }
      v48 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32, 0);
      v49 = vbslq_s8((int8x16_t)vcltzq_f64(vaddq_f64(v45, _Q4)), (int8x16_t)vmlaq_n_f64(v48, vsubq_f64(_Q6, v45), v33), (int8x16_t)v48);
      __asm { FMOV            V6.2D, #-3.0 }
      v51 = vbslq_s8((int8x16_t)vcltzq_f64(vaddq_f64(v45, _Q6)), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v31, 0), v49);
      __asm { FMOV            V4.2D, #-1.0 }
      *(int8x16_t *)a2 = vbslq_s8((int8x16_t)vcltzq_f64(vaddq_f64(v45, _Q4)), (int8x16_t)vmlaq_n_f64(v48, v45, v33), v51);
      a2[2] = v37;
      return 1;
    }
    ColorValues = ReadColorValues((SVGParser *)v59, (SVGColor *)a2);
  }
  return (ColorValues & 1) != 0;
}

void sub_206770100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGParser::StripLeadingTrailingWhitespace(SVGParser *this, const char *a2, uint64_t a3, char *a4)
{
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t result;
  char *v13;
  uint64_t v14;
  const char *v15;
  unsigned int v16;
  unint64_t v17;

  if (!a2)
    return 0;
  v8 = 0;
  v9 = a3 + 1;
  v10 = MEMORY[0x24BDAC740];
  while (1)
  {
    v11 = v8[(_QWORD)this];
    if ((v11 & 0x80000000) != 0)
      break;
    if ((*(_DWORD *)(v10 + 4 * v11 + 60) & 0x4000) == 0)
      goto LABEL_10;
LABEL_7:
    if (a2 == ++v8)
      return 0;
  }
  if (__maskrune(v11, 0x4000uLL))
    goto LABEL_7;
LABEL_10:
  v13 = (char *)this - 1;
  v14 = v9 - (_QWORD)v8;
  v15 = v8;
  do
  {
    v16 = a2[(_QWORD)v13];
    if ((v16 & 0x80000000) != 0)
      result = __maskrune(v16, 0x4000uLL);
    else
      result = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x4000;
    --v13;
    ++v15;
    --v14;
  }
  while ((_DWORD)result);
  if (a2 + 1 != v15 && a2 - v15 + 2 <= (unint64_t)a4)
  {
    v17 = 0;
    do
    {
      *(_BYTE *)(a3 + v17) = v8[(_QWORD)this + v17];
      ++v17;
    }
    while (v17 < a2 - v15 + 1);
    a2[v14] = 0;
    return 1;
  }
  return result;
}

void SVGNode::updatedAttribute(SVGNode **this, SVGAttribute *a2)
{
  uint64_t v3;
  char *v4;

  if (*((_DWORD *)a2 + 12) == 31)
  {
    v3 = SVGAttribute::stringValue(a2);
    if (this[6])
    {
      if (*(char *)(v3 + 23) >= 0)
        v4 = (char *)v3;
      else
        v4 = *(char **)v3;
      SVGNode::updateChildIdentifer(this[6], (SVGNode *)this, v4);
    }
  }
}

void SVGPaint::SVGPaint(SVGPaint *this)
{
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EA8;
  *((_DWORD *)this + 12) = 0;
  SVGColor::SVGColor((uint64_t)this + 56, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
}

void sub_20677032C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void sub_206770434(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  MEMORY[0x20BCFC038](v2, 0x80C40D6874129);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, _QWORD *a3)
{
  void **v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  __int128 v16;
  uint64_t v17;
  void *__p[2];
  char v19;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v19 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  v6 = (void **)(a1 + 56);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  v7 = (_QWORD *)operator new();
  v8 = *a3;
  v9 = a3[1];
  v10 = a3[2];
  v11 = a3[3];
  v12 = a3[4];
  v13 = a3[5];
  v7[1] = 0;
  v7[2] = 0;
  *v7 = 0;
  v14 = operator new(0x30uLL);
  v7[1] = v14 + 6;
  v7[2] = v14 + 6;
  *v14 = v8;
  v14[1] = v9;
  v14[2] = v10;
  v14[3] = v11;
  v14[4] = v12;
  v14[5] = v13;
  *v7 = v14;
  *(_QWORD *)(a1 + 88) = v7;
  SVGParser::FormatString((SVGParser *)"matrix(%g %g %g %g %g %g)", &v16, *a3, a3[1], a3[2], a3[3], a3[4], a3[5]);
  if (*(char *)(a1 + 79) < 0)
    operator delete(*v6);
  *(_OWORD *)v6 = v16;
  *(_QWORD *)(a1 + 72) = v17;
  return a1;
}

void sub_2067705DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;
  void **v24;

  if (*(char *)(v23 + 79) < 0)
    operator delete(*v24);
  *(_QWORD *)v23 = off_24BFD8A68;
  if (*(char *)(v23 + 31) < 0)
    operator delete(*(void **)(v23 + 8));
  _Unwind_Resume(exception_object);
}

_QWORD *SVGParser::FormatString@<X0>(SVGParser *this@<X0>, _QWORD *a2@<X8>, ...)
{
  char v4[8];
  va_list va;

  va_start(va, a2);
  va_copy(v4, va);
  return SVGParser::FormatString(this, (va_list *)v4, a2);
}

_QWORD *SVGParser::FormatString@<X0>(SVGParser *this@<X0>, va_list *a2@<X1>, _QWORD *a3@<X8>)
{
  const char *v5;
  char __str[1024];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (vsnprintf(__str, 0x400uLL, (const char *)this, *a2) >= 0x401)
    SVGUtilities::error((SVGUtilities *)"Invalid format string or arguments provided", v5);
  return std::string::basic_string[abi:ne180100]<0>(a3, __str);
}

_QWORD *std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, a3, (uint64_t)(v4 + 4)))break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

os_unfair_lock_s *CGSVGAttributeGetAtom(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;
  uint32_t v4;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v4 = 0;
    result = (os_unfair_lock_s *)SVGAttribute::nameValue(result, &v4);
    if ((_DWORD)result)
    {
      *(_DWORD *)a2 = v4;
      return (os_unfair_lock_s *)1;
    }
  }
  return result;
}

BOOL SVGAttribute::nameValue(os_unfair_lock_s *a1, uint32_t *a2)
{
  const char *v4;
  _BOOL8 v5;
  os_unfair_lock_t v7;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v7, a1 + 27);
  v5 = SVGAttribute::resolveAsName((SVGAttribute *)a1, v4);
  if (v5)
    *a2 = a1[22]._os_unfair_lock_opaque;
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v7);
  return v5;
}

void sub_206770840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::resolveAsName(SVGAttribute *this, const char *a2)
{
  int v2;
  SVGAtom *v4;

  v2 = *((_DWORD *)this + 20);
  if (v2 != 2)
  {
    if (*((char *)this + 79) < 0)
    {
      if (*((_QWORD *)this + 8))
      {
        *((_DWORD *)this + 20) = 2;
        v4 = (SVGAtom *)*((_QWORD *)this + 7);
        goto LABEL_7;
      }
    }
    else if (*((_BYTE *)this + 79))
    {
      v4 = (SVGAttribute *)((char *)this + 56);
      *((_DWORD *)this + 20) = 2;
LABEL_7:
      *((_DWORD *)this + 22) = SVGAtom::ToName(v4, a2);
      v2 = *((_DWORD *)this + 20);
    }
  }
  return v2 == 2;
}

uint64_t SVGAttribute::floatValue(os_unfair_lock_s *this, double *a2)
{
  double *v4;
  uint64_t v5;
  os_unfair_lock_t v7;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v7, this + 27);
  if (!SVGAttribute::resolveAsFloats((SVGAttribute *)this)
    || (v4 = **(double ***)&this[22]._os_unfair_lock_opaque,
        *(double **)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8) == v4))
  {
    v5 = 0;
  }
  else
  {
    *a2 = *v4;
    v5 = 1;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v7);
  return v5;
}

void sub_206770930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

void *CGSVGNodeEnumerate(uint64_t a1, const char *a2)
{
  void *result;
  _QWORD v4[5];

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    v4[0] = MEMORY[0x24BDAC760];
    v4[1] = 0x40000000;
    v4[2] = __CGSVGNodeEnumerate_block_invoke;
    v4[3] = &unk_24BFD9470;
    v4[4] = a2;
    return (void *)SVGNode::enumerate((uint64_t)result, (uint64_t)v4);
  }
  return result;
}

CGPath *CGSVGNodeCreateCompoundCGPath(uint64_t a1, const char *a2)
{
  void *v3;
  void *v4;
  _QWORD *v5;
  uint64_t v6;
  const char *v7;
  __int128 v8;
  const char *v9;
  CGPath *Mutable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CGPath *CGPath;
  _QWORD v16[9];
  _QWORD v17[3];
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  __n128 (*v22)(_QWORD *, uint64_t);
  void (*v23)(uint64_t);
  void *__p;
  void *v25;
  uint64_t v26;
  _QWORD v27[5];
  void *v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[5];
  __int128 v32;
  __int128 v33;
  __int128 v34;

  v3 = CFRetained::getObject<SVGNode>(a1, a2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = v3;
  do
  {
    v6 = (uint64_t)v5;
    v5 = (_QWORD *)v5[6];
  }
  while (v5);
  v31[2] = 0x5802000000;
  v7 = (const char *)MEMORY[0x24BDBD8B8];
  if (a2)
    v7 = a2;
  v8 = *((_OWORD *)v7 + 1);
  v32 = *(_OWORD *)v7;
  v31[0] = 0;
  v31[1] = v31;
  v31[3] = __Block_byref_object_copy__2;
  v31[4] = __Block_byref_object_dispose__2;
  v33 = v8;
  v34 = *((_OWORD *)v7 + 2);
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x4002000000;
  v27[3] = __Block_byref_object_copy__1;
  v27[4] = __Block_byref_object_dispose__2;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v19 = 0;
  v20 = &v19;
  v21 = 0x4002000000;
  v22 = __Block_byref_object_copy__3;
  v23 = __Block_byref_object_dispose__4;
  v25 = 0;
  v26 = 0;
  __p = 0;
  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x2000000000;
  v18 = 0;
  v16[0] = MEMORY[0x24BDAC760];
  v16[1] = 0x40000000;
  v16[2] = __CGSVGNodeCreateCompoundCGPath_block_invoke;
  v16[3] = &unk_24BFD9498;
  v16[4] = v27;
  v16[5] = v31;
  v16[7] = &v19;
  v16[8] = v4;
  v16[6] = v17;
  SVGNode::enumerate(v6, (uint64_t)v16);
  if (v20[6] == v20[5])
  {
    Mutable = 0;
  }
  else
  {
    Mutable = CGPathCreateMutable();
    v11 = v20[5];
    v12 = v20[6];
    while (v11 != v12)
    {
      v13 = *(_QWORD *)(v11 + 48);
      CGPath = CGSVGPathCreateCGPath(*(_QWORD *)(v13 + 40), v9);
      CFRetained::release((CFTypeRef *)v13);
      CGPathAddPath(Mutable, (const CGAffineTransform *)v11, CGPath);
      CGPathRelease(CGPath);
      v11 += 56;
    }
  }
  _Block_object_dispose(v17, 8);
  _Block_object_dispose(&v19, 8);
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
  _Block_object_dispose(v27, 8);
  if (v28)
  {
    v29 = v28;
    operator delete(v28);
  }
  _Block_object_dispose(v31, 8);
  return Mutable;
}

void sub_206770BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36)
{
  uint64_t v36;

  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a22, 8);
  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose(&a30, 8);
  if (a35)
  {
    a36 = (uint64_t)a35;
    operator delete(a35);
  }
  _Block_object_dispose((const void *)(v36 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t SVGNode::enumerate(uint64_t a1, uint64_t a2)
{
  char v3;

  v3 = 0;
  return EnumerateNode(a1, a2, &v3);
}

uint64_t EnumerateNode(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;

  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _BYTE *))(a2 + 16))(a2, a1, 0, a3);
  v7 = *(uint64_t **)(a1 + 88);
  v8 = *(uint64_t **)(a1 + 96);
  while (v7 != v8)
  {
    if (*a3)
      return result;
    v9 = *v7++;
    result = EnumerateNode(v9, a2, a3);
  }
  if (!*a3)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a2 + 16))(a2, a1, 1, a3);
  return result;
}

CGPath *CGSVGPathCreateCGPath(uint64_t a1, const char *a2)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  SVGPath *v4;
  CGPath *Mutable;
  double v6;
  double v7;
  const char *v8;
  _QWORD *v9;
  const char *v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  const char *v15;
  double x;
  double y;
  _QWORD *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  const char *v30;
  int v31;
  uint64_t v32;
  double v33;
  double v34;
  double v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  const char *v39;
  unint64_t v40;
  double v41;
  const char *v42;
  double v43;
  unsigned int v44;
  double v45;
  double v46;
  const char *v47;
  _QWORD *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  double v52;
  double v53;
  _QWORD *v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  _QWORD *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  const char *v71;
  unint64_t v72;
  double v73;
  const char *v74;
  double v75;
  unsigned int v76;
  double v77;
  double v78;
  CGPoint CurrentPoint;
  unint64_t v80;
  unint64_t v81;
  const char *i;
  double v83;
  double v84;
  double v85;
  const char *v86;
  double v87;
  unsigned int v88;
  double v89;
  double v90;
  double v91;
  double v92;
  const char *v93;
  double v94;
  double v95;
  double v96;
  const char *v97;
  double v98;
  unsigned int v99;
  double v100;
  double v101;
  CGFloat v102;
  uint64_t v103;
  _BOOL4 v104;
  double v105;
  double v106;
  double v107;
  __double2 v108;
  double v109;
  double v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v123;
  double v124;
  double sinval;
  double cosval;
  double v127;
  CGFloat v128;
  double v129;
  __int128 v130;
  double v131;
  CGFloat v132;
  const char *v133;
  double FloatAtIndex;
  double v135;
  double v136;
  const char *v137;
  double v138;
  int v139;
  const char *v140;
  unint64_t v141;
  double v142;
  const char *v143;
  double v144;
  uint64_t v146;
  uint64_t v147;
  double v148;
  double v149;
  uint64_t v150;
  SVGPath *v151;
  double v152;
  double startAngle;
  double v154;
  CGFloat v155;
  CGFloat dx;
  CGFloat sx;
  double angle;
  unint64_t v159;
  double v160;
  double v161;
  double v162;
  double sy;
  CGFloat sya;
  CGAffineTransform v165;
  CGAffineTransform v166;
  CGAffineTransform v167;
  CGAffineTransform v168;
  CGAffineTransform matrix;
  CGVector v170;
  CGVector v171;
  CGVector v172;
  CGVector v173;

  v2 = a1;
  v3 = (os_unfair_lock_s *)CFRetained::getObject<SVGPath>(a1, a2);
  if (!v3)
    return 0;
  v4 = (SVGPath *)v3;
  Mutable = (CGPath *)SVGPath::copyCachedCGPath(v3);
  if (!Mutable)
  {
    v151 = v4;
    v6 = *MEMORY[0x24BDBEFB0];
    v7 = *(double *)(MEMORY[0x24BDBEFB0] + 8);
    Mutable = CGPathCreateMutable();
    v9 = CFRetained::getObject<SVGPath>(v2, v8);
    if (v9)
    {
      v11 = v9[7] - v9[6];
      if (v11)
      {
        v12 = 0;
        v13 = 0;
        v14 = v11 >> 3;
        v15 = "Unhandled operator '%c'\n";
        x = v6;
        y = v7;
        v150 = v2;
        v147 = v11 >> 3;
        while (1)
        {
          v18 = CFRetained::getObject<SVGPath>(v2, v10);
          if (v18 && (v20 = v18[6], v12 < (v18[7] - v20) >> 3))
            v21 = *(_QWORD *)(*(_QWORD *)(v20 + 8 * v12) + 40);
          else
            v21 = 0;
          v22 = (unsigned int *)CFRetained::getObject<SVGPathCommand>(v21, v19);
          if (v22)
            break;
          v23 = 0;
LABEL_14:
          v146 = v23;
          v24 = (char *)v15;
LABEL_15:
          SVGUtilities::log((SVGUtilities *)v24, v10, v146);
LABEL_104:
          ++v12;
          v13 = v23;
          if (v12 == v14)
            goto LABEL_175;
        }
        v23 = v22[12];
        if ((int)v23 <= 96)
        {
          switch((int)v23)
          {
            case 'A':
              goto LABEL_48;
            case 'B':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'I':
            case 'J':
            case 'K':
            case 'N':
            case 'O':
            case 'P':
            case 'R':
            case 'U':
              goto LABEL_14;
            case 'C':
              goto LABEL_54;
            case 'H':
            case 'V':
              goto LABEL_17;
            case 'L':
            case 'M':
              goto LABEL_30;
            case 'Q':
              goto LABEL_59;
            case 'S':
              goto LABEL_63;
            case 'T':
              goto LABEL_67;
            default:
              if ((_DWORD)v23 != 90)
                goto LABEL_14;
              goto LABEL_87;
          }
        }
        switch((int)v23)
        {
          case 'a':
LABEL_48:
            v48 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (!v48)
              goto LABEL_52;
            v49 = (uint64_t *)v48[7];
            if (!v49)
              goto LABEL_52;
            v51 = *v49;
            v50 = *(_QWORD *)(v48[7] + 8);
            if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v50 - v51) >> 3)) > 0x2492492492492492)
            {
              SVGUtilities::log((SVGUtilities *)"A/a command was given the wrong number of floats.\n", v10);
LABEL_52:
              v52 = y;
              v53 = x;
              goto LABEL_53;
            }
            if (v50 == v51)
              goto LABEL_52;
            v93 = 0;
            v159 = (v50 - v51) >> 3;
            v148 = v7;
            v149 = v6;
            break;
          case 'b':
          case 'd':
          case 'e':
          case 'f':
          case 'g':
          case 'i':
          case 'j':
          case 'k':
          case 'n':
          case 'o':
          case 'p':
          case 'r':
          case 'u':
            goto LABEL_14;
          case 'c':
LABEL_54:
            v54 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (v54)
            {
              v55 = (uint64_t *)v54[7];
              if (v55)
              {
                v57 = *v55;
                v56 = *(_QWORD *)(v54[7] + 8);
                v58 = (v56 - v57) >> 3;
                if (__ROR8__(0xAAAAAAAAAAAAAAABLL * v58, 1) <= 0x2AAAAAAAAAAAAAAAuLL)
                {
                  if (v56 != v57)
                  {
                    v133 = 0;
                    do
                    {
                      FloatAtIndex = CGSVGPathCommandGetFloatAtIndex(v21, v133);
                      v135 = CGSVGPathCommandGetFloatAtIndex(v21, v133 + 1);
                      v6 = CGSVGPathCommandGetFloatAtIndex(v21, v133 + 2);
                      v7 = CGSVGPathCommandGetFloatAtIndex(v21, v133 + 3);
                      v136 = CGSVGPathCommandGetFloatAtIndex(v21, v133 + 4);
                      v137 = v133 + 5;
                      v138 = CGSVGPathCommandGetFloatAtIndex(v21, v137);
                      if ((v23 - 97) > 0x15)
                      {
                        x = v136;
                        y = v138;
                      }
                      else
                      {
                        v139 = 1 << (v23 - 97);
                        if ((v139 & 0x2D1885) != 0)
                        {
                          FloatAtIndex = x + FloatAtIndex;
                          v135 = y + v135;
                          v6 = x + v6;
                          v7 = y + v7;
                          x = x + v136;
                        }
                        else
                        {
                          x = v136;
                        }
                        if ((v139 & 0x2D1885) != 0)
                          y = y + v138;
                        else
                          y = v138;
                      }
                      CGPathAddCurveToPoint(Mutable, 0, FloatAtIndex, v135, v6, v7, x, y);
                      v133 = v137 + 1;
                    }
                    while ((unint64_t)v133 < v58);
                  }
                }
                else
                {
                  SVGUtilities::log((SVGUtilities *)"C/c command was given the wrong number of points.\n", v10);
                }
                v14 = v147;
              }
            }
            goto LABEL_104;
          case 'h':
          case 'v':
LABEL_17:
            v25 = v15;
            v26 = v14;
            v27 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (v27)
            {
              v28 = (_QWORD *)v27[7];
              if (v28)
              {
                v29 = *(_QWORD *)(v27[7] + 8) - *v28;
                if (v29)
                {
                  v30 = 0;
                  v31 = v23 & 0xFFFFFFDF;
                  v32 = v29 >> 3;
                  do
                  {
                    v33 = CGSVGPathCommandGetFloatAtIndex(v21, v30);
                    if ((((v23 - 97) < 0x16) & (0x2D1885u >> (v23 - 97))) != 0)
                    {
                      v34 = y + v33;
                      v35 = x + v33;
                      if (v31 == 72)
                        x = v35;
                      else
                        y = v34;
                    }
                    else if (v31 == 72)
                    {
                      x = v33;
                    }
                    else
                    {
                      y = v33;
                    }
                    CGPathAddLineToPoint(Mutable, 0, x, y);
                    ++v30;
                  }
                  while ((const char *)v32 != v30);
                }
              }
            }
            v14 = v26;
            v15 = v25;
            v2 = v150;
            goto LABEL_104;
          case 'l':
          case 'm':
LABEL_30:
            v36 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (!v36)
              goto LABEL_104;
            v37 = (_QWORD *)v36[7];
            if (!v37)
              goto LABEL_104;
            v38 = *(_QWORD *)(v36[7] + 8) - *v37;
            if (!v38)
              goto LABEL_104;
            v39 = 0;
            v40 = v38 >> 3;
            do
            {
              v41 = CGSVGPathCommandGetFloatAtIndex(v21, v39);
              v42 = v39 + 1;
              v43 = CGSVGPathCommandGetFloatAtIndex(v21, v42);
              v44 = v23 - 97;
              v45 = x + v41;
              v46 = y + v43;
              if (((1 << (v23 - 97)) & 0x2D1885) == 0)
              {
                v45 = v41;
                v46 = v43;
              }
              if (v44 <= 0x15)
                x = v45;
              else
                x = v41;
              if (v44 <= 0x15)
                y = v46;
              else
                y = v43;
              v47 = v42 - 1;
              if ((v23 & 0xFFFFFFDF) != 0x4D || v47)
                CGPathAddLineToPoint(Mutable, 0, x, y);
              else
                CGPathMoveToPoint(Mutable, 0, x, y);
              v39 = v47 + 2;
            }
            while ((unint64_t)v39 < v40);
            v14 = v147;
            goto LABEL_103;
          case 'q':
LABEL_59:
            v59 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (!v59)
              goto LABEL_104;
            v60 = (uint64_t *)v59[7];
            if (!v60)
              goto LABEL_104;
            v62 = *v60;
            v61 = v60[1];
            v63 = v61 - *v60;
            if ((v63 & 0x18) != 0)
            {
              v24 = "Q/q command was given the wrong number of points.\n";
              goto LABEL_15;
            }
            if (v61 == v62)
              goto LABEL_104;
            v70 = v14;
            v140 = 0;
            v141 = v63 >> 3;
            do
            {
              v6 = CGSVGPathCommandGetFloatAtIndex(v21, v140);
              v7 = CGSVGPathCommandGetFloatAtIndex(v21, v140 + 1);
              v142 = CGSVGPathCommandGetFloatAtIndex(v21, v140 + 2);
              v143 = v140 + 3;
              v144 = CGSVGPathCommandGetFloatAtIndex(v21, v143);
              if ((_DWORD)v23 == 113)
              {
                v6 = x + v6;
                v7 = y + v7;
                x = x + v142;
              }
              else
              {
                x = v142;
              }
              if ((_DWORD)v23 == 113)
                y = y + v144;
              else
                y = v144;
              CGPathAddQuadCurveToPoint(Mutable, 0, v6, v7, x, y);
              v140 = v143 + 1;
            }
            while ((unint64_t)v140 < v141);
            goto LABEL_102;
          case 's':
LABEL_63:
            v64 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (v64 && (v65 = (_QWORD *)v64[7]) != 0)
            {
              v66 = v65[1] - *v65;
              if ((v66 & 0x18) != 0)
              {
                v24 = "S/s command was given the wrong number of points.\n";
                goto LABEL_15;
              }
              v70 = v14;
              v80 = v66 >> 3;
            }
            else
            {
              v70 = v14;
              v80 = 0;
            }
            HIDWORD(v81) = v13 - 67;
            LODWORD(v81) = v13 - 67;
            if ((v81 >> 4) >= 4)
            {
              v7 = y;
              v6 = x;
            }
            if (v80)
            {
              for (i = 0; (unint64_t)i < v80; i = v86 + 1)
              {
                v83 = x + x - v6;
                v84 = y + y - v7;
                v6 = CGSVGPathCommandGetFloatAtIndex(v21, i);
                v7 = CGSVGPathCommandGetFloatAtIndex(v21, i + 1);
                v85 = CGSVGPathCommandGetFloatAtIndex(v21, i + 2);
                v86 = i + 3;
                v87 = CGSVGPathCommandGetFloatAtIndex(v21, v86);
                v88 = v23 - 97;
                v89 = x + v6;
                v90 = y + v7;
                v91 = x + v85;
                v92 = y + v87;
                if (((1 << (v23 - 97)) & 0x2D1885) == 0)
                {
                  v89 = v6;
                  v90 = v7;
                  v91 = v85;
                  v92 = v87;
                }
                if (v88 > 0x15)
                {
                  x = v85;
                }
                else
                {
                  v6 = v89;
                  v7 = v90;
                  x = v91;
                }
                if (v88 <= 0x15)
                  y = v92;
                else
                  y = v87;
                CGPathAddCurveToPoint(Mutable, 0, v83, v84, v6, v7, x, y);
              }
            }
LABEL_102:
            v14 = v70;
LABEL_103:
            v15 = "Unhandled operator '%c'\n";
            goto LABEL_104;
          case 't':
LABEL_67:
            if ((v13 - 81) > 0x23 || ((1 << (v13 - 81)) & 0x900000009) == 0)
            {
              v7 = y;
              v6 = x;
            }
            v67 = CFRetained::getObject<SVGPathCommand>(v21, v10);
            if (!v67)
              goto LABEL_104;
            v68 = (_QWORD *)v67[7];
            if (!v68)
              goto LABEL_104;
            v69 = *(_QWORD *)(v67[7] + 8) - *v68;
            if (!v69)
              goto LABEL_104;
            v70 = v14;
            v71 = 0;
            v72 = v69 >> 3;
            do
            {
              v6 = x + x - v6;
              v7 = y + y - v7;
              v73 = CGSVGPathCommandGetFloatAtIndex(v21, v71);
              v74 = v71 + 1;
              v75 = CGSVGPathCommandGetFloatAtIndex(v21, v74);
              v76 = v23 - 97;
              v77 = x + v73;
              v78 = y + v75;
              if (((1 << (v23 - 97)) & 0x2D1885) == 0)
              {
                v77 = v73;
                v78 = v75;
              }
              if (v76 <= 0x15)
                x = v77;
              else
                x = v73;
              if (v76 <= 0x15)
                y = v78;
              else
                y = v75;
              CGPathAddQuadCurveToPoint(Mutable, 0, v6, v7, x, y);
              v71 = v74 + 1;
            }
            while ((unint64_t)v71 < v72);
            goto LABEL_102;
          default:
            if ((_DWORD)v23 != 122)
              goto LABEL_14;
LABEL_87:
            CGPathCloseSubpath(Mutable);
            CurrentPoint = CGPathGetCurrentPoint(Mutable);
            x = CurrentPoint.x;
            y = CurrentPoint.y;
            v7 = CurrentPoint.y;
            v6 = CurrentPoint.x;
            goto LABEL_104;
        }
        while (1)
        {
          v94 = CGSVGPathCommandGetFloatAtIndex(v21, v93);
          sy = CGSVGPathCommandGetFloatAtIndex(v21, v93 + 1);
          v95 = CGSVGPathCommandGetFloatAtIndex(v21, v93 + 5);
          v96 = CGSVGPathCommandGetFloatAtIndex(v21, v93 + 6);
          v160 = CGSVGPathCommandGetFloatAtIndex(v21, v93 + 2);
          v162 = CGSVGPathCommandGetFloatAtIndex(v21, v93 + 3);
          v98 = CGSVGPathCommandGetFloatAtIndex(v21, v93 + 4);
          v99 = v23 - 97;
          v100 = x + v95;
          v101 = y + v96;
          if (((1 << (v23 - 97)) & 0x2D1885) == 0)
          {
            v101 = v96;
            v100 = v95;
          }
          if (v99 <= 0x15)
            v102 = v101;
          else
            v102 = v96;
          if (v99 <= 0x15)
            v95 = v100;
          if (v94 != 0.0 && sy != 0.0)
            break;
          SVGUtilities::log((SVGUtilities *)"Warning: ellipses path has invalid rx or ry value. Drawing line.\n", v97);
          CGPathAddLineToPoint(Mutable, 0, v95, v102);
          v52 = y;
          v53 = x;
LABEL_144:
          v93 += 7;
          if ((unint64_t)v93 >= v159)
          {
LABEL_53:
            y = v52;
            x = v53;
            goto LABEL_104;
          }
        }
        v103 = v14;
        v104 = v98 > 0.0;
        v105 = fabs(sy);
        v106 = fabs(v94);
        v107 = v160 / 180.0 * 3.14159265;
        angle = v107;
        v161 = v98;
        v108 = __sincos_stret(v107);
        v154 = v95;
        v155 = v102;
        v109 = x - v95;
        v110 = v108.__sinval * (y - v102) * 0.5 + v108.__cosval * (x - v95) * 0.5;
        v111 = v108.__cosval * (y - v102) * 0.5 - v109 * v108.__sinval * 0.5;
        v112 = v110 * v110 / (v94 * v94) + v111 * v111 / (sy * sy);
        v113 = sqrt(v112);
        if (v112 <= 1.0)
          v114 = 1.0;
        else
          v114 = v113;
        v115 = v105 * v114;
        v116 = v106 * v114;
        v117 = sqrt((v115 * (v116 * v116) * v115 - v111 * (v116 * v116) * v111 - v110 * (v115 * v115) * v110)/ (v110 * (v110 * (v115 * v115)) + v111 * (v116 * v116) * v111));
        if (v162 > 0.0 == v104)
          v117 = -v117;
        v118 = v111 * v116 / v115 * v117;
        v119 = -(v115 * v110) / v116 * v117;
        v172.dx = (v110 - v118) / v116;
        v172.dy = (v111 - v119) / v115;
        dx = v172.dx;
        v170.dx = 1.0;
        v170.dy = 0.0;
        Vec2Angle(v170, v172);
        startAngle = v120;
        v121 = -v110;
        v122 = v118;
        sx = v116;
        v173.dx = (v121 - v118) / v116;
        v152 = v119;
        sya = v115;
        v173.dy = (-v111 - v119) / v115;
        v171.dy = (v111 - v119) / v115;
        v171.dx = dx;
        Vec2Angle(v171, v173);
        v124 = v123;
        if (v161 <= 0.0)
        {
          if (v162 > 0.0 || v123 <= 0.0)
          {
            v14 = v103;
            v15 = "Unhandled operator '%c'\n";
            v53 = v154;
            v52 = v155;
            cosval = v108.__cosval;
            sinval = v108.__sinval;
            v7 = v148;
            v6 = v149;
            v127 = v152;
            if (v123 <= -6.28318531)
            {
              do
                v124 = v124 + 6.28318531;
              while (v124 <= -6.28318531);
            }
LABEL_134:
            v128 = (x + v53) * 0.5 + cosval * v122 - sinval * v127;
            v129 = cosval * v127 + sinval * v122;
            v130 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
            *(_OWORD *)&matrix.a = *MEMORY[0x24BDBD8B8];
            *(_OWORD *)&matrix.c = v130;
            *(_OWORD *)&matrix.tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
            *(_OWORD *)&v167.a = *(_OWORD *)&matrix.a;
            *(_OWORD *)&v167.c = v130;
            *(_OWORD *)&v167.tx = *(_OWORD *)&matrix.tx;
            CGAffineTransformTranslate(&v168, &v167, v128, (y + v52) * 0.5 + v129);
            matrix = v168;
            v166 = v168;
            CGAffineTransformRotate(&v168, &v166, angle);
            matrix = v168;
            v165 = v168;
            CGAffineTransformScale(&v168, &v165, sx, sya);
            matrix = v168;
            if (v162 <= 0.0 || v161 <= 0.0 || v124 >= 0.0)
            {
              if (v162 <= 0.0 || v161 > 0.0 || v124 <= 0.0)
              {
                v132 = startAngle;
                if (v124 == 0.0)
                  v124 = 6.28318531;
                goto LABEL_143;
              }
              v131 = -6.28318531;
            }
            else
            {
              v131 = 6.28318531;
            }
            v124 = v124 + v131;
            v132 = startAngle;
LABEL_143:
            CGPathAddRelativeArc(Mutable, &matrix, 0.0, 0.0, 1.0, v132, v124);
            y = v52;
            x = v53;
            goto LABEL_144;
          }
          v124 = v123 + -6.28318531;
          v14 = v103;
          v15 = "Unhandled operator '%c'\n";
          v53 = v154;
          v52 = v155;
          cosval = v108.__cosval;
          sinval = v108.__sinval;
          v7 = v148;
          v6 = v149;
        }
        else
        {
          v14 = v103;
          if (v123 >= 0.0)
          {
            v53 = v154;
            v52 = v155;
            v7 = v148;
            v6 = v149;
          }
          else
          {
            v53 = v154;
            v52 = v155;
            v7 = v148;
            v6 = v149;
            do
              v124 = v124 + 6.28318531;
            while (v124 < 0.0);
          }
          v124 = fmod(v124, 6.28318531);
          v15 = "Unhandled operator '%c'\n";
          cosval = v108.__cosval;
          sinval = v108.__sinval;
        }
        v127 = v152;
        goto LABEL_134;
      }
    }
LABEL_175:
    SVGPath::setCGPath((os_unfair_lock_s *)v151, Mutable);
  }
  return Mutable;
}

double CGSVGPathCommandGetFloatAtIndex(uint64_t a1, const char *a2)
{
  _QWORD *v3;
  double result;
  uint64_t *v5;
  uint64_t v6;

  v3 = CFRetained::getObject<SVGPathCommand>(a1, a2);
  result = 0.0;
  if (v3)
  {
    v5 = (uint64_t *)v3[7];
    if (v5)
    {
      v6 = *v5;
      if ((unint64_t)a2 < (*(_QWORD *)(v3[7] + 8) - v6) >> 3)
        return *(double *)(v6 + 8 * (_QWORD)a2);
    }
  }
  return result;
}

void *CFRetained::getObject<SVGPathCommand>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void *CFRetained::getObject<SVGPath>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

_OWORD *SVGShapeNode::createSVGPath(SVGShapeNode *this)
{
  _OWORD *v2;
  __int128 v3;
  CGPath *CGPath;
  const CGPath *v5;
  const CGPath *v6;
  const char *v7;
  __int128 v8;
  _OWORD v10[3];
  _OWORD v11[3];

  if (*((_DWORD *)this + 72) == 42)
  {
    v2 = SVGShapeNode::path(this);
    if (v2)
    {
      SVGNode::transform(this, v11);
      v3 = v11[1];
      v2[5] = v11[0];
      v2[6] = v3;
      v2[7] = v11[2];
      CFRetained::retain((uint64_t)v2);
    }
  }
  else
  {
    CGPath = SVGShapeNode::createCGPath(this);
    v5 = CGPath;
    if (CGPath)
    {
      v6 = CGSVGPathCreateWithCGPath(CGPath);
      v2 = CFRetained::getObject<SVGPath>((uint64_t)v6, v7);
      SVGNode::transform(this, v10);
      v8 = v10[1];
      v2[5] = v10[0];
      v2[6] = v8;
      v2[7] = v10[2];
    }
    else
    {
      v2 = 0;
    }
    CGPathRelease(v5);
  }
  return v2;
}

double SVGNode::transform@<D0>(SVGNode *this@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  __int128 v8;
  CGAffineTransform v10;

  v3 = MEMORY[0x24BDBD8B8];
  v4 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *a2 = *MEMORY[0x24BDBD8B8];
  a2[1] = v4;
  v5 = *(_OWORD *)(v3 + 32);
  a2[2] = v5;
  v6 = *((_QWORD *)this + 7);
  if (v6)
  {
    v7 = (os_unfair_lock_s *)SVGAttributeMap::attribute(v6, 0x3Fu);
    if (v7)
    {
      if (SVGAttribute::transformValue(v7, &v10))
      {
        v8 = *(_OWORD *)&v10.c;
        *a2 = *(_OWORD *)&v10.a;
        a2[1] = v8;
        *(CGFloat *)&v5 = v10.tx;
        a2[2] = *(_OWORD *)&v10.tx;
      }
    }
  }
  return *(double *)&v5;
}

const void *SVGPath::copyCachedCGPath(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  const void *v3;

  v2 = this + 32;
  os_unfair_lock_lock(this + 32);
  v3 = *(const void **)&this[18]._os_unfair_lock_opaque;
  if (v3)
    CFRetain(v3);
  os_unfair_lock_unlock(v2);
  return v3;
}

SVGPath *SVGShapeNode::path(SVGShapeNode *this)
{
  SVGPath *result;
  SVGPath *v2;

  result = (SVGPath *)SVGAttributeMap::attribute(*((_QWORD *)this + 7), 0xBu);
  v2 = 0;
  if (result)
  {
    if (SVGAttribute::pathValue((os_unfair_lock_s *)result, &v2))
      return v2;
    else
      return 0;
  }
  return result;
}

BOOL SVGAttribute::pathValue(os_unfair_lock_s *this, SVGPath **a2)
{
  const char *v4;
  _BOOL8 v5;
  os_unfair_lock_t v7;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v7, this + 27);
  v5 = SVGAttribute::resolveAsPath((SVGAttribute *)this, v4);
  if (v5)
    *a2 = *(SVGPath **)&this[22]._os_unfair_lock_opaque;
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v7);
  return v5;
}

void sub_20677208C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::resolveAsPath(SVGAttribute *this, const char *a2)
{
  SVGParser *v3;
  SVGPath *v4;

  if (*((_DWORD *)this + 20) == 4)
    return 1;
  v3 = (SVGAttribute *)((char *)this + 56);
  if (*((char *)this + 79) < 0)
    v3 = *(SVGParser **)v3;
  v4 = SVGParser::ParseCommandList(v3, a2);
  if (v4)
  {
    *((_DWORD *)this + 20) = 4;
    *((_QWORD *)this + 11) = v4;
    return 1;
  }
  return *((_DWORD *)this + 20) == 4;
}

void SVGPath::setCGPath(os_unfair_lock_s *this, const CGPath *a2)
{
  os_unfair_lock_s *v4;
  const void *v5;

  v4 = this + 32;
  os_unfair_lock_lock(this + 32);
  v5 = *(const void **)&this[18]._os_unfair_lock_opaque;
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)&this[18]._os_unfair_lock_opaque = 0;
  }
  if (a2)
  {
    *(_QWORD *)&this[18]._os_unfair_lock_opaque = a2;
    CFRetain(a2);
  }
  os_unfair_lock_unlock(v4);
}

uint64_t SVGAttribute::rectValue(os_unfair_lock_s *this, CGRect *a2)
{
  uint64_t v4;
  CGSize v5;
  uint64_t v6;
  os_unfair_lock_t v8;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v8, this + 27);
  if (SVGAttribute::resolveAsFloats((SVGAttribute *)this)
    && (v4 = **(_QWORD **)&this[22]._os_unfair_lock_opaque,
        (unint64_t)(*(_QWORD *)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8) - v4) >= 0x19))
  {
    v5 = *(CGSize *)(v4 + 16);
    a2->origin = *(CGPoint *)v4;
    a2->size = v5;
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v8);
  return v6;
}

void sub_2067721CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::transformValue(os_unfair_lock_s *this, CGAffineTransform *a2)
{
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  os_unfair_lock_t v9;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v9, this + 27);
  if (SVGAttribute::resolveAsFloats((SVGAttribute *)this)
    && (v4 = **(_OWORD ***)&this[22]._os_unfair_lock_opaque,
        *(_QWORD *)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8) - (_QWORD)v4 == 48))
  {
    v5 = v4[1];
    v6 = v4[2];
    *(_OWORD *)&a2->a = *v4;
    *(_OWORD *)&a2->c = v5;
    *(_OWORD *)&a2->tx = v6;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v9);
  return v7;
}

void sub_20677225C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

void SVGScopedUnfairLock::~SVGScopedUnfairLock(os_unfair_lock_t *this)
{
  os_unfair_lock_unlock(*this);
}

void SVGScopedUnfairLock::SVGScopedUnfairLock(SVGScopedUnfairLock *this, os_unfair_lock_t lock)
{
  *(_QWORD *)this = lock;
  os_unfair_lock_lock(lock);
}

BOOL SVGAttribute::resolveAsFloats(SVGAttribute *this)
{
  _QWORD *v3;
  SVGParser *v4;
  char *v5;
  CGAffineTransform *v6;
  char **v7;
  char *v8;
  double v9;
  int v10;
  uint64_t v11;
  char v12;
  double *v13;
  char *v14;
  char **v15;
  double *v16;
  double *v17;
  double *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  double *v26;
  double *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  double *v35;
  double *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  double *v44;
  double *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  double *v53;
  double *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  _QWORD *v62;
  double *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char v73[8];
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  if (*((_DWORD *)this + 20) == 1)
    return 1;
  v3 = (_QWORD *)operator new();
  v3[1] = 0;
  v3[2] = 0;
  *v3 = 0;
  v72 = 0;
  v4 = (SVGAttribute *)((char *)this + 56);
  v5 = (char *)this + 56;
  if (*((char *)this + 79) < 0)
    v5 = *(char **)v4;
  if (SVGParser::ParseCGFloatList(v5, &v72, (uint64_t)v3))
  {
    *((_DWORD *)this + 20) = 1;
    *((_QWORD *)this + 11) = v3;
    if (v3[1] - *v3 == 8)
    {
      v8 = v72;
      v9 = 1.0;
      if (v72)
      {
        v10 = *v72;
        if (*v72)
        {
          v11 = MEMORY[0x24BDAC740];
          while (1)
          {
            if ((v10 & 0x80) != 0)
            {
              if (!__maskrune((char)v10, 0x4000uLL))
              {
LABEL_31:
                if (!strcasecmp(v8, "em"))
                {
                  v10 = 1;
                }
                else if (!strcasecmp(v8, "ex"))
                {
                  v10 = 2;
                }
                else if (!strcasecmp(v8, "px"))
                {
                  v10 = 3;
                }
                else if (!strcasecmp(v8, "in"))
                {
                  v10 = 4;
                  v9 = 72.0;
                }
                else if (!strcasecmp(v8, "cm"))
                {
                  v10 = 5;
                  v9 = 28.3464567;
                }
                else if (!strcasecmp(v8, "mm"))
                {
                  v10 = 6;
                  v9 = 2.83464567;
                }
                else if (!strcasecmp(v8, "pt"))
                {
                  v10 = 7;
                }
                else if (!strcasecmp(v8, "pc"))
                {
                  v10 = 8;
                }
                else if (*v8 == 37)
                {
                  v10 = 9;
                }
                else
                {
                  v10 = 0;
                }
                break;
              }
            }
            else if ((*(_DWORD *)(v11 + 4 * (char)v10 + 60) & 0x4000) == 0)
            {
              goto LABEL_31;
            }
            v12 = *++v8;
            LOBYTE(v10) = v12;
          }
        }
      }
      else
      {
        v10 = 0;
      }
      *((_DWORD *)this + 26) = v10;
      if (v3[1] == *v3)
        std::vector<double>::__throw_out_of_range[abi:ne180100]();
      *(double *)*v3 = v9 * *(double *)*v3;
    }
    return *((_DWORD *)this + 20) == 1;
  }
  if (*((char *)this + 79) < 0)
    v4 = *(SVGParser **)v4;
  if (!SVGParser::ParseTransforms(v4, v73, v6, v7))
  {
    v17 = (double *)*v3;
    if (*v3)
    {
      v3[1] = v17;
      operator delete(v17);
    }
    MEMORY[0x20BCFC038](v3, 0x80C40D6874129);
    return *((_DWORD *)this + 20) == 1;
  }
  *((_DWORD *)this + 20) = 1;
  *((_QWORD *)this + 11) = v3;
  v13 = (double *)v3[1];
  v15 = (char **)(v3 + 2);
  v14 = (char *)v3[2];
  if (v13 >= (double *)v14)
  {
    v18 = (double *)*v3;
    v19 = ((uint64_t)v13 - *v3) >> 3;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 61)
      goto LABEL_141;
    v21 = v14 - (char *)v18;
    if (v21 >> 2 > v20)
      v20 = v21 >> 2;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
      v22 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22)
    {
      v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v3 + 2), v22);
      v18 = (double *)*v3;
      v13 = (double *)v3[1];
    }
    else
    {
      v23 = 0;
    }
    v24 = &v23[8 * v19];
    v14 = &v23[8 * v22];
    *(_QWORD *)v24 = *(_QWORD *)v73;
    v16 = (double *)(v24 + 8);
    while (v13 != v18)
    {
      v25 = *((_QWORD *)v13-- - 1);
      *((_QWORD *)v24 - 1) = v25;
      v24 -= 8;
    }
    *v3 = v24;
    v3[1] = v16;
    v3[2] = v14;
    if (v18)
    {
      operator delete(v18);
      v14 = *v15;
    }
  }
  else
  {
    *v13 = *(double *)v73;
    v16 = v13 + 1;
  }
  v3[1] = v16;
  if (v16 >= (double *)v14)
  {
    v27 = (double *)*v3;
    v28 = ((uint64_t)v16 - *v3) >> 3;
    v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 61)
      goto LABEL_141;
    v30 = v14 - (char *)v27;
    if (v30 >> 2 > v29)
      v29 = v30 >> 2;
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
      v31 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v31 = v29;
    if (v31)
    {
      v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v3 + 2), v31);
      v27 = (double *)*v3;
      v16 = (double *)v3[1];
    }
    else
    {
      v32 = 0;
    }
    v33 = &v32[8 * v28];
    v14 = &v32[8 * v31];
    *(_QWORD *)v33 = v74;
    v26 = (double *)(v33 + 8);
    while (v16 != v27)
    {
      v34 = *((_QWORD *)v16-- - 1);
      *((_QWORD *)v33 - 1) = v34;
      v33 -= 8;
    }
    *v3 = v33;
    v3[1] = v26;
    v3[2] = v14;
    if (v27)
    {
      operator delete(v27);
      v14 = *v15;
    }
  }
  else
  {
    *(_QWORD *)v16 = v74;
    v26 = v16 + 1;
  }
  v3[1] = v26;
  if (v26 >= (double *)v14)
  {
    v36 = (double *)*v3;
    v37 = ((uint64_t)v26 - *v3) >> 3;
    v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61)
      goto LABEL_141;
    v39 = v14 - (char *)v36;
    if (v39 >> 2 > v38)
      v38 = v39 >> 2;
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
      v40 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v40 = v38;
    if (v40)
    {
      v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v3 + 2), v40);
      v36 = (double *)*v3;
      v26 = (double *)v3[1];
    }
    else
    {
      v41 = 0;
    }
    v42 = &v41[8 * v37];
    v14 = &v41[8 * v40];
    *(_QWORD *)v42 = v75;
    v35 = (double *)(v42 + 8);
    while (v26 != v36)
    {
      v43 = *((_QWORD *)v26-- - 1);
      *((_QWORD *)v42 - 1) = v43;
      v42 -= 8;
    }
    *v3 = v42;
    v3[1] = v35;
    v3[2] = v14;
    if (v36)
    {
      operator delete(v36);
      v14 = *v15;
    }
  }
  else
  {
    *(_QWORD *)v26 = v75;
    v35 = v26 + 1;
  }
  v3[1] = v35;
  if (v35 >= (double *)v14)
  {
    v45 = (double *)*v3;
    v46 = ((uint64_t)v35 - *v3) >> 3;
    v47 = v46 + 1;
    if ((unint64_t)(v46 + 1) >> 61)
      goto LABEL_141;
    v48 = v14 - (char *)v45;
    if (v48 >> 2 > v47)
      v47 = v48 >> 2;
    if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
      v49 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v49 = v47;
    if (v49)
    {
      v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v3 + 2), v49);
      v45 = (double *)*v3;
      v35 = (double *)v3[1];
    }
    else
    {
      v50 = 0;
    }
    v51 = &v50[8 * v46];
    v14 = &v50[8 * v49];
    *(_QWORD *)v51 = v76;
    v44 = (double *)(v51 + 8);
    while (v35 != v45)
    {
      v52 = *((_QWORD *)v35-- - 1);
      *((_QWORD *)v51 - 1) = v52;
      v51 -= 8;
    }
    *v3 = v51;
    v3[1] = v44;
    v3[2] = v14;
    if (v45)
    {
      operator delete(v45);
      v14 = *v15;
    }
  }
  else
  {
    *(_QWORD *)v35 = v76;
    v44 = v35 + 1;
  }
  v3[1] = v44;
  if (v44 >= (double *)v14)
  {
    v54 = (double *)*v3;
    v55 = ((uint64_t)v44 - *v3) >> 3;
    v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 61)
      goto LABEL_141;
    v57 = v14 - (char *)v54;
    if (v57 >> 2 > v56)
      v56 = v57 >> 2;
    if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8)
      v58 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v58 = v56;
    if (v58)
    {
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v3 + 2), v58);
      v54 = (double *)*v3;
      v44 = (double *)v3[1];
    }
    else
    {
      v59 = 0;
    }
    v60 = &v59[8 * v55];
    v14 = &v59[8 * v58];
    *(_QWORD *)v60 = v77;
    v53 = (double *)(v60 + 8);
    while (v44 != v54)
    {
      v61 = *((_QWORD *)v44-- - 1);
      *((_QWORD *)v60 - 1) = v61;
      v60 -= 8;
    }
    *v3 = v60;
    v3[1] = v53;
    v3[2] = v14;
    if (v54)
    {
      operator delete(v54);
      v14 = *v15;
    }
  }
  else
  {
    *(_QWORD *)v44 = v77;
    v53 = v44 + 1;
  }
  v3[1] = v53;
  if (v53 >= (double *)v14)
  {
    v63 = (double *)*v3;
    v64 = ((uint64_t)v53 - *v3) >> 3;
    v65 = v64 + 1;
    if (!((unint64_t)(v64 + 1) >> 61))
    {
      v66 = v14 - (char *)v63;
      if (v66 >> 2 > v65)
        v65 = v66 >> 2;
      if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8)
        v67 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v67 = v65;
      if (v67)
      {
        v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v3 + 2), v67);
        v63 = (double *)*v3;
        v53 = (double *)v3[1];
      }
      else
      {
        v68 = 0;
      }
      v69 = &v68[8 * v64];
      v70 = &v68[8 * v67];
      *(_QWORD *)v69 = v78;
      v62 = v69 + 8;
      while (v53 != v63)
      {
        v71 = *((_QWORD *)v53-- - 1);
        *((_QWORD *)v69 - 1) = v71;
        v69 -= 8;
      }
      *v3 = v69;
      v3[1] = v62;
      v3[2] = v70;
      if (v63)
        operator delete(v63);
      goto LABEL_129;
    }
LABEL_141:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  *(_QWORD *)v53 = v78;
  v62 = v53 + 1;
LABEL_129:
  v3[1] = v62;
  return *((_DWORD *)this + 20) == 1;
}

uint64_t SVGParser::ParseTransforms(SVGParser *this, char *a2, CGAffineTransform *a3, char **a4)
{
  __int128 v4;
  SVGParser *v6;
  uint64_t v7;
  char **v8;
  char **v9;
  char **v10;
  char **v11;
  char **v12;
  __int128 v13;
  CGAffineTransform v15;
  CGAffineTransform t1;
  CGAffineTransform v17;
  _BYTE v18[56];

  v4 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)&v18[8] = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)&v18[24] = v4;
  *(_OWORD *)&v18[40] = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  *(_QWORD *)v18 = 0;
  if (!*(_BYTE *)this)
    return 0;
  v6 = this;
  v7 = 0;
  do
  {
    if ((SVGParser::ParseTransformMatrix(v6, (char *)&v17, (CGAffineTransform *)v18, a4) & 1) != 0
      || (SVGParser::ParseTransformTranslate(v6, (char *)&v17, (CGAffineTransform *)v18, v8) & 1) != 0
      || (SVGParser::ParseTransformScale(v6, (char *)&v17, (CGAffineTransform *)v18, v9) & 1) != 0
      || (SVGParser::ParseTransformRotate(v6, (char *)&v17, (CGAffineTransform *)v18, v10) & 1) != 0
      || SVGParser::ParseTransformSkewX(v6, &v17.a, (CGAffineTransform *)v18, v11)
      || SVGParser::ParseTransformSkewY(v6, &v17.a, (CGAffineTransform *)v18, v12))
    {
      ++v7;
      t1 = v17;
      v15 = *(CGAffineTransform *)&v18[8];
      CGAffineTransformConcat((CGAffineTransform *)&v18[8], &t1, &v15);
      v6 = *(SVGParser **)v18;
    }
    else
    {
      v6 = (SVGParser *)((char *)v6 + 1);
    }
  }
  while (*(_BYTE *)v6);
  if (!v7)
    return 0;
  v13 = *(_OWORD *)&v18[24];
  *(_OWORD *)a2 = *(_OWORD *)&v18[8];
  *((_OWORD *)a2 + 1) = v13;
  *((_OWORD *)a2 + 2) = *(_OWORD *)&v18[40];
  return 1;
}

uint64_t SVGParser::ParseTransformMatrix(SVGParser *this, char *a2, CGAffineTransform *a3, char **a4)
{
  _BOOL4 v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  void *__p;
  _BYTE *v13;
  uint64_t v14;

  __p = 0;
  v13 = 0;
  v14 = 0;
  v5 = ParseTransformPrefix((uint64_t)this, "matrix", a3, (uint64_t)&__p);
  v6 = __p;
  if (v5 && (unint64_t)(v13 - (_BYTE *)__p) >= 0x30)
  {
    v9 = *((_OWORD *)__p + 1);
    v10 = *((_OWORD *)__p + 2);
    *(_OWORD *)a2 = *(_OWORD *)__p;
    *((_OWORD *)a2 + 1) = v9;
    *((_OWORD *)a2 + 2) = v10;
    v7 = 1;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    if (!__p)
      return v8;
  }
  v13 = v6;
  operator delete(v6);
  return v7;
}

void sub_206772B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL ParseTransformPrefix(uint64_t a1, char *__s, _QWORD *a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  size_t v11;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;

  if (!a1)
    return 0;
  v7 = (char *)(a1 - 1);
  v8 = MEMORY[0x24BDAC740];
  do
  {
    v9 = v7[1];
    if ((v9 & 0x80000000) != 0)
      v10 = __maskrune(v9, 0x4000uLL);
    else
      v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
    ++v7;
  }
  while (v10);
  v11 = strlen(__s);
  if (strncasecmp(v7, __s, v11))
    return 0;
  while (1)
  {
    v13 = *v7;
    if ((*v7 & 0x80000000) == 0 && (*(_DWORD *)(v8 + 4 * v13 + 60) & 0x400) != 0)
      break;
    v14 = v13 > 0x2E;
    v15 = (1 << v13) & 0x680000000001;
    if (!v14 && v15 != 0)
      break;
    ++v7;
  }
  return SVGParser::ParseCGFloatList(v7, a3, a4);
}

uint64_t SVGParser::ParseTransformTranslate(SVGParser *this, char *a2, CGAffineTransform *a3, char **a4)
{
  _BOOL4 v5;
  CGFloat *v6;
  uint64_t v7;
  CGFloat v8;
  uint64_t v9;
  uint64_t result;
  __int128 v11;
  CGAffineTransform v12;
  CGFloat *v13;
  CGFloat *v14;
  uint64_t v15;

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v5 = ParseTransformPrefix((uint64_t)this, "translate", a3, (uint64_t)&v13);
  v6 = v13;
  if (v5)
  {
    v7 = v14 - v13;
    if (v7)
    {
      if (v7 == 1)
        v8 = 0.0;
      else
        v8 = v13[1];
      CGAffineTransformMakeTranslation(&v12, *v13, v8);
      v11 = *(_OWORD *)&v12.c;
      *(_OWORD *)a2 = *(_OWORD *)&v12.a;
      *((_OWORD *)a2 + 1) = v11;
      *((_OWORD *)a2 + 2) = *(_OWORD *)&v12.tx;
      v9 = 1;
      goto LABEL_9;
    }
  }
  v9 = 0;
  result = 0;
  if (v13)
  {
LABEL_9:
    v14 = v6;
    operator delete(v6);
    return v9;
  }
  return result;
}

void sub_206772CFC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 40);
  if (v3)
  {
    *(_QWORD *)(v1 - 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SVGParser::ParseTransformRotate(SVGParser *this, char *a2, CGAffineTransform *a3, char **a4)
{
  _BOOL4 v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  double v12;
  double v13;
  __int128 v14;
  CGAffineTransform v15;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v18;
  CGAffineTransform v19;
  CGAffineTransform v20;
  CGAffineTransform v21;
  CGAffineTransform v22;
  double *v23;
  double *v24;
  uint64_t v25;

  v23 = 0;
  v24 = 0;
  v25 = 0;
  v5 = ParseTransformPrefix((uint64_t)this, "rotate", a3, (uint64_t)&v23);
  v6 = v23;
  if (v5)
  {
    v7 = v24 - v23;
    if (v7)
    {
      if (v7 == 1)
      {
        CGAffineTransformMakeRotation(&v22, *v23 / 180.0 * 3.14159265);
        v10 = *(_OWORD *)&v22.c;
        *(_OWORD *)a2 = *(_OWORD *)&v22.a;
        *((_OWORD *)a2 + 1) = v10;
        v11 = *(_OWORD *)&v22.tx;
      }
      else
      {
        if (v7 == 2)
          goto LABEL_5;
        memset(&v22, 0, sizeof(v22));
        v12 = v23[1];
        v13 = v23[2];
        CGAffineTransformMakeTranslation(&v22, -v12, -v13);
        memset(&v21, 0, sizeof(v21));
        CGAffineTransformMakeRotation(&v21, *v6 / 180.0 * 3.14159265);
        memset(&v20, 0, sizeof(v20));
        CGAffineTransformMakeTranslation(&v20, v12, v13);
        t1 = v22;
        t2 = v21;
        CGAffineTransformConcat(&v18, &t1, &t2);
        v15 = v20;
        CGAffineTransformConcat(&v19, &v18, &v15);
        v14 = *(_OWORD *)&v19.c;
        *(_OWORD *)a2 = *(_OWORD *)&v19.a;
        *((_OWORD *)a2 + 1) = v14;
        v11 = *(_OWORD *)&v19.tx;
      }
      *((_OWORD *)a2 + 2) = v11;
      v8 = 1;
      goto LABEL_10;
    }
  }
LABEL_5:
  v8 = 0;
  result = 0;
  if (v23)
  {
LABEL_10:
    v24 = v6;
    operator delete(v6);
    return v8;
  }
  return result;
}

void sub_206772EB0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 72);
  if (v3)
  {
    *(_QWORD *)(v1 - 64) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL SVGParser::ParseTransformSkewY(SVGParser *this, double *a2, CGAffineTransform *a3, char **a4)
{
  _BOOL4 v5;
  double *v6;
  _BOOL8 v7;
  long double v8;
  double *v10;
  double *v11;
  uint64_t v12;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v5 = ParseTransformPrefix((uint64_t)this, "skewY", a3, (uint64_t)&v10);
  v6 = v10;
  v7 = v11 != v10 && v5;
  if (v7)
  {
    v8 = tan(*v10 / 180.0 * 3.14159265);
    *a2 = 1.0;
    a2[1] = v8;
    *((_OWORD *)a2 + 1) = xmmword_206799FC0;
    a2[4] = 0.0;
    a2[5] = 0.0;
  }
  else if (!v10)
  {
    return 0;
  }
  v11 = v6;
  operator delete(v6);
  return v7;
}

void sub_206772F7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL SVGParser::ParseTransformSkewX(SVGParser *this, double *a2, CGAffineTransform *a3, char **a4)
{
  _BOOL4 v5;
  double *v6;
  _BOOL8 v7;
  long double v8;
  double *v10;
  double *v11;
  uint64_t v12;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v5 = ParseTransformPrefix((uint64_t)this, "skewX", a3, (uint64_t)&v10);
  v6 = v10;
  v7 = v11 != v10 && v5;
  if (v7)
  {
    v8 = tan(*v10 / 180.0 * 3.14159265);
    *(_OWORD *)a2 = xmmword_206799E30;
    a2[2] = v8;
    a2[4] = 0.0;
    a2[5] = 0.0;
    a2[3] = 1.0;
  }
  else if (!v10)
  {
    return 0;
  }
  v11 = v6;
  operator delete(v6);
  return v7;
}

void sub_206773048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGParser::ParseTransformScale(SVGParser *this, char *a2, CGAffineTransform *a3, char **a4)
{
  _BOOL4 v5;
  double *v6;
  uint64_t v7;
  CGFloat v8;
  uint64_t v9;
  uint64_t result;
  __int128 v11;
  CGAffineTransform v12;
  double *v13;
  double *v14;
  uint64_t v15;

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v5 = ParseTransformPrefix((uint64_t)this, "scale", a3, (uint64_t)&v13);
  v6 = v13;
  if (v5)
  {
    v7 = v14 - v13;
    if (v7)
    {
      if (v7 == 1)
        v8 = *v13;
      else
        v8 = v13[1];
      CGAffineTransformMakeScale(&v12, *v13, v8);
      v11 = *(_OWORD *)&v12.c;
      *(_OWORD *)a2 = *(_OWORD *)&v12.a;
      *((_OWORD *)a2 + 1) = v11;
      *((_OWORD *)a2 + 2) = *(_OWORD *)&v12.tx;
      v9 = 1;
      goto LABEL_9;
    }
  }
  v9 = 0;
  result = 0;
  if (v13)
  {
LABEL_9:
    v14 = v6;
    operator delete(v6);
    return v9;
  }
  return result;
}

void sub_206773114(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 40);
  if (v3)
  {
    *(_QWORD *)(v1 - 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SVGShapeNode::pointList(SVGShapeNode *this)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  void *__p;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = SVGAttributeMap::attribute(*((_QWORD *)this + 7), 0x2Bu);
  v9 = 0;
  if (v2)
  {
    if (SVGAttribute::pointsValue(v2, &v9))
      return v9;
    else
      return 0;
  }
  else
  {
    if ((*((_DWORD *)this + 72) & 0xFFFFFFFE) == 0x2C)
    {
      __p = 0;
      v7 = 0;
      v8 = 0;
      v4 = *((_QWORD *)this + 7);
      v5 = operator new();
      SVGAttribute::SVGAttribute(v5, 43, &__p);
      SVGAttributeMap::setAttribute(v4, v5, 1);
      if (__p)
      {
        v7 = __p;
        operator delete(__p);
      }
    }
    return 0;
  }
}

void sub_2067731E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v10;

  MEMORY[0x20BCFC038](v10, 0x10B3C405B4D0908);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::pointsValue(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  os_unfair_lock_t v37;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v37, (os_unfair_lock_t)(a1 + 108));
  v4 = *(_QWORD **)(a1 + 96);
  if (!v4)
  {
    if (!SVGAttribute::resolveAsFloats((SVGAttribute *)a1)
      || (v6 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) - **(_QWORD **)(a1 + 88), (unint64_t)v6 < 9))
    {
      v5 = 0;
      goto LABEL_28;
    }
    v4 = (_QWORD *)operator new();
    *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    *(_QWORD *)(a1 + 96) = v4;
    v7 = (v6 >> 3) + (v6 << 60 >> 63);
    if (v7)
    {
      v8 = 0;
      v9 = **(_QWORD **)(a1 + 88);
      do
      {
        v10 = *(_QWORD *)(v9 + 8 * v8);
        v11 = *(_QWORD *)(v9 + ((8 * v8) | 8));
        v12 = *(_QWORD *)(a1 + 96);
        v13 = *(_QWORD **)(v12 + 8);
        v14 = *(_QWORD *)(v12 + 16);
        if ((unint64_t)v13 >= v14)
        {
          v16 = *(_QWORD **)v12;
          v17 = ((uint64_t)v13 - *(_QWORD *)v12) >> 4;
          v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 60)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v19 = v14 - (_QWORD)v16;
          if (v19 >> 3 > v18)
            v18 = v19 >> 3;
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
            v20 = 0xFFFFFFFFFFFFFFFLL;
          else
            v20 = v18;
          if (v20)
          {
            v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>(v12 + 16, v20);
            v16 = *(_QWORD **)v12;
            v13 = *(_QWORD **)(v12 + 8);
          }
          else
          {
            v21 = 0;
          }
          v22 = &v21[16 * v17];
          *(_QWORD *)v22 = v10;
          *((_QWORD *)v22 + 1) = v11;
          v23 = v22;
          if (v13 != v16)
          {
            do
            {
              *((_OWORD *)v23 - 1) = *((_OWORD *)v13 - 1);
              v23 -= 16;
              v13 -= 2;
            }
            while (v13 != v16);
            v16 = *(_QWORD **)v12;
          }
          v15 = v22 + 16;
          *(_QWORD *)v12 = v23;
          *(_QWORD *)(v12 + 8) = v22 + 16;
          *(_QWORD *)(v12 + 16) = &v21[16 * v20];
          if (v16)
            operator delete(v16);
        }
        else
        {
          *v13 = v10;
          v13[1] = v11;
          v15 = v13 + 2;
        }
        *(_QWORD *)(v12 + 8) = v15;
        v8 += 2;
      }
      while (v8 < v7);
      v4 = *(_QWORD **)(a1 + 96);
      if ((v7 & 1) != 0)
      {
        v24 = *(_QWORD *)(v9 + 8 * v7);
        v25 = v4[2];
        v26 = (_QWORD *)v4[1];
        if ((unint64_t)v26 >= v25)
        {
          v29 = (_QWORD *)*v4;
          v30 = ((uint64_t)v26 - *v4) >> 4;
          v31 = v30 + 1;
          if ((unint64_t)(v30 + 1) >> 60)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v32 = v25 - (_QWORD)v29;
          if (v32 >> 3 > v31)
            v31 = v32 >> 3;
          if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0)
            v33 = 0xFFFFFFFFFFFFFFFLL;
          else
            v33 = v31;
          if (v33)
          {
            v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>((uint64_t)(v4 + 2), v33);
            v29 = (_QWORD *)*v4;
            v26 = (_QWORD *)v4[1];
          }
          else
          {
            v34 = 0;
          }
          v35 = &v34[16 * v30];
          v36 = &v34[16 * v33];
          *(_QWORD *)v35 = v24;
          *((_QWORD *)v35 + 1) = 0;
          v27 = v35 + 16;
          if (v26 != v29)
          {
            do
            {
              *((_OWORD *)v35 - 1) = *((_OWORD *)v26 - 1);
              v35 -= 16;
              v26 -= 2;
            }
            while (v26 != v29);
            v29 = (_QWORD *)*v4;
          }
          *v4 = v35;
          v4[1] = v27;
          v4[2] = v36;
          if (v29)
            operator delete(v29);
        }
        else
        {
          *v26 = v24;
          v26[1] = 0;
          v27 = v26 + 2;
        }
        v4[1] = v27;
        v4 = *(_QWORD **)(a1 + 96);
      }
    }
  }
  *a2 = v4;
  v5 = 1;
LABEL_28:
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v37);
  return v5;
}

void sub_2067734E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

const CGPath *CGSVGPathCreateWithCGPath(const CGPath *result)
{
  const CGPath *v1;
  SVGPath *v2;
  _QWORD block[5];

  if (result)
  {
    v1 = result;
    v2 = (SVGPath *)operator new();
    SVGPath::SVGPath(v2);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = __CGSVGPathCreateWithCGPath_block_invoke;
    block[3] = &__block_descriptor_tmp_9;
    block[4] = v2;
    CGPathApplyWithBlock(v1, block);
    return (const CGPath *)*((_QWORD *)v2 + 5);
  }
  return result;
}

void sub_20677358C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40176D6E88);
  _Unwind_Resume(a1);
}

_QWORD *CGSVGNodeGetChildCount(uint64_t a1, const char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
    return (_QWORD *)((uint64_t)(result[12] - result[11]) >> 3);
  return result;
}

uint64_t CGSVGAttributeGetFloat(uint64_t a1, char *a2)
{
  os_unfair_lock_s *v3;

  v3 = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  return SVGAttribute::floatValue(v3, (double *)a2);
}

void SVGRootNode::~SVGRootNode(SVGRootNode *this)
{
  SVGRootNode::~SVGRootNode(this);
  JUMPOUT(0x20BCFC038);
}

{
  const void *v2;

  *(_QWORD *)this = &off_24BFD8BA8;
  v2 = (const void *)*((_QWORD *)this + 34);
  if (v2)
    CFRelease(v2);
  SVGMask::~SVGMask(this);
}

void SVGNode::~SVGNode(SVGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  SVGNode *v11;
  SVGNode *v12;
  SVGNode *v13;
  BOOL v14;
  void *v15;
  void *v16;

  *(_QWORD *)this = &off_24BFD8DD8;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    SVGAttributeMap::setOwnerNode(v2, 0);
  v3 = *((_QWORD *)this + 23);
  if (v3)
  {
    if (*(char *)(v3 + 23) < 0)
      operator delete(*(void **)v3);
    MEMORY[0x20BCFC038](v3, 0x1012C40EC159624);
  }
  v4 = *((_QWORD *)this + 24);
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0)
      operator delete(*(void **)v4);
    MEMORY[0x20BCFC038](v4, 0x1012C40EC159624);
  }
  CFRetained::release(*((_QWORD *)this + 7));
  v5 = (uint64_t *)*((_QWORD *)this + 11);
  v6 = (uint64_t *)*((_QWORD *)this + 12);
  while (v5 != v6)
  {
    v7 = *v5;
    *(_QWORD *)(v7 + 48) = 0;
    CFRetained::release((CFTypeRef *)v7);
    ++v5;
  }
  v8 = (uint64_t *)*((_QWORD *)this + 14);
  v9 = (uint64_t *)*((_QWORD *)this + 15);
  while (v8 != v9)
  {
    v10 = *v8;
    *(_QWORD *)(v10 + 48) = 0;
    CFRetained::release((CFTypeRef *)v10);
    ++v8;
  }
  v11 = (SVGNode *)*((_QWORD *)this + 20);
  if (v11 != (SVGNode *)((char *)this + 168))
  {
    do
    {
      CFRetained::release(*((CFTypeRef **)v11 + 7));
      v12 = (SVGNode *)*((_QWORD *)v11 + 1);
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = *(SVGNode **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (SVGNode *)*((_QWORD *)v11 + 2);
          v14 = *(_QWORD *)v13 == (_QWORD)v11;
          v11 = v13;
        }
        while (!v14);
      }
      v11 = v13;
    }
    while (v13 != (SVGNode *)((char *)this + 168));
  }
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy((uint64_t)this + 160, *((char **)this + 21));
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy((uint64_t)this + 136, *((char **)this + 18));
  v15 = (void *)*((_QWORD *)this + 14);
  if (v15)
  {
    *((_QWORD *)this + 15) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 11);
  if (v16)
  {
    *((_QWORD *)this + 12) = v16;
    operator delete(v16);
  }
  if (*((char *)this + 87) < 0)
    operator delete(*((void **)this + 8));
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  SVGNode::~SVGNode(this);
  JUMPOUT(0x20BCFC038);
}

uint64_t CGSVGAttributeMapGetAttribute(uint64_t a1, const char *a2)
{
  unsigned int v2;
  uint64_t result;

  v2 = a2;
  result = (uint64_t)CFRetained::getObject<SVGAttributeMap>(a1, a2);
  if (result)
  {
    result = SVGAttributeMap::attribute(result, v2);
    if (result)
      return *(_QWORD *)(result + 40);
  }
  return result;
}

void *CFRetained::getObject<SVGAttributeMap>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

uint64_t CGSVGNodeFindAttribute(uint64_t a1, const char *a2)
{
  unsigned int v2;
  uint64_t result;

  v2 = a2;
  result = (uint64_t)CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    result = SVGNode::findAttribute(result, v2);
    if (result)
      return *(_QWORD *)(result + 40);
  }
  return result;
}

uint64_t SVGNode::findAttribute(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  do
  {
    result = SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
    if (result)
      break;
    a1 = *(_QWORD *)(a1 + 48);
  }
  while (a1);
  return result;
}

void SVGReader::SVGReader(SVGReader *this, CFDataRef theData, const SVGReaderOptions *a3)
{
  SVGAttributeMap ***v6;
  uint64_t v7;
  const char *BytePtr;
  SVGReader *Length;
  uint64_t v10;
  const xmlDoc *Memory;
  uint64_t v12;
  xmlDoc *v13;
  xmlNodePtr RootElement;
  const char *v15;
  SVGReader *v16;
  uint64_t v17;
  SVGAttributeMap *v18;
  SVGReader *v19;
  SVGRootNode *v20;
  SVGAttributeMap *v21;
  const __CFURL *v22;
  double v23;
  double v24;
  double v25;
  double v26;
  os_unfair_lock_s *v27;
  uint64_t v28;
  os_unfair_lock_s *v29;
  _BOOL4 v30;
  _BOOL4 v31;
  SVGAttributeMap **v32;
  _xmlNode *children;
  CFTypeRef **v34;
  CFTypeRef **v35;

  *(_QWORD *)this = a3;
  *(_OWORD *)((char *)this + 8) = 0u;
  v6 = (SVGAttributeMap ***)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 5) = 0;
  BytePtr = (const char *)CFDataGetBytePtr(theData);
  if (!BytePtr)
  {
    SVGReader::report(0, (SVGParser *)"Got null from CFDataGetBytePtr(...)", 0, v7);
    return;
  }
  Length = (SVGReader *)CFDataGetLength(theData);
  if ((int)Length <= 0)
  {
    SVGReader::report(Length, (SVGParser *)"Got zero-length from CFDataRef", 0, v10);
    return;
  }
  Memory = xmlReadMemory(BytePtr, (int)Length, 0, 0, 0);
  v13 = (xmlDoc *)Memory;
  if (!Memory)
  {
    SVGReader::report(0, (SVGParser *)"Failed to parse with xmlReadMemory", 0, v12);
    return;
  }
  RootElement = xmlDocGetRootElement(Memory);
  v16 = (SVGReader *)SVGAtom::ToName((SVGAtom *)RootElement->name, v15);
  if ((_DWORD)v16 != 61)
  {
    SVGReader::report(v16, (SVGParser *)"Root XML node does not have \"SVG\" type", 0, v17);
    xmlFreeDoc(v13);
    return;
  }
  v18 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v18);
  SVGReader::parseXMLNodeAttributes(this, RootElement, v18);
  SVGReader::parseXMLNodeXmlNS(v19, RootElement, v18);
  v20 = (SVGRootNode *)operator new();
  SVGRootNode::SVGRootNode(v20);
  *((_QWORD *)this + 1) = v20;
  SVGReader::ApplyStyleToAttributes(v20, *((SVGNode **)this + 2), v18, v21);
  SVGNode::addUniqueAttributes(*v6, v18);
  if (a3)
  {
    v22 = (const __CFURL *)*((_QWORD *)a3 + 2);
    if (v22)
      SVGRootNode::setWorkingDir((SVGRootNode *)*v6, v22);
  }
  v23 = *((double *)*v6 + 27);
  v24 = *((double *)*v6 + 28);
  v26 = *((double *)*v6 + 31);
  v25 = *((double *)*v6 + 32);
  v27 = (os_unfair_lock_s *)SVGAttributeMap::attribute((uint64_t)v18, 0x42u);
  v28 = SVGAttributeMap::attribute((uint64_t)v18, 0x1Eu);
  v29 = (os_unfair_lock_s *)v28;
  if (v27)
  {
    v30 = SVGAttribute::lengthType(v27) == 9;
    if (v29)
      goto LABEL_10;
LABEL_26:
    v31 = 1;
    v24 = 100.0;
    if (!v30)
      goto LABEL_12;
    goto LABEL_11;
  }
  v30 = 1;
  v23 = 100.0;
  if (!v28)
    goto LABEL_26;
LABEL_10:
  v31 = SVGAttribute::lengthType(v29) == 9;
  if (v30)
LABEL_11:
    v23 = fmax(v26 * v23 / 100.0, 0.0);
LABEL_12:
  if (v31)
    v24 = fmax(v25 * v24 / 100.0, 0.0);
  CFRetained::release((CFTypeRef *)v18);
  v32 = *v6;
  *((double *)v32 + 27) = v23;
  *((double *)v32 + 28) = v24;
  children = RootElement->children;
  if (children)
  {
    do
    {
      SVGReader::parseXMLNode((SVGNode **)this, children, *((SVGNode **)this + 1));
      children = children->next;
    }
    while (children);
    v32 = *v6;
  }
  SVGReader::resolveDefinitions((SVGNode **)this, (SVGNode *)v32);
  v34 = (CFTypeRef **)*((_QWORD *)this + 3);
  v35 = (CFTypeRef **)*((_QWORD *)this + 4);
  while (v34 != v35)
    CFRetained::release(*v34++);
  xmlFreeDoc(v13);
}

void sub_206773BB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(_QWORD *)(v1 + 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void SVGNode::addChild(SVGNode *this, SVGNode *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  void *__p[2];
  char v23;
  SVGNode *v24;

  if (a2 == this)
  {
    SVGUtilities::error((SVGUtilities *)"Warning: attempted to add a node to itself, causing a cycle. Ignoring.", (const char *)a2);
  }
  else if (a2)
  {
    v6 = *((_QWORD *)this + 13);
    v4 = (char *)this + 104;
    v5 = v6;
    v7 = (_QWORD *)*((_QWORD *)v4 - 1);
    if ((unint64_t)v7 >= v6)
    {
      v9 = (void **)(v4 - 16);
      v10 = *((_QWORD *)v4 - 2);
      v11 = ((uint64_t)v7 - v10) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v12 = v5 - v10;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v4, v14);
      else
        v15 = 0;
      v16 = &v15[8 * v11];
      v17 = &v15[8 * v14];
      *(_QWORD *)v16 = a2;
      v8 = v16 + 8;
      v19 = (char *)*((_QWORD *)this + 11);
      v18 = (char *)*((_QWORD *)this + 12);
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v16 - 1) = v20;
          v16 -= 8;
        }
        while (v18 != v19);
        v18 = (char *)*v9;
      }
      *((_QWORD *)this + 11) = v16;
      *((_QWORD *)this + 12) = v8;
      *((_QWORD *)this + 13) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v7 = a2;
      v8 = v7 + 1;
    }
    *((_QWORD *)this + 12) = v8;
    CFRetained::retain((CFTypeRef *)a2);
    *((_QWORD *)a2 + 6) = this;
    if (SVGNode::identifier(a2) && *SVGNode::identifier(a2))
    {
      v21 = SVGNode::identifier(a2);
      std::string::basic_string[abi:ne180100]<0>(__p, v21);
      v24 = a2;
      std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGNode *>>((uint64_t **)this + 17, (uint64_t)__p, (uint64_t)__p);
      if (v23 < 0)
        operator delete(__p[0]);
    }
  }
}

void sub_206773D9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *SVGNode::identifier(SVGNode *this)
{
  SVGAttribute *v1;
  char *result;

  v1 = (SVGAttribute *)SVGAttributeMap::attribute(*((_QWORD *)this + 7), 0x1Fu);
  if (!v1)
    return (char *)&unk_20679A6BE;
  result = (char *)SVGAttribute::stringValue(v1);
  if (result[23] < 0)
    return *(char **)result;
  return result;
}

CFStringRef CGSVGAttributeCopyString(uint64_t a1, const char *a2)
{
  SVGAttribute *v2;
  uint64_t v3;
  __int128 v4;
  CFStringRef v5;
  std::string *p_p;
  std::string __p;

  v2 = (SVGAttribute *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (!v2)
    return 0;
  v3 = SVGAttribute::stringValue(v2);
  if (*(char *)(v3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v3, *(_QWORD *)(v3 + 8));
  }
  else
  {
    v4 = *(_OWORD *)v3;
    __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v3 + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v4;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD260], (const char *)p_p, 0x8000100u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v5;
}

void sub_206773E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGAttribute::stringValue(SVGAttribute *this)
{
  uint64_t v2;
  void **v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  std::string *p_p;
  std::string::size_type size;
  std::string v12;
  std::string __p;

  if (*((char *)this + 79) < 0)
    v2 = *((_QWORD *)this + 8);
  else
    v2 = *((unsigned __int8 *)this + 79);
  v3 = (void **)((char *)this + 56);
  if (!v2)
  {
    switch(*((_DWORD *)this + 20))
    {
      case 1:
        v4 = (_QWORD *)*((_QWORD *)this + 11);
        if (*((_DWORD *)this + 26) == 9)
        {
          v5 = (_QWORD *)*v4;
          v6 = (_QWORD *)v4[1];
          if ((_QWORD *)((char *)v6 - *v4) == (_QWORD *)8)
          {
            CGSVGLengthMakeWithType();
            SVGUtilities::CGSVGLengthToString(v7, v8, &__p);
            if (*((char *)this + 79) < 0)
              operator delete(*v3);
            *(_OWORD *)v3 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *((_QWORD *)this + 9) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
            goto LABEL_29;
          }
        }
        else
        {
          v5 = (_QWORD *)*v4;
          v6 = (_QWORD *)v4[1];
        }
        for (; v5 != v6; ++v5)
        {
          SVGParser::FormatString((SVGParser *)"%g ", &__p, *v5);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_p = &__p;
          else
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          else
            size = __p.__r_.__value_.__l.__size_;
          std::string::append((std::string *)((char *)this + 56), (const std::string::value_type *)p_p, size);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
LABEL_29:
        if (*((char *)this + 79) < 0)
        {
          std::string::__init_copy_ctor_external(&v12, *((const std::string::value_type **)this + 7), *((_QWORD *)this + 8));
        }
        else
        {
          *(_OWORD *)&v12.__r_.__value_.__l.__data_ = *(_OWORD *)v3;
          v12.__r_.__value_.__r.__words[2] = *((_QWORD *)this + 9);
        }
        SVGParser::StripLeadingTrailingWhitespace(&v12, &__p);
        if (*((char *)this + 79) < 0)
          operator delete(*v3);
        *(_OWORD *)v3 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((_QWORD *)this + 9) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
        __p.__r_.__value_.__s.__data_[0] = 0;
        if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v12.__r_.__value_.__l.__data_);
        break;
      case 3:
        SVGPaint::createStringRepresentation(*((SVGPaint **)this + 11), (uint64_t)&__p);
        goto LABEL_14;
      case 4:
        SVGPath::createStringRepresentation(*((SVGPath **)this + 11), &__p);
        goto LABEL_14;
      case 6:
      case 7:
      case 8:
        SVGMask::createStringRepresentation(*((SVGMask **)this + 11), &__p);
LABEL_14:
        if (*((char *)this + 79) < 0)
          operator delete(*v3);
        *(_OWORD *)v3 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((_QWORD *)this + 9) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        return (uint64_t)this + 56;
      default:
        return (uint64_t)this + 56;
    }
  }
  return (uint64_t)this + 56;
}

void sub_2067740CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *CFRetained::getObject<SVGAttribute>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void SVGReader::parseXMLNode(SVGNode **this, _xmlNode *a2, SVGNode *a3)
{
  const char *v6;
  uint64_t v7;
  SVGReader *name;
  uint64_t v9;
  SVGAttributeMap *v10;
  SVGReader *v11;
  SVGAttributeMap *v12;
  const SVGAttributeMap **v13;
  _xmlNode *i;
  const char *v15;
  SVGAttributeMap *v16;
  const SVGAttributeMap **v17;
  SVGReader *v18;
  uint64_t v19;
  _xmlNode *children;
  int v21;
  SVGNode *v22;
  SVGNode **v23;
  SVGNode **v24;
  SVGNode *v25;
  SVGAttributeMap *v26;
  const SVGAttributeMap **v27;
  _xmlNode *j;
  _xmlNode *k;

  if (a2->type != XML_COMMENT_NODE && !xmlNodeIsText(a2))
  {
    if (a2->type == XML_CDATA_SECTION_NODE)
    {
      SVGUtilities::log((SVGUtilities *)"CDATA section node is not currently supported", v6);
      return;
    }
    name = (SVGReader *)a2->name;
    if (!name || !*(_BYTE *)name)
    {
      SVGReader::report(name, (SVGParser *)"Invalid node name", a2->line, v7);
      return;
    }
    v9 = SVGAtom::ToName(name, v6);
    v10 = (SVGAttributeMap *)operator new();
    SVGAttributeMap::SVGAttributeMap(v10);
    SVGReader::parseXMLNodeAttributes((SVGReader *)this, a2, v10);
    if ((_DWORD)v9 == 29)
    {
      v11 = (SVGReader *)operator new();
      SVGNode::SVGNode(v11, 29);
      v13 = (const SVGAttributeMap **)*this;
      if (*this && *v13)
        ApplyVariablesToAttributes(*v13, v10);
      SVGReader::ApplyStyleToAttributes(v11, this[2], v10, v12);
      SVGNode::setAttributes(v11, (CFTypeRef *)v10);
      for (i = a2->children; i; i = i->next)
        SVGReader::parseXMLNode((SVGReader *)this, i, v11);
      goto LABEL_82;
    }
    if (SVGShapeNode::IsValidShapePrimitive(v9))
    {
      v11 = (SVGReader *)operator new();
      SVGShapeNode::SVGShapeNode(v11, v9);
      v17 = (const SVGAttributeMap **)*this;
      if (*this && *v17)
        ApplyVariablesToAttributes(*v17, v10);
      SVGReader::ApplyStyleToAttributes(v11, this[2], v10, v16);
      v18 = (SVGReader *)SVGNode::setAttributes(v11, (CFTypeRef *)v10);
      if ((_DWORD)v9 != 10001)
        goto LABEL_82;
      if (*this && *((_BYTE *)*this + 8))
      {
        SVGReader::report(v18, (SVGParser *)"Text element is not allowed in strict mode", a2->line, v19);
        CFRetained::release((CFTypeRef *)v11);
LABEL_79:
        CFRetained::release((CFTypeRef *)v10);
        return;
      }
      goto LABEL_81;
    }
    if ((int)v9 > 60)
    {
      if ((int)v9 > 76)
      {
        switch((_DWORD)v9)
        {
          case 'M':
            v11 = SVGReader::parseXMLNodeImage(this, a2);
LABEL_82:
            CFRetained::release((CFTypeRef *)v10);
            SVGNode::addChild(a3, v11);
            CFRetained::release((CFTypeRef *)v11);
            return;
          case 'O':
            SVGReader::parseXMLNodePattern(this, a2, a3);
            goto LABEL_79;
          case 'T':
            SVGReader::parseXMLNodeFilter(this, a2, a3);
            goto LABEL_79;
        }
      }
      else
      {
        switch((_DWORD)v9)
        {
          case '=':
            v11 = (SVGReader *)operator new();
            SVGRootNode::SVGRootNode(v11);
            v27 = (const SVGAttributeMap **)*this;
            if (*this && *v27)
              ApplyVariablesToAttributes(*v27, v10);
            SVGReader::ApplyStyleToAttributes(v11, this[2], v10, v26);
            SVGNode::setAttributes(v11, (CFTypeRef *)v10);
            for (j = a2->children; j; j = j->next)
              SVGReader::parseXMLNode((SVGReader *)this, j, v11);
            goto LABEL_82;
          case '>':
            v11 = (SVGReader *)operator new();
            SVGNode::SVGNode(v11, 29);
            SVGNode::setAttributes(v11, (CFTypeRef *)v10);
            for (k = a2->children; k; k = k->next)
              SVGReader::parseXMLNode((SVGReader *)this, k, v11);
            goto LABEL_82;
          case 'J':
            SVGReader::parseXMLNodeMask(this, a2, a3);
            goto LABEL_79;
        }
      }
      goto LABEL_80;
    }
    if ((int)v9 > 32)
    {
      if ((_DWORD)v9 == 33 || (_DWORD)v9 == 48)
      {
        SVGReader::parseXMLNodeGradient(this, a2, a3, v9);
        goto LABEL_79;
      }
      if ((_DWORD)v9 == 60)
      {
        SVGReader::parseXMLNodeStyle((SVGReader *)this, a2);
        goto LABEL_79;
      }
      goto LABEL_80;
    }
    if ((_DWORD)v9 == 5)
    {
      SVGReader::parseXMLNodeClipPath(this, a2, a3);
      goto LABEL_79;
    }
    if ((_DWORD)v9 != 14)
    {
LABEL_80:
      v11 = (SVGReader *)operator new();
      SVGNode::SVGNode(v11, v9);
      SVGNode::setAttributes(v11, (CFTypeRef *)v10);
LABEL_81:
      SetNodeTextIfAvailable(a2, v11);
      goto LABEL_82;
    }
    children = a2->children;
    if (!children)
      goto LABEL_79;
    while (1)
    {
      v21 = SVGAtom::ToName((SVGAtom *)children->name, v15);
      if (v21 > 59)
      {
        if (v21 > 78)
        {
          if (v21 == 79)
          {
            SVGReader::parseXMLNodePattern(this, children, a3);
          }
          else
          {
            if (v21 != 84)
              goto LABEL_60;
            SVGReader::parseXMLNodeFilter(this, children, a3);
          }
        }
        else if (v21 == 60)
        {
          SVGReader::parseXMLNodeStyle((SVGReader *)this, children);
        }
        else
        {
          if (v21 != 74)
            goto LABEL_60;
          SVGReader::parseXMLNodeMask(this, children, a3);
        }
      }
      else if (v21 > 32)
      {
        if (v21 != 33 && v21 != 48)
        {
LABEL_60:
          v22 = (SVGNode *)operator new();
          SVGNode::SVGNode(v22, 14);
          SVGReader::parseXMLNode((SVGReader *)this, children, v22);
          v23 = (SVGNode **)*((_QWORD *)v22 + 11);
          v24 = (SVGNode **)*((_QWORD *)v22 + 12);
          while (v23 != v24)
          {
            v25 = *v23++;
            SVGNode::addDefinitionNode(this[1], a3, v25);
          }
          CFRetained::release((CFTypeRef *)v22);
          goto LABEL_64;
        }
        SVGReader::parseXMLNodeGradient(this, children, a3, v21);
      }
      else if (v21 == 5)
      {
        SVGReader::parseXMLNodeClipPath(this, children, a3);
      }
      else
      {
        if (v21 != 14)
          goto LABEL_60;
        SVGReader::parseXMLNode((SVGReader *)this, children, a3);
      }
LABEL_64:
      children = children->next;
      if (!children)
        goto LABEL_79;
    }
  }
}

void sub_2067746E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C408E750C55);
  _Unwind_Resume(a1);
}

uint64_t SVGNode::setAttributes(SVGNode *this, CFTypeRef *a2)
{
  SVGAttributeMap *v5;

  SVGAttributeMap::setOwnerNode(*((_QWORD *)this + 7), 0);
  CFRetained::release(*((CFTypeRef **)this + 7));
  if (a2)
  {
    *((_QWORD *)this + 7) = a2;
    CFRetained::retain(a2);
    SVGAttributeMap::setOwnerNode(*((_QWORD *)this + 7), (uint64_t)this);
    return (*(uint64_t (**)(SVGNode *, CFTypeRef *))(*(_QWORD *)this + 24))(this, a2);
  }
  else
  {
    v5 = (SVGAttributeMap *)operator new();
    SVGAttributeMap::SVGAttributeMap(v5);
    *((_QWORD *)this + 7) = v5;
    return SVGAttributeMap::setOwnerNode((uint64_t)v5, (uint64_t)this);
  }
}

void sub_2067747F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

uint64_t SVGAttributeMap::setOwnerNode(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 72) = a2;
  return result;
}

BOOL SVGShapeNode::IsValidShapePrimitive(unsigned int a1)
{
  return a1 <= 0x31 && ((1 << a1) & 0x2341100010008) != 0 || a1 == 10001;
}

void SVGReader::ApplyStyleToAttributes(SVGReader *this, SVGNode *a2, SVGStyle *a3, SVGAttributeMap *a4)
{
  SVGAttribute *v7;
  uint64_t v8;
  __int128 v9;
  SVGAttributeMap *v10;
  SVGAttributeMap *v11;
  SVGAttribute *v12;
  BOOL AttributeMapForClassAttribute;
  SVGAttribute *v14;
  BOOL AttributeMapForIdentifierAttribute;
  _BOOL4 AttributeMapForElement;
  SVGAttributeMap *v17;
  std::string v18;
  std::string v19;
  __int128 *v20;
  __int128 *v21;
  std::string v22;
  __int128 **v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t, unsigned int *);
  void *v26;
  SVGStyle *v27;

  v7 = (SVGAttribute *)SVGAttributeMap::attribute((uint64_t)a3, 0x3Cu);
  if (!v7)
    goto LABEL_11;
  v8 = SVGAttribute::stringValue(v7);
  if (*(char *)(v8 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)v8, *(_QWORD *)(v8 + 8));
  }
  else
  {
    v9 = *(_OWORD *)v8;
    v22.__r_.__value_.__r.__words[2] = *(_QWORD *)(v8 + 16);
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v9;
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v19, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
  else
    v19 = v22;
  SVGParser::ParseDeclarationBlockFromRuleset((char *)&v19, 1, (uint64_t *)&v20);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  v10 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v10);
  memset(&v18, 0, sizeof(v18));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v18, v20, v21, 0xAAAAAAAAAAAAAAABLL * (((char *)v21 - (char *)v20) >> 3));
  SVGParser::ParseDeclarationBlockIntoAttributeMap((__int128 **)&v18, (uint64_t)v10);
  v23 = (__int128 **)&v18;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v23);
  SVGAttributeMap::filter((uint64_t)v10, (uint64_t (*)(_QWORD, _QWORD))SVGReader::ApplyStyleToAttributes(SVGNode *,SVGStyle *,SVGAttributeMap *)::$_0::__invoke);
  v23 = (__int128 **)MEMORY[0x24BDAC760];
  v24 = 0x40000000;
  v25 = ___ZL33ApplyUniqueAttributesToAttributesP15SVGAttributeMapS0__block_invoke;
  v26 = &__block_descriptor_tmp_21;
  v27 = a3;
  SVGAttributeMap::enumerate((uint64_t)v10, (uint64_t)&v23);
  CFRetained::release((CFTypeRef *)v10);
  v23 = &v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v23);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v22.__r_.__value_.__l.__data_);
    if (!a2)
      return;
  }
  else
  {
LABEL_11:
    if (!a2)
      return;
  }
  v11 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v11);
  v12 = (SVGAttribute *)SVGAttributeMap::attribute((uint64_t)a3, 4u);
  AttributeMapForClassAttribute = SVGStyle::getAttributeMapForClassAttribute(a2, v12, v11);
  v14 = (SVGAttribute *)SVGAttributeMap::attribute((uint64_t)a3, 0x1Fu);
  AttributeMapForIdentifierAttribute = SVGStyle::getAttributeMapForIdentifierAttribute(a2, v14, v11);
  AttributeMapForElement = SVGStyle::getAttributeMapForElement(a2, this, v11);
  if (AttributeMapForClassAttribute || AttributeMapForIdentifierAttribute || AttributeMapForElement)
  {
    SVGAttributeMap::filter((uint64_t)v11, (uint64_t (*)(_QWORD, _QWORD))SVGReader::ApplyStyleToAttributes(SVGNode *,SVGStyle *,SVGAttributeMap *)::$_1::__invoke);
    v23 = (__int128 **)MEMORY[0x24BDAC760];
    v24 = 0x40000000;
    v25 = ___ZL33ApplyUniqueAttributesToAttributesP15SVGAttributeMapS0__block_invoke;
    v26 = &__block_descriptor_tmp_21;
    v27 = a3;
    SVGAttributeMap::enumerate((uint64_t)v11, (uint64_t)&v23);
  }
  CFRetained::release((CFTypeRef *)v11);
  if (*((_BYTE *)a2 + 24))
  {
    v17 = (SVGAttributeMap *)operator new();
    SVGAttributeMap::SVGAttributeMap(v17);
    SVGStyle::getAttributeMapForIdentifier(a2, ":root", v17);
    ApplyVariablesToAttributes(v17, a3);
    CFRetained::release((CFTypeRef *)v17);
  }
}

void sub_206774B28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGReader::resolveDefinitions(SVGNode **this, SVGNode *a2)
{
  const char *v4;
  SVGNode **v5;
  SVGNode **v6;
  SVGNode *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  SVGNode **v11;
  SVGNode **v12;
  SVGNode *v13;
  char *v14;
  char *v15;
  BOOL v16;

  SVGReader::ResolveAttributeDefinition((uint64_t)this, (uint64_t)a2, 18);
  SVGReader::ResolveAttributeDefinition((uint64_t)this, (uint64_t)a2, 57);
  SVGReader::ResolveAttributeDefinition((uint64_t)this, (uint64_t)a2, 6);
  SVGReader::ResolveAttributeDefinition((uint64_t)this, (uint64_t)a2, 74);
  SVGReader::ResolveAttributeDefinition((uint64_t)this, (uint64_t)a2, 84);
  SVGReader::resolveUseDefinition(this, a2);
  v5 = (SVGNode **)*((_QWORD *)a2 + 11);
  v6 = (SVGNode **)*((_QWORD *)a2 + 12);
  while (v5 != v6)
  {
    v7 = *v5++;
    SVGReader::resolveDefinitions((SVGReader *)this, v7);
  }
  v8 = (char *)*((_QWORD *)a2 + 20);
  v9 = (char *)a2 + 168;
  if (v8 != (char *)a2 + 168)
  {
    do
    {
      v10 = *((_QWORD *)v8 + 7);
      ResolvePatternHrefDefinition(v10, v4);
      v12 = *(SVGNode ***)(v10 + 88);
      v11 = *(SVGNode ***)(v10 + 96);
      while (v12 != v11)
      {
        v13 = *v12++;
        SVGReader::resolveDefinitions((SVGReader *)this, v13);
      }
      v14 = (char *)*((_QWORD *)v8 + 1);
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = *(char **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (char *)*((_QWORD *)v8 + 2);
          v16 = *(_QWORD *)v15 == (_QWORD)v8;
          v8 = v15;
        }
        while (!v16);
      }
      v8 = v15;
    }
    while (v15 != v9);
  }
}

void SVGReader::ResolveAttributeDefinition(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  SVGAttribute *v7;
  const char *v8;
  uint64_t v9;
  char *p_p;
  SVGNode *DefinitionNode;
  SVGNode *v12;
  SVGNode *v13;
  const char *v14;
  SVGNode *v15;
  _QWORD *v16;
  char *v17;
  char *v18;
  const char *v19;
  void *v20;
  void *v21;
  CFTypeRef *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  SVGNode *v27;
  const char *v28;
  SVGNode *v29;
  _QWORD *v30;
  char *v31;
  char *v32;
  const char *v33;
  void *__p;
  uint64_t v35;
  uint64_t v36;

  v6 = *(_QWORD *)(a2 + 56);
  v7 = (SVGAttribute *)SVGAttributeMap::attribute(v6, a3);
  if (v7)
  {
    v9 = (uint64_t)v7;
    if (!*((_DWORD *)v7 + 20) && SVGAttribute::stringValueBeginsWith(v7, "url", v8))
    {
      __p = 0;
      v35 = 0;
      v36 = 0;
      if (!SVGAttribute::urlValue(v9, (uint64_t)&__p))
        goto LABEL_37;
      if (SHIBYTE(v36) < 0)
      {
        if (!v35)
          goto LABEL_37;
        p_p = (char *)__p;
      }
      else
      {
        if (!HIBYTE(v36))
          goto LABEL_37;
        p_p = (char *)&__p;
      }
      DefinitionNode = SVGNode::findDefinitionNode(*(SVGNode **)(a1 + 8), p_p);
      v12 = DefinitionNode;
      if (!DefinitionNode)
      {
LABEL_37:
        if (SHIBYTE(v36) < 0)
          operator delete(__p);
        return;
      }
      if ((int)a3 <= 56)
      {
        if ((_DWORD)a3 != 6)
        {
          if ((_DWORD)a3 != 18)
            goto LABEL_37;
LABEL_18:
          if (v13)
          {
            v15 = v13;
            ResolveGradientHrefDefinition((uint64_t)v12, v14);
            if (SVGNode::isChildOf(a2, (uint64_t)v15))
            {
              v16 = (_QWORD *)(a2 + 64);
              if (*(char *)(a2 + 87) < 0)
                v16 = (_QWORD *)*v16;
              v17 = SVGNode::identifier((SVGNode *)a2);
              v18 = SVGNode::identifier(v15);
              SVGUtilities::log((SVGUtilities *)"Error: Cyclical depedency found when trying to resolve node: %s(%s) attributes with gradient(%s)", v19, v16, v17, v18);
              goto LABEL_37;
            }
            v22 = (CFTypeRef *)operator new();
            SVGAttribute::SVGAttribute(v22, a3, v15);
          }
          else
          {
            if (!v27)
              goto LABEL_37;
            v29 = v27;
            ResolvePatternHrefDefinition((uint64_t)v12, v28);
            if (SVGNode::isChildOf(a2, (uint64_t)v29))
            {
              v30 = (_QWORD *)(a2 + 64);
              if (*(char *)(a2 + 87) < 0)
                v30 = (_QWORD *)*v30;
              v31 = SVGNode::identifier((SVGNode *)a2);
              v32 = SVGNode::identifier(v29);
              SVGUtilities::log((SVGUtilities *)"Error: Cyclical depedency found when trying to resolve node: %s(%s) attributes with pattern(%s)", v33, v30, v31, v32);
              goto LABEL_37;
            }
            v22 = (CFTypeRef *)operator new();
            SVGAttribute::SVGAttribute(v22, a3, v29);
          }
          goto LABEL_36;
        }
        if (!v25)
          goto LABEL_37;
        v26 = v25;
        v22 = (CFTypeRef *)operator new();
        SVGAttribute::SVGAttribute(v22, 6, v26);
      }
      else
      {
        switch((_DWORD)a3)
        {
          case 'T':
            if (!v20)
              goto LABEL_37;
            v21 = v20;
            v22 = (CFTypeRef *)operator new();
            SVGAttribute::SVGAttribute(v22, 84, v21);
            break;
          case 'J':
            if (!v23)
              goto LABEL_37;
            v24 = v23;
            v22 = (CFTypeRef *)operator new();
            SVGAttribute::SVGAttribute(v22, 74, v24);
            break;
          case '9':
            goto LABEL_18;
          default:
            goto LABEL_37;
        }
      }
LABEL_36:
      SVGAttributeMap::setAttribute(v6, (uint64_t)v22, 0);
      CFRetained::release(v22);
      goto LABEL_37;
    }
  }
}

void sub_206775030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;

  MEMORY[0x20BCFC038](v17, 0x10B3C405B4D0908);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t SVGAttributeMap::attribute(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  uint64_t *v8;

  v4 = *(_QWORD *)(a1 + 56);
  v2 = a1 + 56;
  v3 = v4;
  if (!v4)
    return 0;
  v5 = v2;
  do
  {
    v6 = *(_DWORD *)(v3 + 32);
    v7 = v6 >= a2;
    if (v6 >= a2)
      v8 = (uint64_t *)v3;
    else
      v8 = (uint64_t *)(v3 + 8);
    if (v7)
      v5 = v3;
    v3 = *v8;
  }
  while (*v8);
  if (v5 != v2 && *(_DWORD *)(v5 + 32) <= a2)
    return *(_QWORD *)(v5 + 40);
  else
    return 0;
}

void SVGReader::resolveUseDefinition(SVGNode **this, SVGNode *a2)
{
  SVGAtom *v4;
  SVGAttribute *Attribute;
  uint64_t v6;
  __int128 v7;
  int v8;
  std::string::size_type size;
  std::string *v10;
  _QWORD *ChildWithIdentifier;
  std::string *v12;
  SVGNode *v13;
  uint64_t *v14;
  SVGStyle *v15;
  uint64_t v16;
  SVGAttributeMap *v17;
  int v18;
  os_unfair_lock_s *v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  const std::string::value_type *p_p;
  std::string::size_type v24;
  const std::string::value_type *v25;
  std::string::size_type v26;
  uint64_t v27;
  CFTypeRef *v28;
  std::string *v29;
  SVGNode *v30;
  SVGNode *v31;
  SVGNode *v32;
  SVGNode *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  SVGNode *v39;
  SVGNode *v40;
  SVGNode *v41;
  SVGNode *v42;
  uint64_t v43;
  void *__p;
  std::string::size_type v45;
  unsigned __int8 v46;
  int64x2_t v47;
  int64x2_t v48;
  std::string v49;
  std::string v50;
  CGRect v51;
  std::string *v52;
  int64x2_t *v53;
  std::string v54;
  char v55;

  v4 = (SVGNode *)((char *)a2 + 64);
  if (*((char *)a2 + 87) < 0)
    v4 = *(SVGAtom **)v4;
  if (SVGAtom::ToName(v4, (const char *)a2) == 20001)
  {
    Attribute = (SVGAttribute *)SVGNode::findAttribute((uint64_t)a2, 0x4E20u);
    if (Attribute)
    {
      v6 = SVGAttribute::stringValue(Attribute);
      if (*(char *)(v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v49, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
      }
      else
      {
        v7 = *(_OWORD *)v6;
        v49.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
        *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v7;
      }
      SVGParser::StripLeadingTrailingWhitespace(&v49, &v50);
      if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v49.__r_.__value_.__l.__data_);
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(&v50, (char *)&unk_20679A6BE);
    }
    v8 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
    if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v50.__r_.__value_.__r.__words[2]);
    else
      size = v50.__r_.__value_.__l.__size_;
    if (size)
    {
      if (*std::string::at(&v50, 0) == 35)
        std::string::erase(&v50, 0, 1uLL);
      v8 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
    }
    if ((v8 & 0x80) != 0)
    {
      if (v50.__r_.__value_.__l.__size_)
      {
        v10 = (std::string *)v50.__r_.__value_.__r.__words[0];
        goto LABEL_23;
      }
    }
    else if (v8)
    {
      v10 = &v50;
LABEL_23:
      ChildWithIdentifier = (_QWORD *)SVGNode::findChildWithIdentifier(this[1], (char *)v10);
      if (ChildWithIdentifier
        || ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (v12 = &v50)
          : (v12 = (std::string *)v50.__r_.__value_.__r.__words[0]),
            (ChildWithIdentifier = SVGNode::findDefinitionNode(a2, (char *)v12)) != 0))
      {
        v13 = (SVGNode *)*((_QWORD *)a2 + 6);
        v14 = (uint64_t *)(*(uint64_t (**)(_QWORD *))(*ChildWithIdentifier + 16))(ChildWithIdentifier);
        v15 = (SVGStyle *)*((_QWORD *)a2 + 7);
        v16 = ChildWithIdentifier[7];
        SVGReader::ApplyStyleToAttributes((SVGReader *)v14, this[2], v15, v17);
        v47 = vdupq_n_s64(0x7FF8000000000000uLL);
        v48 = v47;
        v54.__r_.__value_.__r.__words[0] = 0;
        v54.__r_.__value_.__l.__size_ = (std::string::size_type)&v54;
        v54.__r_.__value_.__r.__words[2] = 0x2000000000;
        v55 = 0;
        *(_QWORD *)&v51.origin.x = MEMORY[0x24BDAC760];
        *(_QWORD *)&v51.origin.y = 0x40000000;
        *(_QWORD *)&v51.size.width = ___ZL28ConvertUseElementCoordinatesP15SVGAttributeMapR6CGRect_block_invoke;
        *(_QWORD *)&v51.size.height = &unk_24BFD9390;
        v52 = &v54;
        v53 = &v47;
        SVGAttributeMap::enumerate((uint64_t)v15, (uint64_t)&v51);
        if (*(_BYTE *)(v54.__r_.__value_.__l.__size_ + 24))
        {
          SVGAttributeMap::removeAttribute((uint64_t)v15, 0x43u);
          SVGAttributeMap::removeAttribute((uint64_t)v15, 0x46u);
          SVGAttributeMap::removeAttribute((uint64_t)v15, 0x42u);
          SVGAttributeMap::removeAttribute((uint64_t)v15, 0x1Eu);
          v18 = *(unsigned __int8 *)(v54.__r_.__value_.__l.__size_ + 24);
          _Block_object_dispose(&v54, 8);
          if (v18)
          {
            v19 = (os_unfair_lock_s *)SVGAttributeMap::attribute(v16, 0x41u);
            if (!v19 || (SVGAttribute::rectValue(v19, &v51) & 1) == 0)
            {
              v51.origin.x = (*(double (**)(_QWORD *, _QWORD))(*ChildWithIdentifier + 32))(ChildWithIdentifier, 0);
              v51.origin.y = v20;
              v51.size.width = v21;
              v51.size.height = v22;
            }
            memset(&v54, 0, sizeof(v54));
            SVGParser::FormatString((SVGParser *)"translate(%g,%g)", &__p, *(_OWORD *)&v47);
            if ((v46 & 0x80u) == 0)
              p_p = (const std::string::value_type *)&__p;
            else
              p_p = (const std::string::value_type *)__p;
            if ((v46 & 0x80u) == 0)
              v24 = v46;
            else
              v24 = v45;
            std::string::append(&v54, p_p, v24);
            if ((char)v46 < 0)
              operator delete(__p);
            if (v51.size.width > 0.0 && v51.size.height > 0.0)
            {
              SVGParser::FormatString((SVGParser *)"scale(%g,%g)", &__p, *(double *)v48.i64 / v51.size.width, *(double *)&v48.i64[1] / v51.size.height);
              v25 = (v46 & 0x80u) == 0 ? (const std::string::value_type *)&__p : (const std::string::value_type *)__p;
              v26 = (v46 & 0x80u) == 0 ? v46 : v45;
              std::string::append(&v54, v25, v26);
              if ((char)v46 < 0)
                operator delete(__p);
            }
            v27 = operator new();
            v28 = (CFTypeRef *)v27;
            if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v29 = &v54;
            else
              v29 = (std::string *)v54.__r_.__value_.__r.__words[0];
            SVGAttribute::SVGAttribute(v27, 63, v29);
            SVGAttributeMap::setAttribute((uint64_t)v15, (uint64_t)v28, 0);
            CFRetained::release(v28);
            if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v54.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          _Block_object_dispose(&v54, 8);
        }
        SVGAttributeMap::removeAttribute((uint64_t)v15, 0x4E20u);
        SVGAttributeMap::removeAttribute(v14[7], 0x1Fu);
        SVGNode::addUniqueAttributes((SVGAttributeMap **)v14, v15);
        SVGNode::setIdentifier((SVGNode *)v14, 0);
        CFRetained::retain((CFTypeRef *)a2);
        SVGNode::addChild(a2, (SVGNode *)v14);
        SVGNode::replaceChildWithChild(v13, (CFTypeRef *)a2, (CFTypeRef *)v14);
        CFRetained::release((CFTypeRef *)v14);
        v30 = this[5];
        v31 = this[4];
        if (v31 >= v30)
        {
          v33 = this[3];
          v34 = (v31 - v33) >> 3;
          if ((unint64_t)(v34 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v35 = v30 - v33;
          v36 = v35 >> 2;
          if (v35 >> 2 <= (unint64_t)(v34 + 1))
            v36 = v34 + 1;
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
            v37 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v37 = v36;
          if (v37)
            v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(this + 5), v37);
          else
            v38 = 0;
          v39 = (SVGNode *)&v38[8 * v34];
          v40 = (SVGNode *)&v38[8 * v37];
          *(_QWORD *)v39 = a2;
          v32 = (SVGNode *)((char *)v39 + 8);
          v42 = this[3];
          v41 = this[4];
          if (v41 != v42)
          {
            do
            {
              v43 = *((_QWORD *)v41 - 1);
              v41 = (SVGNode *)((char *)v41 - 8);
              *((_QWORD *)v39 - 1) = v43;
              v39 = (SVGNode *)((char *)v39 - 8);
            }
            while (v41 != v42);
            v41 = this[3];
          }
          this[3] = v39;
          this[4] = v32;
          this[5] = v40;
          if (v41)
            operator delete(v41);
        }
        else
        {
          *(_QWORD *)v31 = a2;
          v32 = (SVGNode *)((char *)v31 + 8);
        }
        this[4] = v32;
      }
    }
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v50.__r_.__value_.__l.__data_);
  }
}

void sub_206775604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (a17 < 0)
    operator delete(__p);
  if (*(char *)(v33 - 89) < 0)
    operator delete(*(void **)(v33 - 112));
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

BOOL SVGStyle::getAttributeMapForIdentifierAttribute(SVGStyle *this, SVGAttribute *a2, SVGAttributeMap *a3)
{
  uint64_t v5;
  __int128 v6;
  _BOOL8 AttributeMapForIdentifier;
  std::string *p_p;
  std::string __p;

  if (!a2 || *((_DWORD *)a2 + 12) != 31)
    return 0;
  v5 = SVGAttribute::stringValue(a2);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
  }
  else
  {
    v6 = *(_OWORD *)v5;
    __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v6;
  }
  std::string::insert(&__p, 0, "#");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  AttributeMapForIdentifier = SVGStyle::getAttributeMapForIdentifier(this, (char *)p_p, a3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return AttributeMapForIdentifier;
}

void sub_206775788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL SVGStyle::getAttributeMapForElement(SVGStyle *this, SVGNode *a2, SVGAttributeMap *a3)
{
  char *v4;

  if (!a2)
    return 0;
  v4 = (char *)a2 + 64;
  if (*((char *)a2 + 87) < 0)
    v4 = *(char **)v4;
  return SVGStyle::getAttributeMapForIdentifier(this, v4, a3);
}

BOOL SVGStyle::getAttributeMapForClassAttribute(SVGStyle *this, SVGAttribute *a2, SVGAttributeMap *a3)
{
  uint64_t v5;
  __int128 v6;
  std::string *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __int128 v12;
  std::string *p_p;
  int v14;
  std::string __p;
  uint64_t v16;
  uint64_t v17;
  std::string v18;

  if (!a2 || *((_DWORD *)a2 + 12) != 4)
    return 0;
  v5 = SVGAttribute::stringValue(a2);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
  }
  else
  {
    v6 = *(_OWORD *)v5;
    v18.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 16);
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v6;
  }
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = &v18;
  else
    v8 = (std::string *)v18.__r_.__value_.__r.__words[0];
  SVGParser::ParseClassPropertyValue((SVGParser *)v8, &v16);
  v9 = v16;
  v10 = v17;
  if (v16 == v17)
  {
    v14 = 0;
  }
  else
  {
    v11 = 0;
    do
    {
      if (*(char *)(v9 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v9, *(_QWORD *)(v9 + 8));
      }
      else
      {
        v12 = *(_OWORD *)v9;
        __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 16);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v12;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (SVGStyle::getAttributeMapForIdentifier(this, (char *)p_p, a3))
        v11 = 1;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v9 += 24;
    }
    while (v9 != v10);
    v14 = v11;
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  return v14 != 0;
}

void sub_206775918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGRootNode::SVGRootNode(SVGRootNode *this)
{
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, "svg");
  SVGViewBoxNode::SVGViewBoxNode(this, (char *)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8BA8;
  *((_QWORD *)this + 34) = 0;
}

void sub_2067759C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SVGNode *SVGViewBoxNode::SVGViewBoxNode(SVGNode *a1, char *a2)
{
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;
  CFTypeRef *v6;

  if (a2[23] < 0)
    a2 = *(char **)a2;
  SVGNode::SVGNode(a1, a2);
  *(_QWORD *)v3 = off_24BFD8C98;
  v4 = (_OWORD *)MEMORY[0x24BDBF148];
  *(_OWORD *)(v3 + 200) = *MEMORY[0x24BDBEFB0];
  *(_OWORD *)(v3 + 216) = *v4;
  v5 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(v3 + 232) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(v3 + 248) = v5;
  *(_QWORD *)(v3 + 264) = 5;
  v6 = (CFTypeRef *)SVGAttributeMap::CreateWithDefaults((SVGAttributeMap *)v3);
  SVGNode::setAttributes(a1, v6);
  CFRetained::release(v6);
  return a1;
}

void sub_206775A80(_Unwind_Exception *a1)
{
  SVGNode *v1;

  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

uint64_t SVGViewBoxNode::updatedAttributes(uint64_t a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN14SVGViewBoxNode17updatedAttributesEP15SVGAttributeMap_block_invoke;
  v3[3] = &__block_descriptor_tmp_12;
  v3[4] = a1;
  return SVGAttributeMap::enumerate(a2, (uint64_t)v3);
}

void SVGNode::SVGNode(SVGNode *this, char *a2)
{
  SVGAttributeMap *v4;
  void *__p[2];
  char v6;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8DD8;
  *((_QWORD *)this + 6) = 0;
  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4);
  *((_QWORD *)this + 7) = v4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 8, a2);
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 17) = (char *)this + 144;
  *((_QWORD *)this + 19) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 20) = (char *)this + 168;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 22) = 0;
  SVGAttributeMap::setOwnerNode(*((_QWORD *)this + 7), (uint64_t)this);
}

void sub_206775BE4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v7;
  void *v8;

  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v3, *(char **)(v1 + 168));
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v4, *(char **)(v1 + 144));
  v7 = *(void **)(v1 + 112);
  if (v7)
  {
    *(_QWORD *)(v1 + 120) = v7;
    operator delete(v7);
  }
  v8 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 96) = v8;
    operator delete(v8);
  }
  if (*(char *)(v1 + 87) < 0)
    operator delete(*v2);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGShapeNode::updatedAttributes(uint64_t a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN12SVGShapeNode17updatedAttributesEP15SVGAttributeMap_block_invoke;
  v3[3] = &__block_descriptor_tmp_13;
  v3[4] = a1;
  return SVGAttributeMap::enumerate(a2, (uint64_t)v3);
}

SVGShapeNode *SVGShapeNode::SVGShapeNode(SVGShapeNode *a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  _QWORD *v6;
  const char *v7;
  SVGPath *v8;

  v4 = SVGNode::SVGNode((uint64_t)a1, a2);
  *(_QWORD *)v4 = &off_24BFD8C28;
  *(_OWORD *)(v4 + 216) = 0u;
  *(_OWORD *)(v4 + 232) = 0u;
  *(_OWORD *)(v4 + 248) = 0u;
  *(_QWORD *)(v4 + 280) = 0;
  *(_OWORD *)(v4 + 200) = 0u;
  *(_OWORD *)(v4 + 264) = 0u;
  *(_DWORD *)(v4 + 288) = a2;
  v5 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(v4 + 296) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(v4 + 312) = v5;
  if (!SVGShapeNode::IsValidShapePrimitive(a2))
  {
    v6 = SVGAtom::ToString(a2);
    SVGUtilities::error((SVGUtilities *)"SVGShapeNode: Invalid primitive: %s\n", v7, v6);
    *((_DWORD *)a1 + 72) = 0;
  }
  if (a2 == 42)
  {
    v8 = (SVGPath *)operator new();
    SVGPath::SVGPath(v8);
    SVGShapeNode::setPath(a1, v8);
    CFRetained::release((CFTypeRef *)v8);
  }
  return a1;
}

void sub_206775DD0(_Unwind_Exception *a1)
{
  SVGNode *v1;
  uint64_t v2;

  MEMORY[0x20BCFC038](v2, 0x10F3C40176D6E88);
  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

void SVGPath::SVGPath(SVGPath *this)
{
  uint64_t v2;
  __int128 v3;
  void *__p[2];
  char v5;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPath::kSVGPathClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v5 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8E28;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  v2 = MEMORY[0x24BDBD8B8];
  v3 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x24BDBD8B8];
  *((_OWORD *)this + 6) = v3;
  *((_OWORD *)this + 7) = *(_OWORD *)(v2 + 32);
  *((_DWORD *)this + 32) = 0;
}

void sub_206775E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGNode::SVGNode(uint64_t a1, unsigned int a2)
{
  SVGAttributeMap *v4;
  _QWORD *v5;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8DD8;
  *(_QWORD *)(a1 + 48) = 0;
  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 56) = v4;
  *(_QWORD *)(a1 + 136) = a1 + 144;
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 160) = a1 + 168;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  if (SVGAtom::ToString(a2))
  {
    MEMORY[0x20BCFBFCC](a1 + 64);
  }
  else
  {
    v5 = SVGAtom::ToString(0);
    MEMORY[0x20BCFBFCC](a1 + 64, v5);
  }
  SVGAttributeMap::setOwnerNode(*(_QWORD *)(a1 + 56), a1);
  return a1;
}

void sub_206775FC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x20BCFC038](v2, 0x10B3C4084D8EEBALL);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void SVGShapeNode::setPath(SVGShapeNode *this, SVGPath *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *((_QWORD *)this + 7);
  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, 11, a2);
  SVGAttributeMap::setAttribute(v3, v4, 1);
}

void sub_2067760D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void sub_206776194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void SVGAttributeMap::filter(uint64_t a1, uint64_t (*a2)(_QWORD, _QWORD))
{
  uint64_t **v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;

  v2 = (uint64_t **)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 48);
  v4 = (_QWORD *)(a1 + 56);
  if (v3 != (_QWORD *)(a1 + 56))
  {
    do
    {
      if ((a2(*((unsigned int *)v3 + 8), v3[5]) & 1) != 0)
      {
        v6 = (_QWORD *)v3[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = (_QWORD *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            v7 = (_QWORD *)v3[2];
            v8 = *v7 == (_QWORD)v3;
            v3 = v7;
          }
          while (!v8);
        }
      }
      else
      {
        CFRetained::release((CFTypeRef *)v3[5]);
        v9 = (_QWORD *)v3[1];
        v10 = v3;
        if (v9)
        {
          do
          {
            v7 = v9;
            v9 = (_QWORD *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v7 = (_QWORD *)v10[2];
            v8 = *v7 == (_QWORD)v10;
            v10 = v7;
          }
          while (!v8);
        }
        std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__remove_node_pointer(v2, v3);
        operator delete(v3);
      }
      v3 = v7;
    }
    while (v7 != v4);
  }
}

BOOL SVGAtom::isKnown(uint64_t a1, unsigned int a2)
{
  os_unfair_lock_s *v3;
  _BOOL8 v4;
  unsigned int v6;

  v6 = a2;
  v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v4 = std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::find<SVGAtom::Name>((_QWORD *)(a1 + 48), &v6) != 0;
  os_unfair_lock_unlock(v3);
  return v4;
}

uint64_t *std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::find<SVGAtom::Name>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

BOOL SVGAtom::IsKnown(unsigned int a1)
{
  if (SVGAtom::SharedInstance(void)::onceToken != -1)
    dispatch_once(&SVGAtom::SharedInstance(void)::onceToken, &__block_literal_global);
  return SVGAtom::isKnown(SVGAtom::SharedInstance(void)::instance, a1);
}

void SVGParser::ParseClassPropertyValue(SVGParser *this@<X0>, uint64_t *a2@<X8>)
{
  SVGParser *v3;
  int64_t v5;
  unint64_t v6;
  SVGParser *v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  SVGParser *v11;
  int64_t v12;
  unsigned int v13;
  int v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  std::string __dst;

  v3 = this;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v5 = strlen((const char *)this);
  if (v5 >= 1)
  {
    v6 = (unint64_t)v3 + v5;
    v7 = (SVGParser *)((char *)v3 + v5);
    v8 = MEMORY[0x24BDAC740];
    do
    {
      do
      {
        v9 = *(char *)v3;
        if ((v9 & 0x80000000) != 0)
          v10 = __maskrune(v9, 0x4000uLL);
        else
          v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
        if (!v10)
          break;
        v3 = (SVGParser *)((char *)v3 + 1);
      }
      while ((unint64_t)v3 < v6);
      v11 = v3;
      if ((unint64_t)v3 < v6)
      {
        v12 = v7 - v3;
        v11 = v3;
        while (1)
        {
          v13 = *(char *)v11;
          v14 = (v13 & 0x80000000) != 0 ? __maskrune(v13, 0x4000uLL) : *(_DWORD *)(v8 + 4 * v13 + 60) & 0x4000;
          if (v14 || *(_BYTE *)v11 == 44)
            break;
          v11 = (SVGParser *)((char *)v11 + 1);
          if (!--v12)
          {
            v11 = v7;
            break;
          }
        }
      }
      std::string::basic_string[abi:ne180100](&__dst, v3, v11 - v3);
      std::string::insert(&__dst, 0, ".");
      v15 = a2[1];
      if (v15 >= a2[2])
      {
        v17 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (__int128 *)&__dst);
      }
      else
      {
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)a2[1], __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else
        {
          v16 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          *(_QWORD *)(v15 + 16) = *((_QWORD *)&__dst.__r_.__value_.__l + 2);
          *(_OWORD *)v15 = v16;
        }
        v17 = v15 + 24;
        a2[1] = v15 + 24;
      }
      a2[1] = v17;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__dst.__r_.__value_.__l.__data_);
      v3 = (SVGParser *)((char *)v11 + 1);
    }
    while ((unint64_t)v11 + 1 < v6);
  }
}

void sub_206776598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _QWORD *v15;
  uint64_t v16;

  v15[1] = v16;
  if (a15 < 0)
    operator delete(__p);
  __p = v15;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGNode *>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__construct_node<std::pair<std::string const,SVGNode *>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__construct_node<std::pair<std::string const,SVGNode *>>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v6 + 7) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_2067766E0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, a3, (uint64_t)(v4 + 4)))break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void SVGReader::parseXMLNodeXmlNS(SVGReader *this, _xmlNode *a2, SVGAttributeMap *a3)
{
  xmlNs *nsDef;
  std::string __p;

  if (a2)
  {
    nsDef = a2->nsDef;
    if (nsDef)
    {
      std::string::basic_string[abi:ne180100]<0>(&__p, (char *)nsDef->href);
      SVGAttributeMap::setAttribute((uint64_t)a3, 105, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_2067767F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::addUniqueAttributes(SVGAttributeMap **this, const SVGAttributeMap *a2)
{
  CFTypeRef *v3;

  v3 = (CFTypeRef *)SVGAttributeMap::addUniqueAttributes(this[7], a2);
  (*((void (**)(SVGAttributeMap **, CFTypeRef *))*this + 3))(this, v3);
  CFRetained::release(v3);
}

SVGAttributeMap *SVGAttributeMap::addUniqueAttributes(SVGAttributeMap *this, const SVGAttributeMap *a2)
{
  SVGAttributeMap *v4;
  _QWORD v6[6];

  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4);
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 0x40000000;
  v6[2] = ___ZN15SVGAttributeMap19addUniqueAttributesEPKS__block_invoke;
  v6[3] = &__block_descriptor_tmp_16;
  v6[4] = this;
  v6[5] = v4;
  SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v6);
  return v4;
}

void sub_2067768E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

xmlChar *SVGReader::parseXMLNodeStyle(SVGReader *this, _xmlNode *cur)
{
  xmlChar *result;
  SVGParser *v4;
  SVGStyle *v5;

  result = xmlNodeGetContent(cur);
  if (result)
  {
    v4 = (SVGParser *)result;
    if (*result)
    {
      v5 = (SVGStyle *)*((_QWORD *)this + 2);
      if (!v5)
      {
        v5 = (SVGStyle *)operator new();
        SVGStyle::SVGStyle(v5);
        *((_QWORD *)this + 2) = v5;
      }
      SVGStyle::addDefinitionsFromCSS((uint64_t **)v5, v4);
    }
    return (xmlChar *)((uint64_t (*)(SVGParser *))*MEMORY[0x24BEDE758])(v4);
  }
  return result;
}

void sub_2067769A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x1020C402C28E7A6);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::stringValueBeginsWith(SVGAttribute *this, const char *a2, const char *a3)
{
  SVGParser *v4;

  v4 = (SVGAttribute *)((char *)this + 56);
  if (*((char *)this + 79) < 0)
    v4 = *(SVGParser **)v4;
  return SVGParser::StringBeginsWith(v4, a2, a3);
}

_QWORD *CGSVGNodeGetChildAtIndex(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v4;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    v4 = result[11];
    if ((unint64_t)a2 >= (result[12] - v4) >> 3)
      return 0;
    else
      return *(_QWORD **)(*(_QWORD *)(v4 + 8 * (_QWORD)a2) + 40);
  }
  return result;
}

uint64_t CGSVGNodeGetType(uint64_t a1, const char *a2)
{
  char *v2;
  char *v3;
  SVGAtom *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  int v23;

  v2 = (char *)CFRetained::getObject<SVGNode>(a1, a2);
  if (!v2)
    return 12;
  v3 = v2;
  {
    return 2;
  }
  {
    return 0;
  }
  v5 = (SVGAtom *)(v3 + 64);
  v6 = v3 + 64;
  if (v3[87] < 0)
    v6 = *(const char **)v5;
  v7 = (const char *)SVGAtom::ToString(0x1Du);
  if (!strcmp(v6, v7))
    return 1;
  v8 = v3 + 64;
  if (v3[87] < 0)
    v8 = *(const char **)v5;
  v9 = (const char *)SVGAtom::ToString(0x21u);
  if (!strcmp(v8, v9))
    return 4;
  v10 = v3 + 64;
  if (v3[87] < 0)
    v10 = *(const char **)v5;
  v11 = (const char *)SVGAtom::ToString(0x30u);
  if (!strcmp(v10, v11))
    return 5;
  v12 = v3 + 64;
  if (v3[87] < 0)
    v12 = *(const char **)v5;
  v13 = (const char *)SVGAtom::ToString(5u);
  if (!strcmp(v12, v13))
    return 6;
  v14 = v3 + 64;
  if (v3[87] < 0)
    v14 = *(const char **)v5;
  v15 = (const char *)SVGAtom::ToString(0x4Au);
  if (!strcmp(v14, v15))
    return 7;
  v16 = v3 + 64;
  if (v3[87] < 0)
    v16 = *(const char **)v5;
  v17 = (const char *)SVGAtom::ToString(0x4Du);
  if (!strcmp(v16, v17))
    return 9;
  v18 = v3 + 64;
  if (v3[87] < 0)
    v18 = *(const char **)v5;
  v19 = (const char *)SVGAtom::ToString(0x4Fu);
  if (!strcmp(v18, v19))
    return 8;
  v20 = v3 + 64;
  if (v3[87] < 0)
    v20 = *(const char **)v5;
  v21 = (const char *)SVGAtom::ToString(0x54u);
  if (!strcmp(v20, v21))
    return 10;
  if (v3[87] < 0)
    v5 = *(SVGAtom **)v5;
  v23 = SVGAtom::ToName(v5, v22);
  if (SVGFilter::IsValidFilterPrimitive(v23))
    return 11;
  else
    return 3;
}

void *CFRetained::getObject<SVGNode>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void SVGPath::~SVGPath(SVGPath *this)
{
  SVGPath::~SVGPath(this);
  JUMPOUT(0x20BCFC038);
}

{
  CFTypeRef **v2;
  CFTypeRef **v3;
  const void *v4;
  void *v5;

  *(_QWORD *)this = &off_24BFD8E28;
  v2 = (CFTypeRef **)*((_QWORD *)this + 6);
  v3 = (CFTypeRef **)*((_QWORD *)this + 7);
  while (v2 != v3)
    CFRetained::release(*v2++);
  v4 = (const void *)*((_QWORD *)this + 9);
  if (v4)
    CFRelease(v4);
  v5 = (void *)*((_QWORD *)this + 6);
  if (v5)
  {
    *((_QWORD *)this + 7) = v5;
    operator delete(v5);
  }
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

void ___ZN7SVGAtom14SharedInstanceEv_block_invoke()
{
  SVGAtom *v0;

  v0 = (SVGAtom *)operator new();
  SVGAtom::SVGAtom(v0);
  SVGAtom::SharedInstance(void)::instance = (uint64_t)v0;
}

void sub_206776D8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10A0C4095436CDBLL);
  _Unwind_Resume(a1);
}

void SVGAtom::SVGAtom(SVGAtom *this)
{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = (char *)this + 32;
  *((_QWORD *)this + 5) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
  *((_DWORD *)this + 22) = 0;
  SVGAtom::initializeTable(this);
}

void sub_206776E1C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::~__hash_table(v3);
  std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy(v2, *(char **)(v1 + 32));
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

_QWORD *SVGAtom::initializeTable(SVGAtom *this)
{
  unsigned int v3;

  SVGAtom::_mapInit((uint64_t)this, "accumulate", 142);
  v3 = 142;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "additive", 141);
  v3 = 141;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "animate", 131);
  v3 = 131;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "animateMotion", 133);
  v3 = 133;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "animateTransform", 134);
  v3 = 134;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "attributeName", 135);
  v3 = 135;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "attributeType", 136);
  v3 = 136;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "baseProfile", 106);
  v3 = 106;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "begin", 137);
  v3 = 137;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "bevel", 1);
  v3 = 1;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "bias", 124);
  v3 = 124;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "butt", 2);
  v3 = 2;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "by", 144);
  v3 = 144;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "calcMode", 152);
  v3 = 152;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "circle", 3);
  v3 = 3;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "class", 4);
  v3 = 4;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "clipPath", 5);
  v3 = 5;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "clip-path", 6);
  v3 = 6;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "clipPathUnits", 7);
  v3 = 7;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "clip-rule", 8);
  v3 = 8;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "color", 158);
  v3 = 158;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "cx", 9);
  v3 = 9;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "cy", 10);
  v3 = 10;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "d", 11);
  v3 = 11;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "defs", 14);
  v3 = 14;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "display-p3", 15);
  v3 = 15;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "divisor", 123);
  v3 = 123;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "dur", 138);
  v3 = 138;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "dx", 96);
  v3 = 96;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "dy", 97);
  v3 = 97;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "edgeMode", 127);
  v3 = 127;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "editable", 113);
  v3 = 113;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "ellipse", 16);
  v3 = 16;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "end", 146);
  v3 = 146;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "evenodd", 17);
  v3 = 17;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "extended-srgb", 73);
  v3 = 73;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "externalResourcesRequired", 108);
  v3 = 108;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feBlend", 101);
  v3 = 101;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feComposite", 114);
  v3 = 114;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feConvolveMatrix", 120);
  v3 = 120;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feFlood", 91);
  v3 = 91;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feGaussianBlur", 103);
  v3 = 103;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feImage", 94);
  v3 = 94;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feMerge", 98);
  v3 = 98;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feMergeNode", 99);
  v3 = 99;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feOffset", 95);
  v3 = 95;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "feTile", 100);
  v3 = 100;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "fill", 18);
  v3 = 18;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "fill-opacity", 19);
  v3 = 19;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "fill-rule", 20);
  v3 = 20;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "fill-stroke", 21);
  v3 = 21;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "filter", 84);
  v3 = 84;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "filterRes", 87);
  v3 = 87;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "filterUnits", 85);
  v3 = 85;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "flood-color", 92);
  v3 = 92;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "flood-opacity", 93);
  v3 = 93;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "focusable", 109);
  v3 = 109;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "font", 22);
  v3 = 22;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "font-family", 23);
  v3 = 23;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "font-size", 24);
  v3 = 24;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "font-weight", 25);
  v3 = 25;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "from", 139);
  v3 = 139;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "fx", 26);
  v3 = 26;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "fy", 27);
  v3 = 27;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "g", 29);
  v3 = 29;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "gradientTransform", 78);
  v3 = 78;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "gradientUnits", 28);
  v3 = 28;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "spreadMethod", 130);
  v3 = 130;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "height", 30);
  v3 = 30;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "id", 31);
  v3 = 31;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "image", 77);
  v3 = 77;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "in", 88);
  v3 = 88;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "in2", 89);
  v3 = 89;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "k1", 116);
  v3 = 116;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "k2", 117);
  v3 = 117;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "k3", 118);
  v3 = 118;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "k4", 119);
  v3 = 119;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "kernelMatrix", 122);
  v3 = 122;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "kernelUnitLength", 128);
  v3 = 128;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "keySplines", 154);
  v3 = 154;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "keyTimes", 153);
  v3 = 153;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "keyPoints", 156);
  v3 = 156;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "line", 32);
  v3 = 32;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "linearGradient", 33);
  v3 = 33;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "mask", 74);
  v3 = 74;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "maskUnits", 75);
  v3 = 75;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "maskContentUnits", 76);
  v3 = 76;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "max", 148);
  v3 = 148;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "mesh", 36);
  v3 = 36;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "min", 147);
  v3 = 147;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "miter", 37);
  v3 = 37;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "mode", 102);
  v3 = 102;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "mpath", 155);
  v3 = 155;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "nonzero", 39);
  v3 = 39;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "offset", 40);
  v3 = 40;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "opacity", 41);
  v3 = 41;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "operator", 115);
  v3 = 115;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "order", 121);
  v3 = 121;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "path", 42);
  v3 = 42;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "pattern", 79);
  v3 = 79;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "patternContentUnits", 81);
  v3 = 81;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "patternTransform", 82);
  v3 = 82;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "patternUnits", 80);
  v3 = 80;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "playbackOrder", 111);
  v3 = 111;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "points", 43);
  v3 = 43;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "polygon", 44);
  v3 = 44;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "polyline", 45);
  v3 = 45;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "preserveAspectRatio", 46);
  v3 = 46;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "preserveAlpha", 129);
  v3 = 129;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "primitiveUnits", 86);
  v3 = 86;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "r", 47);
  v3 = 47;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "radialGradient", 48);
  v3 = 48;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "rect", 49);
  v3 = 49;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "repeatDuration", 151);
  v3 = 151;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "repeatCount", 150);
  v3 = 150;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "restart", 149);
  v3 = 149;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "result", 90);
  v3 = 90;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "round", 50);
  v3 = 50;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "rx", 51);
  v3 = 51;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "ry", 52);
  v3 = 52;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "set", 132);
  v3 = 132;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "srgb", 53);
  v3 = 53;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stdDeviation", 104);
  v3 = 104;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "square", 54);
  v3 = 54;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stop", 55);
  v3 = 55;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stop-color", 56);
  v3 = 56;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stop-opacity", 83);
  v3 = 83;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke", 57);
  v3 = 57;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-dasharray", 12);
  v3 = 12;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-dashoffset", 13);
  v3 = 13;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-linecap", 34);
  v3 = 34;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-linejoin", 35);
  v3 = 35;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-miterlimit", 38);
  v3 = 38;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-opacity", 58);
  v3 = 58;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "stroke-width", 59);
  v3 = 59;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "style", 60);
  v3 = 60;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "svg", 61);
  v3 = 61;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "snapShotTime", 110);
  v3 = 110;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "symbol", 62);
  v3 = 62;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "targetX", 125);
  v3 = 125;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "targetY", 126);
  v3 = 126;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "text-anchor", 157);
  v3 = 157;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "timelineBegin", 112);
  v3 = 112;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "to", 140);
  v3 = 140;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "transform", 63);
  v3 = 63;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "type", 143);
  v3 = 143;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "values", 145);
  v3 = 145;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "version", 64);
  v3 = 64;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "viewBox", 65);
  v3 = 65;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "width", 66);
  v3 = 66;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "x", 67);
  v3 = 67;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "xmlns", 105);
  v3 = 105;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "x1", 68);
  v3 = 68;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "x2", 69);
  v3 = 69;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "y", 70);
  v3 = 70;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "y1", 71);
  v3 = 71;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "y2", 72);
  v3 = 72;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "zoomAndPan", 107);
  v3 = 107;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "text", 10001);
  v3 = 10001;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "letter-spacing", 10000);
  v3 = 10000;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "href", 20000);
  v3 = 20000;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "use", 20001);
  v3 = 20001;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "xlink:href", 20000);
  v3 = 20000;
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
  SVGAtom::_mapInit((uint64_t)this, "unknown", 0);
  v3 = 0;
  return std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>((uint64_t)this + 48, &v3, &v3);
}

uint64_t SVGAtom::insert(uint64_t a1, char *a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t *v8;
  unsigned int v9;
  void *__p;
  void *v12;
  char v13;
  int v14;
  char v15;

  v6 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (!(_DWORD)a3)
  {
    v7 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)(v7 - 4294967294) < 0xFFFFFFFF00000001)
    {
      a3 = 0xFFFFFFFFLL;
      goto LABEL_15;
    }
    a3 = 0xFFFFFFFFLL;
    while (1)
    {
      v7 = (v7 + 1);
      if (!*(_QWORD *)(a1 + 32))
      {
LABEL_14:
        a3 = v7;
        goto LABEL_15;
      }
      v8 = *(uint64_t **)(a1 + 32);
      while (1)
      {
        v9 = *((_DWORD *)v8 + 8);
        if (v7 >= v9)
          break;
LABEL_10:
        v8 = (uint64_t *)*v8;
        if (!v8)
          goto LABEL_14;
      }
      if (v9 < v7)
        break;
      if ((_DWORD)v7 == -1)
        goto LABEL_15;
    }
    ++v8;
    goto LABEL_10;
  }
LABEL_15:
  std::string::basic_string[abi:ne180100]<0>(&__p, a2);
  v14 = a3;
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__emplace_unique_key_args<std::string,std::pair<std::string,SVGAtom::Name>>((uint64_t **)a1, (uint64_t)&__p, (uint64_t)&__p);
  if (v13 < 0)
    operator delete(__p);
  LODWORD(__p) = a3;
  std::string::basic_string[abi:ne180100]<0>(&v12, a2);
  std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__emplace_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name,std::string>>((uint64_t **)(a1 + 24), (unsigned int *)&__p, (uint64_t)&__p);
  if (v15 < 0)
    operator delete(v12);
  os_unfair_lock_unlock(v6);
  return a3;
}

void sub_206778BC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_OWORD *std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__emplace_unique_key_args<std::string,std::pair<std::string,SVGAtom::Name>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  void **v5;
  _OWORD *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x40uLL);
    v6[2] = *(_OWORD *)a3;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a3 + 16);
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

uint64_t **std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__emplace_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name,std::string>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  char *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (char *)operator new(0x40uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 40) = *(_OWORD *)(a3 + 8);
    *((_QWORD *)v10 + 7) = *(_QWORD *)(a3 + 24);
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

_QWORD *std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__emplace_unique_key_args<SVGAtom::Name,SVGAtom::Name>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_206778F60(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

const char *CGSVGAtomCopyString(unsigned int a1)
{
  const char *result;

  result = (const char *)SVGAtom::ToString(a1);
  if (result)
    return (const char *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD260], result, 0x8000100u);
  return result;
}

void SVGPathCommand::~SVGPathCommand(SVGPathCommand *this)
{
  SVGPathCommand::~SVGPathCommand(this);
  JUMPOUT(0x20BCFC038);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = &off_24BFD8C78;
  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    v3 = *(void **)v2;
    if (*(_QWORD *)v2)
    {
      *(_QWORD *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x20BCFC038](v2, 0x80C40D6874129);
  }
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

locale_t ___ZL10GetLocaleCv_block_invoke()
{
  locale_t result;

  result = newlocale(63, "C", 0);
  GetLocaleC(void)::localeC = (uint64_t)result;
  return result;
}

void sub_2067794D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40A582917CLL);
  _Unwind_Resume(a1);
}

void SVGPathCommand::appendPoint(SVGPathCommand *this, CGPoint a2)
{
  uint64_t v2;
  CGFloat y;
  CGFloat x;
  unint64_t v6;
  CGFloat *v7;
  CGFloat *v8;
  CGFloat *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  CGFloat *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  CGFloat *v19;
  unint64_t v20;
  _QWORD *v21;
  CGFloat *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  CGFloat *v28;
  char *v29;
  uint64_t v30;

  v2 = *((_QWORD *)this + 7);
  if (!v2)
    SVGPathCommand::appendPoint();
  y = a2.y;
  x = a2.x;
  v6 = *(_QWORD *)(v2 + 16);
  v7 = *(CGFloat **)(v2 + 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = *(CGFloat **)v2;
    v10 = ((uint64_t)v7 - *(_QWORD *)v2) >> 3;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 61)
      goto LABEL_36;
    v12 = v6 - (_QWORD)v9;
    if (v12 >> 2 > v11)
      v11 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v11;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v2 + 16, v13);
      v9 = *(CGFloat **)v2;
      v7 = *(CGFloat **)(v2 + 8);
    }
    else
    {
      v14 = 0;
    }
    v15 = (CGFloat *)&v14[8 * v10];
    v16 = &v14[8 * v13];
    *v15 = x;
    v8 = v15 + 1;
    while (v7 != v9)
    {
      v17 = *((_QWORD *)v7-- - 1);
      *((_QWORD *)v15-- - 1) = v17;
    }
    *(_QWORD *)v2 = v15;
    *(_QWORD *)(v2 + 8) = v8;
    *(_QWORD *)(v2 + 16) = v16;
    if (v9)
      operator delete(v9);
  }
  else
  {
    *v7 = a2.x;
    v8 = v7 + 1;
  }
  *(_QWORD *)(v2 + 8) = v8;
  v18 = *((_QWORD *)this + 7);
  v19 = *(CGFloat **)(v18 + 8);
  v20 = *(_QWORD *)(v18 + 16);
  if ((unint64_t)v19 < v20)
  {
    *v19 = y;
    v21 = v19 + 1;
    goto LABEL_34;
  }
  v22 = *(CGFloat **)v18;
  v23 = ((uint64_t)v19 - *(_QWORD *)v18) >> 3;
  v24 = v23 + 1;
  if ((unint64_t)(v23 + 1) >> 61)
LABEL_36:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v25 = v20 - (_QWORD)v22;
  if (v25 >> 2 > v24)
    v24 = v25 >> 2;
  if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
    v26 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v26 = v24;
  if (v26)
  {
    v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v18 + 16, v26);
    v22 = *(CGFloat **)v18;
    v19 = *(CGFloat **)(v18 + 8);
  }
  else
  {
    v27 = 0;
  }
  v28 = (CGFloat *)&v27[8 * v23];
  v29 = &v27[8 * v26];
  *v28 = y;
  v21 = v28 + 1;
  while (v19 != v22)
  {
    v30 = *((_QWORD *)v19-- - 1);
    *((_QWORD *)v28-- - 1) = v30;
  }
  *(_QWORD *)v18 = v28;
  *(_QWORD *)(v18 + 8) = v21;
  *(_QWORD *)(v18 + 16) = v29;
  if (v22)
    operator delete(v22);
LABEL_34:
  *(_QWORD *)(v18 + 8) = v21;
}

void SVGPathCommand::appendPoint()
{
  __assert_rtn("appendPoint", "SVGPath.cpp", 109, "_floats != nullptr");
}

void ___ZL14NameToColorMapv_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD v2[3];
  int v3;
  _QWORD v4[3];
  int v5;
  _QWORD v6[3];
  int v7;
  _QWORD v8[3];
  int v9;
  _QWORD v10[3];
  int v11;
  _QWORD v12[3];
  int v13;
  _QWORD v14[3];
  int v15;
  _QWORD v16[3];
  int v17;
  _QWORD v18[3];
  int v19;
  _QWORD v20[3];
  int v21;
  _QWORD v22[3];
  int v23;
  _QWORD v24[3];
  int v25;
  _QWORD v26[3];
  int v27;
  _QWORD v28[3];
  int v29;
  _QWORD v30[3];
  int v31;
  _QWORD v32[3];
  int v33;
  _QWORD v34[3];
  int v35;
  _QWORD v36[3];
  int v37;
  _QWORD v38[3];
  int v39;
  _QWORD v40[3];
  int v41;
  _QWORD v42[3];
  int v43;
  _QWORD v44[3];
  int v45;
  _QWORD v46[3];
  int v47;
  _QWORD v48[3];
  int v49;
  _QWORD v50[3];
  int v51;
  _QWORD v52[3];
  int v53;
  _QWORD v54[3];
  int v55;
  _QWORD v56[3];
  int v57;
  _QWORD v58[3];
  int v59;
  _QWORD v60[3];
  int v61;
  _QWORD v62[3];
  int v63;
  _QWORD v64[3];
  int v65;
  _QWORD v66[3];
  int v67;
  _QWORD v68[3];
  int v69;
  _QWORD v70[3];
  int v71;
  _QWORD v72[3];
  int v73;
  _QWORD v74[3];
  int v75;
  _QWORD v76[3];
  int v77;
  _QWORD v78[3];
  int v79;
  _QWORD v80[3];
  int v81;
  _QWORD v82[3];
  int v83;
  _QWORD v84[3];
  int v85;
  _QWORD v86[3];
  int v87;
  _QWORD v88[3];
  int v89;
  _QWORD v90[3];
  int v91;
  _QWORD v92[3];
  int v93;
  _QWORD v94[3];
  int v95;
  _QWORD v96[3];
  int v97;
  _QWORD v98[3];
  int v99;
  _QWORD v100[3];
  int v101;
  _QWORD v102[3];
  int v103;
  _QWORD v104[3];
  int v105;
  _QWORD v106[3];
  int v107;
  _QWORD v108[3];
  int v109;
  _QWORD v110[3];
  int v111;
  _QWORD v112[3];
  int v113;
  _QWORD v114[3];
  int v115;
  _QWORD v116[3];
  int v117;
  _QWORD v118[3];
  int v119;
  _QWORD v120[3];
  int v121;
  _QWORD v122[3];
  int v123;
  _QWORD v124[3];
  int v125;
  _QWORD v126[3];
  int v127;
  _QWORD v128[3];
  int v129;
  _QWORD v130[3];
  int v131;
  _QWORD v132[3];
  int v133;
  _QWORD v134[3];
  int v135;
  _QWORD v136[3];
  int v137;
  _QWORD v138[3];
  int v139;
  _QWORD v140[3];
  int v141;
  _QWORD v142[3];
  int v143;
  _QWORD v144[3];
  int v145;
  _QWORD v146[3];
  int v147;
  _QWORD v148[3];
  int v149;
  _QWORD v150[3];
  int v151;
  _QWORD v152[3];
  int v153;
  _QWORD v154[3];
  int v155;
  _QWORD v156[3];
  int v157;
  _QWORD v158[3];
  int v159;
  _QWORD v160[3];
  int v161;
  _QWORD v162[3];
  int v163;
  _QWORD v164[3];
  int v165;
  _QWORD v166[3];
  int v167;
  _QWORD v168[3];
  int v169;
  _QWORD v170[3];
  int v171;
  _QWORD v172[3];
  int v173;
  _QWORD v174[3];
  int v175;
  _QWORD v176[3];
  int v177;
  _QWORD v178[3];
  int v179;
  _QWORD v180[3];
  int v181;
  _QWORD v182[3];
  int v183;
  _QWORD v184[3];
  int v185;
  _QWORD v186[3];
  int v187;
  _QWORD v188[3];
  int v189;
  _QWORD v190[3];
  int v191;
  _QWORD v192[3];
  int v193;
  _QWORD v194[3];
  int v195;
  _QWORD v196[3];
  int v197;
  _QWORD v198[3];
  int v199;
  _QWORD v200[3];
  int v201;
  _QWORD v202[3];
  int v203;
  _QWORD v204[3];
  int v205;
  _QWORD v206[3];
  int v207;
  _QWORD v208[3];
  int v209;
  _QWORD v210[3];
  int v211;
  _QWORD v212[3];
  int v213;
  _QWORD v214[3];
  int v215;
  _QWORD v216[3];
  int v217;
  _QWORD v218[3];
  int v219;
  _QWORD v220[3];
  int v221;
  _QWORD v222[3];
  int v223;
  _QWORD v224[3];
  int v225;
  _QWORD v226[3];
  int v227;
  _QWORD v228[3];
  int v229;
  _QWORD v230[3];
  int v231;
  _QWORD v232[3];
  int v233;
  _QWORD v234[3];
  int v235;
  _QWORD v236[3];
  int v237;
  _QWORD v238[3];
  int v239;
  _QWORD v240[3];
  int v241;
  _QWORD v242[3];
  int v243;
  _QWORD v244[3];
  int v245;
  _QWORD v246[3];
  int v247;
  _QWORD v248[3];
  int v249;
  _QWORD v250[3];
  int v251;
  _QWORD v252[3];
  int v253;
  _QWORD v254[3];
  int v255;
  _QWORD v256[3];
  int v257;
  _QWORD v258[3];
  int v259;
  _QWORD v260[3];
  int v261;
  _QWORD v262[3];
  int v263;
  _QWORD v264[3];
  int v265;
  _QWORD v266[3];
  int v267;
  _QWORD v268[3];
  int v269;
  _QWORD v270[3];
  int v271;
  _QWORD v272[3];
  int v273;
  _QWORD v274[3];
  int v275;
  _QWORD v276[3];
  int v277;
  _QWORD v278[3];
  int v279;
  _QWORD v280[3];
  int v281;
  _QWORD v282[3];
  int v283;
  _QWORD v284[3];
  int v285;
  _QWORD v286[3];
  int v287;
  _QWORD v288[3];
  int v289;
  _QWORD v290[3];
  int v291;
  _QWORD v292[3];
  int v293;
  _QWORD v294[3];
  int v295;
  _QWORD v296[3];
  int v297;
  _QWORD v298[3];
  int v299;
  uint64_t v300;

  MEMORY[0x24BDAC7A8]();
  v300 = *MEMORY[0x24BDAC8D0];
  v0 = operator new();
  std::string::basic_string[abi:ne180100]<0>(v2, "aliceblue");
  v3 = 15792383;
  std::string::basic_string[abi:ne180100]<0>(v4, "antiquewhite");
  v5 = 16444375;
  std::string::basic_string[abi:ne180100]<0>(v6, "aqua");
  v7 = 0xFFFF;
  std::string::basic_string[abi:ne180100]<0>(v8, "aquamarine");
  v9 = 8388564;
  std::string::basic_string[abi:ne180100]<0>(v10, "azure");
  v11 = 15794175;
  std::string::basic_string[abi:ne180100]<0>(v12, "beige");
  v13 = 16119260;
  std::string::basic_string[abi:ne180100]<0>(v14, "bisque");
  v15 = 16770244;
  std::string::basic_string[abi:ne180100]<0>(v16, "black");
  v17 = 0;
  std::string::basic_string[abi:ne180100]<0>(v18, "blanchedalmond");
  v19 = 16772045;
  std::string::basic_string[abi:ne180100]<0>(v20, "blue");
  v21 = 255;
  std::string::basic_string[abi:ne180100]<0>(v22, "blueviolet");
  v23 = 9055202;
  std::string::basic_string[abi:ne180100]<0>(v24, "brown");
  v25 = 10824234;
  std::string::basic_string[abi:ne180100]<0>(v26, "burlywood");
  v27 = 14596231;
  std::string::basic_string[abi:ne180100]<0>(v28, "cadetblue");
  v29 = 6266528;
  std::string::basic_string[abi:ne180100]<0>(v30, "chartreuse");
  v31 = 8388352;
  std::string::basic_string[abi:ne180100]<0>(v32, "chocolate");
  v33 = 13789470;
  std::string::basic_string[abi:ne180100]<0>(v34, "coral");
  v35 = 16744272;
  std::string::basic_string[abi:ne180100]<0>(v36, "cornflowerblue");
  v37 = 6591981;
  std::string::basic_string[abi:ne180100]<0>(v38, "cornsilk");
  v39 = 16775388;
  std::string::basic_string[abi:ne180100]<0>(v40, "crimson");
  v41 = 14423100;
  std::string::basic_string[abi:ne180100]<0>(v42, "cyan");
  v43 = 0xFFFF;
  std::string::basic_string[abi:ne180100]<0>(v44, "darkblue");
  v45 = 139;
  std::string::basic_string[abi:ne180100]<0>(v46, "darkcyan");
  v47 = 35723;
  std::string::basic_string[abi:ne180100]<0>(v48, "darkgoldenrod");
  v49 = 12092939;
  std::string::basic_string[abi:ne180100]<0>(v50, "darkgray");
  v51 = 11119017;
  std::string::basic_string[abi:ne180100]<0>(v52, "darkgrey");
  v53 = 11119017;
  std::string::basic_string[abi:ne180100]<0>(v54, "darkgreen");
  v55 = 25600;
  std::string::basic_string[abi:ne180100]<0>(v56, "darkkhaki");
  v57 = 12433259;
  std::string::basic_string[abi:ne180100]<0>(v58, "darkmagenta");
  v59 = 9109643;
  std::string::basic_string[abi:ne180100]<0>(v60, "darkolivegreen");
  v61 = 5597999;
  std::string::basic_string[abi:ne180100]<0>(v62, "darkorange");
  v63 = 16747520;
  std::string::basic_string[abi:ne180100]<0>(v64, "darkorchid");
  v65 = 10040012;
  std::string::basic_string[abi:ne180100]<0>(v66, "darkred");
  v67 = 9109504;
  std::string::basic_string[abi:ne180100]<0>(v68, "darksalmon");
  v69 = 15308410;
  std::string::basic_string[abi:ne180100]<0>(v70, "darkseagreen");
  v71 = 9419919;
  std::string::basic_string[abi:ne180100]<0>(v72, "darkslateblue");
  v73 = 4734347;
  std::string::basic_string[abi:ne180100]<0>(v74, "darkslategray");
  v75 = 3100495;
  std::string::basic_string[abi:ne180100]<0>(v76, "darkslategrey");
  v77 = 3100495;
  std::string::basic_string[abi:ne180100]<0>(v78, "darkturquoise");
  v79 = 52945;
  std::string::basic_string[abi:ne180100]<0>(v80, "darkviolet");
  v81 = 9699539;
  std::string::basic_string[abi:ne180100]<0>(v82, "deeppink");
  v83 = 16716947;
  std::string::basic_string[abi:ne180100]<0>(v84, "deepskyblue");
  v85 = 49151;
  std::string::basic_string[abi:ne180100]<0>(v86, "dimgray");
  v87 = 6908265;
  std::string::basic_string[abi:ne180100]<0>(v88, "dimgrey");
  v89 = 6908265;
  std::string::basic_string[abi:ne180100]<0>(v90, "dodgerblue");
  v91 = 2003199;
  std::string::basic_string[abi:ne180100]<0>(v92, "firebrick");
  v93 = 11674146;
  std::string::basic_string[abi:ne180100]<0>(v94, "floralwhite");
  v95 = 16775920;
  std::string::basic_string[abi:ne180100]<0>(v96, "forestgreen");
  v97 = 2263842;
  std::string::basic_string[abi:ne180100]<0>(v98, "fuchsia");
  v99 = 16711935;
  std::string::basic_string[abi:ne180100]<0>(v100, "gainsboro");
  v101 = 14474460;
  std::string::basic_string[abi:ne180100]<0>(v102, "ghostwhite");
  v103 = 16316671;
  std::string::basic_string[abi:ne180100]<0>(v104, "gold");
  v105 = 16766720;
  std::string::basic_string[abi:ne180100]<0>(v106, "goldenrod");
  v107 = 14329120;
  std::string::basic_string[abi:ne180100]<0>(v108, "gray");
  v109 = 8421504;
  std::string::basic_string[abi:ne180100]<0>(v110, "green");
  v111 = 0x8000;
  std::string::basic_string[abi:ne180100]<0>(v112, "greenyellow");
  v113 = 11403055;
  std::string::basic_string[abi:ne180100]<0>(v114, "grey");
  v115 = 8421504;
  std::string::basic_string[abi:ne180100]<0>(v116, "honeydew");
  v117 = 15794160;
  std::string::basic_string[abi:ne180100]<0>(v118, "hotpink");
  v119 = 16738740;
  std::string::basic_string[abi:ne180100]<0>(v120, "indianred");
  v121 = 13458524;
  std::string::basic_string[abi:ne180100]<0>(v122, "indigo");
  v123 = 4915330;
  std::string::basic_string[abi:ne180100]<0>(v124, "ivory");
  v125 = 16777200;
  std::string::basic_string[abi:ne180100]<0>(v126, "khaki");
  v127 = 15787660;
  std::string::basic_string[abi:ne180100]<0>(v128, "lavender");
  v129 = 15132410;
  std::string::basic_string[abi:ne180100]<0>(v130, "lavenderblush");
  v131 = 16773365;
  std::string::basic_string[abi:ne180100]<0>(v132, "lawngreen");
  v133 = 8190976;
  std::string::basic_string[abi:ne180100]<0>(v134, "lemonchiffon");
  v135 = 16775885;
  std::string::basic_string[abi:ne180100]<0>(v136, "lightblue");
  v137 = 11393254;
  std::string::basic_string[abi:ne180100]<0>(v138, "lightcoral");
  v139 = 15761536;
  std::string::basic_string[abi:ne180100]<0>(v140, "lightcyan");
  v141 = 14745599;
  std::string::basic_string[abi:ne180100]<0>(v142, "lightgoldenrodyellow");
  v143 = 16448210;
  std::string::basic_string[abi:ne180100]<0>(v144, "lightgray");
  v145 = 13882323;
  std::string::basic_string[abi:ne180100]<0>(v146, "lightgrey");
  v147 = 13882323;
  std::string::basic_string[abi:ne180100]<0>(v148, "lightgreen");
  v149 = 9498256;
  std::string::basic_string[abi:ne180100]<0>(v150, "lightpink");
  v151 = 16758465;
  std::string::basic_string[abi:ne180100]<0>(v152, "lightsalmon");
  v153 = 16752762;
  std::string::basic_string[abi:ne180100]<0>(v154, "lightseagreen");
  v155 = 2142890;
  std::string::basic_string[abi:ne180100]<0>(v156, "lightskyblue");
  v157 = 8900346;
  std::string::basic_string[abi:ne180100]<0>(v158, "lightslateblue");
  v159 = 8679679;
  std::string::basic_string[abi:ne180100]<0>(v160, "lightslategray");
  v161 = 7833753;
  std::string::basic_string[abi:ne180100]<0>(v162, "lightslategrey");
  v163 = 7833753;
  std::string::basic_string[abi:ne180100]<0>(v164, "lightsteelblue");
  v165 = 11584734;
  std::string::basic_string[abi:ne180100]<0>(v166, "lightyellow");
  v167 = 16777184;
  std::string::basic_string[abi:ne180100]<0>(v168, "lime");
  v169 = 65280;
  std::string::basic_string[abi:ne180100]<0>(v170, "limegreen");
  v171 = 3329330;
  std::string::basic_string[abi:ne180100]<0>(v172, "linen");
  v173 = 16445670;
  std::string::basic_string[abi:ne180100]<0>(v174, "magenta");
  v175 = 16711935;
  std::string::basic_string[abi:ne180100]<0>(v176, "maroon");
  v177 = 0x800000;
  std::string::basic_string[abi:ne180100]<0>(v178, "mediumaquamarine");
  v179 = 6737322;
  std::string::basic_string[abi:ne180100]<0>(v180, "mediumblue");
  v181 = 205;
  std::string::basic_string[abi:ne180100]<0>(v182, "mediumorchid");
  v183 = 12211667;
  std::string::basic_string[abi:ne180100]<0>(v184, "mediumpurple");
  v185 = 9662680;
  std::string::basic_string[abi:ne180100]<0>(v186, "mediumseagreen");
  v187 = 3978097;
  std::string::basic_string[abi:ne180100]<0>(v188, "mediumslateblue");
  v189 = 8087790;
  std::string::basic_string[abi:ne180100]<0>(v190, "mediumspringgreen");
  v191 = 64154;
  std::string::basic_string[abi:ne180100]<0>(v192, "mediumturquoise");
  v193 = 4772300;
  std::string::basic_string[abi:ne180100]<0>(v194, "mediumvioletred");
  v195 = 13047173;
  std::string::basic_string[abi:ne180100]<0>(v196, "midnightblue");
  v197 = 1644912;
  std::string::basic_string[abi:ne180100]<0>(v198, "mintcream");
  v199 = 16121850;
  std::string::basic_string[abi:ne180100]<0>(v200, "mistyrose");
  v201 = 16770273;
  std::string::basic_string[abi:ne180100]<0>(v202, "moccasin");
  v203 = 16770229;
  std::string::basic_string[abi:ne180100]<0>(v204, "navajowhite");
  v205 = 16768685;
  std::string::basic_string[abi:ne180100]<0>(v206, "navy");
  v207 = 128;
  std::string::basic_string[abi:ne180100]<0>(v208, "oldlace");
  v209 = 16643558;
  std::string::basic_string[abi:ne180100]<0>(v210, "olive");
  v211 = 8421376;
  std::string::basic_string[abi:ne180100]<0>(v212, "olivedrab");
  v213 = 7048739;
  std::string::basic_string[abi:ne180100]<0>(v214, "orange");
  v215 = 16753920;
  std::string::basic_string[abi:ne180100]<0>(v216, "orangered");
  v217 = 16729344;
  std::string::basic_string[abi:ne180100]<0>(v218, "orchid");
  v219 = 14315734;
  std::string::basic_string[abi:ne180100]<0>(v220, "palegoldenrod");
  v221 = 15657130;
  std::string::basic_string[abi:ne180100]<0>(v222, "palegreen");
  v223 = 10025880;
  std::string::basic_string[abi:ne180100]<0>(v224, "paleturquoise");
  v225 = 11529966;
  std::string::basic_string[abi:ne180100]<0>(v226, "palevioletred");
  v227 = 14184595;
  std::string::basic_string[abi:ne180100]<0>(v228, "papayawhip");
  v229 = 16773077;
  std::string::basic_string[abi:ne180100]<0>(v230, "peachpuff");
  v231 = 16767673;
  std::string::basic_string[abi:ne180100]<0>(v232, "peru");
  v233 = 13468991;
  std::string::basic_string[abi:ne180100]<0>(v234, "pink");
  v235 = 16761035;
  std::string::basic_string[abi:ne180100]<0>(v236, "plum");
  v237 = 14524637;
  std::string::basic_string[abi:ne180100]<0>(v238, "powderblue");
  v239 = 11591910;
  std::string::basic_string[abi:ne180100]<0>(v240, "purple");
  v241 = 8388736;
  std::string::basic_string[abi:ne180100]<0>(v242, "red");
  v243 = 16711680;
  std::string::basic_string[abi:ne180100]<0>(v244, "rosybrown");
  v245 = 12357519;
  std::string::basic_string[abi:ne180100]<0>(v246, "royalblue");
  v247 = 4286945;
  std::string::basic_string[abi:ne180100]<0>(v248, "saddlebrown");
  v249 = 9127187;
  std::string::basic_string[abi:ne180100]<0>(v250, "salmon");
  v251 = 16416882;
  std::string::basic_string[abi:ne180100]<0>(v252, "sandybrown");
  v253 = 16032864;
  std::string::basic_string[abi:ne180100]<0>(v254, "seagreen");
  v255 = 3050327;
  std::string::basic_string[abi:ne180100]<0>(v256, "seashell");
  v257 = 16774638;
  std::string::basic_string[abi:ne180100]<0>(v258, "sienna");
  v259 = 10506797;
  std::string::basic_string[abi:ne180100]<0>(v260, "silver");
  v261 = 12632256;
  std::string::basic_string[abi:ne180100]<0>(v262, "skyblue");
  v263 = 8900331;
  std::string::basic_string[abi:ne180100]<0>(v264, "slateblue");
  v265 = 6970061;
  std::string::basic_string[abi:ne180100]<0>(v266, "slategray");
  v267 = 7372944;
  std::string::basic_string[abi:ne180100]<0>(v268, "slategrey");
  v269 = 7372944;
  std::string::basic_string[abi:ne180100]<0>(v270, "snow");
  v271 = 16775930;
  std::string::basic_string[abi:ne180100]<0>(v272, "springgreen");
  v273 = 65407;
  std::string::basic_string[abi:ne180100]<0>(v274, "steelblue");
  v275 = 4620980;
  std::string::basic_string[abi:ne180100]<0>(v276, "tan");
  v277 = 13808780;
  std::string::basic_string[abi:ne180100]<0>(v278, "teal");
  v279 = 32896;
  std::string::basic_string[abi:ne180100]<0>(v280, "thistle");
  v281 = 14204888;
  std::string::basic_string[abi:ne180100]<0>(v282, "tomato");
  v283 = 16737095;
  std::string::basic_string[abi:ne180100]<0>(v284, "turquoise");
  v285 = 4251856;
  std::string::basic_string[abi:ne180100]<0>(v286, "violet");
  v287 = 15631086;
  std::string::basic_string[abi:ne180100]<0>(v288, "violetred");
  v289 = 13639824;
  std::string::basic_string[abi:ne180100]<0>(v290, "wheat");
  v291 = 16113331;
  std::string::basic_string[abi:ne180100]<0>(v292, "white");
  v293 = 0xFFFFFF;
  std::string::basic_string[abi:ne180100]<0>(v294, "whitesmoke");
  v295 = 16119285;
  std::string::basic_string[abi:ne180100]<0>(v296, "yellow");
  v297 = 16776960;
  std::string::basic_string[abi:ne180100]<0>(v298, "yellowgreen");
  v299 = 10145074;
  std::map<std::string,unsigned int,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,unsigned int>>>::map[abi:ne180100](v0, (uint64_t)v2, 149);
  v1 = 0;
  NameToColorMap(void)::__colorMap = v0;
  do
  {
    if (SHIBYTE(v298[v1 + 2]) < 0)
      operator delete((void *)v298[v1]);
    v1 -= 4;
  }
  while (v1 != -596);
}

void sub_20677AB50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  char *v11;
  uint64_t v12;
  char *v13;
  int v14;

  v11 = (char *)(v9 + 4759);
  v12 = -4768;
  v13 = v11;
  while (1)
  {
    v14 = *v13;
    v13 -= 32;
    if (v14 < 0)
      operator delete(*(void **)(v11 - 23));
    v11 = v13;
    v12 += 32;
    if (!v12)
    {
      MEMORY[0x20BCFC038](a9, 0x1020C4062D53EE8);
      _Unwind_Resume(a1);
    }
  }
}

void sub_20677AE1C()
{
  JUMPOUT(0x20677ADFCLL);
}

double CGSVGViewBoxNodeGetPosition(uint64_t a1, const char *a2)
{
  double *v2;

  v2 = (double *)CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (v2)
    return v2[25];
  else
    return 0.0;
}

void *CFRetained::getObject<SVGViewBoxNode>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

double *CGSVGViewBoxNodeSetSize(uint64_t a1, const char *a2, double a3, double a4)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (result)
  {
    result[27] = a3;
    result[28] = a4;
  }
  return result;
}

double CGSVGViewBoxNodeGetSize(uint64_t a1, const char *a2)
{
  char *v2;
  char *v3;

  v2 = (char *)CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  v3 = v2 + 216;
  if (!v2)
    v3 = (char *)MEMORY[0x24BDBF148];
  return *(double *)v3;
}

double *CGSVGViewBoxNodeSetViewbox(uint64_t a1, const char *a2, double a3, double a4, double a5, double a6)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (result)
  {
    result[29] = a3;
    result[30] = a4;
    result[31] = a5;
    result[32] = a6;
  }
  return result;
}

double CGSVGViewBoxNodeGetViewbox(uint64_t a1, const char *a2)
{
  char *v2;
  char *v3;

  v2 = (char *)CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  v3 = (char *)MEMORY[0x24BDBF090];
  if (v2)
    v3 = v2 + 232;
  return *(double *)v3;
}

_DWORD *CGSVGViewBoxNodeSetAspectRatio(uint64_t a1, const char *a2)
{
  int v2;
  _DWORD *result;

  v2 = (int)a2;
  result = CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (result)
    result[66] = v2;
  return result;
}

unsigned int *CGSVGViewBoxNodeGetAspectRatio(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (result)
    return (unsigned int *)result[66];
  return result;
}

_DWORD *CGSVGViewBoxNodeSetAspectRatioMeetOrSlice(uint64_t a1, const char *a2)
{
  int v2;
  _DWORD *result;

  v2 = (int)a2;
  result = CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (result)
    result[67] = v2;
  return result;
}

uint64_t CGSVGViewBoxNodeGetAspectRatioMeetOrSlice(uint64_t a1, const char *a2)
{
  _DWORD *v2;
  int v3;

  v2 = CFRetained::getObject<SVGViewBoxNode>(a1, a2);
  if (v2)
    v3 = v2[67];
  else
    LOBYTE(v3) = 0;
  return (char)v3;
}

uint64_t CGSVGCanvasGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGCanvas::kSVGCanvasClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_20677B080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFTypeRef CGSVGCanvasRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGCanvasRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

SVGCanvas *CGSVGCanvasGetCurrentGroup(uint64_t a1, const char *a2)
{
  SVGCanvas *result;

  result = (SVGCanvas *)CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
  {
    result = (SVGCanvas *)SVGCanvas::currentGroup(result);
    if (result)
      return (SVGCanvas *)*((_QWORD *)result + 5);
  }
  return result;
}

void *CFRetained::getObject<SVGCanvas>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

SVGCanvas *CGSVGCanvasPushGroup(uint64_t a1, const char *a2)
{
  SVGCanvas *result;

  result = (SVGCanvas *)CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
  {
    result = SVGCanvas::pushGroup(result);
    if (result)
      return (SVGCanvas *)*((_QWORD *)result + 5);
  }
  return result;
}

void *CGSVGCanvasPopGroup(uint64_t a1, const char *a2)
{
  void *result;

  result = CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
    return (void *)SVGCanvas::popGroup((uint64_t)result);
  return result;
}

SVGCanvas *CGSVGCanvasAddRect(uint64_t a1, const char *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  SVGCanvas *result;
  CGRect v11;

  result = (SVGCanvas *)CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
  {
    v11.origin.x = a3;
    v11.origin.y = a4;
    v11.size.width = a5;
    v11.size.height = a6;
    result = (SVGCanvas *)SVGCanvas::addRect(result, v11);
    if (result)
      return (SVGCanvas *)*((_QWORD *)result + 5);
  }
  return result;
}

SVGCanvas *CGSVGCanvasAddEllipseInRect(uint64_t a1, const char *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  SVGCanvas *result;
  CGRect v11;

  result = (SVGCanvas *)CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
  {
    v11.origin.x = a3;
    v11.origin.y = a4;
    v11.size.width = a5;
    v11.size.height = a6;
    result = (SVGCanvas *)SVGCanvas::addEllipseInRect(result, v11);
    if (result)
      return (SVGCanvas *)*((_QWORD *)result + 5);
  }
  return result;
}

SVGCanvas *CGSVGCanvasAddLine(uint64_t a1, const char *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  SVGCanvas *result;
  CGPoint v11;
  CGPoint v12;

  result = (SVGCanvas *)CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
  {
    v11.x = a3;
    v11.y = a4;
    v12.x = a5;
    v12.y = a6;
    result = (SVGCanvas *)SVGCanvas::addLine(result, v11, v12);
    if (result)
      return (SVGCanvas *)*((_QWORD *)result + 5);
  }
  return result;
}

SVGCanvas *CGSVGCanvasAddPath(uint64_t a1, const char *a2)
{
  SVGCanvas *result;
  const char *v4;
  SVGCanvas *v5;
  const SVGPath *v6;
  SVGPath *v7;

  result = (SVGCanvas *)CFRetained::getObject<SVGCanvas>(a1, a2);
  if (result)
  {
    result = SVGCanvas::addPath(result);
    if (result)
    {
      v5 = result;
      result = (SVGCanvas *)CFRetained::getObject<SVGPath>((uint64_t)a2, v4);
      if (result)
      {
        v6 = result;
        v7 = SVGShapeNode::path(v5);
        SVGPath::appendCommands(v7, v6);
        return (SVGCanvas *)*((_QWORD *)v5 + 5);
      }
    }
  }
  return result;
}

uint64_t CGSVGCanvasAddPolyline(uint64_t a1, uint64_t a2, unint64_t a3)
{
  const char *v4;
  void *v5;
  SVGNode *v6;
  uint64_t v7;
  void *__p;
  void *v10;
  uint64_t v11;

  __p = 0;
  v10 = 0;
  v11 = 0;
  SVGUtilities::CGPointListFromFloats(a2, a3, (uint64_t)&__p);
  v5 = CFRetained::getObject<SVGCanvas>(a1, v4);
  if (v5 && (v6 = SVGCanvas::addPolyline((uint64_t)v5, (uint64_t)&__p)) != 0)
    v7 = *((_QWORD *)v6 + 5);
  else
    v7 = 0;
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }
  return v7;
}

void sub_20677B34C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGCanvasAddPolygon(uint64_t a1, uint64_t a2, unint64_t a3)
{
  const char *v4;
  void *v5;
  SVGNode *v6;
  uint64_t v7;
  void *__p;
  void *v10;
  uint64_t v11;

  __p = 0;
  v10 = 0;
  v11 = 0;
  SVGUtilities::CGPointListFromFloats(a2, a3, (uint64_t)&__p);
  v5 = CFRetained::getObject<SVGCanvas>(a1, v4);
  if (v5 && (v6 = SVGCanvas::addPolygon((uint64_t)v5, (uint64_t)&__p)) != 0)
    v7 = *((_QWORD *)v6 + 5);
  else
    v7 = 0;
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }
  return v7;
}

void sub_20677B3E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24BFD84D8, MEMORY[0x24BEDAAF0]);
}

void sub_20677B50C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

BOOL SVGAtom::HasAtom(SVGAtom *this, const char *a2)
{
  if (SVGAtom::SharedInstance(void)::onceToken != -1)
    dispatch_once(&SVGAtom::SharedInstance(void)::onceToken, &__block_literal_global);
  return SVGAtom::hasAtom((os_unfair_lock_s *)SVGAtom::SharedInstance(void)::instance, (char *)this);
}

uint64_t SVGAtom::SharedInstance(SVGAtom *this)
{
  if (SVGAtom::SharedInstance(void)::onceToken != -1)
    dispatch_once(&SVGAtom::SharedInstance(void)::onceToken, &__block_literal_global);
  return SVGAtom::SharedInstance(void)::instance;
}

BOOL SVGAtom::hasAtom(os_unfair_lock_s *this, char *a2)
{
  os_unfair_lock_s *v4;
  SVGAtom *v5;
  void *__p[2];
  char v8;

  v4 = this + 22;
  os_unfair_lock_lock(this + 22);
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v5 = (SVGAtom *)std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::find<std::string>((uint64_t)this, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  os_unfair_lock_unlock(v4);
  return &this[2] != (os_unfair_lock_s *)v5;
}

void sub_20677B654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGAtom::~SVGAtom(char **this)
{
  std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::~__hash_table((uint64_t)(this + 6));
  std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy((uint64_t)(this + 3), this[4]);
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy((uint64_t)this, this[1]);
}

uint64_t SVGAtom::_mapInit(uint64_t a1, char *a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  void *__p;
  void *v9;
  char v10;
  int v11;
  char v12;

  v6 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  std::string::basic_string[abi:ne180100]<0>(&__p, a2);
  v11 = a3;
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__emplace_unique_key_args<std::string,std::pair<std::string,SVGAtom::Name>>((uint64_t **)a1, (uint64_t)&__p, (uint64_t)&__p);
  if (v10 < 0)
    operator delete(__p);
  LODWORD(__p) = a3;
  std::string::basic_string[abi:ne180100]<0>(&v9, a2);
  std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__emplace_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name,std::string>>((uint64_t **)(a1 + 24), (unsigned int *)&__p, (uint64_t)&__p);
  if (v12 < 0)
    operator delete(v9);
  os_unfair_lock_unlock(v6);
  return a3;
}

void sub_20677B76C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

void std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[63] < 0)
      operator delete(*((void **)a2 + 5));
    operator delete(a2);
  }
}

uint64_t std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

void sub_20677B930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20677BA20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v8;
  _QWORD *v9;
  _QWORD *v10;
  void *__p[2];
  char v13;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v13 < 0)
    operator delete(__p[0]);
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  if (a4 == 1)
    v8 = 9;
  else
    v8 = 0;
  *(_DWORD *)(a1 + 104) = v8;
  v9 = (_QWORD *)operator new();
  *v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  v10 = operator new(8uLL);
  *v9 = v10;
  *v10++ = a3;
  v9[1] = v10;
  v9[2] = v10;
  *(_QWORD *)(a1 + 88) = v9;
  return a1;
}

void sub_20677BCC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  MEMORY[0x20BCFC038](v2, 0x80C40D6874129);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, double a3, double a4, double a5)
{
  _QWORD *v10;
  double *v11;
  void *__p[2];
  char v14;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v14 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  v10 = (_QWORD *)operator new();
  *v10 = 0;
  v10[1] = 0;
  v10[2] = 0;
  v11 = (double *)operator new(0x20uLL);
  v10[1] = v11 + 4;
  v10[2] = v11 + 4;
  *v11 = a3;
  v11[1] = a4;
  v11[2] = a5;
  v11[3] = a5;
  *v10 = v11;
  *(_QWORD *)(a1 + 88) = v10;
  return a1;
}

void sub_20677BE24(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  uint64_t v4;

  v4 = v2;
  MEMORY[0x20BCFC038](v4, 0x80C40D6874129);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, const SVGColor *a3)
{
  SVGPaint *v6;
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 3;
  v6 = (SVGPaint *)operator new();
  SVGPaint::SVGPaint(v6, a3);
  *(_QWORD *)(a1 + 88) = v6;
  return a1;
}

void sub_20677BF50(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  MEMORY[0x20BCFC038](v2, 0x10B3C40C2CA9EE7);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_20677C05C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, SVGGradient *a3)
{
  SVGPaint *v6;
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 3;
  v6 = (SVGPaint *)operator new();
  SVGPaint::SVGPaint(v6, a3);
  *(_QWORD *)(a1 + 88) = v6;
  return a1;
}

void sub_20677C168(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  MEMORY[0x20BCFC038](v2, 0x10B3C40C2CA9EE7);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, SVGPattern *a3)
{
  SVGPaint *v6;
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 3;
  v6 = (SVGPaint *)operator new();
  SVGPaint::SVGPaint(v6, a3);
  *(_QWORD *)(a1 + 88) = v6;
  return a1;
}

void sub_20677C290(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  MEMORY[0x20BCFC038](v2, 0x10B3C40C2CA9EE7);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_20677C39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t SVGAttribute::SVGAttribute(uint64_t a1, int a2, double a3, double a4)
{
  _QWORD *v8;
  double *v9;
  void *__p[2];
  char v12;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v12 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8C08;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 80) = 1;
  v8 = (_QWORD *)operator new();
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  v9 = (double *)operator new(0x10uLL);
  v8[1] = v9 + 2;
  v8[2] = v9 + 2;
  *v9 = a3;
  v9[1] = a4;
  *v8 = v9;
  *(_QWORD *)(a1 + 88) = v8;
  return a1;
}

void sub_20677C4CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  uint64_t v4;

  v4 = v2;
  MEMORY[0x20BCFC038](v4, 0x80C40D6874129);
  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_20677C790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void sub_20677C888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;

  if (*(char *)(v15 + 79) < 0)
    operator delete(*v16);
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

BOOL SVGAttribute::resolveAsMask(SVGAttribute *this, uint64_t a2, const char *a3)
{
  SVGParser *v4;
  SVGMask *v5;

  if (*((_DWORD *)this + 20) != 7)
  {
    v4 = (SVGAttribute *)((char *)this + 56);
    if (*((char *)this + 79) < 0)
      v4 = *(SVGParser **)v4;
    if (SVGParser::StringBeginsWith(v4, "url(", a3))
    {
      *((_DWORD *)this + 20) = 7;
      v5 = (SVGMask *)operator new();
      SVGMask::SVGMask(v5, 0);
      *((_QWORD *)this + 11) = v5;
    }
  }
  return *((_DWORD *)this + 20) == 7;
}

void sub_20677C974(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40691FC75FLL);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::resolveAsPaint(SVGAttribute *this)
{
  SVGColor *v2;
  SVGColor *v3;
  SVGPaint *v4;
  double v6[5];

  SVGColor::SVGColor((uint64_t)v6, 0, 0.0, 0.0, 0.0, 1.0);
  if (*((_DWORD *)this + 20) != 3)
  {
    v2 = (SVGAttribute *)((char *)this + 56);
    if (!std::string::compare((const std::string *)((char *)this + 56), "none"))
    {
      *((_DWORD *)this + 20) = 3;
      v4 = (SVGPaint *)operator new();
      SVGPaint::SVGPaint(v4);
      goto LABEL_8;
    }
    if (*((char *)this + 79) < 0)
      v2 = *(SVGColor **)v2;
    if (SVGColor::GetColorWithString(v2, v6, v3))
    {
      *((_DWORD *)this + 20) = 3;
      v4 = (SVGPaint *)operator new();
      SVGPaint::SVGPaint(v4, (const SVGColor *)v6);
LABEL_8:
      *((_QWORD *)this + 11) = v4;
    }
  }
  return *((_DWORD *)this + 20) == 3;
}

void sub_20677CA80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C2CA9EE7);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::resolveAsClipPath(SVGAttribute *this, uint64_t a2, const char *a3)
{
  SVGParser *v4;
  SVGClipPath *v5;

  if (*((_DWORD *)this + 20) != 6)
  {
    v4 = (SVGAttribute *)((char *)this + 56);
    if (*((char *)this + 79) < 0)
      v4 = *(SVGParser **)v4;
    if (SVGParser::StringBeginsWith(v4, "url(", a3))
    {
      *((_DWORD *)this + 20) = 6;
      v5 = (SVGClipPath *)operator new();
      SVGClipPath::SVGClipPath(v5, 0);
      *((_QWORD *)this + 11) = v5;
    }
  }
  return *((_DWORD *)this + 20) == 6;
}

void sub_20677CB2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4094216EFELL);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::resolveAsURL(SVGAttribute *this, uint64_t a2, const char *a3)
{
  SVGParser *v4;

  if (*((_DWORD *)this + 20) == 5)
    return 1;
  v4 = (SVGAttribute *)((char *)this + 56);
  if (*((char *)this + 79) < 0)
    v4 = *(SVGParser **)v4;
  if (SVGParser::StringBeginsWith(v4, "url(", a3))
  {
    *((_DWORD *)this + 20) = 5;
    return 1;
  }
  return *((_DWORD *)this + 20) == 5;
}

BOOL SVGAttribute::resolveAsFilter(SVGAttribute *this, uint64_t a2, const char *a3)
{
  SVGParser *v4;
  SVGFilter *v5;

  if (*((_DWORD *)this + 20) != 8)
  {
    v4 = (SVGAttribute *)((char *)this + 56);
    if (*((char *)this + 79) < 0)
      v4 = *(SVGParser **)v4;
    if (SVGParser::StringBeginsWith(v4, "url(", a3))
    {
      *((_DWORD *)this + 20) = 8;
      v5 = (SVGFilter *)operator new();
      SVGFilter::SVGFilter(v5, 0);
      *((_QWORD *)this + 11) = v5;
    }
  }
  return *((_DWORD *)this + 20) == 8;
}

void sub_20677CC38(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40B295622DLL);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::lengthValue(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  _QWORD *v5;

  result = SVGAttribute::resolveAsFloats((SVGAttribute *)a1);
  if (result)
  {
    v5 = **(_QWORD ***)(a1 + 88);
    if (*(_QWORD **)(*(_QWORD *)(a1 + 88) + 8) == v5)
    {
      return 0;
    }
    else
    {
      *(_QWORD *)a2 = *v5;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 104) == 9;
      return 1;
    }
  }
  return result;
}

BOOL SVGAttribute::maskValue(os_unfair_lock_s *this, SVGMask **a2)
{
  uint64_t v4;
  const char *v5;
  _BOOL8 v6;
  os_unfair_lock_t v8;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v8, this + 27);
  v6 = SVGAttribute::resolveAsMask((SVGAttribute *)this, v4, v5);
  if (v6)
    *a2 = *(SVGMask **)&this[22]._os_unfair_lock_opaque;
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v8);
  return v6;
}

void sub_20677CD18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::paintValue(os_unfair_lock_s *this, SVGPaint **a2)
{
  _BOOL8 v4;
  os_unfair_lock_t v6;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v6, this + 27);
  v4 = SVGAttribute::resolveAsPaint((SVGAttribute *)this);
  if (v4)
    *a2 = *(SVGPaint **)&this[22]._os_unfair_lock_opaque;
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v6);
  return v4;
}

void sub_20677CD8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::pointValue(os_unfair_lock_s *this, CGPoint *a2)
{
  CGPoint *v4;
  uint64_t v5;
  os_unfair_lock_t v7;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v7, this + 27);
  if (SVGAttribute::resolveAsFloats((SVGAttribute *)this)
    && (v4 = **(CGPoint ***)&this[22]._os_unfair_lock_opaque,
        *(_QWORD *)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8) - (_QWORD)v4 >= 9uLL))
  {
    *a2 = *v4;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v7);
  return v5;
}

void sub_20677CE14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::floatsValue(uint64_t a1, _QWORD *a2)
{
  _BOOL8 v4;
  os_unfair_lock_t v6;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v6, (os_unfair_lock_t)(a1 + 108));
  v4 = SVGAttribute::resolveAsFloats((SVGAttribute *)a1);
  if (v4)
    *a2 = *(_QWORD *)(a1 + 88);
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v6);
  return v4;
}

void sub_20677CE88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::clipPathValue(os_unfair_lock_s *this, SVGClipPath **a2)
{
  uint64_t v4;
  const char *v5;
  _BOOL8 v6;
  os_unfair_lock_t v8;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v8, this + 27);
  v6 = SVGAttribute::resolveAsClipPath((SVGAttribute *)this, v4, v5);
  if (v6)
    *a2 = *(SVGClipPath **)&this[22]._os_unfair_lock_opaque;
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v8);
  return v6;
}

void sub_20677CEFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::lengthType(os_unfair_lock_s *this)
{
  uint64_t os_unfair_lock_opaque;
  os_unfair_lock_t v4;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v4, this + 27);
  if (!SVGAttribute::resolveAsFloats((SVGAttribute *)this)
    || *(_QWORD *)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8) == **(_QWORD **)&this[22]._os_unfair_lock_opaque)
  {
    os_unfair_lock_opaque = 0;
  }
  else
  {
    os_unfair_lock_opaque = this[26]._os_unfair_lock_opaque;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v4);
  return os_unfair_lock_opaque;
}

void sub_20677CF74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::urlValue(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const char *v5;
  const char *v6;
  const char *v7;
  SVGParser *v8;
  uint64_t v9;
  os_unfair_lock_t v11;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v11, (os_unfair_lock_t)(a1 + 108));
  if (!SVGAttribute::resolveAsURL((SVGAttribute *)a1, v4, v5))
    goto LABEL_10;
  v6 = (const char *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
    v6 = *(const char **)v6;
  if (SVGParser::GetParentheticalComponent(v6, a2)
    && (*(char *)(a2 + 23) >= 0 ? (v8 = (SVGParser *)a2) : (v8 = *(SVGParser **)a2),
        SVGParser::StringBeginsWith(v8, "#", v7)))
  {
    v9 = 1;
    std::string::replace((std::string *)a2, 0, 1uLL, (const std::string::value_type *)&unk_20679A6BE);
  }
  else
  {
LABEL_10:
    v9 = 0;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v11);
  return v9;
}

void sub_20677D034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

BOOL SVGAttribute::filterValue(os_unfair_lock_s *this, SVGFilter **a2)
{
  uint64_t v4;
  const char *v5;
  _BOOL8 v6;
  os_unfair_lock_t v8;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v8, this + 27);
  v6 = SVGAttribute::resolveAsFilter((SVGAttribute *)this, v4, v5);
  if (v6)
    *a2 = *(SVGFilter **)&this[22]._os_unfair_lock_opaque;
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v8);
  return v6;
}

void sub_20677D0A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::isEqual(SVGAttribute *this, const SVGAttribute *a2)
{
  const char *v4;
  int v5;
  int v6;
  BOOL v7;
  uint64_t isEqual;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;
  uint64_t v16;
  double v17;
  BOOL v18;
  os_unfair_lock_t v19;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v19, (os_unfair_lock_t)this + 27);
  v5 = *((_DWORD *)this + 20);
  if (v5 && ((v6 = *((_DWORD *)a2 + 20)) != 0 ? (v7 = v5 == v6) : (v7 = 0), v7))
  {
    isEqual = 0;
    switch(v5)
    {
      case 1:
        v10 = (uint64_t *)*((_QWORD *)this + 11);
        v11 = *((_QWORD *)a2 + 11);
        v13 = *v10;
        v12 = v10[1];
        v14 = v12 - *v10;
        v15 = *(double **)v11;
        if (v14 != *(_QWORD *)(v11 + 8) - *(_QWORD *)v11)
          goto LABEL_6;
        if (v13 == v12)
        {
          isEqual = 1;
        }
        else
        {
          v16 = v13 + 8;
          do
          {
            v17 = *v15++;
            isEqual = *(double *)(v16 - 8) == v17;
            v18 = *(double *)(v16 - 8) != v17 || v16 == v12;
            v16 += 8;
          }
          while (!v18);
        }
        break;
      case 2:
        isEqual = *((_DWORD *)this + 22) == *((_DWORD *)a2 + 22);
        break;
      case 3:
        isEqual = SVGPaint::isEqual(*((SVGPaint **)this + 11), *((const SVGPaint **)a2 + 11));
        break;
      case 4:
      case 5:
        break;
      default:
        SVGUtilities::error((SVGUtilities *)"isEqual(): Unexpected expected type: %d\n", v4, *((unsigned int *)this + 20));
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    isEqual = 0;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v19);
  return isEqual;
}

void sub_20677D1D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)va);
  _Unwind_Resume(a1);
}

uint64_t SVGAttribute::print(SVGAttribute *this)
{
  _QWORD *v2;
  const char *v3;
  _QWORD *v4;

  v2 = SVGAtom::ToString(*((_DWORD *)this + 12));
  v4 = (_QWORD *)((char *)this + 56);
  if (*((char *)this + 79) < 0)
    v4 = (_QWORD *)*v4;
  return SVGUtilities::print((SVGUtilities *)"%s: %s", v3, v2, v4);
}

SVGAttributeMap *SVGAttributeMap::createShallowCopy(SVGAttributeMap *this)
{
  SVGAttributeMap *v2;
  _QWORD v4[5];

  v2 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v2);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK15SVGAttributeMap17createShallowCopyEv_block_invoke;
  v4[3] = &__block_descriptor_tmp_14;
  v4[4] = v2;
  SVGAttributeMap::enumerate((uint64_t)this, (uint64_t)v4);
  return v2;
}

void sub_20677D2C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

void ___ZNK15SVGAttributeMap17createShallowCopyEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SVGAttributeMap::setAttribute(*(_QWORD *)(a1 + 32), a3, 0);
}

uint64_t SVGAttributeMap::hasAttribute(uint64_t a1, unsigned int a2)
{
  uint64_t *v2;
  unsigned int v3;

  v2 = *(uint64_t **)(a1 + 56);
  if (!v2)
    return 0;
  while (1)
  {
    v3 = *((_DWORD *)v2 + 8);
    if (v3 <= a2)
      break;
LABEL_5:
    v2 = (uint64_t *)*v2;
    if (!v2)
      return 0;
  }
  if (v3 < a2)
  {
    ++v2;
    goto LABEL_5;
  }
  return 1;
}

void SVGAttributeMap::removeAttribute(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t **v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  uint64_t *v9;

  v4 = *(_QWORD *)(a1 + 56);
  v2 = a1 + 56;
  v3 = v4;
  if (v4)
  {
    v5 = (uint64_t **)(v2 - 8);
    v6 = v2;
    do
    {
      v7 = *(_DWORD *)(v3 + 32);
      v8 = v7 >= a2;
      if (v7 >= a2)
        v9 = (uint64_t *)v3;
      else
        v9 = (uint64_t *)(v3 + 8);
      if (v8)
        v6 = v3;
      v3 = *v9;
    }
    while (*v9);
    if (v6 != v2 && *(_DWORD *)(v6 + 32) <= a2)
    {
      CFRetained::release(*(CFTypeRef **)(v6 + 40));
      std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__remove_node_pointer(v5, (uint64_t *)v6);
      operator delete((void *)v6);
    }
  }
}

uint64_t SVGAttributeMap::count(SVGAttributeMap *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t SVGAttributeMap::print(SVGAttributeMap *this)
{
  return SVGAttributeMap::enumerate((uint64_t)this, (uint64_t)&__block_literal_global_18);
}

uint64_t ___ZNK15SVGAttributeMap5printEv_block_invoke(int a1, int a2, SVGAttribute *this)
{
  const char *v3;

  SVGAttribute::print(this);
  return SVGUtilities::print((SVGUtilities *)"\n", v3);
}

void CFRetained::~CFRetained(void **this)
{
  *this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BCFC038);
}

_QWORD *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<double>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20677D4BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<double>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void std::vector<double>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::vector<double>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24BFD84E0, MEMORY[0x24BEDAB00]);
}

void sub_20677D5B0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

double SVGColor::at(SVGColor *this, int a2)
{
  double result;

  switch(a2)
  {
    case 0:
      goto LABEL_6;
    case 1:
      this = (SVGColor *)((char *)this + 8);
      goto LABEL_6;
    case 2:
      this = (SVGColor *)((char *)this + 16);
      goto LABEL_6;
    case 3:
      this = (SVGColor *)((char *)this + 24);
LABEL_6:
      result = *(double *)this;
      break;
    default:
      result = 0.0;
      break;
  }
  return result;
}

double *SVGColor::setAt(double *this, int a2, double a3)
{
  switch(a2)
  {
    case 0:
      goto LABEL_5;
    case 1:
      ++this;
      goto LABEL_5;
    case 2:
      this += 2;
      goto LABEL_5;
    case 3:
      this += 3;
LABEL_5:
      *this = a3;
      break;
    default:
      return this;
  }
  return this;
}

void SVGColor::SVGColor(SVGColor *this, unsigned int a2)
{
  int8x8_t v2;
  uint64x2_t v3;

  *((_DWORD *)this + 8) = 53;
  v2 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  v3.i64[0] = v2.u32[0];
  v3.i64[1] = v2.u32[1];
  *(float64x2_t *)this = vdivq_f64(vcvtq_f64_u64(v3), (float64x2_t)vdupq_n_s64(0x406FE00000000000uLL));
  *((double *)this + 2) = (double)a2 / 255.0;
  *((_QWORD *)this + 3) = 0x3FF0000000000000;
}

void SVGColor::SVGColor(SVGColor *this, double *a2)
{
  *((_DWORD *)this + 8) = 53;
  *(double *)this = *a2;
  *((double *)this + 1) = a2[1];
  *((double *)this + 2) = a2[2];
  *((double *)this + 3) = a2[3];
}

BOOL SVGColor::isEqual(SVGColor *this, const SVGColor *a2)
{
  _BOOL8 v4;
  _BOOL8 v5;
  _BOOL8 v6;

  v4 = SVGUtilities::CGFloatEqualToFloat(this, *(double *)this, *(double *)a2);
  return v4
      && (v5 = SVGUtilities::CGFloatEqualToFloat((SVGUtilities *)v4, *((double *)this + 1), *((double *)a2 + 1)))
      && (v6 = SVGUtilities::CGFloatEqualToFloat((SVGUtilities *)v5, *((double *)this + 2), *((double *)a2 + 2)))
      && SVGUtilities::CGFloatEqualToFloat((SVGUtilities *)v6, *((double *)this + 3), *((double *)a2 + 3));
}

void SVGColor::GetStringForColor(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double v4;
  SVGUtilities *v5;
  double v6;
  SVGUtilities *v7;
  double v8;
  SVGUtilities *v9;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  int v18;
  _QWORD *v19;
  _BOOL8 v20;
  double v21;
  SVGUtilities *v22;
  double v23;
  SVGUtilities *v24;
  double v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  BOOL v31;
  char *v32;
  __int128 v33;
  uint64_t v34;

  v4 = SVGUtilities::CGFloatClamp((SVGUtilities *)a1, *(double *)a1 * 255.0, 0.0, 255.0);
  v6 = SVGUtilities::CGFloatClamp(v5, *(double *)(a1 + 8) * 255.0, 0.0, 255.0);
  v8 = SVGUtilities::CGFloatClamp(v7, *(double *)(a1 + 16) * 255.0, 0.0, 255.0);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v10 = SVGUtilities::CGFloatEqualToFloat(v9, *(double *)(a1 + 24), 1.0);
  v11 = (int)v4;
  v12 = (int)v6;
  v13 = (int)v8;
  if (v10)
  {
    v15 = *(double *)a1;
    v14 = *(double *)(a1 + 8);
    v17 = *(double *)(a1 + 16);
    v16 = *(double *)(a1 + 24);
    v18 = *(_DWORD *)(a1 + 32);
    if (NameToColorMap(void)::__onceToken != -1)
      dispatch_once(&NameToColorMap(void)::__onceToken, &__block_literal_global_1);
    if (v18 != 53)
      goto LABEL_14;
    v19 = (_QWORD *)NameToColorMap(void)::__colorMap;
    v20 = SVGUtilities::CGFloatEqualToFloat((SVGUtilities *)v10, v16, 1.0);
    if (!v20)
      goto LABEL_14;
    v21 = SVGUtilities::CGFloatClamp((SVGUtilities *)v20, v15 * 255.0, 0.0, 255.0);
    v23 = SVGUtilities::CGFloatClamp(v22, v14 * 255.0, 0.0, 255.0);
    v25 = SVGUtilities::CGFloatClamp(v24, v17 * 255.0, 0.0, 255.0);
    v28 = (_QWORD *)*v19;
    v27 = v19 + 1;
    v26 = v28;
    if (v28 == v27)
      goto LABEL_14;
    while (*((_DWORD *)v26 + 14) != (((int)v23 << 8) | ((int)v21 << 16) | (int)v25))
    {
      v29 = (_QWORD *)v26[1];
      if (v29)
      {
        do
        {
          v30 = v29;
          v29 = (_QWORD *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          v30 = (_QWORD *)v26[2];
          v31 = *v30 == (_QWORD)v26;
          v26 = v30;
        }
        while (!v31);
      }
      v26 = v30;
      if (v30 == v27)
        goto LABEL_14;
    }
    v32 = (char *)(v26 + 4);
    if ((*((char *)v26 + 55) & 0x80000000) == 0 || (v32 = *(char **)v32) != 0)
    {
      std::string::basic_string[abi:ne180100]<0>(&v33, v32);
      if (*(char *)(a2 + 23) < 0)
        operator delete(*(void **)a2);
    }
    else
    {
LABEL_14:
      SVGParser::FormatString((SVGParser *)"#%02x%02x%02x", &v33, v11, v12, v13);
    }
    goto LABEL_17;
  }
  if (*(double *)(a1 + 24) > 0.0)
  {
    SVGParser::FormatString((SVGParser *)"rgba(%d,%d,%d,%g)", &v33, (int)v4, (int)v6, (int)v8, *(_QWORD *)(a1 + 24));
LABEL_17:
    *(_OWORD *)a2 = v33;
    *(_QWORD *)(a2 + 16) = v34;
    return;
  }
  MEMORY[0x20BCFBFCC](a2, "none");
}

void sub_20677DD6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::map<std::string,unsigned int,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,unsigned int>>>::map[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 32 * a3;
    do
    {
      std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,unsigned int> const&>((uint64_t **)a1, v4, a2, a2);
      a2 += 32;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_20677DDFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

void sub_20677DEE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20677DFD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t ReadColorValues(SVGParser *a1, SVGColor *a2)
{
  uint64_t v4;
  char v5;
  char v6;
  unsigned int v7;
  const char *v8;
  const char *v9;
  int *v10;
  int *v11;
  uint64_t v12;
  unint64_t i;
  unsigned int v14;
  int v15;
  _BOOL8 v16;
  double v17;
  double v20;
  double *v21;
  char *v23;
  int v24;
  double v25;
  void *__p;
  int *v27;
  uint64_t v28;
  char v29[64];
  uint64_t v30;

  v4 = 0;
  v30 = *MEMORY[0x24BDAC8D0];
  v5 = 1;
  while (1)
  {
    v6 = v5;
    v7 = ReadColorValues(char const*,SVGColor *)::kColorSpaceNames[v4];
    v8 = (const char *)SVGAtom::ToString(v7);
    if (SVGParser::StringBeginsWith(a1, v8, v9))
      break;
    v5 = 0;
    v4 = 1;
    if ((v6 & 1) == 0)
      goto LABEL_4;
  }
  *((_DWORD *)a2 + 8) = v7;
  a1 = (SVGParser *)((char *)a1 + strlen(v8));
  for (i = *(char *)a1; (SVGParser::IsDigitCharacter((SVGParser *)i) & 1) == 0 && *(_BYTE *)a1; i = v14)
  {
    v14 = *((char *)a1 + 1);
    a1 = (SVGParser *)((char *)a1 + 1);
  }
LABEL_4:
  __p = 0;
  v27 = 0;
  v28 = 0;
  SVGParser::GetSeparatedWhitespaceComponents((const char *)a1, &__p, 0);
  v11 = (int *)__p;
  v10 = v27;
  if ((unint64_t)((char *)v27 - (_BYTE *)__p - 33) < 0xFFFFFFFFFFFFFFF7)
    goto LABEL_5;
  if (__p != v27)
  {
    v15 = 0;
    while ((SVGParser::StripLeadingTrailingWhitespace((SVGParser *)((char *)a1 + *v11), (const char *)v11[1], (uint64_t)v29, (char *)0x40) & 1) != 0)
    {
      v25 = 1.0;
      v24 = 0;
      v23 = 0;
      v16 = SVGParser::ParseCGFloat(v29, &v25, &v23, &v24);
      if (!v16)
        break;
      v17 = 1.0;
      if (v25 < 0.0 || v25 > 1.0 || v24 != 0)
      {
        v17 = 255.0;
        if (v23)
        {
          v17 = 100.0;
          if (*v23 != 37)
            v17 = 255.0;
        }
      }
      v20 = SVGUtilities::CGFloatClamp((SVGUtilities *)v16, v25 / v17, 0.0, 1.0);
      v21 = (double *)a2;
      switch(v15)
      {
        case 0:
          goto LABEL_28;
        case 1:
          v21 = (double *)((char *)a2 + 8);
          goto LABEL_28;
        case 2:
          v21 = (double *)((char *)a2 + 16);
          goto LABEL_28;
        case 3:
          v21 = (double *)((char *)a2 + 24);
LABEL_28:
          *v21 = v20;
          break;
        default:
          break;
      }
      v11 += 2;
      ++v15;
      if (v11 == v10)
        goto LABEL_30;
    }
LABEL_5:
    v12 = 0;
    goto LABEL_31;
  }
LABEL_30:
  v12 = 1;
LABEL_31:
  if (__p)
  {
    v27 = (int *)__p;
    operator delete(__p);
  }
  return v12;
}

void sub_20677E274(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGPattern::SVGPattern(SVGPattern *this)
{
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, "pattern");
  SVGViewBoxNode::SVGViewBoxNode(this, (char *)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8A88;
  *((_QWORD *)this + 34) = 0;
  *((_WORD *)this + 140) = 0;
  *((_OWORD *)this + 18) = *MEMORY[0x24BDBF148];
}

void sub_20677E314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGPattern::copy(SVGPattern *this)
{
  uint64_t v2;

  v2 = operator new();
  SVGViewBoxNode::SVGViewBoxNode((SVGViewBoxNode *)v2, this);
  *(_QWORD *)v2 = &off_24BFD8A88;
  *(_BYTE *)(v2 + 281) = 0;
  *(_OWORD *)(v2 + 288) = *MEMORY[0x24BDBF148];
  *(_BYTE *)(v2 + 280) = *((_BYTE *)this + 280);
  *(_QWORD *)(v2 + 272) = *((_QWORD *)this + 34);
  return v2;
}

void sub_20677E3A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40827AA555);
  _Unwind_Resume(a1);
}

void SVGPattern::SVGPattern(SVGPattern *this, const SVGPattern *a2)
{
  uint64_t v3;

  SVGViewBoxNode::SVGViewBoxNode(this, a2);
  *(_QWORD *)v3 = &off_24BFD8A88;
  *(_QWORD *)(v3 + 272) = 0;
  *(_WORD *)(v3 + 280) = 0;
  *(_OWORD *)(v3 + 288) = *MEMORY[0x24BDBF148];
  *(_BYTE *)(v3 + 280) = *((_BYTE *)a2 + 280);
  *(_QWORD *)(v3 + 272) = *((_QWORD *)a2 + 34);
}

void SVGPattern::~SVGPattern(SVGPattern *this)
{
  SVGMask::~SVGMask(this);
  JUMPOUT(0x20BCFC038);
}

uint64_t SVGPattern::print(SVGPattern *this, const char *a2)
{
  const char *v3;
  SVGUtilities *v4;
  const char *v5;

  SVGUtilities::print((SVGUtilities *)"\n", a2);
  v4 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"Pattern: Size: {%.2f, %.2f} Viewbox: ", v3, *((_QWORD *)this + 27), *((_QWORD *)this + 28));
  SVGUtilities::printIgnoringIndention(v4, *(CGRect *)((char *)this + 232));
  return SVGUtilities::print((SVGUtilities *)"\n", v5);
}

uint64_t SVGPattern::inheritParentPattern(SVGPattern *this)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  SVGNode *v8;
  _QWORD v9[5];

  v2 = *(_QWORD *)(*((_QWORD *)this + 34) + 56);
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = ___ZN10SVGPattern20inheritParentPatternEv_block_invoke;
  v9[3] = &__block_descriptor_tmp_2;
  v9[4] = this;
  SVGAttributeMap::enumerate(v2, (uint64_t)v9);
  if (*((_QWORD *)this + 12) == *((_QWORD *)this + 11))
  {
    v4 = *((_QWORD *)this + 34);
    v5 = *(uint64_t **)(v4 + 88);
    v6 = *(uint64_t **)(v4 + 96);
    while (v5 != v6)
    {
      v7 = *v5++;
      v8 = (SVGNode *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
      SVGNode::addChild(this, v8);
      CFRetained::release((CFTypeRef *)v8);
    }
  }
  return (*(uint64_t (**)(SVGPattern *, _QWORD))(*(_QWORD *)this + 24))(this, *((_QWORD *)this + 7));
}

void ___ZN10SVGPattern20inheritParentPatternEv_block_invoke(uint64_t a1, unsigned int a2, const SVGAttribute *a3)
{
  uint64_t v4;
  SVGAttribute *v5;

  v4 = *(_QWORD *)(a1 + 32);
  if ((SVGAttributeMap::hasAttribute(*(_QWORD *)(v4 + 56), a2) & 1) == 0)
  {
    v5 = (SVGAttribute *)operator new();
    SVGAttribute::SVGAttribute(v5, a3);
    SVGAttributeMap::setAttribute(*(_QWORD *)(v4 + 56), (uint64_t)v5, 0);
    CFRetained::release((CFTypeRef *)v5);
  }
}

void sub_20677E5E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

__n128 SVGPattern::drawCells(SVGPattern *this, CGContextRef c, CGRect a3, CGFloat a4)
{
  double height;
  double width;
  CGFloat y;
  CGFloat x;
  __n128 result;
  int IsUserSpace;
  __int128 *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  __int128 v17;
  os_unfair_lock_s *v18;
  __int128 v19;
  CGPattern *v20;
  CGColorSpace *Pattern;
  __int128 v22;
  CGFloat components;
  CGAffineTransform matrix;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v28;
  CGPatternCallbacks callbacks;
  __int128 v30;
  __int128 v31;
  CGAffineTransform v32;
  CGRect v33;
  CGRect v34;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  if (*((_BYTE *)this + 281))
  {
    CGContextFillRect(c, a3);
  }
  else
  {
    *((_BYTE *)this + 281) = 1;
    IsUserSpace = SVGPattern::attributeIsUserSpace((uint64_t)this, 0x50u, 0);
    v12 = (__int128 *)((char *)this + 200);
    v13 = *((double *)this + 25);
    if (IsUserSpace)
    {
      v14 = *((double *)this + 26);
      v15 = *((double *)this + 27);
      v16 = *((double *)this + 28);
    }
    else
    {
      v13 = width * v13;
      v14 = height * *((double *)this + 26);
      v15 = width * *((double *)this + 27);
      v16 = height * *((double *)this + 28);
    }
    v17 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
    *(_OWORD *)&v32.a = *MEMORY[0x24BDBD8B8];
    *(_OWORD *)&v32.c = v17;
    *(_OWORD *)&v32.tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
    v18 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*((_QWORD *)this + 7), 0x52u);
    if (v18)
      SVGAttribute::transformValue(v18, &v32);
    v19 = *v12;
    v30 = *(_OWORD *)((char *)this + 216);
    v31 = v19;
    *((double *)this + 25) = v13;
    *((double *)this + 26) = v14;
    *((double *)this + 27) = v15;
    *((double *)this + 28) = v16;
    *((double *)this + 36) = width;
    *((double *)this + 37) = height;
    *(_QWORD *)&callbacks.version = 0;
    callbacks.drawPattern = (CGPatternDrawPatternCallback)SVGPattern::drawCells(CGContext *,CGRect,double)::$_0::__invoke;
    callbacks.releaseInfo = 0;
    t1 = v32;
    memset(&v28, 0, sizeof(v28));
    CGContextGetCTM(&t2, c);
    CGAffineTransformConcat(&v28, &t1, &t2);
    matrix = v28;
    v33.origin.x = v13;
    v33.origin.y = v14;
    v33.size.width = v15;
    v33.size.height = v16;
    v20 = CGPatternCreate(this, v33, &matrix, v15, v16, kCGPatternTilingConstantSpacingMinimalDistortion, 1, &callbacks);
    Pattern = CGColorSpaceCreatePattern(0);
    CGContextSetFillColorSpace(c, Pattern);
    components = a4;
    CGContextSetFillPattern(c, v20, &components);
    v34.origin.x = x;
    v34.origin.y = y;
    v34.size.width = width;
    v34.size.height = height;
    CGContextFillRect(c, v34);
    CGColorSpaceRelease(Pattern);
    CGPatternRelease(v20);
    v22 = v30;
    *v12 = v31;
    *(_OWORD *)((char *)this + 216) = v22;
    result = *(__n128 *)MEMORY[0x24BDBF148];
    *((_OWORD *)this + 18) = *MEMORY[0x24BDBF148];
    *((_BYTE *)this + 281) = 0;
  }
  return result;
}

uint64_t SVGPattern::attributeIsUserSpace(uint64_t a1, unsigned int a2, uint64_t a3)
{
  SVGAttribute *v4;
  uint64_t v5;
  __int128 v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  std::string __p;

  v4 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (!v4)
    return a3;
  v5 = SVGAttribute::stringValue(v4);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
  }
  else
  {
    v6 = *(_OWORD *)v5;
    __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v6;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 14
      || (*(_QWORD *)__p.__r_.__value_.__l.__data_ == 0x6361705372657375
        ? (v10 = *(_QWORD *)(__p.__r_.__value_.__r.__words[0] + 6) == 0x6573556E4F656361)
        : (v10 = 0),
          !v10))
    {
      if (__p.__r_.__value_.__l.__size_ == 17)
      {
        v11 = 0x6F626A656374426FLL;
        v12 = bswap64(*(_QWORD *)__p.__r_.__value_.__l.__data_);
        if (v12 == 0x6F626A656374426FLL
          && (v11 = 0x756E64696E67426FLL,
              v12 = bswap64(*(_QWORD *)(__p.__r_.__value_.__r.__words[0] + 8)),
              v12 == 0x756E64696E67426FLL))
        {
          v13 = *(unsigned __int8 *)(__p.__r_.__value_.__r.__words[0] + 16) - 120;
        }
        else if (v12 < v11)
        {
          v13 = -1;
        }
        else
        {
          v13 = 1;
        }
        operator delete(__p.__r_.__value_.__l.__data_);
        if (!v13)
          return 0;
      }
      else
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return a3;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    return 1;
  }
  if (HIBYTE(__p.__r_.__value_.__r.__words[2]) == 14)
  {
    if (__p.__r_.__value_.__r.__words[0] != 0x6361705372657375
      || *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 6) != 0x6573556E4F656361)
    {
      return a3;
    }
    return 1;
  }
  if (HIBYTE(__p.__r_.__value_.__r.__words[2]) == 17)
  {
    v7 = 0x6F626A656374426FLL;
    v8 = bswap64(__p.__r_.__value_.__r.__words[0]);
    if (v8 == 0x6F626A656374426FLL
      && (v7 = 0x756E64696E67426FLL, v8 = bswap64(__p.__r_.__value_.__l.__size_), v8 == 0x756E64696E67426FLL))
    {
      v9 = __p.__r_.__value_.__s.__data_[16] - 120;
    }
    else
    {
      v9 = v8 < v7 ? -1 : 1;
    }
    if (!v9)
      return 0;
  }
  return a3;
}

void SVGPattern::draw(CGFloat *this, CGContext *a2)
{
  if (this[31] <= 0.0 && this[32] <= 0.0 && (SVGPattern::attributeIsUserSpace((uint64_t)this, 0x51u, 1) & 1) == 0)
    CGContextScaleCTM(a2, this[36], this[37]);
}

uint64_t SVGPattern::isEqual()
{
  return 0;
}

uint64_t SVGPattern::updatedSpecificAttribute(double *a1, signed int a2, uint64_t a3)
{
  uint64_t result;
  double v7;
  uint64_t v8;
  double v9;
  double v10;
  uint64_t v11;
  double v12;
  double v13;
  uint64_t v14;
  double v15;
  double v16;
  uint64_t v17;
  double v18;
  _QWORD *v19;
  const char *v20;
  double v21;
  uint64_t v22;

  result = 0;
  if (a2 > 66)
  {
    if (a2 == 70)
    {
      CGSVGLengthMake();
      v21 = v16;
      v22 = v17;
      if (SVGAttribute::lengthValue(a3, (uint64_t)&v21))
      {
        v18 = v21;
        if ((_DWORD)v22 == 1)
          v18 = v21 / 100.0;
        a1[26] = v18;
        return 1;
      }
    }
    else
    {
      if (a2 != 67)
        return result;
      CGSVGLengthMake();
      v21 = v10;
      v22 = v11;
      if (SVGAttribute::lengthValue(a3, (uint64_t)&v21))
      {
        v12 = v21;
        if ((_DWORD)v22 == 1)
          v12 = v21 / 100.0;
        a1[25] = v12;
        return 1;
      }
    }
  }
  else if (a2 == 30)
  {
    CGSVGLengthMake();
    v21 = v13;
    v22 = v14;
    if (SVGAttribute::lengthValue(a3, (uint64_t)&v21))
    {
      v15 = v21;
      if ((_DWORD)v22 == 1)
        v15 = v21 / 100.0;
      a1[28] = v15;
      return 1;
    }
  }
  else
  {
    if (a2 != 66)
      return result;
    CGSVGLengthMake();
    v21 = v7;
    v22 = v8;
    if (SVGAttribute::lengthValue(a3, (uint64_t)&v21))
    {
      v9 = v21;
      if ((_DWORD)v22 == 1)
        v9 = v21 / 100.0;
      a1[27] = v9;
      return 1;
    }
  }
  v19 = SVGAtom::ToString(a2);
  SVGUtilities::log((SVGUtilities *)"Failed to parse %s for node name \"pattern\"", v20, v19);
  return 1;
}

uint64_t SVGPattern::drawCells(CGContext *,CGRect,double)::$_0::__invoke(uint64_t a1, int a2)
{
  return SVGUtilities::CGContextDrawSVGDefinitionNode(a2, *(_QWORD *)(a1 + 40), 0);
}

uint64_t CGSVGGradientStopGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGGradientStop::kSVGGradientStopClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_20677EC80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGGradientStopCreateWithColor(uint64_t a1, double a2)
{
  SVGGradientStop *v3;
  _BYTE v5[40];

  SVGColor::SVGColor((uint64_t)v5, *(_DWORD *)(a1 + 32), *(double *)a1, *(double *)(a1 + 8), *(double *)(a1 + 16), *(double *)(a1 + 24));
  v3 = (SVGGradientStop *)operator new();
  SVGGradientStop::SVGGradientStop(v3, (const SVGColor *)v5, a2);
  return *((_QWORD *)v3 + 5);
}

void sub_20677ED08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C1F8F287);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGGradientStopRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGGradientStopRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void CGSVGGradientStopGetColor(uint64_t a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  double v5[5];

  v4 = CFRetained::getObject<SVGGradientStop>(a1, a2);
  if (v4)
  {
    SVGColor::SVGColor((uint64_t)v5, (uint64_t)v4 + 48);
    CGSVGColorCreateRGBA(a3, v5[0], v5[1], v5[2], v5[3]);
  }
  else
  {
    CGSVGColorCreateRGBA(a3, 0.0, 0.0, 0.0, 1.0);
  }
}

void *CFRetained::getObject<SVGGradientStop>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

double CGSVGGradientStopGetOpacity(uint64_t a1, const char *a2)
{
  double *v2;

  v2 = (double *)CFRetained::getObject<SVGGradientStop>(a1, a2);
  if (v2)
    return v2[11];
  else
    return 1.0;
}

void CGSVGGradientStopGetOffset(uint64_t a1, const char *a2)
{
  if (!CFRetained::getObject<SVGGradientStop>(a1, a2))
    CGSVGLengthMake();
}

uint64_t CGSVGGradientGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_20677EEBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGGradientCreate(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  SVGGradient::SVGGradient(v2, a1, 0);
  return *(_QWORD *)(v2 + 40);
}

void sub_20677EF20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40967F26D3);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGGradientRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGGradientRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGSVGGradientGetType(uint64_t a1, const char *a2)
{
  unsigned int *v2;

  v2 = (unsigned int *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (v2)
    return v2[50];
  else
    return 0xFFFFFFFFLL;
}

void *CFRetained::getObject<SVGGradient>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void *CGSVGGradientAddStop(uint64_t a1, const char *a2)
{
  SVGGradient *v4;
  const char *v5;
  void *result;
  const char *v7;
  SVGGradientStop *v8;

  v4 = (SVGGradient *)CFRetained::getObject<SVGGradient>(a1, a2);
  result = CFRetained::getObject<SVGGradientStop>(a1, v5);
  if (v4)
  {
    if (result)
    {
      v8 = (SVGGradientStop *)CFRetained::getObject<SVGGradientStop>((uint64_t)a2, v7);
      return (void *)SVGGradient::addStop(v4, v8);
    }
  }
  return result;
}

_QWORD *CGSVGGradientGetNumberOfStops(uint64_t a1, const char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
    return (_QWORD *)((uint64_t)(result[27] - result[26]) >> 3);
  return result;
}

_QWORD *CGSVGGradientGetStop(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v4;

  result = CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
  {
    v4 = result[26];
    if ((unint64_t)a2 >= (result[27] - v4) >> 3)
      return 0;
    else
      return *(_QWORD **)(*(_QWORD *)(v4 + 8 * (_QWORD)a2) + 40);
  }
  return result;
}

void CGSVGGradientGetStart(uint64_t a1@<X0>, const char *a2@<X1>, _OWORD *a3@<X8>)
{
  char *v4;
  __int128 v5;

  v4 = (char *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (v4)
  {
    v5 = *(_OWORD *)(v4 + 248);
    *a3 = *(_OWORD *)(v4 + 232);
    a3[1] = v5;
  }
  else
  {
    CGSVGPointMake((uint64_t)a3, 0.0, 0.0);
  }
}

__n128 CGSVGGradientSetStart(uint64_t a1, uint64_t a2)
{
  char *v3;
  __n128 result;

  v3 = (char *)CFRetained::getObject<SVGGradient>(a1, (const char *)a2);
  if (v3)
  {
    result = *(__n128 *)a2;
    *(_OWORD *)(v3 + 248) = *(_OWORD *)(a2 + 16);
    *(__n128 *)(v3 + 232) = result;
  }
  return result;
}

void CGSVGGradientGetEnd(uint64_t a1@<X0>, const char *a2@<X1>, _OWORD *a3@<X8>)
{
  char *v4;
  __int128 v5;

  v4 = (char *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (v4)
  {
    v5 = *(_OWORD *)(v4 + 280);
    *a3 = *(_OWORD *)(v4 + 264);
    a3[1] = v5;
  }
  else
  {
    CGSVGPointMake((uint64_t)a3, 0.0, 0.0);
  }
}

__n128 CGSVGGradientSetEnd(uint64_t a1, uint64_t a2)
{
  char *v3;
  __n128 result;
  __int128 v5;

  v3 = (char *)CFRetained::getObject<SVGGradient>(a1, (const char *)a2);
  if (v3)
  {
    result = *(__n128 *)a2;
    v5 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v3 + 264) = *(_OWORD *)a2;
    *(_OWORD *)(v3 + 280) = v5;
  }
  return result;
}

void CGSVGGradientGetCenter(uint64_t a1@<X0>, const char *a2@<X1>, _OWORD *a3@<X8>)
{
  char *v4;
  __int128 v5;

  v4 = (char *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (v4)
  {
    v5 = *(_OWORD *)(v4 + 312);
    *a3 = *(_OWORD *)(v4 + 296);
    a3[1] = v5;
  }
  else
  {
    CGSVGPointMake((uint64_t)a3, 0.0, 0.0);
  }
}

__n128 CGSVGGradientSetCenter(uint64_t a1, uint64_t a2)
{
  char *v3;
  __n128 result;
  __int128 v5;

  v3 = (char *)CFRetained::getObject<SVGGradient>(a1, (const char *)a2);
  if (v3)
  {
    result = *(__n128 *)a2;
    v5 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v3 + 296) = *(_OWORD *)a2;
    *(_OWORD *)(v3 + 312) = v5;
  }
  return result;
}

void CGSVGGradientGetFocal(uint64_t a1@<X0>, const char *a2@<X1>, _OWORD *a3@<X8>)
{
  char *v4;
  __int128 v5;

  v4 = (char *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (v4)
  {
    v5 = *(_OWORD *)(v4 + 344);
    *a3 = *(_OWORD *)(v4 + 328);
    a3[1] = v5;
  }
  else
  {
    CGSVGPointMake((uint64_t)a3, 0.0, 0.0);
  }
}

__n128 CGSVGGradientSetFocal(uint64_t a1, uint64_t a2)
{
  char *v3;
  __n128 result;
  __int128 v5;

  v3 = (char *)CFRetained::getObject<SVGGradient>(a1, (const char *)a2);
  if (v3)
  {
    result = *(__n128 *)a2;
    v5 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v3 + 328) = *(_OWORD *)a2;
    *(_OWORD *)(v3 + 344) = v5;
  }
  return result;
}

void CGSVGGradientGetRadius(uint64_t a1, const char *a2)
{
  if (!CFRetained::getObject<SVGGradient>(a1, a2))
    CGSVGLengthMake();
}

_QWORD *CGSVGGradientSetRadius(uint64_t a1, const char *a2, uint64_t a3)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
  {
    result[45] = a2;
    result[46] = a3;
  }
  return result;
}

unsigned int *CGSVGGradientGetSpreadMethod(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
    return (unsigned int *)result[94];
  return result;
}

_DWORD *CGSVGGradientSetSpreadMethod(uint64_t a1, const char *a2)
{
  int v2;
  _DWORD *result;

  v2 = (int)a2;
  result = CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
    result[94] = v2;
  return result;
}

_OWORD *CGSVGGradientGetGradientTransform@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, _OWORD *a3@<X8>)
{
  _OWORD *result;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;

  result = CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
  {
    v5 = result[25];
    *a3 = result[24];
    a3[1] = v5;
    v6 = result[26];
  }
  else
  {
    v7 = MEMORY[0x24BDBD8B8];
    v8 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
    *a3 = *MEMORY[0x24BDBD8B8];
    a3[1] = v8;
    v6 = *(_OWORD *)(v7 + 32);
  }
  a3[2] = v6;
  return result;
}

__n128 CGSVGGradientSetGradientTransform(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  __n128 result;
  __int128 v5;

  v3 = CFRetained::getObject<SVGGradient>(a1, (const char *)a2);
  if (v3)
  {
    result = *(__n128 *)a2;
    v5 = *(_OWORD *)(a2 + 32);
    v3[25] = *(_OWORD *)(a2 + 16);
    v3[26] = v5;
    v3[24] = result;
  }
  return result;
}

unsigned int *CGSVGGradientGetSpread(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
    return (unsigned int *)result[94];
  return result;
}

_DWORD *CGSVGGradientSetSpread(uint64_t a1, const char *a2)
{
  int v2;
  _DWORD *result;

  v2 = (int)a2;
  result = CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
    result[94] = v2;
  return result;
}

uint64_t CGSVGMaskGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_20677F444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGMaskCreate()
{
  SVGMask *v0;

  v0 = (SVGMask *)operator new();
  SVGMask::SVGMask(v0, 0);
  return *((_QWORD *)v0 + 5);
}

void sub_20677F4A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40691FC75FLL);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGMaskRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGMaskRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

CGImageRef CGSVGMaskCreateMask(uint64_t a1, const char *a2)
{
  SVGMask *v3;
  const char *v4;
  SVGNode *v5;

  v3 = (SVGMask *)CFRetained::getObject<SVGMask>(a1, a2);
  v5 = (SVGNode *)CFRetained::getObject<SVGNode>((uint64_t)a2, v4);
  if (v3 && v5)
    return SVGMask::createMask(v3, v5);
  else
    return 0;
}

void *CFRetained::getObject<SVGMask>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

uint64_t SVGPathCommand::CharacterFromType(char a1)
{
  return a1;
}

void SVGPathCommand::SVGPathCommand(SVGPathCommand *this, const SVGPathCommand *a2)
{
  _QWORD *v4;
  uint64_t v5;
  void *__p[2];
  char v7;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPathCommand::kSVGPathCommandClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v7 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8C78;
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *((_QWORD *)this + 7) = 0;
  if (*((_QWORD *)a2 + 7))
  {
    v4 = (_QWORD *)operator new();
    v5 = *((_QWORD *)a2 + 7);
    v4[1] = 0;
    v4[2] = 0;
    *v4 = 0;
    std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v4, *(const void **)v5, *(_QWORD *)(v5 + 8), (uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 3);
    *((_QWORD *)this + 7) = v4;
  }
}

void sub_20677F664(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x20BCFC038](v2, 0x80C40D6874129);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGPathCommand::isRelative(SVGPathCommand *this)
{
  return ((*((_DWORD *)this + 12) - 97) < 0x16) & (0x2D0885u >> (*((_BYTE *)this + 48) - 97));
}

void SVGPathCommand::appendPoints(uint64_t a1, _QWORD **a2)
{
  SVGPathCommand::appendPoints(a1, (uint64_t)a2, *a2, a2[1]);
}

void SVGPathCommand::appendPoints(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *i;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;

  if (!*(_QWORD *)(a1 + 56))
    SVGPathCommand::appendPoints();
  for (i = a3; i != a4; i += 2)
  {
    v7 = *(_QWORD *)(a1 + 56);
    v8 = *(_QWORD **)(v7 + 8);
    v9 = *(_QWORD *)(v7 + 16);
    if ((unint64_t)v8 >= v9)
    {
      v11 = *(_QWORD **)v7;
      v12 = ((uint64_t)v8 - *(_QWORD *)v7) >> 3;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61)
        goto LABEL_38;
      v14 = v9 - (_QWORD)v11;
      if (v14 >> 2 > v13)
        v13 = v14 >> 2;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
      {
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7 + 16, v15);
        v11 = *(_QWORD **)v7;
        v8 = *(_QWORD **)(v7 + 8);
      }
      else
      {
        v16 = 0;
      }
      v17 = &v16[8 * v12];
      *(_QWORD *)v17 = *i;
      v10 = v17 + 8;
      while (v8 != v11)
      {
        v18 = *--v8;
        *((_QWORD *)v17 - 1) = v18;
        v17 -= 8;
      }
      *(_QWORD *)v7 = v17;
      *(_QWORD *)(v7 + 8) = v10;
      *(_QWORD *)(v7 + 16) = &v16[8 * v15];
      if (v11)
        operator delete(v11);
    }
    else
    {
      *v8 = *i;
      v10 = v8 + 1;
    }
    *(_QWORD *)(v7 + 8) = v10;
    v19 = *(_QWORD *)(a1 + 56);
    v20 = *(_QWORD **)(v19 + 8);
    v21 = *(_QWORD *)(v19 + 16);
    if ((unint64_t)v20 >= v21)
    {
      v23 = *(_QWORD **)v19;
      v24 = ((uint64_t)v20 - *(_QWORD *)v19) >> 3;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61)
LABEL_38:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v26 = v21 - (_QWORD)v23;
      if (v26 >> 2 > v25)
        v25 = v26 >> 2;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
        v27 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
      {
        v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v19 + 16, v27);
        v23 = *(_QWORD **)v19;
        v20 = *(_QWORD **)(v19 + 8);
      }
      else
      {
        v28 = 0;
      }
      v29 = &v28[8 * v24];
      *(_QWORD *)v29 = i[1];
      v22 = v29 + 8;
      while (v20 != v23)
      {
        v30 = *--v20;
        *((_QWORD *)v29 - 1) = v30;
        v29 -= 8;
      }
      *(_QWORD *)v19 = v29;
      *(_QWORD *)(v19 + 8) = v22;
      *(_QWORD *)(v19 + 16) = &v28[8 * v27];
      if (v23)
        operator delete(v23);
    }
    else
    {
      *v20 = i[1];
      v22 = v20 + 1;
    }
    *(_QWORD *)(v19 + 8) = v22;
  }
}

void SVGPathCommand::appendFloat(SVGPathCommand *this, double a2)
{
  uint64_t v3;
  double *v4;
  unint64_t v5;
  double *v6;
  double *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  double *v13;
  char *v14;
  uint64_t v15;

  v3 = *((_QWORD *)this + 7);
  v4 = *(double **)(v3 + 8);
  v5 = *(_QWORD *)(v3 + 16);
  if ((unint64_t)v4 >= v5)
  {
    v7 = *(double **)v3;
    v8 = ((uint64_t)v4 - *(_QWORD *)v3) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v3 + 16, v11);
      v7 = *(double **)v3;
      v4 = *(double **)(v3 + 8);
    }
    else
    {
      v12 = 0;
    }
    v13 = (double *)&v12[8 * v8];
    v14 = &v12[8 * v11];
    *v13 = a2;
    v6 = v13 + 1;
    while (v4 != v7)
    {
      v15 = *((_QWORD *)v4-- - 1);
      *((_QWORD *)v13-- - 1) = v15;
    }
    *(_QWORD *)v3 = v13;
    *(_QWORD *)(v3 + 8) = v6;
    *(_QWORD *)(v3 + 16) = v14;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v4 = a2;
    v6 = v4 + 1;
  }
  *(_QWORD *)(v3 + 8) = v6;
}

void SVGPath::SVGPath(SVGPath *this, const SVGPath *a2)
{
  __int128 v4;
  __int128 v5;
  char **v6;
  const SVGPathCommand **v7;
  const SVGPathCommand **i;
  const SVGPathCommand *v9;
  SVGPathCommand *v10;
  unint64_t v11;
  SVGPathCommand **v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  SVGPathCommand **v19;
  char *v20;
  char *v21;
  SVGPathCommand *v22;
  void *__p[2];
  char v24;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPath::kSVGPathClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v24 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8E28;
  v4 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  v5 = *MEMORY[0x24BDBD8B8];
  *((_OWORD *)this + 6) = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *((_OWORD *)this + 7) = v4;
  *((_OWORD *)this + 3) = 0u;
  v6 = (char **)((char *)this + 48);
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = v5;
  *((_DWORD *)this + 32) = 0;
  v7 = (const SVGPathCommand **)*((_QWORD *)a2 + 6);
  for (i = (const SVGPathCommand **)*((_QWORD *)a2 + 7); v7 != i; ++v7)
  {
    v9 = *v7;
    v10 = (SVGPathCommand *)operator new();
    SVGPathCommand::SVGPathCommand(v10, v9);
    v12 = (SVGPathCommand **)*((_QWORD *)this + 7);
    v11 = *((_QWORD *)this + 8);
    if ((unint64_t)v12 >= v11)
    {
      v14 = ((char *)v12 - *v6) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v15 = v11 - (_QWORD)*v6;
      v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1))
        v16 = v14 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 64, v17);
      else
        v18 = 0;
      v19 = (SVGPathCommand **)&v18[8 * v14];
      *v19 = v10;
      v13 = v19 + 1;
      v21 = (char *)*((_QWORD *)this + 6);
      v20 = (char *)*((_QWORD *)this + 7);
      if (v20 != v21)
      {
        do
        {
          v22 = (SVGPathCommand *)*((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v19 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      *((_QWORD *)this + 6) = v19;
      *((_QWORD *)this + 7) = v13;
      *((_QWORD *)this + 8) = &v18[8 * v17];
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v12 = v10;
      v13 = v12 + 1;
    }
    *((_QWORD *)this + 7) = v13;
  }
}

void sub_20677FB44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void SVGPath::appendCommands(SVGPath *this, const SVGPath *a2)
{
  const SVGPathCommand **v2;
  const SVGPathCommand **i;
  const SVGPathCommand *v5;
  SVGPathCommand *v6;

  v2 = (const SVGPathCommand **)*((_QWORD *)a2 + 6);
  for (i = (const SVGPathCommand **)*((_QWORD *)a2 + 7); v2 != i; ++v2)
  {
    v5 = *v2;
    v6 = (SVGPathCommand *)operator new();
    SVGPathCommand::SVGPathCommand(v6, v5);
    SVGPath::addCommand(this, v6);
    CFRetained::release((CFTypeRef *)v6);
  }
}

void sub_20677FC40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40A582917CLL);
  _Unwind_Resume(a1);
}

double SVGPath::boundingBox(SVGPath *this)
{
  const CGPath *CGPath;
  const char *v3;
  const CGPath *v4;
  double v5;

  CGPath = (const CGPath *)SVGPath::copyCachedCGPath((os_unfair_lock_s *)this);
  if (!CGPath)
    CGPath = CGSVGPathCreateCGPath(*((_QWORD *)this + 5), v3);
  v4 = CGPath;
  *(_QWORD *)&v5 = (unint64_t)CGPathGetBoundingBox(CGPath);
  CGPathRelease(v4);
  return v5;
}

void SVGPath::createStringRepresentation(SVGPath *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;
  std::string::size_type size;
  int v10;
  const std::string::value_type *p_p;
  std::string::size_type v12;
  double v13;
  std::string::size_type v14;
  int v15;
  const std::string::value_type *v16;
  std::string::size_type v17;
  std::string v18;
  void *__p;
  std::string::size_type v20;
  unsigned __int8 v21;
  std::string v22;

  memset(&v22, 0, sizeof(v22));
  v3 = *((_QWORD *)this + 6);
  v4 = *((_QWORD *)this + 7);
  if (v3 == v4)
    goto LABEL_42;
  do
  {
    v5 = *(_QWORD *)(*(_QWORD *)v3 + 56);
    if (v5)
    {
      v6 = *(double **)v5;
      v7 = (uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 3;
    }
    else
    {
      v6 = 0;
      v7 = 0;
    }
    v8 = *(unsigned int *)(*(_QWORD *)v3 + 48);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    {
      size = v22.__r_.__value_.__l.__size_;
      if (!v22.__r_.__value_.__l.__size_)
        goto LABEL_12;
      v10 = *(unsigned __int8 *)(v22.__r_.__value_.__r.__words[0] + v22.__r_.__value_.__l.__size_ - 1);
    }
    else
    {
      size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
      if (!*((_BYTE *)&v22.__r_.__value_.__s + 23))
        goto LABEL_12;
      v10 = *(&v21 + HIBYTE(v22.__r_.__value_.__r.__words[2]));
    }
    if (v10 == 32)
      std::string::resize(&v22, size - 1, 0);
LABEL_12:
    SVGParser::FormatString((SVGParser *)"%c", &__p, v8);
    if ((v21 & 0x80u) == 0)
      p_p = (const std::string::value_type *)&__p;
    else
      p_p = (const std::string::value_type *)__p;
    if ((v21 & 0x80u) == 0)
      v12 = v21;
    else
      v12 = v20;
    std::string::append(&v22, p_p, v12);
    if ((char)v21 < 0)
    {
      operator delete(__p);
      if (!v7)
        goto LABEL_37;
      while (1)
      {
LABEL_20:
        v13 = *v6;
        if (*v6 < 0.0)
        {
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
          {
            v14 = v22.__r_.__value_.__l.__size_;
            if (v22.__r_.__value_.__l.__size_)
            {
              v15 = *(unsigned __int8 *)(v22.__r_.__value_.__r.__words[0] + v22.__r_.__value_.__l.__size_ - 1);
LABEL_26:
              if (v15 == 32)
              {
                std::string::resize(&v22, v14 - 1, 0);
                v13 = *v6;
              }
            }
          }
          else
          {
            v14 = HIBYTE(v22.__r_.__value_.__r.__words[2]);
            if (*((_BYTE *)&v22.__r_.__value_.__s + 23))
            {
              v15 = *(&v21 + HIBYTE(v22.__r_.__value_.__r.__words[2]));
              goto LABEL_26;
            }
          }
        }
        SVGParser::FormatString((SVGParser *)"%g ", &__p, *(_QWORD *)&v13);
        if ((v21 & 0x80u) == 0)
          v16 = (const std::string::value_type *)&__p;
        else
          v16 = (const std::string::value_type *)__p;
        if ((v21 & 0x80u) == 0)
          v17 = v21;
        else
          v17 = v20;
        std::string::append(&v22, v16, v17);
        if ((char)v21 < 0)
          operator delete(__p);
        ++v6;
        if (!--v7)
          goto LABEL_37;
      }
    }
    if (v7)
      goto LABEL_20;
LABEL_37:
    v3 += 8;
  }
  while (v3 != v4);
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_42:
    v18 = v22;
    goto LABEL_44;
  }
  std::string::__init_copy_ctor_external(&v18, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
LABEL_44:
  SVGParser::StripLeadingTrailingWhitespace(&v18, a2);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
}

void sub_20677FF00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGPath::print(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  double *v5;
  uint64_t v6;
  double v7;

  v1 = *(_QWORD *)(this + 48);
  v2 = *(_QWORD *)(this + 56);
  if (v1 != v2)
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*(_QWORD *)v1 + 56);
      if (v4)
      {
        v5 = *(double **)v4;
        v6 = (uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 3;
      }
      else
      {
        v6 = 0;
        v5 = 0;
      }
      printf("Command %d, %ld floats, type %c:\n    ", v3, v6, *(char *)(*(_QWORD *)v1 + 48));
      for (; v6; --v6)
      {
        v7 = *v5++;
        printf("%f ", v7);
      }
      ++v3;
      this = putchar(10);
      v1 += 8;
    }
    while (v1 != v2);
  }
  return this;
}

char *std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<double const*>,std::__wrap_iter<double const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 3);
    if (v14 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 3;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 2 > v14)
      v14 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[8 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[8 * v17];
    v29 = 8 * a5;
    v30 = &v28[8 * a5];
    do
    {
      v31 = *(_QWORD *)v7;
      v7 += 8;
      *(_QWORD *)v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    v35 = v30;
    v5 = std::vector<double>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    v21 = &__src[8 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[8 * a5];
    v25 = &v23[-8 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_QWORD *)v25;
        v25 += 8;
        *(_QWORD *)v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[8 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_2067801F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGCanvas::SVGCanvas(SVGCanvas *this, const SVGDocument *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  void *__p[2];
  char v13;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGCanvas::kSVGCanvasClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v13 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EC8;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 6) = a2;
  v4 = *((_QWORD *)a2 + 6);
  v5 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 72, 1uLL);
  v7 = &v5[v6];
  *v5 = v4;
  v8 = v5 + 1;
  v10 = (char *)*((_QWORD *)this + 7);
  v9 = (char *)*((_QWORD *)this + 8);
  if (v9 != v10)
  {
    do
    {
      v11 = *((_QWORD *)v9 - 1);
      v9 -= 8;
      *--v5 = v11;
    }
    while (v9 != v10);
    v9 = (char *)*((_QWORD *)this + 7);
  }
  *((_QWORD *)this + 7) = v5;
  *((_QWORD *)this + 8) = v8;
  *((_QWORD *)this + 9) = v7;
  if (v9)
    operator delete(v9);
  *((_QWORD *)this + 8) = v8;
}

void sub_206780300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;
  void *v18;

  v18 = *v16;
  if (*v16)
  {
    *(_QWORD *)(v15 + 64) = v18;
    operator delete(v18);
  }
  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void SVGCanvas::~SVGCanvas(SVGCanvas *this)
{
  CFTypeRef **v2;
  void *v3;

  *(_QWORD *)this = &off_24BFD8EC8;
  if (!*((_QWORD *)this + 6))
  {
    v2 = (CFTypeRef **)*((_QWORD *)this + 7);
    if (*((CFTypeRef ***)this + 8) == v2)
      std::vector<double>::__throw_out_of_range[abi:ne180100]();
    CFRetained::release(*v2);
  }
  v3 = (void *)*((_QWORD *)this + 7);
  if (v3)
  {
    *((_QWORD *)this + 8) = v3;
    operator delete(v3);
  }
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  SVGCanvas::~SVGCanvas(this);
  JUMPOUT(0x20BCFC038);
}

SVGNode *SVGCanvas::pushGroup(SVGCanvas *this)
{
  SVGNode *v2;
  SVGNode *v3;
  unint64_t v4;
  SVGNode **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  SVGNode **v13;
  char *v14;
  char *v15;
  char *v16;
  SVGNode *v17;

  v2 = *(SVGNode **)(*((_QWORD *)this + 8) - 8);
  v3 = (SVGNode *)operator new();
  SVGNode::SVGNode(v3, 29);
  SVGNode::addChild(v2, v3);
  CFRetained::release((CFTypeRef *)v3);
  v4 = *((_QWORD *)this + 9);
  v5 = (SVGNode **)*((_QWORD *)this + 8);
  if ((unint64_t)v5 >= v4)
  {
    v7 = *((_QWORD *)this + 7);
    v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 72, v11);
    else
      v12 = 0;
    v13 = (SVGNode **)&v12[8 * v8];
    v14 = &v12[8 * v11];
    *v13 = v3;
    v6 = v13 + 1;
    v16 = (char *)*((_QWORD *)this + 7);
    v15 = (char *)*((_QWORD *)this + 8);
    if (v15 != v16)
    {
      do
      {
        v17 = (SVGNode *)*((_QWORD *)v15 - 1);
        v15 -= 8;
        *--v13 = v17;
      }
      while (v15 != v16);
      v15 = (char *)*((_QWORD *)this + 7);
    }
    *((_QWORD *)this + 7) = v13;
    *((_QWORD *)this + 8) = v6;
    *((_QWORD *)this + 9) = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = v3;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 8) = v6;
  return v3;
}

void sub_20678051C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C408E750C55);
  _Unwind_Resume(a1);
}

uint64_t SVGCanvas::currentGroup(SVGCanvas *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 8) - 8);
}

uint64_t SVGCanvas::popGroup(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 64);
  if ((unint64_t)(v1 - *(_QWORD *)(this + 56)) >= 9)
    *(_QWORD *)(this + 64) = v1 - 8;
  return this;
}

CGFloat *SVGCanvas::addRect(SVGCanvas *this, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  SVGNode *v6;
  CGFloat *v7;
  CGRect v9;
  CGRect v10;
  CGRect v11;
  CGRect v12;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v6 = *(SVGNode **)(*((_QWORD *)this + 8) - 8);
  v7 = (CGFloat *)operator new();
  SVGShapeNode::SVGShapeNode(v7, 49);
  v9.origin.x = x;
  v9.origin.y = y;
  v9.size.width = width;
  v9.size.height = height;
  v7[25] = CGRectGetMinX(v9);
  v10.origin.x = x;
  v10.origin.y = y;
  v10.size.width = width;
  v10.size.height = height;
  v7[26] = CGRectGetMinY(v10);
  v11.origin.x = x;
  v11.origin.y = y;
  v11.size.width = width;
  v11.size.height = height;
  v7[29] = CGRectGetWidth(v11);
  v12.origin.x = x;
  v12.origin.y = y;
  v12.size.width = width;
  v12.size.height = height;
  v7[30] = CGRectGetHeight(v12);
  SVGNode::addChild(v6, (SVGNode *)v7);
  CFRetained::release((CFTypeRef *)v7);
  return v7;
}

void sub_206780644(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

uint64_t SVGCanvas::addEllipseInRect(SVGCanvas *this, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  SVGNode *v6;
  uint64_t v7;
  SVGUtilities *v8;
  uint64_t v9;
  CGRect v11;
  CGRect v12;
  CGRect v13;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v6 = *(SVGNode **)(*((_QWORD *)this + 8) - 8);
  v7 = operator new();
  SVGShapeNode::SVGShapeNode(v7, 16);
  v11.origin.x = x;
  v11.origin.y = y;
  v11.size.width = width;
  v11.size.height = height;
  *(CGFloat *)(v7 + 264) = SVGUtilities::CGRectGetCenter(v8, v11);
  *(_QWORD *)(v7 + 272) = v9;
  v12.origin.x = x;
  v12.origin.y = y;
  v12.size.width = width;
  v12.size.height = height;
  *(CGFloat *)(v7 + 248) = CGRectGetWidth(v12) * 0.5;
  v13.origin.x = x;
  v13.origin.y = y;
  v13.size.width = width;
  v13.size.height = height;
  *(CGFloat *)(v7 + 256) = CGRectGetHeight(v13) * 0.5;
  SVGNode::addChild(v6, (SVGNode *)v7);
  CFRetained::release((CFTypeRef *)v7);
  return v7;
}

void sub_206780740(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

CGFloat *SVGCanvas::addLine(SVGCanvas *this, CGPoint a2, CGPoint a3)
{
  CGFloat y;
  CGFloat x;
  CGFloat v5;
  CGFloat v6;
  SVGNode *v7;
  CGFloat *v8;

  y = a3.y;
  x = a3.x;
  v5 = a2.y;
  v6 = a2.x;
  v7 = *(SVGNode **)(*((_QWORD *)this + 8) - 8);
  v8 = (CGFloat *)operator new();
  SVGShapeNode::SVGShapeNode(v8, 32);
  v8[25] = v6;
  v8[26] = v5;
  v8[27] = x;
  v8[28] = y;
  SVGNode::addChild(v7, (SVGNode *)v8);
  CFRetained::release((CFTypeRef *)v8);
  return v8;
}

void sub_2067807E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

SVGNode *SVGCanvas::addPath(SVGCanvas *this)
{
  SVGNode *v1;
  SVGNode *v2;

  v1 = *(SVGNode **)(*((_QWORD *)this + 8) - 8);
  v2 = (SVGNode *)operator new();
  SVGShapeNode::SVGShapeNode(v2, 42);
  SVGNode::addChild(v1, v2);
  CFRetained::release((CFTypeRef *)v2);
  return v2;
}

void sub_206780868(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

SVGNode *SVGCanvas::addPolyline(uint64_t a1, uint64_t a2)
{
  SVGNode *v4;

  v4 = (SVGNode *)operator new();
  SVGShapeNode::SVGShapeNode(v4, 45);
  SVGShapeNode::setPointList((uint64_t)v4, a2);
  SVGNode::addChild(*(SVGNode **)(*(_QWORD *)(a1 + 64) - 8), v4);
  CFRetained::release((CFTypeRef *)v4);
  return v4;
}

void sub_206780900(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

SVGNode *SVGCanvas::addPolygon(uint64_t a1, uint64_t a2)
{
  SVGNode *v4;

  v4 = (SVGNode *)operator new();
  SVGShapeNode::SVGShapeNode(v4, 44);
  SVGShapeNode::setPointList((uint64_t)v4, a2);
  SVGNode::addChild(*(SVGNode **)(*(_QWORD *)(a1 + 64) - 8), v4);
  CFRetained::release((CFTypeRef *)v4);
  return v4;
}

void sub_206780998(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

CGFloat *SVGCanvas::addText(SVGCanvas *this, char *a2, CGPoint a3)
{
  CGFloat y;
  CGFloat x;
  CGFloat *v7;

  y = a3.y;
  x = a3.x;
  v7 = (CGFloat *)operator new();
  SVGShapeNode::SVGShapeNode(v7, 10001);
  SVGNode::setText(v7, a2);
  v7[25] = x;
  v7[26] = y;
  SVGNode::addChild(*(SVGNode **)(*((_QWORD *)this + 8) - 8), (SVGNode *)v7);
  CFRetained::release((CFTypeRef *)v7);
  return v7;
}

void sub_206780A44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

uint64_t SVGCanvas::rootNode(SVGCanvas *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 7);
  if (*((_QWORD *)this + 8) == v1)
    std::vector<double>::__throw_out_of_range[abi:ne180100]();
  return *(_QWORD *)v1;
}

void SVGMask::SVGMask(SVGMask *this, char *a2)
{
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;

  v3 = SVGNode::SVGNode((uint64_t)this, 0x4Au);
  *(_QWORD *)v3 = &off_24BFD8D88;
  *(_OWORD *)(v3 + 200) = 0u;
  *(_OWORD *)(v3 + 216) = 0u;
  v4 = (_OWORD *)MEMORY[0x24BDBF090];
  *(_QWORD *)(v3 + 232) = 0x100000000;
  v5 = v4[1];
  *(_OWORD *)(v3 + 240) = *v4;
  *(_OWORD *)(v3 + 256) = v5;
  *(_BYTE *)(v3 + 272) = 0;
  SVGNode::setIdentifier((SVGNode *)v3, a2);
}

void sub_206780AF4(_Unwind_Exception *a1)
{
  SVGNode *v1;

  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

void SVGMask::SVGMask(SVGMask *this, const SVGAttributeMap **a2)
{
  uint64_t v2;
  __int128 v3;

  SVGNode::SVGNode(this, a2);
  *(_QWORD *)v2 = &off_24BFD8D88;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_QWORD *)(v2 + 232) = 0x100000000;
  v3 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(v2 + 240) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(v2 + 256) = v3;
  *(_BYTE *)(v2 + 272) = 0;
}

void SVGMask::~SVGMask(SVGMask *this)
{
  SVGNode::~SVGNode(this);
  JUMPOUT(0x20BCFC038);
}

uint64_t SVGMask::copy(const SVGAttributeMap **this)
{
  uint64_t v2;
  __int128 v3;

  v2 = operator new();
  SVGNode::SVGNode((SVGNode *)v2, this);
  *(_QWORD *)v2 = &off_24BFD8D88;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_QWORD *)(v2 + 232) = 0x100000000;
  v3 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(v2 + 240) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(v2 + 256) = v3;
  *(_BYTE *)(v2 + 272) = 0;
  return v2;
}

void sub_206780BF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40691FC75FLL);
  _Unwind_Resume(a1);
}

void SVGMask::updatedAttributes(SVGMask *this, SVGAttributeMap *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[10];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  __n128 (*v24)(uint64_t, uint64_t);
  uint64_t (*v25)();
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  __n128 (*v31)(uint64_t, uint64_t);
  uint64_t (*v32)();
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  __n128 (*v38)(uint64_t, uint64_t);
  uint64_t (*v39)();
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  __n128 (*v45)(uint64_t, uint64_t);
  uint64_t (*v46)();
  uint64_t v47;
  uint64_t v48;

  v42 = 0;
  v43 = &v42;
  v44 = 0x3802000000;
  v45 = __Block_byref_object_copy_;
  v46 = __Block_byref_object_dispose_;
  v47 = 0;
  v48 = 0;
  CGSVGLengthMakeWithType();
  v47 = v4;
  v48 = v5;
  v35 = 0;
  v36 = &v35;
  v37 = 0x3802000000;
  v38 = __Block_byref_object_copy_;
  v39 = __Block_byref_object_dispose_;
  v40 = 0;
  v41 = 0;
  CGSVGLengthMakeWithType();
  v40 = v6;
  v41 = v7;
  v28 = 0;
  v29 = &v28;
  v30 = 0x3802000000;
  v31 = __Block_byref_object_copy_;
  v32 = __Block_byref_object_dispose_;
  v33 = 0;
  v34 = 0;
  CGSVGLengthMakeWithType();
  v33 = v8;
  v34 = v9;
  v21 = 0;
  v22 = &v21;
  v23 = 0x3802000000;
  v24 = __Block_byref_object_copy_;
  v25 = __Block_byref_object_dispose_;
  v26 = 0;
  v27 = 0;
  CGSVGLengthMakeWithType();
  v26 = v10;
  v27 = v11;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 1;
  v12[0] = MEMORY[0x24BDAC760];
  v12[1] = 0x40000000;
  v12[2] = ___ZN7SVGMask17updatedAttributesEP15SVGAttributeMap_block_invoke;
  v12[3] = &unk_24BFD9130;
  v12[4] = &v42;
  v12[5] = &v35;
  v12[6] = &v28;
  v12[7] = &v21;
  v12[8] = &v17;
  v12[9] = &v13;
  SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v12);
  *((double *)this + 25) = CGSVGLengthScaledLength(v43[5], v43[6], 1.0);
  *((double *)this + 26) = CGSVGLengthScaledLength(v36[5], v36[6], 1.0);
  *((double *)this + 27) = CGSVGLengthScaledLength(v29[5], v29[6], 1.0);
  *((double *)this + 28) = CGSVGLengthScaledLength(v22[5], v22[6], 1.0);
  *((_DWORD *)this + 58) = *((_DWORD *)v18 + 6);
  *((_DWORD *)this + 59) = *((_DWORD *)v14 + 6);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v42, 8);
}

void sub_206780E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  uint64_t v34;

  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 176), 8);
  _Block_object_dispose((const void *)(v34 - 120), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN7SVGMask17updatedAttributesEP15SVGAttributeMap_block_invoke(_QWORD *a1, int a2, SVGAttribute *this)
{
  int v5;
  uint64_t v6;
  _QWORD *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v5 = *((_DWORD *)this + 12);
  switch(v5)
  {
    case 'B':
      v6 = a1[6];
      goto LABEL_7;
    case 'C':
      v6 = a1[4];
      goto LABEL_7;
    case 'D':
    case 'E':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
      return;
    case 'F':
      v6 = a1[5];
      goto LABEL_7;
    case 'K':
      v9 = SVGAttribute::stringValue(this);
      v10 = *(char *)(v9 + 23);
      if (v10 < 0)
      {
        if (*(_QWORD *)(v9 + 8) != 14)
          return;
        v9 = *(_QWORD *)v9;
      }
      else if (v10 != 14)
      {
        return;
      }
      if (*(_QWORD *)v9 == 0x6361705372657375 && *(_QWORD *)(v9 + 6) == 0x6573556E4F656361)
        *(_DWORD *)(*(_QWORD *)(a1[8] + 8) + 24) = 1;
      return;
    case 'L':
      v11 = SVGAttribute::stringValue(this);
      v12 = *(char *)(v11 + 23);
      if (v12 < 0)
      {
        if (*(_QWORD *)(v11 + 8) != 17)
          return;
        v11 = *(_QWORD *)v11;
      }
      else if (v12 != 17)
      {
        return;
      }
      if (*(_QWORD *)v11 == 0x6F427463656A626FLL
        && *(_QWORD *)(v11 + 8) == 0x6F42676E69646E75
        && *(_BYTE *)(v11 + 16) == 120)
      {
        *(_DWORD *)(*(_QWORD *)(a1[9] + 8) + 24) = 0;
      }
      return;
    default:
      if (v5 != 30)
        return;
      v6 = a1[7];
LABEL_7:
      if (!SVGAttribute::lengthValue((uint64_t)this, *(_QWORD *)(v6 + 8) + 40))
      {
        v7 = SVGAtom::ToString(*((_DWORD *)this + 12));
        SVGUtilities::log((SVGUtilities *)"SVGMask: Attribute parse error: %s\n", v8, v7);
      }
      return;
  }
}

CGImageRef SVGMask::createMask(SVGMask *this, SVGNode *a2)
{
  CGImageRef v2;
  double v4;
  double v5;
  double v6;
  double v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  double v11;
  double v12;
  double v13;
  double v14;
  CGColorSpace *v15;
  CGContext *v16;
  CGContext *v17;
  CGImage *Image;
  void *v19;
  CGColorSpace *DeviceGray;
  CGContext *v21;
  CGContext *v22;
  CGDataProvider *v23;
  CGAffineTransform v25;
  CGFloat decode[3];
  uint64_t v27;
  CGRect v28;

  v27 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 272))
    return 0;
  *((_BYTE *)this + 272) = 1;
  v7 = (*(double (**)(SVGNode *, _QWORD))(*(_QWORD *)a2 + 32))(a2, 0);
  v8 = v4;
  v9 = v5;
  v10 = v6;
  v11 = *((double *)this + 25);
  if (*((_DWORD *)this + 58))
  {
    v12 = *((double *)this + 26);
    v13 = *((double *)this + 27);
    v14 = *((double *)this + 28);
  }
  else
  {
    v11 = v7 + v11 * v5;
    v12 = v4 + *((double *)this + 26) * v6;
    v13 = v5 * *((double *)this + 27);
    v14 = v6 * *((double *)this + 28);
  }
  v2 = 0;
  *((double *)this + 30) = v11;
  *((double *)this + 31) = v12;
  *((double *)this + 32) = v13;
  *((double *)this + 33) = v14;
  if (v13 != 0.0 && v14 != 0.0)
  {
    v15 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF318]);
    if (v15)
    {
      v16 = CGBitmapContextCreate(0, (unint64_t)v13, (unint64_t)v14, 8uLL, 0, v15, 1u);
      v17 = v16;
      if (v16)
      {
        CGContextTranslateCTM(v16, -*((double *)this + 30), -*((double *)this + 31));
        if (!*((_DWORD *)this + 59))
        {
          v25.b = 0.0;
          v25.c = 0.0;
          v25.a = v9;
          v25.d = v10;
          v25.tx = v7;
          v25.ty = v8;
          CGContextConcatCTM(v17, &v25);
        }
        SVGUtilities::CGContextDrawSVGDefinitionNode(v17, *((const char **)this + 5), 0);
      }
    }
    else
    {
      v17 = 0;
    }
    CGColorSpaceRelease(v15);
    Image = CGBitmapContextCreateImage(v17);
    CGContextRelease(v17);
    v19 = malloc_type_calloc((unint64_t)(v14 * (double)(unint64_t)((v13 * 8.0 + 7.0) * 0.125)), 1uLL, 0x100004077774924uLL);
    DeviceGray = CGColorSpaceCreateDeviceGray();
    if (DeviceGray)
    {
      v21 = CGBitmapContextCreate(v19, (unint64_t)v13, (unint64_t)v14, 8uLL, (unint64_t)((v13 * 8.0 + 7.0) * 0.125), DeviceGray, 0);
      v22 = v21;
      if (v21)
      {
        v28.origin.x = 0.0;
        v28.origin.y = 0.0;
        v28.size.width = v13;
        v28.size.height = v14;
        CGContextDrawImage(v21, v28, Image);
      }
    }
    else
    {
      v22 = 0;
    }
    CGColorSpaceRelease(DeviceGray);
    CGImageRelease(Image);
    v23 = CGDataProviderCreateWithData(v19, v19, (unint64_t)(v14 * (double)(unint64_t)((v13 * 8.0 + 7.0) * 0.125)), (CGDataProviderReleaseDataCallback)ReleaseCallbackForMaskData);
    *(_OWORD *)decode = xmmword_206799E30;
    v2 = CGImageMaskCreate((unint64_t)v13, (unint64_t)v14, 8uLL, 8uLL, (unint64_t)((v13 * 8.0 + 7.0) * 0.125), v23, decode, 0);
    CGDataProviderRelease(v23);
    CGContextRelease(v22);
    *((_BYTE *)this + 272) = 0;
  }
  return v2;
}

void ReleaseCallbackForMaskData(void *a1, const void *a2)
{
  if (a1)
    free(a1);
}

uint64_t SVGMask::print(SVGMask *this)
{
  const char *v2;
  const char *v3;
  const char *v4;
  uint64_t result;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;

  v2 = (char *)this + 64;
  if (*((char *)this + 87) < 0)
    v2 = *(const char **)v2;
  printf("Node: %s \n", v2);
  if (*((_DWORD *)this + 58) == 1)
    v3 = "userSpaceOnUse : true [non default]";
  else
    v3 = "objectBoundingBox: true [default]";
  printf("maskUnits: %s\n", v3);
  if (*((_DWORD *)this + 59))
    v4 = "userSpaceOnUse: true [default]";
  else
    v4 = "objectBoundingBox : true [non default]";
  printf("maskContentUnits: %s\n", v4);
  SVGAttributeMap::print(*((SVGAttributeMap **)this + 7));
  result = puts("\nMasking Nodes: ");
  v7 = (uint64_t *)*((_QWORD *)this + 11);
  v6 = (uint64_t *)*((_QWORD *)this + 12);
  while (v7 != v6)
  {
    v8 = *v7++;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
  }
  return result;
}

uint64_t SVGMask::printWithNodeToMask(uint64_t a1, uint64_t a2)
{
  double v4;
  double v5;
  double v6;
  double v7;

  puts("\nNodeToMask:");
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 48))(a2);
  v4 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 32))(a2, 0);
  printf("Node to mask bounding box: %g %g %g %g\n\n", v4, v5, v6, v7);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

_QWORD *SVGMask::createStringRepresentation@<X0>(SVGMask *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;

  v3 = SVGNode::identifier(this);
  return SVGParser::FormatString((SVGParser *)"url(#%s)", a2, v3);
}

void ___ZN8SVGStyle21addDefinitionsFromCSSEPKc_block_invoke(uint64_t a1, uint64_t a2, const SVGAttribute *a3)
{
  uint64_t v4;
  SVGAttribute *v5;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = (SVGAttribute *)operator new();
  SVGAttribute::SVGAttribute(v5, a3);
  SVGAttributeMap::setAttribute(v4, (uint64_t)v5, 1);
}

void sub_206781504(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

std::string *std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_206781618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::string>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, __int128 *a2, __int128 *a3, std::string *this)
{
  std::string *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  std::string *v11;
  std::string *v12;

  v4 = this;
  v11 = this;
  v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v12 = ++v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_206781774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0)
      operator delete(*(void **)(v1 - 24));
    v1 -= 24;
  }
}

uint64_t std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

void sub_2067818D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_2067819C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<SVGAtom::Name,SVGAttribute *>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,SVGAttribute *>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,SVGAttribute *>>>::__remove_node_pointer(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
  operator delete((void *)a2);
  return v3;
}

void SVGDocument::~SVGDocument(SVGDocument *this)
{
  SVGStyle *v2;

  *(_QWORD *)this = &off_24BFD8B38;
  CFRetained::release(*((_QWORD *)this + 6));
  CFRetained::release(*((_QWORD *)this + 7));
  v2 = (SVGStyle *)*((_QWORD *)this + 8);
  if (v2)
  {
    SVGStyle::~SVGStyle(v2);
    MEMORY[0x20BCFC038]();
  }
  *(_QWORD *)this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  SVGDocument::~SVGDocument(this);
  JUMPOUT(0x20BCFC038);
}

BOOL SVGDocument::read(SVGDocument *this, const char *a2, SVGReaderOptions *a3)
{
  const __CFAllocator *v5;
  const __CFString *v6;
  const __CFString *v7;
  CFStringRef v8;
  const __CFURL *v9;
  _BOOL8 v10;

  if (!a2)
    return 0;
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, 0x8000100u);
  if (!v6)
    return 0;
  v7 = v6;
  if (!CFStringHasSuffix(v6, CFSTR("file://")))
  {
    v8 = CFStringCreateWithFormat(v5, 0, CFSTR("file://%@"), v7);
    CFRelease(v7);
    v7 = v8;
  }
  v9 = CFURLCreateWithString(v5, v7, 0);
  CFRelease(v7);
  v10 = SVGDocument::read(this, v9, a3);
  if (v9)
    CFRelease(v9);
  return v10;
}

BOOL SVGDocument::read(SVGDocument *this, CFURLRef url, SVGReaderOptions *a3)
{
  SVGReaderOptions *v3;
  int *v6;
  CFURLRef PathComponent;
  SVGReaderOptions *v8;
  const void *v9;
  __CFData *CFDataWithContentsOfURL;
  _BOOL8 v11;
  uint64_t v13;
  char v14;
  uint64_t v15;
  int v16;
  char v17;
  int v18;

  v3 = a3;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 1;
  v18 = 0;
  if (a3)
    v6 = (int *)a3;
  else
    v6 = (int *)&v13;
  if (v6[6] < 1)
  {
    if (!a3)
      v3 = (SVGReaderOptions *)&v13;
    v9 = (const void *)*((_QWORD *)v3 + 2);
    if (v9)
      CFRelease(v9);
    *((_QWORD *)v3 + 2) = 0;
  }
  else
  {
    PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x24BDBD240], url);
    v8 = (SVGReaderOptions *)&v13;
    if (v3)
      v8 = v3;
    *((_QWORD *)v8 + 2) = PathComponent;
  }
  CFDataWithContentsOfURL = CreateCFDataWithContentsOfURL(url);
  v11 = SVGDocument::read(this, CFDataWithContentsOfURL, (SVGReaderOptions *)v6);
  if (CFDataWithContentsOfURL)
    CFRelease(CFDataWithContentsOfURL);
  SVGReaderOptions::~SVGReaderOptions((SVGReaderOptions *)&v13);
  return v11;
}

void sub_206781C84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  SVGReaderOptions::~SVGReaderOptions((SVGReaderOptions *)va);
  _Unwind_Resume(a1);
}

BOOL SVGDocument::checkProfileSettings(SVGDocument *this, CFDataRef theData)
{
  CFIndex Length;
  const char *v5;
  _BOOL8 v6;
  uint64_t i;
  char **v8;
  SVGAttribute *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  int v14;
  char *v15;
  char *v16;
  char **v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  unint64_t v21;
  _QWORD *v22;
  const char *v23;
  _QWORD *v24;
  char *v25;
  char *v26;
  const char *v27;
  uint64_t j;
  uint64_t k;
  _QWORD *v30;
  const char *v31;
  uint64_t m;
  char **v33;
  char *v34;
  char *v35;
  unsigned __int8 **v36;
  unsigned __int8 *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  int v41;
  unsigned __int8 *v42;
  char *v43;
  char **v44;
  const char *v45;
  char *v46;
  unint64_t v47;
  _QWORD *v48;
  const char *v49;
  char **v51;
  char *v52[2];
  uint64_t v53[3];
  void *__p;
  char *v55;
  uint64_t v56;
  void *v57[2];
  char v58;
  void *v59;
  unint64_t v60;
  unsigned __int8 v61;
  void *v62;
  _BYTE *v63;
  uint64_t v64;
  void *v65[2];
  char v66;
  char **v67;
  char *v68[2];
  char *v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  _QWORD v74[3];
  int v75;
  _QWORD v76[3];
  int v77;
  uint64_t v78[3];
  int v79;
  uint64_t v80[3];
  int v81;
  uint64_t v82[3];
  int v83;
  _QWORD v84[4];

  v84[3] = *MEMORY[0x24BDAC8D0];
  if (CFDataGetLength(theData) < 32001)
  {
    LODWORD(v69) = 105;
    std::string::basic_string[abi:ne180100]<0>(&v70, "http://www.w3.org/2000/svg");
    v73 = 64;
    std::string::basic_string[abi:ne180100]<0>(v74, "1.2");
    v75 = 106;
    std::string::basic_string[abi:ne180100]<0>(v76, "tiny-ps");
    std::map<SVGAtom::Name,std::string>::map[abi:ne180100]((uint64_t)&v67, (unsigned int *)&v69, 3);
    for (i = 0; i != -12; i -= 4)
    {
      if (SHIBYTE(v76[i + 2]) < 0)
        operator delete((void *)v76[i]);
    }
    v8 = v67;
    if (v67 != v68)
    {
      while (1)
      {
        v9 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(*((_QWORD *)this + 6) + 56), *((_DWORD *)v8 + 8));
        if (!v9)
          break;
        v10 = (unsigned __int8 *)SVGAttribute::stringValue(v9);
        v11 = v10[23];
        if ((v11 & 0x80u) == 0)
          v12 = (char *)v10[23];
        else
          v12 = (char *)*((_QWORD *)v10 + 1);
        v13 = (char *)*((unsigned __int8 *)v8 + 63);
        v14 = (char)v13;
        if ((char)v13 < 0)
          v13 = v8[6];
        if (v12 != v13)
          break;
        if (v14 >= 0)
          v15 = (char *)(v8 + 5);
        else
          v15 = v8[5];
        if ((v11 & 0x80) != 0)
        {
          if (memcmp(*(const void **)v10, v15, *((_QWORD *)v10 + 1)))
            break;
        }
        else if (v10[23])
        {
          while (*v10 == *v15)
          {
            ++v10;
            ++v15;
            if (!--v11)
              goto LABEL_24;
          }
          break;
        }
LABEL_24:
        v16 = v8[1];
        if (v16)
        {
          do
          {
            v17 = (char **)v16;
            v16 = *(char **)v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            v17 = (char **)v8[2];
            v18 = *v17 == (char *)v8;
            v8 = v17;
          }
          while (!v18);
        }
        v8 = v17;
        if (v17 == v68)
          goto LABEL_30;
      }
      v22 = SVGAtom::ToString(*((_DWORD *)v8 + 8));
      v24 = v8 + 5;
      if (*((char *)v8 + 63) < 0)
        v24 = (_QWORD *)*v24;
      SVGUtilities::error((SVGUtilities *)"\nTiny SVG P/S profile requires attribute: %s with value: %s on root node", v23, v22, v24);
      v6 = 0;
      goto LABEL_123;
    }
LABEL_30:
    std::string::basic_string[abi:ne180100]<0>(v65, "title");
    v62 = 0;
    v63 = 0;
    v64 = 0;
    SVGNode::findChildNodesWithName(*((_QWORD *)this + 6), (unsigned __int8 *)v65, &v62);
    if (v63 - (_BYTE *)v62 != 8)
    {
      SVGUtilities::error((SVGUtilities *)"SVG Tiny P/S profile requires title node to be present once", v19);
      v6 = 0;
LABEL_119:
      if (v62)
      {
        v63 = v62;
        operator delete(v62);
      }
      if (v66 < 0)
        operator delete(v65[0]);
LABEL_123:
      std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy((uint64_t)&v67, v68[0]);
      return v6;
    }
    std::string::basic_string[abi:ne180100]<0>(&v59, (char *)&unk_20679A6BE);
    v20 = *(const char **)(*(_QWORD *)v62 + 192);
    if (v20)
    {
      if ((v20[23] & 0x80000000) == 0 || (v20 = *(const char **)v20) != 0)
        MEMORY[0x20BCFBFCC](&v59);
    }
    if ((char)v61 < 0)
    {
      v21 = v60;
      if (!v60)
        goto LABEL_44;
    }
    else
    {
      v21 = v61;
      if (!v61)
        goto LABEL_44;
    }
    if (v21 < 0x41)
    {
      std::string::basic_string[abi:ne180100]<0>(v57, "desc");
      __p = 0;
      v55 = 0;
      v56 = 0;
      SVGNode::findChildNodesWithName(*((_QWORD *)this + 6), (unsigned __int8 *)v57, &__p);
      v25 = (char *)__p;
      v26 = v55;
      if (__p != v55)
      {
        do
        {
          std::string::basic_string[abi:ne180100]<0>(&v69, (char *)&unk_20679A6BE);
          v27 = *(const char **)(*(_QWORD *)v25 + 192);
          if (v27)
          {
            if ((v27[23] & 0x80000000) == 0 || (v27 = *(const char **)v27) != 0)
              MEMORY[0x20BCFBFCC](&v69);
          }
          if (SHIBYTE(v71) < 0)
          {
            if (!v70)
            {
LABEL_100:
              SVGUtilities::error((SVGUtilities *)"\nSVG Tiny P/S profile requires that description node must not be empty", v27);
              if (SHIBYTE(v71) < 0)
                operator delete(v69);
              v6 = 0;
              goto LABEL_113;
            }
            operator delete(v69);
          }
          else if (!HIBYTE(v71))
          {
            goto LABEL_100;
          }
          v25 += 8;
        }
        while (v25 != v26);
      }
      std::string::basic_string[abi:ne180100]<0>(&v69, "image");
      std::string::basic_string[abi:ne180100]<0>(&v72, "switch");
      std::list<std::string>::list(v53, (uint64_t)&v69, 2);
      for (j = 0; j != -6; j -= 3)
      {
        if (SHIBYTE(v74[j]) < 0)
          operator delete(*(void **)((char *)&v72 + j * 8));
      }
      for (k = v53[1]; (uint64_t *)k != v53; k = *(_QWORD *)(k + 8))
      {
        v30 = (_QWORD *)(k + 16);
        if (SVGNode::hasChildNodeWithName(*((_QWORD *)this + 6), (unsigned __int8 *)(k + 16)))
        {
          if (*(char *)(k + 39) < 0)
            v30 = (_QWORD *)*v30;
          SVGUtilities::error((SVGUtilities *)"\nSVG Tiny P/S profile does not allow %s node", v31, v30);
          v6 = 0;
          goto LABEL_112;
        }
      }
      LODWORD(v69) = 107;
      std::string::basic_string[abi:ne180100]<0>(&v70, "disable");
      v73 = 108;
      std::string::basic_string[abi:ne180100]<0>(v74, "false");
      v75 = 109;
      std::string::basic_string[abi:ne180100]<0>(v76, "false");
      v77 = 110;
      std::string::basic_string[abi:ne180100]<0>(v78, "none");
      v79 = 111;
      std::string::basic_string[abi:ne180100]<0>(v80, "all");
      v81 = 112;
      std::string::basic_string[abi:ne180100]<0>(v82, "onLoad");
      v83 = 113;
      std::string::basic_string[abi:ne180100]<0>(v84, "none");
      std::map<SVGAtom::Name,std::string>::map[abi:ne180100]((uint64_t)&v51, (unsigned int *)&v69, 7);
      for (m = 0; m != -28; m -= 4)
      {
        if (SHIBYTE(v84[m + 2]) < 0)
          operator delete((void *)v84[m]);
      }
      v33 = v51;
      if (v51 == v52)
      {
LABEL_96:
        v69 = 0;
        v70 = 0;
        v71 = 0;
        SVGNode::findChildAttributesWithName(*((uint64_t **)this + 6), 18, (void **)&v69);
        SVGNode::findChildAttributesWithName(*((uint64_t **)this + 6), 57, (void **)&v69);
        v46 = v69;
        v47 = ((v70 - v69) >> 3) - 3;
        v6 = v47 < 0xFFFFFFFFFFFFFFFELL;
        if (v47 >= 0xFFFFFFFFFFFFFFFELL)
        {
          SVGUtilities::error((SVGUtilities *)"\nSVG Tiny P/S profile requires at least two colors in the document", v45);
          v46 = v69;
        }
        if (v46)
        {
          v70 = v46;
          operator delete(v46);
        }
      }
      else
      {
        while (1)
        {
          v69 = 0;
          v70 = 0;
          v71 = 0;
          SVGNode::findChildAttributesWithName(*((uint64_t **)this + 6), *((unsigned int *)v33 + 8), (void **)&v69);
          v34 = v69;
          v35 = v70;
          if (v69 != v70)
            break;
LABEL_88:
          if (v34)
          {
            v70 = v34;
            operator delete(v34);
          }
          v43 = v33[1];
          if (v43)
          {
            do
            {
              v44 = (char **)v43;
              v43 = *(char **)v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              v44 = (char **)v33[2];
              v18 = *v44 == (char *)v33;
              v33 = v44;
            }
            while (!v18);
          }
          v33 = v44;
          if (v44 == v52)
            goto LABEL_96;
        }
        v36 = (unsigned __int8 **)(v33 + 5);
        while (1)
        {
          v37 = (unsigned __int8 *)SVGAttribute::stringValue(*(SVGAttribute **)v34);
          v38 = v37[23];
          if ((v38 & 0x80u) == 0)
            v39 = (char *)v37[23];
          else
            v39 = (char *)*((_QWORD *)v37 + 1);
          v40 = (char *)*((unsigned __int8 *)v33 + 63);
          v41 = (char)v40;
          if ((char)v40 < 0)
            v40 = v33[6];
          if (v39 != v40)
            break;
          if (v41 >= 0)
            v42 = (unsigned __int8 *)(v33 + 5);
          else
            v42 = *v36;
          if ((v38 & 0x80) != 0)
          {
            if (memcmp(*(const void **)v37, v42, *((_QWORD *)v37 + 1)))
              break;
          }
          else if (v37[23])
          {
            while (*v37 == *v42)
            {
              ++v37;
              ++v42;
              if (!--v38)
                goto LABEL_86;
            }
            break;
          }
LABEL_86:
          v34 += 8;
          if (v34 == v35)
          {
            v34 = v69;
            goto LABEL_88;
          }
        }
        v48 = SVGAtom::ToString(*(_DWORD *)(*(_QWORD *)v34 + 48));
        if (*((char *)v33 + 63) < 0)
          v36 = (unsigned __int8 **)*v36;
        SVGUtilities::error((SVGUtilities *)"\nSVG Tiny P/S profile requires that if attribute : %s is present it needs to have the value: %s", v49, v48, v36);
        if (v69)
        {
          v70 = v69;
          operator delete(v69);
        }
        v6 = 0;
      }
      std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy((uint64_t)&v51, v52[0]);
LABEL_112:
      std::__list_imp<std::string>::clear(v53);
LABEL_113:
      if (__p)
      {
        v55 = (char *)__p;
        operator delete(__p);
      }
      if (v58 < 0)
        operator delete(v57[0]);
      goto LABEL_117;
    }
LABEL_44:
    SVGUtilities::error((SVGUtilities *)"\nSVG Tiny P/S profile requires a title string that is not empty and is no more than 64 characters in length", v20);
    v6 = 0;
LABEL_117:
    if ((char)v61 < 0)
      operator delete(v59);
    goto LABEL_119;
  }
  Length = CFDataGetLength(theData);
  SVGUtilities::error((SVGUtilities *)"File size for Tiny SVG P/S profile needs to be less that 32 kilobytes. File size for given file is: %zu bytes", v5, Length);
  return 0;
}

void sub_20678243C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,char a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  uint64_t v50;
  void *v52;

  std::__list_imp<std::string>::clear(&a15);
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  v52 = a33;
  if (a33)
  {
    *(_QWORD *)(v50 + 8) = a33;
    operator delete(v52);
  }
  if (a41 < 0)
    operator delete(*(void **)(v50 + 24));
  std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy((uint64_t)&a42, *(char **)(v50 + 56));
  _Unwind_Resume(a1);
}

__CFData *CreateCFDataWithContentsOfURL(CFURLRef fileURL)
{
  const __CFAllocator *v1;
  __CFReadStream *v2;
  __CFReadStream *v3;
  __CFData *Mutable;
  unsigned __int8 v5;
  CFIndex *v6;
  uint64_t v7;
  UInt8 *v8;
  CFIndex v9;
  uint64_t i;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  if (!fileURL)
    return 0;
  v1 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v2 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x24BDBD240], fileURL);
  if (!v2)
    return 0;
  v3 = v2;
  if (!CFReadStreamOpen(v2))
  {
    CFRelease(v3);
    return 0;
  }
  Mutable = CFDataCreateMutable(v1, 0);
  v6 = (CFIndex *)MEMORY[0x24BDB03C8];
  if ((v5 & 1) == 0
  {
    CreateCFDataWithContentsOfURL(__CFURL const*)::kBufferLength = *v6;
  }
  MEMORY[0x24BDAC7A8]();
  v8 = (UInt8 *)v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = CFReadStreamRead(v3, v8, *v6);
  if (v9 >= 1)
  {
    for (i = v9; i > 0; i = CFReadStreamRead(v3, v8, *v6))
      CFDataAppendBytes(Mutable, v8, i);
  }
  CFReadStreamClose(v3);
  CFRelease(v3);
  return Mutable;
}

BOOL SVGDocument::read(SVGDocument *this, CGDataProviderRef provider, SVGReaderOptions *a3)
{
  const __CFData *v5;
  _BOOL8 v6;

  v5 = CGDataProviderCopyData(provider);
  v6 = SVGDocument::read(this, v5, a3);
  if (v5)
    CFRelease(v5);
  return v6;
}

BOOL SVGDocument::write(uint64_t a1, const char *a2, uint64_t a3)
{
  _BOOL8 v5;
  char v6;
  _BYTE v8[48];

  SVGWriter::SVGWriter((uint64_t)v8, a3);
  v5 = SVGWriter::write((SVGWriter *)v8, *(SVGRootNode **)(a1 + 48), a2, *(const SVGStyle **)(a1 + 64));
  SVGPathCommand::TypeFromCharacter((SVGPathCommand *)v8, v6);
  return v5;
}

void sub_206782854(_Unwind_Exception *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  SVGPathCommand::TypeFromCharacter((SVGPathCommand *)&a9, a2);
  _Unwind_Resume(a1);
}

BOOL SVGDocument::write(uint64_t a1, __CFData *a2, uint64_t a3)
{
  _BOOL8 v5;
  char v6;
  _BYTE v8[48];

  SVGWriter::SVGWriter((uint64_t)v8, a3);
  v5 = SVGWriter::write((SVGWriter *)v8, *(SVGRootNode **)(a1 + 48), a2, *(const SVGStyle **)(a1 + 64));
  SVGPathCommand::TypeFromCharacter((SVGPathCommand *)v8, v6);
  return v5;
}

void sub_2067828C0(_Unwind_Exception *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  SVGPathCommand::TypeFromCharacter((SVGPathCommand *)&a9, a2);
  _Unwind_Resume(a1);
}

BOOL SVGDocument::write(uint64_t a1, const __CFURL *a2, uint64_t a3)
{
  _BOOL8 v5;
  char v6;
  _BYTE v8[48];

  SVGWriter::SVGWriter((uint64_t)v8, a3);
  v5 = SVGWriter::write((SVGWriter *)v8, *(SVGRootNode **)(a1 + 48), a2, *(const SVGStyle **)(a1 + 64));
  SVGPathCommand::TypeFromCharacter((SVGPathCommand *)v8, v6);
  return v5;
}

void sub_20678292C(_Unwind_Exception *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  SVGPathCommand::TypeFromCharacter((SVGPathCommand *)&a9, a2);
  _Unwind_Resume(a1);
}

SVGCanvas *SVGDocument::canvas(SVGDocument *this)
{
  SVGCanvas *v1;

  v1 = (SVGCanvas *)*((_QWORD *)this + 7);
  if (!v1)
  {
    v1 = (SVGCanvas *)operator new();
    SVGCanvas::SVGCanvas(v1, this);
    *((_QWORD *)this + 7) = v1;
  }
  return v1;
}

void sub_206782990(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C405E75A9C0);
  _Unwind_Resume(a1);
}

uint64_t SVGDocument::hasWideGamutContent(SVGDocument *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 40))(*((_QWORD *)this + 6));
}

uint64_t SVGDocument::hasMonochromeContent(SVGDocument *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 56))(*((_QWORD *)this + 6));
}

uint64_t SVGDocument::hasNodeWithName(uint64_t a1, unsigned __int8 *a2)
{
  return SVGNode::hasChildNodeWithName(*(_QWORD *)(a1 + 48), a2);
}

void SVGDocument::findNodesWithName(uint64_t a1, unsigned __int8 *a2, void **a3)
{
  SVGNode::findChildNodesWithName(*(_QWORD *)(a1 + 48), a2, a3);
}

void SVGDocument::findAttributesWithName(uint64_t a1, uint64_t a2, void **a3)
{
  SVGNode::findChildAttributesWithName(*(uint64_t **)(a1 + 48), a2, a3);
}

void std::__list_imp<std::string>::clear(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  if (a1[2])
  {
    v3 = *a1;
    v2 = a1[1];
    v4 = *(_QWORD **)v2;
    v4[1] = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    a1[2] = 0;
    while ((_QWORD *)v2 != a1)
    {
      v5 = *(_QWORD *)(v2 + 8);
      std::__list_imp<std::string>::__delete_node[abi:ne180100]<>((int)a1, (void **)v2);
      v2 = v5;
    }
  }
}

void std::__list_imp<std::string>::__delete_node[abi:ne180100]<>(int a1, void **__p)
{
  if (*((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

uint64_t *std::map<std::string,SVGAttributeMap *,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,SVGAttributeMap *>>>::map[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<std::string,SVGAttributeMap *,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,SVGAttributeMap *>>>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,SVGAttributeMap *>,std::__tree_node<std::__value_type<std::string,SVGAttributeMap *>,void *> *,long>>>(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_206782AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::string,SVGAttributeMap *,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,SVGAttributeMap *>>>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,SVGAttributeMap *>,std::__tree_node<std::__value_type<std::string,SVGAttributeMap *>,void *> *,long>>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,SVGAttributeMap *> const&>(v5, v6, (uint64_t)(v4 + 4), (uint64_t)(v4 + 4));
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t std::map<SVGAtom::Name,std::string>::map[abi:ne180100](uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 32 * a3;
    do
    {
      std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__emplace_hint_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name const,std::string> const&>((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_206782BB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__emplace_hint_unique_key_args<SVGAtom::Name,std::pair<SVGAtom::Name const,std::string> const&>(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__find_equal<SVGAtom::Name>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__construct_node<std::pair<SVGAtom::Name const,std::string> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__find_equal<SVGAtom::Name>(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  unsigned int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::__tree<std::__value_type<SVGAtom::Name,std::string>,std::__map_value_compare<SVGAtom::Name,std::__value_type<SVGAtom::Name,std::string>,std::less<SVGAtom::Name>,true>,std::allocator<std::__value_type<SVGAtom::Name,std::string>>>::__construct_node<std::pair<SVGAtom::Name const,std::string> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)(a3 + 8) = v5;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *(_DWORD *)a2;
  v7 = (std::string *)(v6 + 40);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 8);
    v7->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 24);
  }
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_206782E84(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<SVGAtom::Name,std::string>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<SVGAtom::Name,std::string>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 63) < 0)
      operator delete(__p[5]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t *std::list<std::string>::list(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  if (a3)
  {
    v5 = 24 * a3;
    do
    {
      v6 = std::__list_imp<std::string>::__create_node[abi:ne180100]<std::string const&>((uint64_t)a1, 0, 0, a2);
      v7 = *a1;
      *v6 = *a1;
      v6[1] = a1;
      *(_QWORD *)(v7 + 8) = v6;
      *a1 = (uint64_t)v6;
      ++a1[2];
      a2 += 24;
      v5 -= 24;
    }
    while (v5);
  }
  return a1;
}

void sub_206782F68(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__list_imp<std::string>::clear(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__list_imp<std::string>::__create_node[abi:ne180100]<std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  std::string *v8;

  v7 = operator new(0x28uLL);
  *v7 = a2;
  v7[1] = a3;
  v8 = (std::string *)(v7 + 2);
  if (*(char *)(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)a4;
    v7[4] = *(_QWORD *)(a4 + 16);
  }
  return v7;
}

void sub_206782FE0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CGSVGColorCreateWithRGBA@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(double *)a2 = a3;
  *(double *)(a2 + 8) = a4;
  *(double *)(a2 + 16) = a5;
  *(double *)(a2 + 24) = a6;
  *(_DWORD *)(a2 + 32) = result;
  return result;
}

void CGSVGColorCreateRGBA(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(double *)a1 = a2;
  *(double *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a4;
  *(double *)(a1 + 24) = a5;
}

void CGSVGColorCreateDisplayP3(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>)
{
  *(_QWORD *)(a1 + 32) = 1;
  *(double *)a1 = a2;
  *(double *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a4;
  *(double *)(a1 + 24) = a5;
}

BOOL CGSVGColorCreateFromCString@<W0>(_BOOL8 result@<X0>, uint64_t a2@<X8>)
{
  SVGColor *v3;
  SVGColor *v4;
  __int128 v5;
  _OWORD v6[2];
  int v7;

  if (result
    && (v3 = (SVGColor *)result,
        SVGColor::SVGColor((uint64_t)v6, 0, 0.0, 0.0, 0.0, 1.0),
        result = SVGColor::GetColorWithString(v3, (double *)v6, v4)))
  {
    *(_QWORD *)(a2 + 32) = 0;
    v5 = v6[1];
    *(_OWORD *)a2 = v6[0];
    *(_OWORD *)(a2 + 16) = v5;
    if (v7 == 15)
      *(_DWORD *)(a2 + 32) = 1;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0x3FF0000000000000;
    *(_QWORD *)(a2 + 32) = 0;
  }
  return result;
}

const __CFString *CGSVGColorCreateFromString@<X0>(const __CFString *result@<X0>, _QWORD *a2@<X8>)
{
  char buffer[128];
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    CFStringGetCString(result, buffer, 128, 0x8000100u);
    return (const __CFString *)CGSVGColorCreateFromCString((_BOOL8)buffer, (uint64_t)a2);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = 0x3FF0000000000000;
    a2[4] = 0;
  }
  return result;
}

CGColorRef CGSVGColorCreateCGColor(uint64_t a1)
{
  int v2;
  const __CFString **v3;
  const __CFString *v4;
  CGColorSpace *v5;
  __int128 v6;
  CGColorRef v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a1 + 32);
  if (v2)
  {
    if (v2 == 2)
    {
      v3 = (const __CFString **)MEMORY[0x24BDBF278];
    }
    else
    {
      if (v2 != 1)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v3 = (const __CFString **)MEMORY[0x24BDBF228];
    }
  }
  else
  {
    v3 = (const __CFString **)MEMORY[0x24BDBF318];
  }
  v4 = *v3;
LABEL_9:
  v5 = CGColorSpaceCreateWithName(v4);
  v6 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v6;
  v7 = CGColorCreate(v5, (const CGFloat *)v9);
  CGColorSpaceRelease(v5);
  return v7;
}

void CGSVGDrawState::CGSVGDrawState(CGSVGDrawState *this, const CGSVGDrawState *a2)
{
  char *v2;
  __int128 v3;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  *(_WORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *(_OWORD *)((char *)this + 8) = xmmword_206799E90;
  *((_QWORD *)this + 7) = 0;
  v2 = (char *)this + 56;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 48) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 72) = 0;
  v3 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x24BDBF090];
  *((_OWORD *)this + 6) = v3;
  *((_QWORD *)this + 14) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 120) = _Q0;
  *((_QWORD *)this + 17) = 0x3FF0000000000000;
  *((_BYTE *)this + 144) = 0;
  *((_QWORD *)this + 25) = 0;
  *(_OWORD *)((char *)this + 180) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  if (this == a2)
    CGSVGDrawState::CGSVGDrawState();
  v11 = (_OWORD *)((char *)this + 80);
  *(_WORD *)this = *(_WORD *)a2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  CGSVGDrawState::setFontFamily(this, *((CFTypeRef *)a2 + 25));
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  v12 = *((_OWORD *)a2 + 2);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_OWORD *)this + 2) = v12;
  v13 = *(_OWORD *)((char *)a2 + 56);
  *((_QWORD *)v2 + 2) = *((_QWORD *)a2 + 9);
  *(_OWORD *)v2 = v13;
  v14 = *((_OWORD *)a2 + 6);
  *v11 = *((_OWORD *)a2 + 5);
  v11[1] = v14;
  *((_QWORD *)this + 14) = *((_QWORD *)a2 + 14);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  *((_QWORD *)this + 17) = *((_QWORD *)a2 + 17);
  *((_BYTE *)this + 144) = *((_BYTE *)a2 + 144);
  *((_QWORD *)this + 19) = *((_QWORD *)a2 + 19);
  v15 = *((_OWORD *)a2 + 10);
  v16 = *((_OWORD *)a2 + 11);
  *((_QWORD *)this + 24) = *((_QWORD *)a2 + 24);
  *((_OWORD *)this + 10) = v15;
  *((_OWORD *)this + 11) = v16;
}

_QWORD *CGSVGDrawState::setFontFamily(_QWORD *this, CFTypeRef cf)
{
  _QWORD *v3;
  const void *v4;

  if (cf)
  {
    v3 = this;
    v4 = (const void *)this[25];
    if (v4)
    {
      CFRelease(v4);
      v3[25] = 0;
    }
    this = CFRetain(cf);
    v3[25] = this;
  }
  return this;
}

void CGSVGDrawState::~CGSVGDrawState(CGSVGDrawState *this)
{
  const void *v1;

  v1 = (const void *)*((_QWORD *)this + 25);
  if (v1)
    CFRelease(v1);
}

void CGContextDrawSVGDocument(CGContext *a1, const char *a2)
{
  const char *RootNode;

  RootNode = (const char *)CGSVGDocumentGetRootNode((uint64_t)a2, a2);
  CGContextDrawSVGNodeWithOptions(a1, RootNode, 0);
}

void CGContextDrawSVGDocumentWithOptions(CGContext *a1, const char *a2, const __CFDictionary *a3)
{
  const char *RootNode;

  RootNode = (const char *)CGSVGDocumentGetRootNode((uint64_t)a2, a2);
  CGContextDrawSVGNodeWithOptions(a1, RootNode, a3);
}

void CGContextDrawSVGNodeWithOptions(CGContext *a1, const char *a2, const __CFDictionary *a3)
{
  _QWORD *v6;
  const char *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  double v12;
  double v13;
  __int128 v14;
  SVGAttributeMap *Value;
  const void *v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  _BOOL4 v25;
  unint64_t i;
  uint64_t v27;
  CGAffineTransform v28;
  void **v29;
  __int128 v30;
  void *v31;
  CGContext **v32;
  const __CFDictionary *v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  char v43;
  __int128 v44;
  _BYTE v45[28];
  uint64_t v46;
  CGContext *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  char *v51;
  char *v52;
  uint64_t v53;

  v6 = CFRetained::getObject<SVGNode>((uint64_t)a2, a2);
  if (a1)
  {
    v8 = v6;
    if (v6)
    {
      v51 = 0;
      v52 = 0;
      v53 = 0;
      while (1)
      {
        v9 = v8[6];
        if (!v9)
          break;
        v8 = (_QWORD *)v8[6];
        v29 = *(void ***)(v9 + 40);
        std::vector<CGSVGNode *>::insert((uint64_t)&v51, v51, &v29);
      }
      v10 = v8[5];
      if (a3 && CFDictionaryGetValue(a3, CFSTR("drawingDefinition")))
      {
        v11 = 0;
      }
      else
      {
        GetCanvasSize(v10, v7);
        v13 = v12;
        CGContextSaveGState(a1);
        CGContextScaleCTM(a1, 1.0, -1.0);
        CGContextTranslateCTM(a1, 0.0, -v13);
        v11 = 1;
      }
      v50 = 0u;
      v49 = 0u;
      v48 = 0u;
      v47 = a1;
      LOWORD(v29) = 0;
      HIDWORD(v29) = 0;
      v30 = xmmword_206799E90;
      v32 = 0;
      v33 = 0;
      v31 = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v37 = 0;
      v14 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
      v38 = *MEMORY[0x24BDBF090];
      v39 = v14;
      __asm { FMOV            V1.2D, #1.0 }
      v41 = _Q1;
      v40 = 0;
      v42 = 0x3FF0000000000000;
      v43 = 0;
      v46 = 0;
      memset(v45, 0, sizeof(v45));
      v44 = 0u;
      *(_QWORD *)&v50 = std::vector<CGSVGDrawState>::__push_back_slow_path<CGSVGDrawState>((uint64_t *)&v49 + 1, (const CGSVGDrawState *)&v29);
      CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)&v29);
      *(_QWORD *)&v48 = a2;
      if (a3)
      {
        *((_QWORD *)&v48 + 1) = CFDictionaryGetValue(a3, CFSTR("willDraw"));
        Value = (SVGAttributeMap *)CFDictionaryGetValue(a3, CFSTR("didDraw"));
        *(_QWORD *)&v49 = Value;
      }
      v21 = (const void *)CGSVGAttributeMapCreateWithDefaults(Value);
      ApplyCGSVGAttributes((uint64_t)&v47, (uint64_t)v21, 0);
      CGSVGAttributeMapRelease(v21);
      memset(&v28, 0, sizeof(v28));
      CGContextGetCTM(&v28, a1);
      v22 = v51;
      v23 = (v52 - v51) >> 3;
      if ((int)v23 >= 1)
      {
        v24 = 0;
        do
        {
          if (v23 <= v24)
            std::vector<double>::__throw_out_of_range[abi:ne180100]();
          PushSVGNodeAttributes((uint64_t)&v47, *(_QWORD *)&v22[8 * v24++]);
          v22 = v51;
          v23 = (v52 - v51) >> 3;
        }
        while ((uint64_t)v24 < (int)((unint64_t)(v52 - v51) >> 3));
      }
      if (a3)
        v25 = CFDictionaryGetValue(a3, CFSTR("removeAncestorTransforms")) == (const void *)*MEMORY[0x24BDBD268];
      else
        v25 = 0;
      if (((v11 | v25) & 1) == 0)
        CGContextSetCTM();
      v29 = (void **)MEMORY[0x24BDAC760];
      *(_QWORD *)&v30 = 0x40000000;
      *((_QWORD *)&v30 + 1) = ___ZL11DrawSVGNodeP21CGSVGDrawStateContextP9CGSVGNodePK14__CFDictionary_block_invoke;
      v31 = &__block_descriptor_tmp_12;
      v32 = &v47;
      v33 = a3;
      CGSVGNodeEnumerate((uint64_t)a2, (const char *)&v29);
      for (i = ((unint64_t)(v52 - v51) >> 3) - 1; (int)i + 1 > 0; --i)
      {
        if (i >= (v52 - v51) >> 3)
          std::vector<double>::__throw_out_of_range[abi:ne180100]();
        v27 = *(_QWORD *)&v51[8 * i];
        PopSVGNodeAttributes((uint64_t)&v47, v27);
      }
      CGContextRestoreGState(a1);
      v29 = (void **)&v49 + 1;
      std::vector<CGSVGDrawState>::__destroy_vector::operator()[abi:ne180100](&v29);
      if (v51)
      {
        v52 = v51;
        operator delete(v51);
      }
    }
  }
}

void sub_206783754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;
  void *v23;

  v23 = *(void **)(v21 - 104);
  if (v23)
  {
    *(_QWORD *)(v21 - 96) = v23;
    operator delete(v23);
  }
  _Unwind_Resume(exception_object);
}

void CGContextDrawSVGNode(CGContext *a1, const char *a2)
{
  CGContextDrawSVGNodeWithOptions(a1, a2, 0);
}

char *std::vector<CGSVGNode *>::insert(uint64_t a1, char *__src, _QWORD *a3)
{
  char *v4;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  _BYTE *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  void *__p;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;

  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  v7 = a1 + 16;
  v8 = v9;
  if ((unint64_t)v6 >= v9)
  {
    v14 = *(_BYTE **)a1;
    v15 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v15 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v16 = (__src - v14) >> 3;
    v17 = v8 - (_QWORD)v14;
    if (v17 >> 2 > v15)
      v15 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v15;
    v25 = v7;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v18);
    else
      v19 = 0;
    __p = v19;
    v22 = &v19[8 * v16];
    v23 = v22;
    v24 = &v19[8 * v18];
    std::__split_buffer<CGSVGNode *>::push_back(&__p, a3);
    v4 = std::vector<CGSVGNode *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v23 != v22)
      v23 += (v22 - v23 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v10 = __src + 8;
    v11 = v6 - 8;
    v12 = v6;
    while (v11 < v6)
    {
      v13 = *(_QWORD *)v11;
      v11 += 8;
      *(_QWORD *)v12 = v13;
      v12 += 8;
    }
    *(_QWORD *)(a1 + 8) = v12;
    if (v6 != v10)
      memmove(&v6[-8 * ((v6 - v10) >> 3)], __src, v6 - v10);
    *(_QWORD *)v4 = *a3;
  }
  return v4;
}

void sub_206783928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double GetCanvasSize(uint64_t a1, const char *a2)
{
  const char *v3;
  double v4;
  const char *v5;
  double result;
  double v7;

  if (CGSVGNodeGetType(a1, a2))
  {
    CGSVGNodeGetBoundingBox(a1);
    return v4;
  }
  result = CGSVGViewBoxNodeGetSize(a1, v3);
  if (result < 1.0 || v7 < 1.0)
  {
    CGSVGViewBoxNodeGetViewbox(a1, v5);
    return v4;
  }
  return result;
}

void ApplyCGSVGAttributes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CGContext *v6;
  uint64_t Attribute;
  SVGUtilities *Float;
  uint64_t v9;
  SVGUtilities *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  size_t FloatCount;
  size_t v15;
  char *v16;
  uint64_t v17;
  CGFloat v18;
  const char *v19;
  _QWORD *v20;
  _QWORD v21[8];
  double v22;
  double *v23;
  uint64_t v24;
  char v25;

  v6 = *(CGContext **)a1;
  Attribute = CGSVGAttributeMapGetAttribute(a2, (const char *)0x13);
  if (Attribute)
  {
    v22 = 1.0;
    Float = (SVGUtilities *)CGSVGAttributeGetFloat(Attribute, (char *)&v22);
    if ((_DWORD)Float)
      *(double *)(*(_QWORD *)(a1 + 40) - 88) = SVGUtilities::CGFloatClamp(Float, v22, 0.0, 1.0)
                                               * *(double *)(*(_QWORD *)(a1 + 40) - 88);
  }
  v9 = CGSVGAttributeMapGetAttribute(a2, (const char *)0x3A);
  if (v9)
  {
    v22 = 1.0;
    v10 = (SVGUtilities *)CGSVGAttributeGetFloat(v9, (char *)&v22);
    if ((_DWORD)v10)
      *(double *)(*(_QWORD *)(a1 + 40) - 80) = SVGUtilities::CGFloatClamp(v10, v22, 0.0, 1.0)
                                               * *(double *)(*(_QWORD *)(a1 + 40) - 80);
  }
  v11 = CGSVGAttributeMapGetAttribute(a2, (const char *)0xC);
  if (v11)
  {
    v13 = v11;
    FloatCount = (size_t)CGSVGAttributeGetFloatCount(v11, v12);
    if (FloatCount)
    {
      v15 = FloatCount;
      v16 = (char *)malloc_type_malloc(8 * FloatCount, 0x100004000313F17uLL);
      CGSVGAttributeGetFloats(v13, v16);
      v22 = 0.0;
      v17 = CGSVGAttributeMapGetAttribute(a2, (const char *)0xD);
      if (v17)
      {
        CGSVGAttributeGetFloat(v17, (char *)&v22);
        v18 = v22;
      }
      else
      {
        v18 = 0.0;
      }
      CGContextSetLineDash(*(CGContextRef *)a1, v18, (const CGFloat *)v16, v15);
      free(v16);
    }
  }
  v22 = 0.0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0;
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 0x40000000;
  v21[2] = ___ZL20ApplyCGSVGAttributesP21CGSVGDrawStateContextP17CGSVGAttributeMapP9CGSVGNode_block_invoke;
  v21[3] = &unk_24BFD91A8;
  v21[6] = a1;
  v21[7] = a3;
  v21[4] = &v22;
  v21[5] = v6;
  CGSVGAttributeMapEnumerate(a2, (const char *)v21);
  if (*((_BYTE *)v23 + 24))
  {
    if (a3)
    {
      v20 = (_QWORD *)(a1 + 40);
      if (CGSVGNodeGetType(a3, v19) == 2 && (!*(_BYTE *)(*v20 - 208) || !*(_BYTE *)(*v20 - 207)))
        goto LABEL_21;
    }
    else
    {
      v20 = (_QWORD *)(a1 + 40);
    }
    CGContextBeginTransparencyLayer(v6, 0);
    *(_BYTE *)(*v20 - 64) = 1;
  }
LABEL_21:
  _Block_object_dispose(&v22, 8);
}

void sub_206783BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void PushSVGNodeAttributes(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  const char *v5;
  uint64_t v6;
  _QWORD *AttributeMap;
  _BYTE v8[208];

  CGContextSaveGState(*(CGContextRef *)a1);
  CGSVGDrawState::CGSVGDrawState((CGSVGDrawState *)v8, (const CGSVGDrawState *)(*(_QWORD *)(a1 + 40) - 208));
  v8[144] = 0;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4 >= *(_QWORD *)(a1 + 48))
  {
    v6 = std::vector<CGSVGDrawState>::__push_back_slow_path<CGSVGDrawState const&>((uint64_t *)(a1 + 32), (const CGSVGDrawState *)v8);
  }
  else
  {
    CGSVGDrawState::CGSVGDrawState(*(CGSVGDrawState **)(a1 + 40), (const CGSVGDrawState *)v8);
    v6 = v4 + 208;
    *(_QWORD *)(a1 + 40) = v4 + 208;
  }
  *(_QWORD *)(a1 + 40) = v6;
  AttributeMap = CGSVGNodeGetAttributeMap(a2, v5);
  ApplyCGSVGAttributes(a1, (uint64_t)AttributeMap, a2);
  CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)v8);
}

void sub_206783C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)&a9);
  _Unwind_Resume(a1);
}

void PopSVGNodeAttributes(uint64_t a1, uint64_t a2)
{
  CGContext *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *AttributeMap;
  const char *v8;
  char *v9;
  const char *v10;
  const char *v11;
  _QWORD *v12;
  uint64_t Attribute;
  const char *v14;
  SVGFilter *v15;
  CGContext *v16;
  double BoundingBoxWithOptions;
  double v18;
  CGFloat v19;
  double v20;
  CGFloat v21;
  double v22;
  CGFloat v23;
  CGFloat v24;
  CGFloat v25;
  CGFloat v26;
  _BYTE v27[208];
  uint64_t v28;
  CGRect v29;
  CGRect v30;

  v4 = *(CGContext **)a1;
  CGSVGDrawState::CGSVGDrawState((CGSVGDrawState *)v27, (const CGSVGDrawState *)(*(_QWORD *)(a1 + 40) - 208));
  CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)(*(_QWORD *)(a1 + 40) - 208));
  *(_QWORD *)(a1 + 40) = v6;
  if (v27[144])
    CGContextEndTransparencyLayer(v4);
  AttributeMap = CGSVGNodeGetAttributeMap(a2, v5);
  if (CGSVGAttributeMapGetAttribute((uint64_t)AttributeMap, (const char *)0x54))
  {
    v9 = (char *)CFRetained::getObject<SVGNode>(a2, v8);
    v10 = v9 + 64;
    if (v9[87] < 0)
      v10 = *(const char **)v10;
    if (strcmp("g", v10))
    {
      v28 = 0;
      v12 = CGSVGNodeGetAttributeMap(a2, v11);
      Attribute = CGSVGAttributeMapGetAttribute((uint64_t)v12, (const char *)0x54);
      if (Attribute)
      {
        if (CGSVGAttributeGetFilter(Attribute, (char *)&v28))
        {
          v15 = (SVGFilter *)CFRetained::getObject<SVGFilter>(v28, v14);
          v16 = *(CGContext **)a1;
          BoundingBoxWithOptions = CGSVGNodeGetBoundingBoxWithOptions(a2, 0, 0);
          v19 = v18;
          v21 = v20;
          v23 = v22;
          v30.origin.x = CGSVGNodeGetBoundingBoxWithOptions(a2, 0, 3);
          v30.origin.y = v24;
          v30.size.width = v25;
          v30.size.height = v26;
          v29.origin.x = BoundingBoxWithOptions;
          v29.origin.y = v19;
          v29.size.width = v21;
          v29.size.height = v23;
          SVGFilter::draw(v15, v16, (const SVGNode *)v9, v29, v30);
        }
      }
    }
  }
  CGContextRestoreGState(v4);
  CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)v27);
}

void sub_206783E10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)va);
  _Unwind_Resume(a1);
}

void ___ZL20ApplyCGSVGAttributesP21CGSVGDrawStateContextP17CGSVGAttributeMapP9CGSVGNode_block_invoke(uint64_t a1, const char *a2, uint64_t a3)
{
  CGLineCap v5;
  const __CFString *v6;
  const __CFString *v7;
  uint64_t v8;
  CGFloat a;
  int v10;
  CGContext *v11;
  const char *v12;
  CGContext **v13;
  uint64_t v14;
  CGContext *v15;
  SVGClipPath *v16;
  const char *v17;
  SVGNode *v18;
  const CGPath *CGClippingPath;
  const __CFString *v20;
  const char *v21;
  CFStringRef v22;
  CGLineJoin v23;
  SVGUtilities *Float;
  double v25;
  uint64_t v26;
  CGFloat v27;
  const char *v28;
  CGContext **v29;
  uint64_t v30;
  CGContext *v31;
  char *v32;
  const char *v33;
  SVGNode *v34;
  CGImage *Mask;
  const char *v36;
  const char *v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  _OWORD *v45;
  int v46;
  uint64_t v47;
  __int128 v48;
  _OWORD v49[2];
  uint64_t v50;
  _OWORD v51[2];
  uint64_t v52;
  uint64_t v53;
  CGAffineTransform transform;
  CGAffineTransform v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  if ((int)a2 <= 33)
  {
    switch((int)a2)
    {
      case 18:
        v6 = CGSVGAttributeCopyString(a3, a2);
        v7 = v6;
        if (v6 && CFStringCompare(v6, CFSTR("currentColor"), 0) == kCFCompareEqualTo)
        {
          v41 = *(_QWORD *)(a1 + 48);
          v42 = *(_QWORD *)(a1 + 56);
          v43 = *(_QWORD *)(v41 + 40);
          v44 = *(_OWORD *)(v43 - 32);
          v49[0] = *(_OWORD *)(v43 - 48);
          v49[1] = v44;
          v50 = *(_QWORD *)(v43 - 16);
          v45 = v49;
          v46 = 0;
LABEL_63:
          ApplyCGSVGCurrentColor(v41, (uint64_t)v45, v46, v42);
        }
        else
        {
          v55.a = 0.0;
          if (CGSVGAttributeGetPaint(a3, (char *)&v55))
          {
            v8 = *(_QWORD *)(a1 + 48);
            a = v55.a;
            v10 = 0;
LABEL_32:
            ApplyCGSVGPaint(v8, *(const char **)&a, v10);
          }
LABEL_33:
          if (!v7)
            return;
        }
        CFRelease(v7);
        return;
      case 19:
      case 21:
      case 22:
        return;
      case 20:
        LODWORD(v55.a) = 0;
        if (CGSVGAttributeGetAtom(a3, (char *)&v55))
        {
          if (LODWORD(v55.a) == 39)
          {
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) - 204) = 0;
          }
          else if (LODWORD(v55.a) == 17)
          {
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) - 204) = 1;
          }
          else
          {
            SVGUtilities::log((SVGUtilities *)"Error: Given fill-rule was undefined\n", v21);
          }
        }
        return;
      case 23:
        v22 = CGSVGAttributeCopyString(a3, a2);
        CGSVGDrawState::setFontFamily((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) - 208), v22);
        CFRelease(v22);
        return;
      case 24:
        v55.a = 16.0;
        if (CGSVGAttributeGetFloat(a3, (char *)&v55))
          *(CGFloat *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) - 200) = v55.a;
        return;
      case 25:
        v55.a = 0.0;
        if (CGSVGAttributeGetFloat(a3, (char *)&v55))
          *(CGFloat *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) - 192) = v55.a;
        return;
      default:
        if ((_DWORD)a2 == 6)
        {
          v55.a = 0.0;
          if (CGSVGAttributeGetClipPath(a3, (char *)&v55))
          {
            v13 = *(CGContext ***)(a1 + 48);
            v14 = *(_QWORD *)(a1 + 56);
            v15 = *v13;
            v16 = (SVGClipPath *)CFRetained::getObject<SVGClipPath>(*(uint64_t *)&v55.a, v12);
            v18 = (SVGNode *)CFRetained::getObject<SVGNode>(v14, v17);
            CGClippingPath = SVGClipPath::getCGClippingPath(v16, v18);
            CGContextAddPath(v15, CGClippingPath);
            CGContextClip(v15);
          }
        }
        return;
    }
  }
  if ((int)a2 > 58)
  {
    if ((int)a2 <= 73)
    {
      if ((_DWORD)a2 == 59)
      {
        v55.a = 0.0;
        if (CGSVGAttributeGetFloat(a3, (char *)&v55))
          CGContextSetLineWidth(*(CGContextRef *)(a1 + 40), v55.a);
      }
      else if ((_DWORD)a2 == 63 && CGSVGAttributeGetFloatCount(a3, a2) == (void *)6)
      {
        CGSVGAttributeGetFloats(a3, (char *)&v55);
        v11 = *(CGContext **)(a1 + 40);
        transform = v55;
        CGContextConcatCTM(v11, &transform);
      }
    }
    else
    {
      switch((_DWORD)a2)
      {
        case 0x4A:
          v55.a = 0.0;
          if (CGSVGAttributeGetMask(a3, (char *)&v55))
          {
            v29 = *(CGContext ***)(a1 + 48);
            v30 = *(_QWORD *)(a1 + 56);
            v31 = *v29;
            v32 = (char *)CFRetained::getObject<SVGMask>(*(uint64_t *)&v55.a, v28);
            v34 = (SVGNode *)CFRetained::getObject<SVGNode>(v30, v33);
            Mask = (CGImage *)SVGMask::createMask((SVGMask *)v32, v34);
            CGContextClipToMask(v31, *(CGRect *)(v32 + 240), Mask);
            CGImageRelease(Mask);
          }
          break;
        case 0x9E:
          v53 = 0;
          if (CGSVGAttributeGetPaint(a3, (char *)&v53) && CGSVGPaintGetType(v53, v36) == 1)
          {
            CGSVGPaintGetColor(v53, v37, (uint64_t)&v55);
            v38 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40);
            v39 = *(_OWORD *)&v55.a;
            v40 = *(_OWORD *)&v55.c;
            *(CGFloat *)(v38 - 16) = v55.tx;
            *(_OWORD *)(v38 - 48) = v39;
            *(_OWORD *)(v38 - 32) = v40;
          }
          break;
        case 0x2710:
          v55.a = 0.0;
          if (CGSVGAttributeGetFloat(a3, (char *)&v55))
            *(CGFloat *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) - 184) = v55.a;
          break;
      }
    }
  }
  else
  {
    switch((int)a2)
    {
      case '"':
        LODWORD(v55.a) = 0;
        if (!CGSVGAttributeGetAtom(a3, (char *)&v55))
          return;
        switch(LODWORD(v55.a))
        {
          case 2:
            v5 = kCGLineCapButt;
            break;
          case 0x36:
            v5 = kCGLineCapSquare;
            break;
          case 0x32:
            v5 = kCGLineCapRound;
            break;
          default:
            return;
        }
        CGContextSetLineCap(*(CGContextRef *)(a1 + 40), v5);
        break;
      case '#':
        LODWORD(v55.a) = 0;
        if (!CGSVGAttributeGetAtom(a3, (char *)&v55))
          return;
        switch(LODWORD(v55.a))
        {
          case 1:
            v23 = kCGLineJoinBevel;
            break;
          case 0x25:
            v23 = kCGLineJoinMiter;
            break;
          case 0x32:
            v23 = kCGLineJoinRound;
            break;
          default:
            return;
        }
        CGContextSetLineJoin(*(CGContextRef *)(a1 + 40), v23);
        break;
      case '$':
      case '%':
      case '\'':
      case '(':
        return;
      case '&':
        v55.a = 0.0;
        if (CGSVGAttributeGetFloat(a3, (char *)&v55))
          CGContextSetMiterLimit(*(CGContextRef *)(a1 + 40), v55.a);
        break;
      case ')':
        v55.a = 1.0;
        Float = (SVGUtilities *)CGSVGAttributeGetFloat(a3, (char *)&v55);
        if ((_DWORD)Float)
        {
          v25 = SVGUtilities::CGFloatClamp(Float, v55.a, 0.0, 1.0);
          v55.a = v25;
          if (v25 < 1.0)
          {
            v26 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40);
            v27 = v25 * *(double *)(v26 - 72);
            *(CGFloat *)(v26 - 72) = v27;
            v55.a = v27;
            CGContextSetAlpha(*(CGContextRef *)(a1 + 40), v27);
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
          }
        }
        break;
      default:
        if ((_DWORD)a2 == 57)
        {
          v20 = CGSVGAttributeCopyString(a3, a2);
          v7 = v20;
          if (v20 && CFStringCompare(v20, CFSTR("currentColor"), 0) == kCFCompareEqualTo)
          {
            v41 = *(_QWORD *)(a1 + 48);
            v42 = *(_QWORD *)(a1 + 56);
            v47 = *(_QWORD *)(v41 + 40);
            v48 = *(_OWORD *)(v47 - 32);
            v51[0] = *(_OWORD *)(v47 - 48);
            v51[1] = v48;
            v52 = *(_QWORD *)(v47 - 16);
            v45 = v51;
            v46 = 1;
            goto LABEL_63;
          }
          v55.a = 0.0;
          if (!CGSVGAttributeGetPaint(a3, (char *)&v55))
            goto LABEL_33;
          v8 = *(_QWORD *)(a1 + 48);
          a = v55.a;
          v10 = 1;
          goto LABEL_32;
        }
        break;
    }
  }
}

void ApplyCGSVGCurrentColor(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  CGContext *v7;
  _QWORD *AttributeMap;
  uint64_t Attribute;
  const char *v10;
  const __CFString *v11;
  CGColor *CGColor;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _OWORD v17[2];
  uint64_t v18;
  _OWORD v19[2];
  uint64_t v20;
  _OWORD v21[2];
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v7 = *(CGContext **)a1;
  AttributeMap = CGSVGNodeGetAttributeMap(a4, (const char *)a2);
  Attribute = CGSVGAttributeMapGetAttribute((uint64_t)AttributeMap, (const char *)0x9E);
  if (!Attribute)
  {
    if (a3 == 1)
      goto LABEL_6;
LABEL_9:
    *(double *)(a2 + 24) = *(double *)(*(_QWORD *)(a1 + 40) - 88) * *(double *)(a2 + 24);
    v18 = *(_QWORD *)(a2 + 32);
    v15 = *(_OWORD *)(a2 + 16);
    v17[0] = *(_OWORD *)a2;
    v17[1] = v15;
    CGColor = CGSVGColorCreateCGColor((uint64_t)v17);
    goto LABEL_10;
  }
  v11 = CGSVGAttributeCopyString(Attribute, v10);
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  CGSVGColorCreateFromString(v11, &v23);
  v21[0] = v23;
  v21[1] = v24;
  v22 = v25;
  CGColor = CGSVGColorCreateCGColor((uint64_t)v21);
  CFRelease(v11);
  if (a3 == 1)
  {
    if (CGColor)
    {
LABEL_7:
      CGContextSetStrokeColorWithColor(v7, CGColor);
      CGColorRelease(CGColor);
      v14 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)(v14 - 152) = 0;
      *(_QWORD *)(v14 - 144) = 0;
      *(_BYTE *)(v14 - 208) = 1;
      return;
    }
LABEL_6:
    *(double *)(a2 + 24) = *(double *)(*(_QWORD *)(a1 + 40) - 80) * *(double *)(a2 + 24);
    v20 = *(_QWORD *)(a2 + 32);
    v13 = *(_OWORD *)(a2 + 16);
    v19[0] = *(_OWORD *)a2;
    v19[1] = v13;
    CGColor = CGSVGColorCreateCGColor((uint64_t)v19);
    goto LABEL_7;
  }
  if (!CGColor)
    goto LABEL_9;
LABEL_10:
  CGContextSetFillColorWithColor(v7, CGColor);
  CGColorRelease(CGColor);
  v16 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v16 - 176) = 0;
  *(_QWORD *)(v16 - 168) = 0;
  *(_BYTE *)(v16 - 207) = 1;
}

void ApplyCGSVGPaint(uint64_t a1, const char *a2, int a3)
{
  CGContext *v6;
  unsigned int Type;
  const char *v8;
  uint64_t v9;
  CGColor *CGColor;
  uint64_t v11;
  unsigned int v12;
  _QWORD *Gradient;
  const char *v14;
  _QWORD *Pattern;
  uint64_t Attribute;
  const char *v17;
  const __CFString *v18;
  BOOL v19;
  CGColor *v20;
  _OWORD v21[2];
  uint64_t v22;
  _OWORD v23[2];
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v6 = *(CGContext **)a1;
  Type = CGSVGPaintGetType((uint64_t)a2, a2);
  if (Type == 1)
  {
    v27 = 0;
    v25 = 0u;
    v26 = 0u;
    CGSVGPaintGetColor((uint64_t)a2, v8, (uint64_t)&v25);
    v9 = *(_QWORD *)(a1 + 40);
    if (a3 == 1)
    {
      *((double *)&v26 + 1) = *(double *)(v9 - 80) * *((double *)&v26 + 1);
      v24 = v27;
      v23[0] = v25;
      v23[1] = v26;
      CGColor = CGSVGColorCreateCGColor((uint64_t)v23);
      CGContextSetStrokeColorWithColor(v6, CGColor);
      CGColorRelease(CGColor);
      v11 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)(v11 - 152) = 0;
      *(_QWORD *)(v11 - 144) = 0;
LABEL_16:
      *(_BYTE *)(v11 - 208) = 1;
      return;
    }
    *((double *)&v26 + 1) = *(double *)(v9 - 88) * *((double *)&v26 + 1);
    v22 = v27;
    v21[0] = v25;
    v21[1] = v26;
    v20 = CGSVGColorCreateCGColor((uint64_t)v21);
    CGContextSetFillColorWithColor(v6, v20);
    CGColorRelease(v20);
    v11 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(v11 - 176) = 0;
    *(_QWORD *)(v11 - 168) = 0;
LABEL_18:
    *(_BYTE *)(v11 - 207) = 1;
    return;
  }
  v12 = Type;
  if ((Type & 0xFFFFFFFE) == 2)
  {
    Gradient = CGSVGPaintGetGradient((uint64_t)a2, v8);
    Pattern = CGSVGPaintGetPattern((uint64_t)a2, v14);
    if (v12 == 2)
    {
      Attribute = CGSVGNodeFindAttribute((uint64_t)Gradient, (const char *)0x1C);
      if (Attribute)
      {
        v18 = CGSVGAttributeCopyString(Attribute, v17);
        v19 = CFStringGetCharacterAtIndex(v18, 0) == 117;
        CFRelease(v18);
      }
      else
      {
        v19 = 0;
      }
    }
    else
    {
      v19 = 1;
    }
    v11 = *(_QWORD *)(a1 + 40);
    if (a3 == 1)
    {
      *(_QWORD *)(v11 - 152) = Gradient;
      *(_QWORD *)(v11 - 144) = Pattern;
      *(_BYTE *)(v11 - 136) = v19;
      goto LABEL_16;
    }
    *(_QWORD *)(v11 - 176) = Gradient;
    *(_QWORD *)(v11 - 168) = Pattern;
    *(_BYTE *)(v11 - 160) = v19;
    goto LABEL_18;
  }
  if (!Type)
  {
    if (a3 == 1)
    {
      CGContextSetRGBStrokeColor(v6, 0.0, 0.0, 0.0, 1.0);
      *(_BYTE *)(*(_QWORD *)(a1 + 40) - 208) = 0;
    }
    else
    {
      CGContextSetRGBFillColor(v6, 0.0, 0.0, 0.0, 1.0);
      *(_BYTE *)(*(_QWORD *)(a1 + 40) - 207) = 0;
    }
  }
}

void *CFRetained::getObject<SVGClipPath>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

uint64_t std::vector<CGSVGDrawState>::__push_back_slow_path<CGSVGDrawState const&>(uint64_t *a1, const CGSVGDrawState *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  CGSVGDrawState *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x4EC4EC4EC4EC4EC5 * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x13B13B13B13B13BLL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x4EC4EC4EC4EC4EC5 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x9D89D89D89D89DLL)
    v9 = 0x13B13B13B13B13BLL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGSVGDrawState>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (CGSVGDrawState *)&v10[208 * v4];
  v16 = &v10[208 * v9];
  CGSVGDrawState::CGSVGDrawState(v14, a2);
  v15 = (char *)v14 + 208;
  std::vector<CGSVGDrawState>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<CGSVGDrawState>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_20678486C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CGSVGDrawState>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CGSVGDrawState>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CGSVGDrawState>,std::reverse_iterator<CGSVGDrawState*>,std::reverse_iterator<CGSVGDrawState*>,std::reverse_iterator<CGSVGDrawState*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CGSVGDrawState>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x13B13B13B13B13CLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(208 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CGSVGDrawState>,std::reverse_iterator<CGSVGDrawState*>,std::reverse_iterator<CGSVGDrawState*>,std::reverse_iterator<CGSVGDrawState*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  CGSVGDrawState *v12;

  v10 = 0;
  v11 = a7 - 208;
  while (a3 + v10 != a5)
  {
    v12 = (CGSVGDrawState *)(v11 + v10);
    v10 -= 208;
    CGSVGDrawState::CGSVGDrawState(v12, (const CGSVGDrawState *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<CGSVGDrawState>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 208;
    CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)(i - 208));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void ___ZL11DrawSVGNodeP21CGSVGDrawStateContextP9CGSVGNodePK14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  const char *v5;
  _QWORD *v6;
  uint64_t v7;
  int Type;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v12;
  char v13;
  const char *v14;
  int Primitive;
  const char *v16;
  int v17;
  CGContext *v18;
  CGFloat v19;
  double v20;
  double v21;
  double v22;
  CGContext *v23;
  CGFloat v24;
  CGFloat v25;
  double v26;
  double v27;
  SVGShapeNode *FloatCount;
  SVGShapeNode *v29;
  void *v30;
  uint64_t v31;
  unint64_t v32;
  SVGShapeNode *Path;
  const char *v34;
  const CGPath *CGPath;
  CFStringRef v36;
  const char *v37;
  const __CFString *v38;
  _QWORD *AttributeMap;
  uint64_t Attribute;
  const char *v41;
  uint64_t v42;
  const char *v43;
  CGColorRef ColorForNode;
  CGColorRef v45;
  CGFloat v46;
  CGFloat v47;
  CGFloat b;
  __int128 v49;
  CGFloat v50;
  size_t v51;
  const char *v52;
  __CFDictionary *v53;
  CFStringRef v54;
  __CFDictionary *v55;
  CFNumberRef v56;
  const __CTFontDescriptor *v57;
  CTFontRef v58;
  CGFloat v59;
  CGFloat v60;
  const CGPath *v61;
  __CFDictionary *v62;
  uint64_t v63;
  double v64;
  double v65;
  CFNumberRef v66;
  CFNumberRef v67;
  uint64_t v68;
  const char *v69;
  const __CFString *v70;
  unint64_t width;
  CGPath *v72;
  const __CFArray *GlyphRuns;
  CFIndex v74;
  const __CTRun *ValueAtIndex;
  CFIndex GlyphCount;
  const CGGlyph *GlyphsPtr;
  CGFloat v78;
  const CGPoint *PositionsPtr;
  CGFloat v80;
  uint64_t v81;
  const CGPath *v82;
  int v83;
  _BOOL4 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  double v92;
  CGContext *v93;
  CGFloat v94;
  CGFloat v95;
  CGFloat v96;
  CGFloat v97;
  const char *v98;
  CFIndex NumberOfStops;
  __CFArray *Mutable;
  CGFloat *v101;
  const char *i;
  _QWORD *Stop;
  const char *v104;
  double Opacity;
  const char *v106;
  uint64_t v107;
  int v108;
  const char *v109;
  CGColorRef CGColor;
  CGGradient *v111;
  const char *v112;
  int v113;
  const char *v114;
  const char *v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  double v121;
  double v122;
  CGFloat v123;
  double v124;
  double v125;
  CGFloat v126;
  double v127;
  const char *v128;
  SVGPattern *v129;
  const char *v130;
  double v131;
  double v132;
  CGFloat v133;
  double v134;
  double v135;
  CGFloat v136;
  const char *v137;
  _QWORD *v138;
  uint64_t v139;
  const char *v140;
  CGContext **v141;
  double CanvasSize;
  double v143;
  double v144;
  const char *v145;
  double Viewbox;
  double v147;
  double v148;
  double v149;
  double v150;
  double v151;
  double v152;
  const char *v153;
  unsigned int AspectRatio;
  const char *v155;
  int AspectRatioMeetOrSlice;
  __int128 v157;
  double v158;
  double v159;
  BOOL v160;
  __int128 v161;
  const char *v162;
  __int128 v163;
  double v164;
  double v165;
  CGAffineTransform *p_m;
  CGAffineTransform *p_matrix;
  double a;
  double v169;
  __int128 v170;
  double v171;
  double v172;
  double v173;
  CGContext *v174;
  double Position;
  CGFloat v176;
  const char *v177;
  void *v178;
  const __CFAttributedString *attrString;
  const __CTLine *line;
  CGContext *v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  void *v188;
  CGColorRef v189;
  const __CFArray *v190;
  const __CFString *v191;
  CFIndex Count;
  const __CFAllocator *alloc;
  void *key;
  uint64_t v195;
  const __CFAllocator *allocator;
  CGContext *c;
  CGAffineTransform y[4];
  SVGUtilities *v200;
  CGFloat v201;
  CGAffineTransform x[4];
  CGFloat v203[2];
  __int128 v204;
  __int128 valuePtr;
  __int128 v206;
  CGAffineTransform v207;
  CGAffineTransform m;
  CGAffineTransform matrix;
  CFRange v210;
  CFRange v211;
  CGPoint v212;
  CGPoint v213;
  CGPoint v214;
  CGPoint v215;
  CGRect ImageBounds;
  CGRect v217;

  if (a3 == 1)
  {
    v138 = *(_QWORD **)(a1 + 32);
    v139 = v138[3];
    if (v139)
    {
      (*(void (**)(_QWORD, _QWORD, uint64_t))(v139 + 16))(v138[3], *v138, a2);
      v138 = *(_QWORD **)(a1 + 32);
    }
    PopSVGNodeAttributes((uint64_t)v138, a2);
    return;
  }
  if (a3)
    return;
  PushSVGNodeAttributes(*(_QWORD *)(a1 + 32), a2);
  v6 = *(_QWORD **)(a1 + 32);
  v7 = v6[2];
  if (v7)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(v7 + 16))(v7, *v6, a2);
  Type = CGSVGNodeGetType(a2, v5);
  if (!Type)
  {
    if (!DrawFilterNodeWithDefsOnly(a2, *(const char **)(a1 + 40)))
      return;
    v141 = *(CGContext ***)(a1 + 32);
    CanvasSize = GetCanvasSize(a2, v140);
    v144 = v143;
    Viewbox = CGSVGViewBoxNodeGetViewbox(a2, v145);
    v148 = v147;
    v150 = v149;
    v152 = v151;
    AspectRatio = CGSVGViewBoxNodeGetAspectRatio(a2, v153);
    AspectRatioMeetOrSlice = CGSVGViewBoxNodeGetAspectRatioMeetOrSlice(a2, v155);
    v157 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
    *(_OWORD *)&x[0].a = *MEMORY[0x24BDBD8B8];
    *(_OWORD *)&x[0].c = v157;
    *(_OWORD *)&x[0].tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
    if (v150 <= 0.0 || v152 <= 0.0)
    {
      v161 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
      *(_OWORD *)&y[0].a = *MEMORY[0x24BDBD8B8];
      *(_OWORD *)&y[0].c = v161;
      *(_OWORD *)&y[0].tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
      CGAffineTransformTranslate(x, y, -Viewbox, -v148);
LABEL_187:
      v174 = *v141;
      Position = CGSVGViewBoxNodeGetPosition(a2, v162);
      CGContextTranslateCTM(v174, Position, v176);
      v217.origin.x = 0.0;
      v217.origin.y = 0.0;
      v217.size.width = CanvasSize;
      v217.size.height = v144;
      CGContextClipToRect(v174, v217);
      matrix = x[0];
      CGContextConcatCTM(v174, &matrix);
      v178 = CFRetained::getObject<SVGViewBoxNode>(a2, v177);
      (*(void (**)(void *, CGContext *))(*(_QWORD *)v178 + 72))(v178, v174);
      return;
    }
    if (!AspectRatio)
    {
      v163 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
      *(_OWORD *)&y[0].a = *MEMORY[0x24BDBD8B8];
      *(_OWORD *)&y[0].c = v163;
      *(_OWORD *)&y[0].tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
      CGAffineTransformScale(x, y, CanvasSize / v150, v144 / v152);
      m = x[0];
      v164 = -Viewbox;
      v165 = -v148;
      p_m = &m;
LABEL_186:
      CGAffineTransformTranslate(&matrix, p_m, v164, v165);
      x[0] = matrix;
      goto LABEL_187;
    }
    v158 = CanvasSize / v150;
    v159 = v144 / v152;
    y[0].a = CanvasSize / v150;
    matrix.a = v144 / v152;
    if (AspectRatioMeetOrSlice)
      v160 = v158 < v159;
    else
      v160 = v159 < v158;
    p_matrix = y;
    if (v160)
      p_matrix = &matrix;
    a = p_matrix->a;
    v169 = v150 * p_matrix->a;
    v170 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
    *(_OWORD *)&y[0].a = *MEMORY[0x24BDBD8B8];
    *(_OWORD *)&y[0].c = v170;
    *(_OWORD *)&y[0].tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
    CGAffineTransformScale(x, y, a, a);
    m = x[0];
    CGAffineTransformTranslate(&matrix, &m, -Viewbox, -v148);
    x[0] = matrix;
    if (AspectRatio <= 8)
    {
      v171 = 0.0;
      if (((1 << AspectRatio) & 0x92) != 0)
      {
LABEL_181:
        v172 = 0.0;
        if (AspectRatio >= 4)
        {
          v173 = v152 * a;
          if (AspectRatio - 4 > 2)
            v172 = v144 - v173;
          else
            v172 = v144 * 0.5 - v173 * 0.5;
        }
        v207 = x[0];
        v164 = v171 / a;
        v165 = v172 / a;
        p_m = &v207;
        goto LABEL_186;
      }
      if (((1 << AspectRatio) & 0x124) != 0)
      {
        v171 = CanvasSize * 0.5 - v169 * 0.5;
        goto LABEL_181;
      }
    }
    v171 = CanvasSize - v169;
    goto LABEL_181;
  }
  if (Type == 2 && DrawFilterNodeWithDefsOnly(a2, *(const char **)(a1 + 40)))
  {
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(_QWORD *)(v9 + 40);
    v11 = 1;
    alloc = (const __CFAllocator *)*MEMORY[0x24BDBD260];
    key = (void *)*MEMORY[0x24BDC4D08];
    v188 = (void *)*MEMORY[0x24BDC4E80];
    v187 = (void *)*MEMORY[0x24BDC4DE0];
    v186 = (void *)*MEMORY[0x24BDC4C28];
    v182 = (void *)*MEMORY[0x24BDC4F38];
    v183 = (void *)*MEMORY[0x24BDC4EE0];
    v184 = (void *)*MEMORY[0x24BDC4F30];
    v185 = (void *)*MEMORY[0x24BDC4F08];
    v195 = v9;
    allocator = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    c = *(CGContext **)v9;
    while (1)
    {
      do
      {
        v12 = v11;
        v13 = v11 ^ 1;
        if (((v11 ^ 1) & 1) != 0)
          break;
        v11 = 0;
      }
      while (!*(_BYTE *)(v10 - 207));
      if (!(v12 & 1 | (*(_BYTE *)(v10 - 208) != 0)))
        return;
      CGContextBeginPath(c);
      Primitive = CGSVGShapeNodeGetPrimitive(a2, v14);
      v17 = Primitive;
      if (Primitive > 31)
        break;
      if (Primitive != 3)
      {
        if (Primitive != 16)
          goto LABEL_29;
        x[0].a = 0.0;
        y[0].a = 0.0;
        matrix.a = 0.0;
        m.a = 0.0;
        CGSVGShapeNodeGetEllipseGeometry(a2, (char *)x, y, &matrix, &m.a);
        v18 = c;
        if (matrix.a <= 0.0 || m.a <= 0.0)
          goto LABEL_125;
        v19 = x[0].a - matrix.a;
        v20 = y[0].a - m.a;
        v21 = matrix.a + matrix.a;
        v22 = m.a + m.a;
        v23 = c;
        goto LABEL_27;
      }
      x[0].a = 0.0;
      y[0].a = 0.0;
      matrix.a = 0.0;
      CGSVGShapeNodeGetCircleGeometry(a2, (char *)x, y, &matrix.a);
      v18 = c;
      if (matrix.a > 0.0)
      {
        v19 = x[0].a - matrix.a;
        v20 = y[0].a - matrix.a;
        v21 = matrix.a + matrix.a;
        v23 = c;
        v22 = matrix.a + matrix.a;
LABEL_27:
        CGContextAddEllipseInRect(v23, *(CGRect *)&v19);
      }
LABEL_125:
      v83 = *(_DWORD *)(v10 - 204);
      v84 = *(_OWORD *)(v10 - 152) != 0;
      if ((v12 & 1) != 0)
        v84 = *(_OWORD *)(v10 - 176) != 0;
      if (v84)
      {
        CGContextSaveGState(v18);
        if ((v12 & 1) == 0)
          CGContextReplacePathWithStrokedPath(v18);
        *(CGRect *)(v10 - 128) = CGContextGetPathBoundingBox(v18);
        if (v83)
        {
          if (v83 == 1)
            CGContextEOClip(v18);
        }
        else
        {
          CGContextClip(v18);
        }
        v85 = -80;
        if ((v12 & 1) != 0)
          v85 = -88;
        v86 = -136;
        if ((v12 & 1) != 0)
          v86 = -160;
        v87 = -144;
        if ((v12 & 1) != 0)
          v87 = -168;
        v88 = -152;
        if ((v12 & 1) != 0)
          v88 = -176;
        v89 = *(unsigned __int8 *)(v10 + v86);
        v90 = *(_QWORD *)(v10 + v88);
        v91 = *(_QWORD *)(v10 + v87);
        v92 = *(double *)(v10 + v85);
        v93 = *(CGContext **)v195;
        v94 = *(double *)(v10 - 128);
        v95 = *(double *)(v10 - 120);
        v96 = *(double *)(v10 - 112);
        v97 = *(double *)(v10 - 104);
        CGContextSaveGState(*(CGContextRef *)v195);
        if (v89)
        {
          if (!v90)
            goto LABEL_154;
        }
        else
        {
          CGContextTranslateCTM(v93, v94, v95);
          CGContextScaleCTM(v93, v96, v97);
          if (!v90)
          {
LABEL_154:
            v129 = (SVGPattern *)CFRetained::getObject<SVGPattern>(v91, v98);
            SVGPattern::drawCells(v129, v93, *(CGRect *)(v10 - 128), v92);
            goto LABEL_158;
          }
        }
        NumberOfStops = (CFIndex)CGSVGGradientGetNumberOfStops(v90, v98);
        Mutable = CFArrayCreateMutable(allocator, NumberOfStops, MEMORY[0x24BDBD690]);
        v101 = (CGFloat *)malloc_type_malloc(8 * NumberOfStops, 0x100004000313F17uLL);
        if (NumberOfStops)
        {
          for (i = 0; i != (const char *)NumberOfStops; ++i)
          {
            Stop = CGSVGGradientGetStop(v90, i);
            Opacity = CGSVGGradientStopGetOpacity((uint64_t)Stop, v104);
            CGSVGGradientStopGetOffset((uint64_t)Stop, v106);
            v101[(_QWORD)i] = CGSVGLengthScaledLength(v107, v108, 1.0);
            memset(x, 0, 40);
            CGSVGGradientStopGetColor((uint64_t)Stop, v109, (uint64_t)x);
            x[0].d = v92 * Opacity;
            matrix.tx = x[0].tx;
            *(_OWORD *)&matrix.a = *(_OWORD *)&x[0].a;
            *(_OWORD *)&matrix.c = *(_OWORD *)&x[0].c;
            CGColor = CGSVGColorCreateCGColor((uint64_t)&matrix);
            CFArrayAppendValue(Mutable, CGColor);
            CFRelease(CGColor);
          }
        }
        v111 = CGGradientCreateWithColors(0, Mutable, v101);
        free(v101);
        CFRelease(Mutable);
        v113 = CGSVGGradientGetType(v90, v112);
        memset(&m, 0, 32);
        if (v113)
        {
          CGSVGGradientGetCenter(v90, v114, &m);
          memset(&v207, 0, 32);
          CGSVGGradientGetFocal(v90, v115, &v207);
          CGSVGGradientGetRadius(v90, v116);
          v118 = v117;
          v120 = v119;
          valuePtr = *(_OWORD *)&m.a;
          v206 = *(_OWORD *)&m.c;
          v121 = CGSVGPointScaledPoint((uint64_t)&valuePtr, 1.0);
          v123 = v122;
          *(_OWORD *)v203 = *(_OWORD *)&v207.a;
          v204 = *(_OWORD *)&v207.c;
          v124 = CGSVGPointScaledPoint((uint64_t)v203, 1.0);
          v126 = v125;
          v127 = CGSVGLengthScaledLength(v118, v120, 1.0);
          memset(x, 0, 48);
          CGSVGGradientGetGradientTransform(v90, v128, x);
          y[0] = x[0];
          CGContextConcatCTM(v93, y);
          v212.x = v124;
          v212.y = v126;
          v215.x = v121;
          v215.y = v123;
          CGContextDrawRadialGradient(v93, v111, v212, 0.0, v215, v127, 3u);
        }
        else
        {
          CGSVGGradientGetStart(v90, v114, &m);
          memset(&v207, 0, 32);
          CGSVGGradientGetEnd(v90, v130, &v207);
          valuePtr = *(_OWORD *)&m.a;
          v206 = *(_OWORD *)&m.c;
          v131 = CGSVGPointScaledPoint((uint64_t)&valuePtr, 1.0);
          v133 = v132;
          *(_OWORD *)v203 = *(_OWORD *)&v207.a;
          v204 = *(_OWORD *)&v207.c;
          v134 = CGSVGPointScaledPoint((uint64_t)v203, 1.0);
          v136 = v135;
          memset(x, 0, 48);
          CGSVGGradientGetGradientTransform(v90, v137, x);
          y[0] = x[0];
          CGContextConcatCTM(v93, y);
          v213.x = v131;
          v213.y = v133;
          v214.x = v134;
          v214.y = v136;
          CGContextDrawLinearGradient(v93, v111, v213, v214, 3u);
        }
        v18 = c;
        CGGradientRelease(v111);
LABEL_158:
        CGContextRestoreGState(v93);
        CGContextRestoreGState(v18);
        if ((v12 & 1) == 0)
        {
          *(_QWORD *)(v10 - 152) = 0;
          *(_QWORD *)(v10 - 144) = 0;
          return;
        }
        v11 = 0;
        *(_QWORD *)(v10 - 176) = 0;
        *(_QWORD *)(v10 - 168) = 0;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          CGContextStrokePath(v18);
          return;
        }
        if (v83)
        {
          v11 = 0;
          if (v83 == 1)
          {
            CGContextEOFillPath(c);
            v11 = 0;
          }
        }
        else
        {
          CGContextFillPath(v18);
          v11 = 0;
        }
      }
    }
    if (Primitive == 32)
    {
      x[0].a = 0.0;
      y[0].a = 0.0;
      matrix.a = 0.0;
      m.a = 0.0;
      CGSVGShapeNodeGetLineGeometry(a2, (char *)x, y, &matrix, &m.a);
      v18 = c;
      CGContextMoveToPoint(c, x[0].a, y[0].a);
      CGContextAddLineToPoint(c, matrix.a, m.a);
      goto LABEL_125;
    }
    if (Primitive == 49)
    {
      x[0].a = 0.0;
      y[0].a = 0.0;
      matrix.a = 0.0;
      m.a = 0.0;
      v207.a = 0.0;
      *(_QWORD *)&valuePtr = 0;
      CGSVGShapeNodeGetRectGeometry(a2, (char *)x, y, &matrix, &m, &v207, (double *)&valuePtr);
      v24 = matrix.a;
      v18 = c;
      if (matrix.a <= 0.0)
        goto LABEL_125;
      v25 = m.a;
      if (m.a <= 0.0)
        goto LABEL_125;
      v26 = v207.a;
      v27 = *(double *)&valuePtr;
      if (v207.a > 0.0 || *(double *)&valuePtr > 0.0)
      {
        if (v207.a > 0.0)
        {
          if (*(double *)&valuePtr <= 0.0)
          {
            *(CGFloat *)&valuePtr = v207.a;
            v27 = v207.a;
          }
        }
        else
        {
          *(_QWORD *)&v207.a = valuePtr;
          v26 = *(double *)&valuePtr;
        }
      }
      else
      {
        *(_QWORD *)&valuePtr = 0;
        v207.a = 0.0;
        v27 = 0.0;
        v26 = 0.0;
      }
      if (v26 > matrix.a * 0.5)
      {
        v207.a = matrix.a * 0.5;
        v26 = matrix.a * 0.5;
      }
      if (v27 > m.a * 0.5)
      {
        *(double *)&valuePtr = m.a * 0.5;
        v27 = m.a * 0.5;
      }
      v59 = x[0].a;
      v60 = y[0].a;
      CGPath = CGPathCreateWithRoundedRect(*(CGRect *)(&v24 - 2), v26, v27, 0);
LABEL_85:
      v61 = CGPath;
      CGContextAddPath(v18, CGPath);
      CFRelease(v61);
      goto LABEL_125;
    }
LABEL_29:
    if ((Primitive & 0xFFFFFFFE) == 0x2C)
    {
      FloatCount = CGSVGShapeNodeGetFloatCount(a2, v16);
      v18 = c;
      if ((unint64_t)FloatCount >= 3)
      {
        v29 = FloatCount;
        v30 = malloc_type_malloc(8 * (_QWORD)FloatCount, 0x100004000313F17uLL);
        CGSVGShapeNodeGetFloats(a2, (char *)v30);
        CGContextMoveToPoint(c, *(CGFloat *)v30, *((CGFloat *)v30 + 1));
        v31 = 0;
        do
        {
          CGContextAddLineToPoint(c, *((CGFloat *)v30 + v31 + 2), *((CGFloat *)v30 + v31 + 3));
          v32 = v31 + 4;
          v31 += 2;
        }
        while (v32 < (unint64_t)v29);
        if (v17 == 44)
          CGContextClosePath(c);
        free(v30);
      }
      goto LABEL_125;
    }
    if (Primitive != 10001)
    {
      v18 = c;
      if (Primitive != 42)
        goto LABEL_125;
      Path = CGSVGShapeNodeGetPath(a2, v16);
      if (!Path)
        goto LABEL_125;
      CGPath = CGSVGPathCreateCGPath((uint64_t)Path, v34);
      if (!CGPath)
        goto LABEL_125;
      goto LABEL_85;
    }
    v36 = CGSVGShapeNodeCopyText(a2, v16);
    if (v36)
    {
      v38 = v36;
      AttributeMap = CGSVGNodeGetAttributeMap(a2, v37);
      CGSVGDrawState::CGSVGDrawState((CGSVGDrawState *)x, (const CGSVGDrawState *)(*(_QWORD *)(v195 + 40) - 208));
      v203[0] = 0.0;
      Attribute = CGSVGAttributeMapGetAttribute((uint64_t)AttributeMap, (const char *)0x43);
      if (Attribute && (CGSVGAttributeGetFloat(Attribute, (char *)v203) & 1) == 0)
        SVGUtilities::log((SVGUtilities *)"Text node x argument is unexpected type\n", v41);
      v201 = 0.0;
      v42 = CGSVGAttributeMapGetAttribute((uint64_t)AttributeMap, (const char *)0x46);
      if (v42 && (CGSVGAttributeGetFloat(v42, (char *)&v201) & 1) == 0)
        SVGUtilities::log((SVGUtilities *)"Text node y argument is unexpected type\n", v43);
      ColorForNode = CreateColorForNode(a2, (const char *)0x39);
      v45 = CreateColorForNode(a2, (const char *)0x12);
      CGSVGDrawState::CGSVGDrawState((CGSVGDrawState *)y, (const CGSVGDrawState *)x);
      *(double *)&valuePtr = y[0].c / 400.0 + -1.0;
      SVGUtilities::StringWithCFString((const __CFString *)v200, &matrix);
      v189 = v45;
      v191 = v38;
      if (matrix.c >= 0.0)
        v46 = COERCE_DOUBLE(&matrix);
      else
        v46 = matrix.a;
      memset(&m, 0, 24);
      SVGParser::GetComponentsSeparatedByDelimiters(*(const char **)&v46, ",", (uint64_t *)&m);
      v47 = m.a;
      b = m.b;
      while (*(_QWORD *)&v47 != *(_QWORD *)&b)
      {
        if (*(char *)(*(_QWORD *)&v47 + 23) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&v207, **(const std::string::value_type ***)&v47, *(_QWORD *)(*(_QWORD *)&v47 + 8));
        }
        else
        {
          v49 = **(_OWORD **)&v47;
          v207.c = *(CGFloat *)(*(_QWORD *)&v47 + 16);
          *(_OWORD *)&v207.a = v49;
        }
        if (v207.c >= 0.0)
          v50 = COERCE_DOUBLE(&v207);
        else
          v50 = v207.a;
        v51 = strlen(*(const char **)&v50);
        if (!strncasecmp(*(const char **)&v50, "monospace", v51))
        {
          v52 = "Courier";
        }
        else if (!strncasecmp(*(const char **)&v50, "serif", v51))
        {
          v52 = "Times";
        }
        else if (!strncasecmp(*(const char **)&v50, "sans-serif", v51))
        {
          v52 = "Helvetica";
        }
        else if (!strncasecmp(*(const char **)&v50, "cursive", v51))
        {
          v52 = "Apple Chancery";
        }
        else if (!strncasecmp(*(const char **)&v50, "fantasy", v51))
        {
          v52 = "Papyrus";
        }
        else
        {
          v52 = *(const char **)&v50;
        }
        v53 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        v54 = CFStringCreateWithCString(allocator, v52, 0x8000100u);
        CFDictionaryAddValue(v53, key, v54);
        CFRelease(v54);
        if (*(double *)&valuePtr != 0.0)
        {
          v55 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          v56 = CFNumberCreate(alloc, kCFNumberCGFloatType, &valuePtr);
          CFDictionaryAddValue(v55, v188, v56);
          CFRelease(v56);
          CFDictionaryAddValue(v53, v187, v55);
          CFRelease(v55);
        }
        v57 = CTFontDescriptorCreateWithAttributes(v53);
        CFRelease(v53);
        v58 = CTFontCreateWithFontDescriptor(v57, y[0].b, 0);
        CFRelease(v57);
        if (SHIBYTE(v207.c) < 0)
          operator delete(*(void **)&v207.a);
        if (v58)
          goto LABEL_87;
        *(_QWORD *)&v47 += 24;
      }
      v58 = 0;
LABEL_87:
      *(_QWORD *)&v207.a = &m;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v207);
      if (SHIBYTE(matrix.c) < 0)
        operator delete(*(void **)&matrix.a);
      CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)y);
      v62 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      CFDictionarySetValue(v62, v186, v58);
      CFRelease(v58);
      if (ColorForNode)
      {
        CFDictionarySetValue(v62, v184, ColorForNode);
        CFRelease(ColorForNode);
        matrix.a = 0.0;
        v63 = CGSVGNodeFindAttribute(a2, (const char *)0x3B);
        CGSVGAttributeGetFloat(v63, (char *)&matrix);
        v64 = matrix.a;
        v65 = v64 * 100.0 / CTFontGetSize(v58);
        if (v189)
          v65 = -v65;
        matrix.a = v65;
        v66 = CFNumberCreate(0, kCFNumberCGFloatType, &matrix);
        CFDictionarySetValue(v62, v182, v66);
        CFRelease(v66);
        v13 = 0;
      }
      if (v189)
      {
        CFDictionarySetValue(v62, v183, v189);
        CFRelease(v189);
      }
      else
      {
        v13 |= v12;
      }
      v67 = CFNumberCreate(alloc, kCFNumberCGFloatType, &x[0].d);
      CFDictionarySetValue(v62, v185, v67);
      CFRelease(v67);
      attrString = CFAttributedStringCreate(alloc, v191, v62);
      CFRelease(v191);
      CFRelease(v62);
      line = CTLineCreateWithAttributedString(attrString);
      memset(&matrix, 0, sizeof(matrix));
      CGAffineTransformMakeScale(&matrix, 1.0, -1.0);
      v181 = *(CGContext **)v195;
      v68 = CGSVGNodeFindAttribute(a2, (const char *)0x9D);
      if (v68)
      {
        v70 = CGSVGAttributeCopyString(v68, v69);
        if (v70)
        {
          ImageBounds = CTLineGetImageBounds(line, v181);
          width = (unint64_t)ImageBounds.size.width;
          if (CFStringCompare(v70, CFSTR("end"), 0) == kCFCompareEqualTo)
            goto LABEL_101;
          if (CFStringCompare(v70, CFSTR("middle"), 0) == kCFCompareEqualTo)
          {
            width >>= 1;
LABEL_101:
            v203[0] = v203[0] - (double)width;
          }
          CFRelease(v70);
        }
      }
      if ((v13 & 1) != 0)
      {
        v72 = CGPathCreateMutable();
        GlyphRuns = CTLineGetGlyphRuns(line);
        Count = CFArrayGetCount(GlyphRuns);
        if (Count >= 1)
        {
          v74 = 0;
          v190 = GlyphRuns;
          while (1)
          {
            ValueAtIndex = (const __CTRun *)CFArrayGetValueAtIndex(GlyphRuns, v74);
            GlyphCount = CTRunGetGlyphCount(ValueAtIndex);
            GlyphsPtr = CTRunGetGlyphsPtr(ValueAtIndex);
            if (GlyphsPtr)
            {
              memset(&m, 0, 24);
              std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short const*,unsigned short const*>(&m, GlyphsPtr, (uint64_t)&GlyphsPtr[GlyphCount], GlyphCount);
              v78 = m.a;
            }
            else
            {
              std::vector<unsigned short>::vector(&m, GlyphCount);
              v78 = m.a;
              v210.location = 0;
              v210.length = GlyphCount;
              CTRunGetGlyphs(ValueAtIndex, v210, *(CGGlyph **)&m.a);
            }
            PositionsPtr = CTRunGetPositionsPtr(ValueAtIndex);
            if (PositionsPtr)
            {
              memset(&m, 0, 24);
              std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint const*,CGPoint const*>(&m, PositionsPtr, (uint64_t)&PositionsPtr[GlyphCount], GlyphCount);
              v80 = m.a;
            }
            else
            {
              std::vector<CGPoint>::vector(&m, GlyphCount);
              v80 = m.a;
              v211.location = 0;
              v211.length = GlyphCount;
              CTRunGetPositions(ValueAtIndex, v211, *(CGPoint **)&m.a);
            }
            if (GlyphCount >= 1)
              break;
            if (v80 != 0.0)
              goto LABEL_117;
LABEL_118:
            if (v78 != 0.0)
              operator delete(*(void **)&v78);
            ++v74;
            GlyphRuns = v190;
            if (v74 == Count)
              goto LABEL_121;
          }
          v81 = 0;
          do
          {
            v82 = CTFontCreatePathForGlyph(v58, *(_WORD *)(*(_QWORD *)&v78 + v81), &matrix);
            memset(&m, 0, sizeof(m));
            CGAffineTransformMakeTranslation(&m, v203[0] + *(double *)(*(_QWORD *)&v80 + 8 * v81), v201 + *(double *)(*(_QWORD *)&v80 + 8 * v81 + 8));
            CGPathAddPath(v72, &m, v82);
            CGPathRelease(v82);
            v81 += 2;
            --GlyphCount;
          }
          while (GlyphCount);
LABEL_117:
          operator delete(*(void **)&v80);
          goto LABEL_118;
        }
LABEL_121:
        CGContextAddPath(v181, v72);
        CGPathRelease(v72);
      }
      else
      {
        m = matrix;
        CGContextSetTextMatrix(v181, &m);
        CGContextSetTextPosition(v181, v203[0], v201);
        CTLineDraw(line, v181);
      }
      CFRelease(attrString);
      CFRelease(line);
      CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)x);
    }
    v18 = c;
    goto LABEL_125;
  }
}

void sub_206785D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)&a59);
  _Unwind_Resume(a1);
}

uint64_t DrawFilterNodeWithDefsOnly(uint64_t a1, const char *a2)
{
  _QWORD *AttributeMap;
  uint64_t Attribute;
  uint64_t result;
  uint64_t v6;

  AttributeMap = CGSVGNodeGetAttributeMap(a1, a2);
  Attribute = CGSVGAttributeMapGetAttribute((uint64_t)AttributeMap, (const char *)0x54);
  v6 = 0;
  if (!Attribute || !CGSVGAttributeGetFilter(Attribute, (char *)&v6))
    return 1;
  if (!a2)
    return 0;
  result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("drawingDefinition"));
  if (result)
    return 1;
  return result;
}

CGColorRef CreateColorForNode(uint64_t a1, const char *a2)
{
  uint64_t Attribute;
  const char *v3;
  unsigned int Paint;
  CGColorRef result;
  const char *v6;
  _BYTE v7[40];
  uint64_t v8;

  Attribute = CGSVGNodeFindAttribute(a1, a2);
  v8 = 0;
  Paint = CGSVGAttributeGetPaint(Attribute, (char *)&v8);
  result = 0;
  if (Paint)
  {
    if (CGSVGPaintGetType(v8, v3) == 1)
    {
      CGSVGPaintGetColor(v8, v6, (uint64_t)v7);
      return CGSVGColorCreateCGColor((uint64_t)v7);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *std::vector<unsigned short>::vector(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned short>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_206785F58(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

_QWORD *std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short const*,unsigned short const*>(_QWORD *result, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned short>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20678603C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CGPoint>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CGPoint>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }
  return a1;
}

void sub_2067860B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CGPoint>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

_QWORD *std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint const*,CGPoint const*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CGPoint>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_206786168(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *CFRetained::getObject<SVGPattern>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void *CFRetained::getObject<SVGFilter>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void std::vector<CGSVGDrawState>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        CGSVGDrawState::~CGSVGDrawState((CGSVGDrawState *)(v4 - 208));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__split_buffer<CGSVGNode *>::push_back(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

char *std::vector<CGSVGNode *>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

uint64_t std::vector<CGSVGDrawState>::__push_back_slow_path<CGSVGDrawState>(uint64_t *a1, const CGSVGDrawState *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  CGSVGDrawState *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x4EC4EC4EC4EC4EC5 * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x13B13B13B13B13BLL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x4EC4EC4EC4EC4EC5 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x9D89D89D89D89DLL)
    v9 = 0x13B13B13B13B13BLL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGSVGDrawState>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (CGSVGDrawState *)&v10[208 * v4];
  v16 = &v10[208 * v9];
  CGSVGDrawState::CGSVGDrawState(v14, a2);
  v15 = (char *)v14 + 208;
  std::vector<CGSVGDrawState>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<CGSVGDrawState>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_206786564(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CGSVGDrawState>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CGSVGFilterGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_2067865CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGFilterPrimitiveGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_20678663C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGFilterPrimitiveCreate(unsigned int a1)
{
  uint64_t v2;

  v2 = operator new();
  SVGFilterPrimitive::SVGFilterPrimitive(v2, a1);
  return *(_QWORD *)(v2 + 40);
}

void sub_20678669C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40E03E9813);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGFilterPrimitiveRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGFilterPrimitiveRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGSVGFilterCreate()
{
  SVGFilter *v0;

  v0 = (SVGFilter *)operator new();
  SVGFilter::SVGFilter(v0, 0);
  return *((_QWORD *)v0 + 5);
}

void sub_206786738(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40B295622DLL);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGFilterRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGFilterRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void SVGImage::SVGImage(SVGImage *this, char a2)
{
  void *__p[2];
  char v5;

  std::string::basic_string[abi:ne180100]<0>(__p, "image");
  SVGViewBoxNode::SVGViewBoxNode(this, (char *)__p);
  if (v5 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8E48;
  *((_QWORD *)this + 34) = 0;
  *((_BYTE *)this + 296) = a2;
  *((_QWORD *)this + 38) = 0;
  *((_DWORD *)this + 70) = 0;
  *(int64x2_t *)((char *)this + 216) = vdupq_n_s64(0x7FF8000000000000uLL);
}

void sub_206786820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGImage::SVGImage(SVGImage *this, CFTypeRef *a2)
{
  uint64_t v4;

  SVGImage::SVGImage(this, 0);
  *(_DWORD *)(v4 + 280) = 2;
  CFRetained::retain(a2);
  *((_QWORD *)this + 36) = a2;
}

{
  uint64_t v4;

  SVGImage::SVGImage(this, 0);
  *(_DWORD *)(v4 + 280) = 2;
  CFRetained::retain(a2);
  *((_QWORD *)this + 36) = a2;
}

void sub_206786880(_Unwind_Exception *a1)
{
  SVGImage *v1;

  SVGImage::~SVGImage(v1);
  _Unwind_Resume(a1);
}

void SVGImage::~SVGImage(SVGImage *this)
{
  int v2;
  const void *v3;

  *(_QWORD *)this = &off_24BFD8E48;
  v2 = *((_DWORD *)this + 70);
  if (v2 == 2)
  {
    CFRetained::release(*((CFTypeRef **)this + 36));
  }
  else if (v2 == 1)
  {
    CGImageRelease(*((CGImageRef *)this + 36));
  }
  v3 = (const void *)*((_QWORD *)this + 34);
  if (v3)
    CFRelease(v3);
  CGPathRelease(*((CGPathRef *)this + 38));
  SVGMask::~SVGMask(this);
}

{
  SVGImage::~SVGImage(this);
  JUMPOUT(0x20BCFC038);
}

void sub_206786940(_Unwind_Exception *a1)
{
  SVGImage *v1;

  SVGImage::~SVGImage(v1);
  _Unwind_Resume(a1);
}

void SVGImage::SVGImage(SVGImage *this, CGImage *a2)
{
  uint64_t v4;
  size_t Width;
  size_t Height;

  SVGImage::SVGImage(this, 0);
  *(_DWORD *)(v4 + 280) = 1;
  *((_QWORD *)this + 36) = CGImageRetain(a2);
  Width = CGImageGetWidth(a2);
  Height = CGImageGetHeight(a2);
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((double *)this + 31) = (double)Width;
  *((double *)this + 32) = (double)Height;
}

{
  uint64_t v4;
  size_t Width;
  size_t Height;

  SVGImage::SVGImage(this, 0);
  *(_DWORD *)(v4 + 280) = 1;
  *((_QWORD *)this + 36) = CGImageRetain(a2);
  Width = CGImageGetWidth(a2);
  Height = CGImageGetHeight(a2);
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((double *)this + 31) = (double)Width;
  *((double *)this + 32) = (double)Height;
}

void sub_2067869C4(_Unwind_Exception *a1)
{
  SVGImage *v1;

  SVGImage::~SVGImage(v1);
  _Unwind_Resume(a1);
}

void sub_206786A48(_Unwind_Exception *a1)
{
  SVGImage *v1;

  SVGImage::~SVGImage(v1);
  _Unwind_Resume(a1);
}

SVGImage *SVGImage::copy(CFTypeRef **this)
{
  SVGImage *v2;

  v2 = (SVGImage *)operator new();
  SVGImage::SVGImage(v2, this);
  return v2;
}

void sub_206786AA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40F9C81853);
  _Unwind_Resume(a1);
}

BOOL SVGImage::rasterImage(SVGImage *this, CGImage **a2)
{
  int v2;

  v2 = *((_DWORD *)this + 70);
  if (v2 == 1)
    *a2 = (CGImage *)*((_QWORD *)this + 36);
  return v2 == 1;
}

BOOL SVGImage::svgImage(SVGImage *this, SVGDocument **a2)
{
  int v2;

  v2 = *((_DWORD *)this + 70);
  if (v2 == 2)
    *a2 = (SVGDocument *)*((_QWORD *)this + 36);
  return v2 == 2;
}

void SVGImage::draw(SVGImage *this, CGContextRef c)
{
  int v4;
  CGFloat Width;
  CGFloat Height;
  double v7;
  const char *v8;
  double v9;
  CGRect v10;

  CGContextScaleCTM(c, 1.0, -1.0);
  v4 = *((_DWORD *)this + 70);
  if (v4)
  {
    if (v4 == 2)
    {
      SVGDocument::canvasSize(*((SVGDocument **)this + 36));
      v8 = *(const char **)(*((_QWORD *)this + 36) + 40);
      CGContextTranslateCTM(c, 0.0, -v9);
      CGContextDrawSVGDocument(c, v8);
    }
    else if (v4 == 1)
    {
      Width = (double)CGImageGetWidth(*((CGImageRef *)this + 36));
      Height = (double)CGImageGetHeight(*((CGImageRef *)this + 36));
      CGContextTranslateCTM(c, 0.0, -Height);
      v10.origin.x = 0.0;
      v10.origin.y = 0.0;
      v10.size.width = Width;
      v10.size.height = Height;
      CGContextDrawImage(c, v10, *((CGImageRef *)this + 36));
    }
  }
  else if (*((_BYTE *)this + 296))
  {
    v7 = *((double *)this + 28);
    CGContextSetRGBStrokeColor(c, 1.0, 0.0, 0.0, 1.0);
    CGContextTranslateCTM(c, 0.0, -v7);
    CGContextAddPath(c, *((CGPathRef *)this + 38));
    CGContextDrawPath(c, kCGPathStroke);
  }
}

uint64_t SVGImage::hasWideGamutColor(SVGImage *this)
{
  int v1;
  CGColorSpace *ColorSpace;

  v1 = *((_DWORD *)this + 70);
  if (v1 == 2)
    return SVGDocument::hasWideGamutContent(*((SVGDocument **)this + 36));
  if (v1 != 1)
    return 0;
  ColorSpace = CGImageGetColorSpace(*((CGImageRef *)this + 36));
  return CGColorSpaceIsWideGamutRGB(ColorSpace);
}

uint64_t SVGImage::print(SVGImage *this, const char *a2)
{
  const char *v3;
  SVGUtilities *v4;
  const char *v5;

  SVGUtilities::print((SVGUtilities *)"\n", a2);
  v4 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"ImageNode: Size: {%.2f, %.2f} Viewbox: ", v3, *((_QWORD *)this + 27), *((_QWORD *)this + 28));
  SVGUtilities::printIgnoringIndention(v4, *(CGRect *)((char *)this + 232));
  return SVGUtilities::print((SVGUtilities *)"\n", v5);
}

void SVGImage::updatedAttributes(SVGImage *this, SVGAttributeMap *a2)
{
  SVGViewBoxNode::updatedAttributes((uint64_t)this, (uint64_t)a2);
  SVGImage::calcSize(this);
}

void SVGImage::calcSize(SVGImage *this)
{
  int v2;
  uint64_t v3;
  __int128 v4;
  CGPath *Mutable;
  const CGAffineTransform *v6;
  CGPoint points;
  CGFloat width;
  CGFloat height;
  CGPoint v10;
  CGFloat v11;
  uint64_t v12;
  uint64_t v13;
  CGRect v14;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *((_DWORD *)this + 70);
  if (v2 == 2)
  {
    v3 = *(_QWORD *)(*((_QWORD *)this + 36) + 48);
    v4 = *(_OWORD *)(v3 + 248);
    *(_OWORD *)((char *)this + 232) = *(_OWORD *)(v3 + 232);
    *(_OWORD *)((char *)this + 248) = v4;
    *(_OWORD *)(v3 + 200) = *MEMORY[0x24BDBEFB0];
    SVGDocument::validateSizes(*((SVGDocument **)this + 36));
    v2 = *((_DWORD *)this + 70);
  }
  if (!v2)
  {
    if (*((_BYTE *)this + 296))
    {
      Mutable = CGPathCreateMutable();
      points.x = 0.0;
      points.y = 0.0;
      v14.size.width = *((CGFloat *)this + 27);
      v14.size.height = *((CGFloat *)this + 28);
      width = v14.size.width;
      height = v14.size.height;
      v10.x = 0.0;
      v10.y = v14.size.height;
      v11 = v14.size.width;
      v12 = 0;
      v6 = (const CGAffineTransform *)MEMORY[0x24BDBD8B8];
      v14.origin.x = 0.0;
      v14.origin.y = 0.0;
      CGPathAddRect(Mutable, MEMORY[0x24BDBD8B8], v14);
      CGPathAddLines(Mutable, v6, &points, 2uLL);
      CGPathAddLines(Mutable, v6, &v10, 2uLL);
      CGPathRelease(*((CGPathRef *)this + 38));
      *((_QWORD *)this + 38) = Mutable;
    }
  }
}

uint64_t SVGImage::updatedSpecificAttribute(uint64_t a1, int a2, SVGAttribute *this)
{
  const void *v5;
  uint64_t v6;
  __int128 v7;
  const __CFAllocator *v9;
  std::string *v10;
  const __CFString *v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  std::string v15;

  if (a2 == 65)
    return 1;
  if (a2 != 20000)
    return 0;
  v5 = *(const void **)(a1 + 272);
  if (v5)
    CFRelease(v5);
  v6 = SVGAttribute::stringValue(this);
  if (*(char *)(v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v15, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
  }
  else
  {
    v7 = *(_OWORD *)v6;
    v15.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
    *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v7;
  }
  v9 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v10 = &v15;
  else
    v10 = (std::string *)v15.__r_.__value_.__r.__words[0];
  v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)v10, 0x8000100u);
  *(_QWORD *)(a1 + 272) = CFURLCreateWithString(v9, v11, 0);
  CFRelease(v11);
  v12 = *(_QWORD *)(a1 + 272);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v15.__r_.__value_.__l.__data_);
    if (v12)
      return 1;
LABEL_17:
    v13 = SVGAtom::ToString(0x4E20u);
    SVGUtilities::log((SVGUtilities *)"Failed to parse %s for node name \"svg\"", v14, v13);
    return 1;
  }
  if (!v12)
    goto LABEL_17;
  return 1;
}

void sub_206786FFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double SVGImage::boundingBox(uint64_t a1)
{
  return *(double *)(a1 + 200);
}

uint64_t SVGImage::hasMonochromeColor(SVGImage *this)
{
  int v1;
  CGColorSpace *ColorSpace;

  v1 = *((_DWORD *)this + 70);
  if (v1 == 1)
  {
    ColorSpace = CGImageGetColorSpace(*((CGImageRef *)this + 36));
    return CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelMonochrome;
  }
  else if (v1 == 2)
  {
    return SVGDocument::hasMonochromeContent(*((SVGDocument **)this + 36));
  }
  else
  {
    return 0;
  }
}

void SVGImage::SVGImage(SVGImage *this, CFTypeRef **a2)
{
  uint64_t v4;
  int v5;
  const __CFURL *v6;

  SVGViewBoxNode::SVGViewBoxNode(this, (const SVGViewBoxNode *)a2);
  *(_QWORD *)v4 = &off_24BFD8E48;
  *(_QWORD *)(v4 + 272) = 0;
  v5 = *((_DWORD *)a2 + 70);
  *(_DWORD *)(v4 + 280) = v5;
  *(_BYTE *)(v4 + 296) = *((_BYTE *)a2 + 296);
  *(_QWORD *)(v4 + 304) = 0;
  if (v5 == 2)
  {
    *((_QWORD *)this + 36) = a2[36];
    CFRetained::retain(a2[36]);
  }
  else if (v5 == 1)
  {
    *((_QWORD *)this + 36) = CGImageCreateCopy((CGImageRef)a2[36]);
  }
  v6 = (const __CFURL *)a2[34];
  if (v6)
    *((_QWORD *)this + 34) = CFURLCopyAbsoluteURL(v6);
  *((_QWORD *)this + 38) = CGPathCreateMutableCopy(*((CGPathRef *)this + 38));
}

void sub_206787108(_Unwind_Exception *a1)
{
  SVGMask *v1;

  SVGMask::~SVGMask(v1);
  _Unwind_Resume(a1);
}

uint64_t CGSVGPaintGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206787170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGPaintCreateNone()
{
  SVGPaint *v0;

  v0 = (SVGPaint *)operator new();
  SVGPaint::SVGPaint(v0);
  return *((_QWORD *)v0 + 5);
}

void sub_2067871C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C2CA9EE7);
  _Unwind_Resume(a1);
}

uint64_t CGSVGPaintCreateWithColor(uint64_t a1)
{
  SVGPaint *v2;
  _BYTE v4[40];

  v2 = (SVGPaint *)operator new();
  SVGColor::SVGColor((uint64_t)v4, *(_DWORD *)(a1 + 32), *(double *)a1, *(double *)(a1 + 8), *(double *)(a1 + 16), *(double *)(a1 + 24));
  SVGPaint::SVGPaint(v2, (const SVGColor *)v4);
  return *((_QWORD *)v2 + 5);
}

void sub_206787250(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C2CA9EE7);
  _Unwind_Resume(a1);
}

SVGGradient *CGSVGPaintCreateWithGradient(uint64_t a1, const char *a2)
{
  SVGGradient *result;
  SVGGradient *v3;
  SVGPaint *v4;

  result = (SVGGradient *)CFRetained::getObject<SVGGradient>(a1, a2);
  if (result)
  {
    v3 = result;
    v4 = (SVGPaint *)operator new();
    SVGPaint::SVGPaint(v4, v3);
    return (SVGGradient *)*((_QWORD *)v4 + 5);
  }
  return result;
}

void sub_2067872C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C2CA9EE7);
  _Unwind_Resume(a1);
}

SVGPattern *CGSVGPaintCreateWithPattern(uint64_t a1, const char *a2)
{
  SVGPattern *result;
  SVGPattern *v3;
  SVGPaint *v4;

  result = (SVGPattern *)CFRetained::getObject<SVGPattern>(a1, a2);
  if (result)
  {
    v3 = result;
    v4 = (SVGPaint *)operator new();
    SVGPaint::SVGPaint(v4, v3);
    return (SVGPattern *)*((_QWORD *)v4 + 5);
  }
  return result;
}

void sub_206787330(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C2CA9EE7);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGPaintRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGPaintRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

unsigned int *CGSVGPaintGetType(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGPaint>(a1, a2);
  if (result)
    return (unsigned int *)result[12];
  return result;
}

void *CFRetained::getObject<SVGPaint>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

double *CGSVGPaintIsVisible(uint64_t a1, const char *a2)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGPaint>(a1, a2);
  if (result)
  {
    if (*((_DWORD *)result + 12))
      return (double *)(result[12] > 0.0);
    else
      return 0;
  }
  return result;
}

double CGSVGPaintGetOpacity(uint64_t a1, const char *a2)
{
  double *v2;

  v2 = (double *)CFRetained::getObject<SVGPaint>(a1, a2);
  if (v2)
    return v2[12];
  else
    return 1.0;
}

double *CGSVGPaintSetOpacity(uint64_t a1, const char *a2, double a3)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGPaint>(a1, a2);
  if (result)
    result[12] = a3;
  return result;
}

uint64_t CGSVGPaintGetColor@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  uint64_t v5;
  double v7[4];
  int v8;

  v4 = CFRetained::getObject<SVGPaint>(a1, a2);
  if (!v4)
    return CGSVGColorCreateWithRGBA(0, a3, 0.0, 0.0, 0.0, 0.0);
  SVGColor::SVGColor((uint64_t)v7, (uint64_t)v4 + 56);
  if (v8 == 15)
    v5 = 1;
  else
    v5 = 2 * (v8 == 73);
  return CGSVGColorCreateWithRGBA(v5, a3, v7[0], v7[1], v7[2], v7[3]);
}

_QWORD *CGSVGPaintGetGradient(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v3;

  result = CFRetained::getObject<SVGPaint>(a1, a2);
  if (result)
  {
    v3 = result[13];
    if (v3)
      return *(_QWORD **)(v3 + 40);
    else
      return 0;
  }
  return result;
}

_QWORD *CGSVGPaintGetPattern(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v3;

  result = CFRetained::getObject<SVGPaint>(a1, a2);
  if (result)
  {
    v3 = result[14];
    if (v3)
      return *(_QWORD **)(v3 + 40);
    else
      return 0;
  }
  return result;
}

void SVGGradientStop::SVGGradientStop(SVGGradientStop *this)
{
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGGradientStop::kSVGGradientStopClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_24BFD8D18;
  SVGColor::SVGColor((uint64_t)this + 48, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 11) = 0x3FF0000000000000;
}

void sub_2067875D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void SVGGradientStop::SVGGradientStop(SVGGradientStop *this, const SVGColor *a2, double a3)
{
  uint64_t v5;
  uint64_t v6;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGGradientStop::kSVGGradientStopClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_24BFD8D18;
  SVGColor::SVGColor((uint64_t)this + 48, (uint64_t)a2);
  *((_QWORD *)this + 11) = 0x3FF0000000000000;
  CGSVGLengthMake();
  *((_QWORD *)this + 12) = v5;
  *((_QWORD *)this + 13) = v6;
}

void sub_2067876A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

_QWORD *SVGGradientStop::SVGGradientStop(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *__p[2];
  char v10;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGGradientStop::kSVGGradientStopClassName);
  CFRetained::CFRetained(a1, (uint64_t)__p);
  if (v10 < 0)
    operator delete(__p[0]);
  *a1 = off_24BFD8D18;
  SVGColor::SVGColor((uint64_t)(a1 + 6), a2);
  a1[11] = 0x3FF0000000000000;
  a1[12] = a3;
  a1[13] = a4;
  return a1;
}

void sub_206787778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  *(_QWORD *)v15 = off_24BFD8A68;
  if (*(char *)(v15 + 31) < 0)
    operator delete(*(void **)(v15 + 8));
  _Unwind_Resume(exception_object);
}

void SVGGradientStop::SVGGradientStop(SVGGradientStop *this, const SVGGradientStop *a2)
{
  uint64_t v4;
  void *__p[2];
  char v6;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGGradientStop::kSVGGradientStopClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_24BFD8D18;
  v4 = SVGColor::SVGColor((uint64_t)this + 48, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 11) = 0x3FF0000000000000;
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  SVGColor::operator=(v4, (uint64_t)a2 + 48);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
}

void sub_20678785C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void SVGGradientStop::~SVGGradientStop(void **this)
{
  *this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24BFD8A68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BCFC038);
}

double SVGGradientStop::setColor(SVGGradientStop *this, const SVGColor *a2)
{
  double result;

  *(_QWORD *)&result = SVGColor::operator=((uint64_t)this + 48, (uint64_t)a2).n128_u64[0];
  return result;
}

BOOL SVGGradientStop::isEqual(SVGGradientStop *this, const SVGGradientStop *a2)
{
  _BOOL8 result;

  result = CGSVGLengthEqualToLength(*((_QWORD *)this + 12), *((_QWORD *)this + 13), *((_QWORD *)a2 + 12), *((_QWORD *)a2 + 13));
  if ((_DWORD)result)
  {
    result = SVGColor::isEqual((SVGGradientStop *)((char *)this + 48), (const SVGGradientStop *)((char *)a2 + 48));
    if ((_DWORD)result)
      return *((double *)this + 11) == *((double *)a2 + 11);
  }
  return result;
}

SVGGradientStop *SVGGradientStop::copy(SVGGradientStop *this)
{
  SVGGradientStop *v2;

  v2 = (SVGGradientStop *)operator new();
  SVGGradientStop::SVGGradientStop(v2, this);
  return v2;
}

void sub_206787A04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C1F8F287);
  _Unwind_Resume(a1);
}

void SVGGradientStop::print(SVGGradientStop *this)
{
  const char *v2;
  void **v3;
  _BYTE v4[40];
  void *v5[2];
  char v6;

  SVGColor::SVGColor((uint64_t)v4, (uint64_t)this + 48);
  SVGColor::GetStringForColor((uint64_t)v4, (uint64_t)v5);
  if (v6 >= 0)
    v3 = v5;
  else
    v3 = (void **)v5[0];
  SVGUtilities::print((SVGUtilities *)"Stop: Offset: %g, Color: %s\n", v2, *((_QWORD *)this + 12), v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_206787AA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 17) < 0)
    operator delete(*(void **)(v1 - 40));
  _Unwind_Resume(exception_object);
}

uint64_t SVGGradient::SVGGradient(uint64_t a1, int a2, char *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  if (a2)
    v6 = 48;
  else
    v6 = 33;
  v7 = SVGNode::SVGNode(a1, v6);
  *(_QWORD *)v7 = &off_24BFD8B58;
  *(_DWORD *)(v7 + 200) = a2;
  *(_QWORD *)(v7 + 208) = 0;
  *(_QWORD *)(v7 + 216) = 0;
  *(_QWORD *)(v7 + 224) = 0;
  CGSVGPointMake(v7 + 232, 0.0, 0.0);
  CGSVGPointMake(a1 + 264, 0.0, 0.0);
  CGSVGPointMake(a1 + 296, 0.0, 0.0);
  CGSVGPointMake(a1 + 328, 0.0, 0.0);
  CGSVGLengthMake();
  *(_QWORD *)(a1 + 360) = v8;
  *(_QWORD *)(a1 + 368) = v9;
  *(_DWORD *)(a1 + 376) = 0;
  v10 = MEMORY[0x24BDBD8B8];
  v11 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)(a1 + 384) = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)(a1 + 400) = v11;
  *(_OWORD *)(a1 + 416) = *(_OWORD *)(v10 + 32);
  *(_QWORD *)(a1 + 432) = 0;
  *(_BYTE *)(a1 + 440) = 0;
  SVGNode::setIdentifier((SVGNode *)a1, a3);
  return a1;
}

void sub_206787B98(_Unwind_Exception *a1)
{
  SVGNode *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 27) = v4;
    operator delete(v4);
  }
  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

void SVGGradient::SVGGradient(SVGGradient *this, const SVGGradient *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;
  __int128 v11;
  const SVGGradientStop **v12;
  const SVGGradientStop **v13;
  const SVGGradientStop *v14;
  SVGGradientStop *v15;

  SVGNode::SVGNode(this, (const SVGAttributeMap **)a2);
  *(_QWORD *)v4 = &off_24BFD8B58;
  *(_DWORD *)(v4 + 200) = *((_DWORD *)a2 + 50);
  *(_QWORD *)(v4 + 208) = 0;
  *(_QWORD *)(v4 + 216) = 0;
  *(_QWORD *)(v4 + 224) = 0;
  v5 = *(_OWORD *)((char *)a2 + 232);
  *(_OWORD *)(v4 + 248) = *(_OWORD *)((char *)a2 + 248);
  *(_OWORD *)(v4 + 232) = v5;
  v6 = *(_OWORD *)((char *)a2 + 280);
  *(_OWORD *)(v4 + 264) = *(_OWORD *)((char *)a2 + 264);
  *(_OWORD *)(v4 + 280) = v6;
  CGSVGPointMake(v4 + 296, 0.0, 0.0);
  CGSVGPointMake((uint64_t)this + 328, 0.0, 0.0);
  CGSVGLengthMake();
  *((_QWORD *)this + 45) = v7;
  *((_QWORD *)this + 46) = v8;
  v9 = (__int128 *)MEMORY[0x24BDBD8B8];
  *((_DWORD *)this + 94) = *((_DWORD *)a2 + 94);
  v10 = v9[2];
  v11 = *v9;
  *((_OWORD *)this + 25) = v9[1];
  *((_OWORD *)this + 26) = v10;
  *((_OWORD *)this + 24) = v11;
  *((_QWORD *)this + 54) = 0;
  *((_BYTE *)this + 440) = 0;
  v12 = (const SVGGradientStop **)*((_QWORD *)a2 + 26);
  v13 = (const SVGGradientStop **)*((_QWORD *)a2 + 27);
  while (v12 != v13)
  {
    v14 = *v12;
    v15 = (SVGGradientStop *)operator new();
    SVGGradientStop::SVGGradientStop(v15, v14);
    SVGGradient::addStop(this, v15);
    CFRetained::release((CFTypeRef *)v15);
    ++v12;
  }
  *((_QWORD *)this + 54) = *((_QWORD *)a2 + 54);
  *((_BYTE *)this + 440) = *((_BYTE *)a2 + 440);
}

void sub_206787CF4(_Unwind_Exception *a1)
{
  SVGNode *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 27) = v4;
    operator delete(v4);
  }
  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

uint64_t SVGGradient::addStop(SVGGradient *this, SVGGradientStop *a2)
{
  char *v4;
  _QWORD *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unint64_t v16;
  _QWORD *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;

  v4 = (char *)*((_QWORD *)this + 26);
  v6 = (char *)*((_QWORD *)this + 27);
  v5 = (_QWORD *)((char *)this + 208);
  v7 = v6 - v4;
  if (v6 != v4 && (*((_QWORD *)a2 + 12) & 0x7FFFFFFFFFFFFFFFLL) == 0)
  {
    *((_OWORD *)a2 + 6) = *(_OWORD *)(*((_QWORD *)v6 - 1) + 96);
    v15 = (char *)this + 224;
    v16 = *((_QWORD *)this + 28);
    v6 = (char *)*((_QWORD *)this + 27);
    if ((unint64_t)v6 >= v16)
    {
      v23 = (uint64_t)&v6[-*v5] >> 3;
      if (!((unint64_t)(v23 + 1) >> 61))
      {
        v24 = v16 - *v5;
        v25 = v24 >> 2;
        if (v24 >> 2 <= (unint64_t)(v23 + 1))
          v25 = v23 + 1;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
          v26 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v26 = v25;
        if (v26)
          v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v15, v26);
        else
          v27 = 0;
        v18 = &v27[8 * v23];
        v19 = &v27[8 * v26];
        *(_QWORD *)v18 = a2;
        v17 = v18 + 8;
        v28 = (char *)*((_QWORD *)this + 26);
        v20 = (char *)*((_QWORD *)this + 27);
        if (v20 == v28)
          goto LABEL_30;
        do
        {
          v29 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *((_QWORD *)v18 - 1) = v29;
          v18 -= 8;
        }
        while (v20 != v28);
        goto LABEL_29;
      }
LABEL_33:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
LABEL_13:
    *(_QWORD *)v6 = a2;
    v17 = v6 + 8;
    goto LABEL_32;
  }
  v8 = (char *)this + 224;
  v9 = *((_QWORD *)this + 28);
  if ((unint64_t)v6 < v9)
    goto LABEL_13;
  v10 = v7 >> 3;
  v11 = (v7 >> 3) + 1;
  if (v11 >> 61)
    goto LABEL_33;
  v12 = v9 - (_QWORD)v4;
  if (v12 >> 2 > v11)
    v11 = v12 >> 2;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v8, v13);
  else
    v14 = 0;
  v18 = &v14[8 * v10];
  v19 = &v14[8 * v13];
  *(_QWORD *)v18 = a2;
  v17 = v18 + 8;
  v21 = (char *)*((_QWORD *)this + 26);
  v20 = (char *)*((_QWORD *)this + 27);
  if (v20 == v21)
    goto LABEL_30;
  do
  {
    v22 = *((_QWORD *)v20 - 1);
    v20 -= 8;
    *((_QWORD *)v18 - 1) = v22;
    v18 -= 8;
  }
  while (v20 != v21);
LABEL_29:
  v20 = (char *)*v5;
LABEL_30:
  *((_QWORD *)this + 26) = v18;
  *((_QWORD *)this + 27) = v17;
  *((_QWORD *)this + 28) = v19;
  if (v20)
    operator delete(v20);
LABEL_32:
  *((_QWORD *)this + 27) = v17;
  return CFRetained::retain((uint64_t)a2);
}

void SVGGradient::~SVGGradient(SVGGradient *this)
{
  CFTypeRef **v2;
  CFTypeRef **v3;

  *(_QWORD *)this = &off_24BFD8B58;
  v2 = (CFTypeRef **)*((_QWORD *)this + 26);
  v3 = (CFTypeRef **)*((_QWORD *)this + 27);
  if (v2 != v3)
  {
    do
      CFRetained::release(*v2++);
    while (v2 != v3);
    v2 = (CFTypeRef **)*((_QWORD *)this + 26);
  }
  if (v2)
  {
    *((_QWORD *)this + 27) = v2;
    operator delete(v2);
  }
  SVGNode::~SVGNode(this);
}

{
  SVGGradient::~SVGGradient(this);
  JUMPOUT(0x20BCFC038);
}

void SVGGradient::updatedAttributes(SVGGradient *this, SVGAttributeMap *a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t *v10;
  uint64_t *v11;
  __int128 v12;
  __int128 v13;
  _QWORD v14[11];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  __n128 (*v22)(uint64_t, uint64_t);
  uint64_t (*v23)();
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  __n128 (*v30)(uint64_t, uint64_t);
  uint64_t (*v31)();
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[5];
  _BYTE v35[32];
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  __n128 (*v39)(uint64_t, uint64_t);
  uint64_t (*v40)();
  _BYTE v41[32];
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  __n128 (*v45)(uint64_t, uint64_t);
  uint64_t (*v46)();
  _BYTE v47[32];
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  __n128 (*v51)(uint64_t, uint64_t);
  uint64_t (*v52)();
  _BYTE v53[32];

  v48 = 0;
  v49 = &v48;
  v50 = 0x4802000000;
  v51 = __Block_byref_object_copy__0;
  v52 = __Block_byref_object_dispose__0;
  memset(v53, 0, sizeof(v53));
  CGSVGPointMake((uint64_t)v53, 0.0, 0.0);
  v42 = 0;
  v43 = &v42;
  v44 = 0x4802000000;
  v45 = __Block_byref_object_copy__0;
  v46 = __Block_byref_object_dispose__0;
  memset(v47, 0, sizeof(v47));
  CGSVGPointMakeWithTypes(1, 1, (uint64_t)v47, 100.0, 0.0);
  v36 = 0;
  v37 = &v36;
  v38 = 0x4802000000;
  v39 = __Block_byref_object_copy__0;
  v40 = __Block_byref_object_dispose__0;
  memset(v41, 0, sizeof(v41));
  CGSVGPointMakeWithTypes(1, 1, (uint64_t)v41, 50.0, 50.0);
  v34[0] = 0;
  v34[1] = v34;
  v34[2] = 0x4802000000;
  v34[3] = __Block_byref_object_copy__0;
  v34[4] = __Block_byref_object_dispose__0;
  memset(v35, 0, sizeof(v35));
  CGSVGPointMakeWithTypes(1, 1, (uint64_t)v35, 50.0, 50.0);
  v27 = 0;
  v28 = &v27;
  v29 = 0x3802000000;
  v30 = __Block_byref_object_copy__2;
  v31 = __Block_byref_object_dispose__3;
  v32 = 0;
  v33 = 0;
  CGSVGLengthMakeWithType();
  v21 = 0x5802000000;
  v4 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  v24 = *MEMORY[0x24BDBD8B8];
  v32 = v5;
  v33 = v6;
  v19 = 0;
  v20 = &v19;
  v22 = __Block_byref_object_copy__4;
  v23 = __Block_byref_object_dispose__5;
  v25 = v4;
  v26 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v14[0] = MEMORY[0x24BDAC760];
  v14[1] = 0x40000000;
  v14[2] = ___ZN11SVGGradient17updatedAttributesEP15SVGAttributeMap_block_invoke;
  v14[3] = &unk_24BFD91F0;
  v14[4] = &v48;
  v14[5] = &v42;
  v14[6] = &v36;
  v14[7] = v34;
  v14[8] = &v27;
  v14[9] = &v19;
  v14[10] = &v15;
  SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v14);
  v7 = *(_OWORD *)(v49 + 7);
  *(_OWORD *)((char *)this + 232) = *(_OWORD *)(v49 + 5);
  *(_OWORD *)((char *)this + 248) = v7;
  v8 = *(_OWORD *)(v43 + 7);
  *(_OWORD *)((char *)this + 264) = *(_OWORD *)(v43 + 5);
  *(_OWORD *)((char *)this + 280) = v8;
  v9 = *(_OWORD *)(v37 + 7);
  *(_OWORD *)((char *)this + 296) = *(_OWORD *)(v37 + 5);
  *(_OWORD *)((char *)this + 312) = v9;
  *(_OWORD *)((char *)this + 360) = *(_OWORD *)(v28 + 5);
  if (SVGAttributeMap::hasAttribute((uint64_t)a2, 0x1Au))
    v10 = v34;
  else
    v10 = &v36;
  *(_OWORD *)((char *)this + 328) = *(_OWORD *)(v10[1] + 40);
  if (SVGAttributeMap::hasAttribute((uint64_t)a2, 0x1Bu))
    v11 = v34;
  else
    v11 = &v36;
  *(_OWORD *)((char *)this + 344) = *(_OWORD *)(v11[1] + 56);
  v12 = *(_OWORD *)(v20 + 9);
  v13 = *(_OWORD *)(v20 + 5);
  *((_OWORD *)this + 25) = *(_OWORD *)(v20 + 7);
  *((_OWORD *)this + 26) = v12;
  *((_OWORD *)this + 24) = v13;
  *((_DWORD *)this + 94) = *((_DWORD *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v27, 8);
  _Block_object_dispose(v34, 8);
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v42, 8);
  _Block_object_dispose(&v48, 8);
}

void sub_20678828C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  uint64_t v52;

  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a52, 8);
  _Block_object_dispose((const void *)(v52 - 208), 8);
  _Block_object_dispose((const void *)(v52 - 136), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN11SVGGradient17updatedAttributesEP15SVGAttributeMap_block_invoke(_QWORD *a1, int a2, os_unfair_lock_s *this)
{
  int os_unfair_lock_opaque;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  const char *v12;
  uint64_t v14;
  int v15;
  uint64_t v17;
  int v18;
  uint64_t v20;
  int v21;

  os_unfair_lock_opaque = this[12]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque <= 46)
  {
    if (os_unfair_lock_opaque > 25)
    {
      if (os_unfair_lock_opaque != 26)
      {
        if (os_unfair_lock_opaque != 27)
          return;
        v7 = a1[7];
        goto LABEL_21;
      }
      v6 = a1[7];
    }
    else
    {
      if (os_unfair_lock_opaque != 9)
      {
        if (os_unfair_lock_opaque != 10)
          return;
        v7 = a1[6];
LABEL_21:
        v10 = *(_QWORD *)(v7 + 8) + 56;
        goto LABEL_26;
      }
      v6 = a1[6];
    }
LABEL_25:
    v10 = *(_QWORD *)(v6 + 8) + 40;
LABEL_26:
    if (!SVGAttribute::lengthValue((uint64_t)this, v10))
    {
LABEL_27:
      v11 = SVGAtom::ToString(this[12]._os_unfair_lock_opaque);
      SVGUtilities::log((SVGUtilities *)"SVGGradient: Attribute parse error: %s\n", v12, v11);
    }
    return;
  }
  switch(os_unfair_lock_opaque)
  {
    case 'D':
      v6 = a1[4];
      goto LABEL_25;
    case 'E':
      v6 = a1[5];
      goto LABEL_25;
    case 'F':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
      return;
    case 'G':
      v7 = a1[4];
      goto LABEL_21;
    case 'H':
      v7 = a1[5];
      goto LABEL_21;
    case 'N':
      if ((SVGAttribute::transformValue(this, (CGAffineTransform *)(*(_QWORD *)(a1[9] + 8) + 40)) & 1) == 0)
        goto LABEL_27;
      return;
    default:
      if (os_unfair_lock_opaque == 47)
      {
        v6 = a1[8];
        goto LABEL_25;
      }
      if (os_unfair_lock_opaque != 130)
        return;
      v8 = SVGAttribute::stringValue((SVGAttribute *)this);
      v9 = *(char *)(v8 + 23);
      if (v9 < 0)
      {
        if (*(_QWORD *)(v8 + 8) != 3)
          goto LABEL_35;
        v8 = *(_QWORD *)v8;
      }
      else if (v9 != 3)
      {
        goto LABEL_35;
      }
      if (*(_WORD *)v8 == 24944 && *(_BYTE *)(v8 + 2) == 100)
      {
        *(_DWORD *)(*(_QWORD *)(a1[10] + 8) + 24) = 0;
        return;
      }
LABEL_35:
      v14 = SVGAttribute::stringValue((SVGAttribute *)this);
      v15 = *(char *)(v14 + 23);
      if (v15 < 0)
      {
        if (*(_QWORD *)(v14 + 8) != 7)
          goto LABEL_44;
        v14 = *(_QWORD *)v14;
      }
      else if (v15 != 7)
      {
        goto LABEL_44;
      }
      if (*(_DWORD *)v14 == 1818649970 && *(_DWORD *)(v14 + 3) == 1952671084)
      {
        v20 = *(_QWORD *)(a1[10] + 8);
        v21 = 1;
        goto LABEL_57;
      }
LABEL_44:
      v17 = SVGAttribute::stringValue((SVGAttribute *)this);
      v18 = *(char *)(v17 + 23);
      if (v18 < 0)
      {
        if (*(_QWORD *)(v17 + 8) != 6)
          return;
        v17 = *(_QWORD *)v17;
      }
      else if (v18 != 6)
      {
        return;
      }
      if (*(_DWORD *)v17 == 1701864818 && *(_WORD *)(v17 + 4) == 29793)
      {
        v20 = *(_QWORD *)(a1[10] + 8);
        v21 = 2;
LABEL_57:
        *(_DWORD *)(v20 + 24) = v21;
      }
      return;
  }
}

void SVGGradient::addStop(SVGGradient *this, const SVGGradientStop *a2)
{
  SVGGradientStop *v4;
  unint64_t v5;
  SVGGradientStop **v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  SVGGradientStop **v14;
  char *v15;
  char *v16;
  char *v17;
  SVGGradientStop *v18;

  v4 = (SVGGradientStop *)operator new();
  SVGGradientStop::SVGGradientStop(v4, a2);
  v5 = *((_QWORD *)this + 28);
  v6 = (SVGGradientStop **)*((_QWORD *)this + 27);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *((_QWORD *)this + 26);
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 224, v12);
    else
      v13 = 0;
    v14 = (SVGGradientStop **)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)*((_QWORD *)this + 26);
    v16 = (char *)*((_QWORD *)this + 27);
    if (v16 != v17)
    {
      do
      {
        v18 = (SVGGradientStop *)*((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)*((_QWORD *)this + 26);
    }
    *((_QWORD *)this + 26) = v14;
    *((_QWORD *)this + 27) = v7;
    *((_QWORD *)this + 28) = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  *((_QWORD *)this + 27) = v7;
}

void sub_206788690(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40C1F8F287);
  _Unwind_Resume(a1);
}

BOOL SVGGradient::isEqual(SVGGradient *this, const SVGGradient *a2)
{
  __int128 v4;
  __int128 v5;
  _BOOL8 result;
  __int128 v7;
  __int128 v8;
  const SVGGradientStop **v9;
  const SVGGradientStop **v10;
  SVGGradientStop **v11;
  _OWORD v12[2];
  _OWORD v13[2];
  _OWORD v14[2];
  _OWORD v15[2];

  v4 = *(_OWORD *)((char *)this + 248);
  v15[0] = *(_OWORD *)((char *)this + 232);
  v15[1] = v4;
  v5 = *(_OWORD *)((char *)a2 + 248);
  v14[0] = *(_OWORD *)((char *)a2 + 232);
  v14[1] = v5;
  result = CGSVGPointEqualToPoint((uint64_t)v15, (uint64_t)v14);
  if (result)
  {
    v7 = *(_OWORD *)((char *)this + 280);
    v13[0] = *(_OWORD *)((char *)this + 264);
    v13[1] = v7;
    v8 = *(_OWORD *)((char *)a2 + 280);
    v12[0] = *(_OWORD *)((char *)a2 + 264);
    v12[1] = v8;
    result = CGSVGPointEqualToPoint((uint64_t)v13, (uint64_t)v12);
    if (result)
    {
      if (*((_DWORD *)this + 50) == *((_DWORD *)a2 + 50)
        && *((_DWORD *)this + 94) == *((_DWORD *)a2 + 94)
        && (v10 = (const SVGGradientStop **)*((_QWORD *)a2 + 26),
            v9 = (const SVGGradientStop **)*((_QWORD *)a2 + 27),
            v11 = (SVGGradientStop **)*((_QWORD *)this + 26),
            (char *)v9 - (char *)v10 == *((_QWORD *)this + 27) - (_QWORD)v11))
      {
        if (v10 != v9)
        {
          while (v11 != *((SVGGradientStop ***)this + 27))
          {
            result = SVGGradientStop::isEqual(*v11, *v10);
            if (result)
            {
              ++v10;
              ++v11;
              result = 1;
              if (v10 != *((const SVGGradientStop ***)a2 + 27))
                continue;
            }
            return result;
          }
        }
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t SVGGradient::setParentGradient(SVGGradient *this, const SVGGradient *a2)
{
  *((_QWORD *)this + 54) = a2;
  return SVGGradient::inheritParentGradient(this);
}

uint64_t SVGGradient::inheritParentGradient(SVGGradient *this)
{
  uint64_t v2;
  uint64_t v4;
  SVGGradientStop **v5;
  SVGGradientStop **v6;
  SVGGradientStop *v7;
  SVGGradientStop *v8;
  _QWORD v9[5];

  v2 = *(_QWORD *)(*((_QWORD *)this + 54) + 56);
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = ___ZN11SVGGradient21inheritParentGradientEv_block_invoke;
  v9[3] = &__block_descriptor_tmp_11;
  v9[4] = this;
  SVGAttributeMap::enumerate(v2, (uint64_t)v9);
  if (*((_QWORD *)this + 12) == *((_QWORD *)this + 11))
  {
    v4 = *((_QWORD *)this + 54);
    v5 = *(SVGGradientStop ***)(v4 + 208);
    v6 = *(SVGGradientStop ***)(v4 + 216);
    while (v5 != v6)
    {
      v7 = *v5++;
      v8 = SVGGradientStop::copy(v7);
      SVGGradient::addStop(this, v8);
      CFRetained::release((CFTypeRef *)v8);
    }
  }
  return (*(uint64_t (**)(SVGGradient *, _QWORD))(*(_QWORD *)this + 24))(this, *((_QWORD *)this + 7));
}

void ___ZN11SVGGradient21inheritParentGradientEv_block_invoke(uint64_t a1, unsigned int a2, const SVGAttribute *a3)
{
  uint64_t v4;
  SVGAttribute *v5;

  v4 = *(_QWORD *)(a1 + 32);
  if ((SVGAttributeMap::hasAttribute(*(_QWORD *)(v4 + 56), a2) & 1) == 0)
  {
    v5 = (SVGAttribute *)operator new();
    SVGAttribute::SVGAttribute(v5, a3);
    SVGAttributeMap::setAttribute(*(_QWORD *)(v4 + 56), (uint64_t)v5, 0);
    CFRetained::release((CFTypeRef *)v5);
  }
}

void sub_2067888FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void SVGGradient::print(SVGGradient *this, const char *a2)
{
  SVGUtilities *v3;
  SVGUtilities *v4;
  SVGGradientStop **v5;
  SVGGradientStop **v6;
  SVGGradientStop *v7;

  v3 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"Gradient: %lu stop(s)\n", a2, (uint64_t)(*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 3);
  SVGUtilities::indent(v3);
  v6 = (SVGGradientStop **)*((_QWORD *)this + 26);
  v5 = (SVGGradientStop **)*((_QWORD *)this + 27);
  while (v6 != v5)
  {
    v7 = *v6++;
    SVGGradientStop::print(v7);
  }
  SVGUtilities::unindent(v4);
}

uint64_t CGSVGImageGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_2067889D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGImageCreateWithNoImage(BOOL a1)
{
  SVGImage *v2;

  v2 = (SVGImage *)operator new();
  SVGImage::SVGImage(v2, a1);
  return *((_QWORD *)v2 + 5);
}

void sub_206788A30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40F9C81853);
  _Unwind_Resume(a1);
}

CGImage *CGSVGImageCreateWithRasterImage(CGImage *result)
{
  CGImage *v1;
  SVGImage *v2;

  if (result)
  {
    v1 = result;
    v2 = (SVGImage *)operator new();
    SVGImage::SVGImage(v2, v1);
    return (CGImage *)*((_QWORD *)v2 + 5);
  }
  return result;
}

void sub_206788A9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40F9C81853);
  _Unwind_Resume(a1);
}

uint64_t CGSVGImageCreateWithSVGDocument(uint64_t result)
{
  SVGImage *v1;

  if (result)
  {
    v1 = (SVGImage *)operator new();
    SVGImage::SVGImage(v1, 1);
    return *((_QWORD *)v1 + 5);
  }
  return result;
}

void sub_206788B04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40F9C81853);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGImageRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGImageRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

unsigned int *CGSVGImageGetType(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGImage>(a1, a2);
  if (result)
    return (unsigned int *)result[70];
  return result;
}

void *CFRetained::getObject<SVGImage>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

CGImage *CGSVGImageGetRasterImage(uint64_t a1, const char *a2)
{
  CGImage *result;
  CGImage *v3;

  v3 = 0;
  result = (CGImage *)CFRetained::getObject<SVGImage>(a1, a2);
  if (result)
  {
    SVGImage::rasterImage(result, &v3);
    return v3;
  }
  return result;
}

SVGImage *CGSVGImageGetSVGDocument(uint64_t a1, const char *a2)
{
  SVGImage *result;
  SVGDocument *v3;

  v3 = 0;
  result = (SVGImage *)CFRetained::getObject<SVGImage>(a1, a2);
  if (result)
  {
    SVGImage::svgImage(result, &v3);
    if (v3)
      return (SVGImage *)*((_QWORD *)v3 + 5);
    else
      return 0;
  }
  return result;
}

uint64_t CGSVGDocumentGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGDocument::kSVGDocumentClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206788C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGDocumentCreate(double a1, double a2)
{
  SVGDocument *v4;
  uint64_t result;
  uint64_t v6;

  v4 = (SVGDocument *)operator new();
  SVGDocument::SVGDocument(v4);
  result = *((_QWORD *)v4 + 5);
  v6 = *((_QWORD *)v4 + 6);
  *(double *)(v6 + 216) = a1;
  *(double *)(v6 + 224) = a2;
  return result;
}

void sub_206788CF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4079506790);
  _Unwind_Resume(a1);
}

uint64_t CGSVGDocumentCreateFromURL(const __CFURL *a1, const __CFDictionary *a2)
{
  SVGDocument *v4;
  SVGReaderOptions *Options;
  BOOL v6;

  v4 = (SVGDocument *)operator new();
  SVGDocument::SVGDocument(v4);
  Options = (SVGReaderOptions *)CreateReadOptions(a2);
  v6 = SVGDocument::read(v4, a1, Options);
  if (Options)
  {
    SVGReaderOptions::~SVGReaderOptions(Options);
    MEMORY[0x20BCFC038]();
  }
  if (v6)
  {
    SVGDocument::validateSizes(v4);
    return *((_QWORD *)v4 + 5);
  }
  else
  {
    CFRetained::release((CFTypeRef *)v4);
    return 0;
  }
}

void sub_206788DC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4079506790);
  _Unwind_Resume(a1);
}

uint64_t CGSVGDocumentCreateFromDataProvider(CGDataProvider *a1, const __CFDictionary *a2)
{
  SVGDocument *v4;
  SVGReaderOptions *Options;
  BOOL v6;

  v4 = (SVGDocument *)operator new();
  SVGDocument::SVGDocument(v4);
  Options = (SVGReaderOptions *)CreateReadOptions(a2);
  v6 = SVGDocument::read(v4, a1, Options);
  if (Options)
  {
    SVGReaderOptions::~SVGReaderOptions(Options);
    MEMORY[0x20BCFC038]();
  }
  if (v6)
  {
    SVGDocument::validateSizes(v4);
    return *((_QWORD *)v4 + 5);
  }
  else
  {
    CFRetained::release((CFTypeRef *)v4);
    return 0;
  }
}

void sub_206788E8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4079506790);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGDocumentRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGDocumentRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

BOOL CGSVGDocumentWriteToData(uint64_t a1, char *a2, const __CFDictionary *a3)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL8 v8;

  v5 = CFRetained::getObject<SVGDocument>(a1, a2);
  if (!v5)
    return 0;
  v6 = (uint64_t)v5;
  v7 = CreateWriteOptions(a3);
  v8 = SVGDocument::write(v6, (__CFData *)a2, v7);
  if (v7)
    MEMORY[0x20BCFC038](v7, 0x1000C4033FC2DF1);
  return v8;
}

uint64_t CreateWriteOptions(const __CFDictionary *a1)
{
  uint64_t v2;
  const __CFBoolean *Value;
  const __CFBoolean *v4;
  CFTypeID TypeID;
  const __CFBoolean *v6;
  const __CFBoolean *v7;
  CFTypeID v8;

  if (!a1 || CFDictionaryGetCount(a1) < 1)
    return 0;
  v2 = operator new();
  *(_WORD *)v2 = 0;
  *(_BYTE *)(v2 + 2) = 0;
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("kCGSVGPacked"));
  if (Value)
  {
    v4 = Value;
    TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v4))
    {
      if (CFBooleanGetValue(v4))
        *(_BYTE *)(v2 + 1) = 1;
    }
  }
  v6 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("kCGSVGOmitHeaders"));
  if (v6)
  {
    v7 = v6;
    v8 = CFBooleanGetTypeID();
    if (v8 == CFGetTypeID(v7))
    {
      if (CFBooleanGetValue(v7))
        *(_BYTE *)(v2 + 2) = 1;
    }
  }
  return v2;
}

BOOL CGSVGDocumentWriteToURL(uint64_t a1, const char *a2, const __CFDictionary *a3)
{
  _BOOL8 v3;
  void *v6;
  uint64_t v7;

  v3 = 0;
  if (a1)
  {
    if (a2)
    {
      v6 = CFRetained::getObject<SVGDocument>(a1, a2);
      v7 = CreateWriteOptions(a3);
      v3 = SVGDocument::write((uint64_t)v6, (const __CFURL *)a2, v7);
      if (v7)
        MEMORY[0x20BCFC038](v7, 0x1000C4033FC2DF1);
    }
  }
  return v3;
}

SVGDocument *CGSVGDocumentGetCanvas(uint64_t a1, const char *a2)
{
  SVGDocument *result;

  result = (SVGDocument *)CFRetained::getObject<SVGDocument>(a1, a2);
  if (result)
    return (SVGDocument *)*((_QWORD *)SVGDocument::canvas(result) + 5);
  return result;
}

SVGDocument *CGSVGDocumentContainsWideGamutContent(uint64_t a1, const char *a2)
{
  SVGDocument *result;

  result = (SVGDocument *)CFRetained::getObject<SVGDocument>(a1, a2);
  if (result)
    return (SVGDocument *)SVGDocument::hasWideGamutContent(result);
  return result;
}

void CGSVGDocumentAddNamedStyle(uint64_t a1, const char *a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  const char *v7;
  CFTypeRef *v8;
  void *__p[2];
  char v10;

  v5 = CFRetained::getObject<SVGDocument>(a1, a2);
  if (v5)
  {
    v6 = (uint64_t)v5;
    SVGUtilities::StringWithCFString((const __CFString *)a2, __p);
    v8 = (CFTypeRef *)CFRetained::getObject<SVGAttributeMap>(a3, v7);
    if (v8)
      SVGDocument::addNamedStyle(v6, (uint64_t)__p, v8);
    if (v10 < 0)
      operator delete(__p[0]);
  }
}

void sub_206789180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SVGDocument *CGSVGDocumentIsMonochrome(uint64_t a1, const char *a2)
{
  SVGDocument *result;

  result = (SVGDocument *)CFRetained::getObject<SVGDocument>(a1, a2);
  if (result)
    return (SVGDocument *)SVGDocument::hasMonochromeContent(result);
  return result;
}

void CGSVGDocumentDefsAddNode(uint64_t a1, const char *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  SVGNode *v7;
  const char *v8;
  SVGNode *v9;
  SVGNode *v10;

  v3 = CFRetained::getObject<SVGDocument>(a1, a2);
  if (v3)
  {
    v4 = v3[6];
    if (v4)
    {
      v5 = *(_QWORD *)(v4 + 40);
      if (v5)
      {
        v6 = *(const void **)(v5 + 16);
        if (v6)
        {
          if (v7)
          {
            v9 = v7;
            v10 = (SVGNode *)CFRetained::getObject<SVGNode>((uint64_t)a2, v8);
            if (v10)
              SVGNode::addDefinitionNode(v9, v9, v10);
          }
        }
      }
    }
  }
}

const __CFString *CGSVGDocumentDefsGetNode(uint64_t a1, const char *a2)
{
  const __CFString *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  SVGNode *v7;
  SVGNode *v8;
  char *v9;
  SVGNode *DefinitionNode;
  SVGNode *v11;
  void *__p[2];
  char v14;

  v2 = (const __CFString *)a2;
  v3 = CFRetained::getObject<SVGDocument>(a1, a2);
  if (!v3)
    return 0;
  v4 = v3[6];
  if (!v4)
    return 0;
  v5 = *(_QWORD *)(v4 + 40);
  if (!v5)
    return 0;
  v6 = *(const void **)(v5 + 16);
  if (!v6)
    return 0;
  if (!v7)
    return 0;
  v8 = v7;
  SVGUtilities::StringWithCFString(v2, __p);
  if (v14 >= 0)
    v9 = (char *)__p;
  else
    v9 = (char *)__p[0];
  DefinitionNode = SVGNode::findDefinitionNode(v8, v9);
  v11 = DefinitionNode;
  if (DefinitionNode)
    v2 = (const __CFString *)*((_QWORD *)DefinitionNode + 5);
  if (v14 < 0)
    operator delete(__p[0]);
  if (!v11)
    return 0;
  return v2;
}

void sub_2067892FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CGSVGDocumentDefsEnumerate(uint64_t a1, const char *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  _QWORD v7[5];

  v3 = CFRetained::getObject<SVGDocument>(a1, a2);
  if (v3)
  {
    v4 = v3[6];
    if (v4)
    {
      v5 = *(_QWORD *)(v4 + 40);
      if (v5)
      {
        v6 = *(void **)(v5 + 16);
        if (v6)
        v7[0] = MEMORY[0x24BDAC760];
        v7[1] = 0x40000000;
        v7[2] = __CGSVGDocumentDefsEnumerate_block_invoke;
        v7[3] = &unk_24BFD9260;
        v7[4] = a2;
        SVGNode::enumerate((uint64_t)v6, (uint64_t)v7);
      }
    }
  }
}

void CopyOptionsIntoMap(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  const char *v5;
  void **v6;
  uint64_t v7;
  CFTypeRef *v8;
  void *__p[2];
  char v10;
  void *v11[2];
  char v12;

  SVGUtilities::StringWithCFString(a1, v11);
  SVGUtilities::StringWithCFString(a2, __p);
  if (v12 >= 0)
    v6 = v11;
  else
    v6 = (void **)v11[0];
  v7 = SVGAtom::ToName((SVGAtom *)v6, v5);
  v8 = (CFTypeRef *)operator new();
  SVGAttribute::SVGAttribute(v8, v7, __p);
  SVGAttributeMap::setAttribute(a3, (uint64_t)v8, 0);
  CFRetained::release(v8);
  if (v10 < 0)
    operator delete(__p[0]);
  if (v12 < 0)
    operator delete(v11[0]);
}

void sub_2067894DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  MEMORY[0x20BCFC038](v20, 0x10B3C405B4D0908);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(a1);
}

SVGAtom *CGSVGAtomFromCString(SVGAtom *result, const char *a2)
{
  if (result)
    return (SVGAtom *)SVGAtom::ToName(result, a2);
  return result;
}

void SVGClipPath::SVGClipPath(SVGClipPath *this, char *a2)
{
  SVGNode *v3;

  v3 = (SVGNode *)SVGNode::SVGNode((uint64_t)this, 5u);
  *(_QWORD *)v3 = &off_24BFD8AE8;
  *((_QWORD *)v3 + 25) = 0;
  *((_QWORD *)v3 + 26) = 1;
  SVGNode::setIdentifier(v3, a2);
}

void sub_206789594(_Unwind_Exception *a1)
{
  SVGNode *v1;

  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

void SVGClipPath::SVGClipPath(SVGClipPath *this, const SVGAttributeMap **a2)
{
  _QWORD *v4;

  SVGNode::SVGNode(this, a2);
  *v4 = &off_24BFD8AE8;
  v4[26] = 1;
  *((_QWORD *)this + 25) = CGPathCreateMutableCopy(a2[25]);
}

void sub_2067895F8(_Unwind_Exception *a1)
{
  SVGNode *v1;

  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

void SVGClipPath::~SVGClipPath(SVGClipPath *this)
{
  const CGPath *v2;

  *(_QWORD *)this = &off_24BFD8AE8;
  v2 = (const CGPath *)*((_QWORD *)this + 25);
  if (v2)
  {
    CGPathRelease(v2);
    *((_QWORD *)this + 25) = 0;
  }
  SVGNode::~SVGNode(this);
}

{
  SVGClipPath::~SVGClipPath(this);
  JUMPOUT(0x20BCFC038);
}

void SVGClipPath::releaseCGPath(SVGClipPath *this)
{
  const CGPath *v2;

  v2 = (const CGPath *)*((_QWORD *)this + 25);
  if (v2)
  {
    CGPathRelease(v2);
    *((_QWORD *)this + 25) = 0;
  }
}

void SVGClipPath::updatedAttributes(SVGClipPath *this, SVGAttributeMap *a2)
{
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 1;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN11SVGClipPath17updatedAttributesEP15SVGAttributeMap_block_invoke;
  v3[3] = &unk_24BFD9298;
  v3[4] = &v4;
  SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v3);
  *((_DWORD *)this + 52) = *((_DWORD *)v5 + 6);
  _Block_object_dispose(&v4, 8);
}

void sub_20678973C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11SVGClipPath17updatedAttributesEP15SVGAttributeMap_block_invoke(uint64_t result, int a2, SVGAttribute *this)
{
  uint64_t v3;
  const std::string *v4;

  if (*((_DWORD *)this + 12) == 7)
  {
    v3 = result;
    v4 = (const std::string *)SVGAttribute::stringValue(this);
    result = std::string::compare(v4, "objectBoundingBox");
    if (!(_DWORD)result)
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = 0;
  }
  return result;
}

CGMutablePathRef SVGClipPath::getCGClippingPath(SVGClipPath *this, SVGNode *a2)
{
  const char *v4;
  int v5;
  CGMutablePathRef Mutable;
  CGFloat v7;
  double BoundingBoxWithOptions;
  CGFloat v9;
  CGFloat v10;
  double v11;
  double v12;
  double v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  SVGAtom *v18;
  unsigned int v19;
  SVGShapeNode *v20;
  _OWORD *SVGPath;
  CFTypeRef *v22;
  CGPath *CGPath;
  __int128 v24;
  CGAffineTransform v26;
  CGAffineTransform t1;
  CGAffineTransform m;
  __int128 v29;
  os_unfair_lock_t v30;

  SVGScopedUnfairLock::SVGScopedUnfairLock((SVGScopedUnfairLock *)&v30, (os_unfair_lock_t)this + 53);
  v5 = *((_DWORD *)this + 52);
  if (a2 || v5)
  {
    v7 = *MEMORY[0x24BDBD8B8];
    v29 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 8);
    if (v5)
    {
      v9 = *(double *)(MEMORY[0x24BDBD8B8] + 24);
      BoundingBoxWithOptions = *(double *)(MEMORY[0x24BDBD8B8] + 32);
      v10 = *(double *)(MEMORY[0x24BDBD8B8] + 40);
    }
    else
    {
      BoundingBoxWithOptions = CGSVGNodeGetBoundingBoxWithOptions(*((_QWORD *)a2 + 5), 0, 0);
      v10 = v11;
      v7 = v12;
      v9 = v13;
      v29 = 0uLL;
    }
    Mutable = (CGMutablePathRef)*((_QWORD *)this + 25);
    if (!Mutable)
    {
      Mutable = CGPathCreateMutable();
      *((_QWORD *)this + 25) = Mutable;
      v15 = *((_QWORD *)this + 11);
      v16 = *((_QWORD *)this + 12);
      if (v15 != v16)
      {
        do
        {
          v17 = *(const void **)v15;
          v18 = (SVGAtom *)(*(_QWORD *)v15 + 64);
          if (*(char *)(*(_QWORD *)v15 + 87) < 0)
            v18 = *(SVGAtom **)v18;
          v19 = SVGAtom::ToName(v18, v14);
          if (SVGShapeNode::IsValidShapePrimitive(v19))
          {
            if (v20)
            {
              SVGPath = SVGShapeNode::createSVGPath(v20);
              v22 = (CFTypeRef *)SVGPath;
              if (SVGPath)
              {
                CGPath = CGSVGPathCreateCGPath(*((_QWORD *)SVGPath + 5), v14);
                memset(&m, 0, sizeof(m));
                *(_OWORD *)&t1.b = v29;
                t1.a = v7;
                t1.d = v9;
                t1.tx = BoundingBoxWithOptions;
                t1.ty = v10;
                v24 = *((_OWORD *)v22 + 6);
                *(_OWORD *)&v26.a = *((_OWORD *)v22 + 5);
                *(_OWORD *)&v26.c = v24;
                *(_OWORD *)&v26.tx = *((_OWORD *)v22 + 7);
                CGAffineTransformConcat(&m, &t1, &v26);
                CGPathAddPath(*((CGMutablePathRef *)this + 25), &m, CGPath);
                CGPathRelease(CGPath);
                CFRetained::release(v22);
              }
            }
          }
          v15 += 8;
        }
        while (v15 != v16);
        Mutable = (CGMutablePathRef)*((_QWORD *)this + 25);
      }
    }
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"objectBoundingBox option was given without a relative object.", v4);
    Mutable = 0;
  }
  SVGScopedUnfairLock::~SVGScopedUnfairLock(&v30);
  return Mutable;
}

void sub_206789970(_Unwind_Exception *a1)
{
  uint64_t v1;

  SVGScopedUnfairLock::~SVGScopedUnfairLock((os_unfair_lock_t *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t SVGClipPath::print(uint64_t this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *(uint64_t **)(this + 88);
  v2 = *(uint64_t **)(this + 96);
  while (v1 != v2)
  {
    v3 = *v1++;
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  }
  return this;
}

uint64_t CGSVGPathCommandGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPathCommand::kSVGPathCommandClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206789A28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unsigned int *CGSVGPathCommandGetType(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGPathCommand>(a1, a2);
  if (result)
    return (unsigned int *)result[12];
  return result;
}

void CGSVGPathCommandAppendFloats(uint64_t a1, char *__src, uint64_t a3)
{
  const char *v4;
  void *v5;
  void *__p;
  void *v7;
  uint64_t v8;

  __p = 0;
  v7 = 0;
  v8 = 0;
  SVGUtilities::CGFloatListFromFloats(__src, a3, (uint64_t)&__p);
  v5 = CFRetained::getObject<SVGPathCommand>(a1, v4);
  if (v5)
    SVGPathCommand::appendFloats((uint64_t)v5, (char **)&__p);
  if (__p)
  {
    v7 = __p;
    operator delete(__p);
  }
}

void sub_206789AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CGSVGPathCommandAppendPoint(uint64_t a1, const char *a2, CGFloat a3, CGFloat a4)
{
  SVGPathCommand *v6;
  CGPoint v7;

  v6 = (SVGPathCommand *)CFRetained::getObject<SVGPathCommand>(a1, a2);
  if (v6)
  {
    v7.x = a3;
    v7.y = a4;
    SVGPathCommand::appendPoint(v6, v7);
  }
}

_QWORD *CGSVGPathCommandGetFloatCount(uint64_t a1, const char *a2)
{
  _QWORD *result;
  _QWORD *v3;

  result = CFRetained::getObject<SVGPathCommand>(a1, a2);
  if (result)
  {
    v3 = (_QWORD *)result[7];
    if (v3)
      return (_QWORD *)((uint64_t)(v3[1] - *v3) >> 3);
    else
      return 0;
  }
  return result;
}

uint64_t CGSVGPathGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPath::kSVGPathClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206789BA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGPathCreate()
{
  SVGPath *v0;

  v0 = (SVGPath *)operator new();
  SVGPath::SVGPath(v0);
  return *((_QWORD *)v0 + 5);
}

void sub_206789C00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40176D6E88);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGPathRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGPathRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

SVGPath *CGSVGPathAppendCommand(uint64_t a1, const char *a2)
{
  SVGPath *result;
  SVGPath *v4;
  SVGPathCommand *v5;

  result = (SVGPath *)CFRetained::getObject<SVGPath>(a1, a2);
  if (result)
  {
    v4 = result;
    v5 = (SVGPathCommand *)operator new();
    SVGPathCommand::SVGPathCommand(v5, a2);
    SVGPath::addCommand(v4, v5);
    CFRetained::release((CFTypeRef *)v5);
    return (SVGPath *)*((_QWORD *)v5 + 5);
  }
  return result;
}

void sub_206789CC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40A582917CLL);
  _Unwind_Resume(a1);
}

_QWORD *CGSVGPathGetCommandCount(uint64_t a1, const char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGPath>(a1, a2);
  if (result)
    return (_QWORD *)((uint64_t)(result[7] - result[6]) >> 3);
  return result;
}

_QWORD *CGSVGPathGetCommandAtIndex(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v4;

  result = CFRetained::getObject<SVGPath>(a1, a2);
  if (result)
  {
    v4 = result[6];
    if ((unint64_t)a2 >= (result[7] - v4) >> 3)
      return 0;
    else
      return *(_QWORD **)(*(_QWORD *)(v4 + 8 * (_QWORD)a2) + 40);
  }
  return result;
}

uint64_t CGSVGPathCreateWithPathDescription(const __CFString *a1)
{
  const char *v1;
  void **v2;
  uint64_t v3;
  void *__p[2];
  char v6;

  if (!a1)
    return 0;
  SVGUtilities::StringWithCFString(a1, __p);
  if (v6 < 0)
  {
    if (!__p[1])
    {
      v3 = 0;
LABEL_11:
      operator delete(__p[0]);
      return v3;
    }
    v2 = (void **)__p[0];
    goto LABEL_8;
  }
  if (!v6)
    return 0;
  v2 = __p;
LABEL_8:
  v3 = *((_QWORD *)SVGParser::ParseCommandList((SVGParser *)v2, v1) + 5);
  if (v6 < 0)
    goto LABEL_11;
  return v3;
}

void sub_206789DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFStringRef CGSVGPathCreatePathDescription(uint64_t a1, const char *a2)
{
  SVGPath *v2;
  std::string *p_p;
  CFStringRef v4;
  std::string __p;

  v2 = (SVGPath *)CFRetained::getObject<SVGPath>(a1, a2);
  if (!v2)
    return 0;
  SVGPath::createStringRepresentation(v2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)p_p, 0x8000100u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v4;
}

void sub_206789E64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Vec2Angle(CGVector a1, CGVector a2)
{
  double v2;
  long double v3;

  v2 = (a1.dy * a2.dy + a1.dx * a2.dx) / (sqrt(a1.dy * a1.dy + a1.dx * a1.dx) * sqrt(a2.dy * a2.dy + a2.dx * a2.dx));
  v3 = -1.0;
  if (v2 >= -1.0)
  {
    v3 = v2;
    if (v2 > 1.0)
      v3 = 1.0;
  }
  fabs(acos(v3));
}

void FilterResult::FilterResult(FilterResult *this, CIImage *a2)
{
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = 0;
}

void FilterResult::~FilterResult(FilterResult *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
    free(v2);

}

double SVGFilterPrimitive::SVGFilterPrimitive(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  double result;

  v3 = SVGNode::SVGNode(a1, a2);
  *(_QWORD *)v3 = &off_24BFD8D38;
  result = 0.0;
  *(_OWORD *)(v3 + 200) = 0u;
  *(_OWORD *)(v3 + 216) = 0u;
  *(_QWORD *)(v3 + 232) = 0;
  *(_DWORD *)(v3 + 240) = a2;
  return result;
}

void SVGFilterPrimitive::~SVGFilterPrimitive(SVGFilterPrimitive *this)
{
  SVGNode::~SVGNode(this);
  JUMPOUT(0x20BCFC038);
}

void SVGFilterPrimitive::draw(SVGFilterPrimitive *a1, const char *a2, uint64_t *a3, uint64_t a4, double a5, double a6, double a7, double a8)
{
  _QWORD *v10;
  uint64_t v11;
  std::string *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  std::string::size_type size;
  BOOL v19;
  BOOL v20;
  std::string::size_type v21;
  int v22;
  uint64_t v27;
  int v28;
  void *__p[2];
  char v30;
  std::string v31;
  _QWORD v32[2];
  _QWORD v33[2];

  *(double *)v33 = a5;
  *(double *)&v33[1] = a6;
  *(double *)v32 = a7;
  *(double *)&v32[1] = a8;
  *((_QWORD *)a1 + 25) = a2;
  v10 = (_QWORD *)((char *)a1 + 200);
  *((_QWORD *)a1 + 26) = *a3;
  *((_QWORD *)a1 + 27) = a4;
  *((_QWORD *)a1 + 28) = v33;
  *((_QWORD *)a1 + 29) = v32;
  v11 = SVGFilterPrimitive::selectPrimitive(a1, a2);
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_20679A6BE);
  SVGFilterPrimitive::stringAttr((uint64_t)a1, 0x5Au, (uint64_t)__p, &v31);
  if (v30 < 0)
    operator delete(__p[0]);
  if ((*((_BYTE *)&v31.__r_.__value_.__s + 23) & 0x80) == 0)
  {
    v12 = &v31;
    switch(*((_BYTE *)&v31.__r_.__value_.__s + 23))
    {
      case 9:
        goto LABEL_31;
      case 0xA:
      case 0xC:
      case 0xE:
        goto LABEL_54;
      case 0xB:
        v13 = *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + 3);
        v14 = v31.__r_.__value_.__r.__words[0] == 0x6C41656372756F53;
        v15 = 0x6168706C41656372;
        goto LABEL_40;
      case 0xD:
        v13 = *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + 5);
        v14 = v31.__r_.__value_.__r.__words[0] == 0x7247656372756F53;
        v15 = 0x6369687061724765;
LABEL_40:
        if (!v14 || v13 != v15)
          goto LABEL_54;
        goto LABEL_56;
      case 0xF:
        if ((v31.__r_.__value_.__r.__words[0] != 0x756F72676B636142
           || *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + 7) != 0x6567616D49646E75)
          && (v31.__r_.__value_.__r.__words[0] != 0x756F72676B636142
           || *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + 7) != 0x6168706C41646E75))
        {
          goto LABEL_54;
        }
        goto LABEL_56;
      default:
        if (&v31)
          goto LABEL_54;
        *a3 = v11;
        v10[4] = 0;
        *(_OWORD *)v10 = 0u;
        *((_OWORD *)v10 + 1) = 0u;
        return;
    }
  }
  size = v31.__r_.__value_.__l.__size_;
  if (v31.__r_.__value_.__l.__size_)
  {
    if (v31.__r_.__value_.__l.__size_ == 11)
    {
      if (*(_QWORD *)v31.__r_.__value_.__l.__data_ == 0x6C41656372756F53
        && *(_QWORD *)(v31.__r_.__value_.__r.__words[0] + 3) == 0x6168706C41656372)
      {
        goto LABEL_56;
      }
      size = v31.__r_.__value_.__l.__size_;
    }
    else if (v31.__r_.__value_.__l.__size_ == 13
           && *(_QWORD *)v31.__r_.__value_.__l.__data_ == 0x7247656372756F53
           && *(_QWORD *)(v31.__r_.__value_.__r.__words[0] + 5) == 0x6369687061724765)
    {
      goto LABEL_56;
    }
    if (size != 15
      || (*(_QWORD *)v31.__r_.__value_.__l.__data_ == 0x756F72676B636142
        ? (v19 = *(_QWORD *)(v31.__r_.__value_.__r.__words[0] + 7) == 0x6567616D49646E75)
        : (v19 = 0),
          !v19
       && ((size = v31.__r_.__value_.__l.__size_, v31.__r_.__value_.__l.__size_ != 15)
        || (*(_QWORD *)v31.__r_.__value_.__l.__data_ == 0x756F72676B636142
          ? (v20 = *(_QWORD *)(v31.__r_.__value_.__r.__words[0] + 7) == 0x6168706C41646E75)
          : (v20 = 0),
            !v20))))
    {
      if (size != 9)
        goto LABEL_54;
      v12 = (std::string *)v31.__r_.__value_.__r.__words[0];
LABEL_31:
      v21 = v12->__r_.__value_.__r.__words[0];
      v22 = v12->__r_.__value_.__s.__data_[8];
      if (v21 != 0x6E6961506C6C6946 || v22 != 116)
      {
LABEL_54:
        if (std::operator!=[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v31, "StrokePaint"))
        {
          v27 = *((_QWORD *)a1 + 27);
          __p[0] = &v31;
          *((_QWORD *)std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v27, (unsigned __int8 *)&v31, (uint64_t)&std::piecewise_construct, (__int128 **)__p)+ 5) = v11;
        }
      }
    }
  }
LABEL_56:
  v28 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
  *a3 = v11;
  *(_OWORD *)v10 = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  v10[4] = 0;
  if (v28 < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
}

void sub_20678A314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGFilterPrimitive::selectPrimitive(SVGFilterPrimitive *this, const char *a2)
{
  SVGAtom *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  _OWORD v9[2];

  v3 = (SVGFilterPrimitive *)((char *)this + 64);
  if (*((char *)this + 87) < 0)
    v3 = *(SVGAtom **)v3;
  v4 = SVGAtom::ToName(v3, a2);
  v5 = 0;
  if (v4 > 102)
  {
    switch(v4)
    {
      case 'x':
        v5 = operator new();
        SVGFilterPrimitive::drawFeConvolveMatrix(this, v9);
        *(_QWORD *)v5 = 0;
        v7 = v9[1];
        *(_OWORD *)(v5 + 8) = v9[0];
        *(_OWORD *)(v5 + 24) = v7;
        break;
      case 'r':
        v5 = operator new();
        SVGFilterPrimitive::drawFeComposite(this);
        v6 = objc_claimAutoreleasedReturnValue();
        goto LABEL_16;
      case 'g':
        v5 = operator new();
        SVGFilterPrimitive::drawFeGaussianBlur(this);
        v6 = objc_claimAutoreleasedReturnValue();
        goto LABEL_16;
    }
  }
  else
  {
    switch(v4)
    {
      case '[':
        v5 = operator new();
        SVGFilterPrimitive::drawFeFlood(this);
        v6 = objc_claimAutoreleasedReturnValue();
        goto LABEL_16;
      case '_':
        v5 = operator new();
        SVGFilterPrimitive::drawFeOffset((double **)this);
        v6 = objc_claimAutoreleasedReturnValue();
        goto LABEL_16;
      case 'e':
        v5 = operator new();
        SVGFilterPrimitive::drawFeBlend(this);
        v6 = objc_claimAutoreleasedReturnValue();
LABEL_16:
        *(_QWORD *)v5 = v6;
        *(_QWORD *)(v5 + 8) = 0;
        break;
    }
  }
  return v5;
}

void sub_20678A4D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x1080C40825B58B5);
  _Unwind_Resume(a1);
}

void SVGFilterPrimitive::stringAttr(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  SVGAttribute *v6;
  uint64_t v7;
  __int128 v8;
  const std::string::value_type *v9;
  std::string::size_type v10;

  v6 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (v6)
  {
    v7 = SVGAttribute::stringValue(v6);
    if ((*(char *)(v7 + 23) & 0x80000000) == 0)
    {
      v8 = *(_OWORD *)v7;
      a4->__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 16);
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = v8;
      return;
    }
    v9 = *(const std::string::value_type **)v7;
    v10 = *(_QWORD *)(v7 + 8);
  }
  else
  {
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
    {
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      a4->__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 16);
      return;
    }
    v9 = *(const std::string::value_type **)a3;
    v10 = *(_QWORD *)(a3 + 8);
  }
  std::string::__init_copy_ctor_external(a4, v9, v10);
}

BOOL std::operator!=[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1)
        goto LABEL_10;
      a1 = (_QWORD *)*a1;
      return memcmp(a1, __s, v4) != 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1)
LABEL_10:
      std::string::__throw_out_of_range[abi:ne180100]();
    return memcmp(a1, __s, v4) != 0;
  }
  return 1;
}

id SVGFilterPrimitive::drawFeGaussianBlur(SVGFilterPrimitive *this)
{
  void *v2;
  const char *v3;
  double v4;
  double v5;
  void *v6;
  void *v7;
  void *v8;
  const __CFString *v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x24BDAC8D0];
  SVGFilterPrimitive::inputImage<CIImage>((uint64_t)this, 0x58u);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    v4 = fmin(SVGFilterPrimitive::pointAttr((uint64_t)this, 0x68u, *MEMORY[0x24BDBEFB0]), 100.0);
    if (v4 != fmin(v5, 100.0))
      SVGUtilities::log((SVGUtilities *)"Different radii for gaussian blur not supported", v3);
    v10 = CFSTR("inputRadius");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v4);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v11[0] = v6;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v11, &v10, 1);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "imageByApplyingFilter:withInputParameters:", CFSTR("CIGaussianBlur"), v7);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v8 = 0;
  }

  return v8;
}

void sub_20678A748(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id SVGFilterPrimitive::drawFeOffset(double **this)
{
  void *v2;
  double v3;
  double v4;
  CGFloat v5;
  void *v6;
  CGAffineTransform v8;
  CGAffineTransform v9;

  SVGFilterPrimitive::inputImage<CIImage>((uint64_t)this, 0x58u);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    v3 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x60u, 0.0);
    v4 = *this[29];
    v5 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x61u, 0.0) * this[29][1];
    memset(&v9, 0, sizeof(v9));
    CGAffineTransformMakeTranslation(&v9, v3 * v4, v5);
    v8 = v9;
    objc_msgSend(v2, "imageByApplyingTransform:", &v8);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_20678A840(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id SVGFilterPrimitive::drawFeFlood(SVGFilterPrimitive *this)
{
  CGColor *CGColor;
  void *v3;
  double *v4;
  double v5;
  double v6;
  void *v7;
  void *v8;
  _OWORD v10[2];
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  char v15[40];
  double v16[3];
  double v17;

  SVGColor::SVGColor((uint64_t)v15, 0, 0.0, 0.0, 0.0, 1.0);
  SVGFilterPrimitive::colorAttr((uint64_t)this, 0x5Cu, v15, (uint64_t)v16);
  v17 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x5Du, 1.0);
  v14 = 0;
  v12 = 0u;
  v13 = 0u;
  CGSVGColorCreateRGBA((uint64_t)&v12, v16[0], v16[1], v16[2], v17);
  v10[0] = v12;
  v10[1] = v13;
  v11 = v14;
  CGColor = CGSVGColorCreateCGColor((uint64_t)v10);
  objc_msgSend(MEMORY[0x24BDBF638], "colorWithCGColor:", CGColor);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  CGColorRelease(CGColor);
  v4 = (double *)*((_QWORD *)this + 28);
  v5 = *v4;
  v6 = v4[1];
  objc_msgSend(MEMORY[0x24BDBF660], "imageWithColor:", v3);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "imageByCroppingToRect:", 0.0, 0.0, v5, v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  return v8;
}

void sub_20678A974(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id SVGFilterPrimitive::drawFeComposite(SVGFilterPrimitive *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  std::string::size_type size;
  std::string *v8;
  const __CFString *v9;
  int data_low;
  int v12;
  double v14;
  double v15;
  double v16;
  double v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *__p[2];
  char v47;
  std::string v48;
  const __CFString *v49;
  void *v50;
  _QWORD v51[5];
  _QWORD v52[5];
  const __CFString *v53;
  void *v54;
  _QWORD v55[5];
  _QWORD v56[5];
  _QWORD v57[5];
  _QWORD v58[5];
  const __CFString *v59;
  uint64_t v60;
  const __CFString *v61;
  void *v62;
  const __CFString *v63;
  _QWORD v64[3];

  v64[1] = *MEMORY[0x24BDAC8D0];
  SVGFilterPrimitive::inputImage<CIImage>((uint64_t)this, 0x58u);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  SVGFilterPrimitive::inputImage<CIImage>((uint64_t)this, 0x59u);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = (void *)v3;
  v5 = 0;
  if (!v2 || !v3)
    goto LABEL_50;
  std::string::basic_string[abi:ne180100]<0>(__p, "over");
  SVGFilterPrimitive::stringAttr((uint64_t)this, 0x73u, (uint64_t)__p, &v48);
  if (v47 < 0)
    operator delete(__p[0]);
  v63 = CFSTR("inputBackgroundImage");
  v64[0] = v4;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v64, &v63, 1);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    size = v48.__r_.__value_.__l.__size_;
    if (v48.__r_.__value_.__l.__size_ == 2)
    {
      if (*(_WORD *)v48.__r_.__value_.__l.__data_ == 28265)
        goto LABEL_30;
      size = v48.__r_.__value_.__l.__size_;
    }
    else if (v48.__r_.__value_.__l.__size_ == 4 && *(_DWORD *)v48.__r_.__value_.__l.__data_ == 1919252079)
    {
      goto LABEL_44;
    }
    if (size == 3)
    {
      if (*(_WORD *)v48.__r_.__value_.__l.__data_ == 30063 && *(_BYTE *)(v48.__r_.__value_.__r.__words[0] + 2) == 116)
        goto LABEL_45;
      size = v48.__r_.__value_.__l.__size_;
    }
    if (size == 4)
    {
      if (*(_DWORD *)v48.__r_.__value_.__l.__data_ == 1886352481)
        goto LABEL_46;
      size = v48.__r_.__value_.__l.__size_;
    }
    if (size == 3)
    {
      v8 = (std::string *)v48.__r_.__value_.__r.__words[0];
      goto LABEL_37;
    }
LABEL_41:
    if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v48, "arithmetic"))
    {
      v14 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x74u, 0.0);
      v15 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x75u, 0.0);
      v16 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x76u, 0.0);
      v17 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x77u, 0.0);
      objc_msgSend(v2, "imageByApplyingFilter:withInputParameters:", CFSTR("CIMultiplyCompositing"), v45);
      v44 = (void *)objc_claimAutoreleasedReturnValue();
      v57[0] = CFSTR("inputRVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", v14, 0.0, 0.0, 0.0);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      v58[0] = v18;
      v57[1] = CFSTR("inputGVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, v14, 0.0, 0.0);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      v58[1] = v19;
      v57[2] = CFSTR("inputBVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, v14, 0.0);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      v58[2] = v20;
      v57[3] = CFSTR("inputAVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, 0.0, v14);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v58[3] = v21;
      v57[4] = CFSTR("inputBiasVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, 0.0, 0.0);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      v58[4] = v22;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v58, v57, 5);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v44, "imageByApplyingFilter:withInputParameters:", CFSTR("CIColorMatrix"), v23);
      v43 = (void *)objc_claimAutoreleasedReturnValue();

      v55[0] = CFSTR("inputRVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", v15, 0.0, 0.0, 0.0);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      v56[0] = v24;
      v55[1] = CFSTR("inputGVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, v15, 0.0, 0.0);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      v56[1] = v25;
      v55[2] = CFSTR("inputBVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, v15, 0.0);
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      v56[2] = v26;
      v55[3] = CFSTR("inputAVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, 0.0, v15);
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      v56[3] = v27;
      v55[4] = CFSTR("inputBiasVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, 0.0, 0.0);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v56[4] = v28;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v56, v55, 5);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "imageByApplyingFilter:withInputParameters:", CFSTR("CIColorMatrix"), v29);
      v42 = (void *)objc_claimAutoreleasedReturnValue();

      v53 = CFSTR("inputBackgroundImage");
      v54 = v42;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v54, &v53, 1);
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v43, "imageByApplyingFilter:withInputParameters:", CFSTR("CIAdditionCompositing"), v30);
      v31 = (void *)objc_claimAutoreleasedReturnValue();

      v51[0] = CFSTR("inputRVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", v16, 0.0, 0.0, 0.0);
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      v52[0] = v32;
      v51[1] = CFSTR("inputGVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, v16, 0.0, 0.0);
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      v52[1] = v33;
      v51[2] = CFSTR("inputBVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, v16, 0.0);
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      v52[2] = v34;
      v51[3] = CFSTR("inputAVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", 0.0, 0.0, 0.0, v16);
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      v52[3] = v35;
      v51[4] = CFSTR("inputBiasVector");
      objc_msgSend(MEMORY[0x24BDBF690], "vectorWithX:Y:Z:W:", v17, v17, v17, v17);
      v36 = (void *)objc_claimAutoreleasedReturnValue();
      v52[4] = v36;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v52, v51, 5);
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "imageByApplyingFilter:withInputParameters:", CFSTR("CIColorMatrix"), v37);
      v38 = (void *)objc_claimAutoreleasedReturnValue();

      v49 = CFSTR("inputBackgroundImage");
      v50 = v38;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v50, &v49, 1);
      v39 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v31, "imageByApplyingFilter:withInputParameters:", CFSTR("CIAdditionCompositing"), v39);
      v5 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_43:
      goto LABEL_48;
    }
    goto LABEL_44;
  }
  if (HIBYTE(v48.__r_.__value_.__r.__words[2]) != 2)
  {
    if (HIBYTE(v48.__r_.__value_.__r.__words[2]) != 3)
    {
      if (HIBYTE(v48.__r_.__value_.__r.__words[2]) != 4)
        goto LABEL_41;
      if (LODWORD(v48.__r_.__value_.__l.__data_) != 1886352481)
      {
        if (LODWORD(v48.__r_.__value_.__l.__data_) != 1919252079)
          goto LABEL_35;
LABEL_44:
        v9 = CFSTR("CISourceOverCompositing");
        goto LABEL_47;
      }
LABEL_46:
      v9 = CFSTR("CISourceAtopCompositing");
      goto LABEL_47;
    }
    if (LOWORD(v48.__r_.__value_.__l.__data_) != 30063 || v48.__r_.__value_.__s.__data_[2] != 116)
    {
LABEL_35:
      if (HIBYTE(v48.__r_.__value_.__r.__words[2]) == 3)
      {
        v8 = &v48;
LABEL_37:
        data_low = LOWORD(v8->__r_.__value_.__l.__data_);
        v12 = v8->__r_.__value_.__s.__data_[2];
        if (data_low == 28536 && v12 == 114)
        {
          objc_msgSend(v2, "imageByApplyingFilter:withInputParameters:", CFSTR("CISourceOutCompositing"), v45);
          v44 = (void *)objc_claimAutoreleasedReturnValue();
          v61 = CFSTR("inputBackgroundImage");
          v62 = v2;
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v62, &v61, 1);
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v4, "imageByApplyingFilter:withInputParameters:", CFSTR("CISourceOutCompositing"));
          v41 = objc_claimAutoreleasedReturnValue();
          v59 = CFSTR("inputBackgroundImage");
          v60 = v41;
          v42 = (void *)v41;
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v60, &v59, 1);
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v44, "imageByApplyingFilter:withInputParameters:", CFSTR("CISourceOverCompositing"), v31);
          v5 = (void *)objc_claimAutoreleasedReturnValue();
          goto LABEL_43;
        }
        goto LABEL_41;
      }
      goto LABEL_41;
    }
LABEL_45:
    v9 = CFSTR("CISourceOutCompositing");
    goto LABEL_47;
  }
  if (LOWORD(v48.__r_.__value_.__l.__data_) != 28265)
    goto LABEL_41;
LABEL_30:
  v9 = CFSTR("CISourceInCompositing");
LABEL_47:
  objc_msgSend(v2, "imageByApplyingFilter:withInputParameters:", v9, v45);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_48:

  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v48.__r_.__value_.__l.__data_);
LABEL_50:

  return v5;
}

void sub_20678B20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  void *v26;
  void *v27;
  void *v28;

  if (a26 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

id SVGFilterPrimitive::drawFeBlend(SVGFilterPrimitive *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  std::string::size_type size;
  std::string *v11;
  int data;
  int v13;
  const __CFString *v15;
  void *__p[2];
  char v21;
  std::string v22;
  const __CFString *v23;
  _QWORD v24[2];

  v24[1] = *MEMORY[0x24BDAC8D0];
  SVGFilterPrimitive::inputImage<CIImage>((uint64_t)this, 0x58u);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  SVGFilterPrimitive::inputImage<CIImage>((uint64_t)this, 0x59u);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = (void *)v3;
  v5 = 0;
  if (!v2 || !v3)
    goto LABEL_54;
  std::string::basic_string[abi:ne180100]<0>(__p, "normal");
  SVGFilterPrimitive::stringAttr((uint64_t)this, 0x66u, (uint64_t)__p, &v22);
  if (v21 < 0)
    operator delete(__p[0]);
  v23 = CFSTR("inputBackgroundImage");
  v24[0] = v4;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v24, &v23, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(v22.__r_.__value_.__r.__words[2]) != 6)
    {
      if (HIBYTE(v22.__r_.__value_.__r.__words[2]) != 7)
      {
        if (HIBYTE(v22.__r_.__value_.__r.__words[2]) != 8 || v22.__r_.__value_.__r.__words[0] != 0x796C7069746C756DLL)
          goto LABEL_51;
        goto LABEL_55;
      }
      v11 = &v22;
LABEL_33:
      data = (int)v11->__r_.__value_.__l.__data_;
      v13 = *(_DWORD *)((char *)v11->__r_.__value_.__r.__words + 3);
      if (data == 1751607660 && v13 == 1852142696)
      {
        v15 = CFSTR("CILightenBlendMode");
        goto LABEL_52;
      }
      goto LABEL_51;
    }
    if (LODWORD(v22.__r_.__value_.__l.__data_) == 1836216174 && WORD2(v22.__r_.__value_.__r.__words[0]) == 27745)
      goto LABEL_51;
    if (LODWORD(v22.__r_.__value_.__l.__data_) != 1701995379 || WORD2(v22.__r_.__value_.__r.__words[0]) != 28261)
    {
      if (LODWORD(v22.__r_.__value_.__l.__data_) != 1802658148 || WORD2(v22.__r_.__value_.__r.__words[0]) != 28261)
        goto LABEL_51;
      goto LABEL_57;
    }
LABEL_56:
    v15 = CFSTR("CIScreenBlendMode");
    goto LABEL_52;
  }
  size = v22.__r_.__value_.__l.__size_;
  if (v22.__r_.__value_.__l.__size_ == 6
    && *(_DWORD *)v22.__r_.__value_.__l.__data_ == 1836216174
    && *(_WORD *)(v22.__r_.__value_.__r.__words[0] + 4) == 27745)
  {
    goto LABEL_51;
  }
  if (v22.__r_.__value_.__l.__size_ == 8)
  {
    if (*(_QWORD *)v22.__r_.__value_.__l.__data_ == 0x796C7069746C756DLL)
    {
LABEL_55:
      v15 = CFSTR("CIMultiplyBlendMode");
      goto LABEL_52;
    }
    size = v22.__r_.__value_.__l.__size_;
  }
  if (size != 6)
    goto LABEL_30;
  if (*(_DWORD *)v22.__r_.__value_.__l.__data_ == 1701995379
    && *(_WORD *)(v22.__r_.__value_.__r.__words[0] + 4) == 28261)
  {
    goto LABEL_56;
  }
  size = v22.__r_.__value_.__l.__size_;
  if (v22.__r_.__value_.__l.__size_ != 6)
  {
LABEL_30:
    if (size == 7)
    {
      v11 = (std::string *)v22.__r_.__value_.__r.__words[0];
      goto LABEL_33;
    }
LABEL_51:
    v15 = CFSTR("CISourceOverCompositing");
    goto LABEL_52;
  }
  if (*(_DWORD *)v22.__r_.__value_.__l.__data_ != 1802658148
    || *(_WORD *)(v22.__r_.__value_.__r.__words[0] + 4) != 28261)
  {
    if ((*((_BYTE *)&v22.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_51;
    goto LABEL_30;
  }
LABEL_57:
  v15 = CFSTR("CIDarkenBlendMode");
LABEL_52:
  objc_msgSend(v2, "imageByApplyingFilter:withInputParameters:", v15, v6);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
LABEL_54:

  return v5;
}

void sub_20678B700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  void *v22;
  void *v23;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void SVGFilterPrimitive::drawFeConvolveMatrix(SVGFilterPrimitive *this@<X0>, _OWORD *a2@<X8>)
{
  const vImage_Buffer *v4;
  const vImage_Buffer *v5;
  uint64_t v6;
  vImage_Buffer *v7;
  uint64_t v8;
  unint64_t v9;
  uint32_t v10;
  __int128 v11;
  double *v12;
  double *v13;
  int v14;
  double v15;
  double v16;
  int32_t divisor;
  double v18;
  __int128 v19;
  uint8_t color[8];
  const int16_t *v21;
  uint64_t v22;
  vImage_Buffer v23;
  vImage_Buffer v24;
  vImage_Buffer buf;
  void *v26;
  void *v27;
  uint64_t v28;

  v4 = (const vImage_Buffer *)SVGFilterPrimitive::inputImage<vImage_Buffer>((uint64_t)this, 0x58u);
  if (v4)
  {
    v5 = v4;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v6 = SVGFilterPrimitive::floatsAttr((uint64_t)this, 0x7Au, (uint64_t)&v26);
    if (vImageBuffer_Init(&buf, v5->height, v5->width, *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 25) + 8) + 4), 0))
    {
      *(_QWORD *)a2 = 0;
    }
    else
    {
      v23.data = 0;
      v7 = &v24;
      v24 = buf;
      v8 = *(_QWORD *)(v6 + 8) - *(_QWORD *)v6;
      if (v8
        && (v9 = v8 >> 3, v10 = sqrt((double)(unint64_t)(v8 >> 3)), v8 >> 3 == v10 * v10)
        && SVGFilterPrimitive::floatAttr((uint64_t)this, 0x79u, (double)v10) == (double)v10)
      {
        v12 = *(double **)v6;
        v13 = *(double **)(v6 + 8);
        if (*(double **)v6 == v13)
        {
          v16 = 0.0;
        }
        else
        {
          v14 = 0;
          do
          {
            v15 = *v12++;
            v14 = (int)(v15 + (double)v14);
          }
          while (v12 != v13);
          v16 = (double)v14;
        }
        divisor = (int)SVGFilterPrimitive::floatAttr((uint64_t)this, 0x7Bu, v16);
        if (divisor)
        {
          v18 = SVGFilterPrimitive::floatAttr((uint64_t)this, 0x7Cu, 0.0);
          *(_QWORD *)color = 0;
          v21 = 0;
          v22 = 0;
          std::vector<short>::reserve((void **)color, v9);
          std::transform[abi:ne180100]<std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<short>>,SVGFilterPrimitive::drawFeConvolveMatrix(void)::$_1>(*(uint64_t **)v6, *(_QWORD **)(v6 + 8), (uint64_t)color);
          if (vImageConvolveWithBias_ARGB8888(v5, &buf, 0, 0, 0, *(const int16_t **)color, v10, v10, divisor, (int)(v18 * (double)divisor * 255.0), 0, 8u))
          {
            free(buf.data);
            *(_QWORD *)a2 = 0;
          }
          else
          {
            v19 = *(_OWORD *)&buf.width;
            *a2 = *(_OWORD *)&buf.data;
            a2[1] = v19;
          }
          if (*(_QWORD *)color)
          {
            v21 = *(const int16_t **)color;
            operator delete(*(void **)color);
          }
        }
        else
        {
          SVGFilterPrimitive::drawFeConvolveMatrix(void)const::$_0::operator()(&v23, a2);
        }
      }
      else
      {
        *(_DWORD *)color = 0;
        if (vImageBufferFill_ARGB8888(&v24, color, 0))
        {
          free(v24.data);
          v7 = &v23;
        }
        v11 = *(_OWORD *)&v7->width;
        *a2 = *(_OWORD *)&v7->data;
        a2[1] = v11;
      }
    }
    if (v26)
    {
      v27 = v26;
      operator delete(v26);
    }
  }
  else
  {
    *(_QWORD *)a2 = 0;
  }
}

void sub_20678B9D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  uint64_t v14;
  void *v16;

  v16 = *(void **)(v14 - 104);
  if (v16)
  {
    *(_QWORD *)(v14 - 96) = v16;
    operator delete(v16);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *SVGFilterPrimitive::inputImage<FilterResult>(uint64_t a1, unsigned int a2)
{
  SVGAttribute *v3;
  unsigned __int8 *v4;
  unsigned __int8 *result;
  unsigned __int8 *v6;

  v3 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (v3)
  {
    v4 = (unsigned __int8 *)SVGAttribute::stringValue(v3);
    result = std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::find<std::string>(*(_QWORD **)(a1 + 216), v4);
    if (!result)
      return result;
    v6 = result + 40;
  }
  else
  {
    v6 = (unsigned __int8 *)(a1 + 208);
  }
  return *(unsigned __int8 **)v6;
}

unsigned __int8 *SVGFilterPrimitive::inputImage<CIImage>(uint64_t a1, unsigned int a2)
{
  unsigned __int8 *v3;
  void **v4;
  void *v5;
  CGImage *v6;
  CGImage *v7;
  uint64_t v9;
  void *v10;
  vImage_Error error;

  v3 = SVGFilterPrimitive::inputImage<FilterResult>(a1, a2);
  if (v3)
  {
    v4 = (void **)v3;
    v5 = *(void **)v3;
    if (!*(_QWORD *)v3)
    {
      error = 0;
      v6 = vImageCreateCGImageFromBuffer((const vImage_Buffer *)(v3 + 8), *(const vImage_CGImageFormat **)(*(_QWORD *)(a1 + 200) + 8), 0, 0, 0, &error);
      v7 = v6;
      if (error)
      {
        CGImageRelease(v6);
        v3 = 0;
        return v3;
      }
      objc_msgSend(MEMORY[0x24BDBF660], "imageWithCGImage:", v6);
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = *v4;
      *v4 = (void *)v9;

      CGImageRelease(v7);
      v5 = *v4;
    }
    v3 = v5;
  }
  return v3;
}

_OWORD *SVGFilterPrimitive::inputImage<vImage_Buffer>(uint64_t a1, unsigned int a2)
{
  unsigned __int8 *v3;
  _OWORD *v4;
  CGImage *v5;
  vImage_Error v6;
  uint64_t v7;
  __int128 v8;
  vImage_Buffer v10;
  CGFloat backgroundColor[4];

  backgroundColor[3] = *(CGFloat *)MEMORY[0x24BDAC8D0];
  v3 = SVGFilterPrimitive::inputImage<FilterResult>(a1, a2);
  if (!v3)
    return 0;
  v4 = v3 + 8;
  if (!*((_QWORD *)v3 + 1))
  {
    v5 = (CGImage *)objc_msgSend(**(id **)(a1 + 200), "createCGImage:fromRect:", *(_QWORD *)v3, 0.0, 0.0, **(double **)(a1 + 224), *(double *)(*(_QWORD *)(a1 + 224) + 8));
    memset(backgroundColor, 0, 24);
    v6 = vImageBuffer_InitWithCGImage(&v10, *(vImage_CGImageFormat **)(*(_QWORD *)(a1 + 200) + 8), backgroundColor, v5, 0);
    CGImageRelease(v5);
    v7 = 0;
    if (!v6)
    {
      v8 = *(_OWORD *)&v10.width;
      *v4 = *(_OWORD *)&v10.data;
      v4[1] = v8;
      return v4;
    }
    return (_OWORD *)v7;
  }
  return v4;
}

double SVGFilterPrimitive::pointAttr(uint64_t a1, unsigned int a2, double a3)
{
  uint64_t v5;
  double *v6;
  uint64_t v7;
  uint64_t v9;

  v5 = SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (v5)
  {
    v9 = 0;
    if (SVGAttribute::floatsValue(v5, &v9))
    {
      v6 = *(double **)v9;
      v7 = (uint64_t)(*(_QWORD *)(v9 + 8) - *(_QWORD *)v9) >> 3;
      if (v7 == 2)
      {
        return *v6 * **(double **)(a1 + 232);
      }
      else if (v7 == 1)
      {
        return *v6 * **(double **)(a1 + 232);
      }
    }
  }
  return a3;
}

double SVGFilterPrimitive::floatAttr(uint64_t a1, unsigned int a2, double a3)
{
  os_unfair_lock_s *v4;
  double v6;

  v4 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (v4)
  {
    v6 = 0.0;
    if (SVGAttribute::floatValue(v4, &v6))
      return v6;
  }
  return a3;
}

uint64_t SVGFilterPrimitive::floatsAttr(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;

  v4 = SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (v4)
  {
    v6 = 0;
    if (SVGAttribute::floatsValue(v4, &v6))
      return v6;
  }
  return a3;
}

double SVGFilterPrimitive::colorAttr@<D0>(uint64_t a1@<X0>, unsigned int a2@<W1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v6;
  const char *v7;
  double result;
  SVGPaint *v9;

  v6 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), a2);
  if (v6)
  {
    v9 = 0;
    if (SVGAttribute::paintValue(v6, &v9))
    {
      if (*((_DWORD *)v9 + 12) == 1)
        a3 = (char *)v9 + 56;
      else
        SVGUtilities::log((SVGUtilities *)"feFlood with non-color paint not supported", v7);
    }
    *(_QWORD *)&result = SVGColor::SVGColor(a4, (uint64_t)a3).n128_u64[0];
  }
  else
  {
    *(_QWORD *)&result = SVGColor::SVGColor(a4, (uint64_t)a3).n128_u64[0];
  }
  return result;
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1)
        goto LABEL_10;
      a1 = (_QWORD *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1)
LABEL_10:
      std::string::__throw_out_of_range[abi:ne180100]();
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

__n128 SVGFilterPrimitive::drawFeConvolveMatrix(void)const::$_0::operator()@<Q0>(const vImage_Buffer *a1@<X0>, _OWORD *a2@<X8>)
{
  const vImage_Buffer *v2;
  void **p_data;
  __n128 result;
  __int128 v6;
  uint8_t color[4];

  v2 = a1;
  *(_DWORD *)color = 0;
  p_data = &a1[1].data;
  if (vImageBufferFill_ARGB8888(a1 + 1, color, 0))
    free(*p_data);
  else
    v2 = (const vImage_Buffer *)p_data;
  result = *(__n128 *)&v2->data;
  v6 = *(_OWORD *)&v2->width;
  *a2 = *(_OWORD *)&v2->data;
  a2[1] = v6;
  return result;
}

void std::vector<short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int16 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    v9 = &v6[2 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t *std::transform[abi:ne180100]<std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<short>>,SVGFilterPrimitive::drawFeConvolveMatrix(void)::$_1>(uint64_t *result, _QWORD *a2, uint64_t a3)
{
  double *v4;
  double v5;
  __int16 v6;
  uint64_t v7;

  v7 = a3;
  if (result != a2)
  {
    v4 = (double *)result;
    do
    {
      v5 = *v4++;
      v6 = llround(v5);
      result = std::back_insert_iterator<std::vector<short>>::operator=[abi:ne180100](&v7, &v6);
    }
    while (v4 != (double *)a2);
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_20678C214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,FilterResult *>,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x30uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_20678C2C4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,FilterResult *>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v3 = v2;
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v5, (uint64_t *)a2, v3);
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;

  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      v11 = v7 + v9;
      v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      v14 = v8 + a3 + v7 + v4;
      v15 = v14 + v5;
      v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v18 = v17 + v6 + v9;
      v19 = __ROR8__(v18, 44);
      v20 = v18 + v10;
      v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      v23 = *a2;
      v22 = a2 + 4;
      v24 = v23 - 0x4B6D499041670D8DLL * v5;
      v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v26 = *(v22 - 3);
        v27 = v24 + v15 + v11 + v26;
        v28 = v22[2];
        v29 = v22[3];
        v30 = v22[1];
        v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        v31 = v13 + v20;
        v32 = *(v22 - 2);
        v33 = *(v22 - 1);
        v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        v35 = v34 + v20 + v33;
        v36 = v34 + v26 + v32;
        v15 = v36 + v33;
        v37 = __ROR8__(v36, 44) + v34;
        v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        v16 = v37 + __ROR8__(v35 + v38, 21);
        v39 = v24 + v21 + *v22;
        v20 = v39 + v30 + v28 + v29;
        v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        v13 = v38;
        v25 += 64;
      }
      while (v25);
      v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](_DWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (a2 < 9)
  {
    if (a2 < 4)
    {
      result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    v3 = *(_QWORD *)((char *)a1 + a2 - 8);
    v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = a1[1];
  v3 = 0xB492B66FBE98F273 * *a1;
  v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8);
  v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v2 = *(_QWORD *)((char *)a1 + a2 - 16);
  v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  v5 = a1[2];
  v4 = a1[3];
  v6 = __ROR8__(v3 + v4, 52);
  v7 = v3 + a1[1];
  v8 = __ROR8__(v7, 7);
  v9 = v7 + v5;
  v10 = *(_QWORD *)((char *)a1 + a2 - 32) + v5;
  v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  v12 = *(_QWORD *)((char *)a1 + a2 - 24) + v10 + v2;
  v13 = 0xC3A5C85C97CB3127 * (v12 + *(_QWORD *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t std::equal_to<std::string>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t result;

  v3 = a3;
  v4 = a2[23];
  if ((v4 & 0x80u) == 0)
    v5 = a2[23];
  else
    v5 = *((_QWORD *)a2 + 1);
  v6 = a3[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    v3 = *(unsigned __int8 **)a3;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a2, v3, *((_QWORD *)a2 + 1)) == 0;
  if (!a2[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a2++;
    v9 = v10;
    v12 = *v3++;
    v11 = v12;
    v14 = v8-- != 0;
    result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,FilterResult *>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v13 == v6)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

uint64_t *std::back_insert_iterator<std::vector<short>>::operator=[abi:ne180100](uint64_t *a1, _WORD *a2)
{
  uint64_t v4;
  _WORD *v5;
  _QWORD *v6;
  _WORD *v7;
  _WORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  __int16 v17;

  v4 = *a1;
  v5 = *(_WORD **)(*a1 + 8);
  v6 = (_QWORD *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    v8 = *(_WORD **)v4;
    v9 = (uint64_t)v5 - *(_QWORD *)v4;
    if (v9 <= -3)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v9 >> 1;
    v11 = *v6 - (_QWORD)v8;
    if (v11 <= (v9 >> 1) + 1)
      v12 = v10 + 1;
    else
      v12 = *v6 - (_QWORD)v8;
    if (v11 >= 0x7FFFFFFFFFFFFFFELL)
      v13 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)v6, v13);
      v8 = *(_WORD **)v4;
      v5 = *(_WORD **)(v4 + 8);
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[2 * v10];
    v16 = &v14[2 * v13];
    *(_WORD *)v15 = *a2;
    v7 = v15 + 2;
    while (v5 != v8)
    {
      v17 = *--v5;
      *((_WORD *)v15 - 1) = v17;
      v15 -= 2;
    }
    *(_QWORD *)v4 = v15;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = v16;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v5 = *a2;
    v7 = v5 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

uint64_t CGSVGShapeNodeCreate(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  SVGShapeNode::SVGShapeNode(v2, a1);
  return *(_QWORD *)(v2 + 40);
}

void sub_20678CAB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

unsigned int *CGSVGShapeNodeGetPrimitive(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
    return (unsigned int *)result[72];
  return result;
}

void *CFRetained::getObject<SVGShapeNode>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

void CGSVGShapeNodeSetPath(uint64_t a1, const char *a2)
{
  SVGShapeNode *v3;
  const char *v4;
  SVGPath *v5;

  v3 = (SVGShapeNode *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  v5 = (SVGPath *)CFRetained::getObject<SVGPath>((uint64_t)a2, v4);
  if (v3)
  {
    if (v5)
      SVGShapeNode::setPath(v3, v5);
  }
}

SVGShapeNode *CGSVGShapeNodeGetPath(uint64_t a1, const char *a2)
{
  SVGShapeNode *result;

  result = (SVGShapeNode *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    result = SVGShapeNode::path(result);
    if (result)
      return (SVGShapeNode *)*((_QWORD *)result + 5);
  }
  return result;
}

CGPath *CGSVGShapeNodeCreateCGPath(uint64_t a1, const char *a2)
{
  CGPath *result;

  result = (CGPath *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
    return SVGShapeNode::createCGPath(result);
  return result;
}

SVGShapeNode *CGSVGShapeNodeGetFloatCount(uint64_t a1, const char *a2)
{
  SVGShapeNode *result;

  result = (SVGShapeNode *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    result = (SVGShapeNode *)SVGShapeNode::pointList(result);
    if (result)
      return (SVGShapeNode *)((uint64_t)(*((_QWORD *)result + 1) - *(_QWORD *)result) >> 3);
  }
  return result;
}

SVGShapeNode *CGSVGShapeNodeGetFloats(uint64_t a1, char *a2)
{
  SVGShapeNode *result;

  result = (SVGShapeNode *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    result = (SVGShapeNode *)SVGShapeNode::pointList(result);
    if (result)
      return (SVGShapeNode *)memcpy(a2, *(const void **)result, *((_QWORD *)result + 1) - *(_QWORD *)result);
  }
  return result;
}

void CGSVGShapeNodeSetFloats(uint64_t a1, uint64_t a2, unint64_t a3)
{
  const char *v4;
  void *v5;
  void *__p;
  void *v7;
  uint64_t v8;

  __p = 0;
  v7 = 0;
  v8 = 0;
  SVGUtilities::CGPointListFromFloats(a2, a3, (uint64_t)&__p);
  v5 = CFRetained::getObject<SVGShapeNode>(a1, v4);
  if (v5)
    SVGShapeNode::setPointList((uint64_t)v5, (uint64_t)&__p);
  if (__p)
  {
    v7 = __p;
    operator delete(__p);
  }
}

void sub_20678CCA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double *CGSVGShapeNodeSetRectGeometry(uint64_t a1, const char *a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    if (*((_DWORD *)result + 72) == 49)
    {
      result[25] = a3;
      result[26] = a4;
      result[29] = a5;
      result[30] = a6;
      result[31] = a7;
      result[32] = a8;
    }
  }
  return result;
}

double CGSVGShapeNodeGetRectGeometry(uint64_t a1, char *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, double *a7)
{
  double *v13;
  double result;

  v13 = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (v13)
  {
    if (*((_DWORD *)v13 + 72) == 49)
    {
      *(double *)a2 = v13[25];
      *a3 = *((_QWORD *)v13 + 26);
      *a4 = *((_QWORD *)v13 + 29);
      *a5 = *((_QWORD *)v13 + 30);
      *a6 = *((_QWORD *)v13 + 31);
      result = v13[32];
      *a7 = result;
    }
  }
  return result;
}

double *CGSVGShapeNodeSetCircleGeometry(uint64_t a1, const char *a2, double a3, double a4, double a5)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    if (*((_DWORD *)result + 72) == 3)
    {
      result[33] = a3;
      result[34] = a4;
      result[35] = a5;
    }
  }
  return result;
}

double CGSVGShapeNodeGetCircleGeometry(uint64_t a1, char *a2, _QWORD *a3, double *a4)
{
  double *v7;
  double result;

  v7 = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (v7)
  {
    if (*((_DWORD *)v7 + 72) == 3)
    {
      *(double *)a2 = v7[33];
      *a3 = *((_QWORD *)v7 + 34);
      result = v7[35];
      *a4 = result;
    }
  }
  return result;
}

double *CGSVGShapeNodeSetEllipseGeometry(uint64_t a1, const char *a2, double a3, double a4, double a5, double a6)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    if (*((_DWORD *)result + 72) == 16)
    {
      result[33] = a3;
      result[34] = a4;
      result[31] = a5;
      result[32] = a6;
    }
  }
  return result;
}

double CGSVGShapeNodeGetEllipseGeometry(uint64_t a1, char *a2, _QWORD *a3, _QWORD *a4, double *a5)
{
  double *v9;
  double result;

  v9 = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (v9)
  {
    if (*((_DWORD *)v9 + 72) == 16)
    {
      *(double *)a2 = v9[33];
      *a3 = *((_QWORD *)v9 + 34);
      *a4 = *((_QWORD *)v9 + 31);
      result = v9[32];
      *a5 = result;
    }
  }
  return result;
}

double *CGSVGShapeNodeSetLineGeometry(uint64_t a1, const char *a2, double a3, double a4, double a5, double a6)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (result)
  {
    if (*((_DWORD *)result + 72) == 32)
    {
      result[25] = a3;
      result[26] = a4;
      result[27] = a5;
      result[28] = a6;
    }
  }
  return result;
}

double CGSVGShapeNodeGetLineGeometry(uint64_t a1, char *a2, _QWORD *a3, _QWORD *a4, double *a5)
{
  double *v9;
  double result;

  v9 = (double *)CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (v9)
  {
    if (*((_DWORD *)v9 + 72) == 32)
    {
      *(double *)a2 = v9[25];
      *a3 = *((_QWORD *)v9 + 26);
      *a4 = *((_QWORD *)v9 + 27);
      result = v9[28];
      *a5 = result;
    }
  }
  return result;
}

CFStringRef CGSVGShapeNodeCopyText(uint64_t a1, const char *a2)
{
  _DWORD *v2;
  const char *v3;

  v2 = CFRetained::getObject<SVGShapeNode>(a1, a2);
  if (v2
    && v2[72] == 10001
    && (v3 = (const char *)*((_QWORD *)v2 + 24)) != 0
    && ((v3[23] & 0x80000000) == 0 || (v3 = *(const char **)v3) != 0)
    && *v3)
  {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v3, 0x8000100u);
  }
  else
  {
    return 0;
  }
}

BOOL CGSVGLengthEqualToLength(uint64_t a1, int a2, uint64_t a3, int a4)
{
  return a2 == a4 && vabdd_f64(*(double *)&a1, *(double *)&a3) < 0.00000011920929;
}

double CGSVGLengthScaledLength(uint64_t a1, int a2, double a3)
{
  double result;

  result = *(double *)&a1;
  if (a2 == 1)
    return *(double *)&a1 * a3 / 100.0;
  return result;
}

void CGSVGPointMake(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>)
{
  *(double *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(double *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
}

uint64_t CGSVGPointMakeWithTypes@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  *(double *)a3 = a4;
  *(_DWORD *)(a3 + 8) = result;
  *(double *)(a3 + 16) = a5;
  *(_DWORD *)(a3 + 24) = a2;
  return result;
}

void CGSVGPointMakeWithPoint(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>)
{
  *(double *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(double *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
}

BOOL CGSVGPointEqualToPoint(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && vabdd_f64(*(double *)a1, *(double *)a2) < 0.00000011920929
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
      && vabdd_f64(*(double *)(a1 + 16), *(double *)(a2 + 16)) < 0.00000011920929;
}

double CGSVGPointScaledPoint(uint64_t a1, double a2)
{
  double result;

  result = *(double *)a1;
  if (*(_DWORD *)(a1 + 8) == 1)
    return result * a2 / 100.0;
  return result;
}

uint64_t CGSVGPatternGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_20678D1B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGPatternCreate()
{
  SVGPattern *v0;

  v0 = (SVGPattern *)operator new();
  SVGPattern::SVGPattern(v0);
  return *((_QWORD *)v0 + 5);
}

void sub_20678D210(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40827AA555);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGPatternRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGPatternRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t SVGNode::SVGNode(uint64_t a1, __int128 *a2)
{
  SVGAttributeMap *v4;
  __int128 v5;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  CFRetained::CFRetained((_QWORD *)a1, (uint64_t)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  *(_QWORD *)a1 = &off_24BFD8DD8;
  *(_QWORD *)(a1 + 48) = 0;
  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4);
  *(_QWORD *)(a1 + 56) = v4;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 64), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    v4 = *(SVGAttributeMap **)(a1 + 56);
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 64) = v5;
  }
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 136) = a1 + 144;
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 160) = a1 + 168;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  SVGAttributeMap::setOwnerNode((uint64_t)v4, a1);
  return a1;
}

void sub_20678D398(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  uint64_t v4;
  void **v5;
  uint64_t v6;
  void *v8;
  void *v9;

  v6 = v2;
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v4, *(char **)(v1 + 168));
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v6, *(char **)(v1 + 144));
  v8 = *(void **)(v1 + 112);
  if (v8)
  {
    *(_QWORD *)(v1 + 120) = v8;
    operator delete(v8);
  }
  v9 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 96) = v9;
    operator delete(v9);
  }
  if (*(char *)(v1 + 87) < 0)
    operator delete(*v3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

SVGNode *SVGNode::copy(const SVGAttributeMap **this)
{
  SVGNode *v2;

  v2 = (SVGNode *)operator new();
  SVGNode::SVGNode(v2, this);
  return v2;
}

void sub_20678D494(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C408E750C55);
  _Unwind_Resume(a1);
}

void SVGNode::setAttributes(SVGNode *this, const SVGAttributeMap *a2)
{
  SVGAttributeMap *v4;

  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4, a2);
  SVGNode::setAttributes(this, (CFTypeRef *)v4);
  CFRetained::release((CFTypeRef *)v4);
}

void sub_20678D540(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

void SVGNode::setAttribute(SVGNode *this, SVGAttribute *a2)
{
  SVGAttributeMap::setAttribute(*((_QWORD *)this + 7), (uint64_t)a2, 0);
}

void SVGNode::updateChildIdentifer(SVGNode *this, SVGNode *a2, char *__s)
{
  SVGNode *v5;
  uint64_t **v6;
  SVGNode *v7;
  SVGNode *v8;
  BOOL v9;
  void *__p[2];
  char v11;
  SVGNode *v12;

  v6 = (uint64_t **)((char *)this + 136);
  v5 = (SVGNode *)*((_QWORD *)this + 17);
  if (v5 == (SVGNode *)((char *)this + 144))
  {
LABEL_9:
    if (!__s)
      return;
    goto LABEL_12;
  }
  while (*((SVGNode **)v5 + 7) != a2)
  {
    v7 = (SVGNode *)*((_QWORD *)v5 + 1);
    if (v7)
    {
      do
      {
        v8 = v7;
        v7 = *(SVGNode **)v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        v8 = (SVGNode *)*((_QWORD *)v5 + 2);
        v9 = *(_QWORD *)v8 == (_QWORD)v5;
        v5 = v8;
      }
      while (!v9);
    }
    v5 = v8;
    if (v8 == (SVGNode *)((char *)this + 144))
      goto LABEL_9;
  }
  std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__erase_unique<std::string>((uint64_t **)this + 17, (uint64_t)v5 + 32);
  if (__s)
  {
LABEL_12:
    if (*__s)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, __s);
      v12 = a2;
      std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGNode *>>(v6, (uint64_t)__p, (uint64_t)__p);
      if (v11 < 0)
        operator delete(__p[0]);
    }
  }
}

void sub_20678D648(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::setIdentifier(SVGNode *this, char *a2)
{
  uint64_t v2;
  std::string __p;

  if (a2 && *a2)
  {
    v2 = *((_QWORD *)this + 7);
    std::string::basic_string[abi:ne180100]<0>(&__p, a2);
    SVGAttributeMap::setAttribute(v2, 31, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    SVGAttributeMap::removeAttribute(*((_QWORD *)this + 7), 0x1Fu);
  }
}

void sub_20678D6D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::setIdentifier(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 56);
  if (v2)
    SVGAttributeMap::setAttribute(v3, 31, (const std::string *)a2);
  else
    SVGAttributeMap::removeAttribute(v3, 0x1Fu);
}

void SVGNode::addDefinitionChild(SVGNode *this, SVGNode *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  if (a2 == this)
  {
    SVGUtilities::error((SVGUtilities *)"Warning: attempted to add a node to itself, causing a cycle. Ignoring.", (const char *)a2);
  }
  else if (a2)
  {
    v6 = *((_QWORD *)this + 16);
    v4 = (char *)this + 128;
    v5 = v6;
    v7 = (_QWORD *)*((_QWORD *)v4 - 1);
    if ((unint64_t)v7 >= v6)
    {
      v9 = (void **)(v4 - 16);
      v10 = *((_QWORD *)v4 - 2);
      v11 = ((uint64_t)v7 - v10) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v12 = v5 - v10;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v4, v14);
      else
        v15 = 0;
      v16 = &v15[8 * v11];
      v17 = &v15[8 * v14];
      *(_QWORD *)v16 = a2;
      v8 = v16 + 8;
      v19 = (char *)*((_QWORD *)this + 14);
      v18 = (char *)*((_QWORD *)this + 15);
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v16 - 1) = v20;
          v16 -= 8;
        }
        while (v18 != v19);
        v18 = (char *)*v9;
      }
      *((_QWORD *)this + 14) = v16;
      *((_QWORD *)this + 15) = v8;
      *((_QWORD *)this + 16) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v7 = a2;
      v8 = v7 + 1;
    }
    *((_QWORD *)this + 15) = v8;
    CFRetained::retain((CFTypeRef *)a2);
    *((_QWORD *)a2 + 6) = this;
  }
}

void SVGNode::replaceChildWithChild(SVGNode *this, CFTypeRef *a2, CFTypeRef *a3)
{
  CFTypeRef **v6;
  CFTypeRef **v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  void *__p[2];
  char v15;
  CFTypeRef *v16;

  v7 = (CFTypeRef **)*((_QWORD *)this + 11);
  v6 = (CFTypeRef **)*((_QWORD *)this + 12);
  if (v7 != v6)
  {
    while (*v7 != a2)
    {
      if (++v7 == v6)
      {
        v7 = (CFTypeRef **)*((_QWORD *)this + 12);
        break;
      }
    }
  }
  if (v7 != v6)
  {
    if (SVGNode::identifier((SVGNode *)a2) && *SVGNode::identifier((SVGNode *)a2))
    {
      v8 = SVGNode::identifier((SVGNode *)a2);
      std::string::basic_string[abi:ne180100]<0>(__p, v8);
      v9 = std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__count_unique<std::string>((uint64_t)this + 136, (uint64_t)__p);
      v10 = v9;
      if ((v15 & 0x80000000) == 0)
      {
        if (!v9)
          goto LABEL_14;
LABEL_12:
        v11 = SVGNode::identifier((SVGNode *)a2);
        std::string::basic_string[abi:ne180100]<0>(__p, v11);
        v12 = std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>((uint64_t)this + 136, (uint64_t)__p);
        std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::erase((uint64_t **)this + 17, (uint64_t)v12);
        if (v15 < 0)
          operator delete(__p[0]);
        goto LABEL_14;
      }
      operator delete(__p[0]);
      if (v10)
        goto LABEL_12;
    }
LABEL_14:
    CFRetained::release(*v7);
    *v7 = a3;
    CFRetained::retain(a3);
    a3[6] = this;
    if (SVGNode::identifier((SVGNode *)a3) && *SVGNode::identifier((SVGNode *)a3))
    {
      v13 = SVGNode::identifier((SVGNode *)a3);
      std::string::basic_string[abi:ne180100]<0>(__p, v13);
      v16 = a3;
      std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGNode *>>((uint64_t **)this + 17, (uint64_t)__p, (uint64_t)__p);
      if (v15 < 0)
        operator delete(__p[0]);
    }
  }
}

void sub_20678D9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::removeChildAtIndex(SVGNode *this, unint64_t a2)
{
  uint64_t v2;
  SVGNode *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *__p[2];
  char v15;

  v2 = *((_QWORD *)this + 11);
  if (a2 >= (*((_QWORD *)this + 12) - v2) >> 3)
    return;
  v5 = *(SVGNode **)(v2 + 8 * a2);
  if (SVGNode::identifier(v5) && *SVGNode::identifier(v5))
  {
    v6 = SVGNode::identifier(v5);
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    v7 = std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__count_unique<std::string>((uint64_t)this + 136, (uint64_t)__p);
    v8 = v7;
    if ((v15 & 0x80000000) == 0)
    {
      if (!v7)
        goto LABEL_10;
LABEL_8:
      v9 = SVGNode::identifier(v5);
      std::string::basic_string[abi:ne180100]<0>(__p, v9);
      v10 = std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>((uint64_t)this + 136, (uint64_t)__p);
      std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::erase((uint64_t **)this + 17, (uint64_t)v10);
      if (v15 < 0)
        operator delete(__p[0]);
      goto LABEL_10;
    }
    operator delete(__p[0]);
    if (v8)
      goto LABEL_8;
  }
LABEL_10:
  v11 = *((_QWORD *)this + 12);
  v12 = *((_QWORD *)this + 11) + 8 * a2;
  v13 = v11 - (v12 + 8);
  if (v11 != v12 + 8)
    memmove((void *)v12, (const void *)(v12 + 8), v11 - (v12 + 8));
  *((_QWORD *)this + 12) = v12 + v13;
  CFRetained::release((CFTypeRef *)v5);
}

void sub_20678DADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGNode::hasChildNodeWithName(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  const void **v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t result;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;

  v2 = a2;
  v4 = *(unsigned __int8 *)(a1 + 87);
  if ((v4 & 0x80u) == 0)
    v5 = *(unsigned __int8 *)(a1 + 87);
  else
    v5 = *(_QWORD *)(a1 + 72);
  v6 = a2[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a2 + 1);
  if (v5 != v6)
    goto LABEL_15;
  v8 = (const void **)(a1 + 64);
  if (v7 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*v8, a2, *(_QWORD *)(a1 + 72)))
      goto LABEL_15;
    return 1;
  }
  if (!*(_BYTE *)(a1 + 87))
    return 1;
  while (*(unsigned __int8 *)v8 == *a2)
  {
    v8 = (const void **)((char *)v8 + 1);
    ++a2;
    if (!--v4)
      return 1;
  }
LABEL_15:
  v9 = *(_QWORD **)(a1 + 88);
  v10 = *(_QWORD **)(a1 + 96);
  while (v9 != v10)
  {
    if ((SVGNode::hasChildNodeWithName(*v9, v2) & 1) != 0)
      return 1;
    ++v9;
  }
  v11 = *(_QWORD **)(a1 + 160);
  v12 = (_QWORD *)(a1 + 168);
  if (v11 != v12)
  {
    while (1)
    {
      result = SVGNode::hasChildNodeWithName(v11[7], v2);
      if ((result & 1) != 0)
        break;
      v14 = (_QWORD *)v11[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (_QWORD *)v11[2];
          v16 = *v15 == (_QWORD)v11;
          v11 = v15;
        }
        while (!v16);
      }
      v11 = v15;
      if (v15 == v12)
        return result;
    }
    return 1;
  }
  return 0;
}

void SVGNode::findChildNodesWithName(uint64_t a1, unsigned __int8 *a2, void **a3)
{
  unsigned __int8 *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  const void **v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  BOOL v31;
  std::string __p;
  uint64_t v33;

  v4 = a2;
  v6 = *(unsigned __int8 *)(a1 + 87);
  if ((v6 & 0x80u) == 0)
    v7 = *(unsigned __int8 *)(a1 + 87);
  else
    v7 = *(_QWORD *)(a1 + 72);
  v8 = a2[23];
  v9 = (char)v8;
  if ((v8 & 0x80u) != 0)
    v8 = *((_QWORD *)a2 + 1);
  if (v7 != v8)
    goto LABEL_32;
  v10 = (const void **)(a1 + 64);
  if (v9 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v6 & 0x80) != 0)
  {
    if (memcmp(*v10, a2, *(_QWORD *)(a1 + 72)))
      goto LABEL_32;
    goto LABEL_15;
  }
  if (!*(_BYTE *)(a1 + 87))
  {
LABEL_15:
    v11 = (unint64_t)a3[2];
    v12 = a3[1];
    if ((unint64_t)v12 >= v11)
    {
      v14 = ((char *)v12 - (_BYTE *)*a3) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v15 = v11 - (_QWORD)*a3;
      v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1))
        v16 = v14 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a3 + 2), v17);
      else
        v18 = 0;
      v19 = &v18[8 * v14];
      v20 = &v18[8 * v17];
      *(_QWORD *)v19 = a1;
      v13 = v19 + 8;
      v22 = (char *)*a3;
      v21 = (char *)a3[1];
      if (v21 != *a3)
      {
        do
        {
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *((_QWORD *)v19 - 1) = v23;
          v19 -= 8;
        }
        while (v21 != v22);
        v21 = (char *)*a3;
      }
      *a3 = v19;
      a3[1] = v13;
      a3[2] = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *v12 = a1;
      v13 = v12 + 1;
    }
    a3[1] = v13;
    goto LABEL_32;
  }
  while (*(unsigned __int8 *)v10 == *a2)
  {
    v10 = (const void **)((char *)v10 + 1);
    ++a2;
    if (!--v6)
      goto LABEL_15;
  }
LABEL_32:
  v24 = *(uint64_t **)(a1 + 88);
  v25 = *(uint64_t **)(a1 + 96);
  while (v24 != v25)
  {
    v26 = *v24++;
    SVGNode::findChildNodesWithName(v26, v4, a3);
  }
  v27 = *(_QWORD **)(a1 + 160);
  v28 = (_QWORD *)(a1 + 168);
  if (v27 != v28)
  {
    do
    {
      if (*((char *)v27 + 55) < 0)
        std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v27[4], v27[5]);
      else
        __p = *(std::string *)(v27 + 4);
      v33 = v27[7];
      ((void (*)(void))SVGNode::findChildNodesWithName)();
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v29 = (_QWORD *)v27[1];
      if (v29)
      {
        do
        {
          v30 = v29;
          v29 = (_QWORD *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          v30 = (_QWORD *)v27[2];
          v31 = *v30 == (_QWORD)v27;
          v27 = v30;
        }
        while (!v31);
      }
      v27 = v30;
    }
    while (v30 != v28);
  }
}

void sub_20678DE44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::findChildAttributesWithName(uint64_t *a1, uint64_t a2, void **a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  BOOL v28;
  std::string __p;
  uint64_t v30;

  v6 = SVGAttributeMap::attribute(a1[7], a2);
  if (v6)
  {
    v7 = v6;
    v8 = (unint64_t)a3[2];
    v9 = (uint64_t *)a3[1];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - (_BYTE *)*a3) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*a3;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a3 + 2), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)*a3;
      v18 = (char *)a3[1];
      if (v18 != *a3)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = (char *)*a3;
      }
      *a3 = v16;
      a3[1] = v10;
      a3[2] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v6;
      v10 = v9 + 1;
    }
    a3[1] = v10;
  }
  v21 = (uint64_t *)a1[11];
  v22 = (uint64_t *)a1[12];
  while (v21 != v22)
  {
    v23 = *v21++;
    SVGNode::findChildAttributesWithName(v23, a2, a3);
  }
  v24 = (uint64_t *)a1[20];
  v25 = a1 + 21;
  if (v24 != v25)
  {
    do
    {
      if (*((char *)v24 + 55) < 0)
        std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v24[4], v24[5]);
      else
        __p = *(std::string *)(v24 + 4);
      v30 = v24[7];
      ((void (*)(void))SVGNode::findChildAttributesWithName)();
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v26 = (uint64_t *)v24[1];
      if (v26)
      {
        do
        {
          v27 = v26;
          v26 = (uint64_t *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          v27 = (uint64_t *)v24[2];
          v28 = *v27 == (_QWORD)v24;
          v24 = v27;
        }
        while (!v28);
      }
      v24 = v27;
    }
    while (v27 != v25);
  }
}

void sub_20678E014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::addDefinitionNode(SVGNode *this, SVGNode *a2, SVGNode *a3)
{
  char *v3;
  char *v7;
  char *v8;
  _QWORD *v9;
  SVGNode *v10;
  void *__p[2];
  char v12;
  SVGNode *v13;

  if (*((_QWORD *)this + 6))
  {
    v3 = "Add definition node should be called on root node";
LABEL_3:
    SVGUtilities::error((SVGUtilities *)v3, (const char *)a2, a3);
    return;
  }
  if (!SVGAttributeMap::attribute(*((_QWORD *)a3 + 7), 0x1Fu))
  {
    SVGNode::addDefinitionChild(a2, a3);
    return;
  }
  v7 = SVGNode::identifier(a3);
  if (!*v7)
  {
    v3 = "Invalid node Id for node";
    goto LABEL_3;
  }
  v8 = v7;
  std::string::basic_string[abi:ne180100]<0>(__p, v7);
  v9 = (_QWORD *)std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>((uint64_t)this + 160, (const void **)__p);
  if (v12 < 0)
    operator delete(__p[0]);
  if ((_QWORD *)((char *)this + 168) != v9)
  {
    v10 = (SVGNode *)v9[7];
    if (v10 == a3)
      return;
    CFRetained::release((CFTypeRef *)v10);
    std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::erase((uint64_t **)this + 20, (uint64_t)v9);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, v8);
  v13 = a3;
  std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGNode *>>((uint64_t **)this + 20, (const void **)__p, (uint64_t)__p);
  if (v12 < 0)
    operator delete(__p[0]);
  CFRetained::retain((uint64_t)a3);
  SVGNode::addDefinitionChild(a2, a3);
}

void sub_20678E180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SVGNode *SVGNode::findDefinitionNode(SVGNode *this, char *a2)
{
  char *v4;
  _QWORD *v5;
  SVGNode *result;
  void *__p[2];
  char v8;

  v4 = (char *)this + 160;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v5 = (_QWORD *)std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>((uint64_t)v4, (const void **)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  if ((_QWORD *)((char *)this + 168) != v5)
    return (SVGNode *)v5[7];
  result = (SVGNode *)*((_QWORD *)this + 6);
  if (result)
    return (SVGNode *)SVGNode::findDefinitionNode(result, a2);
  return result;
}

void sub_20678E220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double SVGNode::boundingBox(uint64_t a1, uint64_t a2)
{
  CGFloat v2;
  CGFloat v3;
  CGFloat v4;
  CGFloat v5;
  _QWORD *v6;
  _QWORD *v7;
  double x;
  double v10;
  CGFloat y;
  double v12;
  CGFloat width;
  double v14;
  CGFloat height;
  CGRect v17;
  CGRect v18;
  CGRect v19;
  CGRect v20;

  v3 = *MEMORY[0x24BDBF090];
  v2 = *(double *)(MEMORY[0x24BDBF090] + 8);
  v5 = *(double *)(MEMORY[0x24BDBF090] + 16);
  v4 = *(double *)(MEMORY[0x24BDBF090] + 24);
  v6 = *(_QWORD **)(a1 + 88);
  v7 = *(_QWORD **)(a1 + 96);
  if (v6 == v7)
    return *MEMORY[0x24BDBF090];
  do
  {
    x = (*(double (**)(_QWORD, uint64_t))(*(_QWORD *)*v6 + 32))(*v6, a2);
    y = v10;
    width = v12;
    height = v14;
    v17.origin.x = v3;
    v17.origin.y = v2;
    v17.size.width = v5;
    v17.size.height = v4;
    if (!CGRectIsEmpty(v17))
    {
      v18.origin.x = v3;
      v18.origin.y = v2;
      v18.size.width = v5;
      v18.size.height = v4;
      v20.origin.x = x;
      v20.origin.y = y;
      v20.size.width = width;
      v20.size.height = height;
      v19 = CGRectUnion(v18, v20);
      x = v19.origin.x;
      y = v19.origin.y;
      width = v19.size.width;
      height = v19.size.height;
    }
    ++v6;
    v4 = height;
    v5 = width;
    v2 = y;
    v3 = x;
  }
  while (v6 != v7);
  return x;
}

void SVGNode::ancestorTransforms(SVGNode *this@<X0>, const SVGNode *a2@<X1>, uint64_t a3@<X8>)
{
  const SVGNode *v5;
  BOOL v6;
  const SVGNode **v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  const SVGNode **v12;
  const SVGNode **v13;
  const SVGNode **v14;
  const SVGNode *v15;
  BOOL v16;
  uint64_t v17;
  __int128 v18;
  const SVGNode **v19;
  uint64_t v20;
  uint64_t v21;
  os_unfair_lock_s *v22;
  __int128 v23;
  CGAffineTransform v24;
  CGAffineTransform t1;
  CGAffineTransform v26;
  const SVGNode **v27;
  const SVGNode **v28;
  const SVGNode **v29;

  v5 = (const SVGNode *)*((_QWORD *)this + 6);
  v27 = 0;
  v28 = 0;
  v29 = 0;
  std::vector<SVGNode const*>::reserve((void **)&v27, 0x10uLL);
  if (v5)
    v6 = v5 == a2;
  else
    v6 = 1;
  if (v6)
  {
    v7 = v28;
  }
  else
  {
    v7 = v28;
    do
    {
      if (v7 >= v29)
      {
        v8 = v7 - v27;
        if ((unint64_t)(v8 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = ((char *)v29 - (char *)v27) >> 2;
        if (v9 <= v8 + 1)
          v9 = v8 + 1;
        if ((unint64_t)((char *)v29 - (char *)v27) >= 0x7FFFFFFFFFFFFFF8)
          v10 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v10 = v9;
        if (v10)
          v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v29, v10);
        else
          v11 = 0;
        v12 = (const SVGNode **)&v11[8 * v8];
        *v12 = v5;
        v7 = v12 + 1;
        v14 = v27;
        v13 = v28;
        if (v28 != v27)
        {
          do
          {
            v15 = *--v13;
            *--v12 = v15;
          }
          while (v13 != v14);
          v13 = v27;
        }
        v27 = v12;
        v28 = v7;
        v29 = (const SVGNode **)&v11[8 * v10];
        if (v13)
          operator delete(v13);
      }
      else
      {
        *v7++ = v5;
      }
      v28 = v7;
      v5 = (const SVGNode *)*((_QWORD *)v5 + 6);
      if (v5)
        v16 = v5 == a2;
      else
        v16 = 1;
    }
    while (!v16);
  }
  v17 = MEMORY[0x24BDBD8B8];
  v18 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)a3 = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)(a3 + 16) = v18;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v17 + 32);
  v19 = v27;
  if (v7 == v27)
  {
    if (!v7)
      return;
  }
  else
  {
    do
    {
      v20 = (uint64_t)*--v7;
      v21 = *(_QWORD *)(v20 + 56);
      if (v21)
      {
        v22 = (os_unfair_lock_s *)SVGAttributeMap::attribute(v21, 0x3Fu);
        if (v22)
        {
          if (SVGAttribute::transformValue(v22, &v26))
          {
            t1 = v26;
            v23 = *(_OWORD *)(a3 + 16);
            *(_OWORD *)&v24.a = *(_OWORD *)a3;
            *(_OWORD *)&v24.c = v23;
            *(_OWORD *)&v24.tx = *(_OWORD *)(a3 + 32);
            CGAffineTransformConcat((CGAffineTransform *)a3, &t1, &v24);
          }
        }
        v19 = v27;
      }
    }
    while (v7 != v19);
  }
  v28 = v7;
  operator delete(v7);
}

void sub_20678E524(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 88);
  if (v3)
  {
    *(_QWORD *)(v1 - 80) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<SVGNode const*>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

CGFloat SVGNode::calculateBoundingBox(_QWORD *a1, uint64_t a2)
{
  CGFloat v4;
  CGFloat v5;
  CGFloat v6;
  CGFloat v7;
  SVGShapeNode *v8;
  SVGShapeNode *v9;
  SVGPath *v10;
  const char *v11;
  CGPath *CGPath;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v17;
  double v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat v21;
  void *v22;
  double v23;
  double v24;
  double v25;
  CGAffineTransform *v26;
  _QWORD *v27;
  _QWORD *v28;
  CGFloat v29;
  double v30;
  CGFloat v31;
  double v32;
  CGFloat v33;
  double v34;
  CGFloat v35;
  double v36;
  CGFloat v37;
  CGFloat v38;
  CGFloat v39;
  double v40;
  double v41;
  double v42;
  CGAffineTransform v44;
  _OWORD v45[3];
  CGAffineTransform v46;
  CGRect BoundingBox;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;

  v5 = *MEMORY[0x24BDBF090];
  v4 = *(double *)(MEMORY[0x24BDBF090] + 8);
  v7 = *(double *)(MEMORY[0x24BDBF090] + 16);
  v6 = *(double *)(MEMORY[0x24BDBF090] + 24);
  if (a1)
  {
    if (v8)
    {
      v9 = v8;
      v10 = SVGShapeNode::path(v8);
      if (v10)
      {
        CGPath = CGSVGPathCreateCGPath(*((_QWORD *)v10 + 5), v11);
        BoundingBox = CGPathGetBoundingBox(CGPath);
        x = BoundingBox.origin.x;
        y = BoundingBox.origin.y;
        width = BoundingBox.size.width;
        height = BoundingBox.size.height;
        v17 = -SVGNode::calculateStrokeWidthForBoundingBox((uint64_t)a1, a2);
        v48.origin.x = x;
        v48.origin.y = y;
        v48.size.width = width;
        v48.size.height = height;
        v49 = CGRectInset(v48, v17, v17);
        v18 = v49.origin.x;
        v19 = v49.origin.y;
        v20 = v49.size.width;
        v21 = v49.size.height;
        CGPathRelease(CGPath);
      }
      else
      {
        v18 = (*(double (**)(SVGShapeNode *, uint64_t))(*(_QWORD *)v9 + 32))(v9, a2);
        v19 = v40;
        v20 = v41;
        v21 = v42;
      }
      SVGNode::transform((SVGNode *)a1, &v46);
      v26 = &v46;
      goto LABEL_15;
    }
    if (v22)
    {
      v18 = (*(double (**)(void *, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
      v19 = v23;
      v20 = v24;
      v21 = v25;
      SVGNode::transform((SVGNode *)a1, v45);
      v26 = (CGAffineTransform *)v45;
LABEL_15:
      v54.origin.x = v18;
      v54.origin.y = v19;
      v54.size.width = v20;
      v54.size.height = v21;
      *(_QWORD *)&v36 = (unint64_t)CGRectApplyAffineTransform(v54, v26);
      return v36;
    }
  }
  v27 = (_QWORD *)a1[11];
  v28 = (_QWORD *)a1[12];
  if (v27 == v28)
    return v5;
  do
  {
    v29 = SVGNode::calculateBoundingBox(*v27, a2);
    v31 = v30;
    v33 = v32;
    v35 = v34;
    SVGNode::transform((SVGNode *)a1, &v44);
    v50.origin.x = v29;
    v50.origin.y = v31;
    v50.size.width = v33;
    v50.size.height = v35;
    v51 = CGRectApplyAffineTransform(v50, &v44);
    v36 = v51.origin.x;
    v37 = v51.origin.y;
    v38 = v51.size.width;
    v39 = v51.size.height;
    v51.origin.x = v5;
    v51.origin.y = v4;
    v51.size.width = v7;
    v51.size.height = v6;
    if (!CGRectIsEmpty(v51))
    {
      v52.origin.x = v5;
      v52.origin.y = v4;
      v52.size.width = v7;
      v52.size.height = v6;
      v55.origin.x = v36;
      v55.origin.y = v37;
      v55.size.width = v38;
      v55.size.height = v39;
      v53 = CGRectUnion(v52, v55);
      v36 = v53.origin.x;
      v37 = v53.origin.y;
      v38 = v53.size.width;
      v39 = v53.size.height;
    }
    ++v27;
    v6 = v39;
    v7 = v38;
    v4 = v37;
    v5 = v36;
  }
  while (v27 != v28);
  return v36;
}

double SVGNode::calculateStrokeWidthForBoundingBox(uint64_t a1, int a2)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  os_unfair_lock_s *v11;
  double v13;
  double v14;
  SVGPaint *v15;

  v2 = 0.0;
  if (a2)
  {
    v3 = a1;
    v4 = a1;
    if (a2 != 2)
      goto LABEL_23;
    v5 = a1;
    while (1)
    {
      v6 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*(_QWORD *)(v5 + 56), 0x39u);
      if (v6)
        break;
      v5 = *(_QWORD *)(v5 + 48);
      if (!v5)
      {
        *(double *)&v15 = 0.0;
        goto LABEL_8;
      }
    }
    *(double *)&v15 = 0.0;
    SVGAttribute::paintValue(v6, &v15);
LABEL_8:
    v7 = v3;
    while (1)
    {
      v8 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*(_QWORD *)(v7 + 56), 0x3Au);
      if (v8)
        break;
      v7 = *(_QWORD *)(v7 + 48);
      if (!v7)
      {
        v14 = 1.0;
        goto LABEL_13;
      }
    }
    v14 = 1.0;
    SVGAttribute::floatValue(v8, &v14);
LABEL_13:
    v9 = v3;
    while (1)
    {
      v10 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*(_QWORD *)(v9 + 56), 0x29u);
      if (v10)
        break;
      v9 = *(_QWORD *)(v9 + 48);
      if (!v9)
      {
        v13 = 1.0;
        goto LABEL_18;
      }
    }
    v13 = 1.0;
    SVGAttribute::floatValue(v10, &v13);
LABEL_18:
    if (*(double *)&v15 != 0.0 && *((_DWORD *)v15 + 12) && v14 != 0.0 && v13 != 0.0)
    {
      v4 = v3;
LABEL_23:
      while (!SVGAttributeMap::attribute(*(_QWORD *)(v4 + 56), 0x39u))
      {
        v4 = *(_QWORD *)(v4 + 48);
        if (!v4)
          return v2;
      }
      while (1)
      {
        v11 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*(_QWORD *)(v3 + 56), 0x3Bu);
        if (v11)
          break;
        v3 = *(_QWORD *)(v3 + 48);
        if (!v3)
          return 0.5;
      }
      *(double *)&v15 = 0.0;
      SVGAttribute::floatValue(v11, (double *)&v15);
      return *(double *)&v15 * 0.5;
    }
  }
  return v2;
}

double SVGNode::getBoundingBox(SVGNode *a1, const SVGNode *a2, uint64_t a3)
{
  int v3;
  double v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  CGAffineTransform v14;
  CGAffineTransform v15;
  CGRect v16;

  v3 = a3;
  v6 = SVGNode::calculateBoundingBox(a1, a3);
  v8 = v7;
  v10 = v9;
  v12 = v11;
  if (v3 != 3)
  {
    memset(&v15, 0, sizeof(v15));
    SVGNode::ancestorTransforms(a1, a2, (uint64_t)&v15);
    v14 = v15;
    v16.origin.x = v6;
    v16.origin.y = v8;
    v16.size.width = v10;
    v16.size.height = v12;
    *(_QWORD *)&v6 = (unint64_t)CGRectApplyAffineTransform(v16, &v14);
  }
  return v6;
}

uint64_t SVGNode::hasWideGamutColor(SVGNode *this)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  SVGPaint *v10;

  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    v10 = 0;
    v3 = (os_unfair_lock_s *)SVGAttributeMap::attribute(v2, 0x12u);
    if (v3)
    {
      if (SVGAttribute::paintValue(v3, &v10) && (SVGPaint::isWideGamut(v10) & 1) != 0)
        return 1;
    }
    v4 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*((_QWORD *)this + 7), 0x39u);
    if (v4)
    {
      if (SVGAttribute::paintValue(v4, &v10) && SVGPaint::isWideGamut(v10))
        return 1;
    }
  }
  v6 = *((_QWORD *)this + 11);
  v7 = *((_QWORD *)this + 12);
  if (v6 == v7)
    return 0;
  v8 = v6 + 8;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 - 8) + 40))(*(_QWORD *)(v8 - 8));
    if ((result & 1) != 0)
      break;
    v9 = v8 == v7;
    v8 += 8;
  }
  while (!v9);
  return result;
}

void SVGNode::print(SVGAttributeMap **this)
{
  _QWORD *v2;
  char *v3;
  const char *v4;
  SVGUtilities *v5;
  SVGUtilities *v6;
  SVGAttributeMap *v7;
  SVGAttributeMap *v8;
  uint64_t v9;

  v2 = this + 8;
  if (*((char *)this + 87) < 0)
    v2 = (_QWORD *)*v2;
  v3 = SVGNode::identifier((SVGNode *)this);
  v5 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"Node: %s (id: %s), %lu children, %lu definitions\n", v4, v2, v3, (this[12] - this[11]) >> 3, this[22]);
  SVGUtilities::indent(v5);
  v6 = (SVGUtilities *)SVGAttributeMap::print(this[7]);
  v8 = this[11];
  v7 = this[12];
  while (v8 != v7)
  {
    v9 = *(_QWORD *)v8;
    v8 = (SVGAttributeMap *)((char *)v8 + 8);
    v6 = (SVGUtilities *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
  }
  SVGUtilities::unindent(v6);
}

_QWORD *SVGNode::setComment(_QWORD *this, char *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  v3 = this;
  v4 = this[23];
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0)
      operator delete(*(void **)v4);
    this = (_QWORD *)MEMORY[0x20BCFC038](v4, 0x1012C40EC159624);
  }
  if (a2)
  {
    v5 = (_QWORD *)operator new();
    this = std::string::basic_string[abi:ne180100]<0>(v5, a2);
  }
  else
  {
    v5 = 0;
  }
  v3[23] = v5;
  return this;
}

void sub_20678EC78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x1012C40EC159624);
  _Unwind_Resume(a1);
}

void SVGNode::setText(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  std::string *v5;
  std::string *v6;

  v4 = *(_QWORD *)(a1 + 192);
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0)
      operator delete(*(void **)v4);
    MEMORY[0x20BCFC038](v4, 0x1012C40EC159624);
  }
  v5 = (std::string *)operator new();
  v6 = v5;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v5->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
  *(_QWORD *)(a1 + 192) = v6;
}

void sub_20678ED3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x1012C40EC159624);
  _Unwind_Resume(a1);
}

_QWORD *SVGNode::setText(_QWORD *this, char *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  v3 = this;
  v4 = this[24];
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0)
      operator delete(*(void **)v4);
    this = (_QWORD *)MEMORY[0x20BCFC038](v4, 0x1012C40EC159624);
  }
  if (a2)
  {
    v5 = (_QWORD *)operator new();
    this = std::string::basic_string[abi:ne180100]<0>(v5, a2);
  }
  else
  {
    v5 = 0;
  }
  v3[24] = v5;
  return this;
}

void sub_20678EDEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x1012C40EC159624);
  _Unwind_Resume(a1);
}

BOOL SVGNode::isChildOf(uint64_t a1, uint64_t a2)
{
  _BOOL8 v2;

  if (!a2)
    return 0;
  do
  {
    a1 = *(_QWORD *)(a1 + 48);
    v2 = a1 != 0;
  }
  while (a1 != a2 && a1 != 0);
  return v2;
}

void SVGNode::SVGNode(SVGNode *this, const SVGAttributeMap **a2)
{
  SVGAttributeMap *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  const SVGAttributeMap *v9;
  const SVGAttributeMap *v10;
  SVGNode *v11;
  void *__p[2];
  char v13;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v13 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8DD8;
  *((_QWORD *)this + 6) = 0;
  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4, a2[7]);
  *((_QWORD *)this + 7) = v4;
  if (*((char *)a2 + 87) >= 0)
    v5 = (char *)(a2 + 8);
  else
    v5 = (char *)a2[8];
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 8, v5);
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 17) = (char *)this + 144;
  *((_QWORD *)this + 19) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 20) = (char *)this + 168;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 22) = 0;
  v6 = (char *)a2[23];
  if (v6 && v6[23] < 0)
    v6 = *(char **)v6;
  SVGNode::setComment(this, v6);
  v7 = (char *)a2[24];
  if (v7 && v7[23] < 0)
    v7 = *(char **)v7;
  SVGNode::setText(this, v7);
  SVGAttributeMap::setOwnerNode(*((_QWORD *)this + 7), (uint64_t)this);
  v8 = (char *)a2[23];
  if (v8 && v8[23] < 0)
    v8 = *(char **)v8;
  SVGNode::setComment(this, v8);
  v9 = a2[11];
  v10 = a2[12];
  while (v9 != v10)
  {
    v11 = (SVGNode *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v9 + 16))(*(_QWORD *)v9);
    SVGNode::addChild(this, v11);
    CFRetained::release((CFTypeRef *)v11);
    v9 = (const SVGAttributeMap *)((char *)v9 + 8);
  }
}

void sub_20678EFDC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x20BCFC038](v2, 0x10B3C4084D8EEBALL);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGNode::hasMonochromeColor(SVGNode *this)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  _QWORD *v5;
  _QWORD *v6;
  SVGPaint *v8;
  SVGPaint *v9;

  v2 = *((_QWORD *)this + 7);
  if (!v2)
    return 1;
  v9 = 0;
  v3 = (os_unfair_lock_s *)SVGAttributeMap::attribute(v2, 0x12u);
  if (!v3 || !SVGAttribute::paintValue(v3, &v9) || (SVGPaint::isMonochrome((uint64_t)v9, (const char *)0x12) & 1) != 0)
  {
    v8 = 0;
    v4 = (os_unfair_lock_s *)SVGAttributeMap::attribute(*((_QWORD *)this + 7), 0x39u);
    if (!v4
      || !SVGAttribute::paintValue(v4, &v8)
      || SVGPaint::isMonochrome((uint64_t)v8, (const char *)0x39))
    {
      v6 = (_QWORD *)*((_QWORD *)this + 11);
      v5 = (_QWORD *)*((_QWORD *)this + 12);
      while (v6 != v5)
      {
        if (((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v6 + 56))(*v6) & 1) == 0)
          return 0;
        ++v6;
      }
      return 1;
    }
  }
  return 0;
}

void SVGNode::printTree(SVGNode *this)
{
  const char *v2;
  uint64_t v3;
  const char *v4;
  SVGNode **v5;
  SVGNode **v6;
  SVGNode *v7;
  SVGNode *v8;
  SVGNode *v9;
  SVGNode *v10;
  BOOL v11;
  std::string v12;
  SVGNode *v13;

  v2 = (char *)this + 64;
  if (*((char *)this + 87) < 0)
    v2 = *(const char **)v2;
  printf("\nNode: <%s>. ", v2);
  v3 = *((_QWORD *)this + 6);
  if (v3)
  {
    v4 = (const char *)(v3 + 64);
    if (*(char *)(v3 + 87) < 0)
      v4 = *(const char **)v4;
    printf("Parent: <%s>", v4);
  }
  puts("\nAttributes: ");
  SVGAttributeMap::print(*((SVGAttributeMap **)this + 7));
  v5 = (SVGNode **)*((_QWORD *)this + 11);
  v6 = (SVGNode **)*((_QWORD *)this + 12);
  while (v5 != v6)
  {
    v7 = *v5++;
    SVGNode::printTree(v7);
  }
  v8 = (SVGNode *)*((_QWORD *)this + 20);
  if (v8 != (SVGNode *)((char *)this + 168))
  {
    do
    {
      if (*((char *)v8 + 55) < 0)
        std::string::__init_copy_ctor_external(&v12, *((const std::string::value_type **)v8 + 4), *((_QWORD *)v8 + 5));
      else
        v12 = *(std::string *)((char *)v8 + 32);
      v13 = (SVGNode *)*((_QWORD *)v8 + 7);
      printf("\nNodes under <defs>:");
      SVGNode::printTree(v13);
      if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v12.__r_.__value_.__l.__data_);
      v9 = (SVGNode *)*((_QWORD *)v8 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(SVGNode **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (SVGNode *)*((_QWORD *)v8 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v8;
          v8 = v10;
        }
        while (!v11);
      }
      v8 = v10;
    }
    while (v10 != (SVGNode *)((char *)this + 168));
  }
}

void sub_20678F290(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGNode::enumerate(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  std::string __p;
  char v9;

  v9 = 0;
  v2 = *(_QWORD **)(a1 + 160);
  v3 = (_QWORD *)(a1 + 168);
  if (v2 != (_QWORD *)(a1 + 168))
  {
    do
    {
      if (*((char *)v2 + 55) < 0)
        std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v2[4], v2[5]);
      else
        __p = *(std::string *)(v2 + 4);
      (*(void (**)(uint64_t, std::string *, _QWORD, char *))(a2 + 16))(a2, &__p, v2[7], &v9);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (v9)
        break;
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
}

void sub_20678F380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

{
  char v4;
  std::string *v5;
  unsigned int v6;
  void *v8;
  std::string v9;
  std::string v10;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v10 = *(std::string *)a2;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v9 = *(std::string *)a3;
  v4 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v10;
  else
    v5 = (std::string *)v10.__r_.__value_.__r.__words[0];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v9.__r_.__value_.__r.__words[0];
    v6 = strcasecmp((const char *)v5, v9.__r_.__value_.__l.__data_);
    operator delete(v8);
    if ((*((_BYTE *)&v10.__r_.__value_.__s + 23) & 0x80) == 0)
      return v6 >> 31;
    goto LABEL_12;
  }
  v6 = strcasecmp((const char *)v5, (const char *)&v9);
  if (v4 < 0)
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  return v6 >> 31;
}

void sub_20678F470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20678F560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, (uint64_t)(v3 + 4), a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v6 == v2
    || std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>::operator()[abi:ne180100](v5, a2, (uint64_t)(v6 + 4)))
  {
    return v2;
  }
  return v6;
}

uint64_t std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = std::less<std::string>::operator()[abi:ne180100](v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:ne180100](v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

uint64_t *std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,SVGNode *>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__construct_node<std::pair<std::string const,SVGNode *>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__construct_node<std::pair<std::string const,SVGNode *>>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v6 + 7) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_20678F800(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::__erase_unique<std::string>(uint64_t **a1, uint64_t a2)
{
  uint64_t **v3;

  v3 = (uint64_t **)std::__tree<std::__value_type<std::string,SVGNode *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGNode *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGNode *>>>::find<std::string>((uint64_t)a1, a2);
  if (a1 + 1 == v3)
    return 0;
  std::__tree<std::__value_type<std::string,SVGAttributeMap *>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAttributeMap *>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAttributeMap *>>>::erase(a1, (uint64_t)v3);
  return 1;
}

void SVGPaint::SVGPaint(SVGPaint *this, SVGGradient *a2)
{
  void *__p[2];
  char v5;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v5 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EA8;
  *((_DWORD *)this + 12) = 2;
  SVGColor::SVGColor((uint64_t)this + 56, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 13) = a2;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  CFRetained::retain((uint64_t)a2);
}

void sub_20678F8FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void SVGPaint::SVGPaint(SVGPaint *this, const SVGGradient *a2)
{
  SVGGradient *v4;
  void *__p[2];
  char v6;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EA8;
  *((_DWORD *)this + 12) = 2;
  SVGColor::SVGColor((uint64_t)this + 56, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  v4 = (SVGGradient *)operator new();
  SVGGradient::SVGGradient(v4, a2);
  *((_QWORD *)this + 13) = v4;
}

void sub_20678FA04(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x20BCFC038](v2, 0x10F3C40967F26D3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void SVGPaint::SVGPaint(SVGPaint *this, SVGPattern *a2)
{
  void *__p[2];
  char v5;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v5 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EA8;
  *((_DWORD *)this + 12) = 3;
  SVGColor::SVGColor((uint64_t)this + 56, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = a2;
  CFRetained::retain((uint64_t)a2);
}

void sub_20678FB04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void SVGPaint::SVGPaint(SVGPaint *this, const SVGPaint *a2)
{
  int v4;
  SVGPattern *v5;
  SVGGradient *v6;
  _BYTE v7[40];
  void *__p[2];
  char v9;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGPaint::kSVGPaintClassName);
  CFRetained::CFRetained(this, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &off_24BFD8EA8;
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  SVGColor::SVGColor((uint64_t)this + 56, 0, 0.0, 0.0, 0.0, 1.0);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_QWORD *)this + 14) = 0;
  v4 = *((_DWORD *)this + 12);
  switch(v4)
  {
    case 3:
      v5 = (SVGPattern *)operator new();
      SVGPattern::SVGPattern(v5, *((const SVGPattern **)a2 + 14));
      *((_QWORD *)this + 14) = v5;
      break;
    case 2:
      v6 = (SVGGradient *)operator new();
      SVGGradient::SVGGradient(v6, *((const SVGGradient **)a2 + 13));
      *((_QWORD *)this + 13) = v6;
      break;
    case 1:
      SVGColor::SVGColor((uint64_t)v7, (uint64_t)a2 + 56);
      SVGColor::operator=((uint64_t)this + 56, (uint64_t)v7);
      break;
  }
}

void sub_20678FC7C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x20BCFC038](v2, 0x10F3C40967F26D3);
  *(_QWORD *)v1 = off_24BFD8A68;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t SVGPaint::isWideGamut(SVGPaint *this)
{
  int v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  _BYTE v12[32];
  int v13;

  v1 = *((_DWORD *)this + 12);
  if (v1 == 3)
  {
    v3 = *((_QWORD *)this + 14);
    v4 = *(_QWORD *)(v3 + 88);
    v5 = *(_QWORD *)(v3 + 96);
    if (v4 != v5)
    {
      v6 = v4 + 8;
      do
      {
        result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 - 8) + 40))(*(_QWORD *)(v6 - 8));
        if ((result & 1) != 0)
          break;
        v11 = v6 == v5;
        v6 += 8;
      }
      while (!v11);
      return result;
    }
    return 0;
  }
  if (v1 != 2)
  {
    if (v1 == 1)
      return *((_DWORD *)this + 22) == 15;
    return 0;
  }
  v7 = *((_QWORD *)this + 13);
  v8 = *(_QWORD *)(v7 + 208);
  v9 = *(_QWORD *)(v7 + 216);
  if (v8 == v9)
    return 0;
  v10 = v8 + 8;
  do
  {
    SVGColor::SVGColor((uint64_t)v12, *(_QWORD *)(v10 - 8) + 48);
    result = v13 == 15;
    v11 = v13 == 15 || v10 == v9;
    v10 += 8;
  }
  while (!v11);
  return result;
}

uint64_t SVGPaint::isEqual(SVGPaint *this, const SVGPaint *a2)
{
  int v2;
  SVGColor *v3;
  _BYTE v5[40];

  v2 = *((_DWORD *)this + 12);
  if (v2 != *((_DWORD *)a2 + 12))
    return 0;
  if (!v2)
    return 1;
  if (v2 == 2)
    return SVGGradient::isEqual(*((SVGGradient **)this + 13), *((const SVGGradient **)a2 + 13));
  if (v2 != 1)
    return SVGPattern::isEqual();
  v3 = (SVGPaint *)((char *)this + 56);
  SVGColor::SVGColor((uint64_t)v5, (uint64_t)a2 + 56);
  return SVGColor::isEqual(v3, (const SVGColor *)v5);
}

double SVGPaint::createStringRepresentation@<D0>(SVGPaint *this@<X0>, uint64_t a2@<X8>)
{
  double result;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[40];
  __int128 v9;
  uint64_t v10;

  std::string::basic_string[abi:ne180100]<0>((_QWORD *)a2, "none");
  v5 = *((_DWORD *)this + 12);
  switch(v5)
  {
    case 3:
      v6 = SVGNode::identifier(*((SVGNode **)this + 14));
      SVGParser::FormatString((SVGParser *)"url(#%s)", &v9, v6);
      break;
    case 2:
      v7 = SVGNode::identifier(*((SVGNode **)this + 13));
      SVGParser::FormatString((SVGParser *)"url(#%s)", &v9, v7);
      break;
    case 1:
      SVGColor::SVGColor((uint64_t)v8, (uint64_t)this + 56);
      SVGColor::GetStringForColor((uint64_t)v8, (uint64_t)&v9);
      break;
    default:
      return result;
  }
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  result = *(double *)&v9;
  *(_OWORD *)a2 = v9;
  *(_QWORD *)(a2 + 16) = v10;
  return result;
}

void sub_20678FF34(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t SVGPaint::isMonochrome(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t result;
  double v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  double v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  double v17;
  double v18;
  double v19;

  v2 = *(unsigned int *)(a1 + 48);
  result = 1;
  switch((int)v2)
  {
    case 0:
      return result;
    case 1:
      v5 = *(double *)(a1 + 64);
      if (vabdd_f64(*(double *)(a1 + 56), v5) >= 0.00000011920929)
        goto LABEL_22;
      result = vabdd_f64(v5, *(double *)(a1 + 72)) < 0.00000011920929;
      break;
    case 2:
      v6 = *(_QWORD *)(a1 + 104);
      v7 = *(_QWORD *)(v6 + 208);
      v8 = *(_QWORD *)(v6 + 216);
      if (v7 != v8)
      {
        for (i = v7 + 8; ; i += 8)
        {
          SVGColor::SVGColor((uint64_t)&v17, *(_QWORD *)(i - 8) + 48);
          if (vabdd_f64(v17, v18) >= 0.00000011920929)
            break;
          v10 = vabdd_f64(v18, v19);
          result = v10 < 0.00000011920929;
          if (v10 >= 0.00000011920929 || i == v8)
            return result;
        }
LABEL_22:
        result = 0;
      }
      break;
    case 3:
      v12 = *(_QWORD *)(a1 + 112);
      v13 = *(_QWORD *)(v12 + 88);
      v14 = *(_QWORD *)(v12 + 96);
      if (v13 != v14)
      {
        v15 = v13 + 8;
        do
        {
          result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v15 - 8) + 56))(*(_QWORD *)(v15 - 8));
          if ((_DWORD)result)
            v16 = v15 == v14;
          else
            v16 = 1;
          v15 += 8;
        }
        while (!v16);
      }
      break;
    default:
      SVGUtilities::log((SVGUtilities *)"\nUnsupported paint type : %u", a2, v2);
      result = 1;
      break;
  }
  return result;
}

BOOL SVGParser::ParseBinary(uint64_t a1, double *a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  SVGParser *v11;
  _BOOL8 result;

  v7 = a1 + 1;
  v8 = MEMORY[0x24BDAC740];
  while (1)
  {
    v9 = *(unsigned __int8 *)(v7 - 1);
    if (v9 <= 0x2E && ((1 << v9) & 0x680000000000) != 0)
      return 0;
    v11 = (SVGParser *)(char)v9;
    if ((v11 & 0x80000000) == 0 && (*(_DWORD *)(v8 + 4 * v9 + 60) & 0x400) != 0)
      break;
    result = SVGParser::IsAllowedSeparator(v11);
    if (!result)
      return result;
    ++v7;
  }
  if ((v11 & 0xFFFFFFFE) != 0x30)
    return 0;
  if (a4)
  {
    *a4 = 1;
    LOBYTE(v11) = *(_BYTE *)(v7 - 1);
  }
  *a2 = (double)((char)v11 - 48);
  if (a3)
    *a3 = v7;
  return 1;
}

uint64_t SVGParser::IsDigitCharacter(SVGParser *this)
{
  if (this <= 0x2E && ((1 << (char)this) & 0x680000000000) != 0)
    return 1;
  if ((this & 0x80000000) != 0)
    return 0;
  return (*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * this + 60) >> 10) & 1;
}

BOOL SVGParser::ParseCGFloatListEllipticalArcCurve(char *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v21;
  char *v22;

  v3 = 0;
  if (a1 && a3)
  {
    v6 = 0;
    v22 = a1;
    v7 = MEMORY[0x24BDAC740];
    while (1)
    {
      if (SVGParser::IsAllowedSeparator((SVGParser *)*a1))
      {
        do
          ++v22;
        while (SVGParser::IsAllowedSeparator((SVGParser *)*v22));
      }
      v8 = *v22;
      if ((v8 - 45) >= 2
        && (_DWORD)v8 != 43
        && (!*v22 || (v8 & 0x80) != 0 || (*(_DWORD *)(v7 + 4 * v8 + 60) & 0x400) == 0))
      {
        break;
      }
      v21 = 0;
      if ((v6 - 3) >= 2)
      {
        if (!SVGParser::ParseCGFloat(v22, (double *)&v21, &v22, 0))
          break;
      }
      else if (!SVGParser::ParseBinary((uint64_t)v22, (double *)&v21, &v22, 0))
      {
        break;
      }
      v10 = *(_QWORD **)(a3 + 8);
      v9 = *(_QWORD *)(a3 + 16);
      if ((unint64_t)v10 >= v9)
      {
        v12 = *(_QWORD **)a3;
        v13 = ((uint64_t)v10 - *(_QWORD *)a3) >> 3;
        v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v15 = v9 - (_QWORD)v12;
        if (v15 >> 2 > v14)
          v14 = v15 >> 2;
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v16 = v14;
        if (v16)
        {
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a3 + 16, v16);
          v12 = *(_QWORD **)a3;
          v10 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v17 = 0;
        }
        v18 = &v17[8 * v13];
        *(_QWORD *)v18 = v21;
        v11 = v18 + 8;
        while (v10 != v12)
        {
          v19 = *--v10;
          *((_QWORD *)v18 - 1) = v19;
          v18 -= 8;
        }
        *(_QWORD *)a3 = v18;
        *(_QWORD *)(a3 + 8) = v11;
        *(_QWORD *)(a3 + 16) = &v17[8 * v16];
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v10 = v21;
        v11 = v10 + 1;
      }
      *(_QWORD *)(a3 + 8) = v11;
      if ((_QWORD *)((char *)v11 - *(_QWORD *)a3) == (_QWORD *)56)
        v6 = 0;
      else
        ++v6;
      a1 = v22;
    }
    if (a2)
      *a2 = v22;
    return *(_QWORD *)(a3 + 8) != *(_QWORD *)a3;
  }
  return v3;
}

void SVGParser::GetSeparatedWhitespaceComponents(const char *a1, void **a2, char a3)
{
  size_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  unint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;

  v6 = strlen(a1);
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    v9 = MEMORY[0x24BDAC740];
    do
    {
      v10 = a1[v8];
      if ((v10 & 0x80000000) != 0)
      {
        if (__maskrune(v10, 0x4000uLL))
          goto LABEL_9;
      }
      else if ((*(_DWORD *)(v9 + 4 * v10 + 60) & 0x4000) != 0)
      {
        goto LABEL_9;
      }
      if ((a3 & 1) != 0 || a1[v8] != 44)
      {
        v11 = v8;
        if (v8 < v7)
        {
          v11 = v8;
          while (1)
          {
            v12 = a1[v11];
            if ((v12 & 0x80000000) != 0)
            {
              if (__maskrune(v12, 0x4000uLL))
                break;
            }
            else if ((*(_DWORD *)(v9 + 4 * v12 + 60) & 0x4000) != 0)
            {
              break;
            }
            if ((a3 & 1) == 0 && a1[v11] == 44)
              break;
            if (v7 == ++v11)
            {
              v11 = v7;
              break;
            }
          }
        }
        v13 = v11 - v8;
        v15 = (unint64_t *)a2[1];
        v14 = (unint64_t)a2[2];
        if ((unint64_t)v15 >= v14)
        {
          v17 = ((char *)v15 - (_BYTE *)*a2) >> 3;
          if ((unint64_t)(v17 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v18 = v14 - (_QWORD)*a2;
          v19 = v18 >> 2;
          if (v18 >> 2 <= (unint64_t)(v17 + 1))
            v19 = v17 + 1;
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
            v20 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v20 = v19;
          if (v20)
            v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a2 + 2), v20);
          else
            v21 = 0;
          v22 = (unint64_t *)&v21[8 * v17];
          *v22 = v8 | ((unint64_t)v13 << 32);
          v16 = v22 + 1;
          v24 = (char *)*a2;
          v23 = (char *)a2[1];
          if (v23 != *a2)
          {
            do
            {
              v25 = *((_QWORD *)v23 - 1);
              v23 -= 8;
              *--v22 = v25;
            }
            while (v23 != v24);
            v23 = (char *)*a2;
          }
          *a2 = v22;
          a2[1] = v16;
          a2[2] = &v21[8 * v20];
          if (v23)
            operator delete(v23);
        }
        else
        {
          *v15 = v8 | ((unint64_t)v13 << 32);
          v16 = v15 + 1;
        }
        a2[1] = v16;
        goto LABEL_37;
      }
LABEL_9:
      v11 = v8;
LABEL_37:
      v8 = v11 + 1;
    }
    while (v11 + 1 < v7);
  }
}

BOOL SVGParser::GetParentheticalComponent(const char *a1, uint64_t a2)
{
  int64_t v4;
  unint64_t v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  int64_t v9;

  v4 = strlen(a1);
  v5 = (unint64_t)&a1[v4];
  v6 = a1;
  if (v4 >= 1)
  {
    do
    {
      if (*v6 == 40)
        break;
      ++v6;
    }
    while ((unint64_t)v6 < v5);
  }
  v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) < v5)
  {
    v8 = &a1[v4] - v6 - 1;
    v7 = v6 + 1;
    while (*v7 != 41)
    {
      ++v7;
      if (!--v8)
      {
        v7 = &a1[v4];
        break;
      }
    }
  }
  v9 = v7 - v6;
  if (v7 - v6 >= 1)
    MEMORY[0x20BCFBFD8](a2);
  return v9 > 0;
}

void SVGParser::GetComponentsSeparatedByDelimiters(const char *a1, const char *a2, uint64_t *a3)
{
  char *v5;
  size_t v6;
  size_t v7;
  unint64_t v8;
  int64_t v9;
  int v10;
  const char *v11;
  char *v12;
  const char *v13;
  char *v14;
  int v15;
  const char *v16;
  _BOOL4 v17;
  BOOL v18;
  std::string::value_type *v19;
  char v20;
  unint64_t v21;
  __int128 v22;
  _BOOL4 v23;
  std::string::value_type *v24;
  unint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  const char *v30;
  int v31;
  BOOL v32;
  unsigned int v33;
  const char *v34;
  char *v35;
  std::string::value_type *__s[2];
  uint64_t v37;

  v5 = (char *)a1;
  v6 = strlen(a1);
  if ((v6 & 0x8000000000000000) == 0)
  {
    v7 = v6;
    v8 = (unint64_t)&v5[v6];
    v9 = strlen(a2);
    v10 = 0;
    v11 = &a2[v9];
    v12 = &v5[v7];
    v13 = a2 + 1;
    v14 = v5;
    v35 = 0;
    do
    {
      v15 = *v5;
      if (v9 < 1)
      {
        v17 = 0;
      }
      else
      {
        v16 = v13;
        do
        {
          v17 = *((unsigned __int8 *)v16 - 1) == v15;
          v18 = *((unsigned __int8 *)v16 - 1) == v15 || v16 >= v11;
          ++v16;
        }
        while (!v18);
      }
      if (v15 == 39 || v15 == 34)
      {
        if (v10)
        {
          if (v15 == v10)
          {
            TrimmedString(v35 + 1, v5 - 1, __s);
            v19 = (std::string::value_type *)HIBYTE(v37);
            v20 = HIBYTE(v37);
            if (v37 < 0)
              v19 = __s[1];
            if (v19)
            {
              v21 = a3[1];
              if (v21 >= a3[2])
              {
                v27 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a3, (__int128 *)__s);
              }
              else
              {
                if (SHIBYTE(v37) < 0)
                {
                  std::string::__init_copy_ctor_external((std::string *)a3[1], __s[0], (std::string::size_type)__s[1]);
                }
                else
                {
                  v22 = *(_OWORD *)__s;
                  *(_QWORD *)(v21 + 16) = v37;
                  *(_OWORD *)v21 = v22;
                }
                v27 = v21 + 24;
                a3[1] = v21 + 24;
              }
              a3[1] = v27;
              v20 = HIBYTE(v37);
            }
            if (v20 < 0)
              operator delete(__s[0]);
            v10 = 0;
            v35 = 0;
LABEL_65:
            v14 = v5 + 1;
            if ((unint64_t)(v5 + 1) < v8)
            {
              do
              {
                v33 = *v14;
                v34 = a2;
                if (v9 < 1)
                {
LABEL_69:
                  if ((v33 & 0x80000000) != 0)
                  {
                    if (!__maskrune(v33, 0x4000uLL))
                      goto LABEL_75;
                  }
                  else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v33 + 60) & 0x4000) == 0)
                  {
                    goto LABEL_75;
                  }
                }
                else
                {
                  while (*(unsigned __int8 *)v34 != v33)
                  {
                    if (++v34 >= v11)
                      goto LABEL_69;
                  }
                }
                ++v14;
              }
              while (v14 != (char *)v8);
              v14 = (char *)v8;
            }
          }
        }
        else
        {
          v10 = *v5;
          v35 = v5;
        }
      }
      else
      {
        if (v10)
          v23 = 0;
        else
          v23 = v17;
        if (v14 >= v5)
          v23 = 0;
        if ((char *)v8 == v5 || v23)
        {
          TrimmedString(v14, v5 - 1, __s);
          v24 = (std::string::value_type *)HIBYTE(v37);
          if (v37 < 0)
            v24 = __s[1];
          if (v24)
          {
            v25 = a3[1];
            if (v25 >= a3[2])
            {
              v28 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a3, (__int128 *)__s);
            }
            else
            {
              if (SHIBYTE(v37) < 0)
              {
                std::string::__init_copy_ctor_external((std::string *)a3[1], __s[0], (std::string::size_type)__s[1]);
              }
              else
              {
                v26 = *(_OWORD *)__s;
                *(_QWORD *)(v25 + 16) = v37;
                *(_OWORD *)v25 = v26;
              }
              v28 = v25 + 24;
              a3[1] = v25 + 24;
            }
            v13 = a2 + 1;
            a3[1] = v28;
          }
          if ((char *)v8 != v5 && (unint64_t)v14 < v8)
          {
            do
            {
              while (1)
              {
                v29 = *v14;
                v30 = a2;
                if (v9 >= 1)
                  break;
LABEL_52:
                if ((v29 & 0x80000000) != 0)
                  v31 = __maskrune(v29, 0x4000uLL);
                else
                  v31 = *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v29 + 60) & 0x4000;
                ++v14;
                if (v31)
                  v32 = v14 == v12;
                else
                  v32 = 1;
                if (v32)
                  goto LABEL_62;
              }
              while (*(unsigned __int8 *)v30 != v29)
              {
                if (++v30 >= v11)
                  goto LABEL_52;
              }
              ++v14;
            }
            while (v14 != v12);
          }
LABEL_62:
          if (SHIBYTE(v37) < 0)
            operator delete(__s[0]);
          if ((char *)v8 == v5)
            return;
          goto LABEL_65;
        }
      }
LABEL_75:
      ++v5;
    }
    while ((unint64_t)v5 <= v8);
  }
}

void sub_2067908F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)(v17 + 8) = v18;
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *TrimmedString@<X0>(char *__src@<X0>, char *a2@<X1>, _QWORD *a3@<X8>)
{
  const char *v3;
  char *v4;
  uint64_t v6;
  int64_t v7;
  unsigned int v8;
  unsigned int v9;

  v3 = a2;
  v4 = __src;
  v6 = MEMORY[0x24BDAC740];
  if (__src < a2)
  {
    v7 = a2 - __src;
    do
    {
      v8 = *v4;
      if ((v8 & 0x80000000) != 0)
      {
        if (!__maskrune(v8, 0x4000uLL))
          goto LABEL_9;
      }
      else if ((*(_DWORD *)(v6 + 4 * v8 + 60) & 0x4000) == 0)
      {
        goto LABEL_9;
      }
      ++v4;
      --v7;
    }
    while (v7);
    v4 = (char *)v3;
  }
LABEL_9:
  while (v3 > v4)
  {
    v9 = *v3;
    if ((v9 & 0x80000000) != 0)
    {
      if (!__maskrune(v9, 0x4000uLL))
        return std::string::basic_string[abi:ne180100](a3, v4, v3 - v4 + 1);
    }
    else if ((*(_DWORD *)(v6 + 4 * v9 + 60) & 0x4000) == 0)
    {
      return std::string::basic_string[abi:ne180100](a3, v4, v3 - v4 + 1);
    }
    --v3;
  }
  return std::string::basic_string[abi:ne180100](a3, v4, v3 - v4 + 1);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::__split_buffer<std::string>::pointer end;
  __int128 v12;
  uint64_t v13;
  std::__split_buffer<std::string> __v;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9)
    v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    end = __v.__end_;
  }
  else
  {
    v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_206790BB4(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void SVGReaderOptions::~SVGReaderOptions(SVGReaderOptions *this)
{
  const void *v2;

  CFRetained::release(*(_QWORD *)this);
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
}

void SVGReader::report(SVGReader *this, SVGParser *a2, uint64_t a3, uint64_t a4, ...)
{
  const char *v5;
  void **v6;
  void *__p[2];
  char v8;
  char v9[8];

  *(_QWORD *)v9 = &a4;
  SVGParser::FormatString(a2, (va_list *)v9, __p);
  if (v8 >= 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((a3 & 0x80000000) != 0)
    SVGUtilities::error((SVGUtilities *)"Reader: %s\n", v5, v6);
  else
    SVGUtilities::error((SVGUtilities *)"Reader: Error on line %d: %s\n", v5, a3, v6);
  if (v8 < 0)
    operator delete(__p[0]);
}

void sub_206790DF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFURLRef SVGRootNode::setWorkingDir(SVGRootNode *this, CFURLRef relativeURL)
{
  const void *v4;
  CFURLRef result;

  v4 = (const void *)*((_QWORD *)this + 34);
  if (v4)
    CFRelease(v4);
  result = CFURLCopyAbsoluteURL(relativeURL);
  *((_QWORD *)this + 34) = result;
  return result;
}

void SVGReader::parseXMLNodeGradient(SVGNode **a1, _xmlNode *a2, SVGNode *a3, int a4)
{
  SVGAttributeMap *v8;
  _BOOL8 v9;
  SVGNode *v10;
  const char *v11;
  _xmlNode *children;
  uint64_t v13;
  SVGAtom *name;
  SVGAttributeMap *v15;
  SVGAttribute *v16;
  uint64_t v17;
  __int128 v18;
  SVGAttributeMap *v19;
  SVGGradientStop *v20;
  _QWORD v21[5];
  std::string v22;
  SVGGradientStop *v23;
  std::string v24;
  std::string v25;
  __int128 *v26;
  __int128 *v27;
  void **v28[2];

  v8 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v8);
  SVGReader::parseXMLNodeAttributes((SVGReader *)a1, a2, v8);
  v9 = a4 == 48;
  v10 = (SVGNode *)operator new();
  SVGGradient::SVGGradient(v10, v9, 0);
  SVGNode::setAttributes(v10, (CFTypeRef *)v8);
  CFRetained::release((CFTypeRef *)v8);
  children = a2->children;
  if (children)
  {
    v13 = MEMORY[0x24BDAC760];
    do
    {
      name = (SVGAtom *)children->name;
      if (name && SVGAtom::ToName(name, v11) == 55)
      {
        v15 = (SVGAttributeMap *)operator new();
        SVGAttributeMap::SVGAttributeMap(v15);
        SVGReader::parseXMLNodeAttributes((SVGReader *)a1, children, v15);
        v16 = (SVGAttribute *)SVGAttributeMap::attribute((uint64_t)v15, 0x3Cu);
        if (v16)
        {
          v17 = SVGAttribute::stringValue(v16);
          if (*(char *)(v17 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)v17, *(_QWORD *)(v17 + 8));
          }
          else
          {
            v18 = *(_OWORD *)v17;
            v22.__r_.__value_.__r.__words[2] = *(_QWORD *)(v17 + 16);
            *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v18;
          }
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&v25, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
          else
            v25 = v22;
          SVGParser::ParseDeclarationBlockFromRuleset((char *)&v25, 1, (uint64_t *)&v26);
          if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v25.__r_.__value_.__l.__data_);
          v19 = (SVGAttributeMap *)operator new();
          SVGAttributeMap::SVGAttributeMap(v19);
          memset(&v24, 0, sizeof(v24));
          std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v24, v26, v27, 0xAAAAAAAAAAAAAAABLL * (((char *)v27 - (char *)v26) >> 3));
          SVGParser::ParseDeclarationBlockIntoAttributeMap((__int128 **)&v24, (uint64_t)v19);
          v28[0] = (void **)&v24;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v28);
          SVGAttributeMap::setAttributes((uint64_t)v15, (uint64_t)v19);
          CFRetained::release((CFTypeRef *)v19);
          v28[0] = (void **)&v26;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v28);
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v22.__r_.__value_.__l.__data_);
        }
        v22.__r_.__value_.__r.__words[0] = 0;
        v22.__r_.__value_.__l.__size_ = (std::string::size_type)&v22;
        v22.__r_.__value_.__r.__words[2] = 0x2000000000;
        v23 = 0;
        v20 = (SVGGradientStop *)operator new();
        SVGGradientStop::SVGGradientStop(v20);
        v23 = v20;
        v21[0] = v13;
        v21[1] = 0x40000000;
        v21[2] = ___ZN9SVGReader20parseXMLNodeGradientEP8_xmlNodeP7SVGNodeN7SVGAtom4NameE_block_invoke;
        v21[3] = &unk_24BFD9300;
        v21[4] = &v22;
        SVGAttributeMap::enumerate((uint64_t)v15, (uint64_t)v21);
        CFRetained::release((CFTypeRef *)v15);
        SVGGradient::addStop(v10, *(SVGGradientStop **)(v22.__r_.__value_.__l.__size_ + 24));
        CFRetained::release(*(CFTypeRef **)(v22.__r_.__value_.__l.__size_ + 24));
        _Block_object_dispose(&v22, 8);
      }
      children = children->next;
    }
    while (children);
  }
  SVGNode::addDefinitionNode(a1[1], a3, v10);
  CFRetained::release((CFTypeRef *)v10);
}

void sub_206791148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32)
{
  uint64_t v32;

  MEMORY[0x20BCFC038](v32, 0x10F3C40967F26D3);
  _Unwind_Resume(a1);
}

double ___ZN9SVGReader20parseXMLNodeGradientEP8_xmlNodeP7SVGNodeN7SVGAtom4NameE_block_invoke(uint64_t a1, int a2, os_unfair_lock_s *this)
{
  double result;
  SVGGradientStop *v5;
  double v6[6];
  double v7;
  SVGPaint *v8;

  v7 = 0.0;
  v8 = 0;
  if (a2 == 83)
  {
    if (SVGAttribute::floatValue(this, &v7))
    {
      result = v7;
      *(double *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 88) = v7;
    }
  }
  else if (a2 == 56)
  {
    if (SVGAttribute::paintValue(this, &v8) && *((_DWORD *)v8 + 12) == 1)
    {
      v5 = *(SVGGradientStop **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      SVGColor::SVGColor((uint64_t)v6, (uint64_t)v8 + 56);
      return SVGGradientStop::setColor(v5, (const SVGColor *)v6);
    }
  }
  else if (a2 == 40 && SVGAttribute::lengthValue((uint64_t)this, (uint64_t)v6))
  {
    result = v6[0];
    *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 96) = *(_OWORD *)v6;
  }
  return result;
}

void ApplyVariablesToAttributes(const SVGAttributeMap *a1, SVGAttributeMap *a2)
{
  SVGAttributeMap *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  SVGAttributeMap *v12;

  if (SVGAttributeMap::count(a1))
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    v4 = (SVGAttributeMap *)operator new();
    SVGAttributeMap::SVGAttributeMap(v4);
    v12 = v4;
    v5 = MEMORY[0x24BDAC760];
    v8[0] = MEMORY[0x24BDAC760];
    v8[1] = 0x40000000;
    v8[2] = ___ZL26ApplyVariablesToAttributesPK15SVGAttributeMapPS__block_invoke;
    v8[3] = &unk_24BFD9348;
    v8[4] = &v9;
    v8[5] = a1;
    SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v8);
    v6 = v10[3];
    v7[0] = v5;
    v7[1] = 0x40000000;
    v7[2] = ___ZL26ApplyVariablesToAttributesPK15SVGAttributeMapPS__block_invoke_2;
    v7[3] = &__block_descriptor_tmp_27;
    v7[4] = a2;
    SVGAttributeMap::enumerate(v6, (uint64_t)v7);
    CFRetained::release((CFTypeRef *)v10[3]);
    _Block_object_dispose(&v9, 8);
  }
}

void sub_206791408(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

uint64_t SetNodeTextIfAvailable(_xmlNode *a1, SVGNode *a2)
{
  char *Content;
  char *v4;
  std::string::size_type size;
  char v6;
  std::string __p;
  std::string v9;

  Content = (char *)xmlNodeGetContent(a1);
  v4 = Content;
  if (Content && *Content)
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, Content);
    SVGParser::StripLeadingTrailingWhitespace(&__p, &v9);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
    v6 = HIBYTE(v9.__r_.__value_.__r.__words[2]);
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v9.__r_.__value_.__l.__size_;
    if (size)
    {
      SVGNode::setText((uint64_t)a2, (uint64_t)&v9);
      v6 = HIBYTE(v9.__r_.__value_.__r.__words[2]);
    }
    if (v6 < 0)
      operator delete(v9.__r_.__value_.__l.__data_);
  }
  return ((uint64_t (*)(char *))*MEMORY[0x24BEDE758])(v4);
}

void sub_2067914E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void SVGReader::parseXMLNodeClipPath(SVGNode **this, _xmlNode *a2, SVGNode *a3)
{
  SVGAttributeMap *v6;
  SVGClipPath *v7;
  SVGAttributeMap *v8;
  const SVGAttributeMap **v9;
  _xmlNode *i;

  v6 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v6);
  SVGReader::parseXMLNodeAttributes((SVGReader *)this, a2, v6);
  v7 = (SVGClipPath *)operator new();
  SVGClipPath::SVGClipPath(v7, 0);
  v9 = (const SVGAttributeMap **)*this;
  if (*this && *v9)
    ApplyVariablesToAttributes(*v9, v6);
  SVGReader::ApplyStyleToAttributes(v7, this[2], v6, v8);
  SVGNode::setAttributes(v7, (CFTypeRef *)v6);
  CFRetained::release((CFTypeRef *)v6);
  for (i = a2->children; i; i = i->next)
    SVGReader::parseXMLNode((SVGReader *)this, i, v7);
  SVGNode::addDefinitionNode(this[1], a3, v7);
  CFRetained::release((CFTypeRef *)v7);
}

void sub_206791614(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4094216EFELL);
  _Unwind_Resume(a1);
}

void SVGReader::parseXMLNodeMask(SVGNode **this, _xmlNode *a2, SVGNode *a3)
{
  SVGAttributeMap *v6;
  SVGMask *v7;
  SVGAttributeMap *v8;
  const SVGAttributeMap **v9;
  _xmlNode *i;

  v6 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v6);
  SVGReader::parseXMLNodeAttributes((SVGReader *)this, a2, v6);
  v7 = (SVGMask *)operator new();
  SVGMask::SVGMask(v7, 0);
  v9 = (const SVGAttributeMap **)*this;
  if (*this && *v9)
    ApplyVariablesToAttributes(*v9, v6);
  SVGReader::ApplyStyleToAttributes(v7, this[2], v6, v8);
  SVGNode::setAttributes(v7, (CFTypeRef *)v6);
  CFRetained::release((CFTypeRef *)v6);
  for (i = a2->children; i; i = i->next)
    SVGReader::parseXMLNode((SVGReader *)this, i, v7);
  SVGNode::addDefinitionNode(this[1], a3, v7);
  CFRetained::release((CFTypeRef *)v7);
}

void sub_206791744(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40691FC75FLL);
  _Unwind_Resume(a1);
}

void SVGReader::parseXMLNodePattern(SVGNode **this, _xmlNode *a2, SVGNode *a3)
{
  SVGAttributeMap *v6;
  SVGPattern *v7;
  SVGAttributeMap *v8;
  const SVGAttributeMap **v9;
  _xmlNode *i;

  v6 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v6);
  SVGReader::parseXMLNodeAttributes((SVGReader *)this, a2, v6);
  v7 = (SVGPattern *)operator new();
  SVGPattern::SVGPattern(v7);
  v9 = (const SVGAttributeMap **)*this;
  if (*this && *v9)
    ApplyVariablesToAttributes(*v9, v6);
  SVGReader::ApplyStyleToAttributes(v7, this[2], v6, v8);
  SVGNode::setAttributes(v7, (CFTypeRef *)v6);
  CFRetained::release((CFTypeRef *)v6);
  for (i = a2->children; i; i = i->next)
    SVGReader::parseXMLNode((SVGReader *)this, i, v7);
  SVGNode::addDefinitionNode(this[1], a3, v7);
  CFRetained::release((CFTypeRef *)v7);
}

void sub_206791870(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40827AA555);
  _Unwind_Resume(a1);
}

void SVGReader::parseXMLNodeFilter(SVGNode **this, _xmlNode *a2, SVGNode *a3)
{
  SVGFilter *v6;
  SVGAttributeMap *v7;
  SVGAttributeMap *v8;
  const SVGAttributeMap **v9;
  const char *v10;
  _xmlNode *i;
  unsigned int v12;
  uint64_t v13;
  SVGReader *v14;
  SVGAttributeMap *v15;
  SVGAttributeMap *v16;
  const SVGAttributeMap **v17;

  v6 = (SVGFilter *)operator new();
  SVGFilter::SVGFilter(v6, 0);
  v7 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v7);
  SVGReader::parseXMLNodeAttributes((SVGReader *)this, a2, v7);
  v9 = (const SVGAttributeMap **)*this;
  if (*this && *v9)
    ApplyVariablesToAttributes(*v9, v7);
  SVGReader::ApplyStyleToAttributes(v6, this[2], v7, v8);
  SVGNode::setAttributes(v6, (CFTypeRef *)v7);
  CFRetained::release((CFTypeRef *)v7);
  for (i = a2->children; i; i = i->next)
  {
    v12 = SVGAtom::ToName((SVGAtom *)i->name, v10);
    if (SVGFilter::IsValidFilterPrimitive(v12))
    {
      v13 = SVGFilter::filterPrimitive(v12);
      if (!v13)
        goto LABEL_13;
      v14 = (SVGReader *)v13;
      v15 = (SVGAttributeMap *)operator new();
      SVGAttributeMap::SVGAttributeMap(v15);
      SVGReader::parseXMLNodeAttributes((SVGReader *)this, i, v15);
      v17 = (const SVGAttributeMap **)*this;
      if (*this && *v17)
        ApplyVariablesToAttributes(*v17, v15);
      SVGReader::ApplyStyleToAttributes(v14, this[2], v15, v16);
      SVGNode::setAttributes(v14, (CFTypeRef *)v15);
      CFRetained::release((CFTypeRef *)v15);
      SVGNode::addChild(v6, v14);
      CFRetained::release((CFTypeRef *)v14);
    }
  }
  SVGNode::addDefinitionNode(this[1], a3, v6);
LABEL_13:
  CFRetained::release((CFTypeRef *)v6);
}

void sub_206791A3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

SVGImage *SVGReader::parseXMLNodeImage(SVGNode **this, _xmlNode *a2)
{
  SVGAttributeMap *v4;
  SVGAttribute *v5;
  uint64_t v6;
  __int128 v7;
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFAllocator *v10;
  std::string *p_p;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  _BOOL4 v15;
  _BOOL4 v16;
  char v17;
  int v18;
  SVGImage *v19;
  SVGImage *v20;
  BOOL v21;
  SVGAttributeMap *v22;
  const SVGAttributeMap **v23;
  CGImageSource *v25;
  CGImageSource *v26;
  CGImage *ImageAtIndex;
  SVGDocument *v28;
  const __CFURL *v29;
  const __CFData *CFDataFromDataURL;
  _BOOL4 v31;
  SVGImage *v32;
  BOOL v33;
  std::string __p;
  int v35;
  char v36;
  int v37;

  v4 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v4);
  SVGReader::parseXMLNodeAttributes((SVGReader *)this, a2, v4);
  v5 = (SVGAttribute *)SVGAttributeMap::attribute((uint64_t)v4, 0x4E20u);
  if (!v5)
  {
    v8 = 0;
    goto LABEL_16;
  }
  v6 = SVGAttribute::stringValue(v5);
  if (*(char *)(v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
  }
  else
  {
    v7 = *(_OWORD *)v6;
    __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v7;
  }
  v9 = (const __CFURL *)*((_QWORD *)this[1] + 34);
  v10 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)p_p, 0x8000100u);
  v8 = CFURLCreateWithString(v10, v12, v9);
  if (v12)
    CFRelease(v12);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v8)
      goto LABEL_13;
LABEL_16:
    v15 = 0;
    v16 = 0;
    v17 = 1;
    goto LABEL_26;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v8)
    goto LABEL_16;
LABEL_13:
  v13 = CFURLCopyScheme(v8);
  v14 = v13;
  if (v13)
    v15 = CFStringCompare(v13, CFSTR("data"), 0) == kCFCompareEqualTo;
  else
    v15 = 0;
  if (!*this)
    goto LABEL_23;
  v18 = *((_DWORD *)*this + 6);
  if (v18 != 2)
  {
    if (v18 == 1)
    {
      if (!v14)
      {
        v17 = 0;
        v16 = 1;
        goto LABEL_39;
      }
      v16 = CFStringCompare(v14, CFSTR("file"), 0) == kCFCompareEqualTo;
      goto LABEL_24;
    }
LABEL_23:
    v16 = 0;
    if (!v14)
      goto LABEL_25;
    goto LABEL_24;
  }
  v16 = 1;
  if (v14)
LABEL_24:
    CFRelease(v14);
LABEL_25:
  v17 = 0;
  if (v15)
  {
LABEL_39:
    v25 = CGImageSourceCreateWithURL(v8, 0);
    if (v25)
    {
      v26 = v25;
      ImageAtIndex = CGImageSourceCreateImageAtIndex(v25, 0, 0);
      CFRelease(v26);
      if (ImageAtIndex)
      {
        v20 = (SVGImage *)operator new();
        SVGImage::SVGImage(v20, ImageAtIndex);
        CGImageRelease(ImageAtIndex);
        if ((v17 & 1) != 0)
          goto LABEL_32;
        goto LABEL_31;
      }
    }
    v28 = (SVGDocument *)operator new();
    SVGDocument::SVGDocument(v28);
    __p.__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__s.__data_[8] = 0;
    __p.__r_.__value_.__r.__words[2] = 0;
    v37 = 0;
    v35 = 0;
    v36 = 0;
    if (v15)
    {
      CFDataFromDataURL = (const __CFData *)SVGUtilities::CreateCFDataFromDataURL(v8, v29);
      if (!CFDataFromDataURL)
        goto LABEL_51;
      v31 = SVGDocument::read(v28, CFDataFromDataURL, (SVGReaderOptions *)&__p);
      CFRelease(CFDataFromDataURL);
      if (!v31)
        goto LABEL_51;
    }
    else if (!v16 || !SVGDocument::read(v28, v8, (SVGReaderOptions *)&__p))
    {
      goto LABEL_51;
    }
    if (*((_QWORD *)v28 + 6))
    {
      v20 = (SVGImage *)operator new();
      SVGImage::SVGImage(v20, (CFTypeRef *)v28);
      goto LABEL_55;
    }
LABEL_51:
    v32 = (SVGImage *)operator new();
    v20 = v32;
    if (*this)
      v33 = *((_BYTE *)*this + 28) != 0;
    else
      v33 = 1;
    SVGImage::SVGImage(v32, v33);
LABEL_55:
    CFRetained::release((CFTypeRef *)v28);
    SVGReaderOptions::~SVGReaderOptions((SVGReaderOptions *)&__p);
    if ((v17 & 1) != 0)
      goto LABEL_32;
    goto LABEL_31;
  }
LABEL_26:
  if (v16)
    goto LABEL_39;
  v19 = (SVGImage *)operator new();
  v20 = v19;
  if (*this)
    v21 = *((_BYTE *)*this + 28) != 0;
  else
    v21 = 1;
  SVGImage::SVGImage(v19, v21);
  if ((v17 & 1) != 0)
    goto LABEL_32;
LABEL_31:
  CFRelease(v8);
LABEL_32:
  v23 = (const SVGAttributeMap **)*this;
  if (*this && *v23)
    ApplyVariablesToAttributes(*v23, v4);
  SVGReader::ApplyStyleToAttributes(v20, this[2], v4, v22);
  SVGNode::setAttributes(v20, (CFTypeRef *)v4);
  CFRetained::release((CFTypeRef *)v4);
  return v20;
}

void sub_206791E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;

  MEMORY[0x20BCFC038](v14, 0x10F3C40F9C81853);
  SVGReaderOptions::~SVGReaderOptions((SVGReaderOptions *)&__p);
  _Unwind_Resume(a1);
}

void ResolveGradientHrefDefinition(uint64_t a1, const char *a2)
{
  SVGAtom *v3;
  int v4;
  SVGAtom *v5;
  const char *v6;
  SVGGradient *v7;
  SVGGradient *v8;
  SVGAttribute *v9;
  const char *v10;
  SVGAttribute *v11;
  uint64_t v12;
  __int128 v13;
  std::string::size_type size;
  std::string *v15;
  SVGNode *DefinitionNode;
  const char *v17;
  SVGNode *v18;
  const SVGGradient *v19;
  std::string v20;
  std::string __str;
  char v22;

  v3 = (SVGAtom *)(a1 + 64);
  v4 = *(char *)(a1 + 87);
  v5 = (SVGAtom *)(a1 + 64);
  if (v4 < 0)
    v5 = *(SVGAtom **)v3;
  if (SVGAtom::ToName(v5, a2) == 33)
    goto LABEL_34;
  if (*(char *)(a1 + 87) < 0)
    v3 = *(SVGAtom **)v3;
  if (SVGAtom::ToName(v3, v6) == 48)
  {
LABEL_34:
    if (v7)
    {
      v8 = v7;
      if (!*((_BYTE *)v7 + 440))
      {
        *((_BYTE *)v7 + 440) = 1;
        v9 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), 0x4E20u);
        if (v9)
        {
          v11 = v9;
          if (!*((_DWORD *)v9 + 20) && SVGAttribute::stringValueBeginsWith(v9, "#", v10))
          {
            v12 = SVGAttribute::stringValue(v11);
            if (*(char *)(v12 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v12, *(_QWORD *)(v12 + 8));
            }
            else
            {
              v13 = *(_OWORD *)v12;
              __str.__r_.__value_.__r.__words[2] = *(_QWORD *)(v12 + 16);
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v13;
            }
            size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __str.__r_.__value_.__l.__size_;
            std::string::basic_string(&v20, &__str, 1uLL, size - 1, (std::allocator<char> *)&v22);
            if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
            {
              if (!v20.__r_.__value_.__l.__size_)
              {
LABEL_28:
                if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v20.__r_.__value_.__l.__data_);
                goto LABEL_30;
              }
              v15 = (std::string *)v20.__r_.__value_.__r.__words[0];
            }
            else
            {
              if (!*((_BYTE *)&v20.__r_.__value_.__s + 23))
              {
LABEL_30:
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__str.__r_.__value_.__l.__data_);
                return;
              }
              v15 = &v20;
            }
            DefinitionNode = SVGNode::findDefinitionNode((SVGNode *)a1, (char *)v15);
            v18 = DefinitionNode;
            if (DefinitionNode)
            {
              if (v19 && v8 != v19)
              {
                SVGGradient::setParentGradient(v8, v19);
                ResolveGradientHrefDefinition(v18);
              }
            }
            else
            {
              SVGUtilities::log((SVGUtilities *)"Failed to resolve gradient xlink:href definition\n", v17);
            }
            goto LABEL_28;
          }
        }
      }
    }
  }
}

void sub_2067920D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void ResolvePatternHrefDefinition(uint64_t a1, const char *a2)
{
  SVGAtom *v3;
  SVGPattern *v4;
  SVGPattern *v5;
  SVGAttribute *v6;
  const char *v7;
  SVGAttribute *v8;
  uint64_t v9;
  __int128 v10;
  std::string::size_type size;
  std::string *v12;
  SVGNode *DefinitionNode;
  const char *v14;
  SVGNode *v15;
  SVGPattern *v16;
  SVGPattern *v17;
  std::string v18;
  std::string __str;
  char v20;

  v3 = (SVGAtom *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
    v3 = *(SVGAtom **)v3;
  if (SVGAtom::ToName(v3, a2) == 79)
  {
    if (v4)
    {
      v5 = v4;
      if (!*((_BYTE *)v4 + 280))
      {
        *((_BYTE *)v4 + 280) = 1;
        v6 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 56), 0x4E20u);
        if (v6)
        {
          v8 = v6;
          if (!*((_DWORD *)v6 + 20) && SVGAttribute::stringValueBeginsWith(v6, "#", v7))
          {
            v9 = SVGAttribute::stringValue(v8);
            if (*(char *)(v9 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v9, *(_QWORD *)(v9 + 8));
            }
            else
            {
              v10 = *(_OWORD *)v9;
              __str.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 16);
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v10;
            }
            size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __str.__r_.__value_.__l.__size_;
            std::string::basic_string(&v18, &__str, 1uLL, size - 1, (std::allocator<char> *)&v20);
            if (!std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v18, (char *)&unk_20679A6BE))
            {
              if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v12 = &v18;
              else
                v12 = (std::string *)v18.__r_.__value_.__r.__words[0];
              DefinitionNode = SVGNode::findDefinitionNode((SVGNode *)a1, (char *)v12);
              v15 = DefinitionNode;
              if (DefinitionNode)
              {
                if (v16)
                {
                  v17 = v16;
                  if (v5 != v16)
                  {
                    *((_QWORD *)v5 + 34) = v16;
                    SVGPattern::inheritParentPattern(v5);
                    ResolvePatternHrefDefinition(v15);
                    *((_QWORD *)v5 + 34) = v17;
                    SVGPattern::inheritParentPattern(v5);
                  }
                }
              }
              else
              {
                SVGUtilities::log((SVGUtilities *)"Failed to resolve pattern xlink:href definition\n", v14);
              }
            }
            if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v18.__r_.__value_.__l.__data_);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__str.__r_.__value_.__l.__data_);
          }
        }
      }
    }
  }
}

void sub_2067922CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void ___ZL26ApplyVariablesToAttributesPK15SVGAttributeMapPS__block_invoke(uint64_t a1, int a2, SVGAttribute *this)
{
  uint64_t v5;
  const char *v6;
  __int128 v7;
  std::string *v8;
  std::string *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  SVGParser *v14;
  const char *v15;
  unsigned int v16;
  SVGAttribute *v17;
  uint64_t v18;
  uint64_t v19;
  const std::string *v20;
  std::string __p;
  void **v22;
  void **v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::string v28;

  v5 = SVGAttribute::stringValue(this);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
  }
  else
  {
    v7 = *(_OWORD *)v5;
    v28.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 16);
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v7;
  }
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = &v28;
  else
    v8 = (std::string *)v28.__r_.__value_.__r.__words[0];
  if (SVGParser::StringBeginsWith((SVGParser *)v8, "var(", v6))
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = &v28;
    else
      v9 = (std::string *)v28.__r_.__value_.__r.__words[0];
    SVGParser::GetComponentsSeparatedByDelimiters((const char *)v9, "())", &v25);
    if (v26 - v25 == 48)
    {
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v10 = (const char *)(v25 + 24);
      if (*(char *)(v25 + 47) < 0)
        v10 = *(const char **)v10;
      SVGParser::GetComponentsSeparatedByDelimiters(v10, ",", (uint64_t *)&v22);
      if (v23 != v22)
      {
        v12 = 0;
        if ((unint64_t)(((char *)v23 - (char *)v22) / 24) <= 1)
          v13 = 1;
        else
          v13 = ((char *)v23 - (char *)v22) / 24;
        while (1)
        {
          v14 = (SVGParser *)&v22[v12];
          if (SHIBYTE(v22[v12 + 2]) < 0)
            v14 = *(SVGParser **)v14;
          if (!SVGParser::StringBeginsWith(v14, "--", v11))
            break;
          v16 = SVGAtom::ToName(v14, v15);
          v17 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(a1 + 40), v16);
          if (v17)
          {
            v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            v20 = (const std::string *)SVGAttribute::stringValue(v17);
            SVGAttributeMap::setAttribute(v19, a2, v20);
            goto LABEL_27;
          }
          v12 += 3;
          if (!--v13)
            goto LABEL_27;
        }
        v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v14);
        SVGAttributeMap::setAttribute(v18, a2, &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
LABEL_27:
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v22;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
    }
    v22 = (void **)&v25;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v22);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
}

void sub_206792508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char **__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15 < 0)
    operator delete(__p);
  __p = &a16;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a16 = &a19;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

void ___ZL26ApplyVariablesToAttributesPK15SVGAttributeMapPS__block_invoke_2(uint64_t a1, uint64_t a2, const SVGAttribute *a3)
{
  SVGAttribute *v5;

  v5 = (SVGAttribute *)operator new();
  SVGAttribute::SVGAttribute(v5, a3);
  SVGAttributeMap::setAttribute(*(_QWORD *)(a1 + 32), (uint64_t)v5, 0);
  CFRetained::release((CFTypeRef *)v5);
}

void sub_2067925E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t ___ZL28ConvertUseElementCoordinatesP15SVGAttributeMapR6CGRect_block_invoke(uint64_t result, int a2, os_unfair_lock_s *this)
{
  uint64_t v3;
  double *v4;

  v3 = result;
  if (a2 > 66)
  {
    if (a2 == 70)
    {
      v4 = (double *)(*(_QWORD *)(result + 40) + 8);
    }
    else
    {
      if (a2 != 67)
        return result;
      v4 = *(double **)(result + 40);
    }
  }
  else if (a2 == 30)
  {
    v4 = (double *)(*(_QWORD *)(result + 40) + 24);
  }
  else
  {
    if (a2 != 66)
      return result;
    v4 = (double *)(*(_QWORD *)(result + 40) + 16);
  }
  result = SVGAttribute::floatValue(this, v4);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = 1;
  return result;
}

SVGRootNode *SVGRootNode::copy(const __CFURL **this)
{
  SVGRootNode *v2;

  v2 = (SVGRootNode *)operator new();
  SVGRootNode::SVGRootNode(v2, this);
  return v2;
}

void sub_2067926CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40BD1137ACLL);
  _Unwind_Resume(a1);
}

void SVGRootNode::print(SVGRootNode *this, const char *a2)
{
  const char *v3;
  SVGUtilities *v4;
  const char *v5;
  SVGUtilities *v6;
  SVGUtilities *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;

  SVGUtilities::print((SVGUtilities *)"\n", a2);
  v4 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"RootNode: Size: {%.2f, %.2f} Viewbox: ", v3, *((_QWORD *)this + 27), *((_QWORD *)this + 28));
  SVGUtilities::printIgnoringIndention(v4, *(CGRect *)((char *)this + 232));
  v6 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"\n", v5);
  SVGUtilities::indent(v6);
  v9 = (uint64_t *)*((_QWORD *)this + 11);
  v8 = (uint64_t *)*((_QWORD *)this + 12);
  while (v9 != v8)
  {
    v10 = *v9++;
    v7 = (SVGUtilities *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 48))(v10);
  }
  SVGUtilities::unindent(v7);
}

void SVGRootNode::adjustSizeAndViewboxToFitContents(SVGRootNode *this, CGSize a2)
{
  double height;
  double width;
  CGRect v5;

  height = a2.height;
  width = a2.width;
  v5.origin.x = (*(double (**)(SVGRootNode *, _QWORD))(*(_QWORD *)this + 32))(this, 0);
  *((_QWORD *)this + 27) = *(_QWORD *)&v5.size.width;
  *((_QWORD *)this + 28) = *(_QWORD *)&v5.size.height;
  *(CGRect *)((char *)this + 232) = CGRectInset(v5, -width, -height);
}

void SVGRootNode::SVGRootNode(SVGRootNode *this, const __CFURL **a2)
{
  _QWORD *v4;
  const __CFURL *v5;

  SVGViewBoxNode::SVGViewBoxNode(this, (const SVGViewBoxNode *)a2);
  *v4 = &off_24BFD8BA8;
  v4[34] = 0;
  v5 = a2[34];
  if (v5)
    *((_QWORD *)this + 34) = CFURLCopyAbsoluteURL(v5);
}

void sub_206792814(_Unwind_Exception *a1)
{
  SVGMask *v1;

  SVGMask::~SVGMask(v1);
  _Unwind_Resume(a1);
}

void SVGFilter::SVGFilter(SVGFilter *this, char *a2)
{
  uint64_t v3;

  v3 = SVGNode::SVGNode((uint64_t)this, 0x54u);
  *(_QWORD *)v3 = &off_24BFD8EE8;
  *(int64x2_t *)(v3 + 200) = vdupq_n_s64(0xBFB999999999999ALL);
  *(int64x2_t *)(v3 + 216) = vdupq_n_s64(0x3FF3333333333333uLL);
  *(_QWORD *)(v3 + 232) = 0x100000000;
  *(_BYTE *)(v3 + 240) = 0;
  SVGNode::setIdentifier((SVGNode *)v3, a2);
}

void sub_2067928A0(_Unwind_Exception *a1)
{
  SVGNode *v1;

  SVGNode::~SVGNode(v1);
  _Unwind_Resume(a1);
}

void SVGFilter::SVGFilter(SVGFilter *this, const SVGAttributeMap **a2)
{
  uint64_t v2;

  SVGNode::SVGNode(this, a2);
  *(_QWORD *)v2 = &off_24BFD8EE8;
  *(int64x2_t *)(v2 + 200) = vdupq_n_s64(0xBFB999999999999ALL);
  *(int64x2_t *)(v2 + 216) = vdupq_n_s64(0x3FF3333333333333uLL);
  *(_QWORD *)(v2 + 232) = 0x100000000;
  *(_BYTE *)(v2 + 240) = 0;
}

void SVGFilter::~SVGFilter(SVGFilter *this)
{
  SVGNode::~SVGNode(this);
  JUMPOUT(0x20BCFC038);
}

void SVGFilter::draw(SVGFilter *this, CGContext *a2, const SVGNode *a3, CGRect a4, CGRect a5)
{
  double height;
  double width;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  CGImageRef SourceImage;
  CGImage *v19;
  CIImage *v20;
  CGImage *v21;
  FilterResult *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  FilterResult **v31;
  char *v32;
  FilterResult *v33;
  __int128 v34;
  char *v35;
  FilterResult *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  FilterResult **v45;
  char *v46;
  FilterResult *v47;
  __int128 v48;
  char *v49;
  size_t v50;
  size_t v51;
  const void **v52;
  const void **v53;
  double v54;
  SVGFilterPrimitive *v55;
  uint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  uint64_t *v65;
  char *v66;
  uint64_t v67;
  __int128 v68;
  char *v69;
  CGImage *v70;
  CGImage *v71;
  CGContext *v72;
  id v73;
  CIImage *v74;
  CIImage *v75;
  double rect;
  double v77;
  CGAffineTransform v78;
  CGAffineTransform transform;
  _OWORD v80[2];
  int v81;
  __int128 v82;
  _QWORD v83[2];
  id v84;
  vImage_CGImageFormat *format;
  _DWORD v86[2];
  CGColorSpaceRef ColorSpace;
  __int128 BitmapInfo;
  uint64_t RenderingIntent;
  FilterResult *v90;
  vImage_Error *p_error;
  vImage_Error error;
  __int128 v93;
  char *v94;
  _QWORD *v95;
  CGRect v96;

  height = a4.size.height;
  width = a4.size.width;
  v11 = *((double *)this + 25);
  v10 = *((double *)this + 26);
  v13 = *((double *)this + 27);
  v12 = *((double *)this + 28);
  if (*((_DWORD *)this + 58))
  {
    v14 = *((double *)this + 25);
    v15 = *((double *)this + 26);
    rect = *((double *)this + 28);
    v77 = *((double *)this + 27);
    v16 = v77;
    v17 = rect;
  }
  else
  {
    v14 = a4.origin.x + v11 * width;
    v11 = a5.origin.x + v11 * a5.size.width;
    v15 = a4.origin.y + v10 * height;
    v10 = a5.origin.y + v10 * a5.size.height;
    v16 = width * v13;
    v17 = height * v12;
    rect = a5.size.height * v12;
    v77 = a5.size.width * v13;
  }
  SourceImage = SVGFilter::createSourceImage((uint64_t)this, 0, (uint64_t)a3, v14, v15, v16, v17);
  if (SourceImage)
  {
    v19 = SourceImage;
    objc_msgSend(MEMORY[0x24BDBF660], "imageWithCGImage:", SourceImage);
    v20 = (CIImage *)objc_claimAutoreleasedReturnValue();
    CGImageRelease(v19);
    v21 = SVGFilter::createSourceImage((uint64_t)this, 1, (uint64_t)a3, v14, v15, v16, v17);
    if (!v21)
    {
LABEL_72:

      return;
    }
    v75 = v20;
    objc_msgSend(MEMORY[0x24BDBF660], "imageWithCGImage:", v21);
    v74 = (CIImage *)objc_claimAutoreleasedReturnValue();
    CGImageRelease(v21);
    v90 = 0;
    v86[0] = CGImageGetBitsPerComponent(v19);
    v86[1] = CGImageGetBitsPerPixel(v19);
    ColorSpace = CGImageGetColorSpace(v19);
    BitmapInfo = CGImageGetBitmapInfo(v19);
    RenderingIntent = CGImageGetRenderingIntent(v19);
    v72 = a2;
    objc_msgSend(MEMORY[0x24BDBF648], "contextWithCGContext:options:", a2, 0);
    v84 = (id)objc_claimAutoreleasedReturnValue();
    format = (vImage_CGImageFormat *)v86;
    v82 = 0uLL;
    v83[0] = 0;
    memset(v80, 0, sizeof(v80));
    v81 = 1065353216;
    v73 = v84;
    v22 = (FilterResult *)operator new();
    FilterResult::FilterResult(v22, v74);
    v90 = v22;
    std::string::basic_string[abi:ne180100]<0>(&error, "SourceAlpha");
    p_error = &error;
    *((_QWORD *)std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v80, (unsigned __int8 *)&error, (uint64_t)&std::piecewise_construct, (__int128 **)&p_error)+ 5) = v22;
    if (SHIBYTE(v93) < 0)
      operator delete((void *)error);
    v23 = (_QWORD *)*((_QWORD *)&v82 + 1);
    if (*((_QWORD *)&v82 + 1) >= v83[0])
    {
      v25 = (_QWORD *)v82;
      v26 = (uint64_t)(*((_QWORD *)&v82 + 1) - v82) >> 3;
      v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 61)
        goto LABEL_78;
      v28 = v83[0] - v82;
      if ((uint64_t)(v83[0] - v82) >> 2 > v27)
        v27 = v28 >> 2;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
        v29 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      v95 = v83;
      if (v29)
      {
        v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v83, v29);
        v23 = (_QWORD *)*((_QWORD *)&v82 + 1);
        v25 = (_QWORD *)v82;
      }
      else
      {
        v30 = 0;
      }
      v31 = (FilterResult **)&v30[8 * v26];
      v32 = &v30[8 * v29];
      v94 = v32;
      *v31 = v90;
      *((_QWORD *)&v93 + 1) = v31 + 1;
      if (v23 == v25)
      {
        v24 = v31 + 1;
      }
      else
      {
        do
        {
          v33 = (FilterResult *)*--v23;
          *v23 = 0;
          *--v31 = v33;
        }
        while (v23 != v25);
        v24 = (_QWORD *)*((_QWORD *)&v93 + 1);
        v32 = v94;
      }
      v34 = v82;
      *(_QWORD *)&v82 = v31;
      *((_QWORD *)&v82 + 1) = v24;
      v93 = v34;
      v35 = (char *)v83[0];
      v83[0] = v32;
      v94 = v35;
      error = v34;
      std::__split_buffer<std::unique_ptr<FilterResult>>::~__split_buffer((uint64_t)&error);
    }
    else
    {
      **((_QWORD **)&v82 + 1) = v90;
      v24 = v23 + 1;
    }
    *((_QWORD *)&v82 + 1) = v24;
    v36 = (FilterResult *)operator new();
    FilterResult::FilterResult(v36, v75);
    v90 = v36;
    std::string::basic_string[abi:ne180100]<0>(&error, "SourceGraphic");
    p_error = &error;
    *((_QWORD *)std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v80, (unsigned __int8 *)&error, (uint64_t)&std::piecewise_construct, (__int128 **)&p_error)+ 5) = v36;
    if (SHIBYTE(v93) < 0)
      operator delete((void *)error);
    v37 = (_QWORD *)*((_QWORD *)&v82 + 1);
    if (*((_QWORD *)&v82 + 1) < v83[0])
    {
      **((_QWORD **)&v82 + 1) = v90;
      v38 = v37 + 1;
      goto LABEL_42;
    }
    v39 = (_QWORD *)v82;
    v40 = (uint64_t)(*((_QWORD *)&v82 + 1) - v82) >> 3;
    v41 = v40 + 1;
    if (!((unint64_t)(v40 + 1) >> 61))
    {
      v42 = v83[0] - v82;
      if ((uint64_t)(v83[0] - v82) >> 2 > v41)
        v41 = v42 >> 2;
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v41;
      v95 = v83;
      if (v43)
      {
        v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v83, v43);
        v37 = (_QWORD *)*((_QWORD *)&v82 + 1);
        v39 = (_QWORD *)v82;
      }
      else
      {
        v44 = 0;
      }
      v45 = (FilterResult **)&v44[8 * v40];
      v46 = &v44[8 * v43];
      v94 = v46;
      *v45 = v90;
      *((_QWORD *)&v93 + 1) = v45 + 1;
      if (v37 == v39)
      {
        v38 = v45 + 1;
      }
      else
      {
        do
        {
          v47 = (FilterResult *)*--v37;
          *v37 = 0;
          *--v45 = v47;
        }
        while (v37 != v39);
        v38 = (_QWORD *)*((_QWORD *)&v93 + 1);
        v46 = v94;
      }
      v48 = v82;
      *(_QWORD *)&v82 = v45;
      *((_QWORD *)&v82 + 1) = v38;
      v93 = v48;
      v49 = (char *)v83[0];
      v83[0] = v46;
      v94 = v49;
      error = v48;
      std::__split_buffer<std::unique_ptr<FilterResult>>::~__split_buffer((uint64_t)&error);
LABEL_42:
      *((_QWORD *)&v82 + 1) = v38;
      v50 = CGImageGetWidth(v19);
      v51 = CGImageGetHeight(v19);
      v52 = (const void **)*((_QWORD *)this + 11);
      v53 = (const void **)*((_QWORD *)this + 12);
      if (v52 != v53)
      {
        if (*((_DWORD *)this + 59) == 1)
        {
          height = 1.0;
          width = 1.0;
        }
        v54 = (double)v51;
        do
        {
          if (*v52)
          {
            if (v55)
            {
              SVGFilterPrimitive::draw(v55, (const char *)&v84, (uint64_t *)&v90, (uint64_t)v80, (double)v50, v54, width, height);
              v56 = (uint64_t)v90;
              if (v90)
              {
                v57 = (_QWORD *)*((_QWORD *)&v82 + 1);
                if (*((_QWORD *)&v82 + 1) >= v83[0])
                {
                  v59 = (_QWORD *)v82;
                  v60 = (uint64_t)(*((_QWORD *)&v82 + 1) - v82) >> 3;
                  v61 = v60 + 1;
                  if ((unint64_t)(v60 + 1) >> 61)
                    std::vector<double>::__throw_length_error[abi:ne180100]();
                  v62 = v83[0] - v82;
                  if ((uint64_t)(v83[0] - v82) >> 2 > v61)
                    v61 = v62 >> 2;
                  if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8)
                    v63 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v63 = v61;
                  v95 = v83;
                  if (v63)
                  {
                    v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v83, v63);
                    v57 = (_QWORD *)*((_QWORD *)&v82 + 1);
                    v59 = (_QWORD *)v82;
                    v56 = (uint64_t)v90;
                  }
                  else
                  {
                    v64 = 0;
                  }
                  v65 = (uint64_t *)&v64[8 * v60];
                  v66 = &v64[8 * v63];
                  v94 = v66;
                  *v65 = v56;
                  *((_QWORD *)&v93 + 1) = v65 + 1;
                  if (v57 == v59)
                  {
                    v58 = v65 + 1;
                  }
                  else
                  {
                    do
                    {
                      v67 = *--v57;
                      *v57 = 0;
                      *--v65 = v67;
                    }
                    while (v57 != v59);
                    v58 = (_QWORD *)*((_QWORD *)&v93 + 1);
                    v66 = v94;
                  }
                  v68 = v82;
                  *(_QWORD *)&v82 = v65;
                  *((_QWORD *)&v82 + 1) = v58;
                  v93 = v68;
                  v69 = (char *)v83[0];
                  v83[0] = v66;
                  v94 = v69;
                  error = v68;
                  std::__split_buffer<std::unique_ptr<FilterResult>>::~__split_buffer((uint64_t)&error);
                }
                else
                {
                  **((_QWORD **)&v82 + 1) = v90;
                  v58 = v57 + 1;
                }
                *((_QWORD *)&v82 + 1) = v58;
              }
            }
          }
          ++v52;
        }
        while (v52 != v53);
      }
      v20 = v75;
      if (!v90)
        goto LABEL_71;
      if (*(_QWORD *)v90)
      {
        v70 = (CGImage *)objc_msgSend(v73, "createCGImage:fromRect:", 0.0, 0.0, v16, v17);
      }
      else
      {
        if (!*((_QWORD *)v90 + 1))
          goto LABEL_71;
        error = 0;
        v71 = vImageCreateCGImageFromBuffer((const vImage_Buffer *)((char *)v90 + 8), format, 0, 0, 0, &error);
        v70 = v71;
        if (error)
        {
          CGImageRelease(v71);
          goto LABEL_71;
        }
      }
      SVGNode::transform(a3, &v78);
      CGAffineTransformInvert(&transform, &v78);
      CGContextConcatCTM(v72, &transform);
      v96.origin.x = v11;
      v96.origin.y = v10;
      v96.size.width = v77;
      v96.size.height = rect;
      CGContextDrawImage(v72, v96, v70);
      CGImageRelease(v70);
LABEL_71:
      std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::~__hash_table((uint64_t)v80);
      error = (vImage_Error)&v82;
      std::vector<std::unique_ptr<FilterResult>>::__destroy_vector::operator()[abi:ne180100]((void ***)&error);

      goto LABEL_72;
    }
LABEL_78:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
}

void sub_206793038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void **a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,id a37)
{
  std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::~__hash_table((uint64_t)&a27);
  a27 = (void **)&a33;
  std::vector<std::unique_ptr<FilterResult>>::__destroy_vector::operator()[abi:ne180100](&a27);

  _Unwind_Resume(a1);
}

double SVGFilter::filterRegion(SVGFilter *this, CGRect a2)
{
  double x;
  double result;

  x = a2.origin.x;
  result = *((double *)this + 25);
  if (!*((_DWORD *)this + 58))
    return x + result * a2.size.width;
  return result;
}

CGImageRef SVGFilter::createSourceImage(uint64_t a1, int a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  CGImageRef Image;
  const char *v15;
  const __CFDictionary *v16;
  CGColorSpace *v17;
  CGContext *v18;
  CGContext *v19;
  CGContext *v20;
  const __CFString *v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 240))
  {
    *(_BYTE *)(a1 + 240) = 1;
    v22 = CFSTR("removeAncestorTransforms");
    v23[0] = MEMORY[0x24BDBD1C0];
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v23, &v22, 1);
    v16 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
    if (a2 == 1)
    {
      v19 = CGBitmapContextCreate(0, (unint64_t)a6, (unint64_t)a7, 8uLL, 0, 0, 7u);
      v20 = v19;
      if (v19)
      {
        CGContextTranslateCTM(v19, -a4, -a5);
        SVGUtilities::CGContextDrawSVGDefinitionNode((int)v20, *(_QWORD *)(a3 + 40), v16);
        Image = CGBitmapContextCreateImage(v20);
        CGContextRelease(v20);
        goto LABEL_12;
      }
    }
    else if (a2)
    {
      SVGUtilities::log((SVGUtilities *)"\nSpecified image source for the filter is currently not supported", v15);
    }
    else
    {
      v17 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF318]);
      if (v17)
      {
        v18 = CGBitmapContextCreate(0, (unint64_t)a6, (unint64_t)a7, 8uLL, 0, v17, 1u);
        CGColorSpaceRelease(v17);
        if (v18)
        {
          CGContextTranslateCTM(v18, -a4, -a5);
          SVGUtilities::CGContextDrawSVGDefinitionNode((int)v18, *(_QWORD *)(a3 + 40), v16);
          Image = CGBitmapContextCreateImage(v18);
          CGContextRelease(v18);
LABEL_12:

          goto LABEL_13;
        }
      }
    }
    Image = 0;
    goto LABEL_12;
  }
  Image = 0;
LABEL_13:
  *(_BYTE *)(a1 + 240) = 0;
  return Image;
}

void sub_206793320(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t SVGFilter::filterPrimitive(unsigned int a1)
{
  uint64_t v2;
  int *v3;
  _QWORD *v4;
  const char *v5;
  uint64_t v6;

  v2 = 0;
  v3 = (int *)"9SVGFilter";
  while (SupportedFilters[v2] != a1)
  {
    if (++v2 == 6)
      goto LABEL_6;
  }
  v3 = &SupportedFilters[v2];
LABEL_6:
  if ((char *)v3 - (char *)SupportedFilters == 24)
  {
    v4 = SVGAtom::ToString(a1);
    SVGUtilities::log((SVGUtilities *)"\nFilter primitive: <%s> is currently not supported.", v5, v4);
    return 0;
  }
  else
  {
    v6 = operator new();
    SVGFilterPrimitive::SVGFilterPrimitive(v6, a1);
  }
  return v6;
}

void sub_2067933F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C40E03E9813);
  _Unwind_Resume(a1);
}

void SVGFilter::updatedAttributes(SVGFilter *this, SVGAttributeMap *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[10];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  __n128 (*v24)(__n128 *, __n128 *);
  uint64_t (*v25)();
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  __n128 (*v32)(__n128 *, __n128 *);
  uint64_t (*v33)();
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  __n128 (*v40)(__n128 *, __n128 *);
  uint64_t (*v41)();
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  __n128 (*v48)(__n128 *, __n128 *);
  uint64_t (*v49)();
  const char *v50;
  uint64_t v51;
  uint64_t v52;

  v45 = 0;
  v46 = &v45;
  v47 = 0x4012000000;
  v48 = __Block_byref_object_copy__1;
  v49 = __Block_byref_object_dispose__1;
  v51 = 0;
  v52 = 0;
  v50 = "";
  CGSVGLengthMakeWithType();
  v51 = v4;
  v52 = v5;
  v37 = 0;
  v38 = &v37;
  v39 = 0x4012000000;
  v40 = __Block_byref_object_copy__1;
  v41 = __Block_byref_object_dispose__1;
  v43 = 0;
  v44 = 0;
  v42 = "";
  CGSVGLengthMakeWithType();
  v43 = v6;
  v44 = v7;
  v29 = 0;
  v30 = &v29;
  v31 = 0x4012000000;
  v32 = __Block_byref_object_copy__1;
  v33 = __Block_byref_object_dispose__1;
  v35 = 0;
  v36 = 0;
  v34 = "";
  CGSVGLengthMakeWithType();
  v35 = v8;
  v36 = v9;
  v21 = 0;
  v22 = &v21;
  v23 = 0x4012000000;
  v24 = __Block_byref_object_copy__1;
  v25 = __Block_byref_object_dispose__1;
  v27 = 0;
  v28 = 0;
  v26 = "";
  CGSVGLengthMakeWithType();
  v27 = v10;
  v28 = v11;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v20 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 1;
  v12[0] = MEMORY[0x24BDAC760];
  v12[1] = 3221225472;
  v12[2] = ___ZN9SVGFilter17updatedAttributesEP15SVGAttributeMap_block_invoke;
  v12[3] = &unk_24BFD93B8;
  v12[4] = &v45;
  v12[5] = &v37;
  v12[6] = &v29;
  v12[7] = &v21;
  v12[8] = &v17;
  v12[9] = &v13;
  SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v12);
  *((double *)this + 25) = CGSVGLengthScaledLength(v46[6], v46[7], 1.0);
  *((double *)this + 26) = CGSVGLengthScaledLength(v38[6], v38[7], 1.0);
  *((double *)this + 27) = CGSVGLengthScaledLength(v30[6], v30[7], 1.0);
  *((double *)this + 28) = CGSVGLengthScaledLength(v22[6], v22[7], 1.0);
  *((_DWORD *)this + 58) = *((_DWORD *)v18 + 6);
  *((_DWORD *)this + 59) = *((_DWORD *)v14 + 6);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v37, 8);
  _Block_object_dispose(&v45, 8);
}

void sub_206793660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;

  _Block_object_dispose(&a35, 8);
  _Block_object_dispose((const void *)(v35 - 192), 8);
  _Block_object_dispose((const void *)(v35 - 128), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void ___ZN9SVGFilter17updatedAttributesEP15SVGAttributeMap_block_invoke(_QWORD *a1, int a2, SVGAttribute *this)
{
  int v5;
  uint64_t v6;
  _QWORD *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v5 = *((_DWORD *)this + 12);
  if (v5 <= 69)
  {
    switch(v5)
    {
      case 30:
        v6 = a1[7];
        break;
      case 66:
        v6 = a1[6];
        break;
      case 67:
        v6 = a1[4];
        break;
      default:
        return;
    }
LABEL_12:
    if (!SVGAttribute::lengthValue((uint64_t)this, *(_QWORD *)(v6 + 8) + 48))
    {
      v7 = SVGAtom::ToString(*((_DWORD *)this + 12));
      SVGUtilities::log((SVGUtilities *)"SVGFilter: Attribute parse error: %s\n", v8, v7);
    }
    return;
  }
  switch(v5)
  {
    case 'V':
      v9 = SVGAttribute::stringValue(this);
      v10 = *(char *)(v9 + 23);
      if (v10 < 0)
      {
        if (*(_QWORD *)(v9 + 8) != 17)
          return;
        v9 = *(_QWORD *)v9;
      }
      else if (v10 != 17)
      {
        return;
      }
      if (*(_QWORD *)v9 == 0x6F427463656A626FLL
        && *(_QWORD *)(v9 + 8) == 0x6F42676E69646E75
        && *(_BYTE *)(v9 + 16) == 120)
      {
        *(_DWORD *)(*(_QWORD *)(a1[9] + 8) + 24) = 0;
      }
      break;
    case 'U':
      v11 = SVGAttribute::stringValue(this);
      v12 = *(char *)(v11 + 23);
      if (v12 < 0)
      {
        if (*(_QWORD *)(v11 + 8) != 14)
          return;
        v11 = *(_QWORD *)v11;
      }
      else if (v12 != 14)
      {
        return;
      }
      if (*(_QWORD *)v11 == 0x6361705372657375 && *(_QWORD *)(v11 + 6) == 0x6573556E4F656361)
        *(_DWORD *)(*(_QWORD *)(a1[8] + 8) + 24) = 1;
      break;
    case 'F':
      v6 = a1[5];
      goto LABEL_12;
    default:
      return;
  }
}

uint64_t SVGFilter::IsValidFilterPrimitive(int a1)
{
  return ((a1 - 91) < 0x1E) & (0x20801699u >> (a1 - 91));
}

void std::vector<std::unique_ptr<FilterResult>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  FilterResult **v2;
  FilterResult **v4;
  void *v5;

  v1 = *a1;
  v2 = (FilterResult **)**a1;
  if (v2)
  {
    v4 = (FilterResult **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<FilterResult>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

FilterResult *std::unique_ptr<FilterResult>::reset[abi:ne180100](FilterResult **a1, FilterResult *a2)
{
  FilterResult *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    FilterResult::~FilterResult(result);
    JUMPOUT(0x20BCFC038);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__deallocate_node(a1, *(void ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__deallocate_node(int a1, void **__p)
{
  void **v2;
  void **v3;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void *std::__hash_table<std::__hash_value_type<std::string,FilterResult *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,FilterResult *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,FilterResult *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,FilterResult *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  void **v14;
  void *i;
  unint64_t v16;
  _QWORD *v17;
  __int128 *v18;
  __int128 v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(void **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, (unsigned __int8 *)i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  v17 = (_QWORD *)(a1 + 16);
  i = operator new(0x30uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v10;
  v18 = *a4;
  v19 = **a4;
  *((_QWORD *)i + 4) = *((_QWORD *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((_QWORD *)v18 + 1) = 0;
  *((_QWORD *)v18 + 2) = 0;
  *(_QWORD *)v18 = 0;
  *((_QWORD *)i + 5) = 0;
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    v22 = 1;
    if (v11 >= 3)
      v22 = (v11 & (v11 - 1)) != 0;
    v23 = v22 | (2 * v11);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<SVGAtom::Name,std::hash<SVGAtom::Name>,std::equal_to<SVGAtom::Name>,std::allocator<SVGAtom::Name>>::__rehash<true>(a1, v25);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v27)
  {
    *(_QWORD *)i = *v27;
LABEL_38:
    *v27 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v17;
  *v17 = i;
  *(_QWORD *)(v26 + 8 * v4) = v17;
  if (*(_QWORD *)i)
  {
    v28 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v28 >= v11)
        v28 %= v11;
    }
    else
    {
      v28 &= v11 - 1;
    }
    v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_38;
  }
LABEL_39:
  ++*v8;
  return i;
}

void sub_206793C2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void **v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,FilterResult *>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unique_ptr<FilterResult>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<FilterResult>::reset[abi:ne180100]((FilterResult **)(i - 8), 0);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

BOOL SVGViewBoxNode::ParseAspectRatio(uint64_t a1, uint64_t a2)
{
  const char *v4;
  int *v5;
  int *v6;
  uint64_t v7;
  unint64_t v8;
  int v10;
  void *v11;
  std::string *v12;
  int v13;
  unint64_t v15;
  std::string v16;
  int *v17;
  int *v18;
  uint64_t v19;
  char v20;

  *(_QWORD *)(a1 + 264) = 5;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  if (*(char *)(a2 + 23) >= 0)
    v4 = (const char *)a2;
  else
    v4 = *(const char **)a2;
  SVGParser::GetSeparatedWhitespaceComponents(v4, (void **)&v17, 1);
  v5 = v17;
  v6 = v18;
  v7 = ((char *)v18 - (char *)v17) >> 3;
  v8 = v7 - 1;
  if (v18 != v17 && (unint64_t)(v7 - 1) <= 1)
  {
    v15 = v7 - 1;
    while (1)
    {
      std::string::basic_string(&v16, (const std::string *)a2, *v5, v5[1], (std::allocator<char> *)&v20);
      v10 = SHIBYTE(v16.__r_.__value_.__r.__words[2]);
      v11 = (void *)v16.__r_.__value_.__r.__words[0];
      if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &v16;
      else
        v12 = (std::string *)v16.__r_.__value_.__r.__words[0];
      if (!strcasecmp((const char *)v12, "None"))
      {
        *(_DWORD *)(a1 + 264) = 0;
        if (v10 < 0)
          goto LABEL_37;
        goto LABEL_40;
      }
      if (!strcasecmp((const char *)v12, "xMinYMin"))
      {
        v13 = 1;
        goto LABEL_36;
      }
      if (!strcasecmp((const char *)v12, "xMidYMin"))
      {
        v13 = 2;
        goto LABEL_36;
      }
      if (!strcasecmp((const char *)v12, "xMaxYMin"))
      {
        v13 = 3;
        goto LABEL_36;
      }
      if (!strcasecmp((const char *)v12, "xMinYMid"))
      {
        v13 = 4;
        goto LABEL_36;
      }
      if (!strcasecmp((const char *)v12, "xMidYMid"))
      {
        v13 = 5;
        goto LABEL_36;
      }
      if (!strcasecmp((const char *)v12, "xMaxYMid"))
      {
        v13 = 6;
        goto LABEL_36;
      }
      if (!strcasecmp((const char *)v12, "xMinYMax"))
        break;
      if (!strcasecmp((const char *)v12, "xMidYMax"))
      {
        v13 = 8;
LABEL_36:
        *(_DWORD *)(a1 + 264) = v13;
        if (v10 < 0)
          goto LABEL_37;
        goto LABEL_40;
      }
      if (!strcasecmp((const char *)v12, "xMaxYMax"))
      {
        *(_DWORD *)(a1 + 264) = 9;
LABEL_39:
        if ((v10 & 0x80000000) == 0)
          goto LABEL_40;
LABEL_37:
        operator delete(v11);
        goto LABEL_40;
      }
      if (!strcasecmp((const char *)v12, "Meet"))
      {
        *(_DWORD *)(a1 + 268) = 0;
        if ((v10 & 0x80000000) == 0)
          goto LABEL_40;
        goto LABEL_37;
      }
      if (strcasecmp((const char *)v12, "Slice"))
        goto LABEL_39;
      *(_DWORD *)(a1 + 268) = 1;
      if (v10 < 0)
        goto LABEL_37;
LABEL_40:
      v5 += 2;
      if (v5 == v6)
      {
        v5 = v17;
        v8 = v15;
        goto LABEL_44;
      }
    }
    v13 = 7;
    goto LABEL_36;
  }
LABEL_44:
  if (v5)
  {
    v18 = v5;
    operator delete(v5);
  }
  return v8 < 2;
}

void sub_206793F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGViewBoxNode::print(SVGViewBoxNode *this, const char *a2)
{
  const char *v3;
  SVGUtilities *v4;
  const char *v5;

  SVGUtilities::print((SVGUtilities *)"\n", a2);
  v4 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"ViewBoxNode: Size: {%.2f, %.2f} Viewbox: ", v3, *((_QWORD *)this + 27), *((_QWORD *)this + 28));
  SVGUtilities::printIgnoringIndention(v4, *(CGRect *)((char *)this + 232));
  return SVGUtilities::print((SVGUtilities *)"\n", v5);
}

void SVGViewBoxNode::SVGViewBoxNode(SVGViewBoxNode *this, const SVGViewBoxNode *a2)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;

  SVGNode::SVGNode(this, (const SVGAttributeMap **)a2);
  *(_QWORD *)v3 = off_24BFD8C98;
  *(_OWORD *)(v3 + 200) = *MEMORY[0x24BDBEFB0];
  *(_OWORD *)(v3 + 216) = *MEMORY[0x24BDBF148];
  v4 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(v3 + 232) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(v3 + 248) = v4;
  *(_QWORD *)(v3 + 264) = 5;
  *(_OWORD *)(v3 + 200) = *(_OWORD *)((char *)a2 + 200);
  *(_OWORD *)(v3 + 216) = *(_OWORD *)((char *)a2 + 216);
  v5 = *(_OWORD *)((char *)a2 + 232);
  *(_OWORD *)(v3 + 248) = *(_OWORD *)((char *)a2 + 248);
  *(_OWORD *)(v3 + 232) = v5;
  *(_QWORD *)(v3 + 264) = *((_QWORD *)a2 + 33);
}

SVGShapeNode *SVGShapeNode::copy(SVGShapeNode *this)
{
  SVGShapeNode *v2;

  v2 = (SVGShapeNode *)operator new();
  SVGShapeNode::SVGShapeNode(v2, this);
  return v2;
}

void sub_20679405C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4048998896);
  _Unwind_Resume(a1);
}

void SVGShapeNode::~SVGShapeNode(SVGShapeNode *this)
{
  SVGNode::~SVGNode(this);
  JUMPOUT(0x20BCFC038);
}

CGPath *SVGShapeNode::createCGPath(SVGShapeNode *this)
{
  SVGPath *v2;
  const char *v3;
  CGPath *Mutable;
  CGPath *v6;
  int v7;
  const void **v8;
  const void **v9;
  int64_t v10;
  unint64_t v11;
  CGFloat *v12;
  uint64_t v13;
  unint64_t v14;
  double v15;
  double v16;
  double v17;
  double v18;
  _BOOL4 v19;
  _BOOL4 v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  _QWORD *v33;
  const char *v34;
  double v35;
  double v36;

  if (*((_DWORD *)this + 72) == 42)
  {
    v2 = SVGShapeNode::path(this);
    if (v2)
      return CGSVGPathCreateCGPath(*((_QWORD *)v2 + 5), v3);
    return 0;
  }
  Mutable = CGPathCreateMutable();
  v6 = Mutable;
  v7 = *((_DWORD *)this + 72);
  if (v7 > 43)
  {
    if ((v7 - 44) < 2)
    {
      v8 = (const void **)SVGShapeNode::pointList(this);
      if (v8)
      {
        v9 = v8;
        v10 = (_BYTE *)v8[1] - (_BYTE *)*v8;
        if ((unint64_t)v10 >= 0x11)
        {
          v11 = v10 >> 3;
          v12 = (CGFloat *)malloc_type_malloc(v10, 0x100004000313F17uLL);
          memcpy(v12, *v9, (_BYTE *)v9[1] - (_BYTE *)*v9);
          CGPathMoveToPoint(v6, 0, *v12, v12[1]);
          v13 = 0;
          do
          {
            CGPathAddLineToPoint(v6, 0, v12[v13 + 2], v12[v13 + 3]);
            v14 = v13 + 4;
            v13 += 2;
          }
          while (v14 < v11);
          if (*((_DWORD *)this + 72) == 44)
            CGPathCloseSubpath(v6);
          free(v12);
        }
      }
      return v6;
    }
    if (v7 == 49)
    {
      v15 = *((double *)this + 29);
      if (v15 > 0.0)
      {
        v16 = *((double *)this + 30);
        if (v16 > 0.0)
        {
          v17 = *((double *)this + 31);
          v18 = *((double *)this + 32);
          v19 = v17 <= 0.0;
          v20 = v17 > 0.0;
          if (v18 > 0.0)
          {
            v20 = 1;
            v19 = 1;
          }
          v21 = 0.0;
          if (v20)
            v21 = *((double *)this + 32);
          if (v17 <= 0.0)
            v22 = v21;
          else
            v22 = *((double *)this + 31);
          if (v19)
            v23 = v21;
          else
            v23 = *((double *)this + 31);
          v24 = v15 * 0.5;
          if (v17 <= v15 * 0.5)
            v24 = v22;
          if (v18 <= v16 * 0.5)
            v25 = v23;
          else
            v25 = v16 * 0.5;
          v26 = *((_QWORD *)this + 25);
          v27 = *((_QWORD *)this + 26);
          CGPathAddRoundedRect(Mutable, 0, *(CGRect *)(&v15 - 2), v24, v25);
        }
      }
      return v6;
    }
    goto LABEL_38;
  }
  if (v7 == 3)
  {
    v28 = *((double *)this + 35);
    if (v28 <= 0.0)
      return v6;
    v29 = *((double *)this + 33) - v28;
    v30 = *((double *)this + 34) - v28;
    v31 = v28 + v28;
    v32 = v31;
LABEL_44:
    CGPathAddEllipseInRect(Mutable, 0, *(CGRect *)&v29);
    return v6;
  }
  if (v7 == 16)
  {
    v35 = *((double *)this + 31);
    if (v35 <= 0.0)
      return v6;
    v36 = *((double *)this + 32);
    if (v36 <= 0.0)
      return v6;
    v29 = *((double *)this + 33) - v35;
    v30 = *((double *)this + 34) - v36;
    v31 = v35 + v35;
    v32 = v36 + v36;
    goto LABEL_44;
  }
  if (v7 != 32)
  {
LABEL_38:
    CGPathRelease(Mutable);
    v33 = SVGAtom::ToString(*((_DWORD *)this + 72));
    SVGUtilities::error((SVGUtilities *)"Invalid shape primitive: %s", v34, v33);
    return 0;
  }
  CGPathMoveToPoint(Mutable, 0, *((CGFloat *)this + 25), *((CGFloat *)this + 26));
  CGPathAddLineToPoint(v6, 0, *((CGFloat *)this + 27), *((CGFloat *)this + 28));
  return v6;
}

void SVGShapeNode::setPointList(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, 43, a2);
  SVGAttributeMap::setAttribute(v3, v4, 1);
}

void sub_206794384(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

double SVGShapeNode::boundingBox(SVGShapeNode *this, const char *a2)
{
  int v2;
  double *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  int v9;
  SVGPath *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  double *v18;
  double *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  CGFloat v25;
  double result;
  CGRect v27;
  CGRect v28;

  v2 = (int)a2;
  v4 = (double *)MEMORY[0x24BDBF090];
  v5 = *MEMORY[0x24BDBF090];
  v6 = *(double *)(MEMORY[0x24BDBF090] + 8);
  v7 = *(double *)(MEMORY[0x24BDBF090] + 16);
  v8 = *(double *)(MEMORY[0x24BDBF090] + 24);
  v9 = *((_DWORD *)this + 72);
  if (v9 > 43)
  {
    if ((v9 - 44) < 2)
    {
      v17 = SVGShapeNode::pointList(this);
      if (!v17)
      {
LABEL_20:
        v5 = *v4;
        v6 = v4[1];
        v7 = v4[2];
        v8 = v4[3];
        goto LABEL_27;
      }
      v18 = *(double **)v17;
      v19 = *(double **)(v17 + 8);
      if (*(double **)v17 == v19)
      {
        v6 = 3.40282347e38;
        v21 = 1.17549435e-38;
        v20 = 1.17549435e-38;
        v5 = 3.40282347e38;
      }
      else
      {
        v20 = 1.17549435e-38;
        v5 = 3.40282347e38;
        v6 = 3.40282347e38;
        v21 = 1.17549435e-38;
        do
        {
          v22 = *v18;
          v23 = v18[1];
          v18 += 2;
          v5 = fmin(v5, v22);
          v6 = fmin(v6, v23);
          v20 = fmax(v20, v22);
          v21 = fmax(v21, v23);
        }
        while (v18 != v19);
      }
      v7 = v20 - v5;
      v8 = v21 - v6;
    }
    else if (v9 != 10001)
    {
      if (v9 != 49)
        goto LABEL_24;
      v5 = *((double *)this + 25);
      v6 = *((double *)this + 26);
      v7 = *((double *)this + 29);
      v8 = *((double *)this + 30);
    }
  }
  else if (v9 <= 31)
  {
    if (v9 == 3)
    {
      v24 = *((double *)this + 35);
      v5 = *((double *)this + 33) - v24;
      v6 = *((double *)this + 34) - v24;
      v7 = v24 + v24;
      v8 = v24 + v24;
      goto LABEL_27;
    }
    if (v9 != 16)
      goto LABEL_24;
    v15 = *((double *)this + 31);
    v16 = *((double *)this + 32);
    v5 = *((double *)this + 33) - v15;
    v6 = *((double *)this + 34) - v16;
    v7 = v15 + v15;
    v8 = v16 + v16;
  }
  else
  {
    if (v9 == 32)
    {
      v27.origin.x = *((CGFloat *)this + 25);
      v27.origin.y = *((CGFloat *)this + 26);
      v27.size.width = *((double *)this + 27) - v27.origin.x;
      v27.size.height = *((double *)this + 28) - v27.origin.y;
      *(CGRect *)&v11 = CGRectStandardize(v27);
      goto LABEL_22;
    }
    if (v9 != 36)
    {
      if (v9 == 42)
      {
        v10 = SVGShapeNode::path(this);
        if (v10)
        {
          v11 = SVGPath::boundingBox(v10);
LABEL_22:
          v5 = v11;
          v6 = v12;
          v7 = v13;
          v8 = v14;
          goto LABEL_27;
        }
        goto LABEL_20;
      }
LABEL_24:
      SVGUtilities::log((SVGUtilities *)"SVGShapeNode::boundingBox: unhandled type: %d\n", a2, *((unsigned int *)this + 72));
    }
  }
LABEL_27:
  v25 = -SVGNode::calculateStrokeWidthForBoundingBox((uint64_t)this, v2);
  v28.origin.x = v5;
  v28.origin.y = v6;
  v28.size.width = v7;
  v28.size.height = v8;
  *(_QWORD *)&result = (unint64_t)CGRectInset(v28, v25, v25);
  return result;
}

uint64_t SVGShapeNode::print(SVGShapeNode *this)
{
  SVGUtilities *v2;
  _QWORD *v3;
  const char *v4;
  SVGUtilities *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t *v9;
  const char *v10;
  const char *v11;

  SVGNode::print((SVGAttributeMap **)this);
  SVGUtilities::indent(v2);
  v3 = SVGAtom::ToString(*((_DWORD *)this + 72));
  v5 = (SVGUtilities *)SVGUtilities::print((SVGUtilities *)"Shape: %s ", v4, v3);
  if (*((_DWORD *)this + 72) == 10001)
  {
    v7 = *((_QWORD *)this + 24);
    if (v7)
    {
      if ((*(char *)(v7 + 23) & 0x80000000) == 0 || *(_QWORD *)v7)
      {
        SVGUtilities::printIgnoringIndention((SVGUtilities *)" \"", v6);
        v9 = (uint64_t *)*((_QWORD *)this + 24);
        if (v9 && *((char *)v9 + 23) < 0)
          v9 = (uint64_t *)*v9;
        SVGUtilities::printIgnoringIndention((SVGUtilities *)"%s", v8, v9);
        v5 = (SVGUtilities *)SVGUtilities::printIgnoringIndention((SVGUtilities *)"\"", v10);
      }
    }
  }
  SVGUtilities::unindent(v5);
  return SVGUtilities::print((SVGUtilities *)"\n", v11);
}

BOOL SVGShapeNode::standardizeShape(SVGShapeNode *this, const SVGAttributeMap *a2)
{
  int v2;
  float64x2_t v3;
  double v4;

  v2 = *((_DWORD *)this + 72);
  if (v2 == 49)
  {
    v3.f64[0] = *((float64_t *)this + 31);
    v4 = *((double *)this + 32);
    if (v4 > 0.0 && v3.f64[0] <= 0.0)
      v3.f64[0] = *((float64_t *)this + 32);
    if (v3.f64[0] > 0.0 && v4 <= 0.0)
      v4 = v3.f64[0];
    __asm { FMOV            V3.2D, #0.5 }
    v3.f64[1] = v4;
    *(float64x2_t *)((char *)this + 248) = vminnmq_f64(v3, vmulq_f64(*(float64x2_t *)((char *)this + 232), _Q3));
  }
  return v2 == 49;
}

void SVGShapeNode::SVGShapeNode(SVGShapeNode *this, const SVGShapeNode *a2)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;

  SVGNode::SVGNode(this, (const SVGAttributeMap **)a2);
  *(_QWORD *)v3 = &off_24BFD8C28;
  *(_OWORD *)(v3 + 248) = 0u;
  *(_OWORD *)(v3 + 232) = 0u;
  *(_OWORD *)(v3 + 216) = 0u;
  *(_OWORD *)(v3 + 200) = 0u;
  *(_OWORD *)(v3 + 276) = 0u;
  *(_OWORD *)(v3 + 264) = 0u;
  v4 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(v3 + 296) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(v3 + 312) = v4;
  *(_DWORD *)(v3 + 288) = *((_DWORD *)a2 + 72);
  v5 = *(_OWORD *)((char *)a2 + 312);
  *(_OWORD *)(v3 + 296) = *(_OWORD *)((char *)a2 + 296);
  *(_OWORD *)(v3 + 312) = v5;
  *(_OWORD *)(v3 + 200) = *(_OWORD *)((char *)a2 + 200);
  *(_OWORD *)(v3 + 216) = *(_OWORD *)((char *)a2 + 216);
  *(_OWORD *)(v3 + 232) = *(_OWORD *)((char *)a2 + 232);
  *(_OWORD *)(v3 + 248) = *(_OWORD *)((char *)a2 + 248);
  *(_QWORD *)(v3 + 264) = *((_QWORD *)a2 + 33);
  *(_OWORD *)(v3 + 272) = *((_OWORD *)a2 + 17);
}

uint64_t CGSVGRootNodeCreate()
{
  SVGRootNode *v0;

  v0 = (SVGRootNode *)operator new();
  SVGRootNode::SVGRootNode(v0);
  return *((_QWORD *)v0 + 5);
}

void sub_206794768(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10F3C40BD1137ACLL);
  _Unwind_Resume(a1);
}

double *CGSVGRootNodeSetSize(uint64_t a1, const char *a2, double a3, double a4)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGRootNode>(a1, a2);
  if (result)
  {
    result[27] = a3;
    result[28] = a4;
  }
  return result;
}

void *CFRetained::getObject<SVGRootNode>(uint64_t a1, const char *a2)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
  }
  else
  {
    SVGUtilities::error((SVGUtilities *)"NULL ref passed to getObject", a2);
  }
  return 0;
}

double CGSVGRootNodeGetSize(uint64_t a1, const char *a2)
{
  char *v2;
  char *v3;

  v2 = (char *)CFRetained::getObject<SVGRootNode>(a1, a2);
  v3 = v2 + 216;
  if (!v2)
    v3 = (char *)MEMORY[0x24BDBF148];
  return *(double *)v3;
}

double *CGSVGRootNodeSetViewbox(uint64_t a1, const char *a2, double a3, double a4, double a5, double a6)
{
  double *result;

  result = (double *)CFRetained::getObject<SVGRootNode>(a1, a2);
  if (result)
  {
    result[29] = a3;
    result[30] = a4;
    result[31] = a5;
    result[32] = a6;
  }
  return result;
}

double CGSVGRootNodeGetViewbox(uint64_t a1, const char *a2)
{
  char *v2;
  char *v3;

  v2 = (char *)CFRetained::getObject<SVGRootNode>(a1, a2);
  v3 = (char *)MEMORY[0x24BDBF090];
  if (v2)
    v3 = v2 + 232;
  return *(double *)v3;
}

_DWORD *CGSVGRootNodeSetAspectRatio(uint64_t a1, const char *a2)
{
  int v2;
  _DWORD *result;

  v2 = (int)a2;
  result = CFRetained::getObject<SVGRootNode>(a1, a2);
  if (result)
    result[66] = v2;
  return result;
}

unsigned int *CGSVGRootNodeGetAspectRatio(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGRootNode>(a1, a2);
  if (result)
    return (unsigned int *)result[66];
  return result;
}

_DWORD *CGSVGRootNodeSetAspectRatioMeetOrSlice(uint64_t a1, const char *a2)
{
  int v2;
  _DWORD *result;

  v2 = (int)a2;
  result = CFRetained::getObject<SVGRootNode>(a1, a2);
  if (result)
    result[67] = v2;
  return result;
}

uint64_t CGSVGRootNodeGetAspectRatioMeetOrSlice(uint64_t a1, const char *a2)
{
  _DWORD *v2;
  int v3;

  v2 = CFRetained::getObject<SVGRootNode>(a1, a2);
  if (v2)
    v3 = v2[67];
  else
    LOBYTE(v3) = 0;
  return (char)v3;
}

uint64_t SVGUtilities::shared(SVGUtilities *this)
{
  if (SVGUtilities::shared(void)::onceToken != -1)
    dispatch_once(&SVGUtilities::shared(void)::onceToken, &__block_literal_global_3);
  return SVGUtilities::shared(void)::utilities;
}

void SVGUtilities::indent(SVGUtilities *this)
{
  if (SVGUtilities::shared(void)::onceToken != -1)
    dispatch_once(&SVGUtilities::shared(void)::onceToken, &__block_literal_global_3);
  ++*(_DWORD *)SVGUtilities::shared(void)::utilities;
}

void SVGUtilities::unindent(SVGUtilities *this)
{
  if (SVGUtilities::shared(void)::onceToken != -1)
    dispatch_once(&SVGUtilities::shared(void)::onceToken, &__block_literal_global_3);
  if (*(int *)SVGUtilities::shared(void)::utilities >= 1)
    --*(_DWORD *)SVGUtilities::shared(void)::utilities;
}

uint64_t SVGUtilities::print(SVGUtilities *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  if (SVGUtilities::shared(void)::onceToken != -1)
    dispatch_once(&SVGUtilities::shared(void)::onceToken, &__block_literal_global_3);
  printf("%.*s", 2 * *(_DWORD *)SVGUtilities::shared(void)::utilities, "                                      ");
  return vprintf((const char *)this, va);
}

uint64_t SVGUtilities::printIgnoringIndention(SVGUtilities *this, CGRect a2)
{
  return printf("{{%g, %g}, {%g, %g}}", a2.origin.x, a2.origin.y, a2.size.width, a2.size.height);
}

uint64_t SVGUtilities::printIgnoringIndention(SVGUtilities *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return vprintf((const char *)this, va);
}

void SVGUtilities::log(SVGUtilities *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  if (is_verbose_logging(void)::onceToken != -1)
    dispatch_once(&is_verbose_logging(void)::onceToken, &__block_literal_global_19);
  if (is_verbose_logging(void)::isVerbose)
  {
    if (SVGUtilities::shared(void)::onceToken != -1)
      dispatch_once(&SVGUtilities::shared(void)::onceToken, &__block_literal_global_3);
    printf("%.*s", 2 * *(_DWORD *)SVGUtilities::shared(void)::utilities, "                                      ");
    vprintf((const char *)this, va);
  }
}

void SVGUtilities::error(SVGUtilities *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  if (is_verbose_logging(void)::onceToken != -1)
    dispatch_once(&is_verbose_logging(void)::onceToken, &__block_literal_global_19);
  if (is_verbose_logging(void)::isVerbose)
  {
    printf("CoreSVG: Error: ");
    vprintf((const char *)this, va);
  }
}

CGFloat SVGUtilities::CGRectGetCenter(SVGUtilities *this, CGRect a2)
{
  return a2.origin.x + a2.size.width * 0.5;
}

BOOL SVGUtilities::CGFloatEqualToFloat(SVGUtilities *this, double a2, double a3)
{
  return vabdd_f64(a2, a3) <= 0.00000001;
}

double SVGUtilities::CGFloatClamp(SVGUtilities *this, double a2, double a3, double a4)
{
  return fmin(fmax(a2, a3), a4);
}

void SVGUtilities::CGPointListConvertToFloatList(uint64_t **a1, char **a2)
{
  uint64_t *v2;
  uint64_t *v3;
  char **v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;

  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    v5 = a2 + 2;
    v6 = a2[1];
    do
    {
      v8 = *v2;
      v7 = v2[1];
      v9 = *v5;
      if (v6 >= *v5)
      {
        v11 = *a2;
        v12 = (v6 - *a2) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          goto LABEL_37;
        v14 = v9 - v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v5, v15);
          v11 = *a2;
          v6 = a2[1];
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v8;
        v10 = v17 + 8;
        while (v6 != v11)
        {
          v18 = *((_QWORD *)v6 - 1);
          v6 -= 8;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        v9 = &v16[8 * v15];
        *a2 = v17;
        a2[1] = v10;
        a2[2] = v9;
        if (v11)
        {
          operator delete(v11);
          v9 = *v5;
        }
      }
      else
      {
        *(_QWORD *)v6 = v8;
        v10 = v6 + 8;
      }
      a2[1] = v10;
      if (v10 >= v9)
      {
        v19 = *a2;
        v20 = (v10 - *a2) >> 3;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 61)
LABEL_37:
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v22 = v9 - v19;
        if (v22 >> 2 > v21)
          v21 = v22 >> 2;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
          v23 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v23 = v21;
        if (v23)
        {
          v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v5, v23);
          v19 = *a2;
          v10 = a2[1];
        }
        else
        {
          v24 = 0;
        }
        v25 = &v24[8 * v20];
        *(_QWORD *)v25 = v7;
        v6 = v25 + 8;
        while (v10 != v19)
        {
          v26 = *((_QWORD *)v10 - 1);
          v10 -= 8;
          *((_QWORD *)v25 - 1) = v26;
          v25 -= 8;
        }
        *a2 = v25;
        a2[1] = v6;
        a2[2] = &v24[8 * v23];
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v10 = v7;
        v6 = v10 + 8;
      }
      a2[1] = v6;
      v2 += 2;
    }
    while (v2 != v3);
  }
}

char *SVGUtilities::CGFloatListFromFloats(char *__src, uint64_t a2, uint64_t a3)
{
  return std::vector<double>::__insert_with_size[abi:ne180100]<double const*,double const*>(a3, *(_QWORD *)(a3 + 8), __src, &__src[8 * a2], a2);
}

void SVGUtilities::CGPointListFromFloats(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;

  if ((a2 & 1) != 0)
    SVGUtilities::CGPointListFromFloats();
  if (a2)
  {
    v6 = 0;
    v7 = (_QWORD *)(a3 + 16);
    v8 = *(_QWORD **)(a3 + 8);
    do
    {
      v9 = *(_QWORD *)(a1 + 8 * v6);
      v10 = *(_QWORD *)(a1 + ((8 * v6) | 8));
      if ((unint64_t)v8 >= *v7)
      {
        v11 = *(_QWORD **)a3;
        v12 = ((uint64_t)v8 - *(_QWORD *)a3) >> 4;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 60)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v14 = *v7 - (_QWORD)v11;
        if (v14 >> 3 > v13)
          v13 = v14 >> 3;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
          v15 = 0xFFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>((uint64_t)v7, v15);
          v11 = *(_QWORD **)a3;
          v8 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[16 * v12];
        *(_QWORD *)v17 = v9;
        *((_QWORD *)v17 + 1) = v10;
        v18 = v17;
        if (v8 != v11)
        {
          do
          {
            *((_OWORD *)v18 - 1) = *((_OWORD *)v8 - 1);
            v18 -= 16;
            v8 -= 2;
          }
          while (v8 != v11);
          v11 = *(_QWORD **)a3;
        }
        v8 = v17 + 16;
        *(_QWORD *)a3 = v18;
        *(_QWORD *)(a3 + 8) = v17 + 16;
        *(_QWORD *)(a3 + 16) = &v16[16 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v8 = v9;
        v8[1] = v10;
        v8 += 2;
      }
      *(_QWORD *)(a3 + 8) = v8;
      v6 += 2;
    }
    while (v6 < a2);
  }
}

double SVGUtilities::CGSVGLengthToString@<D0>(uint64_t a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  double result;
  __int128 v5;
  uint64_t v6;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 == 1)
    SVGParser::FormatString((SVGParser *)"%g%%", &v5, a1);
  else
    SVGParser::FormatString((SVGParser *)"%g", &v5, a1);
  result = *(double *)&v5;
  *(_OWORD *)a3 = v5;
  a3[2] = v6;
  return result;
}

uint64_t SVGUtilities::CreateCFDataFromDataURL(SVGUtilities *this, const __CFURL *a2)
{
  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithContentsOfURL:", this);
  return objc_claimAutoreleasedReturnValue();
}

void SVGUtilities::CGContextDrawSVGDefinitionNode(CGContext *a1, const char *a2, CFDictionaryRef theDict)
{
  _BOOL8 v5;
  void *v6;
  const __CFDictionary *v7;
  _QWORD v8[2];
  _QWORD v9[3];

  v9[2] = *MEMORY[0x24BDAC8D0];
  if (theDict)
    v5 = CFDictionaryGetValue(theDict, CFSTR("removeAncestorTransforms")) != (const void *)*MEMORY[0x24BDBD268];
  else
    v5 = 1;
  v8[1] = CFSTR("removeAncestorTransforms");
  v9[0] = MEMORY[0x24BDBD1C8];
  v8[0] = CFSTR("drawingDefinition");
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v9[1] = v6;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v9, v8, 2);
  v7 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();

  CGContextDrawSVGNodeWithOptions(a1, a2, v7);
}

void sub_206795168(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CFIndex CFRetained::getRetainCount(CFTypeRef *this)
{
  return CFGetRetainCount(this[5]);
}

void SVGUtilities::bitmapContextDebugInfo(SVGUtilities *this, CGContext *a2, const char *a3, unint64_t a4, unint64_t a5)
{
  int v7;
  const char *v10;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  size_t v14;
  size_t v15;
  void *v16;
  void *Data;
  size_t v18;
  size_t BitsPerComponent;
  size_t v20;
  CGColorSpace *ColorSpace;
  uint32_t BitmapInfo;
  CGContext *v23;
  const char *v24;
  size_t v25;
  int v26;
  size_t v27;
  int v28;
  CGImage *Image;
  CGAffineTransform v30;
  CGFloat lengths[128];
  uint64_t v32;

  v7 = (int)a3;
  v32 = *MEMORY[0x24BDAC8D0];
  if (CGContextGetType() == 4)
  {
    memset(&v30, 0, sizeof(v30));
    CGContextGetCTM(&v30, this);
    Width = CGBitmapContextGetWidth(this);
    Height = CGBitmapContextGetHeight(this);
    printf("\n%s, context address: %p, width: %zu, height: %zu, Transforms: %g %g %g %g %g %g\n", (const char *)a2, this, Width, Height, v30.a, v30.b, v30.c, v30.d, v30.tx, v30.ty);
    if (this)
    {
      if (v7)
      {
        BytesPerRow = CGBitmapContextGetBytesPerRow(this);
        v14 = CGBitmapContextGetHeight(this);
        v15 = v14 * BytesPerRow;
        v16 = malloc_type_calloc(v14 * BytesPerRow, 1uLL, 0x100004077774924uLL);
        Data = CGBitmapContextGetData(this);
        memcpy(v16, Data, v15);
        v18 = CGBitmapContextGetWidth(this);
        BitsPerComponent = CGBitmapContextGetBitsPerComponent(this);
        v20 = CGBitmapContextGetBytesPerRow(this);
        ColorSpace = CGBitmapContextGetColorSpace(this);
        BitmapInfo = CGBitmapContextGetBitmapInfo(this);
        v23 = CGBitmapContextCreate(v16, v18, v14, BitsPerComponent, v20, ColorSpace, BitmapInfo);
        CGContextCopyTopGState();
        CGContextReplaceTopGState();
        CGGStateRelease();
        if (CGContextGetType() == 4)
        {
          CGContextSaveGState(v23);
          CGContextSetRGBStrokeColor(v23, 0.5, 0.8, 0.8, 0.5);
          v25 = CGBitmapContextGetWidth(v23);
          CGBitmapContextGetHeight(v23);
          v26 = 0;
          do
          {
            CGContextMoveToPoint(v23, 0.0, (double)v26);
            CGContextAddLineToPoint(v23, (double)v25, (double)v26);
            v26 += a5;
          }
          while (CGBitmapContextGetHeight(v23) >= v26);
          v27 = CGBitmapContextGetHeight(v23);
          CGBitmapContextGetWidth(v23);
          v28 = 0;
          do
          {
            CGContextMoveToPoint(v23, (double)v28, 0.0);
            CGContextAddLineToPoint(v23, (double)v28, (double)v27);
            v28 += a4;
          }
          while (CGBitmapContextGetWidth(v23) >= v28);
          *(_OWORD *)lengths = xmmword_20679A0A0;
          CGContextSetLineDash(v23, 0.0, lengths, 2uLL);
          CGContextStrokePath(v23);
          CGContextSetRGBFillColor(v23, 0.0, 0.0, 0.0, 0.7);
          CGContextAddArc(v23, (double)(unint64_t)((double)a4 * 0.1), (double)(unint64_t)((double)a5 * 0.1), (double)(unint64_t)((double)a4 * 0.1), 0.0, 6.28318531, 0);
          CGContextFillPath(v23);
          CGContextRestoreGState(v23);
        }
        else
        {
          SVGUtilities::log((SVGUtilities *)"drawGridLinesOnBitmapContext provides debug information for the bitmap contexts only", v24);
        }
        Image = CGBitmapContextCreateImage(v23);
        CGContextRelease(v23);
        free(v16);
      }
      else
      {
        Image = CGBitmapContextCreateImage(this);
      }
      snprintf((char *)lengths, 0x400uLL, "*/%s.png", (const char *)a2);
      if (Image)
      {
        CGImageWriteToFile();
        CGImageRelease(Image);
      }
    }
  }
  else
  {
    SVGUtilities::log((SVGUtilities *)"bitmapContextDebugInfo provides debug information for the bitmap contexts only", v10);
  }
}

void ___ZL18is_verbose_loggingv_block_invoke()
{
  char *v0;

  if (!is_verbose_logging(void)::isVerbose)
  {
    v0 = getenv("CORESVG_VERBOSE");
    is_verbose_logging(void)::isVerbose = v0 != 0;
    if (!v0)
      printf("CoreSVG has logged an error. Set environment variabe \"%s\" to learn more.\n", "CORESVG_VERBOSE");
  }
}

char *std::vector<double>::__insert_with_size[abi:ne180100]<double const*,double const*>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 3);
    if (v14 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 3;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 2 > v14)
      v14 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[8 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[8 * v17];
    v29 = 8 * a5;
    v30 = &v28[8 * a5];
    do
    {
      v31 = *(_QWORD *)v7;
      v7 += 8;
      *(_QWORD *)v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    v35 = v30;
    v5 = std::vector<double>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    v21 = &__src[8 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[8 * a5];
    v25 = &v23[-8 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_QWORD *)v25;
        v25 += 8;
        *(_QWORD *)v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[8 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_2067957BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGNodeGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206795848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGNodeCreate(const __CFString *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *__p[2];
  char v5;

  if (!a1)
    return 0;
  SVGUtilities::StringWithCFString(a1, __p);
  v1 = operator new();
  SVGNode::SVGNode(v1, __p);
  v2 = *(_QWORD *)(v1 + 40);
  if (v5 < 0)
    operator delete(__p[0]);
  return v2;
}

void sub_2067958D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  uint64_t v16;

  v16 = v15;
  MEMORY[0x20BCFC038](v16, 0x10B3C408E750C55);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t CGSVGNodeCreateGroupNode()
{
  uint64_t v0;

  v0 = operator new();
  SVGNode::SVGNode(v0, 29);
  return *(_QWORD *)(v0 + 40);
}

void sub_206795954(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C408E750C55);
  _Unwind_Resume(a1);
}

_QWORD *CGSVGNodeCopy(uint64_t a1, const char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 16))(result);
    if (result)
      return (_QWORD *)result[5];
  }
  return result;
}

CFTypeRef CGSVGNodeRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGNodeRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void *CGSVGNodeIsRoot(uint64_t a1, const char *a2)
{
  void *result;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  return result;
}

CFStringRef CGSVGNodeCopyName(uint64_t a1, const char *a2)
{
  CFStringRef result;
  const char *v3;

  result = (CFStringRef)CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    v3 = (const char *)&result[2];
    if (SHIBYTE(result[2].data) < 0)
      v3 = *(const char **)v3;
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v3, 0x8000100u);
  }
  return result;
}

_QWORD *CGSVGNodeGetAttributeMap(uint64_t a1, const char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
    return *(_QWORD **)(result[7] + 40);
  return result;
}

CFTypeRef *CGSVGNodeSetAttributeMap(uint64_t a1, const char *a2)
{
  CFTypeRef *result;
  const char *v4;
  SVGNode *v5;

  result = (CFTypeRef *)CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    v5 = (SVGNode *)result;
    result = (CFTypeRef *)CFRetained::getObject<SVGAttributeMap>((uint64_t)a2, v4);
    if (result)
      return (CFTypeRef *)SVGNode::setAttributes(v5, result);
  }
  return result;
}

void CGSVGNodeSetAttribute(uint64_t a1, const char *a2)
{
  SVGNode *v3;
  const char *v4;
  SVGNode *v5;
  SVGAttribute *v6;

  v3 = (SVGNode *)CFRetained::getObject<SVGNode>(a1, a2);
  if (v3)
  {
    v5 = v3;
    v6 = (SVGAttribute *)CFRetained::getObject<SVGAttribute>((uint64_t)a2, v4);
    if (v6)
      SVGNode::setAttribute(v5, v6);
  }
}

_QWORD *CGSVGNodeGetParent(uint64_t a1, const char *a2)
{
  _QWORD *result;
  uint64_t v3;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (result)
  {
    v3 = result[6];
    if (v3)
      return *(_QWORD **)(v3 + 40);
    else
      return 0;
  }
  return result;
}

void CGSVGNodeSetCStringIdentifier(uint64_t a1, char *a2)
{
  SVGNode *v3;

  v3 = (SVGNode *)CFRetained::getObject<SVGNode>(a1, a2);
  if (a2)
  {
    if (v3)
      SVGNode::setIdentifier(v3, a2);
  }
}

void CGSVGNodeSetStringIdentifier(uint64_t a1, const __CFString *this)
{
  const char *v3;
  void *v4;
  void *__p[2];
  char v6;

  if (this)
  {
    SVGUtilities::StringWithCFString(this, __p);
    v4 = CFRetained::getObject<SVGNode>(a1, v3);
    if (v4)
      SVGNode::setIdentifier((uint64_t)v4, (uint64_t)__p);
    if (v6 < 0)
      operator delete(__p[0]);
  }
}

void sub_206795BC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFStringRef CGSVGNodeCopyStringIdentifier(uint64_t a1, const char *a2)
{
  SVGNode *v2;
  char *v3;

  v2 = (SVGNode *)CFRetained::getObject<SVGNode>(a1, a2);
  if (v2 && (v3 = SVGNode::identifier(v2)) != 0)
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD260], v3, 0x8000100u);
  else
    return 0;
}

void CGSVGNodeAddChild(uint64_t a1, const char *a2)
{
  SVGNode *v3;
  const char *v4;
  SVGNode *v5;

  v3 = (SVGNode *)CFRetained::getObject<SVGNode>(a1, a2);
  v5 = (SVGNode *)CFRetained::getObject<SVGNode>((uint64_t)a2, v4);
  if (v3)
  {
    if (v5)
      SVGNode::addChild(v3, v5);
  }
}

void CGSVGNodeRemoveChildAtIndex(uint64_t a1, const char *a2)
{
  SVGNode *v3;

  v3 = (SVGNode *)CFRetained::getObject<SVGNode>(a1, a2);
  if (v3)
    SVGNode::removeChildAtIndex(v3, (unint64_t)a2);
}

double CGSVGNodeGetBoundingBoxWithOptions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SVGNode *v5;
  SVGNode *v6;
  const void *v7;
  const SVGNode *v8;

  v5 = (SVGNode *)CFRetained::getObject<SVGNode>(a1, (const char *)a2);
  if (!v5)
    return *MEMORY[0x24BDBF090];
  v6 = v5;
  if (a2)
  {
    v7 = *(const void **)(a2 + 16);
    if (v7)
    else
      v8 = 0;
    v5 = v6;
  }
  else
  {
    v8 = 0;
  }
  return SVGNode::getBoundingBox(v5, v8, a3);
}

_QWORD *CGSVGNodeSetCStringComment(uint64_t a1, char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (a2)
  {
    if (result)
      return SVGNode::setComment(result, a2);
  }
  return result;
}

void CGSVGNodeSetStringComment(uint64_t a1, const __CFString *this)
{
  char *v3;
  void *__p[2];
  char v5;

  if (this)
  {
    SVGUtilities::StringWithCFString(this, __p);
    if (v5 >= 0)
      v3 = (char *)__p;
    else
      v3 = (char *)__p[0];
    CGSVGNodeSetCStringComment(a1, v3);
    if (v5 < 0)
      operator delete(__p[0]);
  }
}

void sub_206795DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *CGSVGNodeSetCStringText(uint64_t a1, char *a2)
{
  _QWORD *result;

  result = CFRetained::getObject<SVGNode>(a1, a2);
  if (a2)
  {
    if (result)
      return SVGNode::setText(result, a2);
  }
  return result;
}

void CGSVGNodeSetStringText(uint64_t a1, const char *a2)
{
  void *v3;
  uint64_t v4;
  void *__p[2];
  char v6;

  v3 = CFRetained::getObject<SVGNode>(a1, a2);
  if (a2)
  {
    v4 = (uint64_t)v3;
    if (v3)
    {
      SVGUtilities::StringWithCFString((const __CFString *)a2, __p);
      SVGNode::setText(v4, (uint64_t)__p);
      if (v6 < 0)
        operator delete(__p[0]);
    }
  }
}

void sub_206795E7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFStringRef CGSVGNodeCopyText(uint64_t a1, const char *a2)
{
  _QWORD *v2;
  const char *v3;

  v2 = CFRetained::getObject<SVGNode>(a1, a2);
  if (v2 && (v3 = (const char *)v2[24]) != 0 && ((v3[23] & 0x80000000) == 0 || (v3 = *(const char **)v3) != 0))
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD260], v3, 0x8000100u);
  else
    return 0;
}

__n128 __Block_byref_object_copy__1(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

__n128 __Block_byref_object_copy__3(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

double CGSVGNodeGetBoundingBox(uint64_t a1)
{
  return CGSVGNodeGetBoundingBoxWithOptions(a1, 0, 0);
}

double CGSVGNodeGetRelativeBoundingBox(uint64_t a1, uint64_t a2)
{
  return CGSVGNodeGetBoundingBoxWithOptions(a2, a1, 0);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CGAffineTransform>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<CGAffineTransform,SVGPath *>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(56 * a2);
}

uint64_t CGSVGAttributeGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttribute::kSVGAttributeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206796084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGAttributeCreateWithCString(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (!a2)
    return 0;
  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, a1, a2);
  return *(_QWORD *)(v4 + 40);
}

void sub_206796100(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithString(uint64_t a1, const __CFString *this)
{
  uint64_t v3;
  uint64_t v4;
  void *__p[2];
  char v7;

  if (!this)
    return 0;
  SVGUtilities::StringWithCFString(this, __p);
  v3 = operator new();
  SVGAttribute::SVGAttribute(v3, a1, __p);
  v4 = *(_QWORD *)(v3 + 40);
  if (v7 < 0)
    operator delete(__p[0]);
  return v4;
}

void sub_2067961A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  MEMORY[0x20BCFC038](v15, 0x10B3C405B4D0908);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, a1, a2);
  return *(_QWORD *)(v4 + 40);
}

void sub_206796230(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void *CGSVGAttributeCreateWithFilter(uint64_t a1, const char *a2)
{
  void *result;
  void *v4;
  uint64_t v5;

  result = CFRetained::getObject<SVGFilter>((uint64_t)a2, a2);
  if (result)
  {
    v4 = result;
    v5 = operator new();
    SVGAttribute::SVGAttribute(v5, a1, v4);
    return *(void **)(v5 + 40);
  }
  return result;
}

void sub_2067962B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithFloat(uint64_t a1, double a2)
{
  uint64_t v4;

  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, a1, a2);
  return *(_QWORD *)(v4 + 40);
}

void sub_20679632C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithFloats(uint64_t a1, char *__src, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  void *__p;
  void *v8;
  uint64_t v9;

  if (!__src)
    return 0;
  __p = 0;
  v8 = 0;
  v9 = 0;
  SVGUtilities::CGFloatListFromFloats(__src, a3, (uint64_t)&__p);
  v4 = operator new();
  SVGAttribute::SVGAttribute(v4, a1, &__p);
  v5 = *(_QWORD *)(v4 + 40);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
  return v5;
}

void sub_2067963DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;

  MEMORY[0x20BCFC038](v11, 0x10B3C405B4D0908);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithLength(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  v6 = operator new();
  SVGAttribute::SVGAttribute(v6, a1, a2, a3);
  return *(_QWORD *)(v6 + 40);
}

void sub_206796478(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void *CGSVGAttributeCreateWithMask(uint64_t a1, const char *a2)
{
  void *result;
  void *v4;
  uint64_t v5;

  result = CFRetained::getObject<SVGMask>((uint64_t)a2, a2);
  if (result)
  {
    v4 = result;
    v5 = operator new();
    SVGAttribute::SVGAttribute(v5, a1, v4);
    return *(void **)(v5 + 40);
  }
  return result;
}

void sub_2067964FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v10;

  v10 = operator new();
  SVGAttribute::SVGAttribute(v10, a1, a2, a3, a4, a5);
  return *(_QWORD *)(v10 + 40);
}

void sub_206796594(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithColor(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __n128 v4;
  _BYTE v6[40];
  _BYTE v7[40];

  SVGColor::SVGColor((uint64_t)v7, *(_DWORD *)(a2 + 32), *(double *)a2, *(double *)(a2 + 8), *(double *)(a2 + 16), *(double *)(a2 + 24));
  v3 = operator new();
  v4 = SVGColor::SVGColor((uint64_t)v6, (uint64_t)v7);
  SVGAttribute::SVGAttribute(v3, a1, v6, v4);
  return *(_QWORD *)(v3 + 40);
}

void sub_20679662C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void *CGSVGAttributeCreateWithGradient(uint64_t a1, const char *a2)
{
  void *result;
  void *v4;
  uint64_t v5;

  result = CFRetained::getObject<SVGGradient>((uint64_t)a2, a2);
  if (result)
  {
    v4 = result;
    v5 = operator new();
    SVGAttribute::SVGAttribute(v5, a1, v4);
    return *(void **)(v5 + 40);
  }
  return result;
}

void sub_2067966B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void *CGSVGAttributeCreateWithClipPath(uint64_t a1, const char *a2)
{
  void *result;
  void *v4;
  uint64_t v5;

  result = CFRetained::getObject<SVGClipPath>((uint64_t)a2, a2);
  if (result)
  {
    v4 = result;
    v5 = operator new();
    SVGAttribute::SVGAttribute(v5, a1, v4);
    return *(void **)(v5 + 40);
  }
  return result;
}

void sub_206796734(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

void *CGSVGAttributeCreateWithPaint(uint64_t a1, const char *a2)
{
  void *result;
  void *v4;
  uint64_t v5;

  result = CFRetained::getObject<SVGPaint>((uint64_t)a2, a2);
  if (result)
  {
    v4 = result;
    v5 = operator new();
    SVGAttribute::SVGAttribute(v5, a1, v4);
    return *(void **)(v5 + 40);
  }
  return result;
}

void sub_2067967B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithPoint(uint64_t a1, double a2, double a3)
{
  uint64_t v6;

  v6 = operator new();
  SVGAttribute::SVGAttribute(v6, a1, a2, a3);
  return *(_QWORD *)(v6 + 40);
}

void sub_206796838(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

CFTypeRef *CGSVGAttributeCreateWithPath(uint64_t a1, const char *a2)
{
  CFTypeRef *result;
  CFTypeRef *v4;
  uint64_t v5;

  result = (CFTypeRef *)CFRetained::getObject<SVGPath>((uint64_t)a2, a2);
  if (result)
  {
    v4 = result;
    v5 = operator new();
    SVGAttribute::SVGAttribute(v5, a1, v4);
    CFRetained::release(v4);
    return *(CFTypeRef **)(v5 + 40);
  }
  return result;
}

void sub_2067968C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeCreateWithTransform(uint64_t a1, _OWORD *a2)
{
  uint64_t v4;
  __int128 v5;
  _OWORD v7[3];

  v4 = operator new();
  v5 = a2[1];
  v7[0] = *a2;
  v7[1] = v5;
  v7[2] = a2[2];
  SVGAttribute::SVGAttribute(v4, a1, v7);
  return *(_QWORD *)(v4 + 40);
}

void sub_206796954(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGAttributeRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGAttributeRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

unsigned int *CGSVGAttributeGetType(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
    return (unsigned int *)result[20];
  return result;
}

unsigned int *CGSVGAttributeGetName(uint64_t a1, const char *a2)
{
  unsigned int *result;

  result = (unsigned int *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
    return (unsigned int *)result[12];
  return result;
}

void *CGSVGAttributeGetFloatCount(uint64_t a1, const char *a2)
{
  void *result;
  _QWORD *v3;

  result = CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v3 = 0;
    if (SVGAttribute::floatsValue((uint64_t)result, &v3) && v3)
      return (void *)((uint64_t)(v3[1] - *v3) >> 3);
    else
      return 0;
  }
  return result;
}

uint64_t CGSVGAttributeGetFilter(uint64_t a1, char *a2)
{
  os_unfair_lock_s *v3;
  uint64_t result;
  SVGFilter *v5;

  v3 = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  v5 = 0;
  LODWORD(result) = SVGAttribute::filterValue(v3, &v5);
  if (v5)
    result = result;
  else
    result = 0;
  if ((_DWORD)result == 1)
    *(_QWORD *)a2 = *((_QWORD *)v5 + 5);
  return result;
}

uint64_t CGSVGAttributeGetFloats(uint64_t a1, char *a2)
{
  uint64_t result;
  uint64_t v4;

  result = (uint64_t)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v4 = 0;
    if (SVGAttribute::floatsValue(result, &v4) && v4)
    {
      memcpy(a2, *(const void **)v4, *(_QWORD *)(v4 + 8) - *(_QWORD *)v4);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *CGSVGAttributeGetLength(uint64_t a1, const char *a2)
{
  void *result;

  result = CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
    return (void *)SVGAttribute::lengthValue((uint64_t)result, (uint64_t)a2);
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetMask(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;
  SVGMask *v4;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v4 = 0;
    if (SVGAttribute::maskValue(result, &v4) && v4)
    {
      *(_QWORD *)a2 = *((_QWORD *)v4 + 5);
      return (os_unfair_lock_s *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetRect(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
    return (os_unfair_lock_s *)SVGAttribute::rectValue(result, (CGRect *)a2);
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetPaint(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;
  SVGPaint *v4;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v4 = 0;
    if (SVGAttribute::paintValue(result, &v4) && v4)
    {
      *(_QWORD *)a2 = *((_QWORD *)v4 + 5);
      return (os_unfair_lock_s *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetClipPath(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;
  SVGClipPath *v4;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v4 = 0;
    if (SVGAttribute::clipPathValue(result, &v4) && v4)
    {
      *(_QWORD *)a2 = *((_QWORD *)v4 + 5);
      return (os_unfair_lock_s *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetPoint(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
    return (os_unfair_lock_s *)SVGAttribute::pointValue(result, (CGPoint *)a2);
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetPath(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;
  SVGPath *v4;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
  {
    v4 = 0;
    if (SVGAttribute::pathValue(result, &v4) && v4)
    {
      *(_QWORD *)a2 = *((_QWORD *)v4 + 5);
      return (os_unfair_lock_s *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

os_unfair_lock_s *CGSVGAttributeGetTransform(uint64_t a1, char *a2)
{
  os_unfair_lock_s *result;

  result = (os_unfair_lock_s *)CFRetained::getObject<SVGAttribute>(a1, a2);
  if (result)
    return (os_unfair_lock_s *)SVGAttribute::transformValue(result, (CGAffineTransform *)a2);
  return result;
}

uint64_t CGSVGAttributeMapGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGAttributeMap::kSVGAttributeMapClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206796D68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGAttributeMapCreate()
{
  SVGAttributeMap *v0;

  v0 = (SVGAttributeMap *)operator new();
  SVGAttributeMap::SVGAttributeMap(v0);
  return *((_QWORD *)v0 + 5);
}

void sub_206796DC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4084D8EEBALL);
  _Unwind_Resume(a1);
}

uint64_t CGSVGAttributeMapCreateWithDefaults(SVGAttributeMap *a1)
{
  return *((_QWORD *)SVGAttributeMap::CreateWithDefaults(a1) + 5);
}

SVGAttributeMap *CGSVGAttributeMapCopy(uint64_t a1, const char *a2)
{
  SVGAttributeMap *result;

  result = (SVGAttributeMap *)CFRetained::getObject<SVGAttributeMap>(a1, a2);
  if (result)
  {
    result = SVGAttributeMap::createShallowCopy(result);
    if (result)
      return (SVGAttributeMap *)*((_QWORD *)result + 5);
  }
  return result;
}

CFTypeRef CGSVGAttributeMapRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGAttributeMapRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void CGSVGAttributeMapSetAttribute(uint64_t a1, const char *a2)
{
  void *v3;
  const char *v4;
  uint64_t v5;
  void *v6;

  v3 = CFRetained::getObject<SVGAttributeMap>(a1, a2);
  if (v3)
  {
    v5 = (uint64_t)v3;
    v6 = CFRetained::getObject<SVGAttribute>((uint64_t)a2, v4);
    if (v6)
      SVGAttributeMap::setAttribute(v5, (uint64_t)v6, 0);
  }
}

void CGSVGAttributeMapRemoveAttribute(uint64_t a1, const char *a2)
{
  unsigned int v2;
  void *v3;

  v2 = a2;
  v3 = CFRetained::getObject<SVGAttributeMap>(a1, a2);
  if (v3)
    SVGAttributeMap::removeAttribute((uint64_t)v3, v2);
}

SVGAttributeMap *CGSVGAttributeMapGetCount(uint64_t a1, const char *a2)
{
  SVGAttributeMap *result;

  result = (SVGAttributeMap *)CFRetained::getObject<SVGAttributeMap>(a1, a2);
  if (result)
    return (SVGAttributeMap *)SVGAttributeMap::count(result);
  return result;
}

void *CGSVGAttributeMapEnumerate(uint64_t a1, const char *a2)
{
  void *result;
  _QWORD v4[5];

  result = CFRetained::getObject<SVGAttributeMap>(a1, a2);
  if (result)
  {
    v4[0] = MEMORY[0x24BDAC760];
    v4[1] = 0x40000000;
    v4[2] = __CGSVGAttributeMapEnumerate_block_invoke;
    v4[3] = &unk_24BFD94C0;
    v4[4] = a2;
    return (void *)SVGAttributeMap::enumerate((uint64_t)result, (uint64_t)v4);
  }
  return result;
}

double SVGWriter::SVGWriter(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)a1 = a2;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 40) = 0;
  return result;
}

BOOL SVGWriter::write(SVGWriter *this, SVGRootNode *a2, const char *cStr, const SVGStyle *a4)
{
  const __CFAllocator *v5;
  const __CFString *v6;
  const __CFString *v7;
  CFStringRef v8;
  const __CFURL *v9;
  const __CFURL *v10;
  _BOOL8 v11;

  if (!a2 || !cStr)
    return 0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a4;
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], cStr, 0x8000100u);
  if (v6)
  {
    v7 = v6;
    if (!CFStringHasSuffix(v6, CFSTR("file://")))
    {
      v8 = CFStringCreateWithFormat(v5, 0, CFSTR("file://%@"), v7);
      CFRelease(v7);
      v7 = v8;
    }
    v9 = CFURLCreateWithString(v5, v7, 0);
    if (v9)
    {
      v10 = v9;
      *((_QWORD *)this + 3) = CFWriteStreamCreateWithFile(v5, v9);
      CFRelease(v10);
    }
    CFRelease(v7);
  }
  v11 = SVGWriter::writeStream(this);
  SVGWriter::cleanupStream(this);
  return v11;
}

BOOL SVGWriter::writeStream(SVGWriter *this)
{
  uint64_t v1;
  xmlBuffer *v3;
  xmlTextWriter *v4;
  const xmlChar *v5;
  xmlTextWriter *v6;
  const xmlChar *v7;
  const xmlChar *v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double *v20;
  uint64_t v21;
  const SVGNode **v22;
  const SVGNode **v23;
  const SVGNode *v24;
  void *__p[2];
  char v27;

  v1 = *((_QWORD *)this + 3);
  if (v1)
  {
    CFWriteStreamOpen(*((CFWriteStreamRef *)this + 3));
    v3 = xmlBufferCreate();
    *((_QWORD *)this + 5) = v3;
    v4 = xmlNewTextWriterMemory(v3, 0);
    *((_QWORD *)this + 4) = v4;
    if (!*(_QWORD *)this || !*(_BYTE *)(*(_QWORD *)this + 1))
    {
      xmlTextWriterSetIndent(v4, 2);
      xmlTextWriterSetIndentString(*((xmlTextWriterPtr *)this + 4), (const xmlChar *)" ");
    }
    SVGWriter::writeComment((uint64_t)this, *((const SVGNode **)this + 1));
    xmlTextWriterStartDocument(*((xmlTextWriterPtr *)this + 4), 0, "UTF-8", 0);
    if (!*(_QWORD *)this || !*(_BYTE *)(*(_QWORD *)this + 2))
    {
      SVGParser::FormatString((SVGParser *)"Generator: Apple Native CoreSVG %g", __p, 0x4075000000000000);
      v5 = v27 >= 0 ? (const xmlChar *)__p : (const xmlChar *)__p[0];
      xmlTextWriterWriteComment(*((xmlTextWriterPtr *)this + 4), v5);
      xmlTextWriterStartDTD(*((xmlTextWriterPtr *)this + 4), (const xmlChar *)"svg", (const xmlChar *)"-//W3C//DTD SVG 1.1//EN", (const xmlChar *)"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
      xmlTextWriterEndDTD(*((xmlTextWriterPtr *)this + 4));
      if (v27 < 0)
        operator delete(__p[0]);
    }
    v6 = (xmlTextWriter *)*((_QWORD *)this + 4);
    v7 = (const xmlChar *)SVGAtom::ToString(0x3Du);
    xmlTextWriterStartElement(v6, v7);
    v8 = (const xmlChar *)SVGAtom::ToString(0x40u);
    xmlTextWriterWriteAttribute(*((xmlTextWriterPtr *)this + 4), v8, (const xmlChar *)"1.1");
    if (!*(_QWORD *)this || !*(_BYTE *)(*(_QWORD *)this + 2))
    {
      xmlTextWriterWriteAttribute(*((xmlTextWriterPtr *)this + 4), (const xmlChar *)"xmlns", (const xmlChar *)"http://www.w3.org/2000/svg");
      xmlTextWriterWriteAttribute(*((xmlTextWriterPtr *)this + 4), (const xmlChar *)"xmlns:xlink", (const xmlChar *)"http://www.w3.org/1999/xlink");
    }
    v9 = *((_QWORD *)this + 1);
    v11 = *(double *)(v9 + 216);
    v10 = *(double *)(v9 + 224);
    if (v11 == 0.0 || v10 == 0.0)
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
      v13 = v14;
      v12 = v15;
      v9 = *((_QWORD *)this + 1);
    }
    else
    {
      v12 = *(double *)(v9 + 224);
      v13 = *(double *)(v9 + 216);
    }
    v16 = 0.0;
    if (CGRectIsEmpty(*(CGRect *)(v9 + 232)))
    {
      v17 = 0.0;
      v18 = v13;
      v19 = v12;
    }
    else
    {
      v20 = (double *)*((_QWORD *)this + 1);
      v16 = v20[29];
      v17 = v20[30];
      v18 = v20[31];
      v19 = v20[32];
      if (v16 != 0.0 || v17 != 0.0 || v18 != v13 || v19 != v12)
      {
        if (v11 != 0.0)
          SVGWriter::writeAttribute((uint64_t)this, 0x42u, v13);
        if (v10 != 0.0)
          SVGWriter::writeAttribute((uint64_t)this, 0x1Eu, v12);
      }
    }
    SVGWriter::writeAttribute((uint64_t)this, 0x41u, v16, v17, v18, v19);
    SVGWriter::writeDefinitions((xmlTextWriterPtr *)this);
    v21 = *((_QWORD *)this + 1);
    v22 = *(const SVGNode ***)(v21 + 88);
    v23 = *(const SVGNode ***)(v21 + 96);
    while (v22 != v23)
    {
      v24 = *v22++;
      SVGWriter::writeNode((xmlTextWriterPtr *)this, v24);
    }
    xmlTextWriterEndElement(*((xmlTextWriterPtr *)this + 4));
    xmlTextWriterEndDocument(*((xmlTextWriterPtr *)this + 4));
    CFWriteStreamWrite(*((CFWriteStreamRef *)this + 3), **((const UInt8 ***)this + 5), *(unsigned int *)(*((_QWORD *)this + 5) + 8));
  }
  return v1 != 0;
}

void sub_206797358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGWriter::cleanupStream(SVGWriter *this)
{
  __CFWriteStream *v2;

  v2 = (__CFWriteStream *)*((_QWORD *)this + 3);
  if (v2)
  {
    CFWriteStreamClose(v2);
    CFRelease(*((CFTypeRef *)this + 3));
    *((_QWORD *)this + 3) = 0;
  }
  xmlFreeTextWriter(*((xmlTextWriterPtr *)this + 4));
  *((_QWORD *)this + 4) = 0;
  xmlBufferFree(*((xmlBufferPtr *)this + 5));
  *((_QWORD *)this + 5) = 0;
}

BOOL SVGWriter::write(SVGWriter *this, SVGRootNode *a2, __CFData *a3, const SVGStyle *a4)
{
  _BOOL8 v4;
  CFWriteStreamRef v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  CFIndex Length;

  v4 = 0;
  if (a2 && a3)
  {
    *((_QWORD *)this + 1) = a2;
    v8 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x24BDBD240], (CFAllocatorRef)*MEMORY[0x24BDBD240]);
    *((_QWORD *)this + 2) = a4;
    *((_QWORD *)this + 3) = v8;
    v4 = SVGWriter::writeStream(this);
    if (v4)
    {
      v9 = (const __CFData *)CFWriteStreamCopyProperty(*((CFWriteStreamRef *)this + 3), (CFStreamPropertyKey)*MEMORY[0x24BDBD5B8]);
      BytePtr = CFDataGetBytePtr(v9);
      Length = CFDataGetLength(v9);
      CFDataAppendBytes(a3, BytePtr, Length);
      CFRelease(v9);
    }
    SVGWriter::cleanupStream(this);
  }
  return v4;
}

BOOL SVGWriter::write(SVGWriter *this, SVGRootNode *a2, CFURLRef fileURL, const SVGStyle *a4)
{
  CFWriteStreamRef v6;
  _BOOL8 v7;

  if (!a2 || !fileURL)
    return 0;
  *((_QWORD *)this + 1) = a2;
  v6 = CFWriteStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x24BDBD240], fileURL);
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = v6;
  v7 = SVGWriter::writeStream(this);
  SVGWriter::cleanupStream(this);
  return v7;
}

uint64_t SVGWriter::writeComment(uint64_t this, const SVGNode *a2)
{
  const xmlChar *v2;

  v2 = (const xmlChar *)*((_QWORD *)a2 + 23);
  if (v2)
  {
    if (((char)v2[23] & 0x80000000) == 0 || (v2 = *(const xmlChar **)v2) != 0)
    {
      if (*v2)
        return xmlTextWriterWriteComment(*(xmlTextWriterPtr *)(this + 32), v2);
    }
  }
  return this;
}

uint64_t SVGWriter::writeComment(xmlTextWriterPtr *this, const xmlChar *a2)
{
  return xmlTextWriterWriteComment(this[4], a2);
}

uint64_t SVGWriter::writeBeginElement(uint64_t a1, unsigned int a2)
{
  xmlTextWriter *v2;
  const xmlChar *v3;

  v2 = *(xmlTextWriter **)(a1 + 32);
  v3 = (const xmlChar *)SVGAtom::ToString(a2);
  return xmlTextWriterStartElement(v2, v3);
}

uint64_t SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, const xmlChar *a3)
{
  const xmlChar *v5;

  v5 = (const xmlChar *)SVGAtom::ToString(a2);
  return xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v5, a3);
}

uint64_t SVGWriter::writeAttribute(xmlTextWriterPtr *this, const xmlChar *a2, const xmlChar *a3)
{
  return xmlTextWriterWriteAttribute(this[4], a2, a3);
}

void SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, double a3)
{
  int v5;
  void **v6;
  const xmlChar *v7;
  void **v8;
  void *__p[2];
  char v10;

  SVGParser::FormatString((SVGParser *)"%g", __p, *(_QWORD *)&a3);
  v5 = v10;
  v6 = (void **)__p[0];
  v7 = (const xmlChar *)SVGAtom::ToString(a2);
  if (v5 >= 0)
    v8 = __p;
  else
    v8 = v6;
  xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v7, (const xmlChar *)v8);
  if (v10 < 0)
    operator delete(__p[0]);
}

void sub_2067975FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  CGFloat MinX;
  CGFloat MinY;
  CGFloat Width;
  CGFloat Height;
  int v16;
  void **v17;
  const xmlChar *v18;
  void **v19;
  void *__p[2];
  char v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;

  MinX = CGRectGetMinX(*(CGRect *)&a3);
  v22.origin.x = a3;
  v22.origin.y = a4;
  v22.size.width = a5;
  v22.size.height = a6;
  MinY = CGRectGetMinY(v22);
  v23.origin.x = a3;
  v23.origin.y = a4;
  v23.size.width = a5;
  v23.size.height = a6;
  Width = CGRectGetWidth(v23);
  v24.origin.x = a3;
  v24.origin.y = a4;
  v24.size.width = a5;
  v24.size.height = a6;
  Height = CGRectGetHeight(v24);
  SVGParser::FormatString((SVGParser *)"%g %g %g %g", __p, *(_QWORD *)&MinX, *(_QWORD *)&MinY, *(_QWORD *)&Width, *(_QWORD *)&Height);
  v16 = v21;
  v17 = (void **)__p[0];
  v18 = (const xmlChar *)SVGAtom::ToString(a2);
  if (v16 >= 0)
    v19 = __p;
  else
    v19 = v17;
  xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v18, (const xmlChar *)v19);
  if (v21 < 0)
    operator delete(__p[0]);
}

void sub_20679771C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

xmlTextWriterPtr *SVGWriter::writeDefinitions(xmlTextWriterPtr *this)
{
  xmlTextWriterPtr *v1;
  xmlTextWriter *v2;
  const xmlChar *v3;

  v1 = this;
  if (*((_QWORD *)this[1] + 22) || this[2])
  {
    v2 = this[4];
    v3 = (const xmlChar *)SVGAtom::ToString(0xEu);
    xmlTextWriterStartElement(v2, v3);
    SVGWriter::writeGradients((uint64_t)v1);
    SVGWriter::writeImage(v1);
    SVGWriter::writeStyle((SVGWriter *)v1);
    SVGWriter::writePatterns(v1);
    SVGWriter::writeMask(v1);
    return (xmlTextWriterPtr *)xmlTextWriterEndElement(v1[4]);
  }
  return this;
}

uint64_t SVGWriter::writeNode(xmlTextWriterPtr *this, const SVGNode *a2)
{
  const char *v4;
  SVGAtom *v6;
  unsigned int v7;
  xmlTextWriter *v8;
  const xmlChar *v9;
  uint64_t v10;
  const xmlChar *v11;
  const SVGNode **v12;
  const SVGNode **v13;
  const SVGNode *v14;
  _QWORD v15[5];

  SVGWriter::writeComment((uint64_t)this, a2);
  if (!a2)
    __cxa_bad_typeid();
  {
    SVGWriter::writeShapeNode((SVGWriter *)this, a2);
  }
  else
  {
    v6 = (const SVGNode *)((char *)a2 + 64);
    if (*((char *)a2 + 87) < 0)
      v6 = *(SVGAtom **)v6;
    v7 = SVGAtom::ToName(v6, v4);
    v8 = this[4];
    v9 = (const xmlChar *)SVGAtom::ToString(v7);
    xmlTextWriterStartElement(v8, v9);
    v10 = *((_QWORD *)a2 + 7);
    if (v10)
    {
      v15[0] = MEMORY[0x24BDAC760];
      v15[1] = 0x40000000;
      v15[2] = ___ZN9SVGWriter17writeAttributeMapEP15SVGAttributeMap_block_invoke;
      v15[3] = &__block_descriptor_tmp_16;
      v15[4] = this;
      SVGAttributeMap::enumerate(v10, (uint64_t)v15);
    }
    v11 = (const xmlChar *)*((_QWORD *)a2 + 24);
    if (v11)
    {
      if (((char)v11[23] & 0x80000000) == 0 || (v11 = *(const xmlChar **)v11) != 0)
      {
        if (*v11)
          xmlTextWriterWriteString(this[4], v11);
      }
    }
    v13 = (const SVGNode **)*((_QWORD *)a2 + 11);
    v12 = (const SVGNode **)*((_QWORD *)a2 + 12);
    while (v13 != v12)
    {
      v14 = *v13++;
      SVGWriter::writeNode((SVGWriter *)this, v14);
    }
  }
  return xmlTextWriterEndElement(this[4]);
}

uint64_t SVGWriter::writeEndElement(xmlTextWriterPtr *this)
{
  return xmlTextWriterEndElement(this[4]);
}

uint64_t SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, unsigned int a3)
{
  const xmlChar *v5;
  const xmlChar *v6;

  v5 = (const xmlChar *)SVGAtom::ToString(a3);
  v6 = (const xmlChar *)SVGAtom::ToString(a2);
  return xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v6, v5);
}

void SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  int v7;
  void **v8;
  const xmlChar *v9;
  void **v10;
  void *__p[2];
  char v12;

  if (!a5 || COERCE_DOUBLE(a3 & 0x7FFFFFFFFFFFFFFFLL) > 0.00000011920929)
  {
    SVGUtilities::CGSVGLengthToString(a3, a4, __p);
    v7 = v12;
    v8 = (void **)__p[0];
    v9 = (const xmlChar *)SVGAtom::ToString(a2);
    if (v7 >= 0)
      v10 = __p;
    else
      v10 = v8;
    xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v9, (const xmlChar *)v10);
    if (v12 < 0)
      operator delete(__p[0]);
  }
}

void sub_2067979B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  int v10;
  void **v11;
  const xmlChar *v12;
  void **v13;
  void *__p[2];
  char v15;

  if (!CGSVGLengthEqualToLength(a3, a4, a5, a6))
  {
    SVGUtilities::CGSVGLengthToString(a3, a4, __p);
    v10 = v15;
    v11 = (void **)__p[0];
    v12 = (const xmlChar *)SVGAtom::ToString(a2);
    if (v10 >= 0)
      v13 = __p;
    else
      v13 = v11;
    xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v12, (const xmlChar *)v13);
    if (v15 < 0)
      operator delete(__p[0]);
  }
}

void sub_206797A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SVGWriter::writeAttribute(uint64_t a1, unsigned int a2, char *__s1, char *__s2)
{
  uint64_t result;
  const xmlChar *v8;

  result = strcmp(__s1, __s2);
  if ((_DWORD)result)
  {
    v8 = (const xmlChar *)SVGAtom::ToString(a2);
    return xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(a1 + 32), v8, (const xmlChar *)__s1);
  }
  return result;
}

uint64_t SVGWriter::writeAttributeMap(uint64_t this, SVGAttributeMap *a2)
{
  _QWORD v2[5];

  if (a2)
  {
    v2[0] = MEMORY[0x24BDAC760];
    v2[1] = 0x40000000;
    v2[2] = ___ZN9SVGWriter17writeAttributeMapEP15SVGAttributeMap_block_invoke;
    v2[3] = &__block_descriptor_tmp_16;
    v2[4] = this;
    return SVGAttributeMap::enumerate((uint64_t)a2, (uint64_t)v2);
  }
  return this;
}

void ___ZN9SVGWriter17writeAttributeMapEP15SVGAttributeMap_block_invoke(uint64_t a1, unsigned int a2, SVGAttribute *this)
{
  uint64_t v4;
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  const xmlChar *v8;
  const xmlChar *v9;

  v4 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)v4 && a2 >= 0xA0 && **(_BYTE **)v4)
  {
    v5 = SVGAtom::ToString(a2);
    SVGUtilities::error((SVGUtilities *)"Attribute '%s' is not allowed in strict mode\n", v6, v5);
  }
  else
  {
    v7 = SVGAttribute::stringValue(this);
    if (*(char *)(v7 + 23) >= 0)
      v8 = (const xmlChar *)v7;
    else
      v8 = *(const xmlChar **)v7;
    v9 = (const xmlChar *)SVGAtom::ToString(a2);
    xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(v4 + 32), v9, v8);
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

void SVGWriter::writeShapeNode(SVGWriter *this, const SVGShapeNode *a2)
{
  SVGAtom *v4;
  unsigned int v5;
  const char *v6;
  xmlTextWriter *v7;
  const xmlChar *v8;
  uint64_t v9;
  SVGAttributeMap *v10;
  CFTypeRef *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  SVGPath *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const xmlChar *v31;
  _QWORD v32[5];

  v4 = (const SVGShapeNode *)((char *)a2 + 64);
  if (*((char *)a2 + 87) < 0)
    v4 = *(SVGAtom **)v4;
  v5 = SVGAtom::ToName(v4, (const char *)a2);
  if (*(_QWORD *)this && **(_BYTE **)this && *((_DWORD *)a2 + 72) == 10001)
  {
    SVGUtilities::error((SVGUtilities *)"Text shapes are not allowed in strict mode\n", v6);
    return;
  }
  v7 = (xmlTextWriter *)*((_QWORD *)this + 4);
  v8 = (const xmlChar *)SVGAtom::ToString(v5);
  xmlTextWriterStartElement(v7, v8);
  v9 = *((_QWORD *)a2 + 7);
  v10 = (SVGAttributeMap *)operator new();
  v11 = (CFTypeRef *)v10;
  if (v9)
    SVGAttributeMap::SVGAttributeMap(v10, *((const SVGAttributeMap **)a2 + 7));
  else
    SVGAttributeMap::SVGAttributeMap(v10);
  v12 = *((_DWORD *)a2 + 72);
  if (v12 > 43)
  {
    if ((v12 - 44) < 2)
    {
      v19 = SVGShapeNode::pointList(a2);
      if (v19)
      {
        v20 = v19;
        v16 = operator new();
        SVGAttribute::SVGAttribute(v16, 43, v20);
        goto LABEL_31;
      }
    }
    else
    {
      if (v12 == 49)
      {
        v23 = operator new();
        SVGAttribute::SVGAttribute(v23, 67, *((double *)a2 + 25));
        SVGAttributeMap::setAttribute((uint64_t)v11, v23, 1);
        v24 = operator new();
        SVGAttribute::SVGAttribute(v24, 70, *((double *)a2 + 26));
        SVGAttributeMap::setAttribute((uint64_t)v11, v24, 1);
        v25 = operator new();
        SVGAttribute::SVGAttribute(v25, 66, *((double *)a2 + 29));
        SVGAttributeMap::setAttribute((uint64_t)v11, v25, 1);
        v26 = operator new();
        SVGAttribute::SVGAttribute(v26, 30, *((double *)a2 + 30));
        SVGAttributeMap::setAttribute((uint64_t)v11, v26, 1);
        if (*((double *)a2 + 31) <= 0.0)
        {
          SVGAttributeMap::removeAttribute((uint64_t)v11, 0x33u);
        }
        else
        {
          v27 = operator new();
          SVGAttribute::SVGAttribute(v27, 51, *((double *)a2 + 31));
          SVGAttributeMap::setAttribute((uint64_t)v11, v27, 1);
        }
        if (*((double *)a2 + 32) <= 0.0)
        {
          SVGAttributeMap::removeAttribute((uint64_t)v11, 0x34u);
          goto LABEL_32;
        }
        v16 = operator new();
        SVGAttribute::SVGAttribute(v16, 52, *((double *)a2 + 32));
        goto LABEL_31;
      }
      if (v12 == 10001)
      {
        v17 = operator new();
        SVGAttribute::SVGAttribute(v17, 67, *((double *)a2 + 25));
        SVGAttributeMap::setAttribute((uint64_t)v11, v17, 1);
        v16 = operator new();
        SVGAttribute::SVGAttribute(v16, 70, *((double *)a2 + 26));
        goto LABEL_31;
      }
    }
  }
  else if (v12 > 31)
  {
    if (v12 == 32)
    {
      v28 = operator new();
      SVGAttribute::SVGAttribute(v28, 68, *((double *)a2 + 25));
      SVGAttributeMap::setAttribute((uint64_t)v11, v28, 1);
      v29 = operator new();
      SVGAttribute::SVGAttribute(v29, 71, *((double *)a2 + 26));
      SVGAttributeMap::setAttribute((uint64_t)v11, v29, 1);
      v30 = operator new();
      SVGAttribute::SVGAttribute(v30, 69, *((double *)a2 + 27));
      SVGAttributeMap::setAttribute((uint64_t)v11, v30, 1);
      v16 = operator new();
      SVGAttribute::SVGAttribute(v16, 72, *((double *)a2 + 28));
      goto LABEL_31;
    }
    if (v12 == 42)
    {
      v18 = SVGShapeNode::path(a2);
      v16 = operator new();
      SVGAttribute::SVGAttribute(v16, 11, v18);
      goto LABEL_31;
    }
  }
  else
  {
    if (v12 == 3)
    {
      v21 = operator new();
      SVGAttribute::SVGAttribute(v21, 9, *((double *)a2 + 33));
      SVGAttributeMap::setAttribute((uint64_t)v11, v21, 1);
      v22 = operator new();
      SVGAttribute::SVGAttribute(v22, 10, *((double *)a2 + 34));
      SVGAttributeMap::setAttribute((uint64_t)v11, v22, 1);
      v16 = operator new();
      SVGAttribute::SVGAttribute(v16, 47, *((double *)a2 + 35));
      goto LABEL_31;
    }
    if (v12 == 16)
    {
      v13 = operator new();
      SVGAttribute::SVGAttribute(v13, 9, *((double *)a2 + 33));
      SVGAttributeMap::setAttribute((uint64_t)v11, v13, 1);
      v14 = operator new();
      SVGAttribute::SVGAttribute(v14, 10, *((double *)a2 + 34));
      SVGAttributeMap::setAttribute((uint64_t)v11, v14, 1);
      v15 = operator new();
      SVGAttribute::SVGAttribute(v15, 51, *((double *)a2 + 31));
      SVGAttributeMap::setAttribute((uint64_t)v11, v15, 1);
      v16 = operator new();
      SVGAttribute::SVGAttribute(v16, 52, *((double *)a2 + 32));
LABEL_31:
      SVGAttributeMap::setAttribute((uint64_t)v11, v16, 1);
    }
  }
LABEL_32:
  v32[0] = MEMORY[0x24BDAC760];
  v32[1] = 0x40000000;
  v32[2] = ___ZN9SVGWriter17writeAttributeMapEP15SVGAttributeMap_block_invoke;
  v32[3] = &__block_descriptor_tmp_16;
  v32[4] = this;
  SVGAttributeMap::enumerate((uint64_t)v11, (uint64_t)v32);
  CFRetained::release(v11);
  if (*((_DWORD *)a2 + 72) == 10001)
  {
    v31 = (const xmlChar *)*((_QWORD *)a2 + 24);
    if (v31)
    {
      if (((char)v31[23] & 0x80000000) == 0 || (v31 = *(const xmlChar **)v31) != 0)
      {
        if (*v31)
          xmlTextWriterWriteString(*((xmlTextWriterPtr *)this + 4), v31);
      }
    }
  }
}

void sub_206798288(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C405B4D0908);
  _Unwind_Resume(a1);
}

xmlTextWriterPtr *SVGWriter::writeImage(xmlTextWriterPtr *this)
{
  xmlTextWriterPtr v1;
  _QWORD *v2;
  _QWORD *v3;
  xmlTextWriterPtr *v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = this[1];
  v2 = (_QWORD *)*((_QWORD *)v1 + 20);
  v3 = (_QWORD *)((char *)v1 + 168);
  if (v2 != (_QWORD *)((char *)v1 + 168))
  {
    v4 = this;
    do
    {
      this = (xmlTextWriterPtr *)v2[7];
      if (this)
      {
        if (this)
          this = (xmlTextWriterPtr *)SVGWriter::writeNode(v4, (const SVGNode *)this);
      }
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  return this;
}

uint64_t SVGWriter::writeGradients(uint64_t this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  xmlTextWriter *v7;
  const xmlChar *v8;
  char *v9;
  const xmlChar *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  SVGAttribute *v25;
  uint64_t v26;
  const xmlChar *v27;
  const xmlChar *v28;
  SVGAttribute *v29;
  uint64_t v30;
  const xmlChar *v31;
  const xmlChar *v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  xmlTextWriter *v36;
  const xmlChar *v37;
  void **v38;
  const xmlChar *v39;
  void **v40;
  _QWORD *v41;
  _QWORD *v42;
  BOOL v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE v51[40];
  void *__p[2];
  char v53;

  v1 = *(_QWORD *)(this + 8);
  v2 = *(_QWORD **)(v1 + 160);
  v3 = (_QWORD *)(v1 + 168);
  if (v2 != (_QWORD *)(v1 + 168))
  {
    v4 = this;
    v44 = (_QWORD *)(v1 + 168);
    do
    {
      this = v2[7];
      if (this)
      {
        if (this)
        {
          v5 = this;
          if (*(_DWORD *)(this + 200))
            v6 = 48;
          else
            v6 = 33;
          v7 = *(xmlTextWriter **)(v4 + 32);
          v8 = (const xmlChar *)SVGAtom::ToString(v6);
          xmlTextWriterStartElement(v7, v8);
          v9 = SVGNode::identifier((SVGNode *)v5);
          v10 = (const xmlChar *)SVGAtom::ToString(0x1Fu);
          xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(v4 + 32), v10, (const xmlChar *)v9);
          if (*(_DWORD *)(v5 + 200))
          {
            v11 = *(_QWORD *)(v5 + 296);
            v12 = *(_QWORD *)(v5 + 304);
            v13 = *(_QWORD *)(v5 + 312);
            v14 = *(_QWORD *)(v5 + 320);
            v45 = *(_QWORD *)(v5 + 336);
            v46 = *(_QWORD *)(v5 + 328);
            v47 = *(_QWORD *)(v5 + 352);
            v48 = *(_QWORD *)(v5 + 344);
            v49 = *(_QWORD *)(v5 + 368);
            v50 = *(_QWORD *)(v5 + 360);
            CGSVGLengthMakeWithType();
            v16 = v15;
            v18 = v17;
            SVGWriter::writeAttribute(v4, 9u, v11, v12, v15, v17);
            SVGWriter::writeAttribute(v4, 0xAu, v13, v14, v16, v18);
            SVGWriter::writeAttribute(v4, 0x1Au, v46, v45, v11, v12);
            SVGWriter::writeAttribute(v4, 0x1Bu, v48, v47, v13, v14);
            SVGWriter::writeAttribute(v4, 0x2Fu, v50, v49, v16, v18);
          }
          else
          {
            v19 = *(_QWORD *)(v5 + 248);
            v20 = *(_QWORD *)(v5 + 256);
            v21 = *(_QWORD *)(v5 + 264);
            v22 = *(_QWORD *)(v5 + 272);
            v23 = *(_QWORD *)(v5 + 280);
            v24 = *(_QWORD *)(v5 + 288);
            SVGWriter::writeAttribute(v4, 0x44u, *(_QWORD *)(v5 + 232), *(_QWORD *)(v5 + 240), 1);
            SVGWriter::writeAttribute(v4, 0x47u, v19, v20, 1);
            SVGWriter::writeAttribute(v4, 0x45u, v21, v22, 1);
            SVGWriter::writeAttribute(v4, 0x48u, v23, v24, 1);
          }
          v25 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(v5 + 56), 0x1Cu);
          if (v25)
          {
            v26 = SVGAttribute::stringValue(v25);
            if (*(char *)(v26 + 23) >= 0)
              v27 = (const xmlChar *)v26;
            else
              v27 = *(const xmlChar **)v26;
            v28 = (const xmlChar *)SVGAtom::ToString(0x1Cu);
            xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(v4 + 32), v28, v27);
          }
          v29 = (SVGAttribute *)SVGAttributeMap::attribute(*(_QWORD *)(v5 + 56), 0x4Eu);
          if (v29)
          {
            v30 = SVGAttribute::stringValue(v29);
            if (*(char *)(v30 + 23) >= 0)
              v31 = (const xmlChar *)v30;
            else
              v31 = *(const xmlChar **)v30;
            v32 = (const xmlChar *)SVGAtom::ToString(0x4Eu);
            xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(v4 + 32), v32, v31);
          }
          v33 = *(uint64_t **)(v5 + 208);
          v34 = *(uint64_t **)(v5 + 216);
          while (v33 != v34)
          {
            v35 = *v33;
            v36 = *(xmlTextWriter **)(v4 + 32);
            v37 = (const xmlChar *)SVGAtom::ToString(0x37u);
            xmlTextWriterStartElement(v36, v37);
            SVGWriter::writeAttribute(v4, 0x28u, *(_QWORD *)(v35 + 96), *(_QWORD *)(v35 + 104), 0);
            SVGColor::SVGColor((uint64_t)v51, v35 + 48);
            SVGColor::GetStringForColor((uint64_t)v51, (uint64_t)__p);
            LODWORD(v36) = v53;
            v38 = (void **)__p[0];
            v39 = (const xmlChar *)SVGAtom::ToString(0x38u);
            if ((int)v36 >= 0)
              v40 = __p;
            else
              v40 = v38;
            xmlTextWriterWriteAttribute(*(xmlTextWriterPtr *)(v4 + 32), v39, (const xmlChar *)v40);
            SVGWriter::writeAttribute(v4, 0x53u, *(double *)(v35 + 88));
            xmlTextWriterEndElement(*(xmlTextWriterPtr *)(v4 + 32));
            if (v53 < 0)
              operator delete(__p[0]);
            ++v33;
          }
          this = xmlTextWriterEndElement(*(xmlTextWriterPtr *)(v4 + 32));
          v3 = v44;
        }
      }
      v41 = (_QWORD *)v2[1];
      if (v41)
      {
        do
        {
          v42 = v41;
          v41 = (_QWORD *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          v42 = (_QWORD *)v2[2];
          v43 = *v42 == (_QWORD)v2;
          v2 = v42;
        }
        while (!v43);
      }
      v2 = v42;
    }
    while (v42 != v3);
  }
  return this;
}

void sub_206798734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

xmlTextWriterPtr *SVGWriter::writePatterns(xmlTextWriterPtr *this)
{
  xmlTextWriterPtr v1;
  _QWORD *v2;
  _QWORD *v3;
  xmlTextWriterPtr *v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = this[1];
  v2 = (_QWORD *)*((_QWORD *)v1 + 20);
  v3 = (_QWORD *)((char *)v1 + 168);
  if (v2 != (_QWORD *)((char *)v1 + 168))
  {
    v4 = this;
    do
    {
      this = (xmlTextWriterPtr *)v2[7];
      if (this)
      {
        if (this)
          this = (xmlTextWriterPtr *)SVGWriter::writeNode(v4, (const SVGNode *)this);
      }
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  return this;
}

void SVGWriter::writeStyle(SVGWriter *this)
{
  uint64_t v1;
  xmlTextWriter *v3;
  const xmlChar *v4;
  char **v5;
  uint64_t v6;
  std::string *v7;
  std::string *v8;
  int v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  std::string *v12;
  char *v13;
  char **v14;
  BOOL v15;
  std::string *v16;
  _QWORD v17[5];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  __n128 (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  void *__p;
  char v24;
  std::string v25;
  std::string v26;
  uint64_t v27;
  std::string v28;
  char **v29;
  char *v30[4];

  v1 = *((_QWORD *)this + 2);
  if (v1 && *(_QWORD *)(v1 + 16))
  {
    v3 = (xmlTextWriter *)*((_QWORD *)this + 4);
    v4 = (const xmlChar *)SVGAtom::ToString(0x3Cu);
    xmlTextWriterStartElement(v3, v4);
    std::map<std::string,SVGAttributeMap *,CaseInsensitiveStringLess,std::allocator<std::pair<std::string const,SVGAttributeMap *>>>::map[abi:ne180100]((uint64_t *)&v29, *((_QWORD *)this + 2));
    memset(&v28, 0, sizeof(v28));
    v5 = v29;
    if (v29 == v30)
    {
      v16 = &v28;
    }
    else
    {
      do
      {
        if (*((char *)v5 + 55) < 0)
          std::string::__init_copy_ctor_external(&v26, v5[4], (std::string::size_type)v5[5]);
        else
          v26 = *(std::string *)(v5 + 4);
        v6 = (uint64_t)v5[7];
        v27 = v6;
        if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(&v25, v26.__r_.__value_.__l.__data_, v26.__r_.__value_.__l.__size_);
          v6 = v27;
        }
        else
        {
          v25 = v26;
        }
        v18 = 0;
        v19 = &v18;
        v20 = 0x4002000000;
        v21 = __Block_byref_object_copy__3;
        v22 = __Block_byref_object_dispose__3;
        v7 = &v25;
        if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v7 = (std::string *)v25.__r_.__value_.__r.__words[0];
        SVGParser::FormatString((SVGParser *)"%s{", &__p, v7);
        v17[0] = MEMORY[0x24BDAC760];
        v17[1] = 0x40000000;
        v17[2] = ___ZN9SVGWriter10writeStyleEv_block_invoke;
        v17[3] = &unk_24BFD9508;
        v17[4] = &v18;
        SVGAttributeMap::enumerate(v6, (uint64_t)v17);
        v8 = std::string::append((std::string *)(v19 + 5), "}");
        std::string::operator=((std::string *)(v19 + 5), v8);
        v9 = *((char *)v19 + 63);
        if (v9 >= 0)
          v10 = (const std::string::value_type *)(v19 + 5);
        else
          v10 = (const std::string::value_type *)v19[5];
        if (v9 >= 0)
          v11 = *((unsigned __int8 *)v19 + 63);
        else
          v11 = v19[6];
        v12 = std::string::append(&v28, v10, v11);
        std::string::operator=(&v28, v12);
        _Block_object_dispose(&v18, 8);
        if (v24 < 0)
          operator delete(__p);
        if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v25.__r_.__value_.__l.__data_);
        if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v26.__r_.__value_.__l.__data_);
        v13 = v5[1];
        if (v13)
        {
          do
          {
            v14 = (char **)v13;
            v13 = *(char **)v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            v14 = (char **)v5[2];
            v15 = *v14 == (char *)v5;
            v5 = v14;
          }
          while (!v15);
        }
        v5 = v14;
      }
      while (v14 != v30);
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v16 = &v28;
      else
        v16 = (std::string *)v28.__r_.__value_.__r.__words[0];
    }
    xmlTextWriterWriteString(*((xmlTextWriterPtr *)this + 4), (const xmlChar *)v16);
    xmlTextWriterEndElement(*((xmlTextWriterPtr *)this + 4));
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v28.__r_.__value_.__l.__data_);
    std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy((uint64_t)&v29, v30[0]);
  }
}

void sub_206798AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v40;

  if (*(char *)(v40 - 137) < 0)
    operator delete(*(void **)(v40 - 160));
  std::__tree<std::__value_type<std::string,SVGAtom::Name>,std::__map_value_compare<std::string,std::__value_type<std::string,SVGAtom::Name>,CaseInsensitiveStringLess,true>,std::allocator<std::__value_type<std::string,SVGAtom::Name>>>::destroy(v40 - 136, *(char **)(v40 - 128));
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

void ___ZN9SVGWriter10writeStyleEv_block_invoke(uint64_t a1, unsigned int a2, SVGAttribute *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  void **v8;
  std::string::size_type v9;
  std::string *v10;
  void *__p[2];
  unsigned __int8 v12;

  v5 = SVGAtom::ToString(a2);
  v6 = SVGAttribute::stringValue(a3);
  if (*(char *)(v6 + 23) >= 0)
    v7 = v6;
  else
    v7 = *(_QWORD *)v6;
  SVGParser::FormatString((SVGParser *)"%s:%s;", __p, v5, v7);
  if ((v12 & 0x80u) == 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  if ((v12 & 0x80u) == 0)
    v9 = v12;
  else
    v9 = (std::string::size_type)__p[1];
  v10 = std::string::append((std::string *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), (const std::string::value_type *)v8, v9);
  std::string::operator=((std::string *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v10);
  if ((char)v12 < 0)
    operator delete(__p[0]);
}

void sub_206798C1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

xmlTextWriterPtr *SVGWriter::writeMask(xmlTextWriterPtr *this)
{
  xmlTextWriterPtr v1;
  _QWORD *v2;
  _QWORD *v3;
  xmlTextWriterPtr *v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = this[1];
  v2 = (_QWORD *)*((_QWORD *)v1 + 20);
  v3 = (_QWORD *)((char *)v1 + 168);
  if (v2 != (_QWORD *)((char *)v1 + 168))
  {
    v4 = this;
    do
    {
      this = (xmlTextWriterPtr *)v2[7];
      if (this)
      {
        if (this)
          this = (xmlTextWriterPtr *)SVGWriter::writeNode(v4, (const SVGNode *)this);
      }
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  return this;
}

uint64_t CGSVGClipPathGetTypeID()
{
  uint64_t TypeID;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, SVGNode::kSVGNodeClassName);
  TypeID = CFRetained::getTypeID((uint64_t)__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return TypeID;
}

void sub_206798D3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGSVGClipPathCreate()
{
  SVGClipPath *v0;

  v0 = (SVGClipPath *)operator new();
  SVGClipPath::SVGClipPath(v0, 0);
  return *((_QWORD *)v0 + 5);
}

void sub_206798D98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCFC038](v1, 0x10B3C4094216EFELL);
  _Unwind_Resume(a1);
}

CFTypeRef CGSVGClipPathRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGSVGClipPathRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

SVGClipPath *CGSVGClipPathGetCompositePath(uint64_t a1, const char *a2)
{
  SVGClipPath *result;

  result = (SVGClipPath *)CFRetained::getObject<SVGClipPath>(a1, a2);
  if (result)
    return SVGClipPath::getCGClippingPath(result, 0);
  return result;
}

CGMutablePathRef CGSVGClipPathGetCompositePathRelativeToNode(uint64_t a1, const char *a2)
{
  SVGClipPath *v3;
  const char *v4;
  SVGClipPath *v5;
  SVGNode *v6;

  v3 = (SVGClipPath *)CFRetained::getObject<SVGClipPath>(a1, a2);
  if (v3 && (v5 = v3, (v6 = (SVGNode *)CFRetained::getObject<SVGNode>((uint64_t)a2, v4)) != 0))
    return SVGClipPath::getCGClippingPath(v5, v6);
  else
    return 0;
}

_QWORD *CGSVGClipPathGetPath(uint64_t a1, const char *a2)
{
  _QWORD *ChildAtIndex;
  const char *v3;
  _QWORD *result;

  ChildAtIndex = CGSVGNodeGetChildAtIndex(a1, a2);
  result = CFRetained::getObject<SVGNode>((uint64_t)ChildAtIndex, v3);
  if (result)
  {
    if (result)
    {
      result = SVGShapeNode::createSVGPath((SVGShapeNode *)result);
      if (result)
        return (_QWORD *)result[5];
    }
  }
  return result;
}

void SVGPathCommand::appendPoints()
{
  __assert_rtn("appendPoints", "SVGPath.cpp", 120, "_floats != nullptr");
}

void CGSVGDrawState::CGSVGDrawState()
{
  __assert_rtn("CGSVGDrawState", "CGSVGContext.cpp", 95, "this != &state");
}

void SVGUtilities::CGPointListFromFloats()
{
  __assert_rtn("CGPointListFromFloats", "SVGUtilities.mm", 177, "((count % 2) == 0) && \"Must be multiple of two\"");
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x24BDBB8B0](alloc, str, attributes);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x24BDBBC88](theData, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x24BDBBCB0](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x24BDBBDB8](theDict, applier, context);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEE8](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x24BDBC218](stream);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x24BDBC230](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x24BDBC258](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x24BDBC260](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC4D0](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x24BDBC598](alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x24BDBC618](theString, idx);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC660](length, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x24BDBC6B0](theString, suffix);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x24BDBC790](relativeURL);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x24BDBC7D8](anURL);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x24BDBC808](allocator, url);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x24BDBC868](allocator, URLString, baseURL);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x24BDBC968](stream);
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x24BDBC978](stream, propertyName);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return (CFWriteStreamRef)MEMORY[0x24BDBC980](alloc, bufferAllocator);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x24BDBC988](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x24BDBC9A8](stream);
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x24BDBC9E0](stream, buffer, bufferLength);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8A0](retstr, t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8C0](retstr, t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8D8](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E0](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E8](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8F8](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD900](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD908](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x24BDBD918](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x24BDBD920](context);
}

CGBitmapInfo CGBitmapContextGetBitmapInfo(CGContextRef context)
{
  return MEMORY[0x24BDBD940](context);
}

size_t CGBitmapContextGetBitsPerComponent(CGContextRef context)
{
  return MEMORY[0x24BDBD948](context);
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  return MEMORY[0x24BDBD958](context);
}

CGColorSpaceRef CGBitmapContextGetColorSpace(CGContextRef context)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBD960](context);
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return (void *)MEMORY[0x24BDBD968](context);
}

size_t CGBitmapContextGetHeight(CGContextRef context)
{
  return MEMORY[0x24BDBD970](context);
}

size_t CGBitmapContextGetWidth(CGContextRef context)
{
  return MEMORY[0x24BDBD978](context);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x24BDBDA78](space, components);
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x24BDBDB40](color);
}

CGColorSpaceRef CGColorSpaceCreateDeviceGray(void)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDB80]();
}

CGColorSpaceRef CGColorSpaceCreatePattern(CGColorSpaceRef baseSpace)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDBA0](baseSpace);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDBB8](name);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x24BDBDC10](space);
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  return MEMORY[0x24BDBDC58](a1);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x24BDBDC60](space);
}

void CGContextAddArc(CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)
{
  MEMORY[0x24BDBDCB0](c, *(_QWORD *)&clockwise, x, y, radius, startAngle, endAngle);
}

void CGContextAddEllipseInRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDCC8](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDCD0](c, x, y);
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
  MEMORY[0x24BDBDCE0](c, path);
}

void CGContextBeginPath(CGContextRef c)
{
  MEMORY[0x24BDBDD00](c);
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
  MEMORY[0x24BDBDD08](c, auxiliaryInfo);
}

void CGContextClip(CGContextRef c)
{
  MEMORY[0x24BDBDD28](c);
}

void CGContextClipToMask(CGContextRef c, CGRect rect, CGImageRef mask)
{
  MEMORY[0x24BDBDD30](c, mask, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDD38](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClosePath(CGContextRef c)
{
  MEMORY[0x24BDBDD48](c);
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  MEMORY[0x24BDBDD50](c, transform);
}

uint64_t CGContextCopyTopGState()
{
  return MEMORY[0x24BDBDD90]();
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x24BDBDDD8](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextDrawLinearGradient(CGContextRef c, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)
{
  MEMORY[0x24BDBDDF8](c, gradient, *(_QWORD *)&options, (__n128)startPoint, *(__n128 *)&startPoint.y, (__n128)endPoint, *(__n128 *)&endPoint.y);
}

void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)
{
  MEMORY[0x24BDBDE18](c, *(_QWORD *)&mode);
}

void CGContextDrawRadialGradient(CGContextRef c, CGGradientRef gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options)
{
  MEMORY[0x24BDBDE28](c, gradient, *(_QWORD *)&options, (__n128)startCenter, *(__n128 *)&startCenter.y, startRadius, (__n128)endCenter, *(__n128 *)&endCenter.y, endRadius);
}

void CGContextEOClip(CGContextRef c)
{
  MEMORY[0x24BDBDE40](c);
}

void CGContextEOFillPath(CGContextRef c)
{
  MEMORY[0x24BDBDE48](c);
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
  MEMORY[0x24BDBDE58](c);
}

void CGContextFillPath(CGContextRef c)
{
  MEMORY[0x24BDBDE68](c);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDE70](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x24BDBDE98](retstr, c);
}

CGRect CGContextGetPathBoundingBox(CGContextRef c)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBDEE8](c);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

uint64_t CGContextGetType()
{
  return MEMORY[0x24BDBDF10]();
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDF20](c, x, y);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x24BDBDF30](c);
}

void CGContextReplacePathWithStrokedPath(CGContextRef c)
{
  MEMORY[0x24BDBDF38](c);
}

uint64_t CGContextReplaceTopGState()
{
  return MEMORY[0x24BDBDF40]();
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x24BDBDF58](c);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x24BDBDF70](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x24BDBDF78](c, sx, sy);
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
  MEMORY[0x24BDBDFA0](c, alpha);
}

uint64_t CGContextSetCTM()
{
  return MEMORY[0x24BDBDFB8]();
}

void CGContextSetFillColorSpace(CGContextRef c, CGColorSpaceRef space)
{
  MEMORY[0x24BDBDFD0](c, space);
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x24BDBDFD8](c, color);
}

void CGContextSetFillPattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
  MEMORY[0x24BDBDFE0](c, pattern, components);
}

void CGContextSetLineCap(CGContextRef c, CGLineCap cap)
{
  MEMORY[0x24BDBE020](c, *(_QWORD *)&cap);
}

void CGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)
{
  MEMORY[0x24BDBE028](c, lengths, count, phase);
}

void CGContextSetLineJoin(CGContextRef c, CGLineJoin join)
{
  MEMORY[0x24BDBE030](c, *(_QWORD *)&join);
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  MEMORY[0x24BDBE038](c, width);
}

void CGContextSetMiterLimit(CGContextRef c, CGFloat limit)
{
  MEMORY[0x24BDBE048](c, limit);
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x24BDBE060](c, red, green, blue, alpha);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x24BDBE068](c, red, green, blue, alpha);
}

void CGContextSetStrokeColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x24BDBE0D0](c, color);
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
  MEMORY[0x24BDBE0F0](c, t);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBE0F8](c, x, y);
}

void CGContextStrokePath(CGContextRef c)
{
  MEMORY[0x24BDBE118](c);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x24BDBE130](c, tx, ty);
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  return (CFDataRef)MEMORY[0x24BDBE168](provider);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE190](info, data, size, releaseData);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  MEMORY[0x24BDBE1C8](provider);
}

uint64_t CGGStateRelease()
{
  return MEMORY[0x24BDBE4E0]();
}

CGGradientRef CGGradientCreateWithColors(CGColorSpaceRef space, CFArrayRef colors, const CGFloat *locations)
{
  return (CGGradientRef)MEMORY[0x24BDBE538](space, colors, locations);
}

void CGGradientRelease(CGGradientRef gradient)
{
  MEMORY[0x24BDBE550](gradient);
}

CGImageRef CGImageCreateCopy(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x24BDBE5E8](image);
}

CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image)
{
  return MEMORY[0x24BDBE628](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x24BDBE630](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x24BDBE638](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBE658](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x24BDBE680](image);
}

CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image)
{
  return MEMORY[0x24BDBE6C0](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x24BDBE6E0](image);
}

CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate)
{
  return (CGImageRef)MEMORY[0x24BDBE6F8](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, provider, decode, shouldInterpolate);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x24BDBE770](image);
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x24BDBE778](image);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x24BDD9158](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x24BDD9180](url, options);
}

uint64_t CGImageWriteToFile()
{
  return MEMORY[0x24BDBE7C8]();
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDB8](path, m, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGPathAddEllipseInRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  MEMORY[0x24BDBEDC0](path, m, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDC8](path, m, x, y);
}

void CGPathAddLines(CGMutablePathRef path, const CGAffineTransform *m, const CGPoint *points, size_t count)
{
  MEMORY[0x24BDBEDD0](path, m, points, count);
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
  MEMORY[0x24BDBEDD8](path1, m, path2);
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDE0](path, m, cpx, cpy, x, y);
}

void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  MEMORY[0x24BDBEDE8](path, m, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathAddRelativeArc(CGMutablePathRef path, const CGAffineTransform *matrix, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat delta)
{
  MEMORY[0x24BDBEDF8](path, matrix, x, y, radius, startAngle, delta);
}

void CGPathAddRoundedRect(CGMutablePathRef path, const CGAffineTransform *transform, CGRect rect, CGFloat cornerWidth, CGFloat cornerHeight)
{
  MEMORY[0x24BDBEE00](path, transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, cornerWidth, cornerHeight);
}

void CGPathApplyWithBlock(CGPathRef path, CGPathApplyBlock block)
{
  MEMORY[0x24BDBEE10](path, block);
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  MEMORY[0x24BDBEE20](path);
}

CGPathRef CGPathCreateCopy(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x24BDBEE30](path);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x24BDBEE80]();
}

CGMutablePathRef CGPathCreateMutableCopy(CGPathRef path)
{
  return (CGMutablePathRef)MEMORY[0x24BDBEE88](path);
}

CGPathRef CGPathCreateWithRoundedRect(CGRect rect, CGFloat cornerWidth, CGFloat cornerHeight, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEEB0](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, cornerWidth, cornerHeight);
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBEEC0](path);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGPoint CGPathGetCurrentPoint(CGPathRef path)
{
  double v1;
  double v2;
  CGPoint result;

  MEMORY[0x24BDBEEC8](path);
  result.y = v2;
  result.x = v1;
  return result;
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEF40](path, m, x, y);
}

void CGPathRelease(CGPathRef path)
{
  MEMORY[0x24BDBEF48](path);
}

CGPatternRef CGPatternCreate(void *info, CGRect bounds, CGAffineTransform *matrix, CGFloat xStep, CGFloat yStep, CGPatternTiling tiling, BOOL isColored, const CGPatternCallbacks *callbacks)
{
  return (CGPatternRef)MEMORY[0x24BDBEF58](info, matrix, *(_QWORD *)&tiling, isColored, callbacks, (__n128)bounds.origin, *(__n128 *)&bounds.origin.y, (__n128)bounds.size, *(__n128 *)&bounds.size.height, xStep, yStep);
}

void CGPatternRelease(CGPatternRef pattern)
{
  MEMORY[0x24BDBEF88](pattern);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBEFB8](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFE8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF010]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF018]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF020]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x24BDBF030]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x24BDBF050]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGRectStandardize(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBF080]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBF088]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGPathRef CTFontCreatePathForGlyph(CTFontRef font, CGGlyph glyph, const CGAffineTransform *matrix)
{
  return (CGPathRef)MEMORY[0x24BDC47A0](font, glyph, matrix);
}

CTFontRef CTFontCreateWithFontDescriptor(CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x24BDC47B0](descriptor, matrix, size);
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x24BDC4830](attributes);
}

CGFloat CTFontGetSize(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4908](font);
  return result;
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x24BDC4A30](attrString);
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
  MEMORY[0x24BDC4A68](line, context);
}

CFArrayRef CTLineGetGlyphRuns(CTLineRef line)
{
  return (CFArrayRef)MEMORY[0x24BDC4A88](line);
}

CGRect CTLineGetImageBounds(CTLineRef line, CGContextRef context)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDC4A90](line, context);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CFIndex CTRunGetGlyphCount(CTRunRef run)
{
  return MEMORY[0x24BDC4B28](run);
}

void CTRunGetGlyphs(CTRunRef run, CFRange range, CGGlyph *buffer)
{
  MEMORY[0x24BDC4B30](run, range.location, range.length, buffer);
}

const CGGlyph *__cdecl CTRunGetGlyphsPtr(CTRunRef run)
{
  return (const CGGlyph *)MEMORY[0x24BDC4B38](run);
}

void CTRunGetPositions(CTRunRef run, CFRange range, CGPoint *buffer)
{
  MEMORY[0x24BDC4B48](run, range.location, range.length, buffer);
}

const CGPoint *__cdecl CTRunGetPositionsPtr(CTRunRef run)
{
  return (const CGPoint *)MEMORY[0x24BDC4B50](run);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x24BDBD0A8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x24BDBD0B0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x24BEDA9C0](this, __s);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

std::string::reference std::string::at(std::string *this, std::string::size_type __n)
{
  return (std::string::reference)MEMORY[0x24BEDAC10](this, __n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC20](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC38](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC58](this, __s);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC60](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC80](this, __pos, __s);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  MEMORY[0x24BEDAC98](this, __n, __c);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDACA0](this, __pos, __n1, __s);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x24BEDACE8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x24BEDAD00](this, __str);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24BFD8500(__p);
}

uint64_t operator delete()
{
  return off_24BFD8508();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24BFD8510(__sz);
}

uint64_t operator new()
{
  return off_24BFD8518();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void __cxa_bad_typeid(void)
{
  MEMORY[0x24BEDB908]();
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x24BEDB968](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

__double2 __sincos_stret(double a1)
{
  double v1;
  double v2;
  __double2 result;

  MEMORY[0x24BDAC890](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

long double acos(long double __x)
{
  long double result;

  MEMORY[0x24BDAD108](__x);
  return result;
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE3F0](__x, __y);
  return result;
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x24BDAE5F0](a1);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

locale_t newlocale(int a1, const char *a2, locale_t a3)
{
  return (locale_t)MEMORY[0x24BDAF108](*(_QWORD *)&a1, a2, a3);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF460](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int putchar(int a1)
{
  return MEMORY[0x24BDAF9F0](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x24BDAFED0](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x24BDAFF10](__s1);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x24BDAFF50](a1, a2, a3);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  double result;

  MEMORY[0x24BDAFFD8](a1, a2, a3);
  return result;
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0030](__str, __endptr, *(_QWORD *)&__base);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x24BDB0138](__x);
  return result;
}

vImage_Error vImageBufferFill_ARGB8888(const vImage_Buffer *dest, const Pixel_8888 color, vImage_Flags flags)
{
  return MEMORY[0x24BDB3620](dest, color, *(_QWORD *)&flags);
}

vImage_Error vImageBuffer_Init(vImage_Buffer *buf, vImagePixelCount height, vImagePixelCount width, uint32_t pixelBits, vImage_Flags flags)
{
  return MEMORY[0x24BDB3630](buf, height, width, *(_QWORD *)&pixelBits, *(_QWORD *)&flags);
}

vImage_Error vImageBuffer_InitWithCGImage(vImage_Buffer *buf, vImage_CGImageFormat *format, const CGFloat *backgroundColor, CGImageRef image, vImage_Flags flags)
{
  return MEMORY[0x24BDB3638](buf, format, backgroundColor, image, *(_QWORD *)&flags);
}

vImage_Error vImageConvolveWithBias_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, const int16_t *kernel, uint32_t kernel_height, uint32_t kernel_width, int32_t divisor, int32_t bias, const Pixel_8888 backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x24BDB3888](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel, *(_QWORD *)&kernel_height, *(_QWORD *)&kernel_width);
}

CGImageRef vImageCreateCGImageFromBuffer(const vImage_Buffer *buf, const vImage_CGImageFormat *format, void (__cdecl *callback)(void *, void *), void *userData, vImage_Flags flags, vImage_Error *error)
{
  return (CGImageRef)MEMORY[0x24BDB38B0](buf, format, callback, userData, *(_QWORD *)&flags, error);
}

int vprintf(const char *a1, va_list a2)
{
  return MEMORY[0x24BDB0430](a1, a2);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

xmlBufferPtr xmlBufferCreate(void)
{
  return (xmlBufferPtr)MEMORY[0x24BEDE638]();
}

void xmlBufferFree(xmlBufferPtr buf)
{
  MEMORY[0x24BEDE650](buf);
}

xmlNodePtr xmlDocGetRootElement(const xmlDoc *doc)
{
  return (xmlNodePtr)MEMORY[0x24BEDE740](doc);
}

void xmlFreeDoc(xmlDocPtr cur)
{
  MEMORY[0x24BEDE760](cur);
}

void xmlFreeTextWriter(xmlTextWriterPtr writer)
{
  MEMORY[0x24BEDE7B0](writer);
}

xmlTextWriterPtr xmlNewTextWriterMemory(xmlBufferPtr buf, int compression)
{
  return (xmlTextWriterPtr)MEMORY[0x24BEDEA10](buf, *(_QWORD *)&compression);
}

xmlChar *__cdecl xmlNodeGetContent(const xmlNode *cur)
{
  return (xmlChar *)MEMORY[0x24BEDEA50](cur);
}

int xmlNodeIsText(const xmlNode *node)
{
  return MEMORY[0x24BEDEA60](node);
}

xmlDocPtr xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  return (xmlDocPtr)MEMORY[0x24BEDEB00](buffer, *(_QWORD *)&size, URL, encoding, *(_QWORD *)&options);
}

int xmlTextWriterEndDTD(xmlTextWriterPtr writer)
{
  return MEMORY[0x24BEDED30](writer);
}

int xmlTextWriterEndDocument(xmlTextWriterPtr writer)
{
  return MEMORY[0x24BEDED38](writer);
}

int xmlTextWriterEndElement(xmlTextWriterPtr writer)
{
  return MEMORY[0x24BEDED40](writer);
}

int xmlTextWriterSetIndent(xmlTextWriterPtr writer, int indent)
{
  return MEMORY[0x24BEDED60](writer, *(_QWORD *)&indent);
}

int xmlTextWriterSetIndentString(xmlTextWriterPtr writer, const xmlChar *str)
{
  return MEMORY[0x24BEDED68](writer, str);
}

int xmlTextWriterStartDTD(xmlTextWriterPtr writer, const xmlChar *name, const xmlChar *pubid, const xmlChar *sysid)
{
  return MEMORY[0x24BEDED80](writer, name, pubid, sysid);
}

int xmlTextWriterStartDocument(xmlTextWriterPtr writer, const char *version, const char *encoding, const char *standalone)
{
  return MEMORY[0x24BEDED88](writer, version, encoding, standalone);
}

int xmlTextWriterStartElement(xmlTextWriterPtr writer, const xmlChar *name)
{
  return MEMORY[0x24BEDED90](writer, name);
}

int xmlTextWriterWriteAttribute(xmlTextWriterPtr writer, const xmlChar *name, const xmlChar *content)
{
  return MEMORY[0x24BEDEDA8](writer, name, content);
}

int xmlTextWriterWriteComment(xmlTextWriterPtr writer, const xmlChar *content)
{
  return MEMORY[0x24BEDEDC0](writer, content);
}

int xmlTextWriterWriteString(xmlTextWriterPtr writer, const xmlChar *content)
{
  return MEMORY[0x24BEDEDD8](writer, content);
}

